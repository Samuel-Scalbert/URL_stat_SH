Capturing Homomorphism-Closed Decidable Queries
with Existential Rules
Camille Bourgaux, David Carral, Markus Krötzsch, Sebastian Rudolph,

Michaël Thomazo

To cite this version:

Camille Bourgaux, David Carral, Markus Krötzsch, Sebastian Rudolph, Michaël Thomazo. Captur-
ing Homomorphism-Closed Decidable Queries with Existential Rules. KR 2021 - 18th International
Conference on Principles of Knowledge Representation and Reasoning, Nov 2021, Virtual, Vietnam.
pp.141-150, ￿10.24963/kr.2021/14￿. ￿lirmm-03345614￿

HAL Id: lirmm-03345614

https://hal-lirmm.ccsd.cnrs.fr/lirmm-03345614

Submitted on 15 Sep 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Capturing Homomorphism-Closed Decidable Queries with Existential Rules
Camille Bourgaux1 , David Carral2 , Markus Kr¨otzsch3 , Sebastian Rudolph3 , Micha¨el Thomazo1

1 DI ENS, ENS, CNRS, PSL University & Inria, Paris, France
2 LIRMM, Inria, University of Montpellier, CNRS, Montpellier, France
3 Technische Universit¨at Dresden, Dresden, Germany
{camille.bourgaux, david.carral, michael.thomazo}@inria.fr,
{markus.kroetzsch, sebastian.rudolph}@tu-dresden.de

Abstract

Existential rules are a very popular ontology-mediated query
language for which the chase represents a generic computa-
tional approach for query answering. It is straightforward that
existential rule queries exhibiting chase termination are de-
cidable and can only recognize properties that are preserved
under homomorphisms. In this paper, we show the converse:
every decidable query that is closed under homomorphism
can be expressed by an existential rule set for which the stan-
dard chase universally terminates. Membership in this frag-
ment is not decidable, but we show via a diagonalisation ar-
gument that this is unavoidable.

1

Introduction

At the core of contemporary logic-based knowledge repre-
sentation is the concept of querying data sources, often using
elaborate query formalisms that allow for taking background
knowledge into account. The classical decision problem re-
lated to such knowledge-aware querying is Boolean query
entailment. From an abstract point of view, a Boolean query
identiﬁes a class of databases D – those that satisfy the
query, i.e., to which the query “matches”. This view allows
us to deﬁne and investigate properties of (abstract) queries
independently from the syntax used to specify them. Such
properties can be structural (morphisms, closure properties)
or computational (decidability, complexity).

A very popular querying formalism are existential rules,
also referred to as tuple-generating dependencies. It
is
straightforward that the class of databases satisfying some
existential rule query is closed under homomorphisms and
recursively enumerable. Conversely, it was established that
every homomorphism-closed query that is recursively enu-
merable can be expressed using existential rules (Rudolph
and Thomazo 2015). That is, plain existential rules al-
ready realize their full potential; further syntactic extensions
within these boundaries do not enhance expressivity.

For questions related to automated deduction, however, a
more restricted requirement than recursive enumerability is
of central interest: decidability. Therefore, the crucial ques-
tion we tackle in this paper is:
Can we characterize an existential rules fragment capable of
expressing every decidable homomorphism-closed query?
The generic computational paradigm for existential rules,
the chase (Beeri and Vardi 1984), is based on repetitive, for-

ward-chaining rule application, starting from the database.
As this may cause the iterated introduction of new domain
elements, this procedure is not guaranteed to terminate – yet,
termination is a crucial criterion for decidability. The chase
comes in several variants, mainly differing in their (increas-
ingly thorough) mechanisms to prevent unnecessary rule ap-
plications: While the Skolem chase (Marnette 2009) essen-
tially just avoids duplicate rule applications, the standard
(Fagin et al. 2005) and the core chase (Deutsch, Nash, and
Remmel 2008) check for redundancy on a local and global
level, respectively.

The class of existential rule sets with terminating1 Skolem
chase has already been weighed and found wanting: it only
comprises those queries that are already expressible in plain
Datalog – and hence can be evaluated in polynomial time
(Marnette 2009; Kr¨otzsch and Rudolph 2011; Zhang, Zhang,
and You 2015). For the standard-chase-terminating and the
core-chase-terminating existential rules classes, on the other
hand, we only know that the former is contained in the latter
(Grahne and Onet 2018), but little more than that (Kr¨otzsch,
Marx, and Rudolph 2019). In this paper, we clarify the situ-
ation signiﬁcantly by showing the following:
Standard-chase-terminating existential rules capture the
class of all decidable homomorphism-closed queries.

Notably, this implies that standard-chase-terminating and
core-chase-terminating existential rule queries are equally
expressive and no decidable enhancement of this formalism
that preserves homomorphism-closedness (e.g. by allowing
disjunction in rule heads) can be strictly more expressive.

As a downside, the existential rules fragment thus identi-
ﬁed is not even semi-decidable, but we show via a diagonal-
isation argument that this downside is, in fact, unavoidable.
Additional proofs and details are given in the appendix.

2 Preliminaries
Rules We consider ﬁrst-order formulas over countably in-
ﬁnite sets Vars of variables and Preds of predicates, where
each p ∈ Preds has an arity Ar (p) ≥ 0. Lists of variables
are denoted (cid:126)x = x1, . . . , xk and will be treated like sets
when order is not relevant. An atom is an expression p((cid:126)x)
with p ∈ Preds and |(cid:126)x| = Ar (p).

1We always mean universal termination, i.e., for every database.

The fragment of disjunctive existential rules consists of

formulae of the form:

(cid:16)

∀(cid:126)x.

β[(cid:126)x] →

(cid:95)k

i=1

∃(cid:126)yi.ηi[(cid:126)xi, (cid:126)yi]

(cid:17)

,

(1)

where β[(cid:126)x] and ηi[(cid:126)xi, (cid:126)yi] (i = 1, . . . , k) are conjunctions of
atoms with variables (cid:126)x and (cid:126)xi ∪ (cid:126)yi, respectively. We call β
body and (cid:87)k
i=1 ∃(cid:126)yi.ηi head. Bodies can be empty (we then
omit →), but heads must be non-empty. We require that (cid:126)x
and (cid:126)yi (i = 1, . . . , k) are mutually disjoint and that (cid:126)xi ⊆ (cid:126)x
for all i = 1, . . . , k. We single out the fragment of existen-
tial rules by disallowing disjunction, i.e. requiring k = 1,
and Datalog rules by disallowing existential quantiﬁers. We
often omit the universal quantiﬁers from rules and treat con-
junctions of atoms as sets of atoms.

Databases, Interpretations, and Entailment The seman-
tics of formulas is based on logical interpretations, which
we deﬁne as relational structures over a countably inﬁnite
set Nulls of nulls. A schema S is a ﬁnite set of predicates.
An interpretation I over schema S is a set of expressions
p((cid:126)n) with p ∈ S and (cid:126)n a list of nulls of length Ar (p). We
write Nulls(I) for the set of nulls in I. A database is a ﬁnite
interpretation. See also the remarks on this notation below.
A homomorphism h : I1 → I2 between interpretations
I1 and I2 is a mapping h from the nulls in I1 to the nulls in
I2, such that p((cid:126)n) ∈ I1 implies p(h((cid:126)n)) ∈ I2, where h((cid:126)n)
denotes the list of h-values over (cid:126)n. We also write h(I) for
{p(h((cid:126)n)) | p((cid:126)n) ∈ I}.

A substitution σ is a mapping from variables to nulls,
which we extend to lists of variables and formulas as usual.
A rule ρ as in (1) is satisﬁed by interpretation I if every sub-
stitution σ : (cid:126)x → Nulls with σ(β) ⊆ I can be extended to
a substitution σ(cid:48) : (cid:126)x ∪ (cid:126)yi → Nulls for some i ∈ {1, . . . , k}
such that σ(cid:48)(ηi) ⊆ I. Otherwise, if σ(β) ⊆ I but no exten-
sion σ(cid:48) of σ veriﬁes σ(cid:48)(ηi) ⊆ I for some i ∈ {1, . . . , k},
then (cid:104)ρ, σ(cid:105) is applicable to I.

I satisﬁes a set Σ of rules if it satisﬁes every rule in Σ. An
interpretation J is satisﬁed by an interpretation I if there is
a homomorphism h : J → I. I is a model of a rule/rule
set/interpretation/database X if X is satisﬁed by I, writ-
ten I |= X . As usual, we also write X |= Y (“X entails
Y”) if every model of X is a model of Y, where X and Y
might be rules, rule sets, databases, or lists of several such
elements. Note that the semantics of a database D in this
context corresponds to the semantics of a Boolean conjunc-
tive query ∃(cid:126)x. (cid:86){p(xn1, . . . , xn(cid:96)) | p(n1, . . . , n(cid:96)) ∈ D} –
we will therefore not introduce such queries as a separate
notion. Also note that entailment and satisfaction between
interpretations/databases coincide.

Abstract Queries, Expressivity, and Decidability An
(abstract) query Q over a schema S is a set of databases over
S that is closed under isomorphism, i.e., such that whenever
D ∈ Q and D(cid:48) is obtained from D by bijective renaming
of nulls, then D(cid:48) ∈ Q. Q is further closed under homomor-
phisms if, for all D ∈ Q and homomorphisms h : D → D(cid:48),
we have D(cid:48) ∈ Q.

Deﬁnition 1. Let Goal be a nullary predicate. A query Q
over S is expressed by a set Σ of rules if, for every database
D over S, we have D ∈ Q if and only if Σ, D |= Goal.

To discuss decidability of queries, we need to con-
ceive databases as Turing machine inputs over a ﬁxed al-
phabet. A serialisation for a schema S is a word s ∈
({0, 1, (cid:107)} ∪ S)∗ of the form e1 · · · en where n ≥ 0 and
ei = pi(cid:107)wi1(cid:107) · · · (cid:107)wiAr (pi)(cid:107) for wij ∈ {0, 1}+ and pi ∈ S.
Given s of this form and an injection η : {0, 1}+ → Nulls,
let η(s) denote the database {pi(η(wi1), . . . , η(wiAr (pi))) |
1 ≤ i ≤ n}. Then s corresponds to a database D if η(s)
is isomorphic to D; note that this does not depend on the
choice of η.

A query Q with schema S is decidable if the set of all
serialisations for S that correspond to some D ∈ Q is a
decidable language.

Remarks on our Notation Many works consider con-
stants to appear in databases (not just nulls), but complex-
ity and expressivity is usually studied for queries that are
closed under isomorphisms, a.k.a. generic (Abiteboul, Hull,
and Vianu 1995, Ch. 16), and nulls are more natural there.
One can admit ﬁnitely many exceptions (elements that must
not be renamed), but such “constants” can be simulated by
marking them with dedicated unary predicates.

Specifying logical interpretations as sets of “atoms” that
may use nulls is a notational convenience with some side
effects: our interpretations cannot contain elements that do
not stand in any relation, but they can have an empty domain.
Both aspects do not change the notion of logical entailment
on the formulas we consider.

Universal Models and the Chase Entailment of
databases (corresponding to Boolean conjunctive queries)
can be decided by considering only a subset of all models.
Given sets I and K of interpretations, I is universal for K if,
for all K ∈ K, there is I ∈ I and a homomorphism I → K.
Consider a rule set Σ and database D, and let M be the set
of all models of Σ, D. Then I is a universal model set for Σ
and D if I ⊆ M and I is universal for M.
Fact 1. If I is a universal model set for Σ and D then, for
every database C, we have Σ, D |= C iff I |= C for all I ∈ I.

Universal model sets can be computed with the chase al-
gorithm. Here, we consider a variation of the standard (or
restricted) chase for rules with disjunction, introduced by
(Carral, Dragoste, and Kr¨otzsch 2017).
Deﬁnition 2. A chase tree for a rule set Σ and database D
is a (ﬁnite or inﬁnite) tree where each node is labelled by a
database, such that:

1. The root is labelled with D.
2. For every node with label E that has (cid:96) children labelled
C1, . . . , C(cid:96), there is a rule ρ ∈ Σ of the form (1) and a sub-
stitution σ : (cid:126)x → Nulls such that (i) (cid:104)ρ, σ(cid:105) is applicable to
E, (ii) ρ has k = (cid:96) head disjuncts, and (iii) Ci = E ∪σi(ηi)
where σi extends σ by mapping each variable y ∈ (cid:126)yi to a
fresh null.

3. For each rule ρ ∈ Σ and each substitution σ, there is i ≥ 1
such that (cid:104)ρ, σ(cid:105) is not applicable to the label of any node
of depth ≥ i.

The result that corresponds to a chase tree is the set of all
interpretations that can be obtained as the union of all inter-
pretations along a path in the tree.

Condition (3) ensures fair, exhaustive rule application, but
different orders of application can lead to different chase
trees, which can also have different results. Nevertheless, ev-
ery result is semantically correct in the following sense:
Fact 2. Every result of a chase on a rule set Σ and database
D is a universal model set for Σ and D.

The pair (cid:104)Σ, D(cid:105) is chase-terminating if all its chase trees
are ﬁnite – by K¨onig’s Lemma, this is equivalent to all
chase results for (cid:104)Σ, D(cid:105) containing only ﬁnite interpre-
tations; this corresponds to all-strategy termination. Σ is
chase-terminating if (cid:104)Σ, D(cid:105) is chase-terminating for every
database D; this corresponds to universal termination.

Turing Machines We will use (deterministic) Turing ma-
chines (TM), denoted as a tuple M = (cid:104)Q, Γ, δ(cid:105), with states
Q, tape alphabet Γ with blank ∈ Γ, and transition function
δ. M has a distinguished initial state qS ∈ Q, and accept-
ing and rejecting halting states qA, qR ∈ Q. For all states
q ∈ Q \ {qA, qR} and tape symbols a ∈ Γ, there is exactly
one transition (q, a) (cid:55)→ (r, b, D) ∈ δ. We assume that TM
tapes are unbounded to the right but bounded to the left, and
that TMs will never attempt to move left on the ﬁrst position
of the tape (this is w.l.o.g., since one can modify any TM to
insert a marker at the tape start to recognise this case).

3 On the Expressivity of Disjunctive Rules
In this section, we show how to express a homomorphism-
closed, decidable query with a disjunctive rule set. This con-
struction will be the basis for ﬁnding a chase-terminating set
of (deterministic) existential rules. Throughout this section,
Q is a ﬁxed but arbitrary homomorphism-closed query over
signature S, and M = (cid:104)Q, Γ, δ(cid:105) is a TM that decides Q.

To express Q, we specify ﬁve rule sets R1 ⊆ R2 ⊆ R3 ⊆
R4 ⊆ R5 (see Figures 1–6), which will be explained later.
We want to show the following result:
Theorem 3. The set R5 of disjunctive existential rules ex-
presses the query Q.

To show this, we ﬁx an arbitrary database D over S. The-

orem 3 then follows from Fact 1 and the next lemma:
Lemma 4. There is a universal model set M of R5 and D
such that D ∈ Q iff Goal ∈ I for every I ∈ M.

The universal model set M is a complicated structure that
we describe step by step, by specifying ﬁve sets of inter-
pretations – I1, I2, I3, I4, and I5 –, such that (1) Ii is
a universal model set of Ri, D for each 1 ≤ i ≤ 5, (2)
|I1| = |I2| = |I3| = |I4| = |I5|, and (3) for each
1 ≤ i < j ≤ 5 and each I ∈ Ii, there is exactly one J ∈ Ij
with I ⊆ J . Lemma 4 can then be shown using M = I5.

Before dwelling into the details of each rule set and uni-
versal model, we give an overview of the construction: R1

→ ∃y.First(y) ∧ DbDom(y)
→ ∃z.Last(z) ∧ DbDom(z)

p((cid:126)x) → Inp((cid:126)x) ∧ (cid:86)

x∈(cid:126)x DbDom(x)

DbDom(x) → Eq(x, x)
Eq(x, y) → Eq(y, x)
NEq(x, y) → NEq(y, x)
R((cid:126)x) ∧ Eq(xi, y) → R((cid:126)xxi(cid:55)→y)

DbDom(x) ∧ DbDom(y) → Eq(x, y) ∨ NEq(x, y)

LT(x, y) ∧ LT(y, z) → LT(x, z)
First(x) ∧ NEq(x, y) → LT(x, y)
NEq(x, y) ∧ Last(y) → LT(x, y)

NEq(x, y) → LT(x, y) ∨ LT(y, x)
x∈(cid:126)x DbDom(x) → Inp((cid:126)x) ∨ NInp((cid:126)x)

(cid:86)

(2)
(3)
(4)

(5)
(6)
(7)
(8)
(9)
(10)
(11)
(12)
(13)
(14)

Figure 1: The rule set R1, where rules (4) and (14) are instan-
tiated for each p ∈ S, and rules (8) are instantiated for each
R ∈ {First, Last, Eq, NEq, LT} ∪ {Inp, NInp | p ∈ S} and
1 ≤ i ≤ Ar (R), and (cid:126)xxi(cid:55)→y denotes (cid:126)x with xi replaced by y.

First(x) → ∃u.Root(u) ∧ Rep(x, u)

(15)
Rep(x, v) ∧ LT(x, z) → ∃w.Chi(v, w) ∧ Rep(z, w) (16)
Last(x) ∧ Rep(x, u) → Leaf(u)
(17)
Rep(x, u) ∧ Eq(x, y) → Rep(y, u)
(18)

Inp((cid:126)x) ∧ (cid:86)|(cid:126)x|
NInp((cid:126)x) ∧ (cid:86)|(cid:126)x|

i=1Rep(xi, ui) → In(cid:48)
i=1Rep(xi, ui) → NIn(cid:48)

p((cid:126)u)

p((cid:126)u)

(19)

(20)

Figure 2: The rule set R2 contains R1 (see Figure 1) and all above
rules, where (19) and (20) are instantiated for each p ∈ S.

constructs all possible linear orders over the nulls in D, as
well as all possible completions of D with facts built using
these nulls; R2 \ R1 extracts successor relations from the
linear orders; R3 \ R2 associates to nulls representations of
their positions in successor relations; R4 \ R3 encodes all
initial TM conﬁgurations corresponding to some linear or-
der and completion, and R5 \ R4 simulates the run of the
TM on these conﬁgurations.

R1: Linear Order and Database Completion R1 serves
two distinct purposes: (1) predicates First, Last, Eq (“=”),
NEq (“(cid:54)=”), and LT (“<”) encode representations of possible
linear orders over nulls in D (collected in predicate DbDom);
and (2) predicates Inp and NInp for each p ∈ S explicitly
encode positive and negative (absent) facts in D. Both pur-
poses require disjunctive reasoning. Possible models include
representations of strict, total linear orders (1) and the ex-
act database completion (2), but also models for collapsed
orders and inconsistent completions. The latter is not prob-
lematic since we consider homomorphism-closed queries.

We deﬁne the interpretation set I1 on the set ∆ =
Nulls(D) ∪ {uα, uω}, for fresh nulls uα, uω /∈ Nulls(D).
A (partially collapsed) linear order can be represented by

Root(u) → ∃y1, y2.Enc(u, y1, y2) ∧ S0(y1) ∧ Nxt(y1, y2) ∧ S1(y2)

Enc(u, y1, y ) ∧ Chi(u, v) → ∃z1, z .Enc(v, z1, z ) ∧ Cpy+1(y1, y , z1, z )

(21)
(22)

Cpy+1(y1, y2, z1, z ) ∧ S0(y1) ∧ Nxt(y1, y2) → S1(z1) ∧ Nxt(z1, z ) ∧ S1(z )
(23)
Cpy+1(y1, y2, z1, z ) ∧ S1(y1) ∧ Nxt(y1, y2) → ∃z2.S0(z1) ∧ Nxt(z1, z2) ∧ S0(z2) ∧ Nxt(z2, z ) ∧ S1(z ) (24)
(25)

Cpy+1(y1, y , z1, z ) ∧ S0(y1) ∧ Nxt(y1, y2) ∧ Nxt(y2, y3) → ∃z2.Cpy(y2, y , z2, z ) ∧ S1(z1) ∧ Nxt(z1, z2)
Cpy+1(y1, y , z1, z ) ∧ S1(y1) ∧ Nxt(y1, y2) ∧ Nxt(y2, y3) → ∃z2.Cpy+1(y2, y , z2, z ) ∧ S0(z1) ∧ Nxt(z1, z2)
Cpy(y1, y2, z1, z2) ∧ S∗(y1) ∧ Nxt(y1, y2) → S∗(z1) ∧ Nxt(z1, z2) ∧ S1(z2)
Cpy(y1, y , z1, z ) ∧ S∗(y1) ∧ Nxt(y1, y2) ∧ Nxt(y2, y3) → ∃z2.Cpy(y2, y , z2, z ) ∧ S∗(z1) ∧ Nxt(z1, z2)

(26)

(27)
(28)

Figure 3: The rule set R3 contains R2 (Figure 2) and all of the above rules, where (27) and (28) are instantiated for each ∗ ∈ {0, 1}.

an ordered partition (cid:126)T = T1, . . . , Tk (k ≥ 1) of ∆ where
uα ∈ T1 and uω ∈ Tk. Let Ords be the set of all such (cid:126)T ,
and let Compls( (cid:126)T ) be the set of all interpretations with nulls
∆ that are set-minimal among the models of R1 and D, and
that contain the database

{First(u) | u ∈ T1} ∪ {Last(u) | u ∈ Tk} ∪
{Eq(t, u) | 1 ≤ i ≤ k; t, u ∈ Ti} ∪
{LT(t,u), NEq(t,u), NEq(u,t) | 1 ≤ i < j ≤ k; t ∈ Ti; u ∈ Tj}.

By minimality, each I ∈ Compls( (cid:126)T ) contains exactly one
of {Inp((cid:126)t), NInp((cid:126)t)} for every (cid:126)t ⊆ ∆ with |(cid:126)t| = Ar (p).
Lemma 5. I1 = (cid:83)
set of R1 and D.

(cid:126)T ∈Ords Compls( (cid:126)T ) is a universal model

Proof Sketch. We can construct a chase tree for R1 and D
that prioritises the application of rules in the order of their
appearance in Figure 1. The result of that chase K is a ﬁnite
universal model set (Fact 2) and we can show that every K ∈
K is isomorphic to a unique I ∈ I1.

Each set Ii for some 2 ≤ i ≤ 5 is obtained as Ii =
{Int i(I) | I ∈ Ii−1} for a function Int i as deﬁned be-
low. Every I ∈ Ii with 1 ≤ i ≤ 5 contains a unique
interpretation Seed (I) ∈ I1, and there is a unique or-
dered partition Order (I) ∈ Ords such that Seed (I) ∈
Compls(Order (I)).

R2: Representative Tree The purpose of R2 is to extract
successor relations from the transitive linear order LT. Given
an ordered partition Order (I) = T1, . . . , Tk of some model
I of R1, R2 constructs a ﬁnite tree structure – deﬁned using
predicates Root, Chi (“child”), and Leaf – where each path
represents a sub-sequence Tz1 , . . . , Tzp of T1, . . . , Tk with
z1 = 1 and zp = k. Unavoidably, some paths will skip some
Ti, but it sufﬁces for our purposes if one path is complete.
The elements of any set Tj are related to the tree nodes that
represent Tj by a predicate Rep. Moreover, nodes are related
via predicates In(cid:48)
p that reﬂect the relations for Inp
and NInp that hold between the represented elements (in the
database completion of the considered model I of R1).

p and NIn(cid:48)

Given I with |Order (I)| = k as above, let Z be the
set of all words z1 · · · zp ∈ {1, . . . , k}∗ such that z1 = 1
and zi < zi+1 for all i ∈ {1, . . . , p − 1}. Moreover, let

end (z1 · · · zp) := zp. Using fresh nulls {uw | w ∈ Z}, we
deﬁne Tree(I) to be the interpretation

{Root(u1)} ∪ {Chi(uw, uwz) | wz ∈ Z, 2 ≤ z ≤ k} ∪
{Leaf(uw) | w ∈ Z; end (w) = k} ∪
{Rep(x, uw) | w ∈ Z; x ∈ Tend(w)}.

Now Int 2(I) is the least interpretation that contains I and
Tree(I), and that further satisﬁes rules (19) and (20). We
can extend Lemma 5 as follows. The required universal
model set is obtained by any chase that prioritises rule (18).
Lemma 6. I2 = {Int 2(I) | I ∈ I1} is a universal model
set of R2 and D.

R3: Position Binary Encodings The purpose of R3 is to
associate each node in the tree of R2 with a binary encoding
of its distance from the root (the root starts with “distance” 2
for technical reasons). Encodings start at the least signiﬁcant
bit and always end in 1 (i.e., have no leading 0s). To simplify
upcoming steps, encodings take the form of little TM tapes,
represented by a Nxt-connected chain of nulls with unary
predicates S0 and S1 encoding the symbol at each position.
Nodes u relate to the ﬁrst and last null ts and te of their
“tape” through facts Enc(u, ts, te). Facts Cpy(as, ae, bs, be)
are used to create a tape between bs and be that contains
a copy of the information on the tape between as and ae.
Predicate Cpy+1 is analogous, but creates a representation of
the successor of the number that is copied.

Consider a model I of R2 and deﬁne the set of sequences
Z as before. For w ∈ Z of length |w|, and b1 · · · b(cid:96) the binary
representation of |w| + 1, let EncPos(w) be the database

w) | 1 ≤ i ≤ (cid:96)} ∪

w)} ∪ {Sbi(ei
w, e(cid:96)
w) | 2 ≤ i ≤ (cid:96)}.

{Enc(uw, e1
{Nxt(ei−1
w , ei
Let J = I ∪ (cid:83)
w∈Z EncPos(w). We deﬁne Int 3(I) as the
smallest superset of J that satisﬁes all rules in R3 while
including only the nulls in J . Int 3(I) extends J only by
missing Cpy and Cpy+1 relations, which can be inferred by
slightly rewritten rules. For example, rule (22) is satisﬁed
when applying the following rule to J :

Enc(u, y1, y ) ∧ Chi(u, v) ∧ Enc(v, z1, z )

→ Cpy+1(y1, y , z1, z ).

Ldp(u, t, (cid:126)v) ∧ In(cid:48)

p((cid:126)v) → ∃(cid:126)x, y.Sp(t) ∧ Nxt(t, x1) ∧ (cid:86)|(cid:126)v|

LdE(v, xs, xe) ∧ Enc(v, y1, y ) → ∃z1, z .S(cid:107)(xs) ∧ Nxt(xs, z1) ∧ Cpy(y1, y , z1, z ) ∧ Nxt(z , xe) ∧ S(cid:107)(xe)

i=1 LdE(vi, xi, xi+1) ∧ Nxt(x|(cid:126)v|+1, y) ∧ Rdyp(u, y, (cid:126)v) (29)
(30)

Figure 4: The rule set R4 contains R3 (see Figure 3), the rules from Figure 5, and the above rules instantiated for all p ∈ S.

Leaf(u) → ∃t.Ld1(u,t, u) ∧ HdqS (t)
(u, t, (cid:126)v)

Ld(cid:96)(u, t, (cid:126)v) → Ldp(cid:96)
(u, t, (cid:126)v) → Ldp(cid:96)
(u, t, (cid:126)v) → Rdy(cid:96)(u, t, (cid:126)v)

Rdyp(cid:96)
Rdyp(cid:96)

j+1

1

j

(u, t, (cid:126)v)

¯n

Rdy(cid:96)(u, t, (cid:126)v) ∧ (cid:86)(cid:96)

i=k+1 Root(vi) ∧ Chi(w, vk)
→ Ld(cid:96)(u, t,v1, ···, vk−1, w, u, ···, u)

(31)
(32)

(33)

(34)

(35)

Rdy(cid:96)(u, t, (cid:126)v) ∧ (cid:86)(cid:96)
Rdy ¯m(u, t, (cid:126)v) ∧ (cid:86) ¯m

i=1 Root(vi) → Ld(cid:96)+1(u, t, u, ···, u) (36)
i=1 Root(vi) → S (t) ∧ End(t)
(37)

Ldp(u, t, (cid:126)v) ∧ NIn(cid:48)

p((cid:126)v) → Rdyp(u, t, (cid:126)v)

(38)

Figure 5: Some rules of R4, to be instantiated for all 1 ≤ j ≤ ¯n−1,
1 ≤ k ≤ (cid:96) ≤ ¯m, and p ∈ S.

All other rules can be rewritten analogously, since every ex-
istentially quantiﬁed variable is used in unique ways with
predicates other than Cpy and Cpy+1.

For every I ∈ I2, we show that Int 3(I) is isomorphic
to a result of the chase on R3 and I. The next result then
follows from Lemma 6.
Lemma 7. I3 = {Int 3(I) | I ∈ I2} is a universal model
set of R3 and D.

R4: Initial TM Conﬁguration For each leaf in the tree of
completions, R4 creates the representation of an initial TM
conﬁguration. The tape is again represented by a Nxt-chain,
using further unary predicates S(cid:107), S , and Sp (for all p ∈ S)
for additional tape symbols. HdqS marks the TM’s starting
position and initial state qS, and End the end of the tape.

Let ¯m be the maximal arity of predicates in S. We require
that there is some ¯n > 0 such that S contains exactly ¯n
predicates pi
¯n of arity i, for every 1 ≤ i ≤ ¯m. This is
without loss of generality, except for the exclusion of nullary
predicates. Our results do not depend on this restriction, but
it helps to simplify the presentation of our main ideas.

1, . . . , pi

To serialise the data as a tape, we iterate over all predicate
arities (cid:96) = 1, . . . , ¯m and over all lists (cid:126)v of tree nodes with
length (cid:96). In this process, Ld(cid:96)(u, t, (cid:126)v) expresses that, while
encoding the leaf u, after constructing the tape until position
t, we continue serialising (cid:96)-ary predicate data for arguments
(cid:126)v. Analogously, Rdy(cid:96)(u, t, (cid:126)v) means that this was completed
at tape position t. Similar predicates Ldp and Rdyp are used
to consider a speciﬁc predicate p ∈ S during this process.
The rules in Figure 5 start the serialisation (31), proceed over
all predicates (32)–(34), iterate over parameter vectors (35)
and arities (36), and ﬁnally end the tape (37).

Absent facts do not need to be serialised (38), while
present facts can be treated by copying the encodings for

each of their parameters (29) and (30). In the latter, LdE
states that a speciﬁc argument is serialised between two
given tape positions.

The resulting TM tapes serialise facts In(cid:48)

p((cid:126)u) as intro-
duced by R2, i.e., where (cid:126)u are nodes in the representative
tree. Given a model I ∈ I3 with some Leaf(uw) ∈ I, let
branch(uw) be the set of all nodes uw(cid:48) on the branch of
uw, i.e. all nulls uw(cid:48) where w(cid:48) is a preﬁx of w. Elements
of branch(uw) are totally ordered by setting uw1 ≺ uw2
if |w1| > |w2|. Predicates are totally ordered by setting
pa
i ≺ pb
j if either a < b, or both a = b and i < j. We
can then order facts as p((cid:126)u) ≺ q((cid:126)v) if (cid:126)u, (cid:126)v ⊆ branch(uw)
and (cid:104)p, (cid:126)u(cid:105) is lexicographically before (cid:104)q, (cid:126)v(cid:105).
Now let branchDb(I, uw) = {p((cid:126)u) | In(cid:48)

p((cid:126)u) ∈ I, (cid:126)u ⊆
branch(uw)} denote the set of all facts on the branch with
leaf uw, and let branchTape(I, uw) denote the TM tape
serialisation (as deﬁned in Section 2) of branchDb(I, uw)
according to the total order ≺ and representing each node
uw by the binary representation of |w| + 1 as before. Given
S = branchTape(I, uw), let startConf (I, uw) be the fol-
lowing interpretation:

)} ∪

w), End(t|S|+1

{Ld1(uw, t1
w, uw), HdqS (t1
w
w , tj
{Nxt(tj−1
w) | 2 ≤ j ≤ |S| + 1} ∪
{Sa(tj
w) | 1 ≤ j ≤ |S|, a = S[j]} ∪ {S (t|S|+1
Let J be the extension of I with startConf (I, uw) for ev-
ery Leaf(uw) ∈ I. We deﬁne Int 4(I) to be the smallest
superset of J that satisﬁes all rules in R4 while including
only the nulls in J . As in the case of Int 3, the missing re-
lations can easily be inferred using the original rules or, for
(29) and (30), with simple rewritings thereof.
Lemma 8. I4 = {Int 4(I) | I ∈ I3} is a universal model
set of R4 and D.

)}.

w

R5: TM Run The purpose of R5 is to simulate the run of
the deterministic TM (cid:104)Q, Γ, δ(cid:105) on each of the initial tapes
created by R4. We continue to use predicate Nxt for neigh-
bouring tape cells (augmented with its transitive closure
Nxt+), Sb to encode tape symbols b ∈ Γ, and Hdq to encode
head position and current state q ∈ Q. Predicate Stp con-
nects tape cells in each conﬁguration to the corresponding
tape cells in the next conﬁguration (provided the TM per-
forms another step). The rules in Figure 6 are a standard TM
encoding, with the slight exception of rule (43), which adds
a new blank tape cell in each step (even if not used by the
TM). Our rules use the assumptions on TMs in Section 2.

Consider some I ∈ I4. It is easy and only mildly la-
borious to deﬁne interpretations Run(uw) that represent
all successor conﬁgurations of the starting conﬁguration
startConf (I, uw), appropriately connected with Stp and

(39)

(40)

HdqA (x) → Goal
Nxt(x, y) → Nxt+(x, y)
Nxt+(x, y) ∧ Nxt+(y, z) → Nxt+(x, z)
Nxt(x, y) ∧ Stp(x, z) ∧ Stp(y, w) → Nxt(z, w)

(41)
(42)
End(x) ∧ Stp(x, z) → ∃v.Nxt(z, v) ∧ S (v) ∧ End(v) (43)
Hdq(x) ∧ Sa(x) → ∃z.Stp(x, z) ∧ Sb(z) (44)
Hdq(x) ∧ Nxt+(x, y) ∧ Sc(y) → ∃z.Stp(y, z) ∧ Sc(z) (45)
Hdq(x) ∧ Nxt+(y, x) ∧ Sc(y) → ∃z.Stp(y, z) ∧ Sc(z) (46)
Hdq(x) ∧ Sa(x) ∧ Stp(x, z) ∧ Nxt(z, w) → Hdr(w) (47)
Hdq(x) ∧ Sa(x) ∧ Stp(x, z) ∧ Nxt(w, z) → Hdr(w) (48)

Figure 6: The rule set R5 contains R4 (see Figure 4) and the
above rules, where we instantiate rules (44)–(46) for all transitions
(q, a) (cid:55)→ (r, b, X) ∈ δ and c ∈ Γ; rule (47) for all (q, a) (cid:55)→
(r, b, +1) ∈ δ; and rule (48) for all (q, a) (cid:55)→ (r, b, −1) ∈ δ.

the transitive closure Nxt+. Moreover, let J be the extension
of I with all Nxt+ required to satisfy (40) and (41) (note that
Nxt also occurs in encodings from R3). We deﬁne Int 5(I)
as the union of J with the interpretations Run(uw) for all
uw with Leaf(uw) ∈ I.
Lemma 9. I5 = {Int 5(I) | I ∈ I4} is a universal model
set of R5 and D.

Proving Lemma 4 To complete the proof of Lemma 4,
we set M = I5. For I ∈ M, let Db(I) = {p((cid:126)t) | Inp((cid:126)t) ∈
I} denote the completed database created by R1. Due to
rule (4) in Figure 1, there is a homomorphism D → Db(I).
Moreover, the representation tree constructed for I by R2
has a branch that is maximal, i.e., has |Order (I)| nodes;
this branch has a leaf uw with |w| = |Order (I)|. We obtain
a homomorphism Db(I) → branchDb(I, uw). Lemma 4
now follows from Lemma 9 and Lemmas 11 and 10 below.

Lemma 10. If D ∈ Q, then Goal ∈ I for each I ∈ M.

Proof. As shown above, there is a homomorphism D →
branchDb(I, uw) for the node uw where |w| = |Order (I)|.
Since Q is closed under homomorphisms, D ∈ Q implies
branchDb(I, uw) ∈ Q. By the correctness of our TM sim-
ulation, we obtain Goal ∈ I.

Lemma 11. If D /∈ Q, then Goal /∈ I for some I ∈ M.

Proof. Consider some I ∈ M such that Db(I) = D and
NEq(t, u) ∈ I for each t, u ∈ Nulls(D) with t (cid:54)= u. Let
uw denote the leaf node with |w| = |Order (I)| as be-
fore. Then branchDb(I, uw) is isomorphic to Db(I) = D.
By the correctness of our TM simulation, Goal is not de-
rived from this maximal branch. Moreover, for all other leaf
nodes uv with Leaf(uv) ∈ I, there is a homomorphism
branchDb(I, uv) → branchDb(I, uw). Since Q is closed
under homomorphisms, the TM does not accept any such
branchDb(I, uv), so Goal /∈ I.

4 Ensuring Chase Termination
While the rules in Section 3 are semantically correct, the
disjunctive chase may not terminate on them. Many known
fragments of existential rules can guarantee chase termina-
tion, including for expressive cases where termination might
be exponential (Carral et al. 2019), but they are not applica-
ble to our case, since the runtime of TMs that decide a query
can in general not be bounded by any elementary function.
Indeed, we rely on the TM to stop “naturally”, by virtue of
being a decider. Nevertheless, our rules lead to inﬁnite chase
trees, e.g., if the disjunctive guessing of LT leads to a cycle,
which enables rule (16) to create an inﬁnite path in the rep-
resentation tree. We will now show that this can be avoided:
Theorem 12. Every homomorphism-closed decidable query
is expressed by a set of disjunctive rules that is chase-
terminating for all databases over the schema of the query.

To show this, we reﬁne and generalise the “emergency
brake” technique of Kr¨otzsch, Marx, and Rudolph (2019),
and re-formulate it as a general rule set transformation. This
not only yields a generic method that is of independent in-
terest, but it also allows us to address potential termination
problems in our prior modelling.
Deﬁnition 3. Consider a rule set Σ and a nullary predicate
Halt that does not occur in Σ. For every predicate p in Σ, let
ˆp be a fresh predicate of the same arity, and, for any formula
ψ, let ˆψ be ψ with all predicates p replaced by ˆp. Now the
set brake(Σ, Halt) consists of the following rules:

Halt ∧ Brake(x) → Real(x)
x∈(cid:126)x Real(x) → p((cid:126)x)

ˆp((cid:126)x) ∧ (cid:86)

→ ∃v.Brake(v)

(49)
(50)
for all p in Σ (51)

For every rule ρ : β[(cid:126)x] → (cid:87)k
i=1 ∃(cid:126)yi.ηi[(cid:126)xi, (cid:126)yi]:
(cid:0)Bi
ρ((cid:126)xi) ∧ ˆηi[ (cid:126)xi, (cid:126)yi (cid:55)→ v] ∧
Real(x)(cid:1)
(cid:86)

β[(cid:126)x] ∧ Brake(v) → (cid:87)k

i=1

x∈(cid:126)xi

(52)

ρ((cid:126)xi) → ∃(cid:126)yi.ˆηi[ (cid:126)xi, (cid:126)yi] ∧ (cid:86)
Bi

y∈(cid:126)yi

Real(y)

(53)

where ˆηi[ (cid:126)xi, (cid:126)yi (cid:55)→ v] is ˆηi with each variable y ∈ (cid:126)yi replaced
by v, and Brake, Real, and all Bi
ρ are fresh predicates with
arities as indicated.

Note that brake(Σ, Halt) does not deﬁne rules to derive
Halt, and indeed the transformation largely preserves the
models of Σ in the following sense:
Lemma 13. Consider a rule set Σ and database D
over predicates that occur in Σ. For every model I of
brake(Σ, Halt) and D, the set I − = {p((cid:126)n) | p((cid:126)n) ∈
I, p occurs in Σ} is a model of Σ and D, and every model
J of Σ and D is of this form.

Proof. Consider a rule ρ ∈ Σ as in Deﬁnition 3, and let σ
be a substitution such that σ(β) ⊆ I −. Then we can apply
rules (52), (53), and ﬁnally (51) to derive σ(cid:48)(ηi) ⊆ I − for a
suitable extension σ(cid:48) of σ. Hence I − |= Σ.

Conversely, let J |= Σ. A model I of brake(Σ, Halt)
can be found by adding, for each matching body σ(β) ⊆ J

of rule ρ, an atom σ(Bi
ρ((cid:126)xi)) for some i such that σ(cid:48)(ηi) ⊆ J
for an extension σ(cid:48) of σ. To obtain the required model I of
brake(Σ, Halt), it remains to add facts Brake(b) for a fresh
null b, σ(ˆηi[ (cid:126)xi, (cid:126)yi (cid:55)→ b]) as in (52) for every σ(Bi
ρ((cid:126)xi)) ∈ I,
and Real(n) for every p((cid:126)n) ∈ J and n ∈ (cid:126)n.

For brake(Σ, Halt) to be useful, we need to add rules
that can “pull the brake” by deriving Halt. Doing so stops
the chase in the following sense:
Lemma 14. Consider a rule set Σ, a database D over pred-
icates that occur in Σ, and a set Π of rules of the form
β → Halt where β only uses predicates in Σ. If I is the
label of a node in a chase tree for Σ ∪ Π and D such that
Halt ∈ I, then the tree starting at the node of I is ﬁnite.

Proof. Since Halt ∈ I, there is a substitution σ such
that (cid:104)ρ(50), σ(cid:105) is applicable (for ρ(50) in (50)). By fairness,
Real(σ(x)) will be derived at some depth of the tree. From
this depth on, no rule of form (53) is applicable: given
Real(σ(x)), the head of rules of form (52) already satisﬁes
the head of the rule (53) that could be applied to a newly de-
rived atom for Bi
ρ. Rules other than (53) do not contain exis-
tential quantiﬁers thus can only be applied a ﬁnite number of
times before the chase on this part of the tree terminates.

If Halt is derived,

the semantic correspondence of
Lemma 13 is weakened, but sufﬁces to preserve entailments:
Lemma 15. Consider Σ, D, and Π as in Lemma 14. For
every model I of brake(Σ, Halt) ∪ Π and D, I − (as in
Lemma 13) is a model of Σ and D.

Proof. This is immediate from Lemma 13 and the fact that
every model of brake(Σ, Halt) ∪ Π and D is also a model
of brake(Σ, Halt) and D.

Having established the key properties of the emergency
brake construction, we can now apply it to show Theo-
rem 12. Given the rule set R5 as deﬁned for a query Q in
Section 3, let R6 denote the extension of brake(R5, Halt)
with the following rules:

Inp((cid:126)x) ∧ NInp((cid:126)x) → Halt
LT(x, x) → Halt
Last(x) ∧ LT(x, y) → Halt
LT(x, y) ∧ First(y) → Halt

(54)
(55)
(56)
(57)

Lemma 16. R6 expresses the query Q.

Proof. For a database D over S, let M be the universal
model set constructed in Section 3. If D ∈ Q, then R5, D |=
Goal by Theorem 3. Then R6, D |= Goal since any model
of R6 and D must contain Goal by Lemma 15.

Conversely, if D /∈ Q, then there is U ∈ M with Goal /∈
U. By Lemma 13, there is a model I of brake(R5, Halt)
with I − = U, and hence Goal /∈ I. By construction of M,
none of the rules (54)–(57) applies to U, and hence I is also
a model of R6, i.e., R6, D (cid:54)|= Goal.

Lemma 17. R6 is chase-terminating for all databases over
the schema S of the query Q.

Proof. Consider a chase over R6 and input database D.
Chase branches where Halt is eventually part of a node la-
bel terminate by Lemma 14. Let b denote any branch of the
chase where Halt is not derived, and let I be the union of
all node labels on that branch. We want to show that I (and
hence b) is ﬁnite.

By Lemma 13, I |= R1. Moreover, since Halt /∈ I, rules
(54)–(57) are not applicable to I. Both properties together
sufﬁce to show that the set IR1 = {p((cid:126)n) ∈ I | p is a predi-
cate in R1} is an element of I1 deﬁned in Section 3.

Since the predicates in rule bodies of R1 do not occur
in any rule head in R5 \ R1, we can assume without loss
of generality (and without affecting chase termination), that
the corresponding rules of brake(R1, Halt) ⊆ R6 have
been applied ﬁrst. This shows that I is equal to the result
of a chase with non-disjunctive rules R6 \ brake(R1, Halt)
on a database IR1 ∈ I1. The claim follows by noting that
any such chase must terminate: this was shown in Section 3,
where we described a deterministic process of deﬁning the
elements in the universal model set I5 from those in I1.
Each steps in this construction is fully determined and in-
troduces isomorphic sets of nulls irrespectively of the or-
der of rule applications. The only exception are applica-
tion of rules (15), (16), and (18). For example, given facts
First(n1), First(n2), and Eq(n1, n2), the standard model
of Section 3 contains one fact Root(u1) with Rep(n1, u1)
and Rep(n2, u1), which can be obtained using (15) (on n1)
and (18). If we apply (15) to both n1 and n2 before apply-
ing (18), we obtain two distinct Root(u1) and Root(u(cid:48)
1).
Similar variations can occur with other tree nodes if (16) is
applied before (18). If is easy to see that this does not en-
danger termination, but merely leads to several isomorphic
paths in the representation tree.

Together, Lemmas 16 and 17 show Theorem 12.

5 Removing Disjunctions

Our main result is that any decidable homomorphism-closed
query is expressible by a chase-terminating existential rule
set. To conclude the proof of this statement, we remove the
disjunction from the rule set R6 of Section 4. We present
this as a general technique of expressing disjunctive Datalog
using existential rules, which is also of independent interest.
For a rule set Σ, the input schema Sin(Σ) is the set of all
predicates in Σ that do not occur in any rule head. We focus
on rule sets that can be split into a disjunctive part and an
existential part, such that it is admissible to completely apply
the disjunctive rules ﬁrst, and the existential ones afterwards:

Deﬁnition 4. A split of a set Σ of disjunctive existential
rules consists of a set Σ1 of disjunctive Datalog rules and a
set Σ2 of existential rules, such that Σ = Σ1 ∪ Σ2 and:

For every database D over Sin(Σ), and for every chase
result M over (cid:104)Σ, D(cid:105), there is a chase result M1 over
(cid:104)Σ1, D(cid:105), such that M = {CI | I ∈ M1} where each
CI is the (unique) interpretation resulting from some
chase over (cid:104)Σ2, I(cid:105).

→ ∃w.Init(w) ∧ Done(w) ∧ Empty(w)

Done(w) ∧ Init(w) ∧ p((cid:126)x) → ∃w(cid:48).Insp((cid:126)x, w, w(cid:48)) ∧ Subs(w(cid:48), w(cid:48)) ∧ Init(w(cid:48))
p((cid:126)x)∈β Insp((cid:126)x, w, w) → ∃w1.Insp1( (cid:126)x1, w, w1) ∧ Subs(w1, w1)
p((cid:126)x)∈β Insp((cid:126)x, w, w) → ∃w2.Insp2( (cid:126)x2, w, w2) ∧ Subs(w2, w2)

Done(w) ∧ (cid:86)
Done(w) ∧ (cid:86)
Insp((cid:126)x, w0, w1) ∧ Subs(w1, w2) → Insp((cid:126)x, w2, w2) ∧ p(cid:48)((cid:126)x, w2) ∧ Subs(w0, w2)

Empty(w) ∧ Subs(w, w(cid:48)) → Done(w(cid:48))

(58)

(59)
(60)

(61)

(62)

(63)

Figure 7: The rule set Σ(cid:48)

1, where we instantiate (59) and (62) for all p ∈ Preds in Σ1∪Σ2, and (60) and (61) for all β → p1( (cid:126)x1)∨p2( (cid:126)x2) ∈ Σ1.

Done(w) ∧ (cid:86)

p((cid:126)x)∈β p(cid:48)((cid:126)x, w) → ∃(cid:126)z. (cid:86)

q((cid:126)y)∈η q(cid:48)((cid:126)y, w)

(64)

Figure 8: The rule set Σ(cid:48)
∃(cid:126)z.η ∈ Σ2.

2, where we instantiate (64) for all β →

Goal(cid:48)(w) → Acc(w)

(65)

Insp1((cid:126)x1, w, w1) ∧ Acc(w1) ∧
Insp2((cid:126)x2, w, w2) ∧ Acc(w2) ∧

(cid:86)

p((cid:126)x)∈β Insp((cid:126)x, w, w) → Acc(w)
Init(w) ∧ Acc(w) → Goal

(66)

(67)

Figure 9: The rule set Σ(cid:48)
β → p1( (cid:126)x1) ∨ p2( (cid:126)x2) ∈ Σ1

3, where (66) is instantiated for all rules

Lemma 18. Consider a rule set Σ with split (cid:104)Σ1, Σ2(cid:105). There
is a set Σ(cid:48) of existential rules, such that, for every database
D over Sin(Σ), we have:
1. D, Σ |= Goal iff D, Σ(cid:48) |= Goal, and
2. if (cid:104)Σ2, D2(cid:105) is chase-terminating for every database D2
over Sin(Σ2), then (cid:104)Σ(cid:48), D(cid:105) is also chase-terminating.
To construct this set Σ(cid:48), we assume w.l.o.g. that all dis-
junctive rules have exactly two disjuncts in the head. We
deﬁne Σ(cid:48) as the union of sets Σ(cid:48)
3 as shown in
Figures 7, 8 and 9, which we explain below.

2 and Σ(cid:48)

1, Σ(cid:48)

Σ(cid:48)

1 uses a technique for modelling sets with chase-
terminating existential rules (Kr¨otzsch, Marx, and Rudolph
2019, Fig. 2). We adapt this to sets of ground atoms, called
worlds and denoted by variables w in the ﬁgures. Facts
Insp((cid:126)t, w, w(cid:48)) express that world w(cid:48) is obtained by adding
p((cid:126)t) to world w. In particular, Insp((cid:126)t, w, w) states that p((cid:126)t)
is in w, and we deﬁne world(w) = {p((cid:126)a) | Insp((cid:126)a, w, w) ∈
I} for any interpretation I. Worlds are created by adding
database facts (59) or by applying rules to existing worlds
(60)–(61). Worlds containing only database facts are marked
with Init. Predicate Subs deﬁnes the subset relation on
worlds. Rules (62)–(63) copy all prior facts to a new world
before marking it Done.
Proposition 19. Σ(cid:48)
1 is chase-terminating and for every D
over Sin(Σ), the (unique) interpretation I resulting from
some chase over Σ(cid:48)
1 and D is such that:
• if p((cid:126)a) ∈ D and Done(w) ∈ I, there exists w(cid:48) such that
Insp((cid:126)a, w, w(cid:48)) ∈ I and world(w(cid:48)) = world(w) ∪ {p((cid:126)a)};

• if ρ ∈ Σ1

is applicable to world(w), creating
p1((cid:126)a) or p2((cid:126)b),
there exists w1 and w2 such that
{Insp1 ((cid:126)a, w, w1), Insp2 ((cid:126)b, w, w2)} ⊆ I, world(w1) =
world(w)∪{p1((cid:126)a)} and world(w2) = world(w)∪{p2((cid:126)b)}.
Note that we cannot distinguish worlds that are not con-
taining all database facts, and that some worlds may contain
more facts than needed to satisfy all disjunctive heads.

Σ(cid:48)

2 now simulates the application of rules from Σ2 in any
of the worlds. Computations relative to different worlds are
independent from each other. Finally, Σ(cid:48)
3 aggregates results
from all worlds: a world is accepting (Acc) if either Goal
was derived locally (65) or it has two successor worlds for a
disjunctive rule that are both accepting (66). Goal is a con-
sequence if any initial world is accepting (67). This ﬁnishes
the construction of Σ(cid:48) as the main ingredient for proving
Lemma 18.

Finally, we

Intuitively, a possible split

can apply Lemma 18 to R6

=
brake(R5, Halt) ∪ Π from Section 4, where Π de-
notes rules (54)–(57).
is
brake(R1, Halt) and brake(R5 \ R1, Halt) ∪ Π. Formally,
however, brake(R1, Halt) is not disjunctive Datalog due to
existential rules (2), (3), and (49). However, our result easily
extends to such rules with empty body: we can just add them
to Σ(cid:48)
1 and treat their inferences like facts from the initial
database. The other properties of Deﬁnition 4 are easy to
verify. The fact that both rule sets have some common rules,
such as (50), is no concern. Finally, it remains to argue
termination for Σ2 as required for item (2) in Lemma 18.
This is slightly stronger than Lemma 17 since we must
also consider databases that use some inferred predicates of
R1. However, the proof of Lemma 17 and the emergency
brake technique in general served the main purpose of
safeguarding against problematic structures among the
inferred predicates of R1, and it is not hard to see that this
already showed what we require here. Combining all of our
insights, we ﬁnally obtain:

Theorem 20. Chase-terminating existential rules capture
the class of all decidable homomorphism-closed queries.

6 Limitations of Semi-Decidable Languages
A query language F over a schema S is a function from
a set L to 2DS , where DS is the set of all databases over
schema S. We say that F is semi-decidable if membership to
L is semi-decidable, and that its query answering problem is
decidable if there exists a TM MF that takes as input some

(l, D) ∈ (L × DS ) and decides whether D ∈ F(l).

The set of chase-terminating existential rule sets is a query
language that is not semi-decidable (Grahne and Onet 2018)
and for which the query answering problem is decidable (by
running the chase). In fact, we show that one cannot ﬁnd a
semi-decidable query language with similar properties.
Theorem 21. There are no semi-decidable query languages
that (i) express all decidable, homomorphism-closed queries
and (ii) for which query answering is decidable.

To show this result, we deﬁne a set M of TMs (cf. Deﬁ-
nition 5), show that M can be enumerated up to equivalence
if there is a semi-decidable language that satisﬁes (i) and
(ii) above (cf. Lemma 22), and ﬁnally prove that the conse-
quence of this implication does not hold (cf. Lemma 23).
Deﬁnition 5. Consider the set M of all TMs M such that:
(i) The TM M halts on all inputs. (ii) If M accepts some
word w, then w corresponds to a database over schema
{ed}. (iii) Consider some words w and v that correspond
to some D and E in D{ed}, respectively. If M accepts w and
there is a homomorphism h : D → E, then M accepts v.

Intuitively, M is the set of all deciders that solve

homomorphism-closed queries over databases in D{ed}.
Lemma 22. If there is a semi-decidable query language F
that satisﬁes (i) and (ii) in Theorem 21, then M is enumer-
able up to equivalence.

Proof. If there is a language such as F, then there is an enu-
merator P for L that prints out a sequence l1, l2, . . . and a
decider MF that can be used to check if D ∈ F(l) for each
(l, D) ∈ (L×D{ed}). For each i ≥ 1, let Mi be the TM that,
on input w, performs the following computation: if w corre-
sponds to a database D ∈ D{ed} and MF accepts (li, D),
then accept; otherwise, reject. By modifying P we can de-
ﬁne an enumerator that prints out the sequence M1, M2, . . .,
which contains M up to equivalence.

Lemma 23. The set M is not enumerable up to equivalence.

Proof Sketch. Assume that there is an enumerator that out-
puts a sequence M1, M2, . . . that includes M up to equiv-
alence. We obtain a contradiction by deﬁning a sequence
D1, D2, . . . of databases and a TM Md ∈ M that diago-
nalises over M1, M2, . . . and D1, D2, . . . Namely, for each
i ≥ 1, let Di = {ed(u1, u2), . . . , ed(upi+1, u1)} where
pi+1 is the (i+1)-th prime. Moreover, Md is the TM that, on
input w, performs the computation: (1) Reject if w does not
correspond to some D ∈ D{ed}. (2) Reject if D can be hom-
embedded into a path over ed. (3) Accept if ed(u, u) ∈ D
for some null u. (4) If there is some i ≥ 1 such that there are
less nulls in Di than in D, the TM Mi accepts some seriali-
sation that corresponds to Di, and there is a homomorphism
h : D → Di; then reject. Otherwise, accept.

7 Discussion and Conclusion
In this paper, we have established a characterization of
all decidable homomorphism-closed Boolean queries. We
showed that these are exactly the chase-terminating existen-
tial rule queries, that is, queries that can be expressed by a

set of (non-disjunctive) existential rules for which the stan-
dard chase universally terminates irrespective of the order of
rule applications (as long as it is fair).

By its nature, our result immediately shows that various
extensions of our framework do not increase its expressivity:

Theorem 24. Chase-terminating existential rule queries
have the same expressivity as

1. existential rule queries with guaranteed existence of some

ﬁnite chase tree (for every database),

2. existential rule queries for which the chase terminates ac-
cording to some fair strategy (such as datalog-ﬁrst),

3. core-chase-terminating existential rule queries,
4. disjunctive chase-terminating existential rule queries.

Proof. (3) Standard-chase termination implies core-chase
termination. On the other hand, core chase termination im-
plies decidability and thus our result applies. (1) and (2)
Standard-chase termination implies these weaker form of
guarantees, which themselve imply core chase termination.
(4) Obviously, every (non-disjunctive) existential rule set is
a special case of a disjunctive one and for this special case,
disjunctive chase termination coincides with termination of
the (non-disjunctive) standard chase. On the other hand, dis-
junctive existential rule queries are also closed under homo-
morphisms, and disjunctive universal chase termination ob-
viously implies decidability. So our result applies.

However, the applicability of our result does not stop at
(syntactic) extensions of our framework, as it applies to ar-
bitrary query languages and querying formalisms of differ-
ent types. In particular we would like to stress the relation-
ship to the very comprehensive existential rules fragment of
bounded treewidth sets (bts) of rules (Baget et al. 2011a) that
is not chase-terminating and encompasses a plethora of well-
known existential rule fragments with decidable query en-
tailment, including guarded (Cal`ı, Gottlob, and Kifer 2008),
frontier-guarded (Baget et al. 2011a), and glut-guarded exis-
tential rules (Kr¨otzsch and Rudolph 2011), as well as greedy
bts (Baget et al. 2011b):

Theorem 25. Let Σ be a bounded-treewidth set of rules and
Q a conjunctive query. There is a chase-terminating set ΣQ
of existential rules such that D, Σ |= Q iff D, ΣQ |= Goal.
While possibly surprising, this is a straightforward conse-
quence of decidability of conjunctive query entailment from
bts and of homomorphism-closedness of existential rule
queries in general. Note, however, that every Q would give
rise to a different ΣQ. In fact, asking for a “uniform” chase-
terminating existential rules set Σ(cid:48) satisfying D, Σ(cid:48) |= Q iff
D, Σ |= Q would change the game (Zhang, Zhang, and You
2015). Such a set will not exist in all cases.

While our result addresses many of the open questions
regarding expressivity of the terminating chase (Kr¨otzsch,
Marx, and Rudolph 2019) an important avenue for future
work is to investigate potential differences when it comes to
the corresponding computational complexities. We deem it
likely that not all of the discussed chase variants give rise to
worst-case optimal computations.

Proc. 28th Symposium on Principles of Database Systems
(PODS’09), 13–22. ACM.
Rudolph, S., and Thomazo, M. 2015. Characterization of
the expressivity of existential rule queries. In Yang, Q., and
Wooldridge, M., eds., Proc. 24th Int. Joint Conf. on Artiﬁcial
Intelligence (IJCAI’15), 3193–3199. AAAI Press.
Zhang, H.; Zhang, Y.; and You, J. 2015. Existential rule
languages with ﬁnite chase: Complexity and expressiveness.
In Bonet, B., and Koenig, S., eds., Proc. 29th AAAI Conf. on
Artiﬁcial Intelligence (AAAI’15). AAAI Press.

Acknowledgements This work is partly supported by
DFG in project number 389792660 (TRR 248, Center for
Perspicuous Systems), by BMBF in the Center for Scal-
able Data Analytics and Artiﬁcial Intelligence (ScaDS.AI),
by the Center for Advancing Electronics Dresden (cfaed),
by the ERC Consolidator Grant DeciGUT (project number
771779), and by the ANR project CQFD (ANR-18-CE23-
0003).

References
Abiteboul, S.; Hull, R.; and Vianu, V. 1995. Foundations of
Databases. Addison-Wesley.
Baget, J.; Lecl`ere, M.; Mugnier, M.; and Salvat, E. 2011a.
On rules with existential variables: Walking the decidability
line. Artif. Intell. 175(9-10):1620–1654.
Baget, J.; Mugnier, M.; Rudolph, S.; and Thomazo, M.
2011b. Walking the complexity lines for generalized
guarded existential rules. In Walsh, T., ed., Proc. 22nd Int.
Joint Conf. on Artiﬁcial Intelligence (IJCAI’11), 712–717.
AAAI Press/IJCAI.
Beeri, C., and Vardi, M. Y. 1984. A proof procedure for data
dependencies. J. ACM 31(4):718–741.
Cal`ı, A.; Gottlob, G.; and Kifer, M. 2008. Taming the in-
ﬁnite chase: Query answering under expressive relational
In Brewka, G., and Lang, J., eds., Proc. 11th
constraints.
Int. Conf. on Knowledge Representation and Reasoning
(KR’08), 70–80. AAAI Press.
Carral, D.; Dragoste, I.; Kr¨otzsch, M.; and Lewe, C. 2019.
Chasing sets: How to use existential rules for expressive rea-
soning. In Kraus, S., ed., Proc. 28th Int. Joint Conf. on Arti-
ﬁcial Intelligence, IJCAI’19, 1624–1631. ijcai.org.
Carral, D.; Dragoste, I.; and Kr¨otzsch, M. 2017. Restricted
chase (non)termination for existential rules with disjunc-
tions. In Sierra, C., ed., Proc. 26th Int. Joint Conf. on Ar-
tiﬁcial Intelligence, IJCAI’17, 922–928. ijcai.org.
Deutsch, A.; Nash, A.; and Remmel, J. B. 2008. The chase
revisited. In Lenzerini, M., and Lembo, D., eds., Proc. 27th
Symposium on Principles of Database Systems (PODS’08),
149–158. ACM.
Fagin, R.; Kolaitis, P. G.; Miller, R. J.; and Popa, L. 2005.
Data exchange: semantics and query answering. Theoretical
Computer Science 336(1):89–124.
Grahne, G., and Onet, A. 2018. Anatomy of the chase.
Fundam. Informaticae 157(3):221–270.
Kr¨otzsch, M., and Rudolph, S. 2011. Extending decidable
existential rules by joining acyclicity and guardedness. In
Walsh, T., ed., Proc. 22nd Int. Joint Conf. on Artiﬁcial Intel-
ligence (IJCAI’11), 963–968. AAAI Press/IJCAI.
Kr¨otzsch, M.; Marx, M.; and Rudolph, S. 2019. The power
of the terminating chase. In Barcel´o, P., and Calautti, M.,
eds., Proc. 22nd Int. Conf. on Database Theory, ICDT’19,
volume 127 of LIPIcs, 3:1–3:17.
Schloss Dagstuhl -
Leibniz-Zentrum f¨ur Informatik.
Marnette, B. 2009. Generalized schema-mappings: from
termination to tractability. In Paredaens, J., and Su, J., eds.,

A Proofs for Section 3
In this section, we prove the claims made in Section 3. In particular, besides proving Lemmas 5, 6, 7,
8, 9, 10, and 11, we show Lemma 26 from which the next claims (given in the order they occur in the
section) follow.
1. |I1| = |I2| = |I3| = |I4| = |I5|.
2. For each 1 ≤ i < j ≤ 5 and each I ∈ Ii, there is exactly one J ∈ Ij with I ⊆ J .
3. Every I ∈ Ii with 1 ≤ i ≤ 5 contains a unique interpretation Seed (I) ∈ I1, and there is a unique

ordered partition Order (I) ∈ Ords such that Seed (I) ∈ Compls(Order (I)).

Recall

that ∆ = Nulls(D) ∪ {uα, uω}. We will call a D-order a database over schema
{First, Last, LT, Eq, NEq} and nulls from ∆, and a D-completion a database over schema {Inp, NInp |
p ∈ S} and nulls from ∆. We say that a D-completion is complete if (i) it includes {Inp((cid:126)t) | p((cid:126)t) ∈ D}
and (ii) for every p ∈ S and tuple (cid:126)t ⊆ ∆ of matching arity, it contains exactly one of {Inp((cid:126)t), NInp((cid:126)t)}.
Lemma 26. There is a one-to-one correspondence between the interpretations in Ii (1 ≤ i ≤ 5) and
the pairs of the form ( (cid:126)T , FD), where (cid:126)T = T1, . . . , Tk ∈ Ords is an ordered partition of ∆ with uα ∈ T1
and uω ∈ Tk, and FD is a complete D-completion. More precisely:
• An interpretation I ∈ I1 corresponds to a pair ( (cid:126)T , FD) iff I is the union of the following databases:

– D ∪ {DbDom(t) | t ∈ ∆},
– the D-order corresponding to (cid:126)T : {First(t) | t ∈ T1} ∪ {Last(t) | t ∈ Tk} ∪ {Eq(t, u) | 1 ≤ i ≤

k; t, u ∈ Ti} ∪ {LT(t, u), NEq(t, u), NEq(u, t) | 1 ≤ i < j ≤ k, t ∈ Ti, u ∈ Tj}, and

– FD.

• An interpretation I ∈ Ii (2 ≤ i ≤ 5) corresponds to ( (cid:126)T , FD) iff it includes some I1 ∈ I1 that

corresponds to ( (cid:126)T , FD).

In particular, it follows that every I ∈ Ii with 1 ≤ i ≤ 5 contains a unique interpretation Seed (I) ∈ I1,
and there is a unique ordered partition Order (I) ∈ Ords such that Seed (I) ∈ Compls(Order (I)).

Proof. The correspondence between interpretations in I1 and pairs of the form ( (cid:126)T , FD) is well de-
ﬁned because I1 = (cid:83)
(cid:126)T ∈Ords Compls( (cid:126)T ) where Compls( (cid:126)T ) is the set of all minimal models of
R1 and D that contain the D-order corresponding to (cid:126)T . In particular, every I ∈ I1 must include a
complete D-completion to satisfy (14) and (4), and by minimality I does not include any set of the
form {Inp((cid:126)t), NInp((cid:126)t)}. Moreover, by minimality, I does not contain any other atom over predicates
{First, Last, LT, Eq, NEq}.

Each Ii (2 ≤ i ≤ 5) is obtained from Ii−1 by applying the function Int i to each of its elements and
by construction of Int i, I ⊆ Int i(I) and Int i(I) \ I does not contain any atoms on predicates from
S ∪ {DbDom, First, Last, LT, Eq, NEq} ∪ {Inp, NInp | p ∈ S}. Hence the one-to-one correspondence
between elements of I1 and pairs of the form ( (cid:126)T , FD) is preserved when applying Int i to elements of
Ii−1 to obtain the elements of Ii for each 2 ≤ i ≤ 5.
Lemma 5. I1 = (cid:83)

(cid:126)T ∈Ords Compls( (cid:126)T ) is a universal model set of R1 and D.

Proof. Let K be the result of some chase tree for R1 and D that prioritises the application of rules in the
order of their appearance in Figure 1. By Fact 2, K is a universal model set for R1 and D and we show
that each K ∈ K is isomorphic to a unique I ∈ I1.

We use the one-to-one correspondence between the interpretations in I1 and the pairs of the form
( (cid:126)T , FD) described in Lemma 26. Since K is a result of the chase on R1 and D, the domain of every
K ∈ K contains all nulls in Nulls(D) and exactly two fresh nulls introduced to satisfy rules (2) and (3),

respectively. We name them uα and uω respectively, so that ∆ is the domain of K, and deﬁne a one-to-
one correspondence between the interpretations in K and the pairs of the form ( (cid:126)T , FD) as in Lemma 26.
This can be done because of the following points:

• Every K ∈ K includes D and does not contain any other atom on predicates from S because such

predicates do not occur in rule heads.

• Every K ∈ K includes {DbDom(t) | t ∈ ∆} and does not contain any other atom on predicate DbDom

(since there are no more nulls).

• Every K ∈ K includes a D-order corresponding to some (cid:126)T ∈ Ords and does not contain any other

atom on predicates from {First, Last, LT, Eq, NEq}:
– Let ∼ be the relation over ∆ deﬁned by t ∼ t(cid:48) iff Eq(t, t(cid:48)) ∈ K. This is an equivalence relation
because (i) {DbDom(t) | t ∈ ∆} ⊆ K and K satisﬁes (5) (reﬂexivity); (ii) K satisﬁes (6) (symmetry);
and (iii) K satisﬁes (8) instantiated for R = Eq (transitivity). The equivalence classes form a partition
T1, . . . , Tk of ∆ such that {Eq(t, u) | 1 ≤ i ≤ k; t, u ∈ Ti} ⊆ K.

– For every u, t ∈ ∆, K contains at least one of {Eq(u, t), NEq(u, t)} because it satisﬁes (9). More-
over, K cannot contain both Eq(u, t) and NEq(u, t) because the rules (5), (6) and (8) have a higher
priority than (9). Hence {NEq(t, u), NEq(u, t) | 1 ≤ i < j ≤ k, t ∈ Ti, u ∈ Tj} ⊆ K.

– K includes {First(u) | u ∼ uα} and {Last(u) | u ∼ uω} by deﬁnition of uα, uω and because it
satisﬁes (8). Assuming w.l.o.g. that T1 is the equivalence class of uα and Tk that of uω: {First(t) |
t ∈ T1} ∪ {Last(t) | t ∈ Tk} ⊆ K.

– K does not include any other atom over First or Last because rules (2) and (3) are applied only

once.

– For every u, t ∈ ∆ such that NEq(u, t) ∈ K, K contains at least one of {LT(u, t), LT(t, u)} because

it satisﬁes (13).

– For every u, t ∈ ∆, if First(u) ∈ K (i.e. u ∼ uα) and First(t) /∈ K (i.e. t (cid:54)∼ uα) then

LT(u, t) ∈ K because of (11).

– For every u, t ∈ ∆, if Last(u) ∈ K (i.e. u ∼ uω) and Last(t) /∈ K (i.e. t (cid:54)∼ uω) then LT(t, u) ∈ K

because of (12).

– If LT(u, t) ∈ K then LT(u(cid:48), t(cid:48)) ∈ K for all u(cid:48) ∼ u and t ∼ t(cid:48) because K satisﬁes (8).
– K contains the transitive closure of LT because it satisﬁes (10).
– Since the rules (11), (12), (5), (6), (8), and (10) have a higher priority than (13), then K cannot

contain both LT(u, t) and LT(t, u).

– Hence T1, . . . , Tk can be ordered in a way such that {LT(t, u) | 1 ≤ i < j ≤ k, t ∈ Ti, u ∈ Tj} ⊆

K and the ordered partition corresponds to some (cid:126)T ∈ Ords as required.

• Every K ∈ K contains a complete D-completion FD and does not contain any other atom on predicates

from {Inp, NInp | p ∈ S}:
– K includes {Inp((cid:126)t) | p((cid:126)t) ∈ D} because it satisﬁes (4).
– For every p ∈ S and tuple (cid:126)t ⊆ ∆ of matching arity, K contains at least one of {Inp((cid:126)t), NInp((cid:126)t)}
because it satisﬁes (14). We show that it does not contain both. The rules of the form (14) have the
lowest priority and applying such a rule can only trigger the application of some rules of the form
(8), which themselves cannot trigger the application of any rules but (8). Hence, (i) the application of
these rules in the chase tree happens after the construction of the D-order in K, and (ii) when a rule
of the form (14) is applied and adds some Inp((cid:126)t) (resp. NInp((cid:126)t)), the exhaustive application of rules
(8) adds all Inp((cid:126)t(cid:48)) (resp. NInp((cid:126)t(cid:48))) such that (cid:126)t(cid:48) ∼ (cid:126)t, where (cid:126)t(cid:48) ∼ (cid:126)t iff ti ∼ t(cid:48)
i for every i. Suppose for
a contradiction that there exists (cid:126)u such that Inp((cid:126)u) ∈ K and NInp((cid:126)u) ∈ K. Since the rules (14) and
(8) are the only ones that have predicates from {Inp, NInp | p ∈ S} in the head, it follows that there
exist Inp((cid:126)u1) ∈ K and NInp((cid:126)u2) ∈ K that have both been added by some application of (14) and are

such that (cid:126)u1 ∼ (cid:126)u and (cid:126)u2 ∼ (cid:126)u. Assume that Inp((cid:126)u1) was added ﬁrst. Then by (ii) Inp((cid:126)u2) has been
added before any new application of (14), and the rule (cid:86)
x∈(cid:126)x DbDom(x) → Inp((cid:126)x) ∨ NInp((cid:126)x) with
the substitution that maps (cid:126)x to (cid:126)u2 was already satisﬁed, contradicting the introduction of NInp((cid:126)u2).
• For every ( (cid:126)T , FD), there exists K ∈ K that corresponds to ( (cid:126)T , FD). The existence of K is witnessed
by the path of the chase tree such that for every vertex labelled with E where a disjunctive rule (9),
(13), or (14) is applied, the path chooses the child labelled with Ci = E ∪ σi(ηi) where σi(ηi) is
included in FD or in the D-order corresponding to (cid:126)T .

Hence, we can deﬁne a one-to-one correspondence between interpretations in K and interpretations in
I1 using the corresponding pairs of the form ( (cid:126)T , FD). By construction, every K ∈ K and I ∈ I1 that
are in correspondence are isomorphic (note that since we choose to name the two fresh nulls uα and uω,
they are actually identical).

Lemma 27. Given some I ∈ I1, Int 2(I) is isomorphic to the unique interpretation in a result of the
chase over R2 and I.

Proof. We will let Order (F) = T1, . . . , Tk. The interpretation Int 2(I) is equal to:

I ∪ {Root(u1)} ∪ {Chi(uw, uwz) | wz ∈ Z, 2 ≤ z ≤ k} ∪
{Leaf(uw) | w ∈ Z; end (w) = k} ∪ {Rep(x, uw) | w ∈ Z; x ∈ Tend(w)} ∪
{In(cid:48)
{NIn(cid:48)

p(uw1, . . . , uwAr (p)) | Inp(t1, . . . , tAr (p)) ∈ I; wi ∈ Z; ti ∈ Tend(wi); 1 ≤ i ≤ Ar (p)} ∪
p(uw1 , . . . , uwAr (p)) | NInp(t1, . . . , tAr (p)) ∈ I; wi ∈ Z; ti ∈ Tend(wi); 1 ≤ i ≤ Ar (p)}.

We describe a chase over R2 and I that prioritises rule (18) step by step (note that if we do not
prioritise (18), we could get a result which is not isomorphic to Int 2(I)). Instead of constructing an
isomorphism by giving for each fresh null introduced during the chase its counterpart in Int 2(I), we
directly set the the names of the fresh nulls so that the chase result coincides with Int 2(I). Note that no
rule in Figure 1 is applicable to I and that applying a rule in Figure 2 cannot make a rule in Figure 1
applicable.

• Apply (cid:104)ρ, σ(cid:105) with ρ = (15) and σ the substitution that maps x to some t ∈ T1 (recall that {First(t) |

t ∈ T1} ⊆ I). This introduces a fresh null that we call u1, and adds Root(u1) and Rep(t, u1).

• Apply exhaustively (18): add Rep(t, u1) for all t ∈ T1.
• For 2 ≤ i ≤ k:

– Choose one t1 ∈ T1 and one ti ∈ Ti and apply (cid:104)ρ, σ(cid:105) with ρ = (16) and σ the substitution that maps
x to t1, v to u1, and z to ti (recall that the atoms on predicate LT in I are {LT(t, u) | 1 ≤ j < j(cid:48) ≤ k,
t ∈ Tj, u ∈ T (cid:48)
j}). This introduces a fresh null that we call u1 i and adds Chi(u1, u1 i), Rep(ti, u1 i)
(note that this is the ﬁrst fact of the form Rep(ti, x) with ti ∈ Ti that we introduce).

– Apply exhaustively (18): add Rep(t, u1 i) for all t ∈ Ti.

• Continue applying (16) and (18) exhaustively as done in the previous step, introducing all nulls of the
form uw with w ∈ Z, and adding facts {Chi(uw, uwz) | wz ∈ Z, 2 ≤ z ≤ k} and {Rep(x, uw) | w ∈
Z; x ∈ Tend(w)}.

• Apply exhaustively (17) and add {Leaf(uw) | w ∈ Z; end (w) = k} (recall that {Last(t) | t ∈

Tk} ⊆ I).

• Apply exhaustively (19): for all Inp(t1, . . . , tAr (p)) ∈ I, add all In(cid:48)

p(uw1, . . . , uwAr (p) ) where ti ∈

Tend(wi).

• Apply exhaustively (20): for all NInp(t1, . . . , tAr (p)) ∈ I, add all NIn(cid:48)

p(uw1, . . . , uwAr (p) ) where ti ∈

Tend(wi).

Lemma 6. I2 = {Int 2(I) | I ∈ I1} is a universal model set of R2 and D.

Proof. By Lemmas 5 and 27, I2 only contains models of R2 and D. We show that for every model M
of R2 and D, there exists I2 ∈ I2 and a homomorphism h2 : I2 → M.

1. Let M be a model of R2 and D.
2. By Lemma 5: since M is a model of R2 ⊇ R1 and D, there exist I1 ∈ I1 and a homomorphism

h1 : I1 → M.

3. By Lemma 27: since I1 ∈ I1, there exists a chase over R2 and I1 such that the unique interpretation

J in its result is such that there exists an isomorphism g2 : Int 2(I1) → J .

4. By deﬁnition of J , and since no rule from R1 is applied in the chase of over R2 and I1 (see proof
of Lemma 27) and R2 \ R1 contains no disjunctive rules, it follows that J is a universal model of
R2 \ R1 and I1.

5. By (1), (2) and (4), there exists a homomorphism g1 : J → M that extends h1.
6. Let I2 = Int 2(I1) ∈ I2. By (3) and (5), there is an homomorphism h2 = g2 ◦ g1 : I2 → M.

In the next proofs, we will use the following notation. Given a chase tree node labelled Ci = E ∪σi(ηi)
and obtained by applying some (cid:104)ρ, σ(cid:105) to its parent node labelled by E, then for each variable y of ρ not
in the domain of σ, we denote by uσ,ρ,y the fresh null such that σi(y) = uσ,ρ,y where σi is as introduced
in Deﬁnition 2.
Lemma 28. Given some I ∈ I2, Int 3(I) is well-deﬁned and Int 3(I) is isomorphic to the unique
interpretation in a result of the chase over R3 and I.

Proof. We will let Order (I) = T1, . . . , Tk. The interpretation Int 3(I) is equal to the union of the
following databases:

1. I .
2. For each w ∈ Z of length |w|, with b1 · · · b(cid:96) the binary representation of |w| + 1, the database

EncPos(w):

{Enc(uw, e1

w, e(cid:96)

w)} ∪ {Sbi(ei

w) | 1 ≤ i ≤ (cid:96)} ∪ {Nxt(ei−1

w , ei

w) | 2 ≤ i ≤ (cid:96)}.

3. For each w ∈ Z of length |w| < k, and z ∈ {1, . . . , k} such that wz ∈ Z, with b1 · · · b(cid:96) the
(cid:96)(cid:48) the binary representation of |w| + 1, the database

1 · · · b(cid:48)

binary representation of |w| + 2 and b(cid:48)
CpyPlusOne(w, wz) deﬁned as follows:

{Cpy+1(ei

∪ {Cpy(ei

wz) |

w, ej

wz, e(cid:96)

w, e(cid:96)(cid:48)
the number represented by bj · · · b(cid:96) is equal to the number represented by b(cid:48)
w, e(cid:96)(cid:48)
(cid:96)(cid:48)}.

wz) | bi · · · b(cid:96) = b(cid:48)

i · · · b(cid:48)

wz, e(cid:96)

w, ei

i · · · b(cid:48)

(cid:96)(cid:48) plus one}

We describe a (Datalog-ﬁrst) chase over R3 and I step by step. We directly set the the names of the
fresh nulls so that the chase result coincides with Int 3(I). Note that no rule in Figures 1 or 2 is applicable
to I and that applying a rule in Figure 3 cannot make a rule in Figures 1 or 2 applicable.
• Apply (cid:104)ρ, σ(cid:105) with ρ = (21) and σ(u) = u1. This introduces two fresh nulls, uσ,ρ,y1 = e1
1), Nxt(e1
We show by induction on p that for every w ∈ Z of length |w| = p and z ∈ {1, . . . , k} such that wz ∈ Z,
our chase sequence adds EncPos(wz), and CpyPlusOne(w, wz).
Case p = 1. In this case, w = 1 and z ∈ {2, . . . , k}.

1 and adds Enc(u1, e1

1) and S1(e2

uσ,ρ,y2 = e2

1), S0(e1

1 and

1, e2

1, e2

1).

• For 2 ≤ i ≤ k:

– Apply (cid:104)ρ, σ(cid:105) with ρ = (22) and σ(u) = u1, σ(y1) = e1
1 i and uσ,ρ,z = e2

introduces two fresh nulls, uσ,ρ,z1 = e1
Cpy+1(e1
1 i, e2
1, e2
1 i).
1 i), Nxt(e1
– Apply (23): add S1(e1

1 i, e2

1, e1

1 i), S1(e2

1 i).
Induction step: Assume that our chase sequence already added all required facts for every w(cid:48) ∈ Z of
length |w(cid:48)| < p, and z(cid:48) ∈ {1, . . . , k} such that w(cid:48)z(cid:48) ∈ Z, and consider w ∈ Z of length |w| = p, and
z ∈ {1, . . . , k} such that wz ∈ Z. Let b1 · · · b(cid:96) the binary representation of p + 2 and b(cid:48)
(cid:96)(cid:48) the binary
representation of p + 1.

1 · · · b(cid:48)

1, σ(y ) = e2
1 i and adds Enc(u1 i, e1

1, σ(v) = u1 i. This
1 i, e2
1 i) and

w) was added by the chase sequence. Apply (cid:104)ρ, σ(cid:105) with ρ =
w, σ(v) = uwz. This introduces two fresh nulls,

wz and uσ,ρ,z = e(cid:96)

• By induction hypothesis, Enc(uw, e1
(22) and σ(u) = uw, σ(y1) = e1
uσ,ρ,z1 = e1

w, e(cid:96)(cid:48)
w, σ(y ) = e(cid:96)(cid:48)
wz and adds Enc(uwz, e1
• By induction hypothesis, the chase sequence added Sb(cid:48)

wz) and Cpy+1(e1
wz, e(cid:96)
(ei
w), 1 ≤ i ≤ (cid:96)(cid:48), and Nxt(ei−1
(cid:96)(cid:48). We distinguish two cases, depending on the value of b(cid:48)
1.
(1) In the case where b(cid:48)
(otherwise b(cid:48)
– Apply (cid:104)ρ, σ(cid:105) with ρ = (25) and σ(y1) = e1

1 = 0, we have (cid:96) = (cid:96)(cid:48) and b1 · · · b(cid:96) = 1b(cid:48)

2 = 01 and p + 1 = 2).

w, σ(y ) = e(cid:96)

2 · · · b(cid:48)

w, e(cid:96)(cid:48)

w, e1

1b(cid:48)

wz, e(cid:96)
w , ei

wz).
w), 2 ≤ i ≤

(cid:96). Moreover, note that (cid:96) > 2

i

w, σ(y2) = e2

w, σ(y3) = e3
wz, and adds the atoms Cpy(e2

w, σ(z1) = e1
wz, e(cid:96)
w, e2
w, e(cid:96)

wz,
wz),

wz. This introduces a fresh null, uσ,ρ,z2 = e2

σ(z ) = e(cid:96)
S1(e1

wz), and Nxt(e1
w , e(cid:96)

wz, e2
w, e(cid:96)−1

wz).
wz , e(cid:96)

– While Cpy(e(cid:96)−1

2 < i < (cid:96) and adding atoms Cpy(ei

– Apply (27) and add Sb(cid:96)−1(e(cid:96)−1
(2) In the case where b(cid:48)
number represented by b(cid:48)
– While no atom of the form Cpy(ej

2 · · · b(cid:48)

(cid:96)(cid:48) plus one.
w, e(cid:96)(cid:48)

wz) has not been introduced, apply (28), introducing fresh nulls ei

wz for

w, e(cid:96)

w, ei
wz , e(cid:96)
wz ), Nxt(e(cid:96)−1

wz), Sbi−1 (ei−1
wz).

wz), S1(e(cid:96)

wz, e(cid:96)

wz ), and Nxt(ei−1

wz , ei

wz).

1 = 1, we have b1 = 0 and the number represented by b2 · · · b(cid:96) is equal to the

w, ej

wz, e(cid:96)

wz) have been in-
troduced, and for i starting from 2 and growing by one at each cycle, apply the applicable (cid:104)ρ, σ(cid:105)
among:
* ρ = (25) and σ(y1) = ei−1

w, σ(y3) = ei+1
w, σ(y2) = ei
wz, and adds the atoms Cpy(ei

w , σ(z1) = ei−1
wz, e(cid:96)
w, ei

wz , σ(z ) = e(cid:96)
wz), S1(ei−1

wz.
wz ) =

w , σ(y ) = e(cid:96)(cid:48)
This introduces a fresh null, uσ,ρ,z2 = ei
Sbi−1 (ei−1

wz ), and Nxt(ei−1

wz , ei

w, e(cid:96)(cid:48)

wz) or Cpy+1(e(cid:96)(cid:48)−1

w , e(cid:96)(cid:48)

w, e(cid:96)(cid:48)−1

wz , e(cid:96)

wz).

* ρ = (26) and σ as above. This introduces a fresh null, uσ,ρ,z2 = ei

wz, and adds the atoms

w, ei

wz, e(cid:96)

Cpy+1(ei

wz), S0(ei−1
w, e(cid:96)(cid:48)

w, e(cid:96)(cid:48)
– If an atom of the form Cpy(ej

wz).
wz) is introduced at some point (i.e. the applicable (cid:104)ρ, σ(cid:105)
in the previous step is such that ρ = (25)), we use a sequence of chase steps similar to the case
b(cid:48)
1 = 0, and obtain the required atoms.
wz , e(cid:96)

wz) is introduced at the end of the loop. Apply the applicable

wz ) = Sbi−1(ei−1
wz, e(cid:96)
w, ej

– Otherwise, Cpy+1(e(cid:96)(cid:48)−1

wz ), and Nxt(ei−1

w, e(cid:96)(cid:48)−1

w , e(cid:96)(cid:48)

wz , ei

(cid:104)ρ, σ(cid:105) among:
* ρ = (23) and σ(y1) = e(cid:96)(cid:48)−1
wz ), Nxt(e(cid:96)−1

wz , e(cid:96)

w , σ(y2) = e(cid:96)(cid:48)

w, σ(z1) = e(cid:96)(cid:48)−1

wz , σ(z ) = e(cid:96)

wz with (cid:96)(cid:48) = (cid:96). This adds

S1(e(cid:96)−1

wz), and S1(e(cid:96)
* ρ = (24) and σ is as above but (cid:96) = (cid:96)(cid:48) +1 so that σ(z1) = e(cid:96)(cid:48)−1
wz ), S0(e(cid:96)−1

wz and adds S0(e(cid:96)−2

wz ), Nxt(e(cid:96)−2

uσ,ρ,z2 = e(cid:96)−1

wz , e(cid:96)−1

wz).

wz = e(cid:96)−2
wz ), Nxt(e(cid:96)−1

wz . This introduces a new null
wz) and S1(e(cid:96)

wz , e(cid:96)

wz).

Lemma 7. I3 = {Int 3(I) | I ∈ I2} is a universal model set of R3 and D.

Proof. Similar to the proof of Lemma 6, using Lemmas 6 and 28.

Lemma 29. Given some I ∈ I3, Int 4(I) is well-deﬁned and Int 4(I) is isomorphic to the unique
interpretation in a result of the chase over R4 and I.

g (cid:107)b1

1 · · · b1
(cid:96)1

Proof. Before giving the extension of Int 4(I), we introduce some notation. Consider some fact of the
form Leaf(uw) ∈ I and let S = branchTape(I, uw). By construction, S = e1 · · · e|branchDb(I,uw)|
where each ei corresponds to the serialisation of some px
g (uw1, . . . , uwx ) ∈ branchDb(I, uw) and is of
the form px
(cid:107) · · · (cid:107)bx
(cid:107) where bi
is the binary representation of |wi| + 1. For every
g , uw1, . . . , uwx) and je
g ∈ S and uw1, . . . , uwx ⊆ branch(uw), let js
px
g , uw1, . . . , uwx )−1 be the
g (uw1 , . . . , uwx ) starts and ends respectively if px
indexes where the serialisation of px
g (uw1, . . . , uwx ) ∈
branchDb(I, uw), and otherwise js
S(px
g , uw1 , . . . , uwx ) be the index where
starts the serialisation of the ﬁrst fact of branchDb(I, uw) that follows px
g (uw1 , . . . , uwx) according to
≺ (and |S| + 1 if there is no such fact). (Recall that ≺ is deﬁned before Lemma 8.) It is easy to verify
that:

g , uw1, . . . , uwx ) = je

1 · · · bi
(cid:96)i
S(px

1 · · · bx
(cid:96)x

S(px

S(px

1, uw) = 1.

• js
S(p1
• If In(cid:48)
px
g
• If In(cid:48)
px
g

(uw1, . . . , uwx ) /∈ I, then je
(uw1, . . . , uwx ) ∈ I, then je

S(px
S(px

g , uw1, . . . , uwx ) = js
g , uw1, . . . , uwx) = js

S(px
S(px

g , uw1 , . . . , uwx ).
g , uw1, . . . , uwx ) + Σx

i=1(cid:96)i + x + 2,

where (cid:96)i is the length of the binary encoding of |wi| + 1.

g , uw1, . . . , uwx ) = js
(cid:54)= u1, . . . , u1,

S(px
then je

g+1, uw1, . . . , uwx ).
S(px

¯n, uw1, . . . , uwx) = js

S(px

1 , uw(cid:48)

1

, . . . , uw(cid:48)

), where

x

x comes right after uw1, . . . , uwx in the lexicographic order according to ≺.

• If g < ¯n, then je

S(px

uw(cid:48)

• If uw1, . . . , uwx
, . . . , uw(cid:48)
• If x < ¯m, then je

1

S(px

¯n, u1, . . . , u1) = js

S(px+1

1

, uw, . . . , uw).

Note that je
1 · · · bi
bi
(cid:96)i

S(p ¯m

¯n , u1, . . . , u1) = |S| + 1 and that for every px
is the binary encoding of |wi| + 1 (1 ≤ i ≤ x), then :

g (uw1, . . . , uwx ) ∈ branchDb(I, uw), if

g , uw1 , . . . , uwx )] = px
g ,
g , uw1 , . . . , uwx ) + 1] = (cid:107),

S(px
S(px

• S[js
• S[js
• and for 1 ≤ i ≤ x:
S(px

g , uw1, . . . , uwx ) + i + Σi−1

j=1(cid:96)j + 1] = bi
1,

S(px
S(px

g , uw1 , . . . , uwx ) + i + Σi−1
g , uw1 , . . . , uwx ) + i + Σi

j=1(cid:96)j + (cid:96)i] = bi
(cid:96)i
j=1(cid:96)j + 1] = (cid:107).

,

– S[js
– . . . ,
– S[js
– S[js

Finally, let JS(uw(cid:48)) be the set of indexes of S where starts the sequence (cid:107)b(cid:48)
(cid:96)(cid:48) is
the binary representation of |w(cid:48)| + 1. The interpretation Int 4(I) is equal to the union of the following
databases:

(cid:96)(cid:48)(cid:107) where b(cid:48)

1 · · · b(cid:48)

1 · · · b(cid:48)

1. I ;
2. For every Leaf(uw) ∈ I with serialisation S = branchTape(I, uw), the database startConf (I, uw):

{Ld1(uw, t1
w , tj
{Nxt(tj−1

w, uw), HdqS (t1
w) | 2 ≤ j ≤ |S| + 1} ∪ {Sa(tj

w), End(t|S|+1

w

), S (t|S|+1
w

)} ∪

w) | 1 ≤ j ≤ |S|, a = S[j]}.

3. For every Leaf(uw) ∈ I with serialisation S = branchTape(I, uw), the database loadS (I, uw)

deﬁned as follows:

{Ldx(uw, tj
∪{Rdyx(uw, tj
(uw, tj
∪{Ldpx
(uw, tj
∪{Rdypx

w, uw1 , . . . , uwx ) |1 ≤ x ≤ ¯m; uwi ∈ branch(uw); j = js
w, uw1 , . . . , uwx ) |1 ≤ x ≤ ¯m; uwi ∈ branch(uw); j = je
w, uw1 , . . . , uwx ) |1 ≤ g ≤ ¯n; 1 ≤ x ≤ ¯m; uwi ∈ branch(uw); j = js
w, uw1 , . . . , uwx ) |1 ≤ g ≤ ¯n; 1 ≤ x ≤ ¯m; uwi ∈ branch(uw); j = je

1 , uw1, . . . , uwx )}
¯n, uw1, . . . , uwx )}
S(px
S(px

S(px
S(px

g

g

g , uw1 , . . . , uwx )}
g , uw1 , . . . , uwx )}

∪{LdE(uw(cid:48), tj+1
w(cid:48), tj+r+1
w

w(cid:48), e(cid:96)(cid:48)

w , tj+(cid:96)(cid:48)+2
w
, tj+(cid:96)(cid:48)+1
w

∪{Cpy(er

) |uw(cid:48) ∈ branch(uw); b(cid:48)
) |uw(cid:48) ∈ branch(uw); b(cid:48)

1 · · · b(cid:48)
1 · · · b(cid:48)

(cid:96)(cid:48) bin. rep. of |w(cid:48)| + 1; j ∈ JS(uw(cid:48))}
(cid:96)(cid:48) bin. rep. of |w(cid:48)| + 1;

1 ≤ r ≤ (cid:96)(cid:48) − 1; j − 1 ∈ JS(uw(cid:48))}

We describe a (Datalog-ﬁrst) chase over R4 and I step by step. We directly set the the names of the fresh
nulls so that the chase result coincides with Int 4(I). Note that no rule in Figures 1, 2, or 3 is applicable
to I but that applying rule (30) may trigger the application of the “copy” rules (27) and (28) in Figure3.

For every Leaf(uw) ∈ I with serialisation S = branchTape(I, uw):

• Apply (cid:104)ρ, σ(cid:105) with ρ = (31) and σ that maps u to uw. This introduces a fresh null that we call t1
w). Note that js

w and
1, uw) = 1 so that we have indeed added

w, uw) and HdqS (t1

S(p1

adds atoms Ld1(uw, t1
S (p1
Ld1(uw, tjs
w

1,uw)

, uw).

• Let branch(uw) = {uw1, . . . , uwp } with uw = uw1 ≺ · · · ≺ uwp = u1 (i.e. |w| = |w1| > · · · >

|wp| = 1). For 1 ≤ i ≤ p:

1,uwi )

, uwi) and add Ldp1

1

(uw, t

js
S (p1
w

1,uwi )

, uwi).

g, uwi ):

(uwi) ∈ I, apply (38) and add Rdyp1

g

(uw, tj

w, uwi). Note that j = js

S(p1

g, uwi) =

js
S (p1
– Apply (32) to Ld1(uw, t
w
S(p1
– For 1 ≤ g ≤ ¯n and j = js
* If NIn(cid:48)
p1
g
S(p1
je
g, uwi).
* Else, In(cid:48)
p1
g
σ(t) = tj
tj+(cid:96)i+2
w
This adds atoms Sp1
(uw, tj+(cid:96)i+3
Rdyp1
w

g

g

(uwi) ∈ I: apply (cid:104)ρ, σ(cid:105) with ρ the instantiation of (29) for p1
w and σ(v) = uwi . This introduces three fresh nulls uρ,σ,x1 = tj+1
1 · · · bi
and uρ,σ,y = tj+(cid:96)i+3
(cid:96)i
w ), LdE(uwi, tj+1
w), Nxt(tj

g, and σ(u) = uw,
w , uρ,σ,x2 =
is the binary representation of |wi| + 1.
), Nxt(tj+(cid:96)i+2
) and

, where bi
w, tj+1

, tj+(cid:96)i+3

(tj

w

w , tj+(cid:96)i+2
w
g, uwi) + (cid:96)i + 3 = je

w
S(p1

w
g, uwi ).

, uwi). Note that j + (cid:96)i + 3 = js

S(p1

* If g < ¯n: Apply (33) and add Ldp1
S(p1
otherwise. Note that j(cid:48) = je
in I.

g+1

(uw, tj(cid:48)
g, uwi) = js

w , uwi) with j(cid:48) = j if NIn(cid:48)
p1
g
S(p1

g+1, uwi ), independently of whether In(cid:48)
p1
g

(uwi ) ∈ I, j(cid:48) = j + (cid:96)i + 3
(uwi) is

je
S (p1
– Apply (34) and add Rdy1(uw, t
w
– If i < p (i.e. uwi (cid:54)= u1): Apply the instantiation of (35) Rdy1(u, t, v) ∧ Chi(w, v) → Ld1(u, t, w)
1, uwi+1 ). Recall that uwi+1 comes right

w , uwi+1) with j(cid:48) = je

and add Ld1(uw, tj(cid:48)
after uwi in the lexicographic order according to ≺.

¯n, uwi) = js

, uwi).

S(p1

S(p1

¯n,uwi )

• At the end of the above loop, we obtain an atom Rdy1(uw, tje

S (p1
w

¯n,u1)

of (36) Rdy1(u, t, v) ∧ Root(v) → Ld2(u, t, u, u) and add Ld2(uw, tje
S(p1
je

¯n, u1) = js

1, uw, uw).

S(p2

, u1). Apply the instantiation
S (p1
¯n,u1), uw, uw). Note that

• Repeat the process, so that we obtain the atoms of the following form for 2 ≤ x ≤ ¯m and

uw1, . . . , uwx ∈ branch(uw):

w, uw1 , . . . , uwx ) where j = js
w, uw1, . . . , uwx ) where j = je

S(px
S(px

1 , uw1, . . . , uwx );
¯n, uw1 , . . . , uwx );

w, uw1, . . . , uwx) where j = js
w, uw1, . . . , uwx ) where j = je
S(px

(uw1, . . . , uwx) ∈ I and j = js

g , uw1 , . . . , uwx );
g , uw1 , . . . , uwx);

S(px
S(px
g , uw1 , . . . , uwx ):

g

(uw, tj
(uw, tj

– Ldx(uw, tj
– Rdyx(uw, tj
– for 1 ≤ g ≤ ¯n:
* Ldpx
* Rdypx
* for In(cid:48)
px
g
(tj
w),
· Spx
· Nxt(tj
w, tj+1
· LdE(uw1, tj+1

g

g

S( ¯m, u1, . . . , u1) = |S| + 1. Apply

w

w ), . . . , Nxt(tj+Σx
w , tj+(cid:96)1+2
w

l=1(cid:96)l+x+1
), . . . , LdE(uwx , tj+Σx−1

, tj+Σx

l=1 (cid:96)l+x
w, u1, . . . , u1) with j = je
• We have obtained an atom Rdy ¯m(uw, tj
) and End(t|S|+1
).
w
• For all uwi ∈ branch(uw) and atoms of the form LdE(uwi, tj+1

(37) and add S (t|S|+1

),
, tj+Σx

l=1(cid:96)l+x+2

w

w

w

w

l=1(cid:96)l+x+1

).

w , tj+(cid:96)i+2
w
– Apply (cid:104)ρ, σ(cid:105) with ρ = (30) and σ(v) = uwi, σ(xs) = tj+1
1 · · · bi
(cid:96)i
and uρ,σ,z = tj+(cid:96)i+1
w
, tj+(cid:96)i+2
), Nxt(tj+(cid:96)i+1
w

and σ(y ) = e(cid:96)i
wi where bi
fresh nulls uρ,σ,z1 = tj+2
w , tj+(cid:96)i+1
Cpy(e1
w
wi

, σ(y1) = e1
wi
is the binary representation of |wi| + 1. This introduces two
w ),

and adds the atoms: S(cid:107)(tj+1
) and S(cid:107)(tj+(cid:96)i+2

):
w , σ(xe) = tj+(cid:96)i+2

w ), Nxt(tj+1

w , tj+2

, tj+2

, e(cid:96)i
wi

).

w

w

w

w

– Apply exhaustively rules (27) and (28). This process introduces nulls tj+3, . . . , tj+(cid:96)i and adds the

1

following atoms (cf. proof of Lemma 28):
(tj+2
w ), . . . , Sbi
* Sbi
w
(cid:96)i
w ), . . . , Nxt(tj+(cid:96)i
w , tj+3
* Nxt(tj+2
w , tj+(cid:96)i+1
, e(cid:96)i
* Cpy(e2
w
wi
wi

),
w , tj+(cid:96)i+1
w
), . . . , Cpy(e(cid:96)i−1

(tj+(cid:96)i+1

, tj+3

wi

)

, e(cid:96)i
wi

, tj+(cid:96)i

w , tj+(cid:96)i+1
w

).

At this point, for every null uw such that Leaf(uw) ∈ I, we have added startConf (I, uw) and
loadS (I, uw) and no rule is applicable.

Lemma 8. I4 = {Int 4(I) | I ∈ I3} is a universal model set of R4 and D.

Proof. Similar to the proof of Lemma 7, using Lemmas 7 and 29.

Before proving Lemma 9, we introduce some notation about TM runs. A conﬁguration for a TM
M = (cid:104)Q, Γ, δ(cid:105) is a ﬁnite sequence (cid:126)C = C1, . . . , Ck where Ci = {q, a} for some i ≤ k, q ∈ Q, and
a ∈ Γ, while for each j (cid:54)= i, Cj = {aj} for some aj ∈ Γ. The successor conﬁguration of (cid:126)C under M ,
denoted M ( (cid:126)C), is the conﬁguration (cid:126)C (cid:48) = C (cid:48)

k+1 satisfying, assuming δ(q, a) = (q(cid:48), a(cid:48), l),

1, . . . , C (cid:48)
(cid:40) {a(cid:48)}
{ }
Cj ∩ Γ

C (cid:48)

j ∩ Γ =

if j = i,
if j = k + 1,
otherwise,

while C (cid:48)
j ∩ Q = {q(cid:48)} if j = max(1, i + l), otherwise ∅. For a word (cid:126)γ = γ1, . . . , γk, let StConf (M, (cid:126)γ)
denote the sequence {qS, γ1}, {γ2}, . . . , {γk}, { }. Let Comp(M, (cid:126)γ) = (cid:126)C 1, (cid:126)C 2, . . . be the (possibly
ﬁnite) conﬁguration sequence satisfying (cid:126)C 1 = StConf (M, (cid:126)γ) as well as (cid:126)C i+1 = M ( (cid:126)C i), whenever
deﬁned (otherwise – and only then – the sequence ends at i). Note that M halts on (cid:126)γ if Comp(M, (cid:126)γ) is
ﬁnite, and accepts (cid:126)γ if the last conﬁguration in Comp(M, (cid:126)γ) features qA.
Lemma 30. Given some I ∈ I4, Int 5(I) is isomorphic to the unique interpretation in a result of the
chase over R5 and I.

Proof. The interpretation Int 5(I) is equal to the union of the following interpretations:

1. I ;
2. For each w ∈ Z with b1 · · · b(cid:96) the binary representation of |w| + 1: {Nxt+(ei
w) | 1 ≤ i < j ≤ (cid:96)}.
3. For each uw ∈ Nulls(I) with S = branchTape(I, uw), Comp(M, S) = (cid:126)C 1, . . . , (cid:126)C (cid:96), and (cid:126)C i =

w, ej

Ci,1, . . . , Ci,|S|+i for each 1 ≤ i ≤ (cid:96), the database Run(uw) deﬁned as follows:

w

{Nxt+(ti
w, tj
w) | 1 ≤ i < j ≤ |S| + 1} ∪
{End(ti,|S|+i
) | 2 ≤ i ≤ (cid:96)} ∪
w
, ti,j
{Nxt(ti,j−1
w ) | 2 ≤ i ≤ (cid:96), 2 ≤ j ≤ |S| + i} ∪
w , ti,j(cid:48)
w ) | 1 ≤ i ≤ (cid:96), 1 ≤ j < j(cid:48) ≤ |S| + i} ∪
{Nxt+(ti,j
, ti,j
{Stp(ti−1,j
w ) | 3 ≤ i ≤ (cid:96), 1 ≤ j ≤ |S| + i − 1} ∪
w
{Sa(ti,j
w ) | 2 ≤ i ≤ (cid:96), 1 ≤ j ≤ |S| + i, a ∈ Ci,j ∩ Γ} ∪
{Hdq(ti,j
w ) | 2 ≤ i ≤ (cid:96), 1 ≤ j ≤ |S| + i, q ∈ Ci,j ∩ Q} ∪
{Goal | 1 ≤ j ≤ |S| + (cid:96), qA ∈ C(cid:96),j};

We describe a (Datalog-ﬁrst) chase over R5 and I step by step. We directly set the the names of the
fresh nulls so that the chase result coincides with Int 5(I). Note that no rule in Figures 1, 2, 3, 4, or 5
is applicable to I and that applying a rule in Figure 6 cannot make a rule in Figures 1, 2, 3, 4, or 5
applicable.

w, ej

w, ej

w, tj
w, tj

Nxt(ei
w) and Nxt(ti
point (2) and {Nxt+(ti

We ﬁrst apply exhaustively (40) and (41) which compute a transitive closure on the atoms of the form
w) | 1 ≤ i < j ≤ (cid:96)} described in

w) in I. This adds the atoms {Nxt+(ei
w) | 1 ≤ i < j ≤ |S| + 1} of the ﬁrst line in point (3).
For every null uw such that Leaf(uw) ∈ I, S = branchTape(I, uw) and Comp(M, S) =
(cid:126)C 1, . . . , (cid:126)C (cid:96), we show by induction that for every 2 ≤ i ≤ (cid:96) the following atoms belong to the chase
result:
• End(ti,|S|+i
),
, ti,j
• Nxt(ti,j−1
w ) for 2 ≤ j ≤ |S| + i,
w , ti,j(cid:48)
• Nxt+(ti,j
w ) for 1 ≤ j < j(cid:48) ≤ |S| + i,
• Stp(ti−1,j
, ti,j
w ) for 1 ≤ j ≤ |S| + i − 1,
w
• Sa(ti,j
w ) for 1 ≤ j ≤ |S| + i, a ∈ Ci,j ∩ Γ,
• Hdq(ti,j
w ) for 1 ≤ j ≤ |S| + i, q ∈ Ci,j ∩ Q.

w

w

Base case i = 2. Recall that for every Leaf(uw) ∈ I with serialisation S = branchTape(I, uw), I
includes:

{Ld1(uw, t1
{Sa(tj

w, uw), HdqS (t1
w) | 1 ≤ j ≤ |S|, a = S[j]}.

w), End(t|S|+1

w

), S (t|S|+1
w

)} ∪ {Nxt(tj−1

w , tj

w) | 2 ≤ j ≤ |S| + 1} ∪

Moreover (cid:126)C 1 = StConf (M, S) = {qS, S[1]}, {S[2]}, . . . , {S[|S|]}, { }. Let (qS, S[1]) (cid:55)→ (r, b, +1) ∈
δ (recall that we assume that the TM will never attempt to move left on the ﬁrst position of the tape). By
deﬁnition, we have C2,1 ∩ Γ = {b}, C2,j ∩ Γ = C1,j ∩ Γ = {S[j]} for every 1 < j ≤ |S| + 1, and
C2,2 ∩ Q = {r}.

• For every 1 < j ≤ |S| + 1, let a ∈ C1,j ∩ Γ = C2,j ∩ Γ.

– Apply (cid:104)ρ, σ(cid:105) with ρ the instantiation of (45) for transition (qS, S[1]) (cid:55)→ (r, b, +1) and tape symbol
w, t2,j
w )

w. This introduces a fresh null uρ,σ,z = t2,j

w and adds Stp(tj

w, σ(y) = tj

S[j], and σ(x) = t1
and SS[j](t2,j

w ).

• Apply (cid:104)ρ, σ(cid:105) with ρ the instantiation of (44) for (qS, S[1]) (cid:55)→ (r, b, +X) and σ(x) = t1

w . This

introduces a fresh null uρ,σ,z = t2,1

w and adds Stp(t1

• Apply (cid:104)ρ, σ(cid:105) with ρ = (43) with σ(x) = t|S|+1
w
, t2,|S|+2
w

and adds Nxt(t2,|S|+1

uρ,σ,v = t2,|S|+2

w

w

w, t2,1
w ) and Sb(t2,1
w ).
and σ(z) = t2,|S|+1

w

• Apply exhaustively (42), adding all atoms Nxt(t2,j−1
• Apply exhaustively (40) and (41), adding all atoms Nxt+(t2,j
• Apply (47) and add Hdr(t2,2

w

w ).

. This introduces a fresh null

), S (t2,|S|+2
) and End(t2,|S|+2
).
w
, t2,j
w ) for 2 ≤ j ≤ |S| + 2.

w

w , t2,j(cid:48)

w ) for 1 ≤ j < j(cid:48) ≤ |S| + 2.

Induction step: Assume the property is true for some 2 ≤ i < (cid:96) and let j0 be the unique Ci,j0 such that
Ci,j0 ∩ Q (cid:54)= ∅, {q0} = Ci,j0 ∩ Q, {a0} = Ci,j0 ∩ Γ, and (q0, a0) (cid:55)→ (r, b, +X) ∈ δ. By deﬁnition, we
have Ci+1,j0 ∩ Γ = {b}, Ci+1,j ∩ Γ = Ci,j ∩ Γ for every j (cid:54)= j0, and Ci+1,j0+X ∩ Q = {r}.

• For every j > j0 (resp. j < j0), let a ∈ Ci,j ∩ Γ = Ci+1,j ∩ Γ.

– Apply (cid:104)ρ, σ(cid:105) with ρ the instantiation of (45) (resp. (46)) for transition (q0, a0) (cid:55)→ (r, b, +X) and
and adds

w . This introduces a fresh null uρ,σ,z = ti+1,j

w

w , σ(y) = ti,j
tape symbol a, and σ(x) = ti,j0
Stp(ti,j
).

) and Sa(ti+1,j

w , ti+1,j
w

w

• Apply (cid:104)ρ, σ(cid:105) with ρ the instantiation of (44) for (q0, a0) (cid:55)→ (r, b, +X) and σ(x) = ti,j0

w . This

introduces a fresh null uρ,σ,z = ti+1,j0

and adds Stp(ti,j0

w

• Apply (cid:104)ρ, σ(cid:105) with ρ = (43) with σ(x) = ti,|S|+i

uρ,σ,v = ti+1,|S|+i+1
w

w
and adds Nxt(ti+1,|S|+i

w

, ti+1,|S|+i+1

w

w , ti+1,j0
w
and σ(z) = ti+1,|S|+i

) and Sb(ti+1,j0

w

).

• Apply exhaustively (42), adding all atoms Nxt(ti+1,j−1
, ti+1,j
w
• Apply exhaustively (40) and (41), adding all atoms Nxt+(ti+1,j
• If X = +1, apply (47) and add Hdr(ti+1,j0+X
• If X = −1, then j0 > 1 (since the TM never attempts to move left on the ﬁrst position of the tape):

).

w

w

w

w

w

), S (ti+1,|S|+i+1

. This introduces a fresh null
) and End(ti+1,|S|+i+1
).
w
) for 2 ≤ j ≤ |S| + i + 1.
, ti+1,j(cid:48)
w

) for 1 ≤ j < j(cid:48) ≤ |S| + i + 1.

apply (48) and add Hdr(ti+1,j0+X

).

w

We have shown that all atoms of Run(uw) but Goal belong to the chase result. Finally, for every null
uw such that Leaf(uw) ∈ I, S = branchTape(I, uw) and Comp(M, S) = (cid:126)C 1, . . . , (cid:126)C (cid:96), if there exists
j such that HdqA (t(cid:96),j

w ) ∈ Run(uw), apply (39) and add Goal.

Lemma 9. I5 = {Int 5(I) | I ∈ I4} is a universal model set of R5 and D.

Proof. Similar to the proof of Lemma 8, using Lemmas 8 and 30.

Lemma 10. If D ∈ Q, then Goal ∈ I for each I ∈ M.

Proof. Let I ∈ M. We have shown that there is a homomorphism D → branchDb(I, uw) for
the node uw where |w| = |Order (I)|. Since Q is closed under homomorphisms, D ∈ Q implies
branchDb(I, uw) ∈ Q.

Let Comp(M, S) = (cid:126)C 1, . . . , (cid:126)C (cid:96) be the computation of M on the serialisation S =
branchTape(I, uw) of the database branchDb(I, uw). Since branchDb(I, uw) ∈ Q and M decides
Q, (cid:126)C 1, . . . , (cid:126)C (cid:96) is such that (cid:126)C (cid:96) features qA. By construction of Run(uw) (see proof of Lemma 30), it
follows that Goal ∈ Run(uw). Hence Goal ∈ I.

Lemma 11. If D /∈ Q, then Goal /∈ I for some I ∈ M.

Proof. Consider some I ∈ M such that Db(I) = D and NEq(t, u) ∈ I for each t, u ∈ Nulls(D) with
t (cid:54)= u (such a I exists by Lemma 26). Let uw denote the leaf node with |w| = |Order (I)|. Then
branchDb(I, uw) is isomorphic to Db(I) = D and branchDb(I, uw) /∈ Q.

Let Comp(M, S) = (cid:126)C 1, . . . , (cid:126)C (cid:96) be the computation of M on the serialisation S =
branchTape(I, uw) of the database branchDb(I, uw). Since branchDb(I, uw) /∈ Q and M decides
Q, (cid:126)C 1, . . . , (cid:126)C (cid:96) is such that (cid:126)C (cid:96) does not feature qA. By construction of Run(uw) (see proof of Lemma
30), it follows that Goal /∈ Run(uw).

Moreover,

for all other

leaf nodes uv with Leaf(uv) ∈ I,
there is a homomorphism
branchDb(I, uv) → branchDb(I, uw). Since Q is closed under homomorphisms, M does not accept
any such branchDb(I, uv), and Goal /∈ Run(uv). By construction of M, Goal occurs in I iff it occur
in some Run(uv), so Goal /∈ I.

B Proofs for Section 5
We ﬁx for this whole appendix part a split (Σ1, Σ2) of Σ fulﬁlling the condition of Item 2 of Lemma 18,
and Σ(cid:48)

3 built from Σ1, Σ2 as described in the body of the paper.

1, Σ(cid:48)

2, Σ(cid:48)

1. The world structure of I is the graph

Proof of Proposition 19
Deﬁnition 6 (World Structure). Let I be an interpretation of Σ(cid:48)
(V, E) where:
• V = {w | Done(w) ∈ I}
• E = {(w, w(cid:48)) | w (cid:54)= w(cid:48) ∧ ∃p∃(cid:126)x Insp((cid:126)x, w, w(cid:48)) ∈ I}
Lemma 31. For every D over Sin(Σ), the world structure of a model I of D and Σ(cid:48)
chase sequence is a ﬁnite tree, such that:
• its root is the unique element w such that Empty(w) ∈ I;
• if (w, w(cid:48)) ∈ E, then world(w(cid:48)) = world(w) ∪ {p((cid:126)x)} for some atom p((cid:126)x), and p((cid:126)x) (cid:54)∈ world(w);
• if Init(w) ∈ I and p((cid:126)a) ∈ D \ world(w), there exists w(cid:48) such that Insp((cid:126)a, w, w(cid:48)) ∈ I.

1 generated by a

Proof. Let us ﬁrst notice that Rule (58) is applicable exactly once, as its frontier is empty. The null it
creates, say w∅, is then the only one such that Empty(w∅) ∈ I. Moreover, there is no edge incoming in
w∅ in the world structure, as the only rules Rules (59), (60) and (61) that introduce an atom of the shape
Insp((cid:126)x, w, w(cid:48)) with w (cid:54)= w(cid:48) are such that w(cid:48) is existentially quantiﬁed. For the same reason, note that
there is at most one edge incoming in any vertex in the world structure.

Next notice that no new null is created unless Rules (59), (60) or (61) are applied, and they all must be
applied by mapping w to an element of the world structure, as Done(w) is in the body of each of these
rules. Hence the world structure is connected, and is thus a tree of root w∅.

Now let us notice that in any interpretation I generated by a sequence of rule applications, if
Done(w) ∈ I, then worldI(w) = worldI(cid:48)(w) for any I (cid:48) obtained by extending the sequence of rule
applications that generated I. Indeed, the only way to derive Done(w) is to apply Rule (63), which re-
quires the atoms Empty(w∅) and Subs(w∅, w), as w∅ is the only element for which Empty holds. The
only way to create an atom of the shape Subs(w0, w2) with w0 (cid:54)= w2 is by applying an instantiation
of Rule (62), which can be applied if w0 is a parent of w1 in the world structure, and w1 is such that
Subs(w1, w2) holds. Hence Done(w) is entailed only when Rule (62) as been applied by mapping w0
to every ancestor of w and w2 to w, which has a effect to ensure that worldI(w) contains all the atoms
possibly present in worldI(cid:48)(w).

If (w, w(cid:48)) ∈ E, then w(cid:48) has been created by the application of Rule (59), (60) or (61). In all cases,
Done(w) must hold at the time of the rule application. If it is by Rule (59) and substitution σ, then
p(σ((cid:126)x)) cannot belong to world(w), as this would make Rule (59) not applicable with σ. By the sequence
of rule applications described before, world(w(cid:48)) = world(w)∪{p(σ((cid:126)x))}. Rules (60) and (61) are treated
in a similar way.

Both the depth and the arity of the world structure is thus upper bounded by the number of atoms using

a predicate appearing in Σ1 ∪ Σ2 and nulls from D.

For the last item, let us notice that if Init(w) ∈ I, and p((cid:126)a) ∈ D \ world(w), then Rule (59)
instantiated for p is applicable by mapping (cid:126)x to (cid:126)a. Applying that rule will create a fresh null w(cid:48) which
will fulﬁll the conditions stated in the lemma.

Lemma 32. Let D be a database over Sin(Σ), and let I be a model of D and Σ(cid:48)
1 generated by a chase
sequence. Let v ∈ Nulls(I) such that Done(v) ∈ I. If a disjunctive rule ρ is applicable to world(v) by σ,
then there exist in I two elements w1 and w2 such that Insp1((cid:126)u1, v, w1) and Insp2((cid:126)u2, v, w2) such that
p1((cid:126)u1) and p2((cid:126)u2) are the two atoms created by the application of (cid:104)ρ, σ(cid:105).

Proof. Let us ﬁrst notice that σ, extended by mapping w to v, is a substitution that maps the bodies of
Rules (60) and (61) to I, by deﬁnition of world(v) and since Done(v) ∈ I. As I is a model of Σ(cid:48)
1,
the head of these two rules should be also mappable in I, hence there exists w1 and w2 fulﬁlling the
conditions of the lemma.

Note that Proposition 19 is a direct consequence of Lemmas 31 and 32.

Proof of Lemma 18
Deﬁnition 7 (Saturated World of a Null in an Interpretation). Let w be a null in an interpretation I such
that Subs(w, w) ∈ I. The saturated world of w is deﬁned by saturatedWorldI(w) = {p((cid:126)x) | p(cid:48)((cid:126)x, w) ∈
I}.
Lemma 33. If there is a chase tree w.r.t. (Σ(cid:48)
2) and D whose unique leaf I is such that there exists
w∗ ∈ Nulls(I) s.t. Goal ∈ saturatedWorldI(w∗) and Done(w∗) ∈ I, then there exists a chase tree w.r.t
Σ2 and world(w∗) whose unique leaf contains Goal.

1 ∪ Σ(cid:48)

Proof. Let us consider a chase tree T (cid:48) w.r.t. (Σ(cid:48)
2) and D, and let w∗ be such that Done(w∗)
is in the result I of T (cid:48). We show that there exists a chase tree T w.r.t Σ2 and world(w∗) such that
saturatedWorldI(w∗) is mapped to the label of the (unique) leaf of T by a homomorphism ψ.

1 ∪ Σ(cid:48)

For every label J of a node in T (cid:48) such that Done(w∗) ∈ J , we show that there exists a preﬁx of a
chase tree w.r.t. Σ2 and world(w∗) such that saturatedWorldJ (w∗) is mapped to the label of the leaf
of that preﬁx by a homomorphism ψ. We do this by induction on the number of rule applications (cid:104)ρ, h(cid:105)
with ρ of the form Rule (64) and h(w) = w∗ that are done in T (cid:48) before the node labelled by J .

• If no rule application of the shape (cid:104)ρ, h(cid:105) with h(w) = w∗ is performed in T (cid:48) before J , then
saturatedWorldJ (w∗) = world(w∗). We thus deﬁne ψ as the identity, and the chase tree preﬁx con-
sisting of the root labelled by world(w∗) fulﬁlls the property.

• Assume that the property is true for every J obtained in T (cid:48) after at most i−1 applications of the shape
(cid:104)ρ(cid:48), h(cid:105) with ρ(cid:48) of the form Rule (64) and h(w) = w∗. Let Ji be obtained in T (cid:48) after i such applications
and let (cid:104)ρ(cid:48), h(cid:105) be the last one, with ρ(cid:48) being the instantiation of Rule (64) for ρ ∈ Σ2. Let Ji−1 be the
label of the node in T (cid:48) on which (cid:104)ρ(cid:48), h(cid:105) is applied. By induction assumption, there exist ψ and a preﬁx
of a chase tree for Σ2 and D, resulting in Si−1, such that ψ(saturatedWorldJi−1 (w∗)) ⊆ Si−1. Hence
(cid:104)ρ, ψ ◦ h|Terms(Bρ)(cid:105), where Bρ is the body of ρ, is applicable on Si−1, creating a new leaf, labeled by
Si, and we extend ψ by mapping every null created by the instantiation of zi ∈ (cid:126)z in the application of
(cid:104)ρ(cid:48), h(cid:105) to the null created by the instantiation of zi ∈ (cid:126)z in the application of (cid:104)ρ, ψ ◦ h|Terms(Bρ)(cid:105). We
obtain ψ(saturatedWorldJi(w∗)) ⊆ Si.

Lemma 34. Any restricted chase w.r.t Σ(cid:48)
chase in which rules from Σ(cid:48)

1 ∪ Σ(cid:48)
1 are applied before rules from Σ(cid:48)

3 can be transformed into an equivalent restricted
2, which are applied before rules from Σ(cid:48)
3.

2 ∪ Σ(cid:48)

3 can be applied last. Note that head predicates of Σ(cid:48)

Proof. Notice that head predicates of Σ(cid:48)
Σ(cid:48)
a rule of Σ(cid:48)
rules of Σ(cid:48)
application of a rule of Σ(cid:48)
2.

j with j < 3. Hence rules of
1. Moroever,
2 is applicable by mapping w to w∗ only if Done(w∗) as been derived. Further applications of
1 cannot add an atom of the shape p(cid:48)((cid:126)x, w∗), and thus applying them before do not prevent the

2 do not appear as body predicates of Σ(cid:48)

3 do not appear in do not appear in Σ(cid:48)

Proposition 35. For every database D over Sin(Σ), if Σ1∪Σ2, D |= Goal, then Σ(cid:48)

1∪Σ(cid:48)

2∪Σ(cid:48)

3, D |= Goal.

Proof. Let us consider a ﬁnite a chase tree T proving that Σ1 ∪ Σ2, D |= Goal and such that rules of
Σ1 are applied before rules of Σ2 (this is possible by deﬁnition of Σ1 and Σ2 that form a split of Σ).
We build a chase tree proving that Σ(cid:48)
3, D |= Goal (we actually describe a sequence of rule
applications, as Σ(cid:48)

2 ∪ Σ(cid:48)
3 contains only deterministic rules).

1 ∪ Σ(cid:48)

1 ∪ Σ(cid:48)

2 ∪ Σ(cid:48)

• Apply Rule (58), creating a fresh null w∅ and facts Init(w∅), Done(w∅) and Empty(w∅).
• Until creation of wD, perform the following:

– let wD(cid:48) be the last introduced null;
– let p((cid:126)a) ∈ D \ D(cid:48):
* apply Rule (59), instantiated for p, by mapping (cid:126)x to (cid:126)a and w to wD(cid:48), creating a fresh null

wD(cid:48)∪{p((cid:126)a)};

* apply Rule (62) as many times as necessary until Subs(w∅, wD(cid:48)∪{p((cid:126)a)}) is created, which makes
Rule (63) become applicable by mapping w(cid:48) to wD(cid:48)∪{p((cid:126)a)}. Then apply Rule (63) and add
Done(wD(cid:48)∪{p((cid:126)a)}).

• At the end of the above loop, note that we have created null wD and added in particular Done(wD) as

well as Insp((cid:126)a, wD, wD) and for every p((cid:126)a) ∈ D.

• Let r be the root node of T . Note that r is labelled by D. In what follows, we will introduce some
nulls wN such that N is the label of some node n in T and it will remain true that Done(wN ) as well
as Insp((cid:126)a, wN , wN ) for every p((cid:126)a) ∈ N are introduced between the creation of wN and the creation
of the next wN (cid:48).

• Deﬁne ψ(r) = wD and let N = {r} and L = ∅. Until N = ∅, perform the following.

– Consider the case where n is a node of T labelled by N such that ψ(n) = wN and n has 2
children c1 and c2 labelled by N1 and N2 respectively, which correspond to the application of
(cid:104)ρ, σ(cid:105) with ρ ∈ Σ1 of the form (cid:86)
p((cid:126)x)∈β p((cid:126)x) → p1( (cid:126)x1) ∨ p2( (cid:126)x2). We have N1 = N ∪ {p1((cid:126)a1)}
and N2 = N ∪ {p2((cid:126)a2)} where (cid:126)a1 = σ((cid:126)x1) and (cid:126)a2 = σ((cid:126)x2). The instantiations of (60) and (61)
corresponding to ρ are applicable through σ(cid:48), which maps w to wN and (cid:126)x to σ((cid:126)x).
* Apply Rule (60),

that we call wN1 and adding in particular
Insp1 ((cid:126)a1, wN1 , wN1). Then apply Rule (62) as many times as necessary, then Rule (63) so that
Done(wN1) is created. Deﬁne ψ(c1) = wN1.

introducing a fresh null

* If Rule (61) is not applicable, it implies that p1 = p2 and (cid:126)a1 = (cid:126)a2, so that N1 = N2. Set

N = (N ∪ {c1}) \ {n}, and set ψ(c2) = wN1.

* Otherwise apply Rule (61), introducing a fresh null that we call wN2 and adding in particular
Insp2 ((cid:126)a2, wN2, wN2).Then apply Rule (62) as many times as necessary, then Rule (63) so that
Done(wN2 ) is created. Deﬁne ψ(c2) = wN2 and set N = (N ∪ {c1, c2}) \ {n}.

– If n is a node of T having only one child, set L = L ∪ {n} and N = N \ {n}.

At this point, for every n ∈ L, ψ(n) = wN and if I denotes the current set of facts built by our derivation,
saturatedWorldI(ψ(n)) = N by construction.

For all n ∈ L, the next rule applied on n is a rule from Σ2, hence no more rule of Σ1 are applied on a
descendant of n in T (by assumption on T ). All rule applications below n are thus deterministic, and we
“copy” that derivation. Let ψn be the identity mapping from the label N of n to saturatedWorldI(ψ(n)).

By construction, ψn is a homomorphism. While we extend I by applying new rules, we will extend ψn
into a homomorphism from the label of any descendant n(cid:48) of n in T to saturatedWorldI(ψ(n)).
• For n(cid:48) = n, this is already done.
• Assume that we have built a derivation such that ψn is a homomorphism from the label N (cid:48) of some
descendant n(cid:48) of n in T to saturatedWorldI(ψ(n)). Let n(cid:48)(cid:48) be the child of n(cid:48) in T , labelled by N (cid:48)(cid:48),
and let (cid:104)ρ, σ(cid:105) be the rule application creating n(cid:48)(cid:48), where ρ ∈ Σ2 . Then (cid:104)ρ, ψn ◦ σ(cid:105) can be applied to
saturatedWorldI(ψ(n)), and thus Rule (64), instantiated for ρ is applicable in I by extending ψn ◦ σ
by mapping w to ψ(n). We then deﬁne ψ(n(cid:48)(cid:48)) = ψ(n), and extend ψn by mapping each null created
in the label of n(cid:48)(cid:48) by a variable zi to the null created by variable zi in the application of Rule (64).
Let T (cid:48) be the tree structure having ψ(r) = wD as root and where wp is parent of wc if wc has been
created by an application of Rule (60) or Rule (61), that mapped w to wp. Note that all the wn in this
tree structure are exactly the nulls of I such that there exists a node n in T with ψ(n) = wn, c1, c2 are
children of n in T iff ψ(c1), ψ(c2) are children of ψ(n) in T (cid:48).

Let (cid:96) be a leaf of T . By assumption, Goal belongs to the label of (cid:96). Let n be the unique node in L such
that (cid:96) is a descendant of n. Since ψn is a homomorphism from the label of (cid:96) to saturatedWorldI(ψ(n)),
it holds that saturatedWorldI(ψ(n)) contains Goal. By deﬁnition of saturatedWorldI, it follows that
Goal(cid:48)(ψ(n)) ∈ I. Since any leaf wn of T (cid:48) has an antecedent n by ψ which has a descendant leaf (cid:96) in T ,
then Goal(cid:48)(w) holds for each leaf w of T (cid:48). Extend the derivation as follows:
• Apply Rule (65) to each w leaf of T (cid:48).
• If Acc(w) has already been derived for the children w of a node ψ(n) in T (cid:48), let ρ be the rule that has
been applied by σ on n to create its children. Apply Rule (66) instantiated for ρ by mapping w1 and
w2 to ψ(c1) and ψ(c2), where c1 and c2 are the children of n corresponding to the application of ρ.
Acc(ψ(n)) is thus derived.

• By induction on the depth, one derives Acc(wD). As Init(wD) holds, one can apply Rule (67) and

obtain Goal.

We did not apply every possible rule: hence, to build a chase tree, we must ensure fairness (point 3. of
the deﬁnition of chase tree), by applying all possible remaining rule applications, which concludes the
proof.

To ease that proof, we will actually replace Rule (66) by the following rule:

Insp1 ((cid:126)x1, w, w1) ∧ Acc(w1) ∧
Insp2 ((cid:126)x2, w, w2) ∧ Acc(w2) ∧
p((cid:126)x)∈β Insp((cid:126)x, w, w)

(cid:86)

→ Accρ(w, w1, w2) ∧ Acc(w)

(68)

which has an additional ternary fresh predicate describing the rule ρ ∈ Σ1 (and the worlds generated by
the corresponding rule application) allowing to derive Acc(w). Note that since Accρ not being appearing
anywhere else, all the properties shown so far are still valid.
1∪Σ(cid:48)
Proposition 36. For every database D over Sin(Σ), if Σ(cid:48)
Proof. Let I be a model of D and Σ(cid:48)
3 obtained through a restricted chase sequence such that
Goal ∈ I. We build a chase tree T for Σ1 ∪ Σ2 and D(cid:48) for some D(cid:48) ⊆ D such that Goal is in the label
of every leaf of T .

3, D |= Goal then Σ1∪Σ2, D |= Goal.

2 ∪ Σ(cid:48)

1 ∪ Σ(cid:48)

2∪Σ(cid:48)

Let wD(cid:48) ∈ Nulls(I) be such that Rule (67) is applied on it, with world(wD(cid:48)) = D(cid:48). Set W = {wD(cid:48)},

and perform the following until W = ∅.
• Let w ∈ W . If Goal(cid:48)(w) ∈ I, set W = W \ {w}.

• Otherwise, there must be some Accρ(w, w1, w2) ∈ I, as the only way to derive Acc(w) if Goal(cid:48)(w)
does not hold is to apply some instantiation for some ρ of Rule (68) by some mapping σ. Moreover,
there must be such an atom for which w1 and w2 are different from w. Consider (cid:104)ρ, σTerms(ρ)(cid:105): it is
applicable, as σ maps the body of ρ to world(w), and none of the two atoms in the head are present
in world(w) (otherwise, w would be equal to w1 or to w2). Performing this rule application adds two
children to the node of T labelled by world(w), of respective labels world(w1) and world(w2). Set
W = (W \ w) ∪ {w1, w2}.

As the tree structure of I is ﬁnite, and that at each step, either the size of W is decreasing, or the null w
considered is replaced by two nulls w1 and w2 such that world(w1) and world(w2) are labels of nodes
of strictly greater depth than world(w) in that tree, the above process terminates. Moreover, for each leaf
of the considered preﬁx of T , it holds that its label and Σ2 entail Goal, by Lemma 33 and the fact that
each leaf is labelled by some world(w) such that Goal(cid:48)(w) ∈ I (so that Goal ∈ saturatedWorldI(w)).
Hence, one can expand T in such a way that all its leaves are labeled by sets containing Goal, which
concludes the proof.

Lemma 37. For every database D over Sin(Σ), (cid:104)Σ(cid:48)

1 ∪ Σ(cid:48)

2 ∪ Σ(cid:48)

3, D(cid:105) is chase-terminating.

1 are applied ﬁrst, then rules from Σ(cid:48)

Proof. By Lemma 34, chase sequences can be reordered without changing the number of rule applica-
tions such that rules from Σ(cid:48)
3. Lemma 31 implies
that rules from Σ(cid:48)
1 cannot be triggered indeﬁnitely. As the tree structure is ﬁnite, if there are inﬁnitely
many rule applications performed with a rule from Σ(cid:48)
2, there must be one world null w∗ such that there
2 that are performed mapping w to w∗. By the construction of Proposi-
are inﬁnitely many rules of Σ(cid:48)
tion 36, it implies that there exists a database over Sin(Σ2) for which Σ2 does not terminate, which is
against our assumptions on Σ2. Finally, Σ(cid:48)
3 does not contain any existentially quantiﬁed variable, hence
only ﬁnitely many rules can be triggered.

2, then rules from Σ(cid:48)

Lemma 18 is a direct consequence of Propositions 35, 36 and Lemma 37.

Lemma 23. The set M is not enumerable up to equivalence.

C Proofs of Section 6

Proof by Contradiction.

1. Suppose for a contradiction that the lemma does not hold. Then, there is an enumerator P that outputs
a sequence of TMs that includes M up to equivalence. That is, the enumerator P outputs an inﬁnite
sequence M1, M2, . . . of TMs such that:
• For each i ≥ 1, we have that Mi ∈ M.
• For each M ∈ M, there is some i ≥ 1 such that M and Mi are equivalent.
Two TM M and M (cid:48) are equivalent if, for each word w, we have that M accepts w iff M (cid:48) accepts w.
2. Consider the sequence p1, p2, . . . of natural numbers such that p1 = 1 and pi is the smallest prime

with pi > pi−1 for each i ≥ 2. Note that this sequence is inﬁnite by Euclid’s theorem.

3. By (2):

there is an inﬁnite sequence D1, D2, . . . of databases such that Di = {ed(u1, u2),

. . . , ed(upi+1, u1)} for each i ≥ 1.

4. Consider the TM Md that, on input w, performs the computation:

(a) Check if w corresponds to a database D that only contains facts deﬁned over ed. If this is not the

case, then reject.

(b) If D can be homomorphically embedded into a database such as {ed(u1, u2), . . . , ed(uk−1, uk)}

where k is smaller or equal than the number of nulls in D, then reject.

(c) If ed(u, u) ∈ D for some null u, then accept.

(d) If there is some i ≥ 1 such that (i) there are less or the same number of nulls in Di than in D, (ii) Mi
accepts some serialisation that corresponds to Di, and (iii) there is a homomorphism h : D → Di;
then reject. Otherwise, accept.

5. By (4): the TM Md halts on all inputs. Note the following remarks about instruction (4.d):

• The TM Mi accepts some serialisation that corresponds to Di if Mi accepts any such serialisation.
Therefore, for each instantiation of i, the TM Md only needs to check one (arbitrarily chosen)
serialisation of Di when executing (4.d).

• When executing (4.d), the TM Md only needs to check a ﬁnite amount of instantiations of i ≥ 1

before rejecting with conﬁdence due to condition (4.d.i).

6. After this enumeration, we prove that Md does satisfy (iii) in Deﬁnition 5 by contradiction.
7. By (4.a), (5), and (6): the TM Md is in M.
8. By (4): Md diagonalises over M1, M2, . . . and D1, D2, . . . That is, for any given i ≥ 1, Md accepts

Di iff Mi rejects Di.
• If Mi accepts Di, then Md rejects Di in (4.d).
• If Mi rejects Di, then Md accepts Di in (4.d). Note that, if we assume that Md rejects Di in this
case we obtain a contradiction; namely, we can conclude that p evenly divides q for some prime
numbers p, q > 1 with p (cid:54)= q.

9. Contradiction by (1), (7), and (8): the enumerator P is incomplete since it fails to print out a TM that

is equivalent to Md, which is in M.

Suppose for a contradiction that there are some words w and v that correspond to some databases D
and E such that D and E only contain facts deﬁned over ed, Md accepts D, Md rejects E, and there
is some homomorphism h : D → E. We conduct a case-by-case analysis to show that this assumption
results in a contradiction:

• Assume that D is accepted due to instruction (4.c). Then, ed(u, u) ∈ D for some null u and hence,

ed(t, t) ∈ E for some null t since h : D → E. Therefore, Md accepts E due to (4.c) (

• Assume that D is accepted due instruction (4.d). Two possible cases arise:

).

(cid:32)

– By deﬁnition E is a database that only contains facts deﬁned over the predicate ed. Hence, E cannot

be rejected due to (4.a).

– If E is rejected due to (4.b), then E can be hom-embedded into a path over ed. Therefore, D can

also be hom-embedded into the same path since h : D → E and Md rejects D due to (4.b) (

).

– Assume that E is rejected due to instruction (4.d).
1. There is some i ≥ 1 and a homomorphism g such that (i) the number of nulls in i is smaller than

the number of nulls in E, (ii) g : E → Di, and (iii) the TM Mi accepts the database Di.

2. By (1): g ◦ h : D → Di.
3. If we assume that pi+1 is smaller or equal than the number of nulls in D, then Md rejects D due

to (4.d) (

). Therefore, we conclude that pi+1 is strictly greater than the number of nulls in D.

4. If we assume that D can be homomorphically embedded into a path over ed, then Md rejects D

(cid:32)

(cid:32)

due to (4.b). Hence, we assume that this is not the case.

5. We obtain a contradiction from (2), (3), and (4).

