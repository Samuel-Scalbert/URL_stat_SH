A Single Approach to Decide Chase Termination on
Linear Existential Rules
Michel Leclère, Marie-Laure Mugnier, Michaël Thomazo, Federico Ulliana

To cite this version:

Michel Leclère, Marie-Laure Mugnier, Michaël Thomazo, Federico Ulliana. A Single Approach to
Decide Chase Termination on Linear Existential Rules. ICDT 2019 - 22nd International Conference
on Database Theory, Mar 2019, Lisbonne, Portugal. pp.18:1–18:19, ￿10.4230/LIPIcs.ICDT.2019.18￿.
￿lirmm-02148200￿

HAL Id: lirmm-02148200

https://hal-lirmm.ccsd.cnrs.fr/lirmm-02148200

Submitted on 5 Jun 2019

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution 4.0 International License

A Single Approach to Decide Chase Termination
on Linear Existential Rules

Michel Leclère
University of Montpellier, CNRS, Inria, LIRMM, France
leclere@lirmm.fr

Marie-Laure Mugnier
University of Montpellier, CNRS, Inria, LIRMM, France
mugnier@lirmm.fr

Michaël Thomazo
Inria, DI ENS, ENS, CNRS, PSL University, France
michael.thomazo@inria.fr

Federico Ulliana
University of Montpellier, CNRS, Inria, LIRMM, France
ulliana@lirmm.fr

Abstract

Existential rules, long known as tuple-generating dependencies in database theory, have been
intensively studied in the last decade as a powerful formalism to represent ontological knowledge in
the context of ontology-based query answering. A knowledge base is then composed of an instance
that contains incomplete data and a set of existential rules, and answers to queries are logically
entailed from the knowledge base. This brought again to light the fundamental chase tool, and
its diﬀerent variants that have been proposed in the literature. It is well-known that the problem
of determining, given a chase variant and a set of existential rules, whether the chase will halt on
any instance, is undecidable. Hence, a crucial issue is whether it becomes decidable for known
subclasses of existential rules. In this work, we consider linear existential rules with atomic head, a
simple yet important subclass of existential rules that generalizes inclusion dependencies. We show
the decidability of the all-instance chase termination problem on these rules for three main chase
variants, namely semi-oblivious, restricted and core chase. To obtain these results, we introduce a
novel approach based on so-called derivation trees and a single notion of forbidden pattern. Besides
the theoretical interest of a uniﬁed approach and new proofs for the semi-oblivious and core chase
variants, we provide the ﬁrst positive decidability results concerning the termination of the restricted
chase, proving that chase termination on linear existential rules with atomic head is decidable for
both versions of the problem: Does every chase sequence terminate? Does some chase sequence
terminate?

2012 ACM Subject Classiﬁcation Theory of computation → Logic; Computing methodologies →
Knowledge representation and reasoning

Keywords and phrases Chase, Tuple Generating Dependencies, Existential rules, Decidability

Digital Object Identiﬁer 10.4230/LIPIcs.ICDT.2019.18

Related Version https://arxiv.org/abs/1810.02132

Acknowledgements We thank the reviewers for their insightful comments, as well as Antoine Amarilli
for Example 21, which is simpler than a previous example and shows that the fairness issue already
occurs with binary predicates.

© Michel Leclère, Marie-Laure Mugnier, Michaël Thomazo, and Federico Ulliana;
licensed under Creative Commons License CC-BY

22nd International Conference on Database Theory (ICDT 2019).
Editors: Pablo Barcelo and Marco Calautti; Article No. 18; pp. 18:1–18:19

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

18:2

A Single Approach to Decide Chase Termination on Linear Existential Rules

1

Introduction

The chase procedure is a fundamental tool for solving many issues involving tuple-generating
dependencies, such as data integration [21], data-exchange [11], query answering using views
[16] or query answering on probabilistic databases [24]. In the last decade, tuple-generating
dependencies raised a renewed interest under the name of existential rules for the problem
known as ontology-based query answering. In this context, the aim is to query a knowledge
base (I, Σ), where I is an instance and Σ is an ontology given as a set of existential rules
(see e.g. the survey chapters [5, 23]). In more classical database terms, this problem can
be recast as querying an instance I under open-world assumption, provided with a set
of constraints Σ, which are tuple-generating dependencies. The chase is a fundamental
tool to solve dependency-related problems as it allows one to compute a (possibly inﬁnite)
universal model of (I, Σ), i.e., a model that can be homomorphically mapped to any other
model of (I, Σ). Hence, the answers to a conjunctive query (and more generally to any kind
of query closed by homomorphism) over (I, Σ) can be deﬁned by considering solely this
universal model.

Several variants of the chase have been introduced, and we focus in this paper on the
main ones: semi-oblivious [22] (aka Skolem [22]), restricted [3, 11] (aka standard [25]) and
core [9]. Any chase variant starts from an instance and exhaustively performs a sequence
of non-redundant rule applications according to a redundancy criterion which characterizes
the variant itself. The built sequence is required to be fair, i.e., no rule application deemed
non-redundant can be indeﬁnitely left out. It is well known that all the above variants
produce homomorphically equivalent results but obey increasingly stronger redundancy
criteria, hence terminate for increasingly larger subclasses of existential rules.

The question of whether a chase variant terminates on all instances for a given set of
existential rules is known to be undecidable when there is no restriction on the kind of rules
[1, 12]. A number of suﬃcient syntactic conditions for termination have been proposed in
the literature for the semi-oblivious chase (see e.g.
[25, 15, 27] for syntheses), as well as
for the restricted chase [8] (note that the latter paper also deﬁnes a suﬃcient condition
for non-termination). However, only few positive results exist regarding the termination
of the chase on speciﬁc classes of rules. Decidability was shown for the semi-oblivious
chase on guarded-based rules (linear rules, and their extension to (weakly-)guarded rules)
[4]. Decidability of the core chase termination on guarded rules for a ﬁxed instance was
shown in [17].

In this work, we provide new insights on the chase termination problem for linear
existential rules with atomic head, a simple yet important subclass of guarded existential
rules, which generalizes inclusion dependencies [10] and some practical ontological languages
[6]. When we are interested in the ontology-based query answering problem, we note that
linear rules are ﬁrst-order rewritable, hence answering conjunctive queries on linear rule
knowledge bases can be solved by query rewriting [1, 13, 18]. However, it is well known that
the size and the unusual form of the rewritten query may lead to practical eﬃciency issues.
Hence, the materialization of ontological inferences in the data is often an eﬀective alternative
to query rewriting, provided that some chase algorithm terminates. Finally, having the choice
of how to process a set of linear rules extends the applicability of query answering techniques
that combine query rewriting and materialization [1].

Precisely, the question of whether a chase variant terminates on all instances for a set of

linear existential rules with atomic head is studied in two fashions:

does every chase sequence terminate?

does some chase sequence terminate?

M. Leclère, M.-L. Mugnier, M. Thomazo, and F. Ulliana

18:3

It is well-known that these two questions have the same answer for the semi-oblivious and
the core chase variants, but not for the restricted chase. Indeed, this last one may admit
both terminating and non-terminating sequences over the same knowledge base. We show
that the termination problem is decidable for linear existential rules with atomic head, no
matter which version of the problem and which chase variant we consider.

We study chase termination by exploiting in a novel way a graph structure, namely the
derivation tree, which was originally introduced to solve the ontology-based (conjunctive)
query answering problem for the family of greedy-bounded treewidth sets of existential rules
[2, 28], a class that generalizes guarded-based rules and in particular linear rules. We ﬁrst use
derivation trees to show the decidability of the termination problem for the semi-oblivious
and restricted chase variants, and then generalize them to entailment trees to show the
decidability of termination for the core chase. For every chase variant we consider, we adopt
the same high-level procedure: starting from a ﬁnite set of canonical instances (representative
of all possible instances), we build a (set of) tree structures for each canonical instance, while
forbidding the occurrence of a speciﬁc pattern, that we call unbounded-path witness. The
structures that we build are ﬁnite thanks to this forbidden pattern, and this allows us to
decide if the chase terminates on the associated canonical instance. By doing so, we obtain
a uniform approach to study the termination of several chase variants, which we believe
to be of theoretical interest per se. In particular, some important diﬀerences in the chase
behaviors become more visible. The derivation tree is moreover a simple structure, which
makes the algorithms built on it eﬀectively implementable. Let us also point out that our
approach is constructive: if the chase terminates on a given instance, the algorithm that
decides termination actually computes the result of the chase (or a superset of it in the case
of the core chase), otherwise it pinpoints a forbidden pattern responsible for non-termination.

Besides providing new theoretical tools to study chase termination for linear existential

rules with atomic head, we obtain the following results:

a new proof of the decidability of the semi-oblivious chase termination, building on
diﬀerent objects than the previous proof provided in [4]; we show that our algorithm
provides the same complexity upper-bound;

the decidability of the restricted chase termination, for both versions of the problem, i.e.,
termination of all chase sequences and termination of some chase sequence; to the best
of our knowledge, these are the ﬁrst positive results on the decidability of the restricted
chase termination;

a new proof of the decidability of the core chase termination, with diﬀerent objects than
previous work reported in [17]; although this latter paper solves the question of the core
chase termination given a ﬁxed instance, the results actually allow to infer the decidability
of the all-instance version of the problem (still on linear rules), by noticing that only a
ﬁnite number of instances need to be considered (see the next section).

The paper is organized as follows. After introducing some preliminary notions (Section 2),
we deﬁne the main components of our framework, namely derivation trees and unbounded-
path witnesses (Section 3). We build on these objects to prove the decidability of the
semi-oblivious and restricted chase termination (Section 4). Finally, we generalize derivation-
trees to entailment trees and use them to prove the decidability of the core chase termination
(Section 5). Detailed proofs are provided in [19]. A previous version of this work was
presented as an extended abstract in [20].

I C D T 2 0 1 9

18:4

A Single Approach to Decide Chase Termination on Linear Existential Rules

2

Preliminaries

We consider a logical vocabulary composed of a ﬁnite set of predicates and an inﬁnite set
of constants. An atom α has the form r(t1, . . . , tn) where r is a predicate of arity n and
the ti are terms (i.e., variables or constants). We denote by terms(α) (resp. vars(α)) the
set of terms (resp. variables) in α and extend the notations to a set of atoms. A ground
atom does not contain any variable. It is convenient to identify (the existential closure of) a
conjunction of atoms with the set of these atoms. A set of atoms is atomic if it contains a
single atom. An instance is a set of (non-necessarily ground) atoms, which is ﬁnite unless
otherwise speciﬁed. Abusing terminology, we will often see an instance as its isomorphic
model.

Given two sets of atoms S and S0, a homomorphism from S0 to S is a substitution
π of vars(S0) by terms(S) such that π(S0) ⊆ S. It holds that S |= S0 (where |= denotes
classical logical entailment) iﬀ there is a homomorphism from S0 to S. An endomorphism of
S is a homomorphism from S to itself. A set of atoms is a core if it admits only injective
endomorphisms. Any ﬁnite set of atoms is logically (or: homomorphically) equivalent to
one of its subsets that is a core, and this core is unique up to isomorphism (i.e., bijective
variable renaming). Given sets of atoms S and S0, we say that S0 folds onto S if there is a
homomorphism π from S0 \ S to S such that π is the identity on vars(S). The homomorphism
π is called a folding. In particular, it is well-known that any set of atoms folds onto its core.

An existential rule (or simply rule) is of the form σ = ∀x∀y [body(x, y) → ∃z head(x, z)]
where x, y and z are pairwise disjoint tuples of variables, body(x, y) and head(x, z) are
non-empty conjunctions of atoms respectively on x ∪ y and x ∪ z, called the body and the
head of the rule, and also denoted by body(σ) and head(σ). The variables of z are called
existential variables. The variables of x form the frontier of σ, which is also denoted by fr(σ).
For brevity, we will omit universal quantiﬁers in the examples. A knowledge base (KB) is of
the form K = (I, Σ), where I is an instance and Σ is a ﬁnite set of existential rules.

A rule σ = body(σ) → head(σ) is applicable to an instance I if there is a homomorphism
π from body(σ) to I. The pair (σ, π) is called a trigger for I. The result of the application of
σ according to π on I is the instance I 0 = I ∪ πs(head(σ)), where πs extends π by assigning
a distinct fresh variable (also called a null) to each existential variable.1 We also say that I 0
is obtained by ﬁring the trigger (σ, π) on I. By π|fr(σ) we denote the restriction of π to the
domain fr(σ).

(cid:73) Deﬁnition 1 (Derivation). A Σ-derivation (or simply derivation when Σ is clear from the
context) from an instance I = I0 to an instance In is a sequence I0, (σ1, π1), I1 . . . , (σn, πn), In,
such that for all 1 ≤ i ≤ n: σi ∈ Σ, (σi, πi) is a trigger for Ii−1, Ii is obtained by ﬁring
(σi, πi) on Ii−1, and Ii 6= Ii−1. The notion of derivation can be naturally extended to an
inﬁnite sequence.

Note that the condition Ii 6= Ii−1 in the above deﬁnition implies that all triggers in a
derivation produce distinct atoms. We brieﬂy introduce below the main chase variants and
refer to [25] for a detailed presentation.

The semi-oblivious chase prevents several applications of the same rule through the same
mapping of its frontier. Given a derivation from I0 to Ii, a trigger (σ, π) for Ii is said to
be active according to the semi-oblivious criterion, if (1) there is no trigger (σj, πj) in the

1 The “s” superscript stands for safe, as newly introduced variables are fresh, hence cannot be confused

with already existing variables.

M. Leclère, M.-L. Mugnier, M. Thomazo, and F. Ulliana

18:5

derivation with σ = σj and π|fr(σ) = πj|fr(σj ) and (2) the extension of Ii with (σ, π) remains a
derivation, i.e., π(head(σ)) 6⊆ Ii. The restricted chase performs a rule application only if the
added set of atoms is not redundant with respect to the current instance. Given a derivation
from I0 to Ii, a trigger (σ, π) for Ii is said to be active according to the restricted criterion
if π cannot be extended to a homomorphism from (body(σ) ∪ head(σ)) to Ii (equivalently,
πs(head(σ)) does not fold onto Ii). We say that a (possibly inﬁnite) derivation is a semi-
oblivious (resp. restricted) derivation if it is built by ﬁring only active triggers according to
the semi-oblivious (resp. restricted) criterion. A (possibly inﬁnite) derivation is fair if no
ﬁring of an active trigger is indeﬁnitely delayed; formally: if some Ii in the derivation admits
an active trigger (σ, π), then there is j > i such that, either Ij is obtained by ﬁring (σ, π) on
Ij−1, or (σ, π) is not an active trigger anymore on Ij. A terminating derivation is a ﬁnite
fair derivation (in other words, a ﬁnite derivation that does not admit any active trigger on
its ﬁnal instance). A semi-oblivious (resp. restricted) chase sequence is a fair semi-oblivious
(resp. restricted) derivation. Hence, a chase sequence is terminating if and only if it is ﬁnite.

In its original deﬁnition [9], the core chase proceeds in a breadth-ﬁrst manner, and, at
each step, ﬁrst ﬁres in parallel all active triggers according to the restricted chase criterion,
then computes the core of the result. Alternatively, to bring the deﬁnition of the core chase
closer to the above deﬁnitions of the semi-oblivious and restricted chases, one can deﬁne
a core derivation as a possibly inﬁnite sequence I0, (σ1, π1), I1, . . ., alternating instances
and triggers, such that each (σi, πi) is an active trigger on Ii−1 according to the restricted
criterion, and Ii is obtained from Ii−1 by ﬁrst ﬁring (σi, πi), then computing the core of
the result. Then, a core chase sequence is a fair core derivation. An instance admits a
terminating core chase sequence in that sense if and only if the core chase as originally
deﬁned terminates on that instance.

For the three chase variants, a chase sequence deﬁnes a (possibly inﬁnite) universal model
of the KB, but only the core chase stops if and only if the KB has a ﬁnite universal model.

It is well-known that, for the semi-oblivious and the core chase, if there is a terminating
chase sequence from an instance I then all chase sequences from I are terminating. This is
not the case for the restricted chase, since the order in which rules are applied has an impact
on termination, as illustrated by Example 2.

(cid:73) Example 2. Let Σ = {σ1, σ2}, with σ1 = p(x, y) → ∃z p(y, z) and σ2 = p(x, y) → p(y, y).
Let I = p(a, b). The KB (I, Σ) has a ﬁnite universal model, for example, I ∗ = {p(a, b), p(b, b)}.
The semi-oblivious chase does not terminate on I as σ1 is applied indeﬁnitely, while the
core chase terminates after one breadth-ﬁrst step and returns I ∗. The restricted chase has
a terminating sequence, for example I0 = I, (σ2, {x 7→ a, y 7→ b}), I1 = I ∗, but it also has
inﬁnite sequences, for instance sequences that apply always σ1 before σ2 on a given atom.

We study the following problems for the semi-oblivious, restricted and core chase variants:
(All-instance) all-sequence termination: Given a set of rules Σ, is it true that, for any
instance, all chase sequences are terminating?
(All-instance) one-sequence termination: Given a set of rules Σ, is it true that, for any
instance, there is a terminating chase sequence?

Note that, according to the terminology of [14], these problems can be recast as deciding
whether, for a chase variant, a given set of rules belongs to the class CT∀∀ or CT∀∃,
respectively.

An existential rule is called linear if its body is atomic, see e.g., [6]. As often done, we
moreover restrict linear rules to atomic heads (and still use the name linear rules). Linear
rules generalize inclusion dependencies [10] by allowing several occurrences of the same

I C D T 2 0 1 9

18:6

A Single Approach to Decide Chase Termination on Linear Existential Rules

variable in an atom. They also generalize positive inclusions in the description logic DL-LiteR
(the formal basis of the web ontological language OWL 2 QL) [7], which can be seen as
inclusion dependencies restricted to unary and binary predicates.

Note that the restriction of existential rules to rules with an atomic head is often made in
the literature, considering that any existential rule with a complex head can be decomposed
into several rules with an atomic head, by introducing a fresh predicate for each rule. However,
while this translation preserves the termination of the semi-oblivious chase, it is not the case
for the restricted and the core chases. Hence, considering linear rules with a complex head
would require to extend the techniques developed in this paper.

To simplify the presentation, we assume in the following that each rule frontier is of size

at least one. This assumption is made without loss of generality. 2

We ﬁrst point out that the termination problem on linear rules can be recast by considering

solely atomic instances (as already remarked in several contexts).

(cid:73) Proposition 3. Let Σ be a set of linear rules. The semi-oblivious (resp. restricted, core)
chase terminates on all instances if and only if it terminates on all atomic instances.

We will furthermore rely on the following notion of the type of an atom.

(cid:73) Deﬁnition 4 (Type of an atom). The type of an atom α = r(t1, . . . , tn), denoted by type(α),
is the pair (r, P) where P is the partition of {1, . . . , n} induced by term equality (i.e., i and j
are in the same class of P iﬀ ti = tj).

There are ﬁnitely (more speciﬁcally, exponentially) many types for a given vocabulary.
When two atoms α and α0 have the same type, there is a natural mapping from α to
α0, denoted by ϕα→α0, and deﬁned as follows: it is a bijective mapping from terms(α) to
terms(α0), that maps the i-th term of α to the i-th term of α0. Note that ϕα→α0 may not be
an isomorphism, as constants from α may not be mapped to themselves. However, if (σ, π)
is a trigger for {α}, then (σ, ϕα→α0 ◦ π) is a trigger for {α0}, as there are no constants in the
considered rules.

Together with Proposition 3, this implies that one can check all-instance all-sequence
termination by checking all-sequence termination on a ﬁnite set of instances, called canonical
instances: for each type, we take exactly one canonical instance that has this type.

We will consider diﬀerent kinds of tree structures, which have in common to be trees of bags.

(cid:73) Deﬁnition 5 (Tree of bags). A tree of bags is a rooted tree whose nodes, called bags,3 are
labeled by an atom. For any bag B, we deﬁne the following notations:

atom(B) is the label of B;
terms(B) = terms(atom(B)) is the set of terms of B;
terms(B) is divided into two sets of terms, those generated in B, denoted by generated(B),
and those shared with its parent, denoted by shared(B); precisely, terms(B) = shared(B)∪
then
generated(B), shared(B) ∩ generated(B) = ∅, and if B is the root of T ,

2 For instance, it can always be ensured by adding a position to all predicates, which is ﬁlled by the same
fresh constant in the initial instance and by a new frontier variable in each rule. E.g. let c0 be the
new constant, then an instance atom of the form p(a, b) would become p(c0, a, b) and a rule of the form
p(x, y) → ∃z1∃z2 q(z1, z2) would become p(u, x, y) → ∃z1∃z2 q(u, z1, z2), where u is a variable. This
translation does not change the behavior of any chase variant.

3 The trees of bags that we consider are tree decompositions [26], hence the term “bag”, which is classical

in this setting.

M. Leclère, M.-L. Mugnier, M. Thomazo, and F. Ulliana

18:7

generated(B) = terms(B) (hence shared(B) = ∅), otherwise B has a parent Bp and
generated(B) = terms(B) \ terms(Bp) (hence, shared(B) = terms(Bp) ∩ terms(B)).

Last, we denote by atoms(T ) the set of atoms that label the bags in T .

Finally, we recall some classical mathematical notions. A subsequence S0 of a sequence
S is a sequence that can be obtained from S by deleting some (or no) elements without
changing the order of the remaining elements. The arity of a tree is the maximal number
of children for a node. A preﬁx T 0 of a tree T is a tree that can be obtained from T by
repeatedly deleting some (or no) leaves of T .

3 Derivation Trees

A classical tool to reason about the chase is the so-called chase graph (see e.g., [6]), which
is the directed graph consisting of all atoms that appear in the considered derivation, and
with an arrow from a node n1 to a node n2 iﬀ n2 is created by a rule application on n1 and
possibly other atoms. 4 In the speciﬁc case of KBs of the form (I, Σ), where I is an atomic
instance and Σ a set of linear rules, the chase graph is a tree. We recall below its deﬁnition
in this speciﬁc case, in order to emphasize its diﬀerences with another tree, called derivation
tree, on which we will actually rely.

(cid:73) Deﬁnition 6 (Chase Graph for Linear Rules). Let I0 = {α} be an atomic instance, Σ be a
set of linear rules, and S = I0, (σ1, π1), I1, . . . , (σn, πn), In be a semi-oblivious Σ-derivation.
The chase graph (also called chase tree) assigned to S is a tree of bags built as follows:

the set of bags is in bijection with In via the labeling function atom();
the set of edges is in bijection with the set of triggers in S and is built as follows: for
each trigger (σi, πi) in S, there is an edge (B, B0) with atom(B) = πi(body(σi)) and
atom(B0) = πs

i (head(σi)).

(cid:73) Example 7. Let I0 = q(a) and Σ = {σ1, σ2} where σ1 = q(x) → ∃y∃z∃t p(x, y, z, t)
and σ2 = p(x, y, z, t) → p(x, z, t, y). Let S = I0, (σ1, π1), I1, (σ2, π2), I3, (σ2, π3), I3 with
π1 = {x 7→ a}, πs
1(head(σ1)) = p(a, y0, z0, t0), π2 = {x 7→ a, y 7→ y0, z 7→ z0, t 7→ t0} and
π3 = {x 7→ a, y 7→ z0, z 7→ t0, t 7→ y0}. The chase graph associated with S is a path of four
nodes as pictured in Figure 1.

To check termination of a chase variant on a given KB (with an atomic instance), the
general idea is to build a tree of bags associated with the chase on this KB in such a way
that the occurrence of some forbidden pattern indicates that a path of unbounded length
can be developed, hence the chase does not terminate. The forbidden pattern is composed of
two distinct nodes such that one is an ancestor of the other and, intuitively speaking, these
nodes “can be extended in similar ways”, which leads to an arbitrarily long path that repeats
the pattern.

Two atoms with the same type admit the same rule triggers, however, within a derivation,
the same rule applications cannot necessarily be performed on both of them because of the
presence of other atoms (this is already true for datalog rules, since the same atom is never
produced twice). Hence, on the one hand we will specialize the notion of type, into that of a
sharing type, and, on the other hand, adopt another tree structure, called a derivation tree,
in which two nodes with the same sharing type have the required similar behavior.

4 Note that the chase graph in [9] is a diﬀerent notion.

I C D T 2 0 1 9

18:8

A Single Approach to Decide Chase Termination on Linear Existential Rules

B0

q(a)

B0

q(a)

B1

p(a, y0, z0, t0)

B1

p(a, y0, z0, t0)

B2

p(a, z0, t0, y0)

B2

p(a, z0, t0, y0)

p(a, t0, y0, z0)

B3

B3

p(a, t0, y0, z0)

Chase Graph

Derivation Tree

Figure 1 Chase Graph and Derivation Tree of Example 7.

(cid:73) Deﬁnition 8 (Sharing Type). Given a tree of bags, the sharing type of a bag B is a pair
(type(atom(B)), P ) where P is the set of positions in atom(B) in which a term of shared(B)
occurs. We denote the fact that two bags B and B0 have the same sharing type by B ≡st B0.

We can now specify the forbidden pattern that we will consider: it is a pair of two distinct

nodes with the same sharing type, such that one is an ancestor of the other.

(cid:73) Deﬁnition 9 (Unbounded-Path Witness). An unbounded-path witness (UPW) in a deriva-
tion tree is a pair of distinct bags (B, B0) such that B and B0 have the same sharing type
and B is an ancestor of B0.

As explained below on Example 7, the chase graph is not the appropriate tool to use this

forbidden pattern as a witness of chase non-termination.

(cid:73) Example 7 (continued). B1, B2 and B3 in the chase graph of Figure 1 have the same
classical type, t = (p, {{1}, {2}, {3}, {4}}). The sharing type of B1 is (t, {1}), while B2 and
B3 have the same sharing type (t, {1, 2, 3, 4}). B2 and B3 fulﬁll the condition of the forbidden
pattern, however it is easily checked that any derivation that extends this derivation is ﬁnite.

Derivation trees were introduced as a tool to deﬁne the greedy bounded treewidth set (gbts)
family of existential rules [2, 28]. A derivation tree is associated with a derivation, however
it does not have the same structure as the chase graph. The fundamental reason is that,
when a rule σ is applied to an atom α via a homomorphism π, the newly created bag is not
necessarily attached in the tree as a child of the bag labeled by α. Instead, it is attached as
a child of the highest bag in the tree labeled by an atom that contains π(fr(σ)), the image
by π of the frontier of σ (note that π(fr(σ)) remains the set of terms shared between the
new bag and its parent). This highest bag is unique. It is also the ﬁrst created bag that
contains π(fr(σ)).

In the following deﬁnition, a derivation tree is not associated with any derivation, but
with a semi-oblivious derivation, which has the advantage of yielding trees with bounded
arity. This is appropriate to study the termination of the semi-oblivious chase, and later the
restricted chase, as a restricted derivation is a speciﬁc semi-oblivious derivation.

(cid:73) Deﬁnition 10 (Derivation Tree). Let I0 = {α} be an atomic instance, Σ be a set of
linear rules, and S = I0, (σ1, π1), I1, . . . , (σn, πn), In be a semi-oblivious Σ-derivation. The
derivation tree assigned to S is a tree T of bags built as follows:

the root of the tree, B0, is such that atom(B0) = α;

M. Leclère, M.-L. Mugnier, M. Thomazo, and F. Ulliana

18:9

for each trigger (σi, πi), 0 < i ≤ n, let Bi be the bag such that atom(Bi) = πs
i (head(σi)).
Let j be the smallest integer such that πi(fr(σi)) ⊆ terms(Bj): then Bi is added as a child
to Bj.

By extension, we say that a derivation tree T is associated with α and Σ if there exists a
semi-oblivious Σ-derivation S from α such that T is assigned to S.

(cid:73) Example 7 (continued). The derivation tree associated with S is represented in Figure 1.
Bags have the same sharing types in the chase tree and in the derivation tree. However, we
can see here that they are not linked in the same way: B3 was a child of B2 in the chase
tree, it becomes a child of B1 in the derivation tree. Hence, the forbidden pattern cannot be
found anymore in the tree.

Note that every non-root bag B shares at least one term with its parent (since the rule
frontiers are not empty), furthermore this term is generated in its parent (otherwise B would
have been added at a higher level in the tree).

4

Semi-Oblivious and Restricted Chase Termination

We now use derivation trees and sharing types to characterize the termination of the semi-
oblivious chase. The fundamental property of derivation trees that we exploit is that, when
two nodes have the same sharing type, the considered (semi-oblivious) derivation can always
be extended so that these nodes have the same number of children, and in turn these children
have the same sharing type. We ﬁrst specify the notion of bag copy.

(cid:73) Deﬁnition 11 (Bag Copy). Let T and T 0 be (possibly equal) trees of bags. Let B be a bag
of T and B0 be a bag of T 0 such that B ≡st B0. Let Bc be a child of B. A copy of Bc under
c) = ϕs(atom(Bc)), where ϕs is a substitution of terms(Bc)
B0 is a bag B0
deﬁned as follows:

c such that atom(B0

if t ∈ shared(Bc), then ϕs(t) = ϕatom(B)→atom(B0)(t), where ϕatom(B)→atom(B0) is the
natural mapping from atom(B) to atom(B0);
if t ∈ generated(Bc), then ϕs(t) is a fresh new variable.

Let Te be obtained from a derivation tree T by adding a copy of a bag: strictly speaking,
Te may not be a derivation tree in the sense that there may be no derivation to which it can
be assigned, as illustrated by Example 12. Intuitively, some rule applications that would
allow to produce the copy may be missing. However, there is some derivation tree of which
Te is a preﬁx (intuitively, one can add bags to Te to obtain a derivation tree). That is why
the following proposition considers more generally preﬁxes of derivation trees.

(cid:73) Example 12. Let Σ = {σ1, σ2, σ3} with:

σ1 : r(x, y) → ∃z s(y, z)

σ2 : s(x, y) → ∃z t(y, z)

σ3 : t(x, y) → ∃z s(x, z)

Figure 2 pictures the result of copying a bag in a derivation tree T associated with a
Σ-derivation: T has bags B0, B1, B2 and B3; then the bag B3 is copied under itself yielding
B0
3 (this copy is possible as B1 and B3 have the same sharing type and B3 is a child of B1).
The obtained tree structure is not a derivation tree, as s(z3, z4) cannot be generated by
applying a rule on the instance associated with T , however it could be completed to yield a
derivation tree.

(cid:73) Proposition 13. Let T be a preﬁx of a derivation tree, B and B0 be two bags of T such
c be a copy of Bc under B0. Then: (a) it holds
that B ≡st B0, and Bc be a child of B. Let B0
c under B0, if no copy of Bc
that Bc ≡st B0
already exists under B0, is a preﬁx of a derivation tree.

c, and (b) the tree obtained from T by adding B0

I C D T 2 0 1 9

18:10 A Single Approach to Decide Chase Termination on Linear Existential Rules

B0

r(a, b)

B1

s(b, z1)

B2

t(z1, z2)

s(z1, z3)

B3

s(z3, z4)

B0
3

Figure 2 Copy Operation and Derivation Trees.

The size of a derivation tree without UPW is bounded, since its arity is bounded and its
depth is bounded by the number of sharing types. It remains to show that a derivation tree
that contains a UPW can be extended to an arbitrarily large derivation tree. We recall that
a similar property would not hold for the chase tree, as witnessed by Example 7.

(cid:73) Proposition 14. There exists an arbitrary large derivation tree associated with α and
Σ if and only if there exists a derivation tree associated with α and Σ that contains an
unbounded-path witness.

The previous proposition yields a characterization of the existence of an inﬁnite semi-
oblivious derivation. At this point, one may notice that an inﬁnite semi-oblivious derivation
is not necessarily fair. However, from this inﬁnite derivation one can always build a fair
derivation by inserting missing triggers. Obviously, this operation has no eﬀect on the
termination of the semi-oblivious chase. More precaution will be required for the restricted
chase.

One obtains an algorithm to decide termination of the semi-oblivious chase for a given
set of rules: for each canonical instance, build a semi-oblivious derivation and the associated
derivation tree by applying rules until a UPW is created (in which case the answer is no) or
all possible rule applications have been performed; if no instance has returned a negative
answer, the answer is yes.

(cid:73) Corollary 15. The all-sequence termination problem for the semi-oblivious chase on linear
rules is decidable.

This algorithm can be modiﬁed to run in polynomial space (which is optimal [4]), by

guessing a canonical instance and a UPW of its derivation tree.

(cid:73) Proposition 16. The all-sequence termination problem for the semi-oblivious chase on
linear rules is in PSpace.

We now consider the restricted chase. To this aim, we call restricted derivation tree
associated with α and Σ a derivation tree associated with a restricted Σ-derivation from α.

We ﬁrst point out that Proposition 13 is not true anymore for a restricted derivation tree,

as the order in which rules are applied matters. This is illustrated by the next example.

(cid:73) Example 17. Consider a restricted tree that contains bags B and B0 with the same sharing
type, labeled by atoms q(t, u) and q(v, w) respectively, where the second term is generated.
Consider the following rules (the same as in Example 2):

σ1 : q(x, y) → ∃z q(y, z)

σ2 : q(x, y) → q(y, y)

M. Leclère, M.-L. Mugnier, M. Thomazo, and F. Ulliana

18:11

Assume B has a child Bc labeled by q(u, z0) obtained by an application of σ1, and B0
has a child B0
1 labeled by q(w, w) obtained by an application of σ2. It is not possible to
extend this tree by copying Bc under B0. Indeed, the corresponding application of σ1 does
not comply with the restricted chase criterion: it would produce an atom of the form q(w, z1)
that folds onto q(w, w).

We thus prove a weaker proposition by considering that B0 is a leaf in the restricted

derivation tree.

(cid:73) Proposition 18. Let T be a preﬁx of a restricted derivation tree, B and B0 be two bags
of T such that B ≡st B0 and B0 is a leaf. Let Bc be a child of B and B0
c be a copy of Bc
under B0. Then: (a) Bc ≡st B0
c of
Bc under B0 is a preﬁx of a restricted derivation tree.

c and (b) the tree obtained from T by adding the copy B0

The previous proposition allows us to obtain a variant of Proposition 14 adapted to the

restricted chase: 5

(cid:73) Proposition 19. There exists an arbitrary large restricted derivation tree associated with
α and Σ if and only if there exists a restricted derivation tree associated with α and Σ that
contains an unbounded-path witness.

It is less obvious than in the case of the semi-oblivious chase that the existence of an
inﬁnite derivation entails the existence of an inﬁnite fair derivation. However, this property
still holds:

(cid:73) Proposition 20. For linear rules, every (inﬁnite) non-terminating restricted derivation is
a subsequence of a fair restricted derivation (i.e., a restricted chase sequence).

We point out that the previous property is not true anymore if linear rules are extended
to non-atomic heads, as illustrated by the next example (in which only binary atoms are
used).

(cid:73) Example 21. Let Σ = {σ1 : r(x, y) → r(x, x); σ2 : r(x, y) → s(x, x); σ3 : r(x, y) →
∃z r(x, z) ∧ s(z, x) ∧ s(y, z)}. Starting from the instance r(a, b), one builds an inﬁnite
restricted derivation that repeatedly applies σ3, ignoring the two other rules. In order to
turn this derivation into a fair derivation, one should at some point perform the applications
of σ1 and σ2 to the initial instance, which produce the atoms r(a, a) and s(a, a). However, as
soon as these atoms are produced, all triggers involving σ3 are deactivated. Actually, there
is no inﬁnite fair restricted Σ-derivation from r(a, b).

Similarly to Proposition 14 for the semi-oblivious chase, Proposition 19 provides an
algorithm to decide termination of the restricted chase. The diﬀerence is that it is not
suﬃcient to build a single derivation for a given canonical instance; instead, all possible
restricted derivations from this instance have to be built (note that the associated restricted
derivation trees are ﬁnite for the same reasons as before, and there is obviously a ﬁnite
number of them). Hence, we obtain:

(cid:73) Corollary 22. The all-sequence termination problem for the restricted chase on linear rules
is decidable.

5 Actually, a weak version of Proposition 13 where B0 is a leaf would be suﬃcient to prove Proposition 14.
However, the interest of Proposition 13 is to pinpoint an important diﬀerence between the semi-oblivious
and restricted chase behaviors.

I C D T 2 0 1 9

18:12 A Single Approach to Decide Chase Termination on Linear Existential Rules

p(x, y)

1

2

p(x, y)

1

3

q(y)

r(y, x)

r(y, x)

q(y)

2

r(y, z0)

4

p(z0, z1)

5

7

6

Figure 3 Finite versus Inﬁnite Derivation Tree for Example 25.

A rough analysis of the proposed algorithm provides a co-N2ExpTime upper-bound
for the complexity of the problem, by guessing a derivation that is of length at most double
exponential, and checking whether there is a UPW in the corresponding derivation tree.

We now prove the decidability of the one-sequence termination problem. Note that a
restricted derivation tree T that contains a UPW is a witness of the existence of an inﬁnite
restricted chase sequence, but does not prove that every restricted chase sequence that
extends T is inﬁnite. However, we prove that, if all restricted derivation trees contain a
UPW, then there is no terminating restricted chase sequence.

(cid:73) Proposition 23. There exists a ﬁnite fair restricted derivation (i.e., a terminating restricted
chase sequence) associated with α and Σ if and only if there exists one whose associated
derivation tree does not contain any UPW.

Proof sketch. We show that the derivation tree of the shortest ﬁnite fair restricted derivation
cannot contain a UPW. This is done by contradiction: we assume there is a UPW in the
associated derivation tree of the shortest ﬁnite fair restricted derivation, and we choose a
UPW (B, B0), such that B0 is a deepest bag among all UPWs. We create a new derivation
that is equal to the original one up to the creation of B, then (1) copy the subtree rooted
in B0 under B and (2) perform “similarly” the missing rule applications so as to restore a
fair restricted derivation. We show that during step (2) at least one trigger of the original
(cid:74)
derivation becomes inactive, which yields a strictly shorter fair restricted derivation.

An algorithm to decide the existence of a ﬁnite restricted chase sequence for any instance
is as follows: for any canonical instance, build all restricted derivations until either (i) there
is a UPW in their associated derivation tree or (ii) there is no active trigger. Output Yes if
and only if for all instances, there is a least one restricted derivation that halts because of
the second condition. Such a derivation is of size at most double exponential, and we obtain
a N2ExpTime upper bound for the complexity of the one-sequence termination problem.

(cid:73) Corollary 24. The one-sequence termination problem for the restricted chase on linear
rules is decidable.

Importantly, the previous algorithms are naturally able to consider solely some type of
restricted derivations, i.e., build only derivation trees associated with such derivations, which
is of theoretical but also of practical interest. Indeed, implementations of the restricted chase
often proceed by building breadth-ﬁrst derivations (which are intrinsically fair when they

M. Leclère, M.-L. Mugnier, M. Thomazo, and F. Ulliana

18:13

are inﬁnite), or variants of these. As witnessed by the next example, the termination of all
breadth-ﬁrst fair derivations is a strictly weaker requirement than the termination of all fair
sequences, in the sense that the restricted chase terminates on more sets of rules.

(cid:73) Example 25. Consider the following set of rules:

σ1 = p(x, y) → q(y)
σ3 = q(y) → ∃z r(y, z)

σ2 = p(x, y) → r(y, x)
σ4 = r(x, y) → ∃z p(y, z)

All breadth-ﬁrst (fair) restricted derivations terminate, whatever the initial instance
is. Remark that every application of σ1 is followed by an application of σ2 in the same
breadth-ﬁrst step, which prevents the application of σ3. However, there is a fair restricted
derivation that does not terminate (and this is even true for any instance). Indeed, an
application of σ2 can always be delayed, so that it comes too late to prevent the application
of σ3. See Figure 3: on the left, a ﬁnite derivation tree associated with a breadth-ﬁrst
derivation from instance p(x, y); on the right, an inﬁnite derivation tree associated with a
(non-breadth-ﬁrst) fair inﬁnite derivation from the same instance. The numbers on edges
give the order in which bags are created.

We conclude this section by noting that the previous Example 25 may give the (wrong)
intuition that, given a set of rules, it is suﬃcient to consider breadth-ﬁrst fair derivations to
decide if there exists a terminating sequence. The following example shows that it is not the
case: here, no breadth-ﬁrst chase sequence is terminating, while there exists a terminating
chase sequence for the given instance.

(cid:73) Example 26. Let Σ = {σ1, σ2, σ3} with σ1 = p(x, y) → ∃z p(y, z), σ2 = p(x, y) → h(y),
and σ3 = h(x) → p(x, x). In this case, for every instance, there is a terminating restricted
chase sequence, where the application of σ2 and σ3 prevents the indeﬁnite application of σ1.
However, starting from I = {p(a, b)}, by applying rules in a breadth-ﬁrst fashion one obtains
a non-terminating restricted chase sequence, since σ1 and σ2 are always applied in parallel
from the same atom, before applying σ3.

As for the all-sequence termination problem, the algorithm may restrict the derivations

of interest to speciﬁc kinds.

5

Core Chase Termination

We now consider the termination of the core chase on linear rules. Keeping the same approach,
we prove that the ﬁniteness of the core chase is equivalent to the existence of a ﬁnite tree of
bags whose set of atoms is a minimal universal model. We call this a (ﬁnite) complete core.
To bound the size of a complete core, we show that it cannot contain an unbounded-path
witness. However, we cannot rely on derivation trees: indeed, there are linear sets of rules
for which no derivation tree forms a complete core, as shown in Example 27. We will thus
introduce a more general tree structure, namely entailment trees.

(cid:73) Example 27. Let us consider the following rules:

s(x) → ∃y∃z p(y, z, x)

p(y, z, x) → ∃v q(y, v, x)

q(y, v, x) → p(y, v, x)

Let I = {s(a)}. The ﬁrst rule applications yield a derivation tree T which is a path of

bags B0, B1, B2, B3 respectively labeled by the following atoms:

s(a), p(y0, z0, a), q(y0, v0, a) and p(y0, v0, a)

I C D T 2 0 1 9

18:14 A Single Approach to Decide Chase Termination on Linear Existential Rules

B0

s(a)

B1

p(y0, z0, a)

ϕ

B2

q(y0, v0, a)

B3

p(y0, v0, a)

B0

s(a)

B2

q(y0, v0, a)

B3

p(y0, v0, a)

Derivation Tree

An Entailment Tree

Figure 4 Derivation tree and entailment tree for Example 27.

T is represented on the left of Figure 4. Let A be this set of atoms. First, note that A
is not a core: indeed it is equivalent to its strict subset A0 deﬁned by {B0, B2, B3} with a
homomorphism π that maps atom(B1) to atom(B3). Trivially, A0 is a core since it does not
contain two atoms with the same predicate. Second, note that any further rule application
on T is redundant, i.e., generates a set of atoms equivalent to A (and A0). Hence, A0 is a
complete core. However, there is no derivation tree that corresponds to A0. There is even no
preﬁx of a derivation tree that corresponds to it (which ruins the alternative idea of building
a preﬁx of a derivation tree that would be associated with a complete core). In particular,
note that {B0, B1, B2} is indeed a core, but it is not complete.

The following notion of twins will be used in the deﬁnition of entailment trees to ensure

that they have a bounded arity.

(cid:73) Deﬁnition 28. Two bags B and B0 of a tree of bags are twins if they have the same sharing
type, the same parent Bp and if the natural mapping ϕatom(B)→atom(B0) is the identity on the
terms of atom(Bp).

In the following deﬁnition of entailment tree, we use the notation α1 → α2, where αi is

an atom, to denote the rule ∀X(α1 → ∃Y α2) with X = vars(α1) and Y = vars(α2) \ X.

(cid:73) Deﬁnition 29 (Entailment Tree). An entailment tree associated with α and Σ is a tree of
bags T such that:
1. Br, the root of T , is such that Σ |= α → atom(Br) and Σ |= atom(Br) → α;
2. For any bag Bc child of a node B, the following holds: (i) terms(Bc) ∩ generated(B) 6= ∅
(ii) The terms in generated(Bc) are variables that do not occur outside the subtree of T
rooted in Bc (iii) Σ |= atom(B) → atom(Bc).

3. There is no pair of twins.

If α is a ground atom, then Br is simply labeled by α. Otherwise, it may happen that α
does not belong to the result of the core chase (e.g., α = p(x, y), with x and y variables, and
Σ = {p(x, y) → p(x, x)}), hence Point 1.

First note that an entailment tree is independent from any derivation (in particular,
fairness is not an issue). The main diﬀerence with a derivation tree is that it employs a more
general parent-child relationship, that relies on entailment rather than on rule application,
hence the name entailment tree. Intuitively, with respect to a derivation tree, one is allowed
to move a bag B higher in the tree, provided that it contains at least one term generated in its
new parent Bp; then, the terms of B that are not shared with Bp are freshly renamed. Finally,

M. Leclère, M.-L. Mugnier, M. Thomazo, and F. Ulliana

18:15

since the problem of whether an atom is entailed by a linear existential rule knowledge base
is decidable (precisely PSpace-complete [5], even in the case of atomic instances), one can
actually generate all non-twin children of a bag. As a bag can only have a bounded number
of non-twin children, we are guaranteed to keep a tree of bounded arity.

Derivation trees are entailment trees, but not necessarily conversely. A crucial distinction
between these two structures is the following statement, which does not hold for derivation
trees, as illustrated by Example 27.

(cid:73) Proposition 30. If the core chase associated with α and Σ is ﬁnite, then there exists an
entailment tree T such that the set of atoms associated with T is a complete core.

(cid:73) Example 27 (continued). The tree deﬁned by the path of bags B0, B2, B3 is an entailment
tree, represented on the right of Figure 4, which deﬁnes a complete core.

Diﬀerently from the semi-oblivious case, we cannot conclude that the chase does not
terminate as soon as a UPW is built, because the associated atoms may later be mapped
to other atoms, which would remove the UPW. Instead, starting from the initial bag, we
recursively add bags that do not generate a UPW (for instance, we can recursively add
all such non-twin children to a leaf). Once the process terminates (the non-twin condition
and the absence of UPW ensure that it does), we check that the obtained set of atoms C
is complete (i.e., is a model of the KB): for that, it suﬃces to perform each possible rule
application on C and check if the resulting set of atoms is equivalent to C (i.e., maps by
homomorphism to C). See Algorithm 1. The set C may not be a core, but it is complete iﬀ
it contains a complete core.

We now focus on the key properties of entailment trees associated with complete cores.
We ﬁrst introduce the notion of redundant bags, which captures some cases of bags that
cannot appear in a ﬁnite core. As witnessed by Example 27, this is not a characterization:
B1 is not redundant (according to Deﬁnition 31 below), but cannot belong to a complete
core.

(cid:73) Deﬁnition 31 (Redundancy). Given an entailment tree, a bag Bc child of B is redundant
if there exists an atom β (that may not belong to the tree) with (i) Σ |= atom(B) → β;
(ii) there is a homomorphism from atom(Bc) to β that is the identity on shared(Bc); (iii)
|terms(β) \ terms(B)| < |terms(Bc) \ terms(B)|.

Note that Bc may be redundant even if the “cause” for redundancy, i.e., β, is not in
the tree yet. The role of this notion in the proofs is as follows: we show that if a complete
entailment tree contains a UPW then it contains a redundant bag, and that a complete core
cannot contain a redundant bag, hence a UPW. To prove this, we rely on Proposition 32
below, which is the counterpart for entailment trees of Proposition 13: performing a bag
copy from an entailment tree results in an entailment tree (the notion of preﬁx is not needed,
since a preﬁx of an entailment tree is an entailment tree) and keeps the properties of the
copied bag.

(cid:73) Proposition 32. Let B be a bag of an entailment tree T and B0 be a bag of an entailment
c be a copy of Bc under B0. Then:
tree T 0 such that B ≡st B0. Let Bc be a child of B. Let B0
c under B0, if no copy
(a) it holds that Bc ≡st B0
of Bc already exists under B0, is an entailment tree, and (c) B0
c is redundant if and only if
Bc is redundant.

c, (b) the tree obtained from T by adding B0

In light of this, the copy of a bag can be naturally extended to the copy of the whole

subtree rooted in a bag, which is a crucial element in the proof of Proposition 33 below.

I C D T 2 0 1 9

18:16 A Single Approach to Decide Chase Termination on Linear Existential Rules

(cid:73) Proposition 33. A complete core contains neither (i) a redundant bag, nor (ii) an
unbounded-path witness.

From Propositions 30 and 33, we conclude that Algorithm 1 decides the all-sequence

termination problem for the core chase.

(cid:73) Corollary 34. The all-sequence termination problem for the core chase on linear rules is
decidable.

Algorithm 1: Deciding core chase termination.

: A set of linear rules

Input
Output : true if and only if the core chase terminates on all instances

1 for each canonical atom α do

2

3

4

5

6

7

8

Let T be the entailment tree restricted to a single root bag labeled by α;
while a bag B can be added to T without creating twins nor a UPW do

add B to T

for (σ, π) such that σ is applicable to atoms(T ) by π do

if atoms(T ) 6|= atoms(T ) ∪ πs(head(σ));
then

return false

// homomorphism check

9 return true

A rough complexity analysis of this algorithm yields a 2ExpTime upper bound for the
termination problem. Indeed, the exponential number of (sharing) types yields a bound on
the number of canonical instances to be checked, the arity of the tree, as well as the length
of a path without UPW in the tree, and each edge can be generated with a call to a PSpace
oracle.

Finally, note that for predicates of arity at most two, it would still be possible to rely on
derivation trees (instead of entailment trees), provided that the initial instance is ground.
Indeed, in this speciﬁc case, the core of a (ﬁnite) derivation tree is a preﬁx of this tree (note
that Example 27 uses predicates of arity three). Then, we can incrementally build a preﬁx of
derivation tree until no bag can be added without creating a UPW, and, as in the higher
arity case, check if the built tree is complete.

6

Concluding Remarks

We have shown the decidability of all-instance chase termination over atomic-head linear rules
for three main chase variants (semi-oblivious, restricted, core) following a novel approach
based on derivation trees, and their generalization to entailment trees, and a single notion of
forbidden pattern. As far as we know, these are the ﬁrst decidability results for the restricted
chase, on both versions of the termination problem (i.e., all-sequence and one-sequence
termination). The simplicity of the structures and algorithms makes it realistic to implement
them.

We leave for future work the study of the precise complexity of the termination problems.
A straightforward analysis of the complexity of the algorithms that decide the termination of
the restricted and core chases yields upper bounds, however we believe that a ﬁner analysis
of the properties of sharing types would provide tighter upper bounds. It is an open question
whether our results can be extended to more complex classes of existential rules, i.e., linear
rules with a complex head, which is relevant for the termination of the restricted and core

M. Leclère, M.-L. Mugnier, M. Thomazo, and F. Ulliana

18:17

chases, and more expressive classes from the guarded family. Concerning the extension
to complex-head rules, the diﬃculty is that an inﬁnite restricted derivation may not be
transformable into a fair restricted derivation. Concerning the extension to more expressive
classes, derivation trees were precisely deﬁned to represent derivations with guarded rules
and their extensions (i.e., greedy bounded treewidth sets), hence they seem to be a promising
tool to study chase termination on that family, at least for the one-instance version of the
problem, i.e., given a knowledge base. To consider the all-instance termination problem, a
preliminary issue would be whether a ﬁnite set of canonical instances can be deﬁned.

References

1

2

3

Jean-François Baget, Michel Leclère, Marie-Laure Mugnier, and Eric Salvat. On rules with
existential variables: Walking the decidability line. Artif. Intell., 175(9-10):1620–1654, 2011.
doi:10.1016/j.artint.2011.03.002.
Jean-François Baget, Marie-Laure Mugnier, Sebastian Rudolph, and Michaël Thomazo. Walk-
ing the Complexity Lines for Generalized Guarded Existential Rules. In Toby Walsh, editor,
IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artiﬁcial Intelli-
gence, Barcelona, Catalonia, Spain, July 16-22, 2011, pages 712–717. IJCAI/AAAI, 2011.
doi:10.5591/978-1-57735-516-8/IJCAI11-126.
Catriel Beeri and Moshe Y. Vardi. The Implication Problem for Data Dependencies. In Shimon
Even and Oded Kariv, editors, Automata, Languages and Programming, 8th Colloquium, Acre
(Akko), Israel, July 13-17, 1981, Proceedings, volume 115 of Lecture Notes in Computer Science,
pages 73–85. Springer, 1981. doi:10.1007/3-540-10843-2_7.

4 Marco Calautti, Georg Gottlob, and Andreas Pieris. Chase Termination for Guarded Existential
Rules. In Tova Milo and Diego Calvanese, editors, Proceedings of the 34th ACM Symposium
on Principles of Database Systems, PODS 2015, Melbourne, Victoria, Australia, May 31 -
June 4, 2015, pages 91–103. ACM, 2015. doi:10.1145/2745754.2745773.

5 Andrea Calì, Georg Gottlob, and Thomas Lukasiewicz. Datalog Extensions for Tractable
Query Answering over Ontologies. In Roberto De Virgilio, Fausto Giunchiglia, and Letizia
Tanca, editors, Semantic Web Information Management - A Model-Based Perspective, pages
249–279. Springer, 2009. doi:10.1007/978-3-642-04329-1_12.

6 Andrea Calì, Georg Gottlob, and Thomas Lukasiewicz. A general Datalog-based framework
for tractable query answering over ontologies. J. Web Sem., 14:57–83, 2012. doi:10.1016/j.
websem.2012.03.001.

7 Diego Calvanese, Giuseppe De Giacomo, Domenico Lembo, Maurizio Lenzerini, and Riccardo
Rosati. Tractable Reasoning and Eﬃcient Query Answering in Description Logics: The DL-Lite
Family. J. Autom. Reasoning, 39(3):385–429, 2007. doi:10.1007/s10817-007-9078-x.
8 David Carral, Irina Dragoste, and Markus Krötzsch. Detecting Chase (Non)Termination for
Existential Rules with Disjunctions. In Carles Sierra, editor, Proceedings of the Twenty-Sixth
International Joint Conference on Artiﬁcial Intelligence, IJCAI 2017, Melbourne, Australia,
August 19-25, 2017, pages 922–928. ijcai.org, 2017. doi:10.24963/ijcai.2017/128.

9 Alin Deutsch, Alan Nash, and Jeﬀrey B. Remmel. The chase revisited. In Maurizio Lenzerini
and Domenico Lembo, editors, Proceedings of the Twenty-Seventh ACM SIGMOD-SIGACT-
SIGART Symposium on Principles of Database Systems, PODS 2008, June 9-11, 2008,
Vancouver, BC, Canada, pages 149–158. ACM, 2008. doi:10.1145/1376916.1376938.
10 Ronald Fagin. A Normal Form for Relational Databases That Is Based on Domians and Keys.

ACM Trans. Database Syst., 6(3):387–415, 1981. doi:10.1145/319587.319592.

11 Ronald Fagin, Phokion G. Kolaitis, Renée J. Miller, and Lucian Popa. Data exchange:
semantics and query answering. Theor. Comput. Sci., 336(1):89–124, 2005. doi:10.1016/j.
tcs.2004.10.033.

I C D T 2 0 1 9

18:18 A Single Approach to Decide Chase Termination on Linear Existential Rules

12

Tomasz Gogacz and Jerzy Marcinkowski. All-Instances Termination of Chase is Undecidable. In
Javier Esparza, Pierre Fraigniaud, Thore Husfeldt, and Elias Koutsoupias, editors, Automata,
Languages, and Programming - 41st International Colloquium, ICALP 2014, Copenhagen,
Denmark, July 8-11, 2014, Proceedings, Part II, volume 8573 of Lecture Notes in Computer
Science, pages 293–304. Springer, 2014. doi:10.1007/978-3-662-43951-7_25.

13 Georg Gottlob, Giorgio Orsi, and Andreas Pieris. Query Rewriting and Optimization for
Ontological Databases. ACM Trans. Database Syst., 39(3):25:1–25:46, 2014. doi:10.1145/
2638546.

14 Gösta Grahne and Adrian Onet. Anatomy of the Chase. Fundam. Inform., 157(3):221–270,

2018. doi:10.3233/FI-2018-1627.

15 Bernardo Cuenca Grau, Ian Horrocks, Markus Krötzsch, Clemens Kupke, Despoina Magka,
Boris Motik, and Zhe Wang. Acyclicity Notions for Existential Rules and Their Application to
Query Answering in Ontologies. J. Artif. Intell. Res., 47:741–808, 2013. doi:10.1613/jair.
3949.

16 Alon Y. Halevy. Answering queries using views: A survey. VLDB J., 10(4):270–294, 2001.

doi:10.1007/s007780100054.

17 André Hernich. Computing universal models under guarded TGDs. In Alin Deutsch, editor,
15th International Conference on Database Theory, ICDT ’12, Berlin, Germany, March 26-29,
2012, pages 222–235. ACM, 2012. doi:10.1145/2274576.2274600.

18 Mélanie König, Michel Leclère, Marie-Laure Mugnier, and Michaël Thomazo. Sound, complete
and minimal UCQ-rewriting for existential rules. Semantic Web, 6(5):451–475, 2015. doi:
10.3233/SW-140153.

19 Michel Leclère, Marie-Laure Mugnier, Michaël Thomazo, and Federico Ulliana. A Single
Approach to Decide Chase Termination on Linear Existential Rules. CoRR, abs/1602.05828,
2018. arXiv:1810.02132.

20 Michel Leclère, Marie-Laure Mugnier, Michaël Thomazo, and Federico Ulliana. A Single
Approach to Decide Chase Termination on Linear Existential Rules. In Magdalena Ortiz and
Thomas Schneider, editors, Proceedings of the 31st International Workshop on Description
Logics co-located with 16th International Conference on Principles of Knowledge Representation
and Reasoning (KR 2018), Tempe, Arizona, US, October 27th - to - 29th, 2018., volume 2211
of CEUR Workshop Proceedings. CEUR-WS.org, 2018. URL: http://ceur-ws.org/Vol-2211/
paper-45.pdf.

21 Maurizio Lenzerini. Data Integration: A Theoretical Perspective. In Lucian Popa, Serge
Abiteboul, and Phokion G. Kolaitis, editors, Proceedings of the Twenty-ﬁrst ACM SIGACT-
SIGMOD-SIGART Symposium on Principles of Database Systems, June 3-5, Madison, Wis-
consin, USA, pages 233–246. ACM, 2002. doi:10.1145/543613.543644.

22 Bruno Marnette. Generalized schema-mappings: from termination to tractability. In Jan
Paredaens and Jianwen Su, editors, Proceedings of the Twenty-Eigth ACM SIGMOD-SIGACT-
SIGART Symposium on Principles of Database Systems, PODS 2009, June 19 - July 1, 2009,
Providence, Rhode Island, USA, pages 13–22. ACM, 2009. doi:10.1145/1559795.1559799.

23 Marie-Laure Mugnier and Michaël Thomazo. An Introduction to Ontology-Based Query
Answering with Existential Rules.
In Reasoning Web. Reasoning on the Web in the Big
Data Era - 10th International Summer School 2014, Athens, Greece, September 8-13, 2014.
Proceedings, pages 245–278, 2014. doi:10.1007/978-3-319-10587-1_6.

24 Dan Olteanu, Jiewen Huang, and Christoph Koch. SPROUT: lazy vs. eager query plans
for tuple-independent probabilistic databases. In Yannis E. Ioannidis, Dik Lun Lee, and
Raymond T. Ng, editors, Proceedings of the 25th International Conference on Data Engineering,
ICDE 2009, March 29 2009 - April 2 2009, Shanghai, China, pages 640–651. IEEE Computer
Society, 2009. doi:10.1109/ICDE.2009.123.

25 Adrian Onet.

The chase procedure and its applications.

PhD thesis, Con-
URL: https://pdfs.semanticscholar.org/6b1b/

cordia University, Canada, 2012.
327a989d3d8e2488f645488063f391391b89.pdf.

M. Leclère, M.-L. Mugnier, M. Thomazo, and F. Ulliana

18:19

26 Neil Robertson and Paul D. Seymour. Graph Minors. II. Algorithmic Aspects of Tree-Width.

27

J. Algorithms, 7(3):309–322, 1986. doi:10.1016/0196-6774(86)90023-4.
Swan Rocher. Querying Existential Rule Knowledge Bases: Decidability and Complexity. (In-
terrogation de Bases de Connaissances avec Règles Existentielles : Décidabilité et Complexité).
PhD thesis, University of Montpellier, France, 2016. URL: https://tel.archives-ouvertes.
fr/tel-01483770.

28 Michaël Thomazo. Conjunctive Query Answering Under Existential Rules - Decidability,
Complexity, and Algorithms. PhD thesis, Montpellier 2 University, France, 2013. URL:
https://tel.archives-ouvertes.fr/tel-00925722.

I C D T 2 0 1 9

