Regular Matching and Inclusion on Compressed Tree
Patterns with Context Variables
Iovka Boneva, Joachim Niehren, Momar Sakho

To cite this version:

Iovka Boneva, Joachim Niehren, Momar Sakho. Regular Matching and Inclusion on Compressed
Tree Patterns with Context Variables. LATA 2019 - 13th International Conference on Language and
Automata Theory and Applications, Mar 2019, Saint Petersburg, Russia. ￿hal-01811835v4￿

HAL Id: hal-01811835

https://inria.hal.science/hal-01811835v4

Submitted on 27 Jun 2019

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Regular Matching and Inclusion on Compressed
Tree Patterns with Context Variables

Iovka Boneva1, Joachim Niehren2, and Momar Sakho2

1 Universit´e de Lille, France
2 Inria Lille, France

Abstract. We study the complexity of regular matching and inclusion
for compressed tree patterns extended by context variables. The addi-
tion of context variables to tree patterns permits us to properly capture
compressed string patterns but also compressed patterns for unranked
trees with tree and hedge variables. Regular inclusion for the latter is
relevant to certain query answering on Xml streams with references.

Keywords: computational complexity, patterns, trees, tree languages
and tree automata

1

Introduction

A pattern is a term with variables describing a string, a tree, or some other
algebraic value. The following generic problems for patterns were widely studied:

Pattern matching: Is a given algebraic value an instance of a given pattern?
Pattern uniﬁcation: Do two given patterns have some common instance?
Regular pattern matching: Does some instance of a given pattern belong to

a given regular language?

Regular pattern inclusion: Do all instances of a given pattern belong to a

given regular language?

As inputs, these problems receive descriptors of patterns, values, and regular
languages. Most typically, a string pattern may be described in a compressed
manner by using a singleton context-free grammar (also called straight-line pro-
gram), and a regular string language may be represented by a nondeterministic
ﬁnite automaton (Nfa) or by a deterministic ﬁnite automaton (Dfa). The prob-
lem of string pattern matching is well-known to be NP-complete for Nfas [1]
but in P for Dfas, with and without compression [5]. The more general problem
of string uniﬁcation is known to be Pspace-complete [11].

Compressed patterns were called hyperstreams in [8]. Regular inclusion on
compressed patterns is the problem of certain query answering on hyperstreams
for queries deﬁned by automata. This application motivated the study of regular
inclusion and matching in [2]. For string patterns, both problems were shown
to be Pspace-complete, for Dfas and Nfas, with and without compression. See
Fig. 1 for an overview. When restricted to linear string patterns, the complexity

2

I. Boneva, J. Niehren and M. Sakho

Dfas

Nfas

Dfas Nfas

Regular Matching Pspace-c Pspace-c
Regular Inclusion Pspace-c Pspace-c

Regular Matching P
Regular Inclusion P Pspace-c

P

Fig. 1: (Compressed) string patterns.

Dtas Ntas
Regular Matching NP-c Exp-c
Regular Inclusion coNP-c Exp-c

Fig. 2: Linear restriction.
Dtas Ntas

Regular Matching P
Regular Inclusion P Exp-c

P

Fig. 3: (Compressed) tree patterns.
Dtas Ntas
Regular Matching Pspace-c Exp-c
Regular Inclusion Pspace-c Exp-c

Fig. 4: Linear restriction.

Dtas Ntas

Regular Matching P
Regular Inclusion P Exp-c

P

Fig. 5: Adding context variables.

Fig. 6: Linear restriction.

goes down to polynomial time in 3 of the 4 cases, as summarized in Fig. 2. The
problem which remains Pspace-complete is regular inclusion on linear string
patterns for Nfas.

The complexity landscapes of regular matching and inclusion for tree patterns
look quite diﬀerent to the case of string patterns, see Figs. 3 and 4. Here, regular
languages are deﬁned by tree automata, which may either be nondeterministic
(Ntas) or (bottom-up) deterministic (Dtas), while compressed descriptions of
tree patterns can be obtained by singleton tree grammars. Regular matching for
tree patterns against Ntas is Exp-complete with and without compression. For
Dtas, however, regular matching is NP-complete and regular inclusion coNP-
complete. For linear tree patterns, three of the four problems are in P except
for the case of regular inclusion against Ntas. In [3], regular matching for tree
patterns with neither compression nor context variables is studied as the ground
instance intersection problem. Recently [12] studied the problem of matching
compressed terms represented as singleton tree grammars, which is incomparable
with regular matching that we study here.

The prime reason for the asymmetry of the complexity landscapes in the
case of strings and trees is that string patterns cannot be encoded as tree pat-
terns with a monadic signature without adding context variables. For instance,
the string pattern aZZbY corresponds to the tree pattern a(Z(Z(b(Y )))) with
context variable Z and tree variable Y . The interest of adding context variables
to tree patterns was already noticed when generalizing string pattern matching
to context pattern matching [5], which are both NP-complete, with or without
compression. The same was noticed when generalizing string uniﬁcation to con-
text uniﬁcation, that are both in Pspace [6]. Since we are interested in a proper
generalization of regular matching and inclusion from string to tree patterns, we
propose to study these problems for tree patterns with context variables.

The main contributions of the present paper are the complexity classes of reg-
ular matching and inclusion for compressed tree patterns with context variables,

Regular Matching and Inclusion

3

Tree patterns
Context patterns

p, p1, . . . , pn ∈ P tree
P ∈ P context
Σ

Σ ::= x | f (p1, . . . , pn) | P @p

::= X | λx.p where x occurs exactly once in p

Fig. 7: Tree patterns and context patterns, with x ∈ V tree , X ∈ V context , n ≥ 0,
f ∈ Σ(n).

which are summarized in Figs. 5 and 6. As shown in Figure 5, the problems
are both Pspace-complete when the tree automaton representing the language
is deterministic, while they are Exp-complete in the case of a nondeterministic
tree automaton. This complexities coincide with that of the context inhabitation
problem for the two models.

Finally, we show that regular pattern matching and inclusion have the same
complexity for (compressed) patterns on unranked trees with tree and hedge
variables, mainly since such patterns can be encoded into (compressed ranked)
tree patterns with context variables. Compressed patterns for unranked trees
capture Xml streams with references [10]. They permit to generalize the notion
of hyperstreams in [2] from strings to unranked trees.
Outline. We introduce tree patterns with context variables in Section 2. The
inhabitation problem for Σ-algebras is deﬁned in Section 3. The complexity of
context inhabitation for tree automata is discussed in Section 4. Compressed tree
patterns with context variables are introduced in Section 5 and then studied for
regular matching and inclusion in Section 6. Due to space limitation, the discus-
sion of the special cases of linear patterns and patterns with context variables,
as well as the missing proofs, are not included in this extended abstract.

2 Tree Patterns with Context Variables

We consider the set of types T = {tree, context} with the type tree for trees
and the type context = tree (cid:40) tree for contexts. The latter linear type is
inspired by linear logic and is diﬀerent from the usual (nonlinear) function
type tree → tree.We assume sets V tree of tree variables and V context of context
variables. The tree variables are ranged over by x, y, z and the context variables
by X, Y . The set of all variables is V = V tree ∪ V context .

We ﬁx a ﬁnite ranked signature Σ = (cid:93)n≥0Σ(n) of function symbols f ∈ Σ(n)
of arity n. We assume that Σ contains at least one constant and one symbol of
arity at least 2. The set of trees TΣ is the least set that contains all elements
f (t1, . . . , tn) where f ∈ Σ(n) for some n ≥ 0 and t1, . . . , tn ∈ TΣ. Atomic trees
a() ∈ TΣ are deliberately identiﬁed with a ∈ Σ(0). The set of contexts C ∈ CΣ
is the set of all terms λx.p such that p ∈ TΣ(cid:93){x} for some tree variable x ∈ V tree
that occurs exactly once in p. The set of all values of both types is Val Σ =
TΣ ∪ CΣ.

The sets of all tree patterns P tree

are
deﬁned in Fig. 7. Note that both types of patterns may contain context variables.
The set of all patterns is PΣ = P tree
Σ ∪ P context
. For a (tree or context) pattern
Σ
π, its sets of free variables fv(π) and of bound variables bv(π) can be deﬁned

and of all context patterns P context

Σ

Σ

4

I. Boneva, J. Niehren and M. Sakho

Σ

as usual. The set P gr,τ
of ground patterns of type τ ∈ T is the subset of
patterns in P τ
Σ without free variables. The set of all ground patterns is denoted
by P gr
. Clearly, any tree t ∈ TΣ is a ground pattern of
Σ
type tree and any context C ∈ CΣ is a ground pattern of type context. A pattern
is called linear if each of its free variables has at most one free occurrence.

Σ = P gr,tree

∪ P gr,context

Σ

Σ

We can apply β-reduction to both kinds of patterns. Each β-reduction step
replaces some redex of the form (λx.p)@p(cid:48) in a bigger pattern by p[x/p(cid:48)] if x (cid:54)∈
bv(p) and otherwise renames x apart before. Any ground tree pattern p ∈ P gr,tree
can be β-reduced in a linear number of steps to some tree in polynomial time,
of a ground
since all λ-binders are assumed to be linear. The semantics
pattern p is the tree obtained from p by exhaustive β-reduction. Similarly, any
ground context pattern P ∈ P gr,context
can be β-reduced in a linear number of
steps to a unique context λx.p ∈ CΣ. The semantics
:
(cid:75)
is
TΣ → TΣ such that
(cid:75)
is a proper subset of the set of functions
equal to TΣ while
of type TΣ → TΣ.

is the function
P gr,tree
Σ
(cid:74)

P
(cid:74)
(cid:75)
P gr,context
(cid:74)
A substitution σ : V → P gr

Σ where V ⊆ V is called well-typed if it maps
tree variables to P gr,tree
. For any pattern
Σ
p ∈ P tree
is obtained by applying σ to the free
variables in p. The set of all instances of p is obtained by β-normalizing all
groundings:

Σ , the grounding σ(p) ∈ P gr,tree

and context variables to P gr,context

(t) = p[x/t] for any tree t. Note that

P
(cid:74)
TΣ

p
(cid:74)

CΣ

=

=

P

Σ

Σ

Σ

Σ

(cid:75)

(cid:74)

(cid:75)

(cid:74)

(cid:75)

(cid:75)

(cid:74)

(cid:75)

Inst(p) = {
(cid:74)

σ(p)
(cid:75)

| σ : fv(p) → P gr

Σ well-typed}.

Clearly, Inst(p) ⊆ TΣ. For example, consider the tree pattern p = X@(X@a)
and the substitution σ where σ(X) = λx.f (b, x) and σ(x) = a. Then the β-
normalization of the grounding σ(p) = σ(X)@(σ(X)@σ(x)) is the tree t =
f (b, f (b, a)), i.e. t ∈ Inst(p). Similarly, for any P ∈ P context
, we can deﬁne
Σ
the grounding σ(P ) ∈ P gr,context
. The set of instances Inst(P ) contains the
Σ
.
semantics of all groundings of P . Clearly Inst(P ) ⊆

CΣ

(cid:74)

(cid:75)

3

Inhabitation for Σ-Algebras

We recall the notion of inhabitation by trees and contexts in Val Σ for Σ-algebras,
and then relate it to the notion of pattern evaluation in Σ-algebras.

A Σ-algebra ∆ = (dom∆, .∆) consists of a set D = dom∆ called the domain,
and a mapping .∆ that interprets symbols f ∈ Σ(n) as functions f ∆ : Dn → D.
In particular, the set of trees TΣ yields a Σ-algebra, known as the term alge-
bra, whose domain is TΣ and whose interpretation satisﬁes f TΣ (t1, . . . , tn) =
f (t1, . . . , tn). Depending on their type, we can interpret values in Val Σ as el-
ements of dom∆ or as functions on dom∆. The interpretation of a tree t =
∆), while the
tn
f (t1, . . . , tn) ∈ TΣ is the domain element
(cid:74)
∆ : D → D with
interpretation of a context C = λx.p ∈ CΣ is the function
(cid:75)
C

∆ = f ∆(
(cid:74)

∆, . . . ,
C

∆(d) =

p[x/d]

t
(cid:75)

t1

(cid:75)

(cid:75)

(cid:74)

(cid:74)

(cid:74)

(cid:75)

(cid:74)

∆ for all d ∈ D.
(cid:75)

Regular Matching and Inclusion

5

∆,σ = σ(x),
x
(cid:75)
(cid:74)
∆,σ = σ(X)
X
(cid:75)
(cid:74)

∆,σ = f ∆(
f (p1, . . . , pn)
(cid:75)
(cid:74)
∆,σ(d) =
p[x/d]
λx.p
(cid:74)
(cid:75)
(cid:74)

p1
(cid:74)
∆,σ,
(cid:75)

∆,σ),
∆,σ, . . . ,
pn
(cid:74)
(cid:75)
(cid:75)
∆,σ = σ(P )(
p
P @p
(cid:74)
(cid:75)
(cid:74)

∆,σ).
(cid:75)

Fig. 8: Algebra evaluation of patterns.

Deﬁnition 1. Let ∆ be a Σ-algebra. An element d ∈ dom∆ is called ∆-inhabited,
∆. A function S : dom∆ → dom∆
if there exists a tree t ∈ TΣ such that d =
is called ∆-inhabited if there exists a context C ∈ CΣ such that S =

t
(cid:74)

∆.

C

(cid:75)

(cid:75)

(cid:74)
∆ =

(cid:75)

(cid:74)

(cid:74)

(cid:75)

(cid:75)

(cid:74)

(cid:75)

(cid:75)

(cid:74)

p

TΣ

TΣ

TΣ

Val Σ

CΣ
(cid:74)

∆ ∪
The subset of all ∆-inhabited elements and functions is
(cid:74)
∆. We next lift algebra interpretation on values to algebra evaluation on
CΣ
(cid:74)
(cid:75)
∆ with V ⊆ V well-
patterns. We call a variable assignment σ : V →
Val Σ
∆. In
∆ and context variables to
typed, if σ maps tree variables to
(cid:75)
Fig. 8, we deﬁne for any tree pattern p and any well-typed variable assignment
∆, and similarly
∆ with fv(p) ⊆ V the evaluation
∆,σ ∈
Val Σ
σ : V →
(cid:74)
(cid:75)
(cid:75)
∆ for all context patterns P with fv(P ) ⊆ V . The evaluation of
∆,σ ∈
CΣ
P
a ground pattern π ∈ P gr
(cid:75)
(cid:74)
Σ in ∆ does not depend on the variable assignment
∆,σ. Clearly, algebra evaluation
σ. Therefore we can write
(cid:75)
restricted to values is equal to algebra interpretation. Furthermore, note that
Σ can be β-reduced to some
Val Σ
(cid:74)
value in Val Σ which has the same interpretation. Note also that the notion of
∆-inhabitation does not change when based on ground patterns instead of values.
∆ ◦ σ is
∆ =
(cid:75)
(cid:75)
∆◦σ for all tree patterns p with fv(p) ⊆ V . As a consequence for the term
.
(cid:75)
TΣ ◦σ |
.
(cid:75)
(cid:74)

a well-typed variable assignment into
p
(cid:74)
(cid:75)
algebra, the set of instances Inst(p) of a tree pattern p is equal to {
σ : fv(p) → P gr
(cid:74)
Σ well-typed}, and similarly for context patterns P .

∆ since any ground pattern in P gr
(cid:75)

Consider a well-typed variable assignment σ : V → P gr

Σ . Then
∆, such that

.
(cid:74)
(cid:75)
σ(p)
(cid:74)

∆ instead of

P gr
Σ
(cid:74)

P gr
Σ
(cid:74)

Val Σ

∆ =

∆ =

π
(cid:74)

p
(cid:75)

∆,
(cid:74)

TΣ ,

π

(cid:74)

(cid:74)

(cid:75)

(cid:74)

(cid:74)

(cid:75)

(cid:75)

(cid:75)

4

Inhabitation for Tree Automata

We recall the notion of tree automata for recognizing regular languages of trees
and discuss tree and context inhabitation problems for tree automata. As we
will see in the following section, these inhabitation problems are closely related
to regular matching and inclusion for patterns with tree and context variables.

Deﬁnition 2. A (nondeterministic) tree automaton ( Nta) over Σ is a tuple
A = (Q, Σ, F, ∆) where Q is a ﬁnite set of states, F ⊆ Q is the set of ﬁnal
states, and ∆ ⊆ ∪n≥0Σ(n) × Qn+1 is the transition relation.

A rule (f, q1, . . . , qn, q) ∈ ∆ is written as f (q1, . . . , qn) → q. The transition
Σ-algebra of the Nta A – that we equally denote by ∆ – has as its domain 2Q
and interprets the function symbols f ∈ Σ(n) where n ≥ 0 as the n-ary functions
f ∆ such that for all subsets of states Q1 . . . , Qn ⊆ Q:

f ∆(Q1, . . . , Qn) = {q | ∃q1 ∈ Q1 . . . ∃qn ∈ Qn. f (q1, . . . , qn) → q in ∆}.

6

I. Boneva, J. Niehren and M. Sakho

The regular language L(A) recognized by A is deﬁned as the set of all trees in
TΣ whose evaluation in the Σ-algebra ∆ yields some ﬁnal state in F :

L(A) = {t ∈ TΣ |

∆ ∩ F (cid:54)= ∅}.

t
(cid:75)

(cid:74)

An Nta is (bottom-up) deterministic or equivalently a Dta if no two distinct
rules of ∆ have the same left-hand side, i.e., if ∆ is a partial function from
∪n≥0Σ(n) × Qn to Q. The determinization of an Nta A is the tree automaton
det(A) = (2Q, Σ, det(∆), det(F )) where det(∆) = {(f, Q1, . . . , Qn, f ∆(Q1, . . . ,
Qn)) | f ∈ Σ(n), Q1, . . . , Qn ⊆ Q}, and det(F ) = {Q(cid:48) ⊆ Q | Q(cid:48) ∩ F (cid:54)= ∅}. It is
well-known that det(A) is a Dta with L(A) = L(det(A)). Furthermore, for any
tree t ∈ TΣ it holds that
t
(cid:75)
(cid:74)
Tree Inhabitation. Let NtaΣ be the set of all Ntas with signature Σ, and
similarly DtaΣ. We call Nta and Dta automata classes. For any automaton
class A and any signature Σ, tree inhabitation is the following problem:

det(∆) = {

∆}.

(cid:74)

(cid:75)

t

Inhabtree

Σ (A). Input: A tree automaton A = (Q, Σ, F, ∆) ∈ AΣ, Q(cid:48) ⊆ Q.

Output: The truth value of whether Q(cid:48) is ∆-inhabited.

Theorem 1 (Folklore). Tree inhabitation Inhabtree
while its restriction Inhabtree

Σ (Dta) to deterministic tree automata is in P.

Σ (Nta) is Exp-complete,

(cid:74)

(cid:74)

p
(cid:75)

p
(cid:75)

Proof. Let A = (Q, Σ, F, ∆) be an Nta and Q(cid:48) ⊆ Q. By deﬁnition, Q(cid:48) is ∆-
∆ = Q(cid:48), which is equivalent
inhabited iﬀ there exists a tree p ∈ TΣ such that
det(∆) = {Q(cid:48)}. Thus Q(cid:48) is ∆-inhabited iﬀ Q(cid:48) is accessible in the tree
to that
automaton det(A). This can be tested in polynomial time from det(A) which is
computed in exponential time. Thus Inhabtree
Σ (Nta) is in Exp. If A is a Dta,
then there is no need to determinize it and Q(cid:48) is a singleton. It is thus suﬃcient to
test whether Q(cid:48) is accessible in A. Hence Inhabtree
Σ (Dta) is in polynomial time.
Σ (Nta) is Exp-hard. This is achieved by
reduction from the problem of non-emptiness of the intersection of a sequence of
Dtas, which is well known to be Exp-complete [13]. Let A1, . . . , An be a sequence
of Dtas with alphabet Σ. Suppose that Ai = (Qi, Σ, ∆i, F i). Without loss of
generality, we can assume that each of them has a single ﬁnal state F i = {qi
f }.
i=1Qi,
Let A be the disjoint union of all Ai, that is A = (Q, Σ, F, ∆) where Q = (cid:93)n
∆ = (cid:93)n
f }. Since all Ai are deterministic, we can then
show that t ∈ ∩n
(cid:117)(cid:116)

We now have to show that Inhabtree

i=1L(Ai) iﬀ F is ∆-inhabited by t.

i=1∆i and F = {q1

f , . . . , qn

Context Inhabitation. Contexts evaluate to very particular functions in tran-
sition algebras of tree automata, since they use their bound variable once.

Deﬁnition 3. A union homomorphism on 2Q is a function S : 2Q → 2Q such
that S(∅) = ∅ and for all Q(cid:48), Q(cid:48)(cid:48) ⊆ Q, S(Q(cid:48) ∪ Q(cid:48)(cid:48)) = S(Q(cid:48)) ∪ S(Q(cid:48)(cid:48)).

Lemma 1 (Folklore). For any context C ∈ CΣ and Nta A = (Q, Σ, F, ∆) the
semantics

∆ is a union homomorphism on 2Q.

C

(cid:74)

(cid:75)

Regular Matching and Inclusion

7

The main reason to restrict ourselves to contexts is that Lemma 1 would
fail for nonlinear λ-terms such as N = λx.f (x, x). In order to see this, consider
the signature Σ = {a, f } where a is a constant and f a symbol of arity 2, and
the Nta A = (Q, Σ, F, ∆) with Q = {q1, q2, qok}, F = {qok} and ∆ = {a →
∆({q2}) = ∅, while
q1, a → q2, f (q1, q2) → qok}. We have
(cid:75)
∆({q2}),
∆({q1, q2}) (cid:54)=
∆({q1, q2}) = {qok}. Hence,
N
N
(cid:74)
(cid:74)
(cid:75)
∆ is not a union homomorphism and cannot be represented by a
so that
function s : Q :→ 2Q as stated in Lemma 2. Since union homomorphisms are
determined by their images on singletons, they can be represented by functions
s : Q → 2Q. Conversely, every such function deﬁnes the union homomorphism
ˆs : 2Q → 2Q such that for any Q(cid:48) ⊆ Q: ˆs(Q(cid:48)) = ∪q∈Q(cid:48)s(q).

N
(cid:74)
∆({q1}) ∪
(cid:75)

∆({q1}) =
N

N
(cid:74)

N

N

(cid:75)

(cid:74)

(cid:75)

(cid:75)

(cid:74)

(cid:74)

(cid:75)

Lemma 2. If S : 2Q → 2Q is a union homomorphism then S = ˆs where s :
Q → 2Q is the function with s(q) = S({q}) for all q ∈ Q.

We next consider the problem of context-inhabitation for tree automata.

Here, the input is a succinct descriptor of a union homomorphism:

Inhabcontext
Σ

(A). Input: An automaton A = (Q, Σ, F, ∆) ∈ AΣ, s : Q → 2Q.

Output: The truth value of whether ˆs is ∆-inhabited.

Context inhabitation is a restriction of the more general λ-deﬁnability prob-
lem, which is undecidable [9,7]. However, λ-deﬁnability for orders up to 3 is decid-
able [14], and context-inhabitation is a special case of second-order λ-deﬁnability.
Its precise complexity, however, has not been studied so far to the best of our
knowledge.

Proposition 1. Let A = (Q, Σ, F, ∆) be an Nta and s : Q → 2Q. Then ˆs is
∆-inhabited iﬀ there exists C ∈ CΣ such that for all q ∈ Q, s(q) =

∆({q}).

C

(cid:74)

(cid:75)

Proof. The forward implication is straightforward. For the backwards direction,
∆({q}) for all q ∈ Q. Since ˆs is
let C ∈ CΣ be a context with s(q) =
a union homomorphism, we have for all Q(cid:48) ⊆ Q that ˆs(Q(cid:48)) = ∪q∈Q(cid:48)s(q) =
∆ is a union-homomorphism by Lemma 1.
∪q∈Q(cid:48)
C
(cid:75)
(cid:74)
(cid:117)(cid:116)
Thus ˆs is ∆-inhabited.

∆(Q(cid:48)) since

∆({q}) =

C
(cid:74)

C

C

(cid:75)

(cid:74)

(cid:75)

(cid:74)

(cid:75)

Theorem 2. Context inhabitation is Exp-complete for Ntas while it is Pspace-
complete for Dtas.

Proof. The Pspace-hardness of Inhabcontext
(Dta) can be shown by reduction
Σ
from the problem of non-emptiness of the intersection of a ﬁnite number of De-
terministic Finite Automata (Dfas), while a Pspace algorithm can be obtained
for it by reduction to this problem. We next present an exponential time al-
gorithm for Inhabcontext
(Nta) based on determinization. Let A = (Q, Σ, F, ∆)
be an Nta where Q = {q1, . . . , qn} and s : Q → 2Q. We ﬁx a variable x ∈ V e
arbitrarily. For each i ∈ {1, . . . , n}, let Ai = (Q, Σ (cid:93) {x}, ∆ ∪ {x → qi}, F ). For
Ai is the set of states to which C can be evaluated
any context C = λx.p,
when starting at the hole marker x with state qi. Let ˜A be the product Dta

p
(cid:75)

Σ

(cid:74)

8

I. Boneva, J. Niehren and M. Sakho

˜A = det(A1) × . . . × det(An). Note that the number of states of ˜A is at most
(2n)n = 2n2
, which is exponential. Furthermore, the tuple (s(q1), . . . , s(qn)) is
an accessible state of ˜A if and only if there is a context λx.p ∈ CΣ such that
∆({qi}) = s(qi). By Proposition 1 this is equivalent to
for all 1 ≤ i ≤ n,
that ˆs is ∆-inhabited. Testing whether (s(q1), . . . , s(qn)) is accessible in ˜A is in
polynomial time in the size of ˜A and thus in exponential time too. The Exp-
hardness of Inhabcontext
(Nta) can be shown by reduction from the intersection
problem of Dtas. The idea of the proof is similar to that of the Pspace-hardness
proof of Dfa-inhabitation (see [2]), so we omit the details.
(cid:117)(cid:116)

λx.p

Σ

(cid:74)

(cid:75)

5 Compressed Tree Patterns

We now recall compressed tree patterns with context variables that are deﬁned
by singleton tree grammars.

Deﬁnition 4. A compressed pattern (with context variables) of type τ ∈ T
is an acyclic context-free tree grammar G = (N, Σ, R, S) where N ⊆ V is a
ﬁnite set of nonterminals, S ∈ N ∩ V τ is the start symbol, R is a partial well-
typed function from N to patterns in PΣ with free variables in N . The set of all
compressed tree patterns of type τ is denoted by cP τ
Σ.

For instance, consider the compressed tree pattern G ∈ cP tree

Σ with the
nonterminals N = {x, X, Y, Z, y}, with S = x and with two rules R(x) =
X@a(X@b, Y @c), and R(X) = λx.Z@a(x, y). This grammar is acyclic, in that
no variable on the left hand side of some rule can appear in any subsequent rule.
It should be noticed that the tree language of the grammar G is ∅. What interests
us instead is the tree pattern pat(G) = (λx.Z@a(x, y))@a((λx.Z@a(x, y))@b, Y @c)
that G represents in a compressed manner. By exhaustive β-reduction of pat(G)
we obtain the tree pattern with context variables

pat(G)

= Z@a(a(Z@a(b, y), Y @c), y).

(cid:74)

(cid:75)

We deﬁne the free variables of a compressed tree pattern G as the free vari-
ables of pat(G), and the bound variables of G as the nonterminals in dom(R)
and the bound variables on the right-hand sides of these rules.
In what follows we will identify any tree pattern p ∈ P tree

Σ with the com-
Σ that has a single rule mapping a new start symbol
Σ ⊆
Σ . A compressed tree pattern G is called linear if its tree pattern pat(G)

pressed tree pattern in cP tree
to p. This compressed tree pattern has no compression. In this sense, P tree
cP tree
is linear.

Let A = (Q, Σ, F, ∆) be an Nta, V ⊆ V a ﬁnite subset of variables, and σ a
function with domain V that maps any tree variable x ∈ V to σ(x) ⊆ Q and any
context variable X ∈ V to a function σ(X) : Q → 2Q. Note that σ(X) represents
the union homomorphism (cid:91)σ(X) : 2Q → 2Q. Let ˆσ be such that ˆσ(x) = σ(x) for
all x ∈ V and ˆσ(X) = (cid:91)σ(X) for all X ∈ V .

Lemma 3. For any G = (N, Σ, R, S) ∈ cP tree
pat(G)
(cid:75)

∆,ˆσ in polynomial time from A, G, and σ.

(cid:74)

Σ with fv(G) ⊆ V we can compute

Regular Matching and Inclusion

9

Proof. The algorithm evaluates the pattern inductively along the partial order
on the nonterminals of G; the latter exists because G is acyclic. For any v ∈ V ,
let Gv be the compressed tree pattern equal to G except that the start symbol
∆,ˆσ can be
is changed to v. Then we can show for all v ∈ V that
computed in polynomial time from A, G, and σ. In particular this holds for
(cid:117)(cid:116)
pat(G)
(cid:74)

pat(GS)
(cid:75)
(cid:74)

pat(Gv)
(cid:75)

∆,ˆσ =

∆,ˆσ.

(cid:74)

(cid:75)

6 Regular Matching and Inclusion

We now study the complexity of regular matching and inclusion for classes G of
compressed tree patterns with context variables such as P tree and cP tree .

Deﬁnition 5. For any class G of compressed tree patterns, any class A of Ntas,
and for any ranked alphabet Σ we deﬁne two decision problems:

Regular pattern inclusion InclΣ(G, A). Input: A compressed tree pattern

G ∈ GΣ and a tree automaton A ∈ AΣ.
Output: The truth value of whether Inst(pat(G)) ⊆ L(A).

Regular pattern matching MatchΣ(G, A). Input: A compressed tree pat-

tern G ∈ GΣ and a tree automaton A ∈ AΣ.
Output: The truth value of whether Inst(pat(G)) ∩ L(A) (cid:54)= ∅.

The following characterization of regular matching induces a decision proce-
dure by reduction to context inhabitation, and is useful in the hardness proof.

Lemma 4. Let A = (Q, Σ, F, ∆) be an Nta, p ∈ P tree
Σ be a tree pattern. Then
Inst(p) ∩ L(A) (cid:54)= ∅ if and only if there exists a well-typed assignment into ∆-
∆ such
inhabited subset of states and union-homomorphisms σ : fv(p) →
that

∆,σ ∩ F (cid:54)= ∅.

Val Σ

(cid:74)

(cid:75)

p
(cid:74)

(cid:75)

Proposition 2 (Lower Bound Matching). MatchΣ(P tree , Dta) is Pspace-
hard while MatchΣ(P tree , Nta) is Exp-hard.

Σ

(Dta) to MatchΣ(P tree , Dta) in polynomial time,

Proof. We reduce Inhabcontext
then the Pspace-hardness of the latter problem follows from Theorem 2. Let
A = (Q, Σ, F, ∆) be a complete Dta– otherwise it is completed – and s : Q → 2Q
a function. We set Q = {q1, . . . , qn} and consider a new symbol # (cid:54)∈ Σ of arity
n and a new state q#. Since A is deterministic and complete, s must map states
to singletons in order to be inhabited. Let γ1, . . . , γn ∈ Q be the states such that
s(q1) = {γ1}, . . . , s(qn) = {γn}. From this we build a new Dta ˜A = ( ˜Q, ˜Σ, ˜F , ˜∆)
where ˜Q = Q∪{q#}, ˜Σ = Σ ∪{#}∪Q, ˜F = {q#} and ˜∆ = ∆∪{#(γ1, . . . , γn) →
q#}. Let X ∈ V context and p = #(X@q1, . . . , X@qn) ∈ P tree
. The reduction is
induced by the following claim, whose technical proof is based on Lemma 4
without any special tricks.

˜Σ

Claim. The function ˆs is ∆-inhabited if and only if Inst(p) ∩ L( ˜A) (cid:54)= ∅.

10

I. Boneva, J. Niehren and M. Sakho

For the Exp-hardness of MatchΣ(P tree , Nta), it is suﬃcient to notice that the
ground instance intersection problem [4], which is an Exp-hard problem in the
case of Ntas, is equivalent to regular matching with only ﬁrst-order variables
for Ntas. The latter is a special case of regular matching with context variables.

Lemma 5 (Complementation). Regular inclusion and matching are comple-
mentary problems for deterministic automata: For any class of compressed tree
patterns G, InclΣ(G, Dta) and coMatchΣ(G, Dta) are equivalent modulo P.

Proof. For a compressed tree pattern G and an Nta A, Inst(p) ⊆ L(A) iﬀ
Inst(p)∩L(A) = ∅ iﬀ = Inst(p)∩L(A) = ∅, and the complementation operation is
polynomial for Dtas and exponential for Ntas– since it requires determinization.

Proposition 3 (Lower Bound Inclusion). InclΣ(P tree , Dta) is Pspace-
hard while InclΣ(P tree , Nta) is Exp-hard.

Proof. Lemma 5 states that InclΣ(P tree , Dta) = coMatchΣ(P tree , Dta) mod-
ulo P. By Proposition 2, MatchΣ(P tree , Dta) is Pspace-hard and since Pspace
is closed by complement, coMatchΣ(P tree , Dta) is Pspace-hard too. It then
holds that InclΣ(P tree , Dta) is Pspace-hard. For the Exp-hardness of InclΣ(P tree , Nta),
we make a straightforward reduction from the problem of universality of Ntas,
which is ExpTime-hard.
(cid:117)(cid:116)

We next reduce the problems of regular matching and inclusion to context

inhabitation for tree automata in order to obtain upper complexity bounds.

Proposition 4 (Upper Bounds). MatchΣ(cP tree , Dta) and InclΣ(cP tree , Dta)
are in Pspace, while MatchΣ(cP tree , Nta) and InclΣ(cP tree , Nta) are in
Exp.

Σ be a compressed tree pattern with start symbol S ∈ V tree
Proof. Let G ∈ cP tree
and set of nonterminals N , and A = (Q, Σ, F, ∆) be a tree automaton. According
to Lemma 4, to decide whether pat(G) matches L(A) it is suﬃcient to ﬁnd a
well-typed assignment σ with domain fv(G) such that σ(x) ⊆ Q for all x ∈ fv(G)
and σ(X) : Q → 2Q for all X ∈ fv(G). Furthermore, (cid:98)σ : fv(G) →
Val Σ
(cid:75)
must map to ∆-inhabited subsets of Q and ∆-inhabited union-homomorphisms
of type 2Q → 2Q such that (cid:98)σ(pat(G)) ∩ F (cid:54)= ∅. Thus the algorithm iterates
over all such σ, tests the inhabitation of (cid:98)σ(v) for all v ∈ N , and checks that
(cid:98)σ(pat(G)) ∩ F (cid:54)= ∅. It is successful if the test succeeds for some σ. The number
of iterations is at most 2|Q|2.|fv(G)|, and can be done in a polynomial space.
Moreover inhabitation can be tested in a polynomial space for if A is a Dta,
while it requires at least time an exponential time if A is an Nta– Theorems 1
and 2. We can also compute (cid:98)σ(pat(G)) in polynomial time from A, G, and σ
by Lemma 3. Thus the algorithm is in Pspace for Dtas and Exp for Ntas.
For InclΣ(cP tree , Dta) and InclΣ(cP tree , Nta), the algorithm is similar except
that the condition (cid:98)σ(pat(G)) ∩ F (cid:54)= ∅ must hold for all (cid:98)σ mapping fv(G) to ∆-
(cid:117)(cid:116)
inhabited sets of states and functions.

(cid:74)

Regular Matching and Inclusion

11

Hedge patterns H, H (cid:48) ∈ P h

Γ ::= Y | a(H) | ε | Z | HH (cid:48)

Encoding

(cid:104)Y (cid:105)context = Y,
(cid:104)Z(cid:105)context = Z,

(cid:104)a(H)(cid:105)context = λy.a((cid:104)H(cid:105)context @#, y),
(cid:104)HH (cid:48)(cid:105)context = λy.((cid:104)H(cid:105)context @((cid:104)H (cid:48)(cid:105)context @y)),

(cid:104)ε(cid:105)context = λy.y,
(cid:104)H(cid:105)tree = (cid:104)H(cid:105)context @#.

Fig. 9: Encoding of a hedge pattern H ∈ P h
P context

, where Y ∈ V u, Z ∈ V h, a ∈ Γ , and ε is the empty word.

Γ into a context pattern (cid:104)H(cid:105)context ∈

Σ

7 Encoding Patterns for Unranked Trees

The original motivation of the present work was to understand the problems of
regular matching and inclusion for hedge patterns. We next show that these prob-
lems can be solved using reductions to the corresponding problems of (ranked)
tree patterns with context variables.

Unlike ranked trees, unranked trees are constructed from symbols without
ﬁxed arities. We ﬁx a ﬁnite set Γ of such symbols. The set of hedges HΓ is the
∗ and all pairs a(H) where a ∈ Γ
least set that contains all words of hedges in HΓ
and H ∈ HΓ is a hedge. The set of unranked trees UΓ is the subset of hedges of
the form a(H).

We assume a set of variables for unranked trees Y ∈ V u and a set of hedge
variables Z ∈ V h. The set of hedge patterns H ∈ P h
Γ with these two types
of variables is then deﬁned by the abstract syntax in Fig. 9. The set P u
Γ of
patterns for unranked trees is the subset of hedge patterns of the forms a(H) or
Y ∈ V u. The set of free variables fv(H) is deﬁned as usual. A well-typed variable
assignment σ : V → HΓ where V ⊆ V u (cid:93) V h is a function that maps variables
from V u to unranked trees in UΓ and variables from V h to hedges in HΓ . The
application σ(H) is the hedge obtained from H by replacing all variables Y by
the unranked tree σ(Y ) and all variables Z by the hedge σ(Z). The instance
set of H is denoted Inst(H) = {σ(H) | σ : fv(H) → HΓ well-typed}. Note that
Inst(H) ⊆ UΓ for any unranked tree pattern H ∈ P u
Γ .

We next show in Fig. 9 how to encode hedge patterns into (ranked) context
patterns over the signature Σ = Σ(2) (cid:93) Σ(0) where Σ(2) = Γ and Σ(0) = {#} for
# is a fresh symbol not in Γ . For instance, the hedge pattern H0 = a(ZbcY ) is
encoded into the context pattern (cid:104)H0(cid:105)context = λy.a(Z@(b(#, c(#, Y @#))), y).
The concatenation operation on hedges is simulated by the application operation
of contexts. The set of context variables used in the encoding is V context =
V u (cid:93) V h, while the set V tree of tree variables is left arbitrary. Finally, we deﬁne
for any unranked tree H ∈ P u
Σ by
(cid:104)H(cid:105)tree = (cid:104)H(cid:105)context @#.

Γ its encoding as a tree pattern (cid:104)H(cid:105)tree ∈ P tree

In order to show the soundness of this encoding (Lemma 6 below), we need
to restrict the instantiation operation. Intuitively, we cannot allow arbitrary
substitutions to be applied to (cid:104)H(cid:105)tree because then the resulting tree pattern
might not be a correct encoding of an unranked tree. A variable assignment
σ : V → Val Σ is called unranked if it maps unranked tree variables to (cid:104)UΓ (cid:105)context
and hedge variables to (cid:104)HΓ (cid:105)context . The unranked-restricted instance set of a tree

12

I. Boneva, J. Niehren and M. Sakho

pattern p is deﬁned by Inst unr(p) = {
σ(p)
(cid:74)
unranked} and similarly for Inst unr(P ).

(cid:75)

| σ : fv(p) → Val Σ well-typed and

Lemma 6.

(cid:104)Inst(H)(cid:105)tree

(cid:74)

(cid:75)

= Inst unr((cid:104)H(cid:105)tree ) for any H ∈ P u
Γ .

Proof. We can prove for any H ∈ P u
by induction of the structure of H. This claim implies the lemma.

(cid:104)Inst(H)(cid:105)context

Γ that

(cid:74)

(cid:75)

= Inst unr((cid:104)H(cid:105)context )

Let cP u

Γ be the set of compressed unranked trees over Γ , deﬁned in an analo-
gous way as compressed tree patterns. For a class of automata A ∈ {Dta, Nta},
the problem MatchΓ (cP u, A) of regular matching of compressed unranked tree
patterns takes as input an unranked tree pattern H ∈ cP u and an automaton A
in class A, and outputs the truth value of whether Inst unr((cid:104)H(cid:105)tree ) ∩ L(A) (cid:54)= ∅.
The problem InclΓ (cP u, A) of regular inclusion for compressed patterns of
unranked trees is deﬁned in an analogous way. Note that using tree automata
in the above deﬁnitions is not a restriction, as it is well known [3] that for any
unranked tree language L recognizable by a hedge automaton, there exists a tree
automaton that recognizes the encodings as ranked trees of the trees in L.

Proposition 5. For any A ∈ {Dta, Nta} there exist polynomial time reduc-
tions from MatchΓ (cP u, A) to MatchΣ(cid:48)(cP tree , A) and from InclΓ (cP u, A)
to InclΣ(cid:48)(cP tree , A) for some signature Σ(cid:48) derived from Σ.

Proof idea. The basic idea is to use Lemma 6, but we also need to constrain
the variable assignments for the encoded patterns to be unranked. We illustrate
how this works on an example for the case of regular matching. Consider the
Γ , a language L ⊆ UΓ and an Nta A over Σ
unranked tree pattern H = a(Z) ∈ P u
with L(A) = (cid:104)L(cid:105)tree . From (cid:104)H(cid:105)tree = a(Z@#, #), we build the compressed tree
pattern pH = a(rootZ(Z@holeZ(#)), #), where rootZ and holeZ are new unary
symbols. We also construct a Nta A(cid:48) from A so that Inst unr((cid:104)H(cid:105)tree ) ∩ L(A) (cid:54)= ∅
iﬀ Inst(pH ) ∩ L(A(cid:48)) (cid:54)= ∅. Basically in pH any variable Z is “enclosed” between
the rootZ and holeZ symbols, and A(cid:48) tests that any context between rootZ and
holeZ is a correct encoding of an unranked hedge.

Theorem 3. MatchΓ (cP u, Dta) and InclΓ (cP u, Dta) are Pspace-complete
while MatchΓ (cP u, Nta) and InclΓ (cP u, Nta) are Exp-complete.

Proof. The upper bounds follow via the polynomial time reduction from Propo-
sition 5 and the complexities in Proposition 4. The lower bounds can be obtained
by reducing the equivalent problems on ranked patterns to the version on un-
(cid:117)(cid:116)
ranked patterns, and further using the results in Propositions 2 and 3.

Conclusion. We have shown that regular matching and inclusion for ranked tree
patterns with context variables is Exp-complete with and without compression.
The complexity goes down to P for linear compressed tree patterns in 3 of 4 cases.
The same result holds for unranked tree patterns with hedge variables, which is
relevant to certain query answering on hyperstreams. Previous approaches were
limited to hyperstreams containing words (compressed string patterns), while

Regular Matching and Inclusion

13

the present approach can deal with hyperstreams containing unranked data trees
(compressed unranked tree patterns).
Acknowledgments. We are grateful to Sylvain Salvati for pointing out and
helping to solve diﬃculties. This work was partially supported by a grant from
CPER Nord-Pas de Calais/FEDER DATA Advanced data science and technolo-
gies 2015-2020.
References

1. D. Angluin. Finding patterns common to a set of strings. Journal of Computer

and System Sciences, 21:46–62, 1980.

2. I. Boneva, J. Niehren, and M. Sakho. Certain query answering on compressed string
patterns: From streams to hyperstreams. In Reachability Problems - 12th Interna-
tional Conference, RP 2018, Marseille, France, September 24-26, 2018, Proceed-
ings, pages 117–132, 2018.

3. H. Comon, M. Dauchet, R. Gilleron, C. L¨oding, F. Jacquemard, D. Lugiez, S. Tison,
and M. Tommasi. Tree automata techniques and applications. Available online
since 1997: http://tata.gforge.inria.fr, Oct. 2007.

4. H. Comon, M. Dauchet, R. Gilleron, C. L¨oding, F. Jacquemard, D. Lugiez,
S. Tison, and M. Tommasi. Tree automata techniques and applications., 2007.
http://www.grappa.univ-lille3.fr/tata.

5. A. Gasc´on, G. Godoy, and M. Schmidt-Schauß. Context matching for compressed
terms.
In Proceedings of the Twenty-Third Annual IEEE Symposium on Logic
in Computer Science, LICS 2008, 24-27 June 2008, Pittsburgh, PA, USA, pages
93–102. IEEE Computer Society, 2008.

6. A. Jez. Context uniﬁcation is in PSPACE. In J. Esparza, P. Fraigniaud, T. Hus-
feldt, and E. Koutsoupias, editors, Automata, Languages, and Programming - 41st
International Colloquium, ICALP 2014, Copenhagen, Denmark, July 8-11, 2014,
Proceedings, Part II, volume 8573 of Lecture Notes in Computer Science, pages
244–255. Springer, 2014.

7. T. Joly. Encoding of the halting problem into the monster type & applications.
In M. Hofmann, editor, Typed Lambda Calculi and Applications, 6th International
Conference, TLCA 2003, Valencia, Spain, June 10-12, 2003, Proceedings., volume
2701 of Lecture Notes in Computer Science, pages 153–166. Springer, 2003.

8. P. Labath and J. Niehren. A functional language for hyperstreaming XSLT. Tech-

nical report, INRIA Lille, 2013.

9. R. Loader. The undecidability of λ-deﬁnability. In Z. M. Anderson C.A., editor,

Logic, Meaning and Computation, volume 305. Springer, 2001.

10. S. Maneth, A. O. Pereira, and H. Seidl. Transforming XML streams with refer-
ences. In C. S. Iliopoulos, S. J. Puglisi, and E. Yilmaz, editors, String Processing
and Information Retrieval - 22nd International Symposium, SPIRE 2015, London,
UK, September 1-4, 2015, Proceedings, volume 9309 of Lecture Notes in Computer
Science, pages 33–45. Springer, 2015.

11. W. Plandowski. Satisﬁability of word equations with constants is in PSPACE. J.

ACM, 51(3):483–496, 2004.

12. M. Schmidt-Schauß. Linear pattern matching of compressed terms and polynomial
rewriting. Mathematical Structures in Computer Science, 28(8):1415–1450, 2018.
13. H. Seidl. Deciding equivalence of ﬁnite tree automata. SIAM Journal on Comput-

ing, 19(3):424–437, 1990.

14. M. Zaionc. Probabilistic approach to the lambda deﬁnability for fourth order types.

Electr. Notes Theor. Comput. Sci., 140:41–54, 2005.

