Computing Difference Abstractions of Metabolic
Networks Under Kinetic Constraints
Emilie Allart, Cristian Versari, Joachim Niehren

To cite this version:

Emilie Allart, Cristian Versari, Joachim Niehren. Computing Difference Abstractions of Metabolic
Networks Under Kinetic Constraints. CMSB 2019 - 17th International Conference on Computational
Methods in Systems Biology, Luca Bortolussi; Guido Sanguinetti, Sep 2019, Trieste, Italy. pp.266-285,
￿10.1007/978-3-030-31304-3_14￿. ￿hal-02302463￿

HAL Id: hal-02302463

https://hal.science/hal-02302463

Submitted on 1 Oct 2019

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Copyright

Computing Diﬀerence Abstractions of Metabolic Networks
Under Kinetic Constraints

Emilie Allart1,2, Joachim Niehren1,3, and Cristian Versari1,2

1 BioComputing Team, CRIStAL Lab, Lille
2 Universit´e de Lille
3 Inria Lille

Abstract. Algorithms based on abstract interpretation were proposed recently for pre-
dicting changes of reaction networks with partial kinetic information. Their prediction
precision, however, depends heavily on which heuristics are applied in order to add linear
consequences of the steady state equations of the metabolic network. In this paper we ask
the question whether such heuristics can be avoided while obtaining the highest possible
precision. This leads us to the ﬁrst algorithm for computing the diﬀerence abstractions
of a linear equation system exactly without any approximation. This algorithm relies on
the usage of elementary ﬂux modes in a nontrivial manner, ﬁrst-order deﬁnitions of the
abstractions, and ﬁnite domain constraint solving.

Keywords. Gene knockout prediction, reaction networks, constraints, systems biology, syn-
thetic biology, metabolism.

1 Introduction

Flux balance analysis [16,17] can be used to predict the eﬀect of inﬂux changes of metabolic
networks at steady state. Such predictions can be based on reasoning with linear equations
systems that describe the rates of the reactions in a steady state of the metabolic network, by
using Gaussian elimination, elementary ﬂux modes (EFMs) [13], or optimisation methods [14,6].
Most importantly, precise quantitative kinetic information is not required in contrast to classical
mathematical analysis methods for reaction networks [9,2,11,7]. In fact, even when the kinetic
functions associated to chemical reactions are known, the values of rate constants are most often
missing, since it is diﬃcult to measure them experimentally in the precise state of the regulation
of the metabolic network at the time point of interest.

Recently, abstract interpretation [3,8,5] has been exploited to design novel algorithms [15,4,12]
that can use partial kinetic information beneﬁcially for predicting changes of metabolic networks.
They can in particular exploit the knowledge about the enzymes and inhibitors. Similarly to ﬂux
balance analysis, the linear equations describing steady states are used, but in addition to them,
kinetic constraints are inferred from the partial kinetic information of inhibitors and enzymes.

The steady state equations and the kinetic constraints enable gene knockout predictions based
on abstract interpretation (in the ﬁnite relational structure ∆6), based on the linear equations
from the metabolic network and the constraints on its regulatory control. The unknown kinetic
parameters are abstracted away, by interpretation over some ﬁnite relational structure, that
contains a ﬁnite number of abstract diﬀerences rather than concrete diﬀerences in R2
+. Eventually,
the prediction algorithm will apply a ﬁnite domain constraint solver for ∆6 that we implemented
in Minizinc [18] to enumerate all the changes that may or must lead to the target change.

The prediction quality of abstract interpretation approaches heavily depends on heuristics
that ﬁnd and add linear equations entailed by the steady state equations before constraint solving
over ∆6. This is necessary to enable global reasoning, since local reasoning alone is not able to

Fig. 1. A toy metabolic network with
a simple cycle.

Fig. 2. A glimpse of the formal model from [4] of leucine
production in B. subtilis.

deal with cycles in metabolic part of the network as we will illustrate in Section 2. On the
other hand, it is impossible to add the inﬁnity of all entailed linear equations before abstract
interpretation. Therefore, these algorithms can at best approximate the abstraction of diﬀerences
of solution set of linear equations. Whether this abstraction can be computed exactly is a long
standing open problem, as well as how to measure the quality of approximation heuristics.

In this paper, we present the ﬁrst exact algorithm that can compute the ∆6 diﬀerence ab-
straction of the solution set of a linear equation system without any overapproximation. We
apply it to the prediction of leucine overproduction, a benchmark task that is best studied with
abstract interpretation. In this case, we need to deal with kinetic constraints in addition that
are naturally interpreted over ∆6. It turns out that a new heuristic that we also propose in the
present paper does indeed compute well the diﬀerence abstraction at this benchmark task from
systems biology, although being inexact in the general case. The main advantage of this heuristic
is that it outperforms the exact algorithm dramatically in computation time: only 5 minutes are
needed for the knockout prediction rather than 5 hours with the always exact algorithm.

2 Qualitative reasoning on metabolic reaction networks

The application of abstract interpretation to the analysis of metabolic reaction networks is based
on an intuitive qualitative reasoning. Its aim is to predict how a living organism or its environment
should be changed in order to maximize the production of some metabolite of interest, without
exact knowledge of the quantitative parameters of the system. A change of the organism is
represented for example by any modiﬁcation of its genome, such as a gene knockout. A change
of the environment is typically represented by the modiﬁcation of the culture medium, which
results in an increase or decrease of some inﬂows. Since changes can be arbitrarily combined to
obtain or improve the wanted results, the problem that we tackle is highly combinatorial.

Examples of formal metabolic networks on which abstract interpretation can be applied are
shown in Fig. 1 and Fig. 2. Fig. 1 shows a toy metabolic network with a simple cycle that will
be used in the following to introduce the key ideas of the reasoning. In this network, metabolites
are displayed in yellow rounded boxes, while reactions are in gray squared boxes, in the tradition
of Petri nets. Reactions with dotted contour are inﬂows or outﬂows of the system.

Fig. 2 shows a glimpse of a bigger metabolic reaction network with regulation, where the
regulatory part is represented by the enzymes in blue rounded boxes. The full network of Fig. 2
models a part of the metabolism of the gram positive bacterium B. subtilis. Our benchmark
application – taken from [4] – is the overproduction of one of the metabolites of this network,
the branched chain amino acid Leucine (Leu). This amino acid is a precursor of surfactin, a non
ribosomal peptide with several applications in food and pharmaceutical industry.

2

Let us now reconsider the toy model with a simple cycle in Fig. 1. This network is composed
of two chemical species A and B. The species A is continuously produced by an inﬂow at a ﬁxed
rate X, and is transformed into B by the reaction with rate V . The inverse reaction with rate
V- transforms B back into A. The species B has an outﬂow with rate Y . All reactions but the
inﬂow are controlled internally by the system. The outﬂow rate Y in particular is determined by
the concentration of B which in turn depends on the rates V and V-.

The only possible change in this toy network is the increase or decrease of the inﬂow X. In
order to illustrate the reasoning method, we set the increase of Y as our ﬁnal target. As usually
done in ﬂux balance analysis [16,17], we consider the system at the steady state, that gives us
the following linear system of equations:

∃V ∃V-. V = X + V- ∧ V = Y + V-
The existential quantiﬁers for V and V- allow us to hide the internal behaviour of the network,
so to project to inﬂows and outﬂows. While the consequences of steady state equations may be
diﬃcult to interpret without using Gauss’ algorithm, in this particular case it is easy to see that
by subtracting the ﬁrst equation in (1) from the second we obtain an important relation:

(1)

X = Y

(2)

Eq. (2) tells us that the only way for Y to increase is that X increases too. We formalize now this
intuition by means of abstract interpretation, this time applied to concrete diﬀerences in R2
+.
Concrete diﬀerences capture the essence of a change in the spirit of [15]: a change of the value
of X for instance can be thought of as a pair of positive reals (rbefore, rafter) representing the
value of X at steady state respectively before and after the modiﬁcation of the environment. We
need to consider positive reals since the rates of irreversible reactions are positive. We call the
above concrete diﬀerences an increase if rbefore < rafter, a decrease if rbefore > rafter and a no-
change if rbefore = rafter. This intuition motivates the usage of abstract values in ∆3 = {(cid:97), (cid:96), ∼∼∼}
where (cid:97) = (0, 1) represents an increase, (cid:96) = (1, 0) a decrease, and ∼∼∼ = (0, 0) a no-change. The
canonical mapping of concrete diﬀerences in R2
+ to the abstract diﬀerences in ∆3 can be seen as a
homomorphism between the relational structures R2
+ to ∆3. This algebraic view of abstractions
as homomorphisms enables various generalizations. An example is the abstraction from R2
+ to
∆6 – as considered for gene knockout prediction [12,4] – which reﬁnes each of the three R2
+
equivalence classes produced by ∆3 into two parts in ∆6.

Any abstraction of concrete diﬀerences enables some form of abstract qualitative reasoning
[10] based on operations of the relational structure of abstract diﬀerences, that can be used
for change prediction in systems biology. Let us illustrate how to reason with ∆3. As a ﬁrst
example, assume that we know for some reason that X and V- both increase, that is X = (cid:97)
and V- = (cid:97). Then we can use the ﬁrst equation in (1) to deduce for sure V will also increase,
since (cid:97) +∆3 (cid:97) = (cid:97). The full table deﬁning the summation operator +∆3 on abstract diﬀerence
is given in Fig. 3.

The above qualitative reasoning method, however, is quite weak when relying only on the
steady state equations in (1). The main reason is that all reasoning steps are local, so that they
overlook global properties of the network that are arising for example with metabolic cycles. To
see this, suppose that we want to predict which environmental change may lead to an increase
of Y . We can use the second equation in (1) to infer some constraints on the values of V and V-:
if Y = (cid:97), we can for example infer that V cannot be (cid:96) if V- is (cid:97). In fact, (cid:97) + (cid:97) can never be
equal to (cid:96). However, V = (cid:97), V- = (cid:96) is a partial solution that seems compatible with an increase
of Y . This illustrates that we cannot infer any constraint on X with this kind of local reasoning.
Equation X = Y in Eq. (2), in contrast, expresses a global property of the network that
immediately implies that the only value for X compatible with an increase of Y is (cid:97). In other

3

words, when reasoning with equations over abstract diﬀerences, Eq. (2) is no longer an implicit
consequence of the system (1). Therefore, to be taken into account, such equations must be ex-
plicitly included in the system before applying the abstract reasoning. Unfortunately, the number
of entailed linear equations is inﬁnite in general. For instance, in our small network all the equa-
tions of the family nV + mX = nV- + (m + 1)Y for any two naturals n, m are consequences of
(1). So, instead of trying to infer the set of all the consequences of our system, we may try to
compute a “good” subset of it, by including only the consequences that more heavily constrain
the variables. The prediction quality of the existing approaches heaviliy depends on the heuristics
chosen for adding entailed linear consequences.

One evident advantage of Eq. (2) is its small number of variables (there are only two: X
and Y ). If we consider an individual linear equation, the intuition is that removing a variable
increases the constraining power on the remaining variables. So, we propose as a heuristics the
inclusion of all linear consequences involving a minimal subset of variables. This idea is at the core
of the ﬁrst result that we present in this paper: a heuristic algorithm that enriches the steady
state equations of the metabolic network with minimal support consequences before applying
abstract interpretation. While this algorithm has been internally used for some time to increase
the precision of the abstract interpretation, some key questions have been always open about it:

1. is the set of minimal support equations complete? that is, does it represent all the deducible

constraints on the abstract system?

2. are these constraints suﬃcient to compute the exact set of abstract solutions?
3. if this is not the case, is there a method to compute them?

The deﬁnitive answers to these questions is the second main contribution of this paper. We show
in particular that the above heuristic does not cover all the entailed constraints on the abstract
system, i.e. it does not allow to compute the exact abstraction of a linear system in general.
Intuitively, this happens because the approach takes for granted that the abstract reasoning is
based on the linear system computed at the steady state, that is on the matrix equation AX = 0
where A is the stoichiometry matrix associated to the metabolic network, and X is the set of
metabolic ﬂows representing the unknowns of the linear system. However, it is easy to notice that
as soon as concrete diﬀerences are introduced in the reasoning, there is not only one, but actually
two linear systems to consider: one before the environmental change, and one after it, that is one
system for each value of the pairs representing concrete changes. Informally, we should therefore
consider a bigger matrix equation including somehow both AXbefore = 0 and AXafter = 0.

This idea is the starting point of development of the main contribution of the present paper:
a method for the exact computation of the abstraction of a linear system, that we call the
exact algorithm. This method not only provides us with the counterexamples to the exactness
of the heuristic based on minimal support consequences, but gives us also an exact measure of
its goodness as well as of the goodness of all the other heuristics used to improve our abstract
analysis. Remarkably, both the heuristic and the exact algorithm have their root in the rewriting
of a linear system in terms of its EFMs. The key diﬀerence between the two methods lies in the
choice of the linear system (i.e. the matrix equation) initially used to compute the EFMs.

3 Preliminaries

Set Notation.We start with usual notation for sets. Let N be the set of natural numbers and R+
the set of positive real numbers, both including 0. For any set A and n ∈ N, the set of n-tuples
of elements in A is denoted by An. The i-th projection function on n-tuples of elements in A,
where 1 ≤ i ≤ n is the function πi : An → A such that πi(a1, . . . , an) = ai for all a1, . . . , an ∈ A.
If A is ﬁnite the number of elements of A is denote by |A|.

4

Σ-Algebras and Σ-Structures. We next recall the notions of Σ-algebras, Σ-structures, and ho-
momorphism between Σ-structures. Let Σ = ∪n≥0F (n) (cid:93) C be a ranked signature. The elements
of f ∈ F (n) are called the n-ary function symbols of Σ and the elements in c ∈ C its constants.

Deﬁnition 1. A Σ-algebra S = (dom(S), .S) consists of a set dom(S) and an interpretation .S
such that cS ∈ dom(S) for all c ∈ C, and f S : dom(S)n → dom(S) for all f ∈ F (n) and n ∈ N.

We next reinterpret n-ary function symbols of Σ as n+1-ary relation symbols, so that we can

reuse the same signature Σ for deﬁning Σ-structures.

Deﬁnition 2. A Σ-structure ∆ = (dom(∆), .∆) consists of a set dom(∆) and an interpretation
.∆ such that c∆ ∈ dom(∆) for all c ∈ C and f ∆ ⊆ dom(∆)n+1 for all f ∈ F (n) and n ∈ N.

In this manner, any Σ-algebra is also a Σ-structure since any n-ary function is an n + 1-ary
relation. Note also that symbols in F (0) are interpreted as monadic relations in Σ-structures,
i.e., as subsets of the domain, in contrast to constants in C that are interpreted as elements of
the domain.

Deﬁnition 3. A homomorphism between two Σ-structures S and ∆ is a function h : dom(S) →
dom(∆) such that for c ∈ C, n ∈ N, f ∈ F (n), and s1, . . . , sn+1 ∈ dom(S):

1. h(cS) = c∆, and
2. if (s1, . . . , sn+1) ∈ f S then (h(s1), . . . , h(sn+1)) ∈ f ∆.

If we consider n + 1-ary relations as n-ary set valued functions, the second condition can be
rewritten equivalently as h(f S(s1, . . . , sn)) ⊆ f ∆(h(s1), . . . , h(sn)). For Σ-algebras, this condi-
tion is equivalent to h(f S(s1, . . . , sn)) = f ∆(h(s1), . . . , h(sn)).

4 Σ-Abstractions

Throughout the paper we will use the signature Σ = F (2) (cid:93) C with two binary function symbols
in F (2) = {+, ∗} and two constants C = {0, 1}. We will only consider Σ-algebras S in which +S
and ∗S are associative and commutative, with neutral element 0S and 1S respectively.

Example 4. The set of positive real numbers R+ can be turned into a Σ-algebra with domain
R+, by interpreting + as the addition of positive real numbers +R+, ∗ as the multiplication of
positive real numbers ∗R+, and interpreting the constants by themselves 0R+ = 0 and 1R+ = 1.
We will deliberatly confuse the set R+ with the Σ-algebra (R+, .R+).

Example 5. The set of Booleans B = {0, 1} ⊆ R+ can be turned into a Σ-algebra with domain B
by interpreting +B = ∨B as disjunction, ∗B = ∧B as conjunction, and the constants by themselves
0B = 0 and 1B = 1. We will deliberatly confuse the set B with the Σ-algebra (B, .B).

We can abstract positive real numbers into booleans by deﬁning a function hB : R+ → B such

that hB(0) = 0 and hB(r) = 1 for all r ∈ R+ \ {0}.

Lemma 6. The function hB : R+ → B is a homomorphism between Σ-algebras.

The homomorphism hB is the prime example of what we will call a Σ-abstraction.

Deﬁnition 7. A Σ-abstraction is a homomorphism between Σ-structures S and ∆ such that
dom(∆) ⊆ dom(S).

5

5 Abstracting Concrete Diﬀerences

Concrete diﬀerences are pairs of positive real numbers such as (rbefore, rafter) ∈ R2
+ in the example
Section 2. We show how to abstract concrete diﬀerences into abstract diﬀerences in some ﬁnite
Σ-structure.
The Tuple Σ-Algebra Sn. For any Σ-algebra S and natural number n ∈ N we deﬁne the Σ-
algebra of n-tuples Sn = (dom(S)n, .Sn
n ∈ dom(S) and
(cid:12) ∈ F (2):

) such that for all s1, . . . , sn, s(cid:48)

1, . . . , s(cid:48)

(s1, . . . , sn) (cid:12)Sn

(s(cid:48)

1, . . . , s(cid:48)

n) = (s1 (cid:12)S s(cid:48)

1, . . . , sn (cid:12)S s(cid:48)

n)

The constants c ∈ C are interpreted as cSn
of +S, then 0Sn
∗S then 1Sn
of +Sn

is also the neutral element of ∗Sn

and ∗Sn

is the also the neutral element of +Sn

inherit from +S and ∗S respectively.

= (cS, . . . , cS). Note that if 0S is the neutral element
. In analogy, if 1S is the neutral element of
. Furthermore, the associativity and commutativity

Note that we deliberatly confuse the set R2

Given this, it follows from the above, that the algebra R2
and the neutral element (1, 1) for ∗R2

+) with our notation.
+ has the neutral element (0, 0) for +R2
+, and that these operations are associative and commutative.
For any function h : A → B and n ∈ N we deﬁne the function hn : An → Bn such that

+ with the Σ-algebra (R2

+

+, .R2

hn(a1, . . . , an) = (h(a1), . . . , h(an)) for all a1, . . . , an ∈ A.
Lemma 8. If h is Σ-abstraction from S to ∆ then hn is a Σ-abstraction from Sn to ∆n.
Abstractions of Concrete Diﬀerences. A generic manner to abstract concrete diﬀerences in R2
+ is
to start with a ﬁnite set ∆ ⊆ R2
+ → ∆
that says how to abstract any concrete diﬀerences to some abstract diﬀerence. The function h
deﬁnes a partition of R2
+ into the equivalences classes of concrete diﬀerences that are mapped to
the same abstract diﬀerence.

+ of so called abstract diﬀerences, and some function h : R2

Given such a function h, there is a unique manner to deﬁne an interpretation .∆ such that
(∆, .∆) becomes Σ-structure and h a Σ-abstraction. For any constant c ∈ C we have to deﬁne
c∆ = h(cR2
+) and for any function symbol (cid:12) ∈ F (2) we have to deﬁne a ternary relation (cid:12)∆,
which seen as set-valued function (cid:12)∆ : ∆×∆ → 2∆ must satisfy for all abstract values δ1, δ2 ∈ ∆:

δ1 (cid:12)∆ δ2 = {h(r1 (cid:12)R+ r2, r(cid:48)

1 (cid:12)R+ r(cid:48)

2) | h(r1, r(cid:48)

1) = δ1, h(r2, r(cid:48)

2) = δ2}

Lemma 9. h : R2

+ → ∆ is a Σ-abstraction.

The Σ-Structure ∆3. Our next objective is to recall the abstraction of concrete diﬀerences into the
ﬁnite Σ-structure with domain ∆3 = {(cid:97), (cid:96), ∼∼∼} that is well-known from qualitative reasonning
(see e.g. [10]). For this we start with the function h∆3(r, r(cid:48)) ∈ ∆3 such that for any all r, r(cid:48) ∈ R+:

h∆3 (r, r(cid:48)) =






(cid:96) = (1, 0) if r > r(cid:48)
(cid:97) = (0, 1) if r < r(cid:48)
∼∼∼ = (0, 0) if r = r(cid:48)

+ → ∆3 is a Σ-abstraction by Lemma 9.

The relations +∆3 and ∗∆3 are is the symmetric closure of the relation in Fig. 3. Furthermore,
h∆3 : R2
The Σ-Structure ∆6. We next recall the abstraction of concrete diﬀerences to the ﬁnite Σ-
structure with domain ∆6 = {↑, ↓, ∼, ⇑, ⇓, ≈} that was introduced for gene knockout prediction
in [15]. For deﬁning this Σ-structure, we start with the function h∆6 : R2
+ → ∆6 such that for
any two numbers r, r(cid:48) ∈ R+:






h∆6(r, r(cid:48)) =

↑ = (1, 2)
↓ = (2, 1)
∼ = (1, 1)



if 0 (cid:54)= r < r(cid:48)
if r > r(cid:48) (cid:54)= 0
if r = r(cid:48) (cid:54)= 0

h∆6(r, r(cid:48)) =

⇑ = (0, 2)
⇓ = (2, 0)
≈ = (0, 0)



if 0 = r < r(cid:48)
if r > r(cid:48) = 0
if r = r(cid:48) = 0

6

δ ∗∆3 δ(cid:48)
{(cid:97)}

δ +∆3 δ(cid:48)
{(cid:97)}

δ(cid:48)
δ
(cid:97) (cid:97)
(cid:97) (cid:96) {(cid:97), ∼∼∼, (cid:96)} {(cid:97), ∼∼∼, (cid:96)}
{(cid:97), ∼∼∼}
(cid:97)

δ(cid:48) δ +∆3 δ(cid:48) δ ∗∆3 δ(cid:48)
δ
{∼∼∼}
∼∼∼ ∼∼∼ {∼∼∼}
{(cid:96)}
(cid:96) (cid:96) {(cid:96)}
{(cid:96), ∼∼∼}
∼∼∼ {(cid:96)}
(cid:96)
Fig. 3. Interpretation of Σ-structure ∆3.

{(cid:97)}

∼∼∼

c c∆3
0 ∼∼∼
1 ∼∼∼

δ(cid:48) δ +∆6 δ(cid:48) δ ∗∆6 δ(cid:48)

δ(cid:48) δ +∆6 δ(cid:48) δ ∗∆6 δ(cid:48)

{↑}

δ(cid:48) δ +∆6 δ(cid:48)

δ ∗∆6 δ(cid:48)
{↑}

δ
↑ ↑
↑ ↓ {↑, ∼, ↓} {↑, ∼, ↓}
↑ ∼ {↑}
↑ ⇑
{↑}
↑ ⇓ {↑, ↓, ∼}
↑ ≈ {↑}
⇑ ↓ {↑, ∼, ↓}

{↑}
{⇑}
{⇓}
{≈}
{⇑}

δ
⇑ ∼ {↑}
⇑ ⇑
{⇑}
⇑ ⇓ {↑, ∼, ↓}
⇑ ≈ {⇑}
∼ ∼ {∼}
∼ ≈ {∼}
{↓}
∼ ↓

{⇑}
{⇑}
{≈}
{≈}
{∼}
{≈}
{↓}

δ
{↓}
∼ ⇓
≈ ≈ {≈}
{↓}
≈ ↓
{⇓}
≈ ⇓
{↓}
↓ ↓
{↓}
↓ ⇓
{⇓}
⇓ ⇓

{⇓}
{≈}
{⇓}
{⇓}
{↓}
{⇓}
{⇓}

c c∆6
0 ≈
1 ∼

Fig. 4. Interpretation of Σ-structure ∆6.
The relations +∆6 and ∗∆6 are the symmetric closure of the relations in Fig. 4. By Lemma 9,
h∆6 : R2

+ → ∆6 is a Σ-abstraction.

6 First-Order Logic

We ﬁrst recall the standard ﬁrst-order logic and then show how to enhance it with n-tuples
without increasing the expressiveness.

We ﬁx a set of variables V (for instance V = N). The variables in V will be ranged over by x
and y. The set of ﬁrst-order expressions e ∈ EΣ and ﬁrst-order formulas φ ∈ FΣ are constructed
according to the abstract syntax in Fig. 5 from the symbols in the signature Σ, the variables in
.=. As shortcuts, we deﬁne the formula
V, the ﬁrst-order connectives, and the equality symbol
true =def 1 .=1 and for any sequence of formulas φ1, . . . , φn we deﬁne ∧n
i=1φi as φ1 ∧ . . . ∧ φn
which is equal to true if n = 0. We deﬁne formulas e

.
(cid:54)=0 by ¬e .=0.

The semantics of a formula φ ∈ FΣ is a truth value, which depends on the Σ-structures S
of interpretation and on a variable assignment α : V → dom(S). Any Σ-expressions e ∈ EΣ
denotes a subset of values in dom(S), which will be singleton in case that S was a Σ-algebra.
The semantic of equations e .=e(cid:48) is, as expected when interpreted over Σ-algebras S: the unique
values of e and e(cid:48) in S must be equal. However, we will also need to interpret equations e .=e(cid:48) over
Σ-structures. This is why, any expression e denotes a subset of the Σ-structure, not just a single
element. We can then interpret equality as nondisjointness, i.e., e .=e(cid:48) holds in a Σ-structure S if
e and e(cid:48) are interpreted as nondisjoint subsets of dom(S).

A variable assignment into a Σ-structure S is a partial function α : V → dom(S) for some
subset V ⊆ V. Let S be a Σ-structure and α a variable assignment to S. Any Σ-expression e
with V(e) ⊆ V can be interpreted as an element of dom(S) and any Σ-formula φ ∈ FΣ with
V(φ) ⊆ V as a Boolean value. The set of solutions of a formula φ ∈ FΣ over a Σ-structure S
with respect to some set of variables V ⊇ V(φ) is deﬁned by:

φ
(cid:74)
If V = V(φ) then we omit the index V , i.e., solS(φ) = solS

V (φ)={α : V → dom(S) |

solS

S,α = 1}

(cid:75)
V (φ).

We next extend the ﬁrst-order logic to n-tuples where the parameter n is ﬁxed. In applications,
we will use the case n = 2, that is the ﬁrst-order logic with pairs. Back and forth compilers from
ﬁrst-order logic with and without tuples will be convenient later on.

The syntax of ﬁrst-order logic with n-tuples is given in Fig. 6. The expressions o ∈ On
Σ are
like the expression e ∈ EΣ except that variables x are now replaced by projection expressions

7

First-order expressions and formulas:

e ∈ EΣ ::= x | c | e (cid:12) e(cid:48)
φ ∈ FΣ ::= e .=e | ∃x.φ | φ ∧ φ | ¬φ where x ∈ V

where (cid:12) ∈ F (2), c ∈ C

Interpretation of expressions as sets of elements
structures and α : V → dom(S) where V contains all free variables.

S,α ⊆ dom(S), where S is a Σ-
e
(cid:75)
(cid:74)

S,α = cS
c
(cid:75)
(cid:74)

S,α = {α(x)}
x
(cid:75)
(cid:74)
Interpretation of formulas as truth values

e (cid:12) e(cid:48)
(cid:74)

S,α = ∪{s (cid:12)S s(cid:48) | s ∈
(cid:75)
φ
(cid:74)

S,α ∈ B:
(cid:75)

S,α, s(cid:48) ∈
e
(cid:75)
(cid:74)

e(cid:48)
(cid:74)

S,α}
(cid:75)

(cid:26) 1 if

e
(cid:74)
0 else

S,α ∩
(cid:75)

e(cid:48)
(cid:74)

S,α (cid:54)= ∅
(cid:75)

e .=e(cid:48)
(cid:74)

¬φ
(cid:74)

S,α =
(cid:75)
S,α = ¬B(
φ
(cid:74)
(cid:75)

S,α)
(cid:75)

φ ∧ φ(cid:48)
(cid:74)

S,α =
(cid:75)
S,α =
∃x.φ
(cid:75)
(cid:74)

S,α ∧B
(cid:75)

φ(cid:48)
φ
(cid:74)
(cid:74)
(cid:26) 1 if exists s ∈ dom(S).

S,α
(cid:75)

0 else

φ
(cid:74)

S,α[x/s] = 1
(cid:75)

Fig. 5. Syntax and semantics of expressions and formulas of ﬁrst-order logic.

o ∈ On
ψ ∈ F n

.
πi(x) | c | o (cid:12) o

Σ ::=
Σ ::= o .=o(cid:48) | ∃x.ψ | ψ ∧ ψ | ¬ψ where x ∈ V

where (cid:12) ∈ F (2), c ∈ C, 1 ≤ i ≤ n

Fig. 6. Σ-expressions and Σ-formulas of the ﬁrst-order logic with n-tuples.

.
πi(x) where 1 ≤ i ≤ n. The reason is that any variable does now denote an n-tuple of values,
rather than a single value (while the interpretation of constants and function symbols remain
unchanged). The only change in the semantics is that variables assignment β do now map to
.
S,β = {πi(β(x))}. The set of solutions of a
πi(x)
n-tuples of values of the domain, and that
(cid:75)
formula ψ ∈ F n

Σ over a Σ-structure S is deﬁned as follows:

(cid:74)

n-solS(ψ)={β : V(ψ) → dom(S)n |

S,β = 1}

ψ

(cid:74)

(cid:75)

We next show how to express any ﬁrst-order formulas in FΣ, interpreted over a tuple algebra
Sn, by some formulas in F n
Σ, interpreted over S. In a ﬁrst step, we convert ﬁrst-order expression
in e ∈ EΣ – that we will interpret over the Σ-algebra Sn – to n projected expressions Πi(e) ∈ On
Σ
where 1 ≤ i ≤ n. For all operators (cid:12) ∈ F (2) and constants c ∈ C we deﬁne:

Πi(e (cid:12) e(cid:48)) =def Πi(e) (cid:12) Πi(e(cid:48))

Πi(x) =def

.
πi(x)

Πi(c) =def c

In the second step, we convert any formula φ ∈ FΣ without tuples – that will be interpreted

in the tuple algebra Sn – to some formula (cid:104)φ(cid:105)n ∈ F n

Σ with tuples.

(cid:104)e .=e(cid:48)(cid:105)n =def ∧n
(cid:104)¬φ(cid:105)n =def ¬(cid:104)φ(cid:105)n

i=1Πi(e) .=Πi(e(cid:48))

(cid:104)φ ∧ φ(cid:48)(cid:105)n =def (cid:104)φ(cid:105)n ∧ (cid:104)φ(cid:48)(cid:105)n
(cid:104)∃x.φ(cid:105)n =def ∃x.(cid:104)φ(cid:105)n

Proposition 10. For any φ ∈ FΣ, Σ-structure S, and n ≥ 1: solSn
Example 11. Let 3 =def 1 + 1 + 1 and 4 =def 1 + 1 + 1 + 1. The formula φ ∈ FΣ equal to:

(φ) = n-solS((cid:104)φ(cid:105)n).

3 ∗ x + 4 ∗ y .=0

then has the same solutions over R2

+ than the formula (cid:104)φ(cid:105)2 ∈ F 2

Σ over R+ below:
π2(y) .=0

.

.
π2(x) + 4 ∗

3 ∗

.
π1(x) + 4 ∗

.

π1(y) .=0 ∧ 3 ∗

8

We next show how to rewrite any ﬁrst-order formulas with tuples ψ ∈ F n

Σ into some ﬁrst-order
formula ˜ν(ψ) ∈ FΣ without tuples. The idea is to replace all projections πi(x) by new variables
νi(x). For this, we ﬁrst ﬁx n generators of fresh variables ν1, . . ., νn : V → V. Second, we map
any expression o ∈ On

Σ with projections to some expressions ˜ν(o) ∈ EΣ without new variables:

.
πi(x)) =def νi(x),

˜ν(

˜ν(c) =def c,

˜ν(o1 (cid:12) o2) =def ˜ν(o1) (cid:12) ˜ν(o2).

Third, we map any formula ψ ∈ F n
variables:

Σ with projections to some formula ˜ν(ψ) ∈ FΣ with fresh

˜ν(o = o(cid:48)) =def ˜ν(o) = ˜ν(o(cid:48))
˜ν(ψ ∧ ψ(cid:48)) =def ˜ν(ψ) ∧ ˜ν(ψ(cid:48))

˜ν(¬ψ) =def ¬˜ν(ψ)
˜ν(∃x.ψ) =def ∃ν1(x) . . . ∃νn(x). ˜ν(ψ)

Given an variable assignment β : V → dom(S)n with V ⊆ V, we deﬁne ν(β) : (cid:93)n

i=1νi(V ) →

dom(S) such that for all x ∈ V :

ν(β)(νi(x)) = πi(β(x)))

Function ν is a bijection with range {α | α : (cid:93)n
satisﬁes ν-1(α)(x) = (α(ν1(x)), . . . , α(νn(x)) for all α in the range and all x ∈ V .

i=1νi(V ) → dom(S)}. The inverse of this function

Proposition 12. For any ψ ∈ F n

Σ, Σ-structure S, and n ≥ 1: n-solS(ψ) = ν-1(solS(˜ν(ψ))).

We ﬁnish this section with a commutation property of the operator ν-1 with Σ-abstractions.

Proposition 13. For any subset R of variable assignments of type V → dom(S) where V ⊆ V,
n ≥ 1, and Σ-abstraction h : S → ∆: ν-1(h ◦ R) = hn ◦ ν-1(R).

7 Diﬀerence Abstraction

We next show how to recast the notions of diﬀerence abstractions from [15,4,12] by applying our
notion of Σ-abstractions to the Σ-algebra R2
+.

Let S be a Σ-algebra and V ⊆ V a subset of variables. For any two variable assignments
α, α(cid:48) : V → dom(S), we deﬁne an assignment of variables to pairs of elements in the domain of
the structure diﬀ(α, α(cid:48)) : V → dom(S)2 – that we call the diﬀerences of α and α(cid:48) – such that
for all variables x ∈ V , diﬀ(α, α(cid:48))(x) = (α(x), α(cid:48)(x)). For any subset R of variable assignments
of type V → dom(S) we deﬁne the set of diﬀerences of assignments in R by:

diﬀ(R) = {diﬀ(α, α(cid:48)) | α, α(cid:48) ∈ R}

Furthermore, for any Σ-abstraction h : S2 → ∆ and subset R(cid:48) of diﬀerence abstractions of type
V → dom(S)2 we deﬁne the application of the abstraction h to R(cid:48) by h ◦ R(cid:48) =def {h ◦ β | β ∈ R(cid:48)}

Deﬁnition 14. For any Σ-abstraction h : S2 → ∆ and formula φ ∈ FΣ we deﬁne the diﬀerence
abstraction of the S-solution set of φ by: solS(φ)∆ = h ◦ diﬀ(solS(φ))).

The original deﬁnition of sol(φ)∆6 in [15] did not make explicit the roles of diﬀ and h∆6 :
+ → ∆6 . Having done so, we can now see that the diﬀerence abstraction of the R+-solution

R2
sets of a formula is the R2

+-solution set of the same formula.

Lemma 15. For any formula φ ∈ FΣ and Σ-structure S: diﬀ(solS(φ)) = solS2

(φ).

9

As an immediate consequence, we have for any Σ-abstraction h : S2 → ∆ that sol(φ)∆ =
h∆ ◦ solS2
(φ). Our next objective is to show that we can overapproximate the set sol(φ)∆ by
sol∆(φ) (Corollary 19). In order to show this, let h(cid:48):S(cid:48) → ∆ be a Σ-abstraction and α be a
variable assignment into dom(S(cid:48)):

Lemma 16. For any expression e ∈ EΣ with V (e) ⊆ dom(α): h(cid:48)(
(cid:74)

e

S(cid:48),α) ⊆
(cid:75)

Proposition 17. For any positive formula φ ∈ FΣ with V (φ) ⊆ dom(α):
Theorem 18. For any positive formula φ ∈ FΣ: h(cid:48) ◦ solS(cid:48)

(φ) ⊆ sol∆(φ).

∆,h(cid:48)◦α.

e
(cid:75)
S(cid:48),α ≤

(cid:74)
φ
(cid:74)

(cid:75)

∆,h(cid:48)◦α.

φ

(cid:74)

(cid:75)

Corollary 19. For any Σ-abstraction h : S2 → ∆ and positive ﬁrst-order formula φ ∈ FΣ:

solS(φ)∆ = h ◦ diﬀ(solS(φ)) ⊆ sol∆(φ)

This is an obvious consequence from Theorem 18 and Proposition 15. If ∆ is ﬁnite then the
set sol∆(φ) is ﬁnite. If furthermore φ is a conjunctive formula, we can therefore compute the set
sol∆(φ) by a ﬁnite domain constraint solver (such as e.g. Minizinc [18]). In contrast, it remains
unclear how to compute the ﬁnite set h ◦ diﬀ(solS(φ)) for inﬁnite structures S. The problem is
open, even if φ is a system of homogenous linear equations and S = R+, so that the inﬁnite set
solS(φ) has a ﬁnite solved form by a triangular matrix. This is the core of the objective that we
tackle in the remainder of the present paper.

8 Objective

We formalize the full algorithmic problem that we will solve in this paper and illustrate its
relevance to our benchmark application to systems biology.

Once having ﬁxed the parameter ∆ ∈ {∆3, ∆6} the algorithmic problem has three inputs :

Linear system over R+: a ﬁrst-order formula φ ∈ FΣ that represents a linear equation system.

(This formula typically captures the steady state equations of the model.)

Constraint over ∆: a ﬁrst-order formula φ(cid:48) ∈ FΣ∪∆ where the signature Σ is extended with
additional constants of ∆ that will be interpreted by themselves. (This formula typically
expresses the partial kinetic knowledge on the reactions in the model and the change target
of the prediction task (e.g. overproduction of some metabolites).)

Set of observable variables: a ﬁnite subset of variables V ⊆ V(φ) ∪ V(φ(cid:48)). (This set typically
contains the control variables such as inﬂows and gene knockouts as well as the target vari-
ables, but not the variables for the rate of the internal metabolic reactions. Since the number
of solutions may be of cardinality |∆||V |, it is essential to choose V as small as possible.)

The algorithmic output that has to be produced is the ∆-abstraction of diﬀerences of R+-solutions
of φ, but constrained to the solutions of φ(cid:48) over the structure ∆, and projected to the variables of
V . In other words, the algorithm will compute the following ﬁnite set where V (cid:48) = V(φ) ∪ V(φ(cid:48)):

{β|V | β ∈ sol

R+
V (cid:48) (φ)∆ ∩ sol∆

V (cid:48)(φ(cid:48))}

The only restriction on the inputs that we will impose is that the ﬁrst formula φ must represent
a homogeneous system of linear equations in FΣ. For instance, the linear equation x − 2y = 0 is
captured by the equation x .=y + y in FΣ where we cannot use the minus operator. See Section
9 for the general deﬁnition. The constraint φ(cid:48) ∈ FΣ∪∆ in contrast may be arbitrary, including
nonlinear equations and universal quantiﬁers but must be interpreted abstractly over ∆, while

10

Observable variables

Linear equations in FΣ

V = { xThr,
xAkb,
yLeu,
. . .}

φ =

xT hr

.=r27 + r30

.=r27
.=r35 + yLeu

(T hr)
(Akb)
(Leu)

∧ r41
∧ r45
∧ . . .

∆6 constraints in FΣ∪∆6

φ(cid:48) =

yLeu
∧ r27

.=↑
.=Pyr ∗ Akb ∗ IlvD
∗ IlvBH ∗ IlvC

(target)

(27)

∧ . . .

Fig. 7. Inputs of our algorithm on the benchmark example from of leucine overproduction.
the linear equation system is valid over R+. Note however, that any universal quantiﬁers in φ(cid:48)
can be expressed by a simple conjunction, given that the interpretation domain ∆ is ﬁnite.

In Fig. 7 we illustrate how the inputs will be instantiated for our benchmark application of
leucine overproduction (a glimpse of the reaction network was given in Fig. 2). In this case, we
choose the parameter ∆ = ∆6. The observable variables in V stand for the rates of the inﬂows
Threonine (xThr), Akb(xAkb), etc, the rate of the target outﬂow Leucine (yLeu), and the possible
gene knockouts. The system of linear equations φ contains the steady state equations for the
metabolic reactions in the network. These require that all metabolites must be produced and
consumed at the same rate. For instance, Pyruvate is produced by the inﬂow of Threonine at
rate xThr and consumed by reactions 27 and 30 at rates r27 and r30 respectively. The yields the
linear equation (Thr) of Fig. 7. Species Akb is produced by reaction 41 and consumed by 27,
leading to the steady state equation (Akb). Leucine is produced by reaction 45 and consumed by
its outﬂow, leading to equation (Leu). The constraint φ ∈ FΣ∪∆6
contains the overproduction
target yLeu = ↑ in (target) and the kinetic constraints for all reactions, of which we show only
constraint (27) for reaction 27. The kinetic constraints must be interpreted abstractly over ∆6
according the formal semantics of the modeling language [15] rather than concretely over R+.
Therefore, the meaning of the constraints is purely qualitative and not at all quantitative. For
instance, the constraint (27) states (beside others) that rate of reaction 27 increases if either of
the concentrations of the reactants Pyr and Akb or of the enzymes IlvD, IlvBH or IlvC increase.
Nothing is said about quantities of these increases.

9 Exact Algorithms

We now present an exact solution of the problem presented in the previous section. Our approach
is to characterize the abstraction of the solution set of a linear equation system as the solution
set of some ﬁrst-order formula over the abstract domain. We consider the abstractions hB, h∆3 ,
and h∆6 in this order.
Characterizing B-Abstractions. We now present a result from [1] that shows that the boolean
abstraction of the R+-solution set of a mixed linear system can be computed exactly. The de-
velopment of this result was motivated by the needs of the present paper, but given that it is of
independent interest and nontrivial to prove, we decided to present it independently.

Any natural numbers n can be described by the expression n =def

to deﬁne linear equations as equations in FΣ that have the form:

(cid:80)n

i=1 1 in EΣ. This permits

n1 ∗ x1 + . . . nm ∗ xm

.=nm+1 ∗ xm+1 + . . . + np ∗ xp

(3)

where m, p, n1, . . . , np ∈ N and x1, . . . , xp ∈ V.
Mixed Linear Systems. A product-zero-equation in FΣ is an equation of the form x ∗ y .=0 where
x, y ∈ V. A mixed linear system is a conjunctive formula in FΣ of the form ∃z. L ∧ E where L
is a conjunction of linear equations and E a conjunction of product-zero-equations.
Elementary Flux Modes. The support of a variable assignment α : V → R with V ⊆ V is
supp(α) = {x ∈ dom(α) | α(x) (cid:54)= 0}. Given a linear system φ, the EFMs of φ are the minimal

11

support solutions of φ over R+. The R-EFMs of φ are the minimal support solutions of φ over R.
Note that the interpretation of R is natural for the steady-state equations of metabolic networks
with reversible reactions, while the reactions of our networks are always irreversible.

Theorem 20 [1]. Let φ be a mixed linear system. We can compute in at most exponential time
some conjunctive formula φ(cid:48) with existential quantiﬁers such that hB ◦ solR+(φ) = solB(φ(cid:48)).

Proof sketch. There are quite some insights behind this theorem that we can only sketch here.
First, any linear equation L system can be rewritten in the form Ay .=0 where A is an integer
matrix and y a sequence of pairwise distinct variables such that V (y) = V (L). Let P be a positive
integer matrix whose columns contain all the EFMs of A. These can be computed in at most
exponential time [19]. Then solR+(Ay .=0) is equal to solR+(∃x. P x .=y) given that any solution
of Ay .=0 over R+ can be obtained from some linear combination of the EFMs of A. Second, a
formula φ ∈ FΣ is called hB-exact if solB(φ) = hB ◦ solR+(φ). Unfortunately, not every linear
systems is hB-exact. However, the formula φ(cid:48)(cid:48) equal to ∃x.P x .=y can be shown to be hB-exact,
roughly since matrix P contains only positive integers. Third, it was noticed that any conjunction
of product-zero equations is hB-exact as well. Fourth, for any system of product-zero equations E
and any sequence of variables z, the formula φ(cid:48) equal to ∃z.φ(cid:48)(cid:48) ∧ E can be shown to be hB-exact.
Finally, any mixed linear systems φ can be brought into the form of φ(cid:48) by computing the EFMs
of the matrix A of the linear subsystem of φ in exponential time.

Exact Algorithm.. In order to compute the hB-abstraction of a mixed linear system φ, we ﬁrst
compute φ(cid:48) along the lines of the sketch of the proof ideas of Theorem 20. Second, given that φ(cid:48)
is a conjunctive formula, we compute solB(φ(cid:48)) by ﬁnite domain constraint programming.

Characterizing ∆3-Abstractions. We present a characterization of ∆3-abstractions of linear
equation systems and show that it provides an exact algorithm solving the objective in the case
of ∆3. We ﬁrst decompose h∆3 into hB and the binary relation, that is deﬁned by the following
ﬁrst-order formula in the logic with pairs F 2
Σ:

projG (x, y) =def

.
π1(x) +

.
π2(y) =

.
π2(x) +

.
π1(y) ∧

.
π1(y) ∗

.
π2(y) = 0

We are mainly interested in interpreting this formula over R2
+.

Lemma 21. The relation projG

R2
+ is a function satisfying h∆3 = h2

B ◦ projG

R2

+.

We next deﬁne applications of projG in FO-logic. For any sequence of variables y and FO-
Σ with V(φ(y)) ⊆ {y} we deﬁne a formula projG (φ(y)) ∈ F 2
formula φ(y) ∈ F 2
Σ describing the
application of projG to the solutions of φ(y) by ∃z. φ(z) ∧ projG (z, y) where φ(z) is obtained
from φ(y) by replacing the variables in y by arbitrarily but ﬁxed fresh variables z.

Lemma 22. projG

R2
+ ◦ 2-solR+(φ(y)) = 2-solR+(projG (φ(y)))

Theorem 23. For any linear formula L ∈ FΣ we can compute in at most exponential time a
positive conjunctive formula with existential quantiﬁers φ ∈ FΣ such that:

h∆3 ◦ diﬀ(solR+(L)) = ν-1(solB(φ))

Proof Let L(y) be a linear system with V(L(y)) = V(y) where y is a sequence of distinct
variables. The time for computing φ is dominated by the time for computing the elementary

12

modes, which can be done in at most exponential time.

h∆3 ◦ diﬀ(solR+(L(y)))

Proposition 15 = h∆3 ◦ solR2

+(L(y))

Pair FO Proposition 10 = h∆3 ◦ 2-solR+(L2(y)) with L2(y) = (cid:104)L(y)(cid:105)2

Decomposition Lemma 21 = h2
B ◦ projG
B ◦ 2-solR+(projG (L2(y)))
FO-Deﬁnition Lemma 22 = h2
B ◦ ν-1(solR+(˜ν(projG (L2(y)))))
Proposition 12 = h2
Proposition 13 = ν-1(hB ◦ solR+(˜ν(projG (L2(y)))))
Deﬁnition of projG (L2(y)) = ν-1(hB ◦ solR+(˜ν(∃z. L2(z) ∧ projG (z, y))))

R2
+ ◦ 2-solR+(L2(y)))

Mixed linear systems Theorem 20 = ν-1(solB(φ)

where φ is an equivalent conjunctive formula for the
mixed linear sytem ˜ν(∃z. L2(z) ∧ projG (z, y))

Note that solB(φ) can be computed by ﬁnite domain constraint programming. This yields
an exact algorithm for computing the ∆3-abstraction of a system of linear equations, which is a
special case of our general objective without kinetic constraints.

For adding a treatment of kinetic constraints, we consider the union B ∪ ∆3 as a relational
structure providing the values and functions of both structures B and ∆3. The signature of this
mixed structure consists of the function symbols in {+B, ∗B, +∆3 , ∗∆3} and the constants in the
set B ∪ ∆3, all of which are interpreted by themselves in the mixed structure B ∪ ∆3. The set of
ﬁrst-order formulas over the mixed signature is denoted by FB∪∆3
. For any α : V → dom(S), we
can deﬁne its restriction α|V (cid:48) : V (cid:48) → dom(S) such that for all y ∈ V (cid:48) ⊆ V , α|V (cid:48)(y) = α(y).

Proposition 24. For any formulas φ ∈ FΣ and φ(cid:48) ∈ FΣ∪∆3
V(φ) ∪ V(φ(cid:48)) we can compute in linear time a formula φM ∈ FB∪∆3
such that: solB∪∆3(φM ) = {β|V | β ∈ ν-1(solB

V (cid:48)(φ)) ∩ sol∆3

V (cid:48) (φ(cid:48))}.

and sets of variables V ⊆ V (cid:48) =
over the mixed signature

The set solB∪∆3(φM ) can be computed by a ﬁnite domain constraint programming, since
B∪∆3 is a ﬁnite structure. By combining Theorem 23 and Proposition 29 we obtain an algorithm
for solving the general problem of Section 8 in the cases of ∆3.

Characterizing ∆6-Abstractions. The case of ∆6 is considerably more envolved that the case
of ∆3, even though follwoing the same general approach. For this, we consider the abstraction
h∆6 as an element of the algebra of total functions on R2
+. The
following lemma shows that h∆6 is the sum of h∆3 and h2

+, that we denote as R2
B in this Σ-algebra.

+ → R2

Lemma 25. h∆6 = h2

B + h∆3 where + = +R2

+→R2

+

R2
+ : R2

Let idprojG

+ → (R2

+(p)).
Furthermore, we deﬁne for any two functions g : A → B × C and f : B × C → D the pseudo
composition f • g : A → D such that for all a ∈ A: (f • g)(a) = f (π1(g(a)), π2(g(a))). The
Σ-abstraction h2

+ → B2 allows us to deﬁne (h2

+)2 such that for any p ∈ R2

+)2 → (B2)2

R2
+(p) = (p, projG

+ idprojG

B)2 : (R2

B : R2

R2

Lemma 26 Decomposition. h∆6 = +R2

+ • (h2

B)2 ◦ idprojG

R2

+.

We can now deﬁne the ternary relation idprojG

V × V 2 → F 2

Σ such that for all x, y1, y2 ∈ V:

R2
+ in the ﬁrst-order logic with pairs by idprojG :

idprojG (x, y1, y2) =def (cid:104)x = y1(cid:105)2 ∧ projG (x, y2)

13

Σ with V(φ(y)) ⊆ {y} we deﬁne a formula idprojG (φ(y)) ∈ F 2

We next deﬁne applications of idprojG in FO-logic. For any sequence of variables y and
FO-formula φ(y) ∈ F 2
Σ for de-
scribing the application of idprojG to the solution set of φ(y). We let idprojG (φ(y) be ∃z. φ(z) ∧
idprojG (z, y1, y2) where φ(z) is obtained from φ(y) by replacing the variables in y by arbitrarily
but ﬁxed fresh variables z and by ﬁxing two sequences of fresh variables y1, y2 ∈ V m such that
y = (y1, y2).

Lemma 27. idprojG

R2
+ ◦ 2-solR+(φ(y)) = {[y/(α(y1), α(y2)] | α ∈ 2-solR+(idprojG (φ(y)))}.

Theorem 28. For any linear formula L(y) with free distinct variable y we can compute in at
most exponential time a positive conjunctive formula with existential quantiﬁers φ(cid:48) ∈ FΣ and
sequences of variables y1, y2 such that:

h∆6 ◦ diﬀ(solR+(L(y))) = {[y/(β(y1) +R2

+ β(y2)] | β ∈ ν-1(solB(φ(cid:48)))}

Proof Let L(y) be a linear formula L with free distinct variable y ∈ V m.

h∆6 ◦ diﬀ(solR+(L(y)))

Proposition 15 = h∆6 ◦ solR2
+(L(y))
Proposition 10 = h∆6 ◦ 2-solR+(L2(y)) with L2(y) = (cid:104)L(y)(cid:105)2

Decomposition Lemma 26 = +R2
+ • (h2
FO-Deﬁnition Lemma 27 = +R2
+ • (h2
hR2
+ • {[y/(β(y1), β(y2)] | β ∈ h2

B)2 ◦ idprojG
B)2 ◦ {[y/(α(y1), α(y2)] | α ∈ 2-solR+ (idprojG (L2(y)))}

R2
+ ◦ 2-solR+(L2(y))

B ◦ 2-solR+(idprojG (L2(y)))}

= +
= {[y/(β(y1) +R2

+ β(y2)] | β ∈ h2

B ◦ 2-solR+(idprojG (L2(y)))}

We can now ﬁnish the proof by computing the h2
to the case of ∆3.

B abstraction of the above solution set similarly

B ◦ 2-solR+(idprojG (L2)(y))
h2

B ◦ ν-1(solR+(˜ν(idprojG (L2(y))))
Proposition 12 = h2
Proposition 13 = ν-1(hB ◦ solR+(˜ν(idprojG (L2(y)))))

Deﬁnition of idprojG (L2(y)) = ν-1(hB ◦ solR+(˜ν(∃z. L2(z) ∧ idprojG (z, y))))

Mixed linear systems Theorem 20 = ν-1(solB(φ(cid:48)))

where φ(cid:48) is conjunctive formula equivalent to the
mixed linear system ˜ν(∃z. L2(z) ∧ idprojG (z, y))

For adding a treatment of kinetic constraints, we consider the union B ∪ ∆6 as a relational
structure providing the values and functions of both structures B and ∆6 in analogy to the case
.
of ∆3. We denote the of ﬁrst-order formulas over the signature of this mixed structure by FB∪∆6

Proposition 29. For any formula φ(y) ∈ FΣ with distinct free variables y, formula φ(cid:48) ∈ FΣ∪∆6
,
and variable sets V ⊆ V (cid:48) = V(y) ∪ V(φ(cid:48)) we can compute in linear time a formula φM ∈ FB∪∆6
such that solB∪∆6 (φM ) = {β|V | β ∈ {[y/(β(cid:48)(y1) +R2

+ β(cid:48)(y2)) | β(cid:48) ∈ ν-1(solB

V (cid:48)(φ))} ∩ sol∆6

V (cid:48) (φ(cid:48)).

The set solB∪∆6(φM ) can be computed by a ﬁnite domain constraint programming, since
B∪∆6 is a ﬁnite structure. By combining Theorem 28 and Proposition 29 we obtain an algorithm
for solving the general problem of Section 8 in the case of ∆6.

14

Network
Simple metabolic cycle (Fig. 1) abstract solutions

Count type

Leucine overproduction [4]

Counterexample

knockouts
abstract solutions
abstract solutions

pure abstr. interpr. min. support consequences exact

19
16
292
≥ 10000

6
14
228
4454

6
14
228
4374

Fig. 8. Predictions for the networks analysed in this paper, obtained respectively by pure abstract
interpretation, the heuristic based on minimal support consequences and the exact algorithm.

10 Heuristic Algorithm Based on Minimal Support Consequences

The intuition behind the heuristic with minimal support consequences relies on two facts: ﬁrst,
adding consequences to a given linear system L before applying abstract interpretation can im-
prove the precision of the abstraction, as already discussed (2); second, the smaller the number
of variables in an equation, the more constraining generally is its abstract interpretation. The
heuristics is therefore very simple: before abstracting from R+ to ∆, the linear system L con-
taining the steady state equations of the system is replaced by a linear system Lmin containing
all the minimal support R+-consequences of the equations in L. The linear system Lmin can be
computed by applying any existing algorithm for the calculation of R-EFMs to the orthogonal
complement of L⊥ as follows:

1. From L compute a linear system L⊥ whose solution space – seen as a subspace of the vector
space RV(L) – is the orthogonal complement of solR+(L). This can be done for example by
using a variant of Gauß’ triangularization method.

2. From L⊥ compute the R-EFMs lmin
3. Build Lmin by using lmin

1
, . . . , lmin

1

k

, . . . , lmin

k with any known R-EFMs algorithm.

as the coeﬃcients of the equations of Lmin.

11 Experimental Results

R+
V (cid:48) (φ)∆6 ∩sol∆

We experimentally compare three algorithms for overapproximating the objective {β|V | β ∈
V (cid:48)(φ(cid:48))} given a linear system of equations φ, kinetic constraints φ(cid:48), and observable
sol
variables V . The ﬁrst algorithm directly applies pure abstract interpretation to φ to compute
sol∆6 (∃V .(φ ∧ φ(cid:48))) by ﬁnite domain programming where V = V(φ) \ V , overapproximating the
objective by Theorem 18. The second algorithm enriches the linear system φ with its minimal
support consequences as discussed in Section 10 before applying abstract interpretation. The
third algorithm is the exact algorithm that can be derived from Theorem 28.

The experimental results are summarized in Fig. 8. The ﬁrst instance veriﬁes our expectations
on the toy metabolic network with a simple cycle in Fig. 1, without kinetic constraints and V =
{X, Y } as observable variables. The exact algorithm shows that there are 6 abstract solutions,
one for each value of ∆6. The heuristic with minimal support consequences ﬁnds exactly these
same 6 abstract solutions, while by applying pure abstract interpretation we ﬁnd 19 abstract
solutions (out of 36 possible assignments), thus a large overapproximation.

The second real scale instance treats leucine overproduction on the network from Fig. 2, see
Fig. 7 for a discussion of the precise inputs. The heuristic and the exact algorithm produce the
same result with 226 abstract solutions, while by pure abstract interpretation 292 abstract solu-
tions are found. Thereby, the two new algorithms both remove the same 2 wrong gene knockout
predictions with respect to baseline algorithm by pure abstract interpretation.

15

However, the heuristics with minimal support con-
sequences is not always exact: we found a counter
example given on the right for which it slightly over-
approximates the exact solution set.
On the other hand, the heurstic algorithm with EFM-
consequences is remarkably faster than the exact al-
gorithm – in the benchmark on leucine overproduc-
tion, we have 5 minutes versus 5 hours – while still
being equally precise in most cases.

References

1. E. Allart, J. Niehren, and C. Versari. Computing sign abstractions of linear systems. In preparation.
2. L. Calzone, F. Fages, and S. Soliman. BIOCHAM: an environment for modeling biological systems

and formalizing experimental knowledge. Bioinformatics, 22(14):1805–1807, July 2006.

3. P. Cousot and R. Cousot. Systematic design of program analysis frameworks.

In POPL, pages

269–282, 1979.

4. F. Coutte, J. Niehren, D. Dhali, M. John, C. Versari, and P. Jacques. Modeling Leucine’s Metabolic
Pathway and Knockout Prediction Improving the Production of Surfactin, a Biosurfactant from
Bacillus Subtilis. Biotechnology Journal, 10(8):1216–34, Aug. 2015.

5. V. Danos, J. Feret, W. Fontana, R. Harmer, and J. Krivine. Abstracting the diﬀerential semantics of
rule-based models: Exact and automated model reduction. In LICS, pages 362–381. IEEE Computer
Society, 2010.

6. G. Facchetti and C. Altaﬁni. Partial inhibition and bilevel optimization in ﬂux balance analysis.

BMC Bioinformatics, pages 344–344, 2013.

7. F. Fages, S. Gay, and S. Soliman. Inferring reaction systems from ordinary diﬀerential equations.

Theor. Comput. Sci., 599:64–78, 2015.

8. F. Fages and S. Soliman. Abstract interpretation and types for systems biology. Theor. Comput.

Sci., 403(1):52–70, 2008.

9. M. Feinberg. Chemical reaction network structure and the stability of complex isothermal reactors.

Chemical Engineering Science, 42(10):2229 – 2268, 1987.

10. K. D. Forbus. Qualitative reasoning. In A. B. Tucker, editor, The Computer Science and Engineering

Handbook, pages 715–733. CRC Press, 1997.

11. S. Hoops, S. Sahle, R. Gauges, C. Lee, J. Pahle, N. Simus, M. Singhal, L. Xu, P. Mendes, and
U. Kummer. Copasi—a complex pathway simulator. Bioinformatics, 22(24):3067–3074, 2006.
12. M. John, M. Nebut, and J. Niehren. Knockout Prediction for Reaction Networks with Partial
Kinetic Information. In 14th International Conference on Veriﬁcation, Model Checking, and Abstract
Interpretation, Rom, Italy, Jan. 2013.

13. K. Lotz, A. Hartmann, E. Grafahrend-Belau, and B. Schreiber, F.and Junker. Elementary ﬂux
modes, ﬂux balance analysis, and their application to plant metabolism. Plant Metabolism. Methods
in Molecular Biology (Methods and Protocols), 2014.

14. C. D. Maranas and A. R. Zomorrodi. Flux Balance Analysis and LP Problems, chapter 3, pages

53–80. Wiley-Blackwell, 2016.

15. J. Niehren, C. Versari, M. John, F. Coutte, and P. Jacques. Predicting Changes of Reaction Networks

with Partial Kinetic Information. BioSystems, 149:113–124, July 2016.

16. J. D. Orth, I. Thiele, and B. O. Palsson. What is ﬂux balance analysis? Nature biotechnology,

28(3):245–248, 2010.

17. J. A. Papin, J. Stelling, N. D. Price, S. Klamt, S. Schuster, and B. O. Palsson. Comparison of

network-based pathway analysis methods. Trends in biotechnology, 22(8):400–405, 2004.

18. A. Rendl, T. Guns, P. J. Stuckey, and G. Tack. Minisearch: A solver-independent meta-search
language for minizinc. In G. Pesant, editor, Principles and Practice of Constraint Programming -
21st International Conference, CP 2015, volume 9255 of LNCS, pages 376–392, 2015.

19. D. Zanghellini, D. E. Ruckerbauer, M. Hanscho, and C. Jungreuthmayer. Elementary ﬂux modes in
a nutshell: Properties, calculation and applications. Biotechnology Journal, pages 1009–1016, 2013.

16

