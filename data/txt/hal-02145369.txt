Reasoning about disclosure in data integration in the
presence of source constraints
Michael Benedikt, Pierre Bourhis, Louis Jachiet, Michaël Thomazo

To cite this version:

Michael Benedikt, Pierre Bourhis, Louis Jachiet, Michaël Thomazo. Reasoning about disclosure in
data integration in the presence of source constraints. IJCAI 2019 - 28th International Joint Conference
on Artificial Intelligence, Aug 2019, Macao, China. ￿hal-02145369v3￿

HAL Id: hal-02145369

https://inria.hal.science/hal-02145369v3

Submitted on 14 Dec 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Reasoning about Disclosure in Data Integration in the Presence of Source
Constraints

Michael Benedikt1 , Pierre Bourhis2 , Louis Jachiet2 and Micha¨el Thomazo3
1University of Oxford
2CNRS CRIStAL, Universit´e Lille, Inria Lille
3Inria, DI ENS, ENS, CNRS, PSL University
{pierre.bourhis, louis.jachiet}@univ-lille.fr, michael.thomazo@inria.fr, michael.benedikt@cs.ox.ac.uk

Abstract

Data integration systems allow users to access data
sitting in multiple sources by means of queries over
a global schema, related to the sources via map-
pings. Datasources often contain sensitive informa-
tion, and thus an analysis is needed to verify that a
schema satisﬁes a privacy policy, given as a set of
queries whose answers should not be accessible to
users. Such an analysis should take into account not
only knowledge that an attacker may have about the
mappings, but also what they may know about the
semantics of the sources. In this paper, we show
that source constraints can have a dramatic impact
on disclosure analysis. We study the problem of de-
termining whether a given data integration system
discloses a source query to an attacker in the pres-
ence of constraints, providing both lower and upper
bounds on source-aware disclosure analysis.

1 Introduction

In data integration, users are shielded from the heterogene-
ity of multiple datasources by querying via a global schema,
which provides a uniﬁed vocabulary. The relationship be-
tween sources and the user-facing schema are speciﬁed
declaratively via mapping rules. In data integration systems
based on knowledge representation techniques, users pose
queries against the global schema, and these queries are an-
swered using data in the sources and background knowledge.
The computation of the answers involves reasoning based on
the query, the mappings, and any additional semantic infor-
mation that is known on the global schema.

Data integration brings with it the danger of disclosing
information that data owners wish to keep conﬁdential.
In
declarative data integration, detection of privacy violations is
complex: although explicit access to source information may
be masked by the global schema, an attacker can infer source
facts via reasoning with schema and mapping information.

Predicate Meaning

IsOpen(b, t)
PatBdlg(p, b)
PatSpec(p, s)
PatDoc(p, d)
DocBldg(d, b)
DocSpec(d, s)

building b is open on date t
patient p is present in building b
patient p was treated for specialty s
patient p was treated by doctor d
doctor d is associated with building b
doctor d is associated with specialty s

the

The

hospital

publishes

data:
OpenHours(b, t) giving opening times t for building b,
VisitingHours(p, t) giving times t when a given patient p
can be visited, and DocList(d, s, b) listing the doctors d with
their specialty s and their building b. Formally the data
being exposed is given by the following mappings:

following

IsOpen(b, t) → OpenHours(b, t)

PatBdlg(p, b) ∧ IsOpen(b, t) → VisitingHours(p, t)

DocSpec(d, s) ∧ DocBldg(d, b) → DocList(d, s, b)

Prior work [Benedikt et al., 2018] has studied disclosure in
knowledge-based data integration, with an emphasis on the
role of semantic information on the global schema – in the
form of ontological rules that relate the global schema vo-
cabulary. The presence of an ontology can assist in privacy,
since distinctions in the source data may become indistin-
guishable in the ontology. More dangerous from the point of
view of protecting information is semantic information about
sources. For example, the sources in a data integration set-
ting will generally overlap: that is, they will satisfy referen-
tial integrity constraints, saying that data items in one source
link to items in another source. Such constraints should be
assumed as public knowledge, and with that knowledge the
attacker may be able to infer information that was intended to
be secret.
Example 2. Continuing Example 1, suppose that we know
that each patient has a doctor specialized in their condition,
which can be formalized as:

PatDoc(p, d) → ∃s PatSpec(p, s) ∧ DocSpec(d, s)

And that we also know that when a patient is in a building,
they must have a doctor there:

PatBdlg(p, b) → ∃d PatDoc(p, d) ∧ DocBldg(d, b)

Example 1. We consider an information integration setting
for a hospital, which internally stores the following data:

Due to the presence of these constraints, there can be
to speciality
the relationship of patient

a disclosure of

PatSpec(p, s). Indeed, an attacker can see the VisitingHours
for p, and from this, along with OpenHours, they can some-
times infer the building b where p is treated (e.g. if b has a
unique set of open hours). From this they may be able to infer,
using DocList, the specialty that p has been treated for – for
example, if all the doctors in b share a specialty.

In this work, we perform a detailed examination of the role
of source constraints in disclosing information in the context
of data integration. We focus on mappings from the sources
given by universal Horn rules, where the global schema
comes with no constraints. Since our disclosure problem re-
quires reasoning over all sources satisfying the constraints,
we need a constraint formalism that admits effective reason-
ing. We will look at a variety of well-studied rule-based for-
malisms, with the simplest being referential constraints, and
the most complex being the frontier-guarded rules [Baget et
al., 2011]. While decidability of our disclosure problems will
follow from prior work [Benedikt et al., 2016], we will need
new tools to analyze the complexity of the problem. In Sec-
tion 3, we give reductions of disclosure problems to the query
entailment problem that is heavily-studied in knowledge rep-
resentation. While a na¨ıve application of the reduction al-
lows us only to conclude very pessimistic bounds, a more
ﬁne-grained analysis, combined with some recent results on
CQ entailment, will allow us to get much better bounds, in
some cases ensuring tractability. In Section 4, we comple-
ment these results with lower bounds. Both the upper and
lower bounds revolve around a complexity analysis for rea-
soning with guarded existential rules and a restricted class
of equality rules, where the rule head compares a variable
and a distinguished constant. We believe this exploration of
limited equality rules can be productive for other reasoning
problems.

Overall we get a complete picture of the complexity of dis-
closure in the presence of source constraints for many nat-
ural classes: see Tables 1 in Section 6 for a summary of
our bounds. Full proofs are available at the address https:
//hal.inria.fr/hal-02145369.

2 Preliminaries
We adopt standard notions from function-free ﬁrst-order logic
over a vocabulary of relational names. An instance is a ﬁnite
set of facts. By a query we always mean a conjunctive query
(CQ), which is a ﬁrst-order formula of the form ∃(cid:126)x (cid:86) Ai,
where each Ai is an atom. The arity of a CQ is the number of
its free variables, and CQs of arity 0 are Boolean.
Data integration. Assume that the relational names in the
vocabulary are split into two disjoint subsets: source and
global schema. The arity of such a schema is the maximal
arity of its relational names. We consider a set M of mapping
rules between source relations and a global schema relation
T given. We focus on rules φ((cid:126)x, (cid:126)y) → T ((cid:126)x) where φ is a
conjunctive query, there are no repeated variables in T ((cid:126)x),
and where each global schema relation T is associated with
exactly one rule. Such rules are sometimes called “GAV map-
pings” in the database literature [Lenzerini, 2002], and the
unique φ associated to a global relation T is referred to as the
deﬁnition of T . The rules are guarded (M ∈ GuardedMap)

if for every rule, there exists an atom in the antecedent φ
that contains all the variables of φ. The rules are atomic
(M ∈ AtomMap) if each φ consists of a single atom, and
they are projection maps (M ∈ ProjMap) if each φ is a sin-
gle atom with no repeated variables. Given an instance D for
the source relations, the image of D under mapping M, de-
noted M(D), is the instance for the global schema consisting
of all facts {T ((cid:126)c) | D |= ∃(cid:126)y φ((cid:126)c)}, where φ is the deﬁnition
of T .

Source constraints. We consider
restrictions on the
sources in the form of rules. A tuple-generating depen-
dency (TGD) is a universally quantiﬁed sentence of the form
ϕ(x, z) → ∃yψ(x, y), where the body ϕ(x, z) and the head
ψ(x, y) are conjunctions of atoms such that each term is ei-
ther a constant or a variable in x ∪ z and x ∪ y, respectively.
Variables x, common to the head and body, are called the
frontier variables. A frontier-guarded TGD (FGTGD) is a
TGD in which there is an atom of the body that contains
every frontier variable. We focus on FGTGDs because they
have been heavily studied in the database and knowledge rep-
resentation community, and it is known that many computa-
tional problems involving FGTGDs are decidable [Baget et
al., 2011]. In particular this is true of the query entailment
problem, which asks, given a ﬁnite collection of facts F, a
ﬁnite set Σ of sentences, and a CQ Q, whether F ∧ Σ entails
Q. We use QEntail(F, Σ, Q) to denote an instance of this
problem and also say that “F entails Q w.r.t. constraints Σ”.
A special case of FGTGDs are Guarded TGDs (GTGDs), in
which there is an atom containing all body variables. These
specialize further to linear TGDs (LTGDs), whose body con-
sists of a single atom; and even further to inclusion dependen-
cies (IncDeps), a linear TGD with a single atom in the head,
in which no variable occurs multiple times in the body, and
no variable occurs multiple times in the head. Even IncDeps
occur quite commonly: for example, the source constraints
of Example 2 can be rewritten as IncDeps. The most special-
ized class we study are the unary IncDeps:(UIDs), which are
IncDeps with at most one frontier variable.

Queries and disclosure. The sensitive information in a
data integration setting is given by a CQ p over the source
schema, which we refer to as the policy. Intuitively, disclo-
sure of sensitive information occurs in a source instance D
whenever the attacker can infer from the image M(D) that p
holds of a tuple in D. Formally, we say an instance V for the
global schema is realizable, with respect to mappings M and
source constraints ΣSource if there is some source instance D
that satisﬁes ΣSource such that M(D) = V. For a realizable
V, the set of such D are the possible source instances for V.
A query result p((cid:126)t) is disclosed at V if p((cid:126)t) holds on all possi-
ble source instances for V. A query p admits a disclosure (for
mappings M and source constraints ΣSource) if there is some
realizable instance V and binding (cid:126)t for the free variables of
p for which p((cid:126)t) is disclosed. In this terminology, the con-
clusion of Example 2 was that policy PatSpec(p, s) admits a
disclosure with respect to the constraints and mappings. For
a class of constraints C, a class of mappings Map, a class
of policies Policy, we write DiscloseC(C, Map) to denote the
problem of determining whether a policy (a CQ, unless other-

wise stated) admits a disclosure for a set of mappings in Map
and a set of source constraints in C. Given ΣSource, M and a
CQ p, the corresponding instance of this problem is denoted
by Disclose(C, M, p). In this paper we will focus on disclo-
sure for queries and constraints without constants, although
our techniques extend to the setting with constants, as long as
distinct constants are not assumed to be unequal.

a

is

to

ﬁrst

goal

provide

reduction

3 Reducing Disclosure to Query Entailment
Our
from
DiscloseC(TGD, Map) to a ﬁnite collection of standard
query entailment problems.
For simplicity we will re-
to Boolean queries p in stating the results, but
strict
it
is straightforward to extend the reductions and re-
sults to the non-Boolean case. We ﬁrst recall a prior
reduction of DiscloseC(TGD, Map) to a more complex
the hybrid open and closed world query an-
problem,
swering problem [Lutz et al., 2013; Lutz et al., 2015;
Franconi et al., 2011], denoted HOCWQ. HOCWQ takes as
input a set of facts F, a collection of constraints Σ, a Boolean
query Q, and additionally a subset C of the vocabulary. A
possible world for such HOCWQ(F, Σ, Q, C) is any instance
D containing F, satisfying Σ, and such that for each relation
C ∈ C, the C-facts in D are the same as the C-facts in F.
HOCWQ(F, Σ, Q, C) holds if Q holds in every possible
world. Note that the query entailment problem is a special
case of HOCWQ, where C is empty.

Given a set of mapping rules M of the form φ((cid:126)y, (cid:126)x) →
T ((cid:126)x), we let G(M) be the set of global schema predicates,
and let ΣM(M) be the mapping rules, considered as bi-
directional constraints between global schema predicates and
sources.

We now recall one of the main results of [Benedikt et al.,

2016]:
Theorem 1.
putable
that Disclose(ΣSource, M, p)
and
HOCWQ(D(cid:48), ΣSource ∪ ΣM(M), p, G(M)) holds.

instance D(cid:48)
an
from ΣSource, M, p,
if

is
time

linear

There

holds

in

com-
such
if

only

In fact, the arguments in [Benedikt et al., 2016] show that
D(cid:48) can be taken to be a very simple instance, the critical in-
stance over the global schema G(M) denoted DG(M)
Crit where
DS
Crit, for S a set of predicates, denotes the instance that men-
tions only a single element cCrit, and contains, for each rela-
tion R in S of arity n, the fact R(cCrit, . . . cCrit).
Corollary 1. DiscloseC(FGTGD, CQMap) is in 2EXPTIME.

Proof. The non-classical aspect of HOCWQ comes into play
with rules of ΣM(M) of form φ((cid:126)x, (cid:126)y) → T ((cid:126)x). But in the
context of DG(M)
, these can be rewritten as single-constant
equality rules (SCEQrules) φ((cid:126)x, (cid:126)y) → (cid:86)
i xi = cCrit. Such
rules remain in the Guarded Negation Fragment of ﬁrst-order
logic, which also subsumes FGTGDs, while having a query
entailment problem in 2EXPTIME [B´ar´any et al., 2015].

Crit

We now want to conduct a ﬁner-grained analysis, looking
for cases that give lower complexity. To do this we will trans-
form further into a classical query entailment problem. This

will require a transformation of our query p, a transforma-
tion of our source constraints and mappings into a new set of
constraints, and a transformation of the instance DG(M)
. The
idea of the transformation is that we remove the SCEQrules
that are implicit in the HOCWQ problem, replacing them with
constraints and queries that reﬂect all the possible impacts the
rules might have on identifying two variables.

Crit

We ﬁrst describe the transformation of the query and the
constraints. They will involve introducing a new unary pred-
icate IsCrit(x); informally this states that x is equal to cCrit.
Consider a CQ Q = ∃(cid:126)y (cid:86) Ai. An annotation of Q is a sub-
set of Q’s variables. Given an annotation Annot of Q, we let
QAnnot be the query obtained from Q by performing the fol-
lowing operation for each v in Annot: for all occurrences j of
v except the ﬁrst one, replacing v with a fresh variable vj; and
adding conjuncts IsCrit(vj) as well as IsCrit(v) to QAnnot. A
critical-instance rewriting of a CQ Q is a CQ obtained by ap-
plying the above process to Q for any annotation. We write
QAnnot ∈ CritRewrite(Q) to indicate that QAnnot is such a
rewriting.

To transform the mapping rules and constraints to a new set
of constraints using IsCrit(x), we lift the notion of critical-
instance rewriting to TGDs in the obvious way: a critical-
instance rewriting of a TGD σ (either in ΣSource or ΣM(M)),
is the set of TGDs formed by applying the above process to
the body of σ. We write σAnnot ∈ CritRewrite(Σ) to indi-
cate that σAnnot is a critical-instance rewriting for a σ ∈ Σ,
and similarly for mappings. For example, the second map-
ping rule in Example 1 has several rewritings; one of them
will change the rule body to PatBdlg(p, b) ∧ IsOpen(b(cid:48), d) ∧
IsCrit(b) ∧ IsCrit(b(cid:48)).

Our transformed constraints will additionally use the set of

constraints IsCrit(M), including all rules:

T (x1 . . . xn) → IsCrit(xi)

where T ranges over the global schema and 1 ≤ i ≤ n. In-
formally IsCrit(M) states that all elements in the mapping
image must be cCrit. We also need to transform the instance,
using a source instance with “witnesses for the target facts”.
Consider a fact T (cCrit . . . cCrit) in DG(M)
formed by apply-
ing a mapping rule (cid:86)
i Ai((cid:126)xi, (cid:126)yi) → T ((cid:126)x) in M. The set
of witness tuples for T ((cid:126)x) is the set Ai((cid:126)c), where (cid:126)c con-
tains cCrit in each position containing a variable xj and con-
taining a constant cyj in every position containing a vari-
able yj. That is the witness tuples are witnesses for the
fact T (cCrit . . . cCrit), where each existential witness is chosen
fresh. Let HideM(DG(M)
) be the instance formed by taking
the witness tuples for every fact T (cCrit . . . cCrit) ∈ DG(M)

Crit

Crit

.

We are now ready to state the reduction of the disclosure

Crit

problem to query entailment:
Theorem 2. Disclose(ΣSource, M, p) holds exactly when
there is a pAnnot ∈ CritRewrite(p) such that HideM(DG(M)
)
entails pAnnot w.r.t. constraints:

Crit

CritRewrite(ΣSource) ∪ CritRewrite(M) ∪ IsCrit(M)

Note that Theorem 2 does not give a polynomial time re-
duction: both CritRewrite(ΣSource) and CritRewrite(M) can

contain exponentially many rewritings, and further there can
be exponentially many rewritings in CritRewrite(p).

However, the algorithm does give us a better bound in the

case of Guarded TGDs with bounded arity.
Corollary 2. If we bound the arity of schema relations, then
DiscloseC(GTGD, GuardedMap) is in EXPTIME.

Proof. First, by introducing additional
intermediate rela-
tions and source constraints, we can assume that M con-
tains only projection mappings. Thus we can guarantee that
CritRewrite(M) just contains the rules in M. By introduc-
ing intermediate relations and additional source constraints,
we can also assume that each GTGD ∈ ΣSource has a body
with at most two atoms. Since the arity of relations is ﬁxed,
the size of such 1- or 2-atom bodies is ﬁxed as well. From this
we see that the number of constraints in any CritRewrite(σ)
is polynomial. The reduction in Theorem 2 thus gives us ex-
ponentially many GTGD entailment problems of polynomial
size. Since entailment over Guarded TGDs with bounded ar-
ity is in EXPTIME [Cal`ı et al., 2013], we can conclude.

3.1 Reﬁnements of the Reduction to Identify

Lower Complexity Cases

In order to lower the complexity to EXPTIME without bound-
ing the arity, we reﬁne the construction of the function
CritRewrite(σ) in the case where σ is a linear TGD, provid-
ing a function CritRewritePTIME(σ) that constructs only poly-
nomially many rewritten constraints.

Let σ = B((cid:126)x) → ∃(cid:126)y H((cid:126)z) be a linear TGD with relation
B of arity k, and suppose (cid:126)x contains d distinct free variables
V = {v1 . . . vd}. Let P be the set of pairs (e, f ) with e <
f ≤ k such that the same variable vi sits at positions e and f
in (cid:126)x. We order P as (e0, f0) . . . (eh, fh); for each (e, f ) that
is not the initial pair (e0, f0), we let (e, f )− be its predecessor
in the linear order.

We let Be,f denote new predicates of arity k for each
(e, f ) ∈ P . Let (cid:126)w be a set of k distinct variables, and
(cid:126)wi=j be formed from (cid:126)w by replacing wj with wi. We begin
the construction of CritRewritePTIME(σ) with the constraints:
B( (cid:126)we0=f0 ) → Be0,f0( (cid:126)we0=f0) and B( (cid:126)w) ∧ IsCrit(we0) ∧
IsCrit(wf0) → Be0,f0 ( (cid:126)w).

For each (e, f ) with a predecessor (e, f )− = (e(cid:48), f (cid:48)),
we add to CritRewritePTIME(σ) the following constraints:
Be(cid:48),f (cid:48)( (cid:126)we=f ) → Be,f ( (cid:126)we=f ) and Be(cid:48),f (cid:48)( (cid:126)w) ∧ IsCrit(we) ∧
IsCrit(wf ) → Be,f ( (cid:126)w).

If

of

ΣSource

LTGDs,

in P , we

Letting eh, fh

the ﬁnal pair

add to
CritRewritePTIME(σ) the constraint Beh,fh ((cid:126)x(cid:48)) → ∃(cid:126)y H((cid:126)z)
where (cid:126)x(cid:48) is obtained from (cid:126)x by replacing all but the ﬁrst
occurrence of each variable v by a fresh variable.
consists

let
CritRewritePTIME(ΣSource) be the result of applying this
process to every σ ∈ ΣSource. Similarly, if M consists of
atomic mappings (implying that the associated rules are
LTGDs),
then we let CritRewritePTIME(M) the result of
applying the process above to the rule going from source
relation to global schema relation associated to m ∈ M.
Then we have:
Theorem 3. When ΣSource
LTGDs,
Disclose(ΣSource, M, p) holds exactly when there is a

consists

we

of

pAnnot ∈ CritRewrite(p) such that HideM(DG(M)
pAnnot w.r.t. to the constraints

Crit

) entails

CritRewritePTIME(ΣSource)∪CritRewritePTIME(M)∪IsCrit(M)

We can combine this result with recent work on ﬁne-
grained complexity of GTGDs to improve the doubly expo-
nential upper bound of Corollary 1 for linear TGD source
constraints and atomic mappings:
Theorem 4. DiscloseC(LTGD, AtomMap) is in EXPTIME. If
the arity of relations in the source schema is bounded, then
the complexity drops to NP, while if further the policy is
atomic, the problem is in PTIME.

Proof. It is sufﬁcient to get an EXPTIME algorithm for
the entailment problem produced by Theorem 3, since then
we can apply it to each pAnnot in EXPTIME. The con-
straints in CritRewritePTIME(ΣSource) ∪ CritRewritePTIME(M)
are Guarded TGDs that are not necessarily LTGDs. But the
bodies of these guarded TGDs consist of a guard predicate
and atoms over a ﬁxed “side signature”, namely the unary
predicate IsCrit.
It is known that the query entailment for
IncDeps and guarded TGDs with a ﬁxed side signature is
in EXPTIME, with the complexity dropping to NP (resp.
PTIME) when the arity is ﬁxed (resp. ﬁxed and the query
is atomic) [Amarilli and Benedikt, 2018a].

Can we do better than EXPTIME? We can note that when
the constraints σ ∈ ΣSource are IncDeps, CritRewrite(σ) con-
sists only of σ; similarly if a mapping m ∈ M is a projection,
then CritRewrite(m) consists only of m. This gives us a good
upper bound in one of the most basic cases:
Corollary 3. DiscloseC(IncDep, ProjMap) is in PSPACE. If
further a bound is ﬁxed on the arity of relations in the source
schema, then the problem becomes NP, dropping to PTIME
when the policy is atomic.

Proof. Our algorithm will guess a pAnnot in CritRewrite(Q)
and checks the entailment of Theorem 2. This gives an entail-
ment problem for IncDeps, known to be in PSPACE in gen-
eral, in NP for bounded arity, and in PTIME for bounded arity
and atomic queries [Johnson and Klug, 1984].

3.2 Obtaining Tractability
Thus far we have seen cases where the complexity drops to
PSPACE in the general case and NP in the bounded arity case,
and PTIME for atomic queries. We now present a case where
we obtain tractability for arbitrary queries and arity. Recall
that a UID is an IncDep where at most one variable is ex-
ported. They are actually quite common, capturing referen-
tial integrity when data is identiﬁed by a single attribute. We
can show that restricting to UIDs while having only projection
maps leads to tractability:
Theorem 5. DiscloseC(UID, ProjMap) is in PTIME.

Proof. The ﬁrst step is to reﬁne the reduction of Theorem 2 to
get an entailment problem with only UIDs, over an instance
consisting of a single unary fact IsCrit(cCrit). The main is-
sue is avoid the constraints in ΣM(M), corresponding to
the mapping rules. The intuition for this is that on DG(M)
,

Crit

the only impact of the backward and forward implications of
ΣM(M) is to create new facts among the source relations. In
these new facts only cCrit, is propagated. Rather than creating
SCEQrules (implicitly what happens in the HOCWQ reduc-
tion) or generating classical constraints where the impact of
the equalities are “baked in” (as in the critical-instance rewrit-
ings of Theorems 2 and 3), we truncate the source relations to
the positions where non-visible elements occur, while gener-
ating UIDs on these truncated relations that simulate the im-
pact of back-and-forth using ΣM(M).

The second step is to show that query entailment with UIDs
over the instance consisting only of IsCrit(cCrit) is in PTIME.
This can be seen as an extension of the PTIME inference al-
gorithm for UIDs [Cosmadakis et al., 1990]. The idea behind
this result is to analyze the classical “chase procedure” for
query entailment with TGDs [Fagin et al., 2005]. In the case
of UIDs over a unary fact, the shape of the chase model is very
restricted; roughly speaking, it is a tree where only a single
fact connects two values. Based on this, we can simplify the
query dramatically, making it into an acyclic query where any
two variables co-occur in at most one predicate. Once query
simpliﬁcation is performed, we can reduce query entailment
to polynomial many entailment problems involving individ-
ual atoms in the query. This in turn can be solved using the
UID inference procedure of [Cosmadakis et al., 1990].

lower

bounds

providing

4 Lower Bounds
for
We
on
now focus
DiscloseC(C, Map), showing in particular that
the upper
bounds provided in Section 3 can not be substantially
improved. For many classes of constraints it is easy to see
that the complexity of disclosure inherits the lower bounds
for the classical entailment problem for the class. From this
we get a number of matching lower bounds; e.g. 2EXPTIME
for GTGD constraints, PSPACE for IncDep constraints. But
note that in some cases the upper bounds we have provided
for disclosure in Section 3 are higher than the complexity
of entailment over the source constraints. For example,
for IncDeps we have provided only a 2EXPTIME upper
bound for guarded mappings (from Corollary 1), and only an
exponential bound for atomic mappings (from Theorem 4).
This suggests that the form of the mappings inﬂuences the
complexity as well, as we now show.

Most of our proofs for hardness above the entailment
bound for source constraints rely on the encoding of a Tur-
ing machine. Source constraints are used to generate the un-
derlying structures (tree of conﬁgurations, tape of a Turing
machine) while mappings are used to ensure consistency (a
universal conﬁguration is accepting if and only if all its suc-
cessor conﬁgurations are accepting, the content of the tape is
consistently represented,...). To illustrate our approach, we
sketch the proof of the following result.
Theorem
DiscloseC(GTGD, ProjMap) are 2EXPTIME-hard,
are EXPTIME-hard even in bounded arity.

DiscloseC(IncDep, GuardedMap)

and
and

6.

Proof. Recall that Theorem 1 relates disclosure to a HOCWQ
problem on DG(M)
. Also recall from Section 3 the intuition

Crit

that such a problem amounts to a classical entailment prob-
lem for a CQ over a very simple instance, using the source
dependencies and SCEQrules: of the form φ((cid:126)x) → x = cCrit,
where φ will be the body of a mapping. We will sketch how to
simulate an alternating EXPSPACE Turing machine M using
a QEntail problem using IncDeps and guarded SCEQrules.
This can in turn be simulated using our HOCWQ problem.

We ﬁrst build a tree of conﬁgurations using IncDeps, such
that each node has a type (existential or universal) and is the
parent of two nodes (called α-successor and β-successor) of
the opposite type. This tree structure is represented, together
with additional information, by atoms such as:

Children∀(c, cα, cβ, ac, acα, acβ, (cid:126)y0, (cid:126)y1, r).

Intuitively, this states that c is a universal conﬁguration, par-
ent of cα and cβ. ac (resp. acα, resp. acβ) is the acceptance
bit for c (resp. cα, resp. cβ), which will be made equal to
cCrit if and only if the conﬁguration represented by c (resp.
cα, resp. cβ) is accepting. (cid:126)y0, (cid:126)y1 will be used to represent
cell addresses, while r is the identiﬁer of the root of the con-
ﬁguration tree. The initial instance is such an atom, where
the ﬁrst position and the last position are the same constant,
(cid:126)y0 is a vector of n 0’s, (cid:126)y1 is a vector of n 1’s, and all other
arguments are distinct constants.

We use SCEQrules to propagate acceptance information up
in the tree. For instance, a universal conﬁguration is accepting
if both its successors are accepting. This is simulated by the
following SCEQrule:

Children∀(c, cα, cβ, acc, cCrit, cCrit, (cid:126)y0, (cid:126)y1, r) → acc = cCrit.

To simulate M, we need access to an exponential num-
ber of cells for each conﬁguration. We identify a cell by
the conﬁguration it belongs to and an address, which is a
vector, generated by IncDeps, of length n whose arguments
are either 0 or 1. The atom for representing a cell is thus
Cell(cp, c, (cid:126)addr, (cid:126)v, (cid:126)vprev, (cid:126)vnext), where cp is the parent con-
ﬁguration of c, which is the conﬁguration to which the rep-
(cid:126)addr is the address of the cell, (cid:126)v its
resented cell belongs,
content, (cid:126)vprev the content of the previous cell, and (cid:126)vnext the
content of the next cell. Note that this representation is redun-
dant, and we need to use SCEQrules to ensure its consistency.
Note that (cid:126)v is a tuple of length the size of (Σ ∪ {(cid:91)}) ×
(Q ∪ {⊥}). Each position corresponds to an element of that
set, and the content of a represented cell is the element which
corresponds to the unique position in which cCrit appears.

We now explain how to build the representation of the ini-
tial tape, and simulate the transition function. Both steps are
done by unifying some nulls with cCrit. W.l.o.g., we assume
that the initial tape contains a l in the ﬁrst cell, on which
points the head of M in a state s, and that (l, s) corresponds
to the ﬁrst bit of (cid:126)v. We thus use a SCEQrule to set this bit
to cCrit in the ﬁrst cell of the ﬁrst conﬁguration. We then set
(w.l.o.g.) the second bit of all the other cells of that conﬁgu-
ration to cCrit (assuming this represents ((cid:91), ⊥)).

To simulate the transitions, we note that the content of a
cell in a conﬁguration depends only on the content of the
same cell in the parent conﬁguration, along with the content
of parent’s previous and next cells. We thus add a SCEQrule

M

ΣSource

IncDep
LTGD
GTGD
FGTGD

Unbounded arity

Bounded arity

L=QEntail

ProjMap
PSPACEU =C3
EXPTIMEL=T 7
2EXPTIMEL=T 6
2EXPTIME

AtomMap
EXPTIMEL=T 7
EXPTIMEU =T 4
2EXPTIME
2EXPTIME

GuardedMap
2EXPTIMEL=T 6
2EXPTIME
2EXPTIME
2EXPTIME

CQMap

2EXPTIME
2EXPTIME
2EXPTIME
2EXPTIMEU =C1

ProjMap
NPL=QEntail
NP
EXPTIMEL=T 6
2EXPTIMEL=QEntail

AtomMap

NP
NPU =T 4
EXPTIME
2EXPTIME

GuardedMap
EXPTIMEL=T 6
EXPTIME
EXPTIMEU =C2
2EXPTIME

CQMap
2EXPTIMEL=T 8
2EXPTIME
2EXPTIME
2EXPTIMEU =C1

Table 1: Complexity of disclosure: PSPACE
by Corollary 3 (U=C3) and the Lower bound is inherited from entailment. We omit bounds inferred from inclusion (M or ΣSource).

U =C3
L=QEntail means the corresponding problem is PSPACE-complete, where the Upper bound is given

that checks for the presence of cCrit specifying the content
of three consecutive cells in a conﬁguration, and unify a null
with cCrit to specify the content of the corresponding cell of a
child conﬁguration.

The argument above uses IncDeps and GuardedMaps, but

we can simplify the mappings to ProjMap using GTGDs.

A simple variation of the construction used for PSPACE-
hardness of entailment with IncDeps [Casanova et al., 1984]
shows that our upper bounds for IncDep source constraints
and atomic maps are tight. The case of LTGD source con-
straints and projection maps can be done via reduction to that
of IncDep source constraints and atomic maps:

Theorem
DiscloseC(LTGD, ProjMap) are both EXPTIME-hard.

DiscloseC(IncDep, AtomMap)

7.

and

The above results, coupled with argument that the lower
bounds for entailment are inherited by disclosure, show tight-
ness of all upper bounds from Table 1 in the unbounded arity
case. Another variation of the encoding in Theorem 6 shows
that with no restriction on the mappings one can not do bet-
ter than the 2EXPTIME upper bound of Corollary 1 even for
IncDep constraints in bounded arity,

Theorem 8. DiscloseC(IncDep, CQMap) is 2EXPTIME-hard
in bounded arity.

The theorem above, again combined with results showing
that the lower bounds for entailment are inherited, sufﬁce to
show tightness of all upper bounds from Table 1 in the case
of bounded arity.

We can also show that our tractability result for UID con-
straints and projection maps does not extend when either the
maps or the constraints are broadened. Informally, this is be-
cause with these extensions we can generate an instance on
which CQ querying is NP-hard.

5 Related Work

Disclosure analysis has been approached from many angles.
We do not compare with the vast amount of work that an-
alyzes probabilistic mechanisms for releasing information,
providing probabilistic guarantees on disclosure [Dwork,
2006]. Our work focuses on the impact of reasoning on
mapping-based mechanisms used in knowledge-based infor-
mation integration, which are deterministic; thus one would
prefer, and can hope for, deterministic guarantees on dis-
closure. We deal here with the analysis of disclosure,
while there is a complementary literature on how to enforce
privacy [Biskup and Weibert, 2008; Bonatti et al., 1995;
Bonatti and Sauro, 2013; Studer and Werner, 2014].

The problem of whether information is disclosed on a par-
ticular instance (variation of HOCWQ introduced in Section
3) has been studied in both the knowledge representation
[Lutz et al., 2013; Lutz et al., 2015; Franconi et al., 2011;
Ahmetaj et al., 2016; Amendola et al., 2018] and database
community [Abiteboul and Duschka, 1998]. The correspond-
ing schema-level problem was deﬁned in [Benedikt et al.,
2016], which allows arbitrary constraints relating the source
and the global schema. However, results are provided only
for constraints in guarded logics, which does not subsume
the case of mappings given here. Our results clarify some
issues in prior work: [Benedikt et al., 2016] claimed that dis-
closure with IncDep source constraints and atomic maps is
in PSPACE, while our Theorem 7 shows that the problem is
EXPTIME-hard. Our notion of disclosure corresponds to the
complement of [Benedikt et al., 2018]’s “data-independent
compliance”. The formal framework of [Benedikt et al.,
2018] is orthogonal to ours. On the one hand, source con-
straints are absent; on the other hand a more powerful map-
ping language is considered, with existentials in the head of
rules, while constraints on the global schema, given by on-
tological axioms, are now allowed. [Benedikt et al., 2018]
assume that the attacker has an interface for posing queries
against the global schema, with the queries being answered
under entailment semantics. In general, the semantic infor-
mation on the global schema makes disclosure harder, since
the outputs of different mapping rules may be indistinguish-
able by an attacker who only sees the results of reasoning. In
contrast, source constraints make disclosure of secrets easier,
since they provide additional information to the attacker.

6 Summary and Conclusion

We have isolated the complexity of information disclosure
from a schema in the presence of commonly-studied sets of
source constraints. A summary of many combinations of
mappings M and source constraints ΣSource is given in Ta-
ble 1: note that all problems are complete for the complex-
ity classes listed. We have shown tractability in the case of
UIDs and projection maps (omitted in the tables), while show-
ing that lifting the restriction leads to intractability. But we
leave open a ﬁner-grained analysis of complexity for frontier-
one constraints with more general mappings. Our results de-
pend on a ﬁne-grained analysis of reasoning with TGDs and
SCEQrules, a topic we think is of independent interest.

Acknowledgements

This work was partially funder by CNRS Momentum project
“Managing Data without Leak”.

References
[Abiteboul and Duschka, 1998] Serge Abiteboul and Olivier
Duschka. Complexity of answering queries using materi-
alized views. In PODS, pages 254–263, 1998.

[Ahmetaj et al., 2016] Shqiponja Ahmetaj, Magdalena Or-
tiz, and Mantas ˇSimkus. Polynomial datalog rewritings
for expressive description logics with closed predicates. In
IJCAI, pages 878–885, 2016.

[Amarilli and Benedikt, 2018a] Antoine

and
Michael Benedikt. When Can We Answer Queries
Using Result-Bounded Data Interfaces? In PODS, pages
281–293, 2018.

Amarilli

[Amarilli and Benedikt, 2018b] Antoine

and
Michael Benedikt. When Can We Answer Queries Using
Result-Bounded Data Interfaces? In arxiv, 2018. available
at https://arxiv.org/pdf/1706.07936.pdf.

Amarilli

[Amendola et al., 2018] Giovanni Amendola, Nicola Leone,
Marco Manna, and Pierfrancesco Veltri. Enhancing exis-
In IJCAI, pages
tential rules by closed-world variables.
1676–1682, 2018.

[Baget et al., 2011] Jean-Franc¸ois Baget, Michel Lecl`ere,
Marie-Laure Mugnier, and Eric Salvat. On rules with ex-
istential variables: Walking the decidability line. Artif. In-
tell., 175(9-10), 2011.

[B´ar´any et al., 2015] Vince B´ar´any, Balder Ten Cate, and
Luc Segouﬁn. Guarded negation. J. ACM, 62(3):356–367,
2015.

[Benedikt et al., 2016] Michael Benedikt, Pierre Bourhis,
Balder ten Cate, and Gabriele Puppis. Querying visible
and invisible information. In LICS, pages 297–306, 2016.
[Benedikt et al., 2018] Michael Benedikt, Bernardo Cuenca
Grau, and Egor V. Kostylev. Logical foundations of infor-
mation disclosure in ontology-based data integration. Ar-
tif. Intell., 262:52–95, 2018.

[Bienvenu et al., 2018] Meghyn Bienvenu, Stanislav Kikot,
Roman Kontchakov, Vladimir V. Podolskii, and Michael
Zakharyaschev. Ontology-mediated queries: Combined
complexity and succinctness of rewritings via circuit com-
plexity. J. ACM, 65(5), 2018.

[Biskup and Weibert, 2008] Joachim Biskup and Torben
Weibert. Keeping Secrets in Incomplete Databases. Int.
J. Inf. Sec., 7(3):199–217, 2008.

[Bonatti and Sauro, 2013] Piero A. Bonatti and Luigi Sauro.
In ISWC, pages

A conﬁdentiality model for ontologies.
17–32, 2013.

[Bonatti et al., 1995] Piero Bonatti, Sarit Kraus, and V. S.
Foundations of Secure Deductive

Subrahmanian.
Databases. TKDE, 7(3):406–422, 1995.

[Cal`ı et al., 2013] Andrea Cal`ı, Georg Gottlob, and Michael
Kifer. Taming the inﬁnite chase: Query answering under
expressive relational constraints. JAIR, pages 70–80, 2013.
[Casanova et al., 1984] Marco Casanova, Ronald Fagin, and
Christos Papadimitriou. Inclusion dependencies and their

interaction with functional dependencies. JCSS, 28(1):29–
59, 1984.

[Cosmadakis et al., 1990] Stavros S. Cosmadakis, Paris C.
Kanellakis, and Moshe Y. Vardi. Polynomial-time implica-
tion problems for unary inclusion dependencies. J. ACM,
37(1):15–46, 1990.

[Dwork, 2006] Cynthia Dwork. Differential privacy.

In

ICALP, pages 1–12, 2006.

[Fagin et al., 2005] Ronald Fagin, Phokion G. Kolaitis, Re-
nee J. Miller, and Lucian Popa. Data Exchange: Seman-
tics and Query Answering. Theoretical Computer Science,
336(1):89–124, 2005.

[Franconi et al., 2011] Enrico Franconi, Yasmin Ib´a˜nez-
Garc´ıa, and Inanc¸ Seylan. Query answering with DBoxes
is hard. ENTCS, 278:71–84, 2011.

[Gottlob et al., 2014] Georg Gottlob, Marco Manna, and An-
dreas Pieris. Polynomial combined rewritings for existen-
tial rules. In KR, 2014.

[Johnson and Klug, 1984] David S. Johnson and Anthony C.
Klug. Testing Containment of Conjunctive Queries un-
der Functional and Inclusion Dependencies. JCSS, 28(1),
1984.

[Kikot et al., 2011] Stanislav Kikot, Roman Kontchakov,
Polynomial conjunctive
In

and Michael Zakharyaschev.
query rewriting under unary inclusion dependencies.
RR, 2011.

[Lenzerini, 2002] Maurizio Lenzerini. Data integration: A
theoretical perspective. In PODS, pages 233–246, 2002.

[Lutz et al., 2013] Carsten Lutz, Inanc¸ Seylan, and Frank
Wolter. Ontology-based data access with closed predicates
In IJCAI, pages
is inherently intractable (sometimes).
1024–1030, 2013.

[Lutz et al., 2015] Carsten Lutz, Inanc¸ Seylan, and Frank
Wolter. Ontology-mediated queries with closed predicates.
In IJCAI, pages 3120–3126, 2015.

[Papadimitriou, 1994] Christos H. Papadimitriou. Computa-

tional complexity. Addison-Wesley, 1994.

[Sagiv and Yannakakis, 1980] Yehoshua Sagiv and Mihalis
Yannakakis. Equivalences among relational expressions
with the union and difference operators. J. ACM, 27(4),
1980.

[Studer and Werner, 2014] Thomas Studer and Johannes
Werner. Censors for Boolean Description Logic. Trans.
on Data Privacy, 7(3):223–252, 2014.

A Detailed Proofs from Section 3: Upper

Bounds for Disclosure

A.1 Proof of Theorem 2: Correctness of the Basic
Reduction from Disclosure to Classical
Entailment

Recall the statement of Theorem 2, which applies the algo-
rithms CritRewrite(ΣSource) to TGDs and CritRewrite(M) to
mappings.

Disclose(ΣSource, M, p) holds exactly when there is a
) entails

pAnnot ∈ CritRewrite(p) such that HideM(DG(M)
pAnnot w.r.t. constraints:

Crit

CritRewrite(ΣSource) ∪ CritRewrite(M) ∪ IsCrit(M)

holds.

By Theorem 1 we know that Disclose(ΣSource, M, p)
∪

HOCWQ(DG(M)

, ΣSource

to

Crit

equivalent

is
ΣM(M), p, G(M)).

Crit

Crit

Crit

This will immediately allow us to prove one direction
of the equivalence. Suppose each of our entailments fails.
From this, we see using [Sagiv and Yannakakis, 1980] that
HideM(DG(M)
) does not entail the disjunction of pAnnot.
Thus we have an instance D extending HideM(DG(M)
) with
facts that may include the IsCrit predicate, where D satis-
ﬁes all the rewritten constraints and no rewritten query pAnnot.
Note that since D satisﬁes the constraints of CritRewrite(M)
as well as IsCrit(M), we know that the element cCrit, if it
occurs in HideM(DG(M)

), will be labeled with IsCrit.

Form an instance D(cid:48) by unifying all elements e in D sat-
isfying IsCrit into a single element cCrit, making cCrit inherit
any fact that such an e participates in. That is, we choose
D(cid:48) so that if h is the mapping taking any element satisfying
IsCrit to cCrit and ﬁxing every other element, then h is a ho-
momorphism from D onto D(cid:48). We can easily verify that D(cid:48)
satisﬁes the original source constraints ΣSource. For each ho-
momorphism λ(cid:48) of the body of σ(cid:48) ∈ ΣSource into D(cid:48), there
is a homomorphism λ of some σ ∈ CritRewrite(σ(cid:48)) into D.
We know σ is satisﬁed in D, and taking the h-image of the
tuples that witness this gives us the required witnesses for σ(cid:48)
0 be the restriction of D(cid:48) to the source re-
in D(cid:48). Now let D(cid:48)
lations. We argue that the mapping image of D(cid:48)
0 under M
is exactly DG(M)
. To see that the image of D(cid:48)
0 must in-
Crit
clude all the facts in DG(M)
, note that D includes all facts
of HideM(DG(M)
), which contains witnesses for each such
fact. Thus the h-image, namely D(cid:48), contains witnesses for
each such fact as well. Conversely, suppose the image of D(cid:48)
0
includes a fact F ( (cid:126)d); we will argue that F ( (cid:126)d) is in DG(M)
.
Since D satisﬁed IsCrit(M), any such fact in D must have all
di satisfying IsCrit. Thus in D(cid:48)
0 each such fact must be of the
form F (cCrit . . . cCrit). Thus the M-image of D(cid:48)
0 is exactly
the same DG(M)

Finally, we claim that D(cid:48) satisﬁes ¬p. If it satisﬁes p, then
D would satisfy pAnnot for some annotation Annot, a contra-
diction. Putting this all together, we see that D(cid:48) contradicts
HOCWQ(DCrit, ΣSource ∪ ΣM(M), p, G(M)).

Crit

Crit

Crit

Crit

.

Before turning to the other direction, we will explain some
other results that will be necessary. The ﬁrst is the chase pro-
cedure for checking entailment of a query Q from a set of
constraints Σ and a set of facts D. This proceeds by building
a sequence of instances D = D0 . . . Di . . . where each Di+1
is formed from Di by “ﬁring a rule” σ ∈ Σ Di. Firing σ
in Di means ﬁnding a homomorphism λ from the body of σ
into Di, and adding facts to extend λ to the head, using fresh
values for all existentially quantiﬁed variables. Such a homo-
morphism λ is called a trigger for the rule ﬁring. The chase
of D under Σ, denoted ChaseΣ(D), is any instance formed as
the union of such a sequence having the additional property
that every rule that could ﬁre in some Di ﬁres in some later
Dj. The signiﬁcance of the chase for query entailment is the
following result [Fagin et al., 2005]:
Theorem 9. For an instance D, set of TGDs Σ, and UCQ Q,
we have QEntail(D, Σ, Q) if and only if some chase model
for D under Σ satisﬁes Q.

Crit

Crit

Crit

al.,

We will also need a variation of the chase for the prob-
lem HOCWQ(DG(M)
, ΣSource ∪ ΣM(M), p, G(M)), taken
from [Benedikt et al., 2016]. The visible chase is a se-
quence of source instances D0 . . . Dn . . . that begins with
D0 = HideM(DG(M)
). Di+1 is formed from Di by “chasing
and merging”. The chase step applies the usual chase proce-
dure described above to Di with constraints ΣSource, creating
new facts that possibly contain fresh values. In a merge step,
we take a mapping m ∈ M and a homomorphism λ of the
body of m into Di, and for each free variable x of m, we re-
place λ(x) by cCrit in all facts in which it appears. We say
that this is a merge step with m, λ on Di. Since the process is
monotone, it must reach a ﬁxpoint, which we refer to as the
visible chase of DG(M)
Proposition
HOCWQ(DG(M)
exactly when VisChase(ΣSource, M) satisﬁes p.
We now prove the other direction,

Crit
1.
, ΣSource ∪ ΣM(M), p, G(M))

, denoted VisChase(ΣSource, M).
[Benedikt
et

assuming that
HOCWQ(DG(M)
, ΣSource ∪ ΣM(M), p, G(M)) fails, but
one of the entailments holds. By Theorem 9, this means
that some chase of HideM(DG(M)
) under the constraints
CritRewrite(ΣSource) ∪ CritRewrite(M) ∪ IsCrit(M) satis-
ﬁes pAnnot for some annotation Annot. Let D(cid:48)
n . . .
denote such a chase sequence for HideM(DG(M)
) under
CritRewrite(ΣSource) ∪ CritRewrite(M) ∪ IsCrit(M). We
form another sequence D0 . . . Dn . . ., with D0 = D(cid:48)
0, main-
taining the invariant that there is a homomorphism hi from
i to Di mapping every element satisfying IsCrit to DG(M)
D(cid:48)
.
The inductive step is performed as follows:
a
of
chase
CritRewrite(ΣSource) applied in D(cid:48)
i, having trigger
λ(cid:48), we know that σ(cid:48) = CritRewrite(σ) for some
σ ∈ ΣSource. We can apply the corresponding rule σ
in Di, with a trigger λ that maps a variable x to the
hi-image of λ(cid:48)(x). Thus λ composed with hi is λ.

2016]
holds

step with

0 . . . D(cid:48)

• For

every

rule

σ(cid:48)

Crit

Crit

Crit

Crit

• For every chase step in D(cid:48)

i with a rule of σ(cid:48) ∈
CritRewrite(m) for m ∈ M and a trigger λ, we apply a
merge step in Di with m and λ.

Since some D(cid:48)
n satisﬁes pAnnot, one of the Dn must sat-
isfy pAnnot. Since Dn contains the image of D(cid:48)
n under the
homomorphism hn, and hn maps pAnnot to p, we see that
Dn must satisfy p. But Dn is a subinstance of the visi-
ble chase for our HOCWQ problem. Thus the assumption
that HOCWQ(DG(M)
, ΣSource∪ΣM(M), p, G(M)) fails and
Proposition 1 imply that p cannot hold in Dn, a contradiction.

Crit

A.2 Simplifying Mappings
In this section, we will see that we can simplify mapping to
be projection maps at the cost of moving to a richer class of
source constraints.

Given a problem Disclose(ΣSource, M, p) we consider
Σ(cid:48)
Source and M(cid:48) built in the following way: Σ(cid:48)
Source is com-
posed of ΣSource plus for each mapping φ((cid:126)x, (cid:126)y) → T ((cid:126)x) we
create a predicate Rφ((cid:126)x, (cid:126)y) and we add to Σ(cid:48)
Source the two
constraints φ((cid:126)x, (cid:126)y) → Rφ((cid:126)x, (cid:126)y) and Rφ((cid:126)x, (cid:126)y) → φ((cid:126)x, (cid:126)y).
M(cid:48) is composed of mappings Rφ((cid:126)x, (cid:126)y) → Tφ((cid:126)x).
Proposition 2. We have Disclose(ΣSource, M, p) if and only
if Disclose(Σ(cid:48)

Source, M(cid:48), p).

Proof. To prove the proposition, it is sufﬁcient to prove that
p holds on VisChase(ΣSource, M) if and only if p holds on
VisChase(Σ(cid:48)
Source, M(cid:48)) (see Proposition 1). Let Π(D) be the
instance obtained by removing all the facts Rφ((cid:126)x, (cid:126)y) in D.

We recall that the visible chase works iteratively, at each
step a database Di+1 is created from Di by chasing all facts
then merging some values with cCrit. For the sake of simplic-
ity we suppose that each step is composed of either one rule
ﬁring or one merging.

• We start by proving that Disclose(ΣSource, M, p) implies

a

sequence

Source, M(cid:48), p).
be

Disclose(Σ(cid:48)
Let D0, . . .
corresponding
VisChase(ΣSource, M). We build a sequence D(cid:48)
corresponding to VisChase(Σ(cid:48)
to build D(cid:48)
exists j such that Di = Π(D(cid:48)
x = cCrit.
We prove by induction:

to
0, . . .
Source, M(cid:48)). We are trying
0, . . . such that there exists for all i there
j), and h(x) = cCrit implies

– D0 is composed of witnesses of M and D(cid:48)

0 of wit-
j such that each
i is obtained by ﬁring the i-th rule Rφ((cid:126)x, (cid:126)y) →

nesses of M(cid:48). We build D(cid:48)
D(cid:48)
φ((cid:126)x, (cid:126)y).

1, . . . , D(cid:48)

– Let us suppose that Di = Π(D(cid:48)

j) and Di+1 is
obtained by ﬁring a rule σ; σ could have been
j and thus we can build D(cid:48)
ﬁred on D(cid:48)
j+1 such that
Di+1 = Π(D(cid:48)

j+1).

– When Di+1 is obtained by merging values then it
means that we have φ((cid:126)x, (cid:126)y) holding in Di and thus
φ((cid:126)x, (cid:126)y) holding in Π(D(cid:48)
j) therefore we could use
the rule φ((cid:126)x, (cid:126)y) → Rφ((cid:126)x, (cid:126)y) followed by an uniﬁ-
cation on Rφ. Therefore we can build D(cid:48)
j ∪
{Rφ((cid:126)x, (cid:126)y)} and D(cid:48)
j+2 such that Di+1 = Π(Dj+2).
Source, M(cid:48), p)
the direction Disclose(Σ(cid:48)
implies
Disclose(ΣSource, M, p) we start by noticing that, with-
out loss of generality, we can suppose that the sequence

j+1 = D(cid:48)

• For

0, . . . of VisChase(Σ(cid:48)

D(cid:48)
Source, M(cid:48)) starts by ﬁring each
rule Rφ((cid:126)x, (cid:126)y) → φ((cid:126)x, (cid:126)y) (it is always possible to gener-
ate more facts) and then we create D0, . . . such that for
all i big enough there exists j such that Dj = h(Π(D(cid:48)
i))

– When Dj = h(Π(D(cid:48)

– Once all rules Rφ((cid:126)x, (cid:126)y) → φ((cid:126)x, (cid:126)y) have been ﬁred,
we see that we obtain an instance isomorphic to D0.
i+1 is obtained
through a merge step, it means that we had D(cid:48)
i |=
Rφ((cid:126)x, (cid:126)y) but we easily see by induction that this
means that we had Dj |= h(φ((cid:126)x, (cid:126)y)) and thus that
we can also perform the merge step on Dj

i)) and D(cid:48)

– When D(cid:48)

i+1 is obtained through a rule, it is either
a rule in ΣSource that we can reproduce in Dj or it
is a rule φ((cid:126)x, (cid:126)y) → Rφ((cid:126)x, (cid:126)y). In this latter case,
we don’t have anything to do as Rφ((cid:126)x, (cid:126)y) will be
discarded by Π.

Now, we also see that j will grow as i grows since except
for rules φ((cid:126)x, (cid:126)y) → Rφ((cid:126)x, (cid:126)y), our j increases. Therefore
Source, M(cid:48)) |= p
at the limit we have that VisChase(Σ(cid:48)
implies VisChase(ΣSource, M) |= p.

Corollary 4. DiscloseC(GTGD, GuardedMap) reduces to
DiscloseC(GTGD, ProjMap).

A.3 More Details for the Proof of Corollary 2

We recall the statement of Corollary 2:

If we ﬁx the maximal arity of relations in the schema, then

DiscloseC(GTGD, GuardedMap) is in EXPTIME.

We now ﬁll in the details of the proof sketch in the body.

Reducing to ProjMap. Using Corollary 4, we can reduce
the problem to DiscloseC(GTGD, ProjMap). We now show
that this latter problem is in EXPTIME.

Reducing to two atoms in the body of TGDs. Given a set
of GTGDs ΣSource and a set of maps M ∈ IncDep we now
reduce Disclose(ΣSource, M, p) to Disclose(Σ(cid:48)
Source, M, p)
where each GTGD in Σ(cid:48)
Source holds at most two conjuncts in
the rule body.

Σ(cid:48)

Source is composed by applying the following process for
each GTGD φ((cid:126)x) → ∃(cid:126)y R((cid:126)t) ∈ ΣSource. The constraint
φ((cid:126)x) → ∃(cid:126)y R((cid:126)t) is guarded, therefore we can select a guard-
ing conjunct Gφ((cid:126)x) such that φ((cid:126)x) = Gφ((cid:126)x) ∧ Q1((cid:126)x) ∧ · · · ∧
Qk((cid:126)x). When k ≤ 1 we simply add φ((cid:126)x) → ∃(cid:126)y R((cid:126)t) to
Σ(cid:48)
Source. When k > 1, we rewrite this constraint by introduc-
ing k predicates R1, . . . , Rk, while producing the following
constraints Gφ((cid:126)x) ∧ Q1((cid:126)x) → R1((cid:126)x) and for 1 ≤ i ≤ k − 1:
Ri((cid:126)x) ∧ Qi+1((cid:126)x) → Ri+1((cid:126)x). Finally we also add Rk((cid:126)x) →
∃(cid:126)y R((cid:126)t). It is easy to see that this new problem is equiva-
lent because each constraint in ΣSource is implied by its corre-
sponding constraints in Σ(cid:48)
Source and if we look at the result of
the visible chase, the only fact derived from a Rk((cid:126)x) are facts
R((cid:126)y) such that φ((cid:126)x).

Rewriting in PTIME. Now that maps are ProjMaps and
each GTGD has at most two atoms in their body, we can apply
the rewriting presented in Theorem 2. Notice that each GTGD
will be rewritten to a bounded number of GTGDs, and the
rewriting of the maps will be trivial. Since query entailment
with GTGDs is EXPTIME when the arity is bounded we can
conclude the proof.

A.4 Proof of Theorem 3: More Efﬁcient Reduction

to Entailment for LTGD Source Constraints
and Atomic Mappings

Recall the statement of Theorem 3, which concerns the appli-
cation of the rewriting algorithms CritRewritePTIME(ΣSource)
for LTGD source constraints ΣSource, and the algorithm
CritRewritePTIME(M) for atomic mappings M:

Disclose(ΣSource, M, p) holds exactly when there is a
) entails

QAnnot ∈ CritRewrite(Q) such that HideM(DG(M)
QAnnot w.r.t. to the constraints
CritRewritePTIME(ΣSource)∪CritRewritePTIME(M)∪IsCrit(M)

Crit

=

Let Σsimple

CritRewritePTIME(ΣSource) ∪
CritRewritePTIME(M) ∪ IsCrit(M) and ΣPTIME be the
constraints posed in Theorem 3. By Theorem 2, it is enough
to show that query entailment involving ΣPTIME is equivalent
to entailment involving Σsimple.

In one direction, suppose that I is a counterexample to
entailment involving Σsimple. We ﬁre the rules generating
atoms Be,f to get instance I (cid:48). We claim that the constraints
of ΣPTIME hold. Clearly, the rules generating atoms Be,f
hold. Further, by construction, for any e, f if Be,f holds ex-
actly when there is an annotation We now consider the rule
Beh,fh ((cid:126)x) → ∃(cid:126)z H((cid:126)z). Considering a (cid:126)c such that Beh,fh ((cid:126)c)
holds, we want to claim that there is an annotation Annot such
that BAnnot((cid:126)c) holds.

Recall that each ei, fi is associated with some variable v
that occurs as both xei and xfi in B((cid:126)x). If Bei,fi((cid:126)c) holds, we
know that either cei = cfi or IsCrit(cei) ∧ IsCrit(cfi ) holds.
If the latter happens, then we add the variable v to our anno-
tation. We can then verify that BAnnot((cid:126)c) holds.

Since we are assuming that the corresponding constraint
of Σsimple holds in I, we can conclude that I (cid:48), (cid:126)c |= ∃(cid:126)z H((cid:126)z).
From this we see that I (cid:48) is a counterexample to the entailment
involving ΣPTIME.

In the other direction, let I (cid:48) be a counterexample to the en-
tailment for the constraints in ΣPTIME. We claim that the con-
straints of Σsimple hold of I (cid:48). For constraints corresponding to
source constraints with no repeated variables in the body, this
is easy to verify, so we concentrate on constraints deriving
from source constraints that do have repeated variables in the
body.

Each of these constraints is of the form BAnnot((cid:126)x) →
∃(cid:126)z H((cid:126)z) for some annotation Annot. Fix a (cid:126)c such that
BAnnot((cid:126)c) holds. We claim that Be,f ((cid:126)c) holds for all (e, f ) ∈
P . We prove this by induction on the position of (e, f ) in
the ordering of pairs in P . Each (e, f ) corresponds to some
variable v that is repeated. If v is in Annot, then BAnnot((cid:126)c)
implies that IsCrit(ce) ∧ IsCrit(cf ) hold. Using the corre-
sponding rule and the induction hypothesis we conclude that

Be,f ((cid:126)c) holds. If v is not in Annot then BAnnot((cid:126)c) implies
that ce = cf . Using the other rule generating Be,f in ΣPTIME,
as well as the induction hypothesis, we conclude that Be,f ((cid:126)c)
holds. This completes the inductive proof that Be,f ((cid:126)c) holds.
Now using the corresponding constraint of ΣPTIME we con-
clude that I (cid:48), (cid:126)c |= ∃(cid:126)z H((cid:126)z). Since the constraints of Σsimple
hold, I (cid:48) is also a counterexample to the entailment involving
Σsimple.

A.5 More details in proof of Theorem 4: upper

bounds for LTGD source constraints and
atomic maps

Recall the statement of Theorem 4

The problem DiscloseC(LTGD, AtomMap) is in EXPTIME.
If the arity of relations in the source schema is bounded, then
the complexity drops to NP. If further the query is atomic,
the problem is in PTIME.

We now give more details on the proof. As mentioned
in the body, is sufﬁcient to get an EXPTIME algorithm for
the entailment problem produced by Theorem 3, since then
we can apply it to each pAnnot in EXPTIME. The con-
straints in CritRewritePTIME(ΣSource) ∪ CritRewritePTIME(M)
are Guarded TGDs that are not necessarily LTGDs. But the
bodies of these guarded TGDs consist of a guard predicate
and atoms over a ﬁxed “side signature”, namely the unary
predicate IsCrit. We can apply now the linearization tech-
nique, originating in [Gottlob et al., 2014] and reﬁned in
[Amarilli and Benedikt, 2018a]. Given a side signature SSide
this is an algorithm that converts an entailment problem in-
volving ta set of non-full IncDeps and Guarded TGDs using
SSide, producing an equivalent entailment problem involving
the same query, but only LTGDs. Further:

• The algorithm runs in EXPTIME in general, and in
PTIME when the arity of the relations in the input is
ﬁxed

• The algorithm does not increase the arity of the sig-
nature, and thus the size of each output LTGD is
polynomially-bounded in the input.

See also Appendix G of [Amarilli and Benedikt, 2018b]
for a longer exposition of the linearization technique. Thus
for general arity, we can use this algorithm to get an en-
tailment problem with the same query, a data set exponen-
tially bounded in the input data I (cid:48) and a set of LTGDs, each
polynomially-sized in the inputs. By applying a standard
ﬁrst-order query-rewriting algorithm to the query, we reduce
this problem to evaluation of a union of conjunctive queries
get a UCQ Q(cid:48) on I (cid:48). The size of each conjunct in Q(cid:48) is
polynomially-bounded in the inputs, and so each conjunct C
can be evaluated in time |I (cid:48)||C(cid:48)|, giving an EXPTIME algo-
rithm in total.

For ﬁxed arity, we apply the same algorithm to get an en-
tailment problem using IncDeps of bounded arity, which is
known [Johnson and Klug, 1984] to be solvable in NP. Fur-
ther, when the query is atomic, entailment with IncDeps is in
PTIME.

A.6 Proof of Theorem 5: Disclosure for UID

Crit

By Theorem 1,

Source Constraints and ProjMap is PTIME
We prove that when the source constraints are UIDs and
the mappings are projections, disclosure analysis is in
it sufﬁces to show that
PTIME.
the
problem HOCWQ(DG(M)
, ΣSource ∪ ΣM(M), p, G(M)) is
PTIME. We will thus ﬁrst reduce this problem a problem
QEntail(D, Σ, p) where Σ is composed of UID constraints
and D is composed of a single unary fact IsCrit(cCrit).
Reachable predicates. We deﬁne the entailment graph
over a set of IncDep constraints Σ. In this graph, nodes cor-
respond to predicates and there is an edge P → R for each
constraint P ((cid:126)x) → R((cid:126)y). Given an initial set of facts D, one
can compute the set Reachable(Σ, D) of entailed predicates.
This set is deﬁned as the set of predicates reachable in the
entailment graph starting from the predicates appearing in D.

Visible position graph.
In studying tuple-generating de-
pendencies, one often associates a set of dependencies with
a graph whose edges represent the ﬂow of data from one re-
lation to another via the dependencies. See, for example the
position graph used in deﬁning the class of weakly acyclic
sets of TGDs [Fagin et al., 2005].

We develop another such graph, the visible position graph
associated with a set of source constraints and mappings. The
nodes are the pairs (P, i) where P is a predicate, 1 ≤ i ≤
ar(P ) and there is an edge (P, i) → (R, j) when we have an
IncDep (either a source constraint or a mapping rule) P ((cid:126)x) →
∃(cid:126)y R((cid:126)t) with xi = tj. We refer to a node in this graph as a
position. A position of a relation in the source schema is said
to be visible if there is a path from (P, i) to a node (R, j) such
that R belongs to the global schema. Another other position
is said to be invisible. We see that when a position (P, i) is
visible then for any fact P ((cid:126)c) that holds in a possible world
for HOCWQ(DG(M)
, ΣSource ∪ ΣM(M), p, G(M)) we must
have ci = cCrit.

Note that if we have P ((cid:126)x) → ∃(cid:126)y R((cid:126)t), xi is exported to tj,
and position j of R is visible, then position i of P is visible
as well.

Crit

Crit
HOCWQ(D0, Σ, p, G(M))

Reduction to entailment. Let Σ = ΣSource ∪ ΣM(M)
and D0 = DG(M)
reduce the prob-
problem
lem
QEntail(D(cid:48)
is
a set of UIDs, and ˜p is a CQ. Our reduction proceeds as
follows:

0, ˜Σ, ˜p), where ˜Σ = Σreach ∪ Σ1 ∪ ΣcCrit

We will

the

to

.

• We transform the schema for sources creating a predi-
cate ˜P for each source predicate P , where the arity of
˜P is the arity of P minus the number of positions (P, i)
that are visible.

0 = {IsCrit(cCrit)}.

• D(cid:48)
• Σreach is built as the set of constraints IsCrit(w) →
∃(cid:126)x P ((cid:126)x) where (cid:126)x are fresh distinct variables and P ∈
Reachable(HideM(DG(M)

), Σ).

Crit

• Σ1 is formed from the set of constraints P ((cid:126)x) →
∃(cid:126)y R((cid:126)t) ∈ Σ such that there is an exported variable ly-

ing in an invisible position of P ((cid:126)x). For each such con-
straint, Σ1 contains the constraint ˜P ((cid:126)x∗) → ∃ (cid:126)y∗ ˜R((cid:126)t∗)
where (cid:126)x∗ denotes the projection of (cid:126)x to the invisible po-
sitions of P , and similarly for (cid:126)y∗ and (cid:126)t∗.

• ΣcCrit is formed from constraints P ((cid:126)x) → ∃(cid:126)y R((cid:126)t) ∈ Σ
such that P ∈ Reachable(HideM(DG(M)
), Σ) and there
is an exported variable x lying in a visible position of
P ((cid:126)x), exported to an invisible position of R. For each
such constraint ΣcCrit includes the constraint IsCrit(x) →
∃(cid:126)y∗ ˜R((cid:126)t∗) where (cid:126)y∗ denotes the projection of (cid:126)y to the
invisible positions of P and similarly for (cid:126)t∗.

Crit

• the query ˜p is built from p by ﬁrst replacing each con-
junct P ((cid:126)x) with its corresponding predicate ˜P (˜(cid:126)x), pro-
jecting out the visible positions. After this, for every
variable x that occurred in p within both a visible and
an invisible position, x is replaced by v, while we add a
conjunct IsCrit(v).

Correctness of the reduction. The correctness of the re-
duction is captured in the following result:
Proposition 3. For any source constraints ΣSource consisting
of IncDeps and M consisting of projection mappings, there
is a disclosure over a schema S with constraints ΣSource map-
0, ˜Σ, ˜p)
pings M and secret query p if and only if QEntail(D(cid:48)
holds.

Proof. We start with the argument for the left to right di-
rection. We let D(cid:48) be a counterexample to the entailment
0, ˜Σ, ˜p). By Theorem 9, we can assume that D(cid:48)
QEntail(D(cid:48)
is formed by applying the chase procedure to D(cid:48)
0. In partic-
ular, each fact in D(cid:48) can be assumed to use a predicate in
Reachable(HideM(DG(M)
), Σ).

We show that there is an instance D that is a counterexam-

Crit

ple to

HOCWQ(DG(M)

Crit

, ΣSource ∪ ΣM(M), p, G(M))

and thus (by Theorem 1) we cannot have a disclosure. We
form D by ﬁlling out each visible position with cCrit. We
claim that D satisﬁes each source constraint σ = P ((cid:126)x) →
∃(cid:126)y R((cid:126)t). Suppose that P ((cid:126)c) holds in D. Then ˜P ((cid:126)c(cid:48)) holds in
D(cid:48), where (cid:126)c(cid:48) projects (cid:126)c on to the invisible positions.

• First, suppose there is a variable x in an invisible posi-
tion of P ((cid:126)x) exported to an invisible position in R((cid:126)t).
Then since D(cid:48) satisﬁes Σ1, we know that for some (cid:126)d,
˜R((cid:126)d) holds in D(cid:48), By the deﬁnition of D, we have that
R((cid:126)d∗) holds, where (cid:126)d∗ ﬁlls out each visible position with
cCrit. We can see that R( (cid:126)d∗) is the required witness for
P ((cid:126)c).

• Next, suppose there is a variable x in a visible po-
sition j of P ((cid:126)x) exported to an invisible position in
R((cid:126)t). Then we must have cj = cCrit. Since P is in
Reachable(HideM(DG(M)
), Σ) and D(cid:48) satisﬁes ΣcCrit,
we have ˜R((cid:126)e) holding in D(cid:48) for some (cid:126)e, and hence R( (cid:126)f )
holding in D for some tuple where cCrit ﬁlls all the visi-
ble positions. Thus σ holds in this case as well.

Crit

• Finally, note that a variable at an invisible position can-
not be exported to a visible position. Therefore the only
remaining case is the case where no variable has been
exported. Since P is reachable, then R is also reachable
therefore there is a constraints IsCrit(x) → ∃(cid:126)y∗R((cid:126)y∗) ∈
ΣReachable and thus ˜R((cid:126)d∗) holds in D(cid:48)

We next claim that the image of D under M agrees with

.

DG(M)
Crit
• For every global schema predicate G, G(cCrit . . . cCrit)
occurs in the the image of D under M. This follows
easily from the fact that D(cid:48) contains D(cid:48)
0.

• If G((cid:126)c) holds in the M-image, then because each visible
position was ﬁlled out with cCrit, we must have each ci =
cCrit. Thus the result follows.

Note that from the preceding claims, we know that
D is a possible world for HOCWQ(DG(M)
, ΣSource ∪
ΣM(M), p, G(M)). Finally, we claim that D does not sat-
isfy p.

Crit

• Suppose D |= p with homomorphism h as
Since D is a possible world for
a witness.
HOCWQ(D0, Σ, p, G(M)), for any variable v occurring
in a visible position, h(v) = cCrit. Let h(cid:48) be formed from
the restriction of h to variables that occur in ˜p, by map-
ping the additional variable v to cCrit. Note that in D(cid:48),
IsCrit(cCrit) holds. For this, we see that h(cid:48) is a homomor-
phism witnessing that D(cid:48) |= ˜p. This is a contradiction to
the fact that D(cid:48) is a counterexample to the entailment.

We now have argued that D is a counterexample to
HOCWQ(D0, Σ, p, G(M)), which completes the proof of the
left to right direction.

For the other direction, suppose that D is a counterexample
to HOCWQ(D0, Σ, p, G(M)). Note that for any fact R((cid:126)c)
over the source relations in D, for any visible position i of
R, we must have ci = cCrit. Form D(cid:48) by projecting each fact
in D to the invisible positions of the relation. We will argue
that D(cid:48) is a counterexample to the entailment produced by the
reduction.

fact

that

• D should contain IsCrit(cCrit) therefore D(cid:48) extends D(cid:48)
0.
• The
to
solution
HOCWQ(D0, Σ, p, G(M)) also guarantees that
for
all reachable predicates P we have D |= ∃(cid:126)x P ((cid:126)x)
and thus D(cid:48) |= ∃(cid:126)x∗ ˜P ((cid:126)x∗) and thus all constraints in
ΣReachable are satisﬁed.

was

D

a

• Let us show that the constraints in Σ1 are satisﬁed: ﬁx
a constraint σ(cid:48) ∈ Σ1 = ˜P ((cid:126)x∗) → ∃(cid:126)y(cid:48) ˜R(˜(cid:126)t), derived
from source constraint σ = P ((cid:126)x) → ∃(cid:126)y R((cid:126)t). Fix a fact
F (cid:48) = ˜P ((cid:126)c∗) in D(cid:48). By deﬁnition of D(cid:48), (cid:126)c∗ extends to
a (cid:126)c satisfying P in D. Thus, since D |= Σ, there is a
fact G = R((cid:126)d) that holds in D with di = cj whenever
ti = xj. We can project to the invisible positions to get
a fact G(cid:48) = ˜R(dj1 . . . djn ) in D(cid:48). We claim that G(cid:48) is
a witness for the satisfaction of σ(cid:48) with respect to F (cid:48).
Consider any variable x exported from F (cid:48) to position j(cid:48)
of G(cid:48) where x is mapped to value c in (cid:126)c∗. Then in σ, x

was exported to the corresponding invisible position j in
R((cid:126)y), and from this we see that dj = c as required.
• Now consider a constraint σ(cid:48) ∈ ΣcCrit = IsCrit(x) →
˜(cid:126) ∗
∃(cid:126)y∗ ˜R(
t). Since IsCrit(x) holds only for x = cCrit in
D, we only have to verify that ˜R((cid:126)e∗) holds for some
(cid:126)e such that e(cid:96) = cCrit (where (cid:96) is the position of x in
(cid:126)y∗). Let us suppose that σ(cid:48) was derived from source
constraint σ = P ((cid:126)x) → ∃(cid:126)y R((cid:126)t) where j is the position
of the exported in (cid:126)y and i is the position of the exported
variable in (cid:126)t. By the deﬁnition of ΣcCrit, we know that P
is a reachable predicate, and hence P ((cid:126)d) must hold for
some (cid:126)d in D and since dj is visible we have dj = cCrit.
Because D |= σ we have ˜R((cid:126)e) holds in D for some
(cid:126)e such that ei = cCrit and thus R((cid:126)e∗) is the required
witness for σ(cid:48).

• Finally, we argue that D(cid:48) does not satisfy ˜p. Suppose
by way of contradiction that D(cid:48) satisﬁes ˜p via homo-
morphism h(cid:48). Note that the variables of p that do not
occur in ˜p are those that occur only in visible posi-
tions within an atom of p. We extend h(cid:48) to a map-
ping h from the variables of p to D by mapping each
such variable x to cCrit. We argue that h is a homo-
morphism of p to D. Consider an atom R((cid:126)t, (cid:126)t(cid:48)) of p,
where (cid:126)t correspond to the invisible positions. Suppose
ﬁrst that the corresponding atom of ˜p is of the form
˜R((cid:126)t∗) where (cid:126)t∗ is obtained from (cid:126)t by replacing any vari-
able shared with a visible position by v. We know that
˜R(h(t∗
j )) holds in D(cid:48) because h is a homomor-
1) . . . h(t∗
phism. Thus R(h(t∗
j ), (cid:126)e) holds in D for some
(cid:126)e. By the properties of visible positions and the fact that
D is a possible world for HOCWQ(D0, Σ, p, G(M)),
we see that each ei = cCrit. Thus h not only preserves
the atom ˜R((cid:126)t∗), but it also preserves the additional atom
IsCrit(v), since IsCrit(cCrit) holds in D(cid:48). thus h is a ho-
momorphism, contradicting the fact that D is a coun-
terexample to HOCWQ(D0, Σ, p, G(M)).

1), . . . h(t∗

Since D(cid:48) extends D0, satisﬁes the constraints ˜Σ, and does
not satisfy the query ˜p, it is a counterexample to the entail-
ment, completing this direction of the argument.

Overview of PTIME algorithm for entailment with UIDs
over a single fact. At this point we have restricted to a CQ
entailment problem for a set of UIDs and a single fact. It was
claimed in [Kikot et al., 2011] that there is a polynomial time
query rewriting for UIDs, and from this it would easily follow
that our entailment problem is in PTIME (query evaluation is
PTIME when these is a single fact). However later work (foot-
note on page 38 of [Bienvenu et al., 2018]) refers to ﬂaws in
this argument, and says that polynomial rewritability is open.
We therefore give a direct proof that such an entailment prob-
lems are in PTIME. This will proceed via several steps:

• A reduction to the case of “binary schemas”:
where the arity of each predicate is at most 2.

those

• Query simpliﬁcation, which will reduce the query to a

connected acyclic query.

• Reduction to atomic entailment.

Reduction to binary schemas. We begin by using verba-
tim an idea of [Kikot et al., 2011], reducing to the same prob-
lem but when the input schema is binary. We do this via a
standard reduction of general arity reasoning to binary rea-
soning, introducing predicates Ri(t, v) for every relation R
of arity n ≥ 1 and each 1 ≤ i ≤ n; informally these state
that v is the value in position i of n-tuple t. We also intro-
duce a predicate R∃(t) for each predicate R; informally this
states that there is some tuple t in the predicate R. We trans-
late each UID B((cid:126)x) → ∃(cid:126)y H((cid:126)t) exporting a variable xi from
position i to position j to a UID Bi(t, xi) → ∃t(cid:48) Hj(t(cid:48), xi).
For each UID, H((cid:126)x) → B((cid:126)y) that is not exporting a vari-
able, we create a rule H∃(t) → ∃t(cid:48) B∃(t(cid:48)). We also cre-
ate rules Ri(t, x) → R∃(t) and R∃(t) → ∃x Ri(t, x) for
each predicate R and 1 ≤ i ≤ n where n is the arity of
R. Finally the query p is transformed into p(cid:48) where each
conjunct R(x1, . . . , xn) is transformed into the conjunction
R1(t, x1) ∧ · · · ∧ Rn(t, xn) ∧ R∃(t), for a fresh variable t.
Finally the database over the binary schema is built in the fol-
lowing way: for each fact R((cid:126)v) of the initial database, we
create a fresh value t and we add the conjunct Ri(t, x) for
1 ≤ i ≤ n where n is the arity of R and we also add R∃(t).
Further details can be found in [Kikot et al., 2011]. Note that,
in the resulting problem, each frontier-0 rule produced has a
body with an atom over a unary predicate.
Proposition 4. The transformation above preserves query
entailment.
Special form of the chase: annotated chase forest.
In the
case of UIDs the chase process applied to our single-fact in-
stance D0 produces an in instance ChaseΣ(D0) that will be
inﬁnite. However, it has a special shape that we can exploit.
For the remainder of this section, by ChaseΣ(D0) we con-
sider an instance formed from a restricted chase sequence, in
which a witness to a TGD φ((cid:126)x) → ∃(cid:126)y H((cid:126)t) is added to in-
stance Di for binding (cid:126)c to (cid:126)x only if D, (cid:126)c |= φ((cid:126)x) ∧ ¬∃(cid:126)y H((cid:126)t).
It is known [Fagin et al., 2005] that in Theorem 9 it sufﬁces to
consider such instances. The annotated chase is a node- and
edge-labelled forest formed from ChaseΣ(D0) as follows:

• the nodes are the values of Chase(D)
• the node label of a value v is the collection of unary

predicates holding at v

• an edge labeled by fact F mentioning v1 and v2 connects
a value v1 to a value v2 if F holds in Chase(D) and v2
is generated in the chase step that produces F .

We can see that this graph is a forest where he roots are cCrit
(the value where IsCrit(cCrit) holds) as well as some other
trees rooted to reachable facts generated from frontier-0 de-
pendencies and thus rooted at elements t where R∃(t) holds
for some R. Further, since the chase is restricted, we can
see that this graph has the unique adjoining label property:
for each v1, for each predicate P , there cannot be two nodes
v2, v(cid:48)
2 adjacent to v1 such that the edge e from v1 to v2 and
e(cid:48) from v1 to v2 both are labelled with the same predicate
and have v1 in the same position. Furthermore, the restricted
chase also ensures that the forest is composed of at most one
tree per predicate since all the roots that are produced needs
to be different.

First query simpliﬁcation:
eliminating forking pairs.
Given a CQ Q, a pair of distinct atoms A1 and A2 shar-
ing the same predicate and a variable at the same position
(i.e. q1 = R(x, z) and q2 = R(x, y) or q1 = R(z, x) and
q2 = R(y, x)) is a forking pair of Q. We say that a query Q
is non-forking when there are no forking pairs.
Proposition 5. If a CQ Q has a forking pair A1 = R(x, z)
and A2 = R(x, y) and Q(cid:48)
is the query Q where the
variable z is replaced with y, then QEntail(D0, Σ, Q) =
QEntail(D0, Σ, Q(cid:48))

If p(cid:48) holds in D, then
Proof. Let D = ChaseΣ(D0, Σ).
clearly the same holds of p. Conversely suppose p holds in D
via homomorphism h, and suppose h(y) (cid:54)= h(z). This gives
us a violation of the unique adjoining label property.

Applying the proposition above, we can assume that Q is
non-forking. Without loss of generality, we can also assume
that Q is connected (otherwise we can test the entailment of
each connected part).

Second simpliﬁcation: reducing to acyclic queries The
CQ-graph. of a CQ Q is the node- and edge-labelled graph
whose nodes are the variables of Q and whose edges are la-
belled with atoms of Q such that:

• an edge between variables labelled with x and y is la-
belled with the binary atoms containing both x and y;

• a node x is labelled with the set of unary predicates in Q

containing x.

The CQ-graph said embedded in some annotated chase
forest T if there is a homomorphism h : A → T pre-
if there is an edge x to y labeled with
serving edges, i.e.
R(a, b) then T should contain an A(x) to A(y) labeled with
R(A(a), A(b)) and nodes, i.e. if there is a predicate P (x) on
the node x then there should be P (A(x)) in T . The homo-
morphism h is called an embedding of Q in T .

It is immediate from the completeness of the chase proce-
dure that for any annotated chase forest T for ChaseΣ(D), a
query is entailed if and only if its CQ-graph is embedded in
T . Our reduction to the case of a CQ with acyclic CQ-graph
will depend heavily on the following observation:

Proposition 6. Any embedding of a connected and non-
forking CQ Q into an annotated chase forest for ChaseΣ(D0)
must be injective.

Proof. Let Q be a connected and non-forking and let h be an
embedding. Let us prove by induction on the size of the path
between x and y that h(x) (cid:54)= h(y) when x (cid:54)= y.

Two neighboring nodes cannot be sent to the same value.
For a path of size 2, if we have z such that x, z, y forms a path
in the CQ-graph of Q then h(x) has to be different than h(y)
otherwise the label from x to z and from z to y would be the
same and there would be a forking pair in Q.

Let x = p1, p2, . . . , pk = y with k ≥ 4 be a path in the CQ-
graph between x and y. By induction the h(pi) for i < k are
all distinct and thus the distance between h(x) and h(pk−1)
is at least k − 2 hence h(y) is at least at distance k − 3 > 0
of h(x).

Proof. We ﬁrst check whether A is a root-generating atom,
using a PTIME inference algorithm for UIDs [Cosmadakis et
al., 1990]. We then consider each child y of x in the tree
arrangement. We know that there is exactly one conjunct B
containing x and y. We check whether A entails ∃y B, and
then call the algorithm recursively for y and B. If each recur-
sive call succeeds, the algorithm succeeds.

From the prior proposition we get a PTIME algorithm for

the arrangement as a whole:
Proposition 9. There is a PTIME algorithm taking a tree
arrangement of CQ Q, and an atom A containing the root
of the arrangement, and determines whether the whole tree
arrangement can be faithfully entailed and A is a root-
generating atom.

Proof. We ﬁrst need to check that A is entailed, which
amounts to checking that Σ |= IsCrit(c) → ∃y A. As be-
fore this can be done using [Cosmadakis et al., 1990]. We
then utilize the algorithm of Proposition 8.

Note that Proposition 9 gives a polynomial time algorithm
for checking whether a tree arrangement can be faithfully en-
tailed. We can apply the algorithm of the proposition with
every possible unary and binary atom A containing the root
variable. In the binary case, we consider all atoms containing
the root variable and an additional fresh variable.
Putting it all together. Putting together our reduction to
UID-entailment (Proposition 3), our schema simpliﬁcation
(Proposition 4) the query simpliﬁcations (the reduction to
connected CQs, Proposition 5, and Corollary 5), and our
PTIME algorithm for simpliﬁed queries (Proposition 9) we
obtain the proof of Theorem 5.

Our reduction to the acyclic case follows immediately:

Corollary 5. If a connected non-forking CQ Q is entailed by
Σ over then the CQ-graph of Q is acyclic.

Proof. Q is entailed The image of the CQ-graph through the
injective homomorphism is a forest.

Determining entailment for acyclic connected graphs.
We now give the ﬁnal setp in our algorithm, which deals with
deciding entailment of a connected, non-forking query Q,
which by Corollary 5 must have an acyclic CQ-graph. Given
an acyclic connected undirected graph and any vertex v of the
graph, we can direct it be a tree with v as the root. Thus for
such a Q having n variables, the tree arrangements are the n
possible ways to root the CQ-graph of the query Q. We are
particularly interested in arrangements of Q where the direc-
tionality from parent to child reﬂects the entailment structure
relative to Σ between atoms in the query. A tree arrangement
A of Q is faithfully entailed if for every variable y in Q with
parent x in the tree, there is an atom A containing x and not
containing y such that A ∧ Σ entails ∃y Bx,y, where Bx,y is
the conjunction of all atoms whose variables are contained in
{x, y}; in the case that y is the root, we require Σ alone to
entail ∃y Bx,y.

In a faithfully-entailed tree arrangement, the conjunction of
atoms holding at the root of the tree entails the existence of
the whole tree. We can further ﬁnd a single atom that entails
the whole tree. A root-generating atom of a tree arrangement
is an atom A (not necessarily in Q) containing the root vari-
able r, such that A ∧ Σ generates all atoms mentioning r.

Proposition 7. A faithfully entailed tree arrangement for Q
must have a root-generating atom.

Proof. We know that Q must hold in the chase of the initial
fact under Σ, and by Proposition 6 we know that there is an
injective homomorphism h from Q to the chase. Consider
the point in the chase process where value h(r) is ﬁrst gen-
erated. This occurs by ﬁring some rule with an atom, where
the head has either a binary atom A(x, y) or a unary atom
B(x). We consider the case where the atom is binary, and
where the generated atom is A(h(r), s). In this case the fact
A(h(r), s) must generate every fact containing r. Thus we
can take the atom A(r, w), where w is a fresh variable, as a
root-generating atom. The case of unary atoms and the case
where r is in the second position of the fact is similar.

Given a tree arrangement T of Q and variable x of Q, Tx
denotes the the restriction of T to the variables that are de-
scendants of x in T .

The main idea of our PTIME algorithm is that it sufﬁces to
descend through the tree arrangement, checking some entail-
ments for each parent-child pair in isolation.

Proposition 8. There is a PTIME algorithm taking as input
a variable x in a CQ Q, a tree arrangement of Q, and an
atom A containing x such that the existential quantiﬁcation
of A is entailed by Σ, and determining whether Tx is faithfully
entailed and A is a root-generating atom.

B Detailed Proofs from Section 4: Lower

Bounds for Disclosure

B.1 Proof of the ﬁrst part: Theorem 6:

2EXPTIME-hardness for IncDep and
GuardedMap without arity bound

Recall the ﬁrst part of Theorem 6:

DiscloseC(IncDep, GuardedMap) is 2EXPTIME-hard.

Recall that Theorem 1 relates disclosure to a HOCWQ
problem on a very simple instance. Also recall from Sec-
tion 3 the intuition that such a problem amounts to a classi-
cal entailment problem for a CQ over a very simple instance,
using the source dependencies and SCEQrules: of the form
φ((cid:126)x) → x = cCrit, where φ will be the body of a map-
ping. We show here how to simulate the run of an alternat-
ing EXPSPACE Turing machine T without explicitly using
SCEQrules, instead using inclusion dependencies as source
constraints coupled with guarded mappings. An alternating
Turing machine T is a 6-tuple (Q, Σ, δα, δβ, q0, g) where:

• Q is the ﬁnite set of states
• Σ is the ﬁnite tape alphabet
• δα and δβ are functions from Q × Σ to Q × Σ × {L, R}
• q0 ∈ Q is the initial state
• g is a function from Q to {accept, reject, ∀, ∃} that

speciﬁes the type of each state.

We assume that T always alternates between existential and
universal states, and that there is a unique ﬁnal state, that can
be reached only if the head is in the ﬁrst cell and contains a
speciﬁc symbol. All of these assumptions can be made with-
out loss of generality. If T is in a conﬁguration where whose
state q is such that g(q) = accept, the conﬁguration is said
to be accepting. If T is in a conﬁguration where whose state
q is such that g(q) = ∀, the conﬁguration is said to be ac-
cepting if its α and β successors (obtained after applying δα
or δβ) are accepting. If T is in a conﬁguration whose state
q is such that g(q) = ∃, the conﬁguration is said to be ac-
cepting if its α-successor or its β-successor is accepting. A
more thorough introduction to Turing machines can be found
in [Papadimitriou, 1994].

We ﬁrst present the reduction, and show its correctness in

the next subsection.

B.2 The Reduction
We will create constraints and mappings that will serve to
perform the following tasks:

• generate addresses for cells of T in such a way that one
can check whether two addresses are consecutive in a
guarded way. The same addresses will be used for all the
conﬁgurations. This will be done by a mapping creating
k copies of two individuals that represent 0 and 1, along
with inclusion dependencies that perform permutations
and generate 2k addresses;

• encode the content of a cell, the position of the head,
and the state of the head: for each cell, we store a vector
whose length is the size of (Σ ∪ {(cid:91)}) × (Q ∪ ⊥). Each

position corresponds to an element (l, s) of that set; we
will arrange that the position contains cCrit if and only if
the cell contains l, and either the head is over that cell
and is in state s, or the head is not over that cell and
s = (cid:91). All values are ﬁrst freshly instantiated by inclu-
sion dependencies, and mappings are then responsible
for unifying the correct positions with cCrit;

• ensure that the tape that is associated with a successor
of a conﬁguration can be obtained by a transition of the
Turing machine: this is also performed by using a map-
ping to enforce the correct positions of the cell to be uni-
ﬁed with cCrit;

• check that conﬁgurations are accepting: this is the case
either when the corresponding tape is in a ﬁnal accept-
ing state, or when it is in an existential state and one of
the two successor conﬁgurations is accepting, or it is in
a universal state, and both successor conﬁgurations are
accepting.

Let us describe the source signature. For each predicate,
we will explain what feature of the ATM T it should repre-
sent in the appropriate instance generated by the constraints.
By “the appropriate instance”, we mean the visible chase of
the initial instance over the source constraints and mappings:
this was introduced after Theorem 9, and it was noted that it
is the canonical instance for the source and targets to consider
for disclosure.

We use y1,k to represent a tuple (y1, . . . , yk), and yk to

represent the tuple (y, . . . , y) of size k.

0 , y1,k

• Children∀(c, cα, cβ, ac, acα, acβ, y1,k

1 , r, z, y0, y1).
The intended meaning is that a conﬁguration c is uni-
versal and has as children cα and cβ, and that the
acceptance bit of c is ac, of cα is acα and of cβ is acβ.
The last four positions are placeholders: r for the root
of the tree of conﬁgurations, z for cCrit, y0 for a value
representing 0 and y1 for a value representing 1.

• Children∃(c, cα, cβ, ac, acα, acβ, y1,k

0 , y1,k

1 , r, z, y0, y1):

same intended meaning, except that c is existential.
• Cell(cp, cn, y1,k, v, vprev, vnext, r, z, y0, y1) with in-
tended meaning that the cell of address y1,k of the tape
represented by cn has a content represented by v, while
the previous cell has a content represented by vprev and
the next cell has content represented by vnext. The last
four positions are placeholders for the root of the tree of
conﬁgurations, cCrit, a value representing 0 and a value
representing 1.

• Cellc

i (c, y1,k, x, z, y0, y1) with intended meaning that
the cell of address y1,k in conﬁguration c contains x at
the ith position of the representation of its content. Cellp
i
and Celln
i play similar roles for the cell before and after
the cell of address y1,k.

• GenAddr is an auxiliary predicate used to generated an

exponential number of addresses.

• succα(cp, cn) states that cn is the α-successor of cp (and

similarly for β)

y0 y0 v00v00

prev v00

next

y0 y1 v01 v01

prev v01

next

y1 y0 v10 v10

prev v10

next

prev v11

next

y1 y1 v11 v11
(cid:124) (cid:123)(cid:122)(cid:125)
address

Cell

Cell

Cell

Cell

c

ac

y0

y0

y1

y1
Children∀

β acβ

α acα

y0

y0

y1

αα acαα

Children∃

y1
αβ acαβ

Below we will always use the symbol Q to range over

n. We create a mapping T∀(x) with deﬁnition:

Figure 1: The generated structure

{∀, ∃}.

The structure generated by the inclusion dependencies is
represented Figure 1. Atoms are represented by geometric
shapes in the inside of which are arguments (some are omit-
ted to ease the reading). The ChildrenQ atoms form a tree
shaped structure, and induce a tree structure on the conﬁgu-
ration identiﬁers: for instance, c is the parent of α and β. Cell
atoms are associated with a conﬁguration identiﬁer (for in-
stance, those represented are associated with β), and has the
parent conﬁguration identiﬁer to ensure guardedness of the
mappings used in the following reduction. Note that the el-
ements used to describe the cell’s addresses (y0 and y1) also
appear in the ChildrenQ atoms, to ensure guardedness.
Initialization. We ﬁrst deﬁne a mapping TInit(x), introduc-
ing some elements in the visible chase. The deﬁnition of this
mapping is:

Children∃(croot,cα, cβ, acroot, acα, acβ,
0 , y1,k
y1,k
1 , croot, x, y0
Generation of the tree of conﬁguration. α-successors
have themselves α- and β-successors, and are existential if
their parent is universal:

0, y0
1)

0 , y1,k

1 , r, z, y0, y1)

Children∀(c, α, β, ac, acα, acβ, y1,k
→ ∃αα, αβ, acαα , acαβ
Children∃(α, αα, αβ, acα, acαα , acαβ , y1,k
And similarly for Children∃ and for the β-successor.
Universal and existential acceptance condition.
If both
successors of a universal conﬁguration n are accepting, so is

0 , y1,k

1 , r, z, y0, y1)

Children∀(c, α, β, x, z, z, yk

0, yk

1, r, z, y0, y1)

If the α-successor of an existential conﬁguration n is ac-
cepting, so is n. We create a mapping T∃,α(x) with deﬁni-
tion:

Children∃(c, α, β, x, z, acβ, yk

0, yk

1, r, z, y0, y1)

We create a similar mapping T∃,β for the β-successor.

Tape representation and consistency of tapes. We now
focus on the representation of the tape and its consistency.
We generate 2k addresses and associated values:

ChildrenQ(c, α, β, ac, acα, acβ, y1,k
→ GenAddr(c, α, y1,k

0 , y1,k
1 , r, z, y0, y1)

0 , y1,k

1 , r, z, y0, y1)

ChildrenQ(c, α, β, y1,k
→ GenAddr(c, β, y1,k

0 , y1,k
0 , y1,k

1 , r, z, y0, y1)
1 , r, z, y0, y1)

GenAddr will generate addresses to represent the tape as-
sociated with its ﬁfth argument. To emphasize this, we use the
letter n (as node) at this position, while the fourth argument
contains its parent conﬁguration, denoted by p.

GenAddr(cp, cn, a1, . . . , ai, . . . , ak+i, . . . , a2k, r, z, y0, y1)
→ GenAddr(cp, cn, a1, . . . , ak+i, . . . , ai, . . . , a2k, r, z, y0, y1)

For each address, we initialize its content (as well as
the content of the previous and next cells) by fresh values
v, vprev, vnext.

GenAddr(cp, cn, a1, . . . , a2k, z, y0, y1) → ∃v, vprev, vnext
Cell(cp, cn, a1, . . . , ak, v, vprev, vnext, r, z, y0, y1)

Note that the values v, vprev and vnext are vectors of length
the size of (Σ ∪ {(cid:91)}) × (Q ∪ ⊥). In particular, we use the
notation li(x) to represent a vector of same length, composed
of fresh variables, except for the position i, that contains x.

We now use mappings to force some of these values to be
equal to cCrit. Each position of v represents an element of
(Σ ∪ {(cid:91)}) × (Q ∪ ⊥), and we will enforce exactly one of these
positions to contain cCrit. If the head of the Turing machine is
on the cell represented, then the position of v corresponding
to (a, q) where a is the letter in the cell and q the state of the
Turing machine, will contain cCrit. Otherwise, the position of
v corresponding to (a, ⊥) will contain cCrit.

As we store the content of a cell in several atoms, we must
ensure that the tape associated with a conﬁguration is con-
sistent, by checking that vnext is consistent with v from the
next cell. To ensure guardedness, we ﬁrst introduce auxiliary
predicates Cellc
i that deﬁne the content of the
ith bit of the value of the current, previous and next cells:

i and Celln

i , Cellp

Cell(cp, cn, y1,k, li(x), v(cid:48)
→ Cellc

i (cn, y1,k, x)

prev, v(cid:48)

nxt, r, z, y0, y1)

We now introduce the deﬁnition of a mapping Tdatan(x)
which ensures the consistency of the tape content (note that
the ﬁrst atom is a guard):

Cell(cp, cn, yb1, . . . , ybj , y0, y1, v, vprev, li(x), r, z, y0, y1)
∧ Cellc

i (cn, yb1 , . . . , ybj , y1, y0, z)

Tdatap (x) is deﬁned similarly to deal with the previous cell.
We enforce the tape of the initial conﬁguration to have
the head of the Turing machine on the ﬁrst cell (and assume
w.l.o.g that this is represented by the ﬁrst position of v con-
taining cCrit) and all the other cells containing (cid:91) (and we as-
sume w.l.o.g that this is represented by the second position of
v containing cCrit). We thus create the mappings Ttapei(x),
for the the ﬁrst cell, having deﬁnition:

Cell(cp, cn, y0, l1(x), vprev, vnext, cp, z, y0, y1)

and we introduce the mappings Ttapeo(x), for all the other

cells, having deﬁnition:

Cell(cp, cn, . . . , y1, . . . , an, l2(x), vprev, vnext, cp, z, y0, y1)

Note that this data is associated with the children of the
root (as p is both in the fourth and last minus three positions
of the atoms), and not with the root itself, due to the choice of
keeping in Cell the identiﬁer of the parent of the considered
conﬁguration.

We then check that the tape associated with the α-successor
of a conﬁguration is indeed obtained by applying an α-
transition. This is done by noticing that the value of each cell
of the α-successor is deterministically deﬁned by the value of
the cell and its two neighbors in the original conﬁguration (the

neighbors are necessary to know whether the head of the Tur-
ing machine is now in the considered cell). To ensure guard-
edness, we ﬁrst deﬁne a predicate marking α-successors (and
similarly for β-successors):

0, yk

1, croot, z, y0, y1)

ChildrenQ(c, α, β, z, acα, acβ, yk
→ succα(c, α)
Let us consider a cell of address b1,k in cp. We assume
that its content is represented by i, while the content of its
left (resp. right) neighbor is represented by j (resp. k). We
represent the fact that this implies that the content of the cell
of address b1,k is w in the α-successor of cp by the following
mapping T α

i,j,k→w(x):

Cell(cp, cn, b1,k, lw(x), vprev, vnext, r, z, y0, y1)
∧ Cellc
∧ Cellp
∧ Celln
∧ succα(cp, cn)

i (cp, b1,k, z)
j (cp, b1,k, z)
k (cp, b1,k, z)

Note that the above formulation requires the content of the
previous and of the next cells, which makes this mappings
not applicable when b1,k is the address of either the ﬁrst or
the last cell. We thus add rules to speciﬁcally deal with these
two cases (that looks at the content of the current and next
cell when b1,k is a vector of y0, and at the content of cur-
rent and previous cell when b1,k is a vector of y1). Note that
there is only polynomially such mappings to be built. And we
ﬁnally create a mapping Taccept(x) enforcing that conﬁgura-
tions whose tape is in an accepting state (which we assume
w.l.o.g. corresponds to the case where the ﬁrst cell contains
the lth bit) are declared as accepting.

l (cn, yk

Cellc
∧ ChildrenQ(cn, α, β, x, acα, acβ, yk

0, z)

0, yk

1, r, z, y0, y1)

The policy query is
Children∃(root, α, β, z, acα, acβ, y1,k
1 , root, z, y0, y1),
We will show that this policy query is disclosed if and only if
the original Turing machine accepts on the empty tape.

0 , y1,k

B.3 Proof of Correctness
We show that the policy is disclosed if and only if T accepts
on the empty tape. By Theorem 1, the policy is disclosed if
and only if the corresponding HOCWQ problem has a posi-
tive answer. Further, this holds if and only if the policy query
holds on the result of the visible chase (introduced after The-
orem 9). We thus focus on showing the equivalence of the
acceptance of the empty tape by T and the satisfaction of the
policy in the visible chase.

Let us start by describing some relationships between the
contains

visible chase of DG(M)
TInit(cCrit), there is in the visible chase the atom

and the run of T . As DG(M)

Crit

Crit

Children∃(croot,cα, cβ, acroot, acα, acβ,
0, yk
yk
0, y0

1, croot, cCrit, y0

1),

where all individuals but cCrit are nulls.

Deﬁnition 1 (Tape Representation). Let T be a tape (with
head position and state included) of T . A representation of
T is a set of atoms

{Cell(cp, cn, a, va, vprev

a, vnext

a, cCrit, y0, y1)}a,

where a ranges over the binary representations of the ad-
dresses of T , and such that for any cell of T the following
holds:

• for any a, v contains fresh nulls except for the bit that
represents the content of T at address a, where it con-
tains cCrit

• for any a except the representation of the leftmost cell,
vprev contains fresh nulls except for the bit that repre-
sents the content of T at address a − 1; in this bit it
contains cCrit (vprev exclusively contains fresh nulls for
the leftmost cell)

• for any a except the representation of the rightmost cell,
vnext contains fresh nulls except for the bit that repre-
sents the content of T at address a + 1; on this bit it
contains cCrit (vnext exclusively contains fresh nulls for
the rightmost cell)

In that case, cn is called a representative of T .
Lemma 1. cα and cβ, as deﬁned above Deﬁnition 1, are rep-
resentatives of the initial tape.

Proof. We show the result for cα, the same reasoning being
applicable to cβ. As the atom

Children∃(croot,cα, cβ, acroot, acα, acβ,
0, y0
0, yk
yk

1, croot, cCrit, y0

1),

belongs to the visible chase, atoms of the shape

Cell(croot, cα, a1, . . . , ak, v, vprev, vnext, croot, z, y0, y1)

for any vector a1, . . . , ak with ai ∈ {y0, y1} for any i, are
generated, where all nulls from v, vprev and vnext are fresh
(thanks to the rules involving GenAddr). As the ﬁrst argument
and the ante-ante-penultimate argument of such an atom are
equal, the deﬁnition of Ttapei(x) maps to the atom of address
y0, . . . , y0, and the body of Ttapeo (x) maps to all the other
atoms. Applying Tdatan and Tdatap then ensures that cα is a
representative for the initial tape, as no other mapping may
merge a term of these atoms.

Lemma 2. If cp is a representative of a tape T and if the
visible chase contains

ChildrenQ(cp, α, β, ac, acα, acβ, yk

0, yk

1, croot, cCrit, y0, y1),

then α (resp. β) is a representative of the tape Tα (resp. Tβ)
obtained by applying the α-transition (resp. β-transition) ap-
plicable to T .

Proof. We show the result for the α-successor, the same rea-
soning being applicable for the β-successor. As the visible
chase contains

ChildrenQ(cp, α, β, ac, acα, acβ, yk

0, yk

1, croot, cCrit, y0, y1),

it also contains atoms of the shape:

Cell(cp, α, a1, . . . , ak, v, vprev, vnext, croot, cCrit, y0, y1),

for any vector a1, . . . , ak, where all nulls from v, vprev and
vnext are fresh. Note that cp is necessary distinct from croot
(as it is the representative of a tape). Hence neither Ttapei(x)
nor Ttapeo (x) may unify a term with cCrit. As cp is a represen-
tative of T , for any address, if the ith bit of v represents the
actual value in T at address ad, then the visible chase contains
Cellc
i (cp, b1,k, cCrit) where b1,k is the binary encoding of ad.
Similarly, Celln
i (cp, b1,k, cCrit) also
belong to the visible chase where applicable. Then for all ad-
dresses, an application of the relevant mapping of the shape
T α
i,j,k→w(x) merges the null at the position representing the
content of Tα with cCrit. Applying Tdatan and Tdatap then en-
sures that α is a representative for Tα.

i (cp, b1,k, cCrit) and Cellp

Wrapping up the previous two lemmas, we get that there is
a tree structure in the visible chase that corresponds exactly
to the tree of conﬁgurations of the run of T : the two individ-
uals cα and cβ are representatives of the initial conﬁguration,
and their children (which are the individuals at the second and
third individuals in the Children atom in which they appear at
the ﬁrst position) are representatives of the conﬁgurations that
can be reached with an α or β transition. It remains to check
that the argument representing the accepting status of a con-
ﬁguration are correctly set, which is the topic of the following
lemma.
Lemma 3. If cp is the representative of a tape, there is in the
visible chase an atom of the shape

ChildrenQ(cp, α, β, cCrit, acα, acβ, yk
if and only if T accepts on T .

0, yk

1, croot, cCrit, y0, y1),

Proof. Let T be a tape of representative cp. There are four
cases in which T accepts on T :
• the state of T is ﬁnal

this is the case if
and only if Taccept merges the fourth argument of
ChildrenQ(cp, α, β, ac, acα, acβ, yk
with cCrit

0, yk

in T :

1, croot, cCrit, y0, y1)

• the state of T is universal in T and both its successors
are accepting: by induction assumption (on the number
of transitions that need to be applied to prove acceptance
of a tape), both accepting bits of α and β are uniﬁed with
cCrit, and thus the accepting bit of cp is uniﬁed with cCrit
thanks to T∀

• the state of T is existential in T and its α-successor is
accepting: by induction assumption, the accepting bit of
α is uniﬁed with cCrit, and thus the accepting bit of cp is
uniﬁed with cCrit thanks to T∃,α
• similar case, with the β-successor.

Let us now use the above lemmas to show that T accepts
if and only if the policy query p holds in the visible chase.
If T accepts, let us consider an accepting run of T . From

Lemmas 1 and 2, we can build a conﬁguration tree that con-
tains a representative for all the tapes that are involved in this
run. From Lemma 3, the accepting bits of the representative
are set adequately, and the policy query holds in the visible
chase.

Conversely, let us consider a visible chase sequence such
that the policy query holds in its result. Let us ﬁrst remark
that the argument of the policy query appearing in the ﬁrst
position is equal to the argument in the ante-ante-penultimate
position. This implies that none of the witnesses of mappings
other than TInit need to be applied in order to entail the policy
query, which can be seen from the following three facts: (i)
none of the positions that may contain a conﬁguration identi-
ﬁer may be uniﬁed with cCrit; (ii) all mappings contain conﬁg-
uration identiﬁers (iii) only the witness associated with TInit
may generate an atom of the shape
Children∃(root, α, β, z, acα, acβ, y1,k
1 , root, z, y0, y1),
This implies that in the visible chase sequence entailing the
policy query, we start by introducing α and β as in Lemma 1.
Let us now consider the smallest set S of conﬁguration rep-
resentatives that fulﬁlls the following conditions:

0 , y1,k

• α and β are in S
• if c is in S and the tape associated with c is in a universal

state, then both successors of c are in S

• if c is in S and the tape associated with c is an existen-
tial state, then a successor of c having its acceptance bit
equal to cCrit is in S.

By the previous lemmas, there exists an accepting run of T

going exactly through the represented conﬁgurations.

B.4 Second Part of Proof of Theorem 6:

EXPTIME-hardness for Inclusion
Dependencies and Guarded Maps in Bounded
Arity

Recall the statement of the second part of Theorem 6:

DiscloseC(IncDep, GuardedMap) is EXPTIME-hard even

in bounded arity.

In the proof of Theorem 6, we used predicates of un-
bounded arity only to generate exponentially many cell ad-
dresses. Here, we use only k addresses, and can encode their
content through k predicates Cell1 to Cellk. However, the
proof follows the same line of argumentation as in Theorem
6.

Let us describe the source signature.
• Children∀(c, cα, cβ, ac, acα, acβ, r, z) states that a con-
ﬁguration c is universal and has as children cα and cβ,
and that the acceptance bit of c is ac, of cα is acα and
of cβ is acβ. The last two positions are placeholders for
the root of the tree of conﬁgurations, and cCrit.

• Children∃(c, cα, cβ, ac, acα, acβ, r, z): same meaning,

except that c is existential.

• Celll(cp, cn, v, z) states that the cell of address l of the
tape represented by cn has a content represented by v.
The last position is a placeholder for cCrit.

• Celll

i(c, x, z) states that the cell of address l in conﬁgura-
tion c contains x at the ith position of the representation
of its content.

• succα(cp, cn) states that cn is the α-successor of cp (and

similarly for β)

The symbol Q always ranges over {∀, ∃}.

Initialization. We ﬁrst deﬁne a mapping TInit(x), introduc-
ing some elements in the visible chase, whose deﬁnition is:

Children∃(croot, cα, cβ, acroot, acα, acβ, croot, x)

Generation of the tree of conﬁguration. α-successors
have themselves α- and β-successors, and are existential if
their parent is universal:

Children∀(c, α, β, ac, acα, acβ, r, z)
→ ∃αα, αβ, acαα, acαβ
Children∃(α, αα, αβ, acα, acαα , acαβ , r, z)

And similarly for Children∃ and for the β-successor.
Universal and existential acceptance condition.
If both
successors of a universal conﬁguration n are accepting, so is
n. We create a mapping T∀(x) having deﬁnition:

Children∀(c, α, β, x, z, z, r, z)

If the α-successor of an existential conﬁguration n is ac-
cepting, so is n. We create a mapping T∃,α(x) having deﬁni-
tion:

Children∃(c, α, β, x, z, acβ, r, z)

We create a similar mapping T∃,β for the β-successor.
Tape representation and consistency of tapes. We now
focus on the representation of the tape and its consistency.
For each conﬁguration, we generate k cells whose content is
initialized freshly:

Children∀(c, α, β, ac, acα, acβ, r, z)
→ ∃v Celll(c, α, v, z)

and similarly for existential conﬁgurations and for the β-
successors. Note that the values v, vprev and vnext are again
vectors of length the size of (Σ ∪ {(cid:91)}) × (Q ∪ ⊥). We again
use the notation li(x) to represent a vector of same length,
composed of fresh variables, except for the position i, which
contains x.

To ensure guardedness, we ﬁrst introduce auxiliary predi-
that deﬁne the content of the ith

cates Cellc
i
bit of the value of the current, previous and next cells:

i and Celln

i , Cellp

Celll(cp, cn, li(x), z)
→ Celll

i(cn, x)
We enforce that the tape of the initial conﬁguration has
the head of the Turing machine on the ﬁrst cell (and assume
w.l.o.g that this is represented by the ﬁrst position of v con-
taining cCrit) with all the other cells containing (cid:91). We also

assume w.l.o.g that the other cells containing (cid:91) is represented
by the second position of v containing cCrit. We thus create
the mappings Ttapei(x), for the the ﬁrst cell, having deﬁni-
tion:

Cell1(cp, cn, l1(x), cp)

(x), for all the other cells (2 ≤ l ≤ n), with

and T l
deﬁnition:

tapeo

Celll(cp, cn, l2(x), cp)
Note that this data is associated with the children of the
root (as cp is both in the ﬁrst and the penultimate positions of
the atoms), and not with the root itself, due to the choice of
keeping in Celll the identiﬁer of the parent of the considered
conﬁguration.

We then check that the tape associated with the α-successor
of a conﬁguration is indeed obtained by applying an α-
transition. This is done by noticing that the value of each
cell of the α-successor is determined by the value of the cell
and its two neighbors in the original conﬁguration (the neigh-
bors are necessary to know whether the head of the Turing
machine is now in the considered cell). To ensure guarded-
ness, we ﬁrst deﬁne a predicate marking α-successors (and
similarly for β-successors):

ChildrenQ(c, α, β, z, acα, acβ, r, z)
→ succα(c, α)

Let us consider a cell of address l in cp. We assume that
its content is represented by i, while the content of its left
(resp. right) neighbor is represented by j (resp. k). We rep-
resent the fact that this implies that the content of the cell of
address l is w in the α-successor of cp by the following map-
ping T α

i,j,k→w(x):

Celll(cp, cn, lw(x), z)
∧ Celll
i(cp, z)
∧ Celll−1
(cp, z)
j
∧ succα(cp, cn)

As in the non-bounded case, the ﬁrst (resp. last) cell should
be dealt with separately, as there is no content in the (non-
existent) previous (resp. next) cell. And we ﬁnally create a
mapping Taccept(x) enforcing that conﬁgurations whose tape
is in an accepting state (which we assume w.l.o.g. corre-
sponds to the case where the ﬁrst cell contains the lth
f bit)
are declared as accepting.

Cell1
lf

(cn, z)

∧ ChildrenQ(cn, α, β, x, acα, acβ, r, z)

The policy is

Children∃(root, α, β, z, acα, acβ, root, z)

We can verify that this policy is disclosed if and only if the
original Turing machine accepts on the empty tape, using a
similar reasoning to the unbounded case.

B.5 Final Part of Proof of Theorem 6: Reduction
from GTGD and ProjMap to IncDep and
GuardedMap

Theorem 6 states a 2EXPTIME lower bound for general arity
and an EXPTIME lower bound in bounded arity for two differ-
ent cases. The ﬁrst case was when the source constraints are
IncDeps and the mappings are guarded. The previous sections
of the appendix have gone through the proofs of this case in
detail. We now ﬁnish the proof of Theorem 6 showing:

DiscloseC(GTGD, ProjMap) is 2EXPTIME-hard, and is

EXPTIME-hard even in bounded arity.

The proof of both of these assertions follows directly from
Corollary 4 (the general reduction of maps presented in sec-
tion A.2).

We have seen that IncDep and GuardedMap reduces to
GTGD and ProjMap, therefore we have the lower bound
for Disclose(GTGD, ProjMap, p) from the lower bound
Disclose(IncDep, GuardedMap, p)

B.6 Proof of Theorem 7: EXPTIME-hardness for

Inclusion Dependencies and Atomic Maps,
and for LTGDs with Projection Maps

Recall the statement of Theorem 7:

DiscloseC(IncDep, AtomMap)

DiscloseC(LTGD, ProjMap) are both EXPTIME-hard.

and

on

the

We

ﬁrst

case

focus
of
DiscloseC(IncDep, AtomMap). We adapt
the construc-
tion used for PSPACE-hardness of entailment with IncDeps
[Casanova et al., 1984] to show EXPTIME-hardness for
IncDep source constraints and atomic maps. We start with
an alternating (rather than deterministic in [Casanova et al.,
1984]) Turing machine M and an input x, and consider the
problem asking whether there exists a halting computation
of M that uses at most |x| cells. As in the original reduction,
we use inclusion dependencies to simulate the transition
relation of M. The adaptation lies in the additional use of
a fresh position holding a conﬁguration identiﬁer, and the
generation of a tree of conﬁgurations, as in the reduction
presented in Theorem 6.

Let us describe the signature:
• ConﬁgQ(c, ac, v, z) states the conﬁguration c has quan-
tiﬁcation Q, has accepting bit ac, a tape represented by
c. the last argument will always hold cCrit in the visible
chase;

• TransitionQ

tα,tβ

(c, ac, v, α, acα, β, acβ, z) names

two
successors conﬁgurations α and β, with the conﬁgura-
tions consisting of acceptance bits acα and acβ, which
are obtained from c by applying transitions tα and tβ.
Let us turn to the description of v and subsequently tα. v
represents the content of the tape: for each position of the
tape, there is an argument for each pair of Σ × (Q ∪ {⊥}).
Intuitively, this argument is equal to cCrit if and only if the po-
sition contains the corresponding letter and head, and a fresh
null otherwise.

We introduce a mapping that initializes the tape:

Conﬁg∀(x, ac, v, x)

As in the proof of Theorem 6, we propagate the acceptance
information using mappings. For a universal state, we use a
mapping with deﬁnition:

Transition∀

tα,tβ

(c, x, v, α, z, β, z, z)

For an existential state, we use two mappings with deﬁni-

tions:

and

Transition∃

tα,tβ

(c, x, v, α, z, β, acα, z)

Transition∃

tα,tβ

(c, x, v, α, acα, β, z, z)

As before, we notice that the state of a cell after applying
a transition is deterministically deﬁned by its content as well
as the content of its left and right neighbor. The following
inclusion dependency states that from any conﬁguration, we
can try to apply all possible transitions to generate the α- and
β-successors:

ConﬁgQ(c, ac, v, z) → ∃α, acα, β, acβ
TransitionQ

(c, ac, v, α, acα, β, acβ, z)

tα,tβ

Proposition 10. The policy is disclosed if and only if there is
an accepting computation that uses at most |x| cells.

The lower bound for DiscloseC(LTGD, ProjMap) follows

by reduction:
Proposition 11. There
duction
from
DiscloseC(LTGD, ProjMap).

is

a

polynomial

time

DiscloseC(IncDep, AtomMap)

re-
to

Proof. Given a mapping φ((cid:126)x) → ∃(cid:126)y H((cid:126)t) where there may
be repeated variables in the head atom, we replace it by a
projection mapping

φ((cid:126)x) → ∃(cid:126)y H (cid:48)((cid:126)t)

where H (cid:48) is a new predicate whose arity is the number of dis-
tinct variables in H((cid:126)t). H (cid:48)((cid:126)t(cid:48)) has the same variables as H,
but with no repetition. For example, if the head of the original
rule is H(x, x, y), then the new rule has head H (cid:48)(x, y).

We additionally add the source constraint:

∀(cid:126)t H (cid:48)((cid:126)t) → H((cid:126)t)

It is easy to see that this transformation preserves disclosure.

B.7 Proof of Theorem 8: lower bounds for IncDeps

We now generate the tape associated with the α-transition

(and similarly for the β-transition):

in bounded arity
Recall the statement of Theorem 8:

TransitionQ

(c, ac, v, α, acα, β, acβ, z) →

∃v(cid:48)

α, z),

α Conﬁg

tα,tβ
(cid:126)Q(α, acα, vα ⊕ v(cid:48)
where (cid:126)Q denotes the dual quantiﬁer. Let us describe the vec-
tor vα ⊕ v(cid:48)
α. Suppose tα is the transition that checks whether
position i contains a, position i + 1 contains b and the head in
state s, and position i + 2 contains c; changes b to b(cid:48), moves
the head to the right and goes into state s(cid:48). Then vα ⊕ v(cid:48)
α is
deﬁned as follows:

• any argument that corresponds to a position distinct from
i + 1 or i + 2 is chosen equal to the argument at the same
position in v;

• the argument that corresponds to (i + 1, (b(cid:48), ⊥)) now
contains the value of v at position ((i+1), (b, s)), and all
other variables appearing in an argument corresponding
to position (i + 1) are existentially quantiﬁed;

• the argument that corresponds to ((i + 2), (c, s(cid:48))) now
contains the value of v at position ((i + 2), (b, ⊥)), and
all other variables appearing in an argument correspond-
ing to position (i + 1) are existentially quantiﬁed.

Note that here we have a distinction with the previous re-
duction: we do not check that a transition is applicable before
applying it, as this would be out of the capabilities of IncDep.
However, the same argument as in [Casanova et al., 1984]
proves that a conﬁguration reached from simulating a non-
applicable transition cannot lead to an accepting state. We
choose as a policy:

Conﬁg∀(x, x, v, x),

DiscloseC(IncDep, Map) is 2EXPTIME-hard in bounded

arity.

This proof will be very similar to the proof of Theorem 6.
We will provide a reduction from an alternating EXPSPACE
Turing machine to IncDep and SCEQrules. We show how to
simulate the run of an alternating EXPSPACE Turing machine
M with inclusion dependencies and SCEQrules.

The main difference between the proof of Theorem 6 and
the proof here is that in Theorem 6 each cell carried n bits
b1 . . . bn specifying the address of the cell.
In this version
we cannot use this trick as we are using a reduction where
all predicates are bounded. For each conﬁguration, the tape
will represented in the leaves of a full binary tree of depth
n. For a cell c, the n bits specifying the address of a c will
scattered across the n predicates in its lineage, each holding
one bit of the address: an internal node has two descendants
each carrying four values b,(cid:126)b, y0, y1. We will have b = y0
and (cid:126)b = y1 when then node represents the addresses where
the i-th bit is 0 and b = y1, (cid:126)b = y0 when it is 1.

Let us describe our source signature:
• Children∀(c, cα, cβ, ac, acα, acβ, r, y0, ybis

0 , y1, ybis
1 )

states that a conﬁguration c is universal and has children
cα and cβ, and that the acceptance bit of c is ac, of
cα is acα and of cβ is acβ. The last four positions are
placeholders for r the root of the tree of conﬁgurations,
two values y0 = ybis
representing 0 and two values
y1 = ybis

representing 1.

0

1

• Children∃(c, cα, cβ, ac, acα, acβ, r, y0, ybis
same meaning, except that c is existential.

0 , y1, ybis

1 ):

• for i ∈ 1..n, Addressi(cp, cn, bi,(cid:126)bi, y0, y1) corresponds
to a node of depth i in the binary tree representing the
tape of a conﬁguration. In this predicate cp is the parent
of the node, cn is the current node, bi will be equal to
y0 when the node if the ﬁrst child of cp and equal to y1
otherwise. (cid:126)bi will be the complement of bi (i.e. y0 = bi
implies y1 = (cid:126)i and y1 = bi implies y0 = (cid:126)i).

• Cellc(c, (cid:126)v) states that the cell at position c contains the
data represented by (cid:126)v. Cellp and Celln play similar roles
for the previous cell and the next cell.

Critical element. We create a mapping TcCrit(x) deﬁned as
IsCrit(x). The relation IsCrit will allow us to test whether a
variable is equal to cCrit.
Initialization. We ﬁrst deﬁne a mapping Tinit() introduc-
ing some elements in the visible chase, whose deﬁnition is:
Children∃(croot, cα, cβ, acroot, acα, acβ, croot, y0, y0, y1, y1)
Generating the tree of conﬁguration. α-successors have
themselves α- and β-successors, and are existential if their
parent is universal:

0, y1, yb
1)

Children∀(c, α, β, ac, acα, acβ, r, y0, yb
→ ∃αα, αβ, acαα , acαβ
Children∃(α, αα, αβ, acα, acαα, acαβ , r, y0, yb
And similarly for Children∃ and for the β-successor.
Universal and Existential Acceptance Condition.
If both
successors of a universal conﬁguration n are accepting, so is
n. We create a mapping T∀(x) with deﬁnition:
0, y1, yb

Children∀(c, α, β, x, ac, ac, r, y0, yb

1) ∧ IsCrit(ac)

0, y1, yb
1)

If the α-successor of an existential conﬁguration n is ac-
cepting, so is n. We create a mapping T∃,α(x) of deﬁnition:
Children∃(c, α, β, x, acα, acβ, r, y0, yb
1) ∧ IsCrit(acα)

0, y1, yb

We create a similar mapping T∃,β for the β-successor.
Generating the tape cells. We now focus on the represen-
tation of the tape and its consistency. We generate 2k ad-
dresses and associated values:

ChildrenQ(c, α, β, ac, acα, acβ, r, y0, yb
→ Address1(c, c1, y0, y1, yb

0, yb
1)

0, y1, yb
1)

ChildrenQ(c, α, β, ac, acα, acβ, r, y0, yb
→ Address1(c, c1, y1, y0, yb

0, yb
1)

0, y1, yb
1)

And for i ∈ 1..n − 1 we have:

0, yb
1)

Addressi(ci−1, ci, b,(cid:126)b, yb
→ Addressi+1(ci, ci+1, , b,(cid:126)b, yb
Addressi(ci−1, ci, b,(cid:126)b, yb
→ Addressi+1(ci, ci+1,(cid:126)b, b, yb

0, yb
1)

0, yb
1)

0, yb
1)

Finally for n we have:

Addressn(cn−1, cn, b,(cid:126)b, yb
→ Cellc(cn, (cid:126)v)

0, yb
1)

Initialization of the tape. For the case 0, we use the pattern
l1 and introduce a mapping Ttape0(x) deﬁned as:

Children∃(croot, α, β, ac, acα, acβ, y0, y0, y1, y1)
Address1(root, id1, y0, y1, y0, y1)
. . .
Addressn(idn−1, idn, y0, y1, y0, y1)
Cellc(idn, l1(x))

∧
∧
∧
∧

For all others cases, with a ﬁrst 1 at the i-th bit, we use the

pattern l0 and introduce Ttape i(x):

Children∃(croot, α, β, ac, acα, acβ, y0, y0, y1, y1)
Address1(root, id1, y0, y1, y0, y1)
. . .
Addressi(idi−1, idi, y1, y0, y0, y1)
Addressi+1(idi, idi+1, ai, bi, y0, y1)
. . .
Addressn(idn−1, idn, an, bn, y0, y1)
Cellc(idn, l0(x))

∧
∧
∧
∧
∧
∧
∧

Ensuring the coherence between Cellc and Cellp. We
need to check the coherence between Cellc in an address and
Cellp at the previous address. As usual when v is at the ad-
dress (cid:126)b10j then Cellc needs to be checked against the Cellp at
the address (cid:126)b01j. We introduce the mapping Tprev j(x):

Addressn−j−1(id, id1, y1, y0, y0, y1)
∧ Addressn−j−1(id, id0, y0, y1, y0, y1)
∧ Addressn−j(id1, id10, y0, y1, y0, y1)
∧ Addressn−j(id0, id01, y1, y0, y0, y1)

. . .

∧ Addressn(id10j−1, id10j , y0, y1, y0, y1)
∧ Addressn(id01j−1, id01j , y1, y0, y0, y1)
∧ Cellc(id10j , lk(s))
∧ Cellp(id10j , lk(v))
∧ IsCrit(v)

Encoding transitions. As in previous reductions, we en-
code the transitions of δ(cid:15) as a set of (i, j, k) → w (where i is
the value of the cell, j is the value at the cell before and k at
the cell after and w is the written value).

For our transition, we need to write w at the same address
s where l lies in the (cid:15)-child of the conﬁguration of c. To be at
the same address, we need to check that the path follows the
same bits (that we note here bn . . . b1). We use the mapping
T (cid:15)
i,j,k→w(x) deﬁned as:

∧
∧
∧
∧
∧
∧
∧
∧

IsCrit(v)
Cellp(idn, li(v))
Cellc(idn, lj(c))
Celln(idn, lk(c))
Cellc(id(cid:48)
n, lw(x))

Addressn(idn, idn−1, bn,(cid:126)bn, y0, y1, y0, y1)

Addressn(id(cid:48)

n, id(cid:48)

n−1, bn,(cid:126)bn, y0, y1)

n−1, id(cid:48)

Addressn−1(idn−1, idn−2, bn−1,(cid:126)bn−1, y0, y1)
n−2, bn−1,(cid:126)bn−1, y0, y1)
Addressn−1(id(cid:48)
. . .
Address1(idp, id1, b1,(cid:126)b1, y0, y1)
1,(cid:126)b1, b1, y0, y1)
Address1(id(cid:48)
c, id(cid:48)
T ree(cid:96)(idg, idp, y0, y0, y1, y1)

∧
∧
∧
∧ ChildrenQ(c, cα, cβ, ac, acα, acβ, r, y0, y0, y1, y1)

Encoding ﬁnal states. Whenever the current state is qaccept
we need to enforce that the ac bit is set. To enforce that the ac
bit is set, we introduce the following mapping, for each value
k ∈ {qaccept} × Σ marking a ﬁnal state:

∧
∧

IsCrit(v)
Cellc(idn, lk(v))
Addressn(idn−1, idn, xn−1, zn−1, y0, y1)
. . .
Address1(c, id1, x1, z1, y0, y1)

∧
∧ ChildrenQ(c, α, β, x, acα, acβ, r, y0, y0, y1, y1)

Policy. The policy query is

Children∃(root, α, β, z, acα, acβ, r, y0, y0, y1, y1),

We can verify that the policy query is disclosed if and only

if the original Turing machine accepts on the empty tape.

B.8 Maximality of our Tractability Conditions
Recall that Theorem 5 shows that we can get tractability by
simultaneously restricting our constraints to be UIDs and our
mappings to be ProjMaps. Recall also that a UID is an IncDep
with at most one exported variable. Here we show that these
restrictions are maximal in the following sense: if we increase
from UIDs to LTGDs with frontier one we get intractability.
We also get intractability if we stick with UIDs but we allow
the mappings to be atomic. Let Fr1LTGD denote the LTGDs
with at most one exported variable.
In fact, we will show
something stronger (here ∅ denotes no constraints):
DiscloseC(∅, AtomMap)
Theorem
DiscloseC(Fr1LTGD, ProjMap) are both NP-hard.

and

10.

In order to prove our results, we will rely again on Propo-
sition 1, which states that testing for disclosure is equiva-
lent to evaluating the policy query on the result of the vis-
ible chase process. The process starts with the instance
HideM(DG(M)
), which has source witnesses for each tuple
Crit
in DG(M)
. It proceeds by alternating traditional chase steps
Crit
and merge steps, which are applications of a SCEQrule. It

is well known that query evaluation is NP-hard on arbitrary
instances. But the constraints that we are considering in this
section do not allow us to generate arbitrary instances as a
visible sections. In this section we will exhibit a instance D
on which query evaluation is NP-hard, but where D can be
the result of the visible chase using AtomMaps but no con-
straints, or with a visible chase using Fr1LTGD constraints
and ProjMaps.
The instance D. D will have one relation R with 6 atoms.
We present the content of R below. Empty cells are ﬁlled
with fresh nulls, c is the only value shared by two tuples and
ni correspond to nulls that are shared inside a tuple:

d ¬d
n1
c

b ¬a ¬b a ∨ b ¬2b

a
n1 n1
c
n3
c
c

c
c
c
n2 n2
c
c
n3
n4 n4
c
n5 n5
c

n1
c
c
c

c
n6

n6

c

Note that this is a single-shared value instance: only one
value, namely c, is shared among multiple tuples. Such in-
stances can be produced as the result of the visible chase over
atomic mappings with no constraints. In this case:

R(y, y, x, x, y, v1, x, y) → T1(x)
R(x, y, y, x, x, v1, v2, v3) → T2(x)
R(y, x, x, y, x, v1, v2, v3) → T3(x)
R(x, x, y, y, x, v1, v2, v3) → T4(x)
R(x, u, y, y, v1, x, v2, v3) → T5(x)
R(v1, v2, v3, x, v4, y, y, x) → T6(x)
They can also be produced as the result of the visible
chase over one projection mapping A(x) → T (x) with 6
Fr1LTGDs:

A(x) → R(y, y, x, x, y, v1, x, y)
A(x) → R(x, y, y, x, x, v1, v2, v3)
A(x) → R(y, x, x, y, x, v1, v2, v3)
A(x) → R(x, x, y, y, x, v1, v2, v3)
A(x) → R(x, u, y, y, v1, x, v2, v3)
A(x) → R(v1, v2, v3, x, v4, y, y, x)
The remainder of the argument is to show that CQ evalua-
tion is NP-hard over this instance, via reduction from satisﬁ-
ability of a propositional circuit (Circuit SAT).
General idea of the reduction. The reduction that we pro-
vide will create a query Q for each instance I of Circuit SAT.
Without loss of generality, we suppose that I is composed of
wires w1, . . . , wk, of negation gates N1, . . . Nl and of binary
OR gates O1, . . . , Om. Wire that are not the output of any
gate are the inputs of the circuit. We will suppose that the
output corresponds to the wire 1.

We will build the query Q to contain conjuncts for each
wire, each negation gate and each binary OR. Furthermore
we will create a variable vi for each wire wi.

For the sake of readability, we present the conjuncts graph-
ically, with each row representing an R atom. A row with en-
tries tj1 . . . tjk represents an atom R( (cid:126)w) where wi is a fresh

existentially quantiﬁed variable when the cell is empty and
the variable tji in the cell otherwise.
Wires. For each wire wi, we will force the value of its as-
sociated variable vi to be either c (when the wire carries the
value true) or n1 (when the wire carries false).
For each wire i, we will have a conjunct:

a
vi

b ¬a ¬b a ∨ b ¬2b d ¬d
vi

For the variable v1 corresponding to the output wire we

also add a conjunct:

a b ¬a ¬b a ∨ b ¬2b d ¬d

v1

v1

Negation. For each negation gate Nk, whose input is the
wire i and output is the wire j, we will have the following
conjuncts:

– when wj = ⊥ and wi = (cid:62) and thus vj = n1,

vi = c we can set x(cid:96) = n2, y(cid:96) = c

– when wi = wj = ⊥ and thus vi = vj = n)1 we

can set x(cid:96) = y(cid:96) = c
In all cases, our conjuncts are satisﬁed.

Conversely, let us show that when the query is satisﬁed
in our instance D, then the circuit is satisﬁable. Let h be a
homomorphism from the query variables to values. Since we
have wire conjuncts constraining vi for each wire wi, we can
see that h(vi) = n1 or h(vi) = c. We now consider the circuit
assignment such that wi = (cid:62) when h(vi) = c and wi = ⊥
when h(vi) = n1. Let us show that this assignment witnesses
the satisﬁability of the circuit.

• The output wire is already constrained such that h(v1) ∈
{n1, c} but it also has a special conjunct and the only
remaining possibility for h(v1) is c and thus the output
gate is set at (cid:62).

• For each negation gate whose input is wi and output is

b ¬a ¬b a ∨ b ¬2b

d ¬d

wj:

a
vi

rk

rk

pk

pk

vj

Computing binary OR. For the binary OR O(cid:96) gate whose
inputs are the wires vi and vj and the output is vk, we intro-
duce the following conjuncts:

a
vi

b ¬a ¬b a ∨ b ¬2b d ¬d

vj

x(cid:96)

x(cid:96)

y(cid:96)
y(cid:96)

vk

Proof that this reduction captures Circuit-SAT. Let us
suppose that the circuit is satisﬁed. Towards showing that the
query is satisﬁed in the instance D, we ﬁrst build a binding
for the variables that are shared between multiple of the con-
junct grouping above, which are exactly the “wire variables”
vi. We do this by setting vi = c when wi = (cid:62) and vi = n1
when wi = ⊥. We now show that this binding extends to
a valuation making the query true. Since all the other vari-
ables are not shared between the conjunct groups, it sufﬁces
to show satisﬁability of each conjunct group in isolation.

• We see that all the conjuncts corresponding to wires are
satisﬁed (even the special conjunct corresponding to the
output).

• For the negation gate Nk whose input is vi and output is
vj. When wi = (cid:62) and thus vi = c, we can set rk = n5,
pk = c and satisfy all 3 conjuncts. When wi = ⊥ and
thus vi = n1, we can set rk = c and pk = n6 and satisfy
all 3 conjuncts.

• For an OR gate O(cid:96) whose inputs are vi and vj, and

whose output is vk. There are four cases:

– when wi = wj = (cid:62) and thus vi = vj = c we can

set x(cid:96) = y(cid:96) = n4

– when h(vi) = n1 then the conjunct holding vi and
rk (i.e. the ﬁrst row in the graphical representation)
forces that h(rk) = c. The conjunct holding rk and
pk forces pk to be a fresh null or n6. But since pk
appears in the column ¬2b and in the column d, we
can only have pk = n6 and thus vj = c.

– when h(vi) = c then the conjunct holding vi and
rk forces that h(rk) = n5 or h(rk) = n4. Then
the conjunct holding rk and pk forces pk to be ei-
ther a fresh null (when h(rk) = n4) or c (when
h(rk) = n5). Since pk appears in the column ¬2b
and in the column d we cannot have pk fresh null,
we conclude thatpk = c, and thus vj = n1.

In both cases, the semantics of the negation gate is re-
spected.

• Consider each OR gate whose inputs are wi, wj and out-

put is wk. First we have:

– when h(vi) = n1 then necessarily h(x(cid:96)) = c
– when h(vi) = c then h(x(cid:96)) = n2 or h(x(cid:96)) = n4 or

h(x(cid:96)) = n5

– when h(vj) = n1 then necessarily h(y(cid:96)) = c
– when h(vj) = c then h(x(cid:96)) = n3 or h(x(cid:96)) = n4.

Therefore we see that:

– when h(vi) = n1 = h(vj) then necessarily

h(x(cid:96)) = h(y(cid:96)) = c and thus h(vk) = n1

– when h(vi) = c and h(vj) = n1 then h(x(cid:96)) = n2

and thus h(vk) = c

– when h(vi) = n1 and h(vj) = c then necessarily

h(y(cid:96)) = n3 and thus h(vk) = c

– when h(vj) = c = h(vi) then h(x(cid:96)) = n4 = h(y(cid:96))

and thus h(vk) = c

in all cases we do have that the semantics of the OR gate
is respected.

– when wi = ⊥ and wj = (cid:62) and thus vi = n1,

All in all, we have seen that the circuit is satisﬁable if and

vj = c we can set x(cid:96) = c, y(cid:96) = n3

only if the query has a solution on the visible chase.

B.9 Lower Bounds Inherited from Entailment

In the body of the paper we claimed that in several cases, we
could show that the complexity of disclosure for a class was
at least as hard as the complexity of query entailment for the
class. We do not claim that there is a generic reduction from
query entailment to disclosure. There is a simple reduction
from entailment for special classes of instances to disclosure.
More speciﬁcally, disclosure is easily seen to subsume en-
tailment on instances of the form HideM(DG(M)
). But one
needs to see that entailment on these specialized instances is
as hard as entailment in general; this requires a separate argu-
ment for each class.

Crit

There are three cases of “lower bounds from entailment”
those whose lower
that are used in the body of the paper:
bound is annotated with QEntail in Table 1. We give the de-
tails of each argument below.

In Bounded Arity, Disclosure with IncDep Source
Constraints and Projection Maps is NP-hard

We begin by showing that disclosure for IncDep source con-
straints and projection maps inherits the NP-hardness that is
known for query entailment with IncDeps. We do this via a
direct reduction from 3-coloring. We make use again of the
characterization of disclosure using the visible chase.

Let us take a graph G = (V, E) that is an input to 3-
coloring. In our reduction, the schema, the constraints and
the mapping will not depend on this actual graph reduced.
Only the query will depend on the graph.

Crit

We will have a single source relation OK(x, y, z) and one
mapping OK(x, y, z) → M () to create canonical values for
(x0, y0, z0) in HideM(DG(M)
), which is the initial instance
in the visible chase. Then we will use two IncDep constraints
to create all permutations for these values: OK(x, y, z) →
OK(x, z, y) and OK(x, y, z) → OK(y, x, z).
the mapping, HideM(DG(M)
) will have
three values x0, y0, z0 with OK(x0, y0, z0).
Then the
constraints ensure that the canonical model contains the six
for OK: OK(x0, y0, z0),
permutations of arguments
OK(x0, z0, y0),
OK(y0, z0, x0),
OK(z0, x0, y0), OK(z0, y0, z0).

OK(y0, x0, z0),

Because of

Crit

In General Arity, Disclosure with IncDep Source
Constraints and Projection Maps is PSPACE-hard
Here we give a direct reduction1 from the implication prob-
lem for IncDeps, or equivalently, the entailment problem for
a single-atom instance and an atomic query. This is known
to be PSPACE-hard [Casanova et al., 1984]. Given a prob-
lem Σ (cid:15) R1( (cid:126)X) ⊆ R2( (cid:126)X) (where (cid:126)X has no repeated vari-
ables and Σ is composed of IDs), we introduce a fresh predi-
cate shadowR1 and we reduce it to the disclosure problem
with query shadowR1( (cid:126)X) ∧ R2( (cid:126)X) on the constraints Σ
plus shadowR1( (cid:126)X) → R1( (cid:126)X) and the mapping V () :=
∃ (cid:126)X shadowR1( (cid:126)X).
In Bounded Arity, Disclosure with FGTGD Source
Constraints and Projection Maps is 2EXPTIME-hard
The last place where we claim that disclosure is at least as
hard as entailment is for FGTGD source constraints and pro-
jection maps in bounded arity. Here we will proceed by mod-
ifying the reduction used in Theorem 8. In this proof we used
mappings for two distinct purposes. The initialization map-
ping Tinit() was used to generate some values in the initial
instance of the visible chase. In the proof, this mapping is
an atomic map but not a projection map; but we can easily
change this to use a projection map and an LTGD.

The remaining maps are used to ensure that certain val-
ues get merged with cCrit in the visible chase. Put another
way, they are used to enforce certain SCEQrules. But with
the mappings Tinit() and TcCrit(x), we can ensure that the ini-
tial instance of the visible chase includes exactly one element
satisfying IsCrit. Once we have done this, we can mimic a
SCEQrule

φ((cid:126)x) → xi = cCrit

by a source constraint

φ((cid:126)x) → IsCrit(xi)

This must be a FGTGD, since the frontier has size one. Trans-
forming the mappings according to this methodology, while
leaving the query the same as in Theorem 8 gives us a modiﬁ-
cation of the hardness proof using FGTGD source constraints
and projection maps, as required.

In our query |V | variables will capture the coloring of
each node, we note v(n) the variable associated with node
n. For each (f, t) ∈ E the query will include a conjunct
∃c OK(v(f ), v(t), c).

We sketch the correctness of this reduction. The three val-
ues x0, y0, z0 in HideM(DG(M)
) encode the three possible
colors in a coloring. The conjunct ∃c OK(v(f ), v(t), c) for-
bids the nodes f and t to be mapped to the same value (x0, y0
or z0) as ∃c OK(v, v, c) has no solution in HideM(DG(M)
).
Therefore if we have disclosure have a 3-coloring.

Crit

Crit

Conversely, if we have a 3-coloring, we can ﬁnd a solution

1The original proof given here was faulty, many thanks to Balder

for the query in the visible chase.

ten Cate for noticing it and suggesting a ﬁx.

C Reﬁnements of our results

Atomic queries. We have focused in the body of the paper
on policy queries given as general CQs. But almost all of our
lower bounds can be seen to hold for atomic queries. The only
exceptions are stated in Theorem 4 and Corollary 3, where we
claim PTIME membership in bounded arity when restricting
to atomic queries. Note that the NP-hardness bounds for gen-
eral CQs corresponding to these upper bounds do not follow
from our custom reductions, but using the simple reduction
from entailment of CQs for the corresponding classes (e.g.
IncDeps).

Non-Boolean queries.
In this appendix we have provided
details of our upper bounds, assuming for simplicity that the
queries p are Boolean. But the proofs all extend to the non-
Boolean case, as we now explain. To see this we need to
go back to Theorem 1. We restate the theorem in a slightly
different variant:
Theorem 11. [Benedikt et al., 2016] When source con-
straints are TGDs and mapping rules are given by CQ deﬁni-
tions, then if a disclosure of a CQ (Boolean or non-Boolean)
occurs, then the source instance which witnesses this can be
taken to be DS

Crit.

Crit

The statement differs slightly from that of Theorem 1, since
this version talks about getting an instance that agrees with
DS
Crit on the mapping images, rather than having one that ex-
tends HideM(DG(M)

) and satisﬁes the constraints.

The important point is that the result holds for non-Boolean
queries as well as Boolean queries. Note that for a Non-
Boolean query p((cid:126)x), all the facts that an attacker will see
in the mapping image of DS
Crit will contain only the value
cCrit. Thus the only query answers that can be disclosed to
the attacker will involve the value cCrit. Inspection of each
of the upper bound reductions will show that to detect such
disclosures, it sufﬁces to pre-process the query to add con-
juncts IsCrit(xi) for each variable xi, treating the result as a
Boolean query.

Note that this transformation converts atomic queries to
queries consisting of a single atom and an additional set of
unary atoms. However, this will not impact the PTIME claims
in Theorem 4 and Corollary 3. For example in Theorem 4, we
will need only to note that for atomic queries on a bounded ar-
ity schema, we will get an atomic query with a bounded num-
ber of additional atoms of the form IsCrit(xi). Entailment of
such queries over a bounded arity schema with IncDeps is
still in PTIME.

Dependencies with multiple atoms in the head.
In some
of our upper bound proofs, we assumed that the dependencies
had a single atom in the head for simplicity, even when the
classes in question (e.g. GTGDs) does not impose this. In
our results that are stated for general arity, this assumption
can be made without loss of generality, since one can simplify
the heads by introducing intermediate predicates. In bounded
arity, one must take some care, since one cannot polynomially
reduce to the case of a single atom in the head. All of our
results for bounded arity do in fact hold as stated, without
any additional restrictions on the head. We explain how the

argument needs to be customized for the most subtle case,
Theorem 4.

Recall that the bounded arity case of Theorem 4 starts
with the critical-instance rewriting, which reduces to reason-
ing with Guarded TGDs having a ﬁxed side signature, the
unary predicate IsCrit(x). The linearization of [Amarilli and
Benedikt, 2018a; Amarilli and Benedikt, 2018b], applied in
this context, proceeds in two steps. First we generate all de-
rived rules of the form:
(cid:94)

R((cid:126)x) ∧

IsCrit(xi) → IsCrit(xj)

i

Notice that these are full-dependencies: no existentials in the
head. This generation can be done inductively, via the dy-
namic programming steps in [Amarilli and Benedikt, 2018b]:
one inductive steps composes a derived rule with one of the
original non-full dependencies. A second step composes two
derived full rules. This can be applied directly to the case of
rules with multiple atoms in the head.

After this is done, the second step of linearization moves
to an extended signature described as follows: for every re-
lation R of arity k in the original signature (without IsCrit),
and for each set of positions P of R, we introduce predi-
cates RP of arity k. Informally, RP ((cid:126)x) stands in for R((cid:126)x) ∧
(cid:86)

i∈P IsCrit(xi). We lift every original dependency:

R((cid:126)x) ∧

(cid:94)

i∈P

IsCrit(xi) → ∃(cid:126)y

(cid:94)

Hj((cid:126)tj)

to a linear TGD:

(cid:94)

RP ((cid:126)x) → ∃(cid:126)y

(cid:94)

H Pj

j ((cid:126)tj)

where Pj contains the positions corresponding to exported
variables in P . We lift every derived full dependency of the
form:

(cid:94)

R((cid:126)x) ∧

IsCrit(xi) → IsCrit(xj)

to a linear TGD:

i∈P

RP ((cid:126)x) → RP ∪{j}((cid:126)x)

Finally we have linear TGD asserting that the semantics of
RP become stronger as one adds to the set of positions P :

RP (cid:48)

((cid:126)x) → RP ((cid:126)x)

for P ⊂ P (cid:48).

We rewrite the query to the extended signature in the anal-
ogous way. The correctness of this transformation is given
by an argument identical to that in the single-headed case in
[Amarilli and Benedikt, 2018b].

Note that this transformation is in PTIME when the arity
is ﬁxed. It reduces us to an entailment problem with LTGDs,
still with bounded arity, but with multiple atoms in the head.
Such an entailment problem can be shown to be in NP using
a simple variation of the algorithm for IncDeps of [Johnson
and Klug, 1984].

