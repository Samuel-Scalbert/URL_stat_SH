The Power of Programs over Monoids in J
Nathan Grosshans

To cite this version:

Nathan Grosshans. The Power of Programs over Monoids in J. LATA 2020 - 14th International
Conference on Language and Automata Theory and Applications, Mar 2020, Milan, Italy. pp.315-
327, ￿10.1007/978-3-030-40608-0_22￿. ￿hal-02414771￿

HAL Id: hal-02414771

https://hal.science/hal-02414771

Submitted on 17 Dec 2019

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

The Power of Programs over Monoids in J

Nathan Grosshans∗†

Abstract

The model of programs over (ﬁnite) monoids, introduced by Barring-
ton and Thérien, gives an interesting way to characterise the circuit com-
plexity class NC1 and its subclasses and showcases deep connections with
algebraic automata theory.
In this article, we investigate the compu-
tational power of programs over monoids in J, a small variety of ﬁnite
aperiodic monoids. First, we give a ﬁne hierarchy within the class of lan-
guages recognised by programs over monoids from J, based on the length
of programs but also some parametrisation of J. Second, and most import-
antly, we make progress in understanding what regular languages can be
recognised by programs over monoids in J. We show that those programs
actually can recognise all languages from a class of restricted dot-depth
one languages, using a non-trivial trick, and conjecture that this class
suﬃces to characterise the regular languages recognised by programs over
monoids in J.

1

Introduction

In computational complexity theory, many hard still open questions concern
relationships between complexity classes that are expected to be quite small in
comparison to the mainstream complexity class P of tractable languages. One
of the smallest such classes is NC1, the class of languages decided by Boolean
circuits of polynomial length, logarithmic depth and bounded fan-in, a relevant
and meaningful class, that has many characterisations but whose internal struc-
ture still mostly is a mystery. Indeed, among its most important subclasses, we
count AC0, CC0 and ACC0: all of them are conjectured to be diﬀerent from each
other and strictly within NC1, but despite many eﬀorts for several decades, this
could only be proved for the ﬁrst of those classes.

In the late eighties, Barrington and Thérien [3], building on Barrington’s
celebrated theorem [2], gave an interesting viewpoint on those conjectures, re-
lying on algebraic automata theory. They deﬁned the notion of a program over
a monoid M : a sequence of instructions (i, f ), associating through function f
some element of M to the letter at position i in the input of ﬁxed length. In that
way, the program outputs an element of M for every input word, by multiplying
out the elements given by the instructions for that word; acceptance or rejec-
tion then depends on that outputted element. A language of words of arbitrary
length is consequently recognised in a non-uniform fashion, by a sequence of

∗DI ENS, ENS, CNRS, PSL University, Paris, France, nathan.grosshans@polytechnique.

edu, https://www.di.ens.fr/~ngrosshans/.

†Inria, Paris, France.

1

programs over some ﬁxed monoid, one for each possible input length; when that
sequence is of polynomial length, it is said that the monoid p-recognises that
language. Barrington and Thérien’s discovery is that NC1 and almost all of its
signiﬁcant subclasses can each be exactly characterised by p-recognition over
monoids taken from some suitably chosen variety of ﬁnite monoids (a class of
ﬁnite monoids closed under basic operations on monoids). For instance, NC1,
AC0, CC0 and ACC0 correspond exactly to p-recognition by, respectively, ﬁ-
nite monoids, ﬁnite aperiodic monoids, ﬁnite solvable groups and ﬁnite solvable
monoids. Understanding the internal structure of NC1 thus becomes a matter
of understanding what ﬁnite monoids from some particular variety are able to
p-recognise.

It soon became clear that regular languages play a central role in understand-
ing p-recognition: McKenzie, Péladeau and Thérien indeed observed [12] that
ﬁnite monoids from a variety V and a variety W p-recognise the same languages
if and only if they p-recognise the same regular languages. Otherwise stated,
most conjectures about the internal structure of NC1 can be reformulated as a
statement about where one or several regular languages lie within that structure.
This is why a line of previous works got interested into various notions of tame-
ness, capturing the fact that for a given variety of ﬁnite monoids, p-recognition
does not oﬀer much more power than classical morphism-recognition when it
comes to regular languages (see [13, 14, 11, 20, 21, 22, 10, 8]).

This paper is a contribution to an ongoing study of what regular languages
can be p-recognised by monoids taken from “small” varieties, started with the
author’s Ph.D. thesis [7]. In a previous paper by the author with McKenzie and
Segouﬁn [8], a novel notion of tameness was introduced and shown for the “small”
variety of ﬁnite aperiodic monoids DA. This allowed them to characterise the
class of regular languages p-recognised by monoids from DA as those recognised
by so called quasi-DA morphisms and represented a ﬁrst small step towards a
new proof that the variety A of ﬁnite aperiodic monoids is tame. This is a
statement equivalent to Furst’s, Saxe’s, Sipser’s [6] and Ajtai’s [1] well-known
lower bound result about AC0. In [8], the authors also observed that, while DA
“behaves well” with respect to p-recognition of regular languages, the variety J,
a subclass of DA, does, in contrast, “behave badly” in the sense that monoids
from J do p-recognise regular languages that are not recognised by quasi-J
morphisms.

Now, J is a well-studied and fundamental variety in algebraic automata
theory (see, e.g., [15, 16]), corresponding through classical morphism-recognition
to the class of regular languages in which membership depends on the presence
or absence of a ﬁnite set of words as subwords. This paper is a contribution to
the understanding of the power of programs over monoids in J, a knowledge that
certainly does not bring us closer to a new proof of the tameness of A (as we are
dealing with a strict subvariety of DA), but that is motivated by the importance
of J in algebraic automata theory and the unexpected power of programs over
monoids in J. The results we present in this article are twofold: ﬁrst, we
exhibit a ﬁne hierarchy within the class of languages p-recognised by monoids
from J, depending on the length of those programs and on a parametrisation
of J; second, we show that a whole class of regular languages, that form a
subclass of dot-depth one languages [16], are p-recognised by monoids from J
while, in general, they are not recognised by any quasi-J morphism. This class
roughly corresponds to dot-depth one languages where detection of a given factor

2

does work only when it does not appear too often as a subword. We actually
even conjecture that this class of languages with additional positional modular
counting (that is, letters can be diﬀerentiated according to their position modulo
some ﬁxed number) corresponds exactly to all those p-recognised by monoids
in J, a statement that is interesting in itself for algebraic automata theory.

Organisation of the paper. Following the present introduction, Section 2
is dedicated to the necessary preliminaries. In Section 3, we present the results
about the ﬁne hierarchy and in Section 4 we expose the results concerning the
regular languages p-recognised by monoids from J. Section 5 gives a short
conclusion.

Note.
thesis [7].

This article is based on unpublished parts of the author’s Ph.D.

2 Preliminaries

2.1 Various mathematical materials

We assume the reader is familiar with the basics of formal language theory,
semigroup theory and recognition by morphisms, that we might designate by
classical recognition; for those, we only specify some things and refer the reader
to the two classical references of the domain by Eilenberg [4, 5] and Pin [15].

General notations and conventions. Let i, j ∈ N. We shall denote by [[i, j]]
the set of all n ∈ N verifying i ≤ n ≤ j. We shall also denote by [i] the set
[[1, i]]. Given some set E, we shall denote by P(E) the powerset of E. All our
alphabets and words will always be ﬁnite; the empty word will be denoted by ε.

Varieties and languages. A variety of monoids is a class of ﬁnite monoids
closed under submonoids, Cartesian product and morphic images. A variety of
semigroups is deﬁned similarly. When dealing with varieties, we consider only
ﬁnite monoids and semigroups, each having an idempotent power, a smallest
ω ∈ N>0 such that xω = x2ω for any element x. To give an example, the variety
of ﬁnite aperiodic monoids, denoted by A, contains all ﬁnite monoids M such
that, given ω its idempotent power, xω = xω+1 for all x ∈ M .

To each variety V of monoids or semigroups we associate the class L(V) of
languages such that, respectively, their syntactic monoid or semigroup belongs
to V. For instance, L(A) is well-known to be the class of star-free languages.

Quasi V languages.
is already a monoid and S ∪ {1} otherwise.

If S is a semigroup we denote by S1 the monoid S if S

The following deﬁnitions are taken from [17]. Let ϕ be a surjective morphism
from Σ∗ to a ﬁnite monoid M . For all k consider the subset ϕ(Σk) of M (where
Σk is the set of words over Σ of length k). As M is ﬁnite there is a k such
that ϕ(Σ2k) = ϕ(Σk). This implies that ϕ(Σk) is a semigroup. The semigroup
given by the smallest such k is called the stable semigroup of ϕ.
If S is the
stable semigroup of ϕ, S1 is called the stable monoid of ϕ. If V is a variety of
monoids or semigroups, then we shall denote by QV the class of such surjective

3

morphisms whose stable monoid or semigroup, respectively, is in V and by
L(QV) the class of languages whose syntactic morphism is in QV.

Programs over monoids. Programs over monoids form a non-uniform model
of computation, ﬁrst deﬁned by Barrington and Thérien [3], extending Barring-
ton’s permutation branching program model [2]. Let M be a ﬁnite monoid and
Σ an alphabet. A program P over M on Σn is a ﬁnite sequence of instructions
of the form (i, f ) where i ∈ [n] and f ∈ M Σ; said otherwise, it is a word over
([n] × M Σ). The length of P , denoted by |P |, is the number of its instruc-
tions. The program P deﬁnes a function from Σn to M as follows. On input
w ∈ Σn, each instruction (i, f ) outputs the monoid element f (wi). A sequence
of instructions then yields a sequence of elements of M and their product is the
output P (w) of the program. A language L ⊆ Σn is consequently recognised by
P whenever there exists F ⊆ M such that L = P −1(F ).

A language L over Σ is recognised by a sequence of programs (Pn)n∈N over
some ﬁnite monoid M if for each n, the program Pn is on Σn and recognises
L=n = L ∩ Σn. We say (Pn)n∈N is of length s(n) for s : N → N whenever
|Pn| = s(n) for all n ∈ N and that it is of length at most s(n) whenever there
exists α ∈ R>0 verifying |Pn| ≤ α · s(n) for all n ∈ N.

For s : N → N and V a variety of monoids, we denote by P(V, s(n)) the class
of languages recognised by sequences of programs over monoids in V of length
k∈N P(cid:0)V, nk(cid:1) is then the class of languages
at most s(n). The class P(V) = (cid:83)
p-recognised by a monoid in V, i.e. recognised by sequences of programs over
monoids in V of polynomial length.

The following is an important property of P(V).

Proposition 2.1 ([12, Corollary 3.5]). Let V be a variety of monoids, then
P(V) is closed under Boolean operations.

Given two alphabets Σ and Γ, a Γ-program on Σn for n ∈ N is deﬁned
just like a program over some ﬁnite monoid M on Σn, except that instructions
output letters from Γ and thus that the program outputs words over Γ. Let now
L ⊆ Σ∗ and K ⊆ Γ∗. We say that L program-reduces to K if and only if there
exists a sequence (Ψn)n∈N of Γ-programs (the program-reduction) such that Ψn
n (K =|Ψn|) for each n ∈ N. The following proposition
is on Σn and L=n = Ψ−1
shows closure of P(V) also under program-reductions.

Proposition 2.2 ([7, Proposition 3.3.12 and Corollary 3.4.3]). Let Σ and Γ be
two alphabets. Let V be a variety of monoids. Given K ⊆ Γ∗ in P(V, s(n))
for s : N → N and L ⊆ Σ∗ from which there exists a program-reduction to K of
length t(n), for t : N → N, we have that L ∈ P(V, s(t(n))). In particular, when
K is recognised (classically) by a monoid in V, we have that L ∈ P(V, t(n)).

2.2 Tameness and the variety J

We won’t introduce any of the proposed notions of tameness but will only state
that the main consequence for a variety of monoids V to be tame in the sense
of [8] is that P(V) ∩ Reg ⊆ L(QV). This consequence has far-reaching im-
plications from a computational-complexity-theoretic standpoint when P(V)
happens to be equal to a circuit complexity class. For instance, tameness for
A implies that P(A) ∩ Reg ⊆ L(QA), which is equivalent to the fact that AC0

4

does not contain the language MODm of words over {0, 1} containing a number
of 1s not divisible by m for any m ∈ N, m ≥ 2 (a central result in complexity
theory [6, 1]).

Let us now deﬁne the variety of monoids J. A ﬁnite monoid M of idempotent
power ω belongs to J if and only if (xy)ω = (xy)ωx = y(xy)ω for all x, y ∈ M .
It is a strict subvariety of the variety DA, containing all ﬁnite monoids M of
idempotent power ω such that (xy)ω = (xy)ωx(xy)ω for all x, y ∈ M , itself a
strict subvariety of A. The variety J is a “small” one, well within A.

We now give some speciﬁc deﬁnitions and results about J that we will use,

based essentially on [9], but also on [15, Chapter 4, Section 1].

For some alphabet Σ and each k ∈ N, let us deﬁne the equivalence relation
∼k on Σ∗ by u ∼k v if and only if u and v have the same set of k-subwords
(subwords of length at most k), for all u, v ∈ Σ∗. The relation ∼k is a congruence
of ﬁnite index on Σ∗. For an alphabet Σ and a word u ∈ Σ∗, we shall write
u (cid:1) Σ∗ for the language of all words over Σ having u as a subword.
In the
following, we consider that (cid:1) has precedence over ∪ and ∩ (but of course not
over concatenation).

We deﬁne the class of piecewise testable languages PT as the class of regular
languages such that for every alphabet Σ, we associate to Σ∗ the set PT (Σ∗)
of all languages over Σ that are Boolean combinations of languages of the form
u (cid:1) Σ∗ where u ∈ Σ∗. In fact, PT (Σ∗) is the set of languages over Σ equal
to a union of ∼k-classes for some k ∈ N (see [18]). Simon showed [18] that a
language is piecewise testable if and only if its syntactic monoid is in J, i.e.
PT = L(J).

We can deﬁne a hierarchy of piecewise testable languages in a natural way.
For k ∈ N, let the class of k-piecewise testable languages PT k be the class of
regular languages such that for every alphabet Σ, we associate to Σ∗ the set
PT k(Σ∗) of all languages over Σ that are Boolean combinations of languages
of the form u (cid:1) Σ∗ where u ∈ Σ∗ with |u| ≤ k. We then have that PT k(Σ∗) is
the set of languages over Σ equal to a union of ∼k-classes. Let us deﬁne Jk the
inclusion-wise smallest variety of monoids containing the quotients of Σ∗ by ∼k
for any alphabet Σ: we have that a language is k-piecewise testable if and only
if its syntactic monoid belongs to Jk, i.e. PT k = L(Jk). (See [9, Section 3].)

3 Fine Hierarchy

The ﬁrst part of our investigation of the computational power of programs
over monoids in J concerns the inﬂuence of the length of programs on their
computational capabilities.

We say two programs over a same monoid on the same set of input words are
equivalent if and only if they recognise the same languages. Tesson and Thérien
proved in [23] that for any monoid M in DA, there exists some k ∈ N such that
for any alphabet Σ there is a constant c ∈ N>0 verifying that any program over
M on Σn for n ∈ N is equivalent to a program over M on Σn of length at most
c · nk. Since J ⊂ DA, any monoid in J does also have this property. However,
this does not imply that there exists some k ∈ N working for all monoids in J,
i.e. that P(J) collapses to P(cid:0)J, nk(cid:1).

In this section, we show on the one hand that, as for DA, while P(J, s(n))
collapses to P(J) for any super-polynomial function s : N → N, there does not

5

exist any k ∈ N such that P(J) collapses to P(cid:0)J, nk(cid:1); and on the other hand
that P(Jk) does optimally collapse to P(cid:0)Jk, n(cid:100)k/2(cid:101)(cid:1) for each k ∈ N.

3.1 Strict hierarchy

Given k, n ∈ N, we say that σ is a k-selector over n if σ is a function of
P([n])[n]k
that associates a subset of [n] to each vector in [n]k. For any sequence
∆ = (σn)n∈N such that σn is a k-selector over n for each n ∈ N — a sequence we
will call a sequence of k-selectors —, we set L∆ = (cid:83)
n∈N Kn,σn , where for each
n ∈ N, the language Kn,σn is the set of words over {0, 1} of length (k + 1) · n
that can be decomposed into k + 1 consecutive blocks u(1), u(2), . . . , u(k), v of n
letters where the ﬁrst k blocks each contain 1 exactly once and uniquely deﬁne
a vector ρ in [n]k, where for all i ∈ [k], ρi is given by the position of the only 1
in u(i) (i.e. u(i)
ρi = 1) and v is such that there exists j ∈ σn(ρ) verifying that vj
is 1. Observe that for any k-selector σ0 over 0, we have K0,σ0 = ∅.

We now proceed similarly to what has been done in Subsection 5.1 in [8] to
show, on one hand, that for all k ∈ N, there is a monoid Mk in J2k+1 such that
for any sequence of k-selectors ∆, the language L∆ is recognised by a sequence
of programs over Mk of length at most nk+1; and, on the other hand, that for
all k ∈ N there is a sequence of k-selectors ∆ such that for any ﬁnite monoid
M and any sequence of programs (Pn)n∈N over M of length at most nk, the
language L∆ is not recognised by (Pn)n∈N.

We obtain the following proposition; the proof can be found in Appendix A.
Proposition 3.1. For all k ∈ N, we have P(cid:0)J, nk(cid:1) ⊂ P(cid:0)J, nk+1(cid:1). More pre-
(cid:7) − 1, we have P(cid:0)Jk, nd(cid:1) ⊂ P(cid:0)Jk, nd+1(cid:1).
cisely, for all k ∈ N and d ∈ N, d ≤ (cid:6) k

2

3.2 Collapse

Looking at Proposition 3.1, it looks at ﬁrst glance rather strange that, for each
k ∈ N, we can only prove strictness of the hierarchy inside P(Jk) up to exponent
(cid:6) k
(cid:7). We now show, in a way similar to Subsection 5.2 in [8], that in fact
2
P(Jk) does collapse to P(cid:0)Jk, n(cid:100)k/2(cid:101)(cid:1) for all k ∈ N, showing Proposition 3.1
to be optimal in some sense. Due to space constraints, we leave the proof to
Appendix A.

Proposition 3.2. Let k ∈ N. Let M ∈ Jk and Σ be an alphabet. Then there
exists a constant c ∈ N>0 such that any program over M on Σn for n ∈ N is
equivalent to a program over M on Σn of length at most c · n(cid:100)k/2(cid:101).

In particular, P(Jk) = P(cid:0)Jk, n(cid:100)k/2(cid:101)(cid:1) for all k ∈ N.

4 Regular Languages in P(J)

The second part of our investigation of the computational power of programs
over monoids in J is dedicated to understanding exactly what regular languages
can be p-recognised by monoids in J.

6

4.1 Non-tameness of J

It is shown in [8] that P(J) ∩ Reg (cid:42) L(QJ), thus giving an example of a well-
known subvariety of A for which p-recognition allows to do unexpected things
when recognising a regular language. How far does this unexpected power go?
The ﬁrst thing to notice is that, though none of them is in L(QJ), all
languages of the form Σ∗u and uΣ∗ for Σ an alphabet and u ∈ Σ+ are in
P(J). Indeed, each of them can be recognised by a sequence of constant-length
programs over the syntactic monoid of u (cid:1) Σ∗:
for every input length, just
output the image, through the syntactic morphism of u (cid:1) Σ∗, of the word made
of the |u| ﬁrst or last letters. So, informally stated, programs over monoids in
J can check for some constant-length beginning or ending of their input words.
Indeed, the language (a + b)∗ac+ does not
belong to L(QJ) (compute the stable monoid), yet it is in P(J). The cru-
cial insight is that it can be program-reduced in linear length to the piecewise
testable language of all words over {a, b, c} having ca as a subword but not
the subwords cca, caa and cb by using the following trick (that we shall call
“feedback-sweeping”) for input length n ∈ N: read the input letters in the order
2, 1, 3, 2, 4, 3, 5, 4, . . . , n, n−1, output the letters read. This has already been ob-
served in [8, Proposition 5]; here we give a formal proof of the following lemma,
to be found in Appendix B.

But they can do much more.

Lemma 4.1. (a + b)∗ac+ ∈ P(J, n).

Using variants of the “feedback-sweeping” reading technique, we can prove

that the phenomenon just described is not an isolated case.

Lemma 4.2. The languages (a + b)∗ac+, (a + b)∗ac+a(a + b)∗, c+a(a + b)∗ac+,
(a + b)∗bac+ and (a + b)∗ac+(a + b)∗ac+ do all belong to P(J) \ L(QJ).

Hence, we are tempted to say that there are “much more” regular languages
in P(J) than just those in L(QJ), even though it is not clear to us whether
L(QJ) ⊆ P(J) or not. But can we show any upper bound on P(J) ∩ Reg? It
turns out that we can, relying on two known results.

First, since J ⊆ DA, we have P(J) ⊆ P(DA), so Theorem 6 in [8], that

states P(DA) ∩ Reg = L(QDA), implies that P(J) ∩ Reg ⊆ L(QDA).

Second, let us deﬁne an important superclass of the class of piecewise test-
able languages. Let Σ be an alphabet and u1, . . . , uk ∈ Σ+ (k ∈ N>0); we deﬁne
[u1, . . . , uk] = Σ∗u1Σ∗ · · · Σ∗ukΣ∗. The class of dot-depth one languages is the
class of Boolean combinations of languages of the form Σ∗u, uΣ∗ and [u1, . . . , uk]
for Σ an alphabet, k ∈ N>0 and u, u1, . . . , uk ∈ Σ+. The inclusion-wise smal-
lest variety of semigroups containing all syntactic semigroups of dot-depth one
languages is denoted by J ∗ D and veriﬁes that L(J ∗ D) is exactly the class of
dot-depth one languages. (See [19, 11, 16].) It has been shown in [11, Corollary
8] that P(J ∗ D) ∩ Reg = L(Q(J ∗ D)) (if we extend the program-over-monoid
formalism in the obvious way to ﬁnite semigroups). Now, we have J ⊆ J ∗ D,
so that P(J) ⊆ P(J ∗ D) and hence P(J) ∩ Reg ⊆ L(Q(J ∗ D)).

To summarise, we have the following.

Proposition 4.3. P(J) ∩ Reg ⊆ L(QDA) ∩ L(Q(J ∗ D)).

In fact, we conjecture that the inverse inclusion does also hold.

7

Conjecture 1. P(J) ∩ Reg = L(QDA) ∩ L(Q(J ∗ D)).

Why do we think this should be true? Though, for a given alphabet Σ, we
cannot decide whether some word u ∈ Σ+ of length at least 2 appears as a factor
of any given word w in Σ∗ with programs over monoids in J (because Σ∗uΣ∗ /∈
L(QDA)), Lemma 4.2 and the possibilities oﬀered by the “feedback-sweeping”
technique give the impression that we can do it when we are guaranteed that
u appears at most a ﬁxed number of times in w, which seems somehow to be
what dot-depth one languages become when restricted to belong to L(QDA).
This intuition motivates the deﬁnition of threshold dot-depth one languages.

4.2 Threshold dot-depth one languages

The idea behind the deﬁnition of threshold dot-depth one languages is that
we take the basic building blocks of dot-depth one languages, of the form
[u1, . . . , uk] for an alphabet Σ, for k ∈ N>0 and u1, . . . , uk ∈ Σ+, and restrict
them so that, given l ∈ N>0, membership of a word does really depend on the
presence of a given word ui as a factor if and only if it appears less than l times
as a subword.

Deﬁnition 4.4. Let Σ be an alphabet. For all u ∈ Σ+ and l ∈ N>0, we deﬁne
[u]l to be the language of words over Σ containing ul as a subword or u as a
factor, i.e. [u]l = Σ∗uΣ∗ ∪ ul (cid:1) Σ∗. Then, for all u1, . . . , uk ∈ Σ+ (k ∈ N, k ≥ 2)
and l ∈ N>0, we deﬁne [u1, . . . , uk]l = [u1]l · · · [uk]l.

Obviously, for each Σ an alphabet, k ∈ N>0 and u1, . . . , uk ∈ Σ+, the
language [u1, . . . , uk]1 equals u1 · · · uk (cid:1) Σ∗. Over {a, b, c}, the language [ab, c]3
contains all words containing a letter c verifying that in the preﬁx up to that
letter, ababab appears as a subword or ab appears as a factor. Finally, the
language (a+b)∗ac+ over {a, b, c} of Lemma 4.1 is equal to [c, a]2
∩[ac]2.
We then deﬁne a threshold dot-depth one language as any Boolean combina-
tion of languages of the form Σ∗u, uΣ∗ and [u1, . . . , uk]l for Σ an alphabet, for
k, l ∈ N>0 and u, u1, . . . , uk ∈ Σ+.

∩[c, b]2

(cid:123)

(cid:123)

Conﬁrming the intuition brieﬂy given above, the technique of “feedback-
sweeping” can indeed be pushed further to prove that the whole class of threshold
dot-depth one languages is contained in P(J), and we dedicate the remainder
of this section to prove it. Concerning Conjecture 1, our intuition leads us
to believe that, in fact, the class of threshold dot-depth one languages with
additional positional modular counting is exactly L(QDA) ∩ L(Q(J ∗ D)). We
simply refer the interested reader to Section 5.4 of the author’s Ph.D. thesis [7],
that contains a partial result supporting this belief, too technical and long to
be presented here.

Let us now move on to the proof of the following theorem.

Theorem 4.5. Every threshold dot-depth one language belongs to P(J).

As P(J) is closed under Boolean operations (Proposition 2.1), our goal is to
prove, given an alphabet Σ, given l ∈ N>0 and u1, . . . , uk ∈ Σ+ (k ∈ N>0), that
[u1, . . . , uk]l is in P(J); the case of Σ∗u and uΣ∗ for u ∈ Σ+ is easily handled
(see the discussion at the beginning of Subsection 4.1). To do this, we need to
It is readily seen that [u1, . . . , uk]l =
put [u1, . . . , uk]l in some normal form.
(cid:83)
(ui,qi)’s are deﬁned thereafter.

(uk,qk) where the L(l)

q1,...,qk∈{1,l} L(l)

(u1,q1) · · · L(l)

8

Deﬁnition 4.6. Let Σ be an alphabet.

For all u ∈ Σ+, l ∈ N>0 and α ∈ [l], set L(l)

(u,α) =

(cid:40)

Σ∗uΣ∗
ul (cid:1) Σ∗

if α < l
otherwise

.

Building directly a sequence of programs over a monoid in J that decides
L(l)
(u1,q1) · · · L(l)
(uk,qk) for some alphabet Σ and q1, . . . , qk ∈ {1, l} seems however
tricky. We need to split things further by controlling precisely how many times
each ui for i ∈ [k] appears in the right place when it does less than l times.
To do this, we consider, for each α ∈ [l]k, the language Rα
l (u1, . . . , uk) deﬁned
below.

Deﬁnition 4.7. Let Σ be an alphabet.

For all u1, . . . , uk ∈ Σ+ (k ∈ N>0), l ∈ N>0, α ∈ [l]k, we set

Rα

l (u1, . . . , uk) =(u1

αk ) (cid:1) Σ∗∩

α1 · · · uk
(cid:92)

(cid:0)(u1

α1 · · · ui

αi+1 · · · uk

αk ) (cid:1) Σ∗(cid:1)(cid:123)

.

i∈[k],αi<l

Now, for a given α ∈ [l]k, we are interested in the words of Rα

l (u1, . . . , uk)
such that for each i ∈ [k] verifying αi < l, the word ui indeed appears as a factor
in the right place. We thus introduce a last language Sα
l (u1, . . . , uk) deﬁned as
follows.

Deﬁnition 4.8. Let Σ be an alphabet.

For all u1, . . . , uk ∈ Σ+ (k ∈ N>0), l ∈ N>0, α ∈ [l]k, we set

Sα

l (u1, . . . , uk) =

(cid:92)

(cid:0)(u1

α1 · · · ui−1

αi−1)(cid:1)Σ∗(cid:1)ui

(cid:0)(ui+1

αi+1 · · · uk

αk )(cid:1)Σ∗(cid:1).

i∈[k],αi<l

l (u1, . . . , uk) and Sα

We now have the normal form we were looking for to prove Theorem 4.5:
is equal to the union, over all α ∈ [l]k, of the intersection of
[u1, . . . , uk]l
Rα
l (u1, . . . , uk). Though rather intuitive, the correctness
of this decomposition is not so straightforward to prove and, actually, we can
only prove it when for each i ∈ [k], the letters in ui are all distinct. (The tedious
proof is to be found in Appendix B.)

Lemma 4.9. Let Σ be an alphabet, l ∈ N>0 and u1, . . . , uk ∈ Σ+ (k ∈ N>0)
such that for each i ∈ [k], the letters in ui are all distinct. Then,

(cid:91)

(u1,q1) · · · L(l)
L(l)

(uk,qk) =

q1,...,qk∈{1,l}

(cid:91)

α∈[l]k

(cid:0)Rα

l (u1, . . . , uk) ∩ Sα

l (u1, . . . , uk)(cid:1) .

Our goal now is to prove, given an alphabet Σ, given l ∈ N>0 and u1, . . . , uk ∈
Σ+ (k ∈ N>0) such that for each i ∈ [k], the letters in ui are all distinct, that
for any α ∈ [l]k, the language Rα
l (u1, . . . , uk)∩Sα
l (u1, . . . , uk) is in P(J); closure
of P(J) under union (Proposition 2.1) consequently entails that [u1, . . . , uk]l ∈
P(J). The way Rα
l (u1, . . . , uk) are deﬁned allows us to
reason as follows. For each i ∈ [k] verifying αi < l, let Li be the language
αi+1xi,2
of words w over Σ containing xi,1ui
and such that w = y1uiy2 with y1 ∈ xi,1 (cid:1) Σ∗ and y2 ∈ xi,2 (cid:1) Σ∗, where
xi,1 = u1
If we manage to prove

αi xi,2 as a subword but not xi,1ui

l (u1, . . . , uk) and Sα

αi−1 and xi,2 = ui+1

α1 · · · ui−1

αi+1 · · · uk

αk .

9

l (u1, . . . , uk) = (u1

l (u1, . . . , uk) ∩ Sα

that for each i ∈ [k] verifying αi < l we have Li ∈ P(J), we can conclude that
Rα
i∈[k],αi<l Li does
belong to P(J) by closure of P(J) under intersection, Proposition 2.1. The
lemma that follows, the main lemma in the proof of Theorem 4.5, exactly shows
this. The proof crucially uses the “feedback sweeping” technique, but note that
we actually don’t know how to prove it when we do not enforce that for each
i ∈ [k], the letters in ui are all distinct.

αk ) (cid:1) Σ∗ ∩ (cid:84)

α1 · · · uk

Lemma 4.10. Let Σ be an alphabet and u ∈ Σ+ such that its letters are all
distinct. For all α ∈ N>0 and x1, x2 ∈ Σ∗, we have

(x1uαx2) (cid:1) Σ∗ ∩ (cid:0)(x1uα+1x2) (cid:1) Σ∗(cid:1)(cid:123)

∩ (x1 (cid:1) Σ∗)u(x2 (cid:1) Σ∗) ∈ P(J) .

Sketch. Let Σ be an alphabet and u ∈ Σ+ such that its letters are all distinct.
Let α ∈ N>0 and x1, x2 ∈ Σ∗. We let

L = (x1uαx2) (cid:1) Σ∗ ∩ (cid:0)(x1uα+1x2) (cid:1) Σ∗(cid:1)(cid:123)

∩ (x1 (cid:1) Σ∗)u(x2 (cid:1) Σ∗) .

If |u| = 1, the lemma follows trivially because L is piecewise testable and hence
belongs to L(J), so we assume |u| > 1.

For each letter a ∈ Σ, we shall use 2 |u| − 1 distinct decorated letters of the
form a(i) for some i ∈ [[0, 2 |u| − 2]], using the convention that a(0) = a; of course,
for two distinct letters a, b ∈ Σ, we have that a(i) and b(j) are distinct for all
i, j ∈ [[0, 2 |u| − 2]]. We denote by A the alphabet of these decorated letters. The
main idea of the proof is, for a given input length n ∈ N, to build an A-program
Ψn over Σn such that, given an input word w ∈ Σn, it ﬁrst ouputs the |u| − 1
ﬁrst letters of w and then, for each i going from |u| to n, outputs wi, followed by
w(1)
i−1 · · · w(|u|−1)
i−|u|+1 (a “sweep” of |u|−1 letters backwards down to position i−|u|+
1, decorating the letters incrementally) and ﬁnally by w(|u|)
(a
“sweep” forwards up to position i, continuing the incremental decoration of the
letters). The idea behind this way of rearranging and decorating letters is that,
given an input word w ∈ Σn, as long as we make sure that w and thus Ψn(w) do
contain x1uαx2 as a subword but not x1uα+1x2, then Ψn(w) can be decomposed
as Ψn(w) = y1zy2 where y1 ∈ x1 (cid:1) Σ∗, y2 ∈ x2 (cid:1) Σ∗, and |y1| , |y2| are minimal,
with z containing uβu(1)
u(|u|)
uα−β as a subword for
2
some β ∈ [α] if and only if w ∈ (x1 (cid:1) Σ∗)u(x2 (cid:1) Σ∗). This means we can check
whether w ∈ L by testing whether w belongs to some ﬁxed piecewise testable
language over A.

i−|u|+2 · · · w(2|u|−2)

|u|−1 · · · u(|u|−1)

· · · u(2|u|−2)
|u|

1

i

The full proof can be found in Appendix B.

As explained before stating the previous lemma, we can now use it to prove
the result we were aiming for. The detailed proof can be found in Appendix B.

Proposition 4.11. Let Σ be an alphabet, l ∈ N>0 and u1, . . . , uk ∈ Σ+ (k ∈
N>0) such that for each i ∈ [k], the letters in ui are all distinct. For all α ∈ [l]k,
we have Rα
l (u1, . . . , uk) ∈ P(J).

l (u1, . . . , uk) ∩ Sα

We thus derive the awaited corollary.

Corollary 4.12. Let Σ be an alphabet, l ∈ N>0 and u1, . . . , uk ∈ Σ+ (k ∈ N>0)
such that for each i ∈ [k], the letters in ui are all distinct. Then, [u1, . . . , uk]l ∈
P(J).

10

However, what we really want to obtain is that [u1, . . . , uk]l ∈ P(J) without
putting any restriction on the ui’s. But, in fact, to remove the constraint that
the letters must be all distinct in each of the ui’s, we simply have to decorate each
of the input letters with its position minus 1 modulo a big enough d ∈ N>0. This
ﬁnally leads to the following proposition; as usual, the proof is in Appendix B.

Proposition 4.13. Let Σ be an alphabet, l ∈ N>0 and u1, . . . , uk ∈ Σ+ (k ∈
N>0). Then [u1, . . . , uk]l ∈ P(J).

This ﬁnishes to prove Theorem 4.5 by closure of P(J) under Boolean com-
binations (Proposition 2.1) and by the discussion at the beginning of Subsec-
tion 4.1.

5 Conclusion

Although P(J) is very small compared to AC0, we have shown that programs
over monoids in J are an interesting subject of study in that they allow to
do quite unexpected things. The “feedback-sweeping” technique allows one to
detect presence of a factor thanks to such programs as long as this factor does
not appear too often as a subword: this is the basic principle behind threshold
dot-depth one languages, that our article shows to belong wholly to P(J).

Whether threshold dot-depth one languages with additional positional mod-
ular counting do correspond exactly to the languages in L(QDA)∩L(Q(J ∗ D))
seems to be a challenging question, that we leave open. In his Ph.D. thesis [7],
the author proved that all strongly unambiguous monomials (the basic building
blocks in L(DA)) that are imposed to belong to L(J ∗ D) at the same time are in
fact threshold dot-depth one languages. However, the proof looks much too com-
plex and technical to be extended to, say, all languages in L(DA) ∩ L(J ∗ D).
New techniques are probably needed, and we might conclude by saying that
proving (or disproving) this conjecture could be a nice research goal in algebraic
automata theory.

Acknowledgements The author thanks the anonymous referees for their
helpful comments and suggestions.

References

[1] M. Ajtai. Σ1

1-formulae on ﬁnite structures. Annals of pure and applied

logic, 24(1):1–48, 1983.

[2] D. A. M. Barrington. Bounded-width polynomial-size branching programs
recognize exactly those languages in NC1. J. Comput. Syst. Sci., 38(1):150–
164, 1989.

[3] D. A. M. Barrington and D. Thérien. Finite monoids and the ﬁne structure

of NC1. J. ACM, 35(4):941–952, 1988.

[4] S. Eilenberg. Automata, Languages, and Machines, volume A. Academic

Press, New York, 1974.

11

[5] S. Eilenberg. Automata, Languages, and Machines, volume B. Academic

Press, New York, 1976.

[6] M. L. Furst, J. B. Saxe, and M. Sipser. Parity, circuits, and the polynomial-

time hierarchy. Mathematical Systems Theory, 17(1):13–27, 1984.

[7] N. Grosshans. The limits of Nečiporuk’s method and the power of programs
over monoids taken from small varieties of ﬁnite monoids. PhD thesis,
University of Paris-Saclay, France, 2018.

[8] N. Grosshans, P. McKenzie, and L. Segouﬁn. The power of programs over
monoids in DA. In MFCS 2017, August 21-25, 2017 - Aalborg, Denmark,
pages 2:1–2:20, 2017.

[9] O. Klíma and L. Polák. Hierarchies of piecewise testable languages. Int. J.

Found. Comput. Sci., 21(4):517–533, 2010.

[10] C. Lautemann, P. Tesson, and D. Thérien. An algebraic point of view
on the Crane Beach property. In CSL 2006, Szeged, Hungary, September
25-29, 2006, pages 426–440, 2006.

[11] A. Maciel, P. Péladeau, and D. Thérien. Programs over semigroups of

dot-depth one. Theor. Comput. Sci., 245(1):135–148, 2000.

[12] P. McKenzie, P. Péladeau, and D. Thérien. NC1: The automata-theoretic

viewpoint. Computational Complexity, 1:330–359, 1991.

[13] P. Péladeau. Classes de circuits booléens et variétés de monoïdes. PhD
thesis, Université Pierre-et-Marie-Curie (Paris-VI), Paris, France, 1990.

[14] P. Péladeau, H. Straubing, and D. Thérien. Finite semigroup varieties
deﬁned by programs. Theor. Comput. Sci., 180(1-2):325–339, 1997.

[15] J. Pin. Varieties Of Formal Languages. Plenum Publishing Co., 1986.

[16] J. Pin. The dot-depth hierarchy, 45 years later. In The Role of Theory in
Computer Science - Essays Dedicated to Janusz Brzozowski, pages 177–202,
2017.

[17] J. Pin and H. Straubing. Some results on C-varieties. ITA, 39(1):239–262,

2005.

[18] I. Simon. Piecewise testable events.

In Automata Theory and Formal
Languages, 2nd GI Conference, Kaiserslautern, May 20-23, 1975, pages
214–222, 1975.

[19] H. Straubing. Finite semigroup varieties of the form V ∗ D. Journal of

Pure and Applied Algebra, 36:53–94, 1985.

[20] H. Straubing. When can one ﬁnite monoid simulate another?

In Al-
gorithmic Problems in Groups and Semigroups, pages 267–288. Springer,
2000.

[21] H. Straubing. Languages deﬁned with modular counting quantiﬁers. Inf.

Comput., 166(2):112–132, 2001.

12

[22] P. Tesson. Computational Complexity Questions Related to Finite Monoids

and Semigroups. PhD thesis, McGill University, Montreal, 2003.

[23] P. Tesson and D. Thérien. The computing power of programs over ﬁnite

monoids. J. Autom. Lang. Comb., 7(2):247–258, 2001.

13

A Missing Proofs from Section 3

A.1 Proof of Proposition 3.1

Upper bound. We start with the upper bound. Given k ∈ N, we deﬁne the
alphabet Yk = {e, #} ∪ {⊥l, (cid:62)l | l ∈ [k]}; we are going to prove that for all
k ∈ N there exists a language Zk ∈ PT 2k+1(Y ∗
k ) such that for all ∆ = (σn)n∈N
sequences of k-selectors, there exists a program-reduction from L∆ to Zk of
length at most 2 · (k + 1)−k · nk+1. To this end, we use the following proposition
and the fact that the language of words of length n ∈ N of L∆ is exactly Kn(cid:48),σn(cid:48)
when there exists n(cid:48) ∈ N verifying n = (k + 1) · n(cid:48) and ∅ otherwise.

Proposition A.1. For all k ∈ N there is a language Zk ∈ PT 2k+1(Y ∗
k ) such
that ε /∈ Zk and for all n ∈ N and all k-selectors σn over n, we have Kn,σn =
Ψ−1
) where Ψ(k+1)·n,σn is a Yk-program on {0, 1}(k+1)·n
of length at most 2 · (k + 1) · nk+1.

=|Ψ(k+1)·n,σn |
k

(k+1)·n,σn

(Z

Proof. We ﬁrst deﬁne by induction on k a family of languages Zk over the
0 . For k ∈ N>0, the language Zk is
alphabet Yk. For k = 0, set Z0 = Y ∗
0 #Y ∗
the set of words containing each of (cid:62)k and ⊥k exactly once, the ﬁrst before
the latter, and verifying that the factor between the occurrence of (cid:62)k and the
occurrence of ⊥k belongs to Zk−1, i.e. Zk = Y ∗
k−1. A simple
induction on k shows that Zk for k ∈ N is deﬁned by the expression

k−1(cid:62)kZk−1⊥kY ∗

k−1(cid:62)kY ∗
Y ∗

k−2(cid:62)k−1 · · · Y ∗

1 (cid:62)2Y ∗

0 (cid:62)1Y ∗

0 #Y ∗

0 ⊥1Y ∗

0 ⊥2Y ∗

1 · · · ⊥k−1Y ∗

k−2⊥kY ∗

k−1 ,

hence it belongs to PT 2k+1(Y ∗
word ε.

k ) and in particular does not contain the empty

Fix n ∈ N. If n = 0, the proposition follows trivially since for any k-selector
σ0 over 0, we have K0,σ0 = ∅ and ε /∈ Zk; otherwise, we deﬁne by induction
on k a Yk-program Pk(d, σ) on {0, 1}(d+k+1)·n for every k-selector σ over n and
every d ∈ N.

For any j ∈ [n] and σ a 0-selector over n, which is just a function in P([n]){ε},
let hj,σ : {0, 1} → Y0 be the function deﬁned by hj,σ(0) = e and hj,σ(1) =
(cid:40)

. For all k ∈ N>0, we also let fk and gk be the functions in

# if j ∈ σ(ε)
e
otherwise
{0,1} deﬁned by fk(0) = gk(0) = e, fk(1) = (cid:62)k and gk(1) = ⊥k. Moreover,
Yk
for any k-selector σ over n, the symbol σ|j for j ∈ [n] denotes the (k − 1)-
selector over n such that for all ρ(cid:48) ∈ [n]k−1, we have i ∈ σ|j(ρ(cid:48)) if and only if
i ∈ σ((j, ρ(cid:48))).

For k ∈ N>0, for d ∈ N and σ a k-selector over n, the Yk-program Pk(d, σ)

on {0, 1}(d+k+1)·n is the following sequence of instructions:

(d · n + 1, fk)Pk−1(d + 1, σ|1)(d · n + 1, gk)
· · ·(d · n + n, fk)Pk−1(d + 1, σ|n)(d · n + n, gk) .

In words, for each position i ∈ [[d · n + 1, d · n + n]] with a 1 in the (d + 1)-th block
of n letters in the input, the program runs, between the symbols (cid:62)k and ⊥k,
the program Pk−1(d + 1, σ|i) obtained by induction for σ|i the (k − 1)-selector
over n obtained by restricting σ to all vectors in [n]k whose ﬁrst coordinate is i.

14

For k = 0, for d ∈ N and σ a 0-selector over n, the Y0-program P0(d, σ) on

{0, 1}(d+1)·n is the following sequence of instructions:

(d · n + 1, h1,σ)(d · n + 2, h2,σ) · · · (d · n + n, hn,σ) .

In words, for each position i ∈ [[d · n + 1, d · n + n]] with a 1 in the (d + 1)-th
block of n letters in the input, the program outputs # if and only if (i − d · n)
does belong to the set σ(ε).

In short, Pk(d, σ) is designed so that for any w ∈ {0, 1}(d+k+1)·n, the word
Pk(d, σ)(w) belongs to Zk if and only if the last (k + 1) · n letters of w form a
word of Kn,σ.

A simple computation shows that for any k ∈ N, any d ∈ N and σ a k-selector

over n, the number of instructions in Pk(d, σ) is at most 2 · (k + 1) · nk+1.

A simple induction on k shows that for any k ∈ N and d ∈ N, when running
on a word w ∈ {0, 1}(d+k+1)·n, for any σ a k-selector over n, the program
Pk(d, σ) returns a word in Zk if and only if when u(1), u(2), . . . , u(k), v are the
last k + 1 consecutive blocks of n letters of w, then u(1), u(2), . . . , u(k) each
contain 1 exactly once and deﬁne the vector ρ in [n]k where for all i ∈ [k], the
value ρi is given by the position of the only 1 in u(i), verifying that there exists
j ∈ σn(ρ) such that vj is 1.

Therefore, for any k ∈ N and σn a k-selector over n, if we set Ψ(k+1)·n,σn =
) where Ψ(k+1)·n,σn is a
(Z

Pk(0, σn), we have Kn,σn = Ψ−1
Yk-program on {0, 1}(k+1)·n of length at most 2 · (k + 1) · nk+1.

=|Ψ(k+1)·n,σn |
k

(k+1)·n,σn

Consequently, for all k ∈ N and any sequence of k-selectors ∆, since the
k ) and thus recognised by a monoid from J2k+1,

language Zk is in PT 2k+1(Y ∗
we have, by Proposition 2.2, that L∆ ∈ P(cid:0)J2k+1, nk+1(cid:1).

Lower bound. For the lower bound, we use the following claim, whose proof
can be found in [8, Claim 10].

Claim A.2. For all i ∈ N>0 and n ∈ N, the number of languages in {0, 1}n
recognised by programs over a monoid of order i on {0, 1}n, with at most l ∈ N
instructions, is upper-bounded by ii2

2i · (n · i2)l.

If for some k ∈ N and i ∈ [α] with α ∈ N>0, we apply this claim for all n ∈ N
and l = α · ((k + 1) · n)k, we get a number µi(n) of languages in {0, 1}(k+1)·n
recognised by programs over a monoid of order i on {0, 1}(k+1)·n with at most
l instructions that is in 2O(nk log2(n)), which is asymptotically strictly smaller
than the number of distinct Kn,σn when the k-selector σn over n varies, which
is 2nk+1

, i.e. µi(n) is in o(2nk+1

Hence, for all j ∈ N>0, there exist an nj ∈ N and τj a k-selector over nj such
that no program over a monoid of order i ∈ [j] on {0, 1}(k+1)·nj and of length
at most j · ((k + 1) · nj)k recognises Knj ,τj . Moreover, we can assume without
loss of generality that the sequence (nj)j∈N>0 is increasing. Let ∆ = (σn)n∈N be
such that σnj = τj for all j ∈ N>0 and σn : [n]k → P([n]), ρ (cid:55)→ ∅ for any n ∈ N
verifying that it is not equal to any nj for j ∈ N>0. We show that no sequence
of programs over a ﬁnite monoid of length O(nk) can recognise L∆. If this were
the case, then let i be the order of the monoid. Let j ∈ N, j ≥ i be such that for
any n ∈ N, the n-th program has length at most j · nk. But, by construction, we

).

15

know that there does not exist any such program on {0, 1}(k+1)·nj recognising
Knj ,τj , a contradiction.

This implies that for all k ∈ N, we have P(cid:0)J, nk(cid:1) ⊂ P(cid:0)J, nk+1(cid:1) and addi-
(cid:7) − 1, we have P(cid:0)Jk, nd(cid:1) ⊂ P(cid:0)Jk, nd+1(cid:1), since

tionally that for all d ∈ N, d ≤ (cid:6) k
any monoid from Jd is also a monoid from Jk.

2

A.2 Proof of Proposition 3.2

Actually, the equivalent shorter program we give is even a subprogram of the
original one, i.e. a subsequence of the latter. For P some program over a
ﬁnite monoid M , we may denote by ξP the function that associates to each
possible input word w the word in M |P | obtained by successively evaluating the
instructions of P for w.

Observe that given P a program over some ﬁnite monoid M on Σn for n ∈ N
and Σ an alphabet, a subprogram P (cid:48) of P is equivalent to P if and only if for
every language K ⊆ M ∗ recognised by the evaluation morphism ηM of M ,
the unique morphism from M ∗ to M extending the identity on M , we have
ξP (w) ∈ K ⇔ ξP (cid:48)(w) ∈ K for all w ∈ Σn. Moreover, every language recognised
by ηM is precisely a language of PT k(M ∗) when M ∈ Jk for some k ∈ N.

The result is hence a consequence of the following lemma and the fact that
every language in PT k(M ∗) is a union of ∼k-classes, each of those classes cor-
responding to all words over M having the same set of k-subwords, that is
ﬁnite.

Lemma A.3. Let Σ be an alphabet and M a ﬁnite monoid.

For all k ∈ N, there exists a constant c ∈ N>0 verifying that for any program
P over M on Σn for n ∈ N and any word t ∈ M k, there exists a subprogram Q
of P of length at most c · n(cid:100)k/2(cid:101) such that for any subprogram Q(cid:48) of P that has
Q as a subprogram, we have that t is a subword of ξP (w) if and only if t is a
subword of ξQ(cid:48)(w) for all w ∈ Σn.

Proof. A program P over M on Σn for n ∈ N is a ﬁnite sequence (pi, fi) of
instructions where each pi is a positive natural number which is at most n and
each fi is a function from Σ to M . We denote by l the number of instructions
of P . For each set I ⊆ [l] we denote by P [I] the subprogram of P consisting
of the subsequence of instructions of P obtained after removing all instructions
whose index is not in I. When I = [[i, j]] for some i, j ∈ [l], we may write P [i, j]
instead of P [I].

We prove the lemma by induction on k, ﬁxing the constant to be ck =

k! · |Σ|(cid:100)k/2(cid:101) for a given k ∈ N.

The intuition behind the proof for a program P on inputs of length n and
some t of length at least 3 is as follows. Given l the length of P , we will select
a subset I of the indices of instructions numbered from 1 to l to obtain P [I]
verifying the conditions of the lemma. Consider all the indices 1 ≤ i1 < i2 <
· · · < is ≤ l that each correspond, for some letter a and some position p in
the input, to the ﬁrst instruction of P that would output the element t1 when
reading a at position p or to the last instruction of P that would output the
element tk when reading a at position p. We then have that, given some w as
input, t is a subword of ξP (w) if and only if there exist 1 ≤ γ < δ ≤ s verifying
that the element at position iγ of ξP (w) is t1, the element at position iδ of ξP (w)

16

is tk and t2 · · · tk−1 is a subword of ξP [iγ +1,iδ−1](w). The idea is then that if
we set I to contain i1, i2, . . . , is as well as all indices obtained by induction for
P [ij + 1, ij+1 − 1] and tα · · · tβ for all 1 ≤ j ≤ s − 1 and 1 < α ≤ β < k, we
would have that for all w, the word t is a subword of ξP (w) if and only if it
is a subword of ξP [I](w), that is ξP (w) where only the elements at indices in I
have been kept. The length upper bound of the order of n(cid:100)k/2(cid:101) would be met
because the number of possible values for j is s − 1, hence at most linear in n,
and the number of possible values for (α, β) is quadratic in k, a constant.

The intuition behind the proof when t is of length less than 3 is essentially

the same, but without induction.

Inductive step. Let k ∈ N, k ≥ 3 and assume the lemma proven for all
k(cid:48) ∈ N, k(cid:48) < k. Let P be a program over M on Σn for n ∈ N of length l ∈ N
and some word t ∈ M k.

Observe that when n = 0, we necessarily have P = ε, so that the lemma is

trivially proven in that case. So we now assume n > 0.

(cid:12)I(1,k)

Let s = (cid:12)

For each p ∈ [n] and each a ∈ Σ consider within the sequence of instructions
of P the ﬁrst instruction of the form (p, f ) with f (a) = t1 and the last instruction
of that form with f (a) = tk, if they exist. We let I(1,k) be the set of indices
of these instructions for all a and p. Notice that the size of I(1,k) is at most
2 · |Σ| · n.

(cid:12)
(cid:12) and let us denote I(1,k) = {i1, i2, . . . , is} where i1 < i2 <
· · · < is. Given α, β ∈ [k], we also set t(α,β) = tαtα+1 · · · tβ. For all α, β ∈ [k]
such that 1 < α ≤ β < k and j ∈ [s − 1], we let Jj,(α,β) be the set of indices of
the instructions within P [ij + 1, ij+1 − 1] appearing in its subprogram obtained
by induction for P [ij + 1, ij+1 − 1] and t(α,β).
We now let I be the union of I(1,k) and J (cid:48)

j,(α,β) = {e + ij | e ∈ Jj,(α,β)} for
all α, β ∈ [k] such that 1 < α ≤ β < k and j ∈ [s − 1] (the translation being
required because the ﬁrst instruction in P [ij + 1, ij+1 − 1] is the (ij + 1)-th
instruction in P ). We claim that Q = P [I], a subprogram of P , has the desired
properties.

First notice that by induction the size of J (cid:48)
1 < α ≤ β < k and j ∈ [s − 1] is upper bounded by

j,(α,β) for all α, β ∈ [k] such that

(β − α + 1)! · |Σ|(cid:100)(β−α+1)/2(cid:101) · n(cid:100)(β−α+1)/2(cid:101) ≤ (k − 2)! · |Σ|(cid:100)(k−2)/2(cid:101) · n(cid:100)(k−2)/2(cid:101) .

Hence, the size of I is at most

(cid:12)
(cid:12)I(1,k)

(cid:12)
(cid:12) +

s−1
(cid:88)

(cid:88)

j=1

1<α≤β<k

(cid:12)
(cid:12)J (cid:48)
(cid:12)

j,(α,β)

(cid:12)
(cid:12)
(cid:12)

≤2 · |Σ| · n + (2 · |Σ| · n − 1) ·

≤2 · |Σ| · n + (2 · |Σ| · n − 1) ·

(k − 1) · (k − 2)
2

· (k − 2)! · |Σ|(cid:100)(k−2)/2(cid:101) · n(cid:100)(k−2)/2(cid:101)

k · (k − 1)
2

· (k − 2)! · |Σ|(cid:100)(k−2)/2(cid:101) · n(cid:100)(k−2)/2(cid:101)

≤k! · |Σ|(cid:100)k/2(cid:101) · n(cid:100)k/2(cid:101) = ck · n(cid:100)k/2(cid:101)
as (cid:12)
(cid:12){(α, β) ∈ N2 | 1 < α ≤ β < k}(cid:12)
2 · |Σ| · n ≤ k!
required length.

and
2 · |Σ|(cid:100)(k−2)/2(cid:101) · n(cid:100)(k−2)/2(cid:101) since k ≥ 3, so that P [I] has at most the

j=1 j = (k−1)·(k−2)

j=2 (k − j) = (cid:80)k−2

(cid:12) = (cid:80)k−1

2

17

Let Q(cid:48) be a subprogram of P that has Q as a subprogram:
there exists some set I (cid:48) ⊆ [l] containing I such that Q(cid:48) = P [I (cid:48)].

it means that

) = t1 and fiδ (wpiδ

Take w ∈ Σn.
Assume now that t is a subword of ξP (w). It means that there exist r1, r2, . . . ,
) = tj. By
rk ∈ [l], r1 < r2 < · · · < rk, such that for all j ∈ [k], we have frj (wprj
deﬁnition of I(1,k), there exist γ, δ ∈ [s], γ < δ, such that iγ ≤ r1 < rk ≤ iδ and
fiγ (wpiγ
) = tk. For each j ∈ [[γ, δ − 1]], let mj ∈ [[2, k]] be the
smallest integer in [[2, k − 1]] such that ij ≤ rmj < ij+1 and k if it does not exist,
and Mj ∈ [[1, k − 1]] be the biggest integer in [[2, k − 1]] such that ij ≤ rMj < ij+1
and 1 if it does not exist. Observe that, since for each j ∈ [[γ, δ − 1]], we
have t(mj ,Mj ) = t(k,1) = ε if there does not exist any o ∈ [[2, k − 1]] verifying
ij ≤ ro < ij+1, it holds that t(2,k−1) = (cid:81)δ−1
j=γ t(mj ,Mj ). For all j ∈ [[γ, δ − 1]],
we have that for any set J ⊆ [ij+1 − ij − 1] containing (cid:83)
1<α≤β<k Jj,(α,β), the
word t(mj ,Mj ) is a subword of fij (wpij
)ξP [ij +1,ij+1−1][J](w) when mj < k and
rmj = ij, and of ξP [ij +1,ij+1−1][J](w) otherwise. Indeed, let j ∈ [[γ, δ − 1]].

) = frmj

• If mj < k and rmj = ij, then fij (wpij

) = tmj and
ij = rmj < rmj +1 < · · · < rMj < ij+1, so t(mj +1,Mj ) is a subword of
ξP [ij +1,ij+1−1](w). This implies, directly when mj = Mj or by induction
otherwise, that for any set J ⊆ [ij+1 −ij −1] containing (cid:83)
1<α≤β<k Jj,(α,β),
the word t(mj +1,Mj ) is a subword of ξP [ij +1,ij+1−1][J](w). This implies in
turn that t(mj ,Mj ) is a subword of fij (wpij

)ξP [ij +1,ij+1−1][J](w).

(wprmj

• Otherwise, when mj = k, there does not exist any o ∈ [[2, k − 1]] verifying
ij ≤ ro < ij+1, so t(mj ,Mj ) = ε is trivially a subword of ξP [ij +1,ij+1−1][J](w)
for any set J ⊆ [ij+1 − ij − 1] containing (cid:83)
1<α≤β<k Jj,(α,β). And when
mj < k but rmj (cid:54)= ij, it means that rmj > ij, hence ij < rmj < rmj +1 <
· · · < rMj < ij+1, so t(mj ,Mj ) is a subword of ξP [ij +1,ij+1−1](w). This
implies, by induction, that t(mj ,Mj ) is a subword of ξP [ij +1,ij+1−1][J](w)
for any set J ⊆ [ij+1 − ij − 1] containing (cid:83)

1<α≤β<k Jj,(α,β).

Therefore, using the convention that i0 = 0 and is+1 = l + 1, if we deﬁne, for
each j ∈ [[0, s]], the set I (cid:48)
j = {e − ij | e ∈ I (cid:48), ij < e < ij+1} as the subset of I (cid:48) of
elements strictly between ij and ij+1 translated by −ij, we have that t(2,k−1) is
a subword of

ξP [iγ +1,iγ+1−1][I (cid:48)

γ ](w)fiγ+1(wpiγ+1
fiδ−1(wpiδ−1

)ξP [iγ+1+1,iγ+2−1][I (cid:48)
)ξP [iδ−1+1,iδ−1][I (cid:48)

δ−1](w)

γ+1](w) · · ·

(since we have rmγ ≥ r2 > r1 ≥ iγ), so that, as fiγ (wpiγ
tk, we have that t = t1t(2,k−1)tk is a subword of

) = t1 and fiδ (wpiδ

) =

ξP [1,i1−1][I (cid:48)
=ξP [I (cid:48)](w) .

0](w)fi1(wpi1

)ξP [i1+1,i2−1][I (cid:48)

1](w) · · · fis(wpis

)ξP [is+1,l][I (cid:48)

s](w)

Assume ﬁnally that t is a subword of ξP [I (cid:48)](w). Then it is obviously a

subword of ξP (w), as ξP [I (cid:48)](w) is a subword of ξP (w).

Therefore, t is a subword of ξP (w) if and only if t is a subword of ξQ(cid:48)(w) =

ξP [I (cid:48)](w), as desired.

18

Base case. There are three subcases to consider.

Subcase k = 2. Let P be a program over M on Σn for n ∈ N of length l ∈ N

and some word t ∈ M 2.

We use the same idea as in the inductive step.
Observe that when n = 0, we necessarily have P = ε, so that the lemma is

trivially proven in that case. So we now assume n > 0.

For each p ∈ [n] and each a ∈ Σ consider within the sequence of instructions
of P the ﬁrst instruction of the form (p, f ) with f (a) = t1 and the last instruction
of that form with f (a) = t2, if they exist. We let I be the set of indices of these
instructions for all a and p. Notice that the size of I is at most 2 · |Σ| · n =
2! · |Σ|(cid:100)2/2(cid:101) · n(cid:100)2/2(cid:101) = c2 · n(cid:100)2/2(cid:101).

We claim that Q = P [I], a subprogram of P , has the desired properties. We

just showed it has at most the required length.

Let Q(cid:48) be a subprogram of P that has Q as a subprogram:
there exists some set I (cid:48) ⊆ [l] containing I such that Q(cid:48) = P [I (cid:48)].

it means that

Take w ∈ Σn.
Assume now that t is a subword of ξP (w).

[l], i1 < i2 such that fi1(wpi1
(cid:48), i2
there exist i1
and fi2
(cid:48)(wpi2
(cid:48) ) = t2. Hence, as fi1
(because I ⊆ I (cid:48)), we get that t = t1t2 is a subword of ξP [I (cid:48)](w).

(cid:48) ≤ i1 < i2 ≤ i2
(cid:48)(wpi2

) = t1 and fi2(wpi2

(cid:48) ∈ I, such that i1

(cid:48)(wpi1

(cid:48) )fi2

It means there exist i1, i2 ∈
) = t2. By deﬁnition of I,
(cid:48) ) = t1
(cid:48) ) is a subword of ξP [I (cid:48)](w)

(cid:48) and fi1

(cid:48)(wpi1

Assume ﬁnally that t is a subword of ξP [I (cid:48)](w). Then it is obviously a

subword of ξP (w), as ξP [I (cid:48)](w) is a subword of ξP (w).

Therefore, t is a subword of ξP (w) if and only if t is a subword of ξQ(cid:48)(w) =

ξP [I (cid:48)](w), as desired.

Subcase k = 1. Let P be a program over M on Σn for n ∈ N of length l ∈ N

and some word t ∈ M 1.

We again use the same idea as before.
Observe that when n = 0, we necessarily have P = ε, so that the lemma is

trivially proven in that case. So we now assume n > 0.

For each p ∈ [n] and each a ∈ Σ consider within the sequence of instructions
of P the ﬁrst instruction of the form (p, f ) with f (a) = t1, if it exists. We let I
be the set of indices of these instructions for all a and p. Notice that the size of
I is at most |Σ| · n = 1! · |Σ|(cid:100)1/2(cid:101) · n(cid:100)1/2(cid:101) = c1 · n(cid:100)1/2(cid:101).

We claim that Q = P [I], a subprogram of P , has the desired properties. We

just showed it has at most the required length.

Let Q(cid:48) be a subprogram of P that has Q as a subprogram:
there exists some set I (cid:48) ⊆ [l] containing I such that Q(cid:48) = P [I (cid:48)].

it means that

Take w ∈ Σn.
Assume now that t is a subword of ξP (w). It means there exists i ∈ [l] such
that fi(wpi ) = t1. By deﬁnition of I, there exists i(cid:48) ∈ I such that i(cid:48) ≤ i and
fi(cid:48)(wpi(cid:48) ) = t1. Hence, as fi(cid:48)(wpi(cid:48) ) is a subword of ξP [I (cid:48)](w) (because I (cid:48) ⊆ I), we
get that t = t1 is a subword of ξP [I (cid:48)](w).

Assume ﬁnally that t is a subword of ξP [I (cid:48)](w). Then it is obviously a

subword of ξP (w), as ξP [I (cid:48)](w) is a subword of ξP (w).

Therefore, t is a subword of ξP (w) if and only if t is a subword of ξQ(cid:48)(w) =

ξP [I (cid:48)](w), as desired.

Subcase k = 0. Let P be a program over M on Σn for n ∈ N of length l ∈ N

and some word t ∈ M 0.

19

We claim that Q = ε, a subprogram of P , has the desired properties.
First notice that the length of Q is 0 ≤ 0! · |Σ|(cid:100)0/2(cid:101) · n(cid:100)0/2(cid:101) = c0 · n(cid:100)0/2(cid:101), at

most the required length.

Let Q(cid:48) be a subprogram of P that has Q as a subprogram. As t ∈ M 0, we
necessarily have that t = ε, which is a subword of any word in M ∗. Therefore,
we immediately get that for all w ∈ Σn, the word t is a subword of ξP (w) if and
only if t is a subword of ξQ(cid:48)(w), as desired.

B Missing Proofs from Section 4

B.1 Proof of Lemma 4.1

Proof of Lemma 4.1. Let Σ = {a, b, c}.

Let

L = ca (cid:1) Σ∗ ∩ (cca (cid:1) Σ∗)(cid:123) ∩ (caa (cid:1) Σ∗)(cid:123) ∩ (cb (cid:1) Σ∗)(cid:123)

be the language of all words over Σ having ca as a subword but not the subwords
cca, caa and cb, that by construction is piecewise testable, i.e. belongs to L(J).
We are now going to build a program-reduction from (a + b)∗ac+ to L. Let
n ∈ N. If n ≤ 1, we set Ψn to be ε, the empty Σ-program on Σn. Otherwise, if
n ≥ 2, we set

Ψn = (2, idΣ)(1, idΣ)(3, idΣ)(2, idΣ)(4, idΣ)(3, idΣ) · · · (n, idΣ)(n − 1, idΣ) .

Let us deﬁne s : N → N by s(n) = |Ψn| for all n ∈ N, which is such that

s(n) =

(cid:40)
if n ≤ 1
0
2n − 2 otherwise (n ≥ 2)

for all n ∈ N. Fix n ∈ N.

Let w ∈ ((a + b)∗ac+)=n: it means n ≥ 2 and there exist u ∈ (a + b)n1 with
n1 ∈ [[0, n−2]] and n2 ∈ [[0, n−2]] verifying that w = uaccn2 and n1 +n2 = n−2.
We therefore have

Ψn(w) =

(cid:40)

cac2n2
u2u1 · · · un1 un1−1aun1 cac2n2

when n1 = 0
otherwise (n1 > 0) ,

a word easily seen to belong to L=2n−2. Since this is true for all w ∈ ((a +
b)∗ac+)=n, it follows that ((a + b)∗ac+)=n ⊆ Ψ−1

n (L=s(n)).
n (L=s(n)). Since this means that Ψn(w) ∈ L=s(n), we

Let conversely w ∈ Ψ−1

necessarily have n ≥ 2 as it must contain ca as a subword, so that

Ψn(w) = w2w1w3w2w4w3 · · · wnwn−1 .

Let i, j ∈ [n] verifying that wi = c, that wj = a and wiwj is a subword of Ψn(w).
This means that j ≥ i−1, and we will now show that, actually, j = i−1. Assume
that j ≥ i+2; by construction, this would mean that wiwjwj = caa is a subword
of Ψn(w), a contradiction to the fact it belongs to L. Assume otherwise that
j = i + 1; by construction, this would either mean that wiwi−1wi+1wi is a
subword of Ψn(w), which would imply one of caa, cba and cca is a subword of
Ψn(w), or that wi+1wiwi+2wi+1 is a subword of Ψn(w), which would imply one

20

of caa, cba and cca is a subword of Ψn(w), in both cases contradicting the fact
Ψn(w) belongs to L. Hence, we indeed have j = i − 1, and in particular that
i ≥ 2. Now, by construction, for each t ∈ [i − 2], we have that wtwiwi−1 = wtca
is a subword of Ψn(w) ∈ L, so that wt cannot be equal to c. Similarly, for
each t ∈ [[i + 1, n]], we have that wiwi−1wt = cawt is a subword of Ψn(w) ∈ L,
so that wt must be equal to c. This means that w1 · · · wi−2 ∈ (a + b)∗ and
wi+1 · · · wn ∈ c∗, so that w ∈ (a + b)∗acc∗ = (a + b)∗ac+. Since this is true for
all w ∈ Ψ−1

n (L=s(n)), it follows that ((a + b)∗ac+)=n ⊇ Ψ−1

n (L=s(n)).

Therefore, we have that ((a + b)∗ac+)=n = Ψ−1

n (L=s(n)) for all n ∈ N, so
(Ψn)n∈N is a program reduction from (a + b)∗ac+ to L of length s(n). So
since L ∈ L(J), we can conclude that (a + b)∗ac+ ∈ P(J, s(n)) = P(J, n) by
Proposition 2.2.

B.2 Proof of Lemma 4.9
Proof of Lemma 4.9. Let Σ be an alphabet and l ∈ N>0. We prove it by induc-
tion on k ∈ N>0.

Base case k = 1. Let u1 ∈ Σ+ such that the letters in u1 are all distinct. It
is clear that

(cid:91)

L(l)

(u1,q1)

q1∈{1,l}

=(Σ∗u1Σ∗ ∪ u1

l (cid:1) Σ∗)

(cid:16) l−1
(cid:91)

(cid:0)u1

α1 (cid:1) Σ∗ ∩ (u1

α1+1 (cid:1) Σ∗)(cid:123) ∩ Σ∗u1Σ∗(cid:1) ∪ (u1

l (cid:1) Σ∗)

(cid:17)

α1=1
(cid:91)

(cid:0)Rα1

l (u1) ∩ Sα1

l (u1)(cid:1) .

=

=

α1∈[l]

Induction. Let k ∈ N>0 and assume that for all u1, . . . , uk ∈ Σ+ such that
for each i ∈ [k], the letters in ui are all distinct, we have

(cid:91)

(u1,q1) · · · L(l)
L(l)

(uk,qk) =

q1,...,qk∈{1,l}

(cid:91)

α∈[l]k

(cid:0)Rα

l (u1, . . . , uk) ∩ Sα

l (u1, . . . , uk)(cid:1) .

Let now u1, . . . , uk+1 ∈ Σ+ such that for each i ∈ [k + 1], the letters in ui

are all distinct.

Right-to-left inclusion. Let

(cid:91)

w ∈

α∈[l]k+1

(cid:0)Rα

l (u1, . . . , uk+1) ∩ Sα

l (u1, . . . , uk+1)(cid:1) .

Let α ∈ [l]k+1 witnessing this fact. As w ∈ Rα

l (u1, . . . , uk+1), we can decom-
αk+1 (cid:1) Σ∗ with
pose it as w = xy where x ∈ (u1
|y| being minimal. What we are going to do is, on the one hand, to prove that
x ∈ Rα(cid:48)
l (u1, . . . , uk) where α(cid:48) = (α1, . . . , αk), so that we can
apply the inductive hypothesis on x and get that there exist q1, . . . , qk ∈ {1, l}
such that x ∈ L(l)
(uk,qk); and, on the other hand, we are going to prove

αk ) (cid:1) Σ∗ and y ∈ uk+1

l (u1, . . . , uk) ∩ Sα(cid:48)

(u1,q1) · · · L(l)

α1 · · · uk

21

that there exists qk+1 ∈ {1, l} verifying y ∈ L(l)
details.

(uk+1,qk+1). We now spell out the

α1 · · · ui

α1 · · · ui
αi+1 · · · uk+1

For each i ∈ [k], αi < l, we have x /∈ (u1

αk )(cid:1)Σ∗, otherwise
αi+1 · · · uk
αk+1 ) (cid:1) Σ∗. Also, for all i ∈
we would have w = xy ∈ (u1
[k], αi < l, we have that x ∈ (cid:0)(u1
αk ) (cid:1)
αi+1 · · · uk
α1 · · · ui−1
Σ∗(cid:1), otherwise it would mean that y = y1y2 with |y1| > 0, that xy1 ∈ (cid:0)(u1
α1 · · ·
(cid:0)(ui+1
αk+1 (cid:1) Σ∗, contra-
ui−1
dicting the minimality of |y|. So x ∈ Rα(cid:48)
l (u1, . . . , uk), which
means by inductive hypothesis that there exist q1, . . . , qk ∈ {1, l} such that
x ∈ L(l)

αk ) (cid:1) Σ∗(cid:1) and y2 ∈ uk+1
l (u1, . . . , uk) ∩ Sα(cid:48)

αi−1) (cid:1) Σ∗(cid:1)ui

αi−1) (cid:1) Σ∗(cid:1)ui

αi+1 · · · uk

(cid:0)(ui+1

(u1,q1) · · · L(l)

(uk,qk).

α1 . . . uk

Remember now that the letters in uk+1 are all distinct. If αk+1 < l, since
w ∈ (cid:0)(u1
αk ) (cid:1) Σ∗(cid:1)uk+1Σ∗, we must have y ∈ Σ∗uk+1Σ∗. Indeed, by
minimality of |y|, the word y starts with the ﬁrst letter of uk+1, which has
pairwise distinct letters, so that uk+1 cannot appear as a factor of xy partly
in x and partly in y; so if it were the case that y does not contain uk+1
as a factor, we would have x ∈ (cid:0)(u1
αk ) (cid:1) Σ∗(cid:1)uk+1Σ∗, so that xy =
αk+1+1) (cid:1) Σ∗, a contradiction with the hypothesis on w.
αk uk+1
α1 . . . uk
w ∈ (u1
Hence, y ∈ L(l)
(uk+1,αk+1).

(uk+1,αk+1). If αk+1 = l, then y ∈ uk+1

αk+1 (cid:1) Σ∗ = L(l)

α1 . . . uk

(cid:40)

So, if we set qk+1 =

1 if αk+1 < l
otherwise
l
We can conclude that w = xy ∈ L(l)
Left-to-right inclusion. Let w ∈ (cid:83)

, then we get that y ∈ L(l)

(uk+1,qk+1).

(uk,qk)L(l)

(u1,q1) · · · L(l)
q1,...,qk+1∈{1,l} L(l)

(uk+1,qk+1).
(u1,q1) · · · L(l)

(uk+1,qk+1). The
rough idea of our proof here is to take αk+1 ∈ [l] the biggest integer in [l] such
that w ∈ (cid:0)(cid:83)
q1,...,qk∈{1,l} L(l)
αk+1 (cid:1) Σ∗) and decompose
w as w = xy where x ∈ (cid:83)
αk+1 (cid:1)
(uk,qk) and y ∈ uk+1
Σ∗ with |y| being minimal. By inductive hypothesis, we know there exists
α ∈ [l]k such that x ∈ Rα
l (u1, . . . , uk) and we then prove that
xy ∈ R(α1,...,αk+1)
(u1, . . . , uk+1) by distinguishing
l
between the case in which αk+1 = l and the case in which αk+1 < l. The ﬁrst
one is easy to handle, the second one is much trickier.

l (u1, . . . , uk) ∩ Sα
(u1, . . . , uk+1) ∩ S(α1,...,αk+1)

(u1,q1) · · · L(l)
q1,...,qk∈{1,l} L(l)

(uk,qk))(cid:1)(uk+1

(u1,q1) · · · L(l)

l

We now spell out the details.

• Suppose we have

w ∈

(cid:91)

(u1,q1) · · · L(l)
L(l)

(uk,qk)L(l)

(uk+1,l)

q1,...,qk∈{1,l}
(cid:16) (cid:91)

=

q1,...,qk∈{1,l}

(u1,q1) · · · L(l)
L(l)

(uk,qk)

(cid:17)

(uk+1

l (cid:1) Σ∗) .

(uk,qk) and y ∈ uk+1

Then w can be decomposed as w = xy where x ∈ (cid:83)
L(l)
thesis, there exists α ∈ [l]k such that x ∈ Rα
Observe that this means we have w ∈ (u1
each i ∈ [k], αi < l, that w /∈ (u1
wise it would mean that x ∈ (u1

(u1,q1) · · ·
l (cid:1) Σ∗ with |y| being minimal. So by inductive hypo-
l (u1, . . . , uk).
l) (cid:1) Σ∗ and for
αk uk+1
l) (cid:1) Σ∗, other-
αk uk+1
αk ) (cid:1) Σ∗ by minimality

l (u1, . . . , uk) ∩ Sα
α1 · · · uk
αi+1 · · · uk
αi+1 · · · uk

q1,...,qk∈{1,l} L(l)

α1 · · · ui
α1 · · · ui

22

of |y|. Similarly, for all i ∈ [k], αi < l, it is obvious that we have
αi−1 ) (cid:1) Σ∗(cid:1)ui
w = xy ∈ (cid:0)(u1
(cid:0)(ui+1
as x ∈ (cid:0)(u1
α1 · · · ui−1
(cid:1) Σ∗. Hence, w ∈ R(α1,...,αk+1)

αi+1 · · · uk
(u1, . . . , uk+1) ∩ S(α1,...,αk+1)

αk uk+1
αk )(cid:1)Σ∗(cid:1) and y ∈ uk+1
(u1, . . . , uk+1).

αi−1)(cid:1)Σ∗(cid:1)ui

α1 · · · ui−1

αi+1 · · · uk

l) (cid:1) Σ∗(cid:1)

(cid:0)(ui+1

l

l

l

• Or we have

w /∈

(cid:91)

(u1,q1) · · · L(l)
L(l)

(uk,qk)L(l)

(uk+1,l)

q1,...,qk∈{1,l}
(cid:16) (cid:91)

=

q1,...,qk∈{1,l}

(u1,q1) · · · L(l)
L(l)

(uk,qk)

(cid:17)

(uk+1

l (cid:1) Σ∗)

but

w ∈

(cid:91)

q1,...,qk∈{1,l}

(u1,q1) · · · L(l)
L(l)

(uk,qk)L(l)

(uk+1,1) .

Let αk+1 ∈ [l − 1] be the biggest integer in [l − 1] such that

(cid:16) (cid:91)

w ∈

(u1,q1) · · · L(l)
L(l)

(uk,qk)

(cid:17)

(uk+1

αk+1 (cid:1) Σ∗)

q1,...,qk∈{1,l}

q1,...,qk∈{1,l} L(l)

which does exist by hypothesis. We can decompose w as w = xy where
x ∈ (cid:83)
αk+1 (cid:1) Σ∗ with |y|
being minimal. So by inductive hypothesis, there exists α ∈ [l]k such that
x ∈ Rα

l (u1, . . . , uk). We are now going to prove that

(uk,qk) and y ∈ uk+1

l (u1, . . . , uk) ∩ Sα

(u1,q1) · · · L(l)

w = xy ∈ R(α1,...,αk+1)
l

(u1, . . . , uk+1) ∩ S(α1,...,αk+1)

l

(u1, . . . , uk+1) .

Among the obvious things to observe is that we have w ∈ (u1
uk+1

αk+1) (cid:1) Σ∗ and for each i ∈ [k], αi < l, that

α1 · · · uk

αk

w /∈ (u1

α1 · · · ui

αi+1 · · · uk

αk uk+1

αk+1) (cid:1) Σ∗ ,

α1 · · · ui

αi+1 · · · uk

αk ) (cid:1) Σ∗ by min-

(cid:0)(ui+1

α1 · · · ui−1

αi−1 ) (cid:1) Σ∗(cid:1)ui

otherwise it would mean that x ∈ (u1
imality of |y|. Similarly, for all i ∈ [k], αi < l, it is obvious that we have
w = xy ∈ (cid:0)(u1
because x ∈ (cid:0)(u1
αk+1 (cid:1) Σ∗.
y ∈ uk+1
Now let us show that we have y ∈ Σ∗uk+1Σ∗. Assume it weren’t the case:
the letters in uk+1 are pairwise distinct and moreover y starts with the
ﬁrst letter of uk+1 by minimality of |y|, so uk+1 cannot appear as a factor
of xy partly in x and partly in y and, additionally,

αk ) (cid:1) Σ∗(cid:1) and

αi−1 ) (cid:1) Σ∗(cid:1)ui

αk+1) (cid:1) Σ∗(cid:1)

αi+1 · · · uk

α1 · · · ui−1

αi+1 · · · uk

(cid:0)(ui+1

αk uk+1

w ∈

(cid:91)

(u1,q1) · · · L(l)
L(l)

(uk,qk)L(l)

(uk+1,1)

q1,...,qk∈{1,l}
(cid:16) (cid:91)

=

q1,...,qk∈{1,l}

(u1,q1) · · · L(l)
L(l)

(uk,qk)

(cid:17)

Σ∗uk+1Σ∗ ,

23

so we would have x ∈ ((cid:83)
this either contradicts the maximality of αk+1 or the fact that

q1,...,qk∈{1,l} L(l)

(u1,q1) · · · L(l)

(uk,qk))Σ∗uk+1Σ∗. But

(cid:16) (cid:91)

w /∈

(u1,q1) · · · L(l)
L(l)

(uk,qk)

(cid:17)

(uk+1

l (cid:1) Σ∗) .

q1,...,qk∈{1,l}

α1 · · ·

αk uk+1

α1 · · · uk

αk ) (cid:1) Σ∗.

αk ) (cid:1) Σ∗(cid:1)uk+1Σ∗ as x ∈ (u1

αk+1+1) (cid:1) Σ∗. Assume that w ∈ (u1

Thus, we have w = xy ∈ (cid:0)(u1
uk
α1 · · ·
Let us ﬁnish with the trickiest part, namely showing that w /∈ (u1
αk+1+1) (cid:1) Σ∗.
αk uk+1
uk
αk uk+1) (cid:1) Σ∗, otherwise it would
We then have that x ∈ (u1
αk uk+1) (cid:1)
mean that y = y1y2 with |y1| > 0, with xy1 ∈ (u1
αk+1 (cid:1) Σ∗, contradicting the minimality of |y|. We
Σ∗ and y2 ∈ uk+1
αk ) (cid:1) Σ∗ and
can decompose x as x = x1x2 where x1 ∈ (u1
x2 ∈ uk+1 (cid:1) Σ∗ with |x2| being minimal. We claim that, actually, x1 ∈
Rα
l (u1, . . . , uk), so that by inductive hypothesis, x1 ∈
(cid:83)
αk+1+1 (cid:1) Σ∗, this

l (u1, . . . , uk) ∩ Sα
q1,...,qk∈{1,l} L(l)

(uk,qk). But since x2y ∈ uk+1

(u1,q1) · · · L(l)

α1 · · · uk

α1 · · · uk

α1 · · · uk

α1 · · · uk

means that

w = x1x2y ∈

(cid:16) (cid:91)

(u1,q1) · · · L(l)
L(l)

(uk,qk)

(cid:17)

(uk+1

αk+1+1 (cid:1) Σ∗) ,

q1,...,qk∈{1,l}

contradicting the maximality of αk+1 or the fact that

(cid:16) (cid:91)

w /∈

(u1,q1) · · · L(l)
L(l)

(uk,qk)

(cid:17)

(uk+1

l (cid:1) Σ∗) .

q1,...,qk∈{1,l}

αk uk+1

αi+1 · · · uk

α1 · · · uk
l (u1, . . . , uk) ∩ Sα
α1 · · · ui

αk+1+1) (cid:1) Σ∗.
l (u1, . . . , uk) remains to be shown.
αk )(cid:1)Σ∗ for all i ∈ [k], αi <
αk ) (cid:1) Σ∗. Let
αi−1) (cid:1) Σ∗(cid:1)ui
αk ) (cid:1) Σ∗(cid:1). We can decompose x1 as x1 = x1,1x1,2 where
αi) (cid:1) Σ∗ and x1,2 ∈ (ui+1
αk ) (cid:1) Σ∗ with |x1,1|
αi−1) (cid:1)

So we can conclude that w /∈ (u1
The claim that x1 ∈ Rα
We directly see that x1 /∈ (u1
α1 · · · ui
l, otherwise it would mean that x ∈ (u1
now i ∈ [k], αi < l, and assume that x1 /∈ (cid:0)(u1
(cid:0)(ui+1
x1,1 ∈ (u1
being minimal. By hypothesis, we have x1,1 /∈ (cid:0)(u1
Σ∗(cid:1)uiΣ∗, otherwise we would have
x1 = x1,1x1,2 ∈ (cid:0)(u1

αi+1 · · · uk
α1 · · · ui−1

αi−1) (cid:1) Σ∗(cid:1)ui

αk ) (cid:1) Σ∗(cid:1) .

α1 · · · ui−1

αi+1 · · · uk

α1 · · · ui−1

αi+1 · · · uk

αi+1 · · · uk

(cid:0)(ui+1

α1 · · · ui

As previously, the letters in ui are pairwise distinct, and x1,1 ends with
the last letter of ui by minimality of |x1,1|, so ui cannot appear as a factor
of x partly in x1,1 and partly in x1,2x2. Thus, we have that

(cid:0)(ui+1

αk ) (cid:1) Σ∗(cid:1)

αi+1 · · · uk

x1,2x2 ∈ Σ∗ui
because we know that x ∈ (cid:0)(u1
αk )
(cid:1) Σ∗(cid:1). But this means that x = x1,1x1,2x2 ∈ (u1
αk ) (cid:1)
Σ∗, a contradiction. Hence, we can deduce that for all i ∈ [k], αi < l,
αk ) (cid:1) Σ∗(cid:1). This
we have x1 ∈ (cid:0)(u1
ﬁnishes to show that

αi−1) (cid:1) Σ∗(cid:1)ui

αi−1 )(cid:1)Σ∗(cid:1)ui

αi+1 · · · uk

α1 · · · ui−1

α1 · · · ui−1

αi+1 · · · uk

αi+1 · · · uk

(cid:0)(ui+1

(cid:0)(ui+1

α1 · · · ui

x1 ∈ Rα

l (u1, . . . , uk) ∩ Sα

l (u1, . . . , uk) .

24

Putting all together, we indeed also have that

w ∈ R(α1,...,αk+1)

l

(u1, . . . , uk+1) ∩ S(α1,...,αk+1)

l

(u1, . . . , uk+1)

in the present case.

In conclusion, in both cases,

(cid:91)

w ∈

α∈[l]k+1

(cid:0)Rα

l (u1, . . . , uk+1) ∩ Sα

l (u1, . . . , uk+1)(cid:1) .

So we can ﬁnally conclude that

(cid:91)

(u1,q1) · · · L(l)
L(l)

(uk+1,qk+1)

q1,...,qk+1∈{1,l}

(cid:91)

=

α∈[l]k+1

(cid:0)Rα

l (u1, . . . , uk+1) ∩ Sα

l (u1, . . . , uk+1)(cid:1) .

This concludes the proof of the lemma.

B.3 Proof of Lemma 4.10

Before proving Lemma 4.10, we need a useful decomposition lemma, that is
straightforward to prove.

Lemma B.1. Let Σ be an alphabet and u ∈ Σ+. Then, for all α ∈ N>0, each
w ∈ uα (cid:1) Σ∗ ∩ (uα+1 (cid:1) Σ∗)(cid:123) veriﬁes

α
(cid:89)

|u|
(cid:89)

w = (cid:0)

(vi,juj)(cid:1)y

i=1

j=1

where vi,j ∈ (Σ \ {uj})∗ for all i ∈ [α] and j ∈ [|u|], and y ∈ (cid:83)|u|
{uj})∗uj

(cid:1)(Σ \ {ui})∗(cid:17)

.

i=1

(cid:16)(cid:81)i−1
j=1

(cid:0)(Σ \

Proof. Let Σ be an alphabet and u ∈ Σ+.

Take α ∈ N>0 and w ∈ uα (cid:1) Σ∗ ∩ (uα+1 (cid:1) Σ∗)(cid:123).
As w ∈ uα (cid:1) Σ∗, the word w can be decomposed as w = xy where x ∈
uα (cid:1) Σ∗ and |x| is minimal. Then, it is clearly necessarily the case that x =
(cid:81)α
j=1(vi,juj) with vi,j ∈ (Σ \ {uj})∗ for all i ∈ [α] and j ∈ [|u|]. Moreover,
as xy /∈ uα+1 (cid:1) Σ∗, we necessarily have that y /∈ u (cid:1) Σ∗, so that there exists
some i ∈ [|u|] verifying that u1 · · · ui−1 is a subword of y but not u1 · · · ui. Thus,
we have that y ∈ (cid:81)i−1
j=1

(cid:0)(Σ \ {uj})∗uj

(cid:1)(Σ \ {ui})∗.

(cid:81)|u|

i=1

This concludes the proof.

We can now prove Lemma 4.10.

Proof of Lemma 4.10. Let Σ be an alphabet and u ∈ Σ+ such that its letters
are all distinct. Let α ∈ N>0 and x1, x2 ∈ Σ∗. We let

L = (x1uαx2) (cid:1) Σ∗ ∩ (cid:0)(x1uα+1x2) (cid:1) Σ∗(cid:1)(cid:123)

∩ (x1 (cid:1) Σ∗)u(x2 (cid:1) Σ∗) .

25

If |u| = 1, the lemma follows trivially because L is piecewise testable and hence
belongs to L(J), so we assume |u| > 1.

For each letter a ∈ Σ, we shall use 2 |u| − 1 distinct decorated letters of the
form a(i) for some i ∈ [[0, 2 |u| − 2]], using the convention that a(0) = a; of course,
for two distinct letters a, b ∈ Σ, we have that a(i) and b(j) are distinct for all
i, j ∈ [[0, 2 |u| − 2]]. We denote by A the alphabet of these decorated letters.

For each i ∈ [[0, 2 |u| − 2]], let

f (i) : Σ → A

.

a (cid:55)→ a(i)

For all i ∈ N, i ≥ |u|, we deﬁne

Φi = (i, f (0))

|u|−1
(cid:89)

(i − j, f (j))

j=1

|u|
(cid:89)

j=2

(i − |u| + j, f (|u|+j−2)) .

For all n ∈ N, n < |u|, we deﬁne Ψn = ε. For all n ∈ N, n ≥ |u|, we deﬁne

|u|−1
(cid:89)

(i, f (0))

Ψn =

i=1

n
(cid:89)

i=|u|

Φi .

Finally, let K be the language of words over A having

ζβ = x1uβ−1u

|u|−1
(cid:89)

j=1

u(j)
|u|−j

|u|
(cid:89)

j=2

u(|u|+j−2)
j

uα−βx2

for some β ∈ [α] as a subword but not x1uα+1x2.

Claim B.2. The sequence (Ψn)n∈N of A-programs is a program-reduction from
L to K.

Let

s : N → N
(cid:40)
0
|u| − 1 + (n − |u| + 1) · (2 |u| − 1) otherwise .

if n < |u|

n (cid:55)→

It is direct to see that s(n) = |Ψn| ≤ (2 |u| − 1) · n for all n ∈ N.

Therefore, using this claim, (Ψn)n∈N is a program-reduction from L to K of
length s(n), so since K is piecewise testable and hence is recognised (classically)
by some monoid from J, Proposition 2.2 tells us that L ∈ P(J, s(n)) = P(J, n).

Proof of claim. Let n ∈ N. If n < |u|, then it is obvious that for all w ∈ Σn,
we have w /∈ (x1 (cid:1) Σ∗)u(x2 (cid:1) Σ∗) so w /∈ L=n and also Ψn(w) = ε /∈ K =s(n),
hence L=n = ∅ = Ψ−1
n (K =s(n)). Otherwise, n ≥ |u|. We are going to show that
n (K =s(n)).
L=n = Ψ−1

26

Left-to-right inclusion. Let w ∈ L=n. We want to show that Ψn(w) ∈
K =s(n).

(cid:0)(Σ \ {uj})∗uj

(cid:81)|u|
(cid:16)(cid:81)i−1
j=1

We are ﬁrst going to show that there exists some β ∈ [α] such that ζβ is
a subword of Ψn(w). The fact that w ∈ L=n means in particular that w ∈
(x1 (cid:1) Σ∗)u(x2 (cid:1) Σ∗) and we can hence decompose w as w = y1zy2 where
y1 ∈ (x1 (cid:1) Σ∗) and y2 ∈ (x2 (cid:1) Σ∗) with |y1| and |y2| being minimal. It follows
necessarily that z ∈ uα (cid:1) Σ∗ ∩ (uα+1 (cid:1) Σ∗)(cid:123) ∩ Σ∗uΣ∗ by minimality of |y1| and
j=1(vi,juj)(cid:1)y where vi,j ∈ (Σ\{uj})∗
|y2|. By Lemma B.1, we have z = (cid:0)(cid:81)α
i=1
for all i ∈ [α] and j ∈ [|u|], and y ∈ (cid:83)|u|
. We
i=1
know the letters in u are all distinct, so this means that there is no β ∈ [α − 1]
such that u is a factor of z partly in (cid:81)|u|
j=1(vβ+1,juj),
and that u cannot appear as a factor of z partly in (cid:81)|u|
j=1(vα,juj) and partly
in y either. Hence, since z ∈ Σ∗uΣ∗, by the way we decomposed z, there
necessarily exists β ∈ [α] such that (cid:81)|u|
j=1(vβ,juj) ∈ Σ∗uΣ∗. Let γ, δ ∈ [n]
j=1(vi,juj)(cid:1) and
such that wγ · · · wδ = (cid:81)|u|
wδ+1 · · · wn = (cid:0)(cid:81)α
j=1(vi,juj)(cid:1)yy2. By the way β is deﬁned, we have
wδ−|u|+1 · · · wδ = u, because δ is the ﬁrst and only position in w with the letter
u|u| within the interval [[γ, δ]] verifying that wγ · · · wδ−1 contains u1 · · · u|u|−1 as
a subword, and we observe additionally that δ ≥ γ + |u| − 1 ≥ |u|. This means
that

j=1(vβ,juj), w1 · · · wγ−1 = y1
(cid:81)|u|

j=1(vβ,juj) and partly in (cid:81)|u|

(cid:1)(Σ \ {ui})∗(cid:17)

(cid:0)(cid:81)β−1
i=1

(cid:81)|u|

i=β+1

Φδ(w)

=f (0)(wδ)f (1)(wδ−1) · · · f (|u|−1)(wδ−|u|+1)f (|u|)(wδ−|u|+2) · · · f (2|u|−2)(wδ)

=u|u|

|u|−1
(cid:89)

j=1

u(j)
|u|−j

|u|
(cid:89)

j=2

u(|u|+j−2)
j

.

Moreover,

γ−1
(cid:89)

i=1

f (0)(wi) = w1 · · · wγ−1 = y1

β−1
(cid:89)

|u|
(cid:89)

(cid:0)

(vi,juj)(cid:1) ,

i=1

j=1

δ−1
(cid:89)

i=δ−|u|+1

f (0)(wi) = wδ−|u|+1 · · · wδ−1 = u1 · · · u|u|−1

and

n
(cid:89)

i=δ+1

f (0)(wi) = wδ+1 · · · wn = (cid:0)

α
(cid:89)

|u|
(cid:89)

i=β+1

j=1

(vi,juj)(cid:1)yy2 .

So as (cid:81)γ−1
have that

i=1 (i, f (0)) (cid:81)δ−1

i=δ−|u|+1(i, f (0))Φδ

(cid:81)n

i=δ+1(i, f (0)) is a subword of Ψn, we

ζβ = x1uβ−1u

|u|−1
(cid:89)

j=1

u(j)
|u|−j

|u|
(cid:89)

j=2

u(|u|+j−2)
j

uα−βx2

is a subword of Ψn(w).

We secondly show that x1uα+1x2 cannot be a subword of Ψn(w). But this
is direct by construction of Ψn, otherwise we would have that x1uα+1x2 is a
subword of w, contradicting the fact that w ∈ L=n.

27

Hence, Ψn(w) ∈ K =s(n), and since this is true for all w ∈ L=n, we have

L=n ⊆ Ψ−1

n (K =s(n)).

Right-to-left inclusion. We are going to prove the “contrapositive inclusion”.

Let w ∈ Σn \ L=n. We want to show that Ψn(w) /∈ K =s(n).
Let us start with the easy cases. If we have w /∈ (x1uαx2) (cid:1) Σ∗, then it
means that x1uαx2 is not a subword of w and hence, by construction of Ψn, not
a subword of Ψn(w) either, so that there does not exist any β ∈ [α] such that
ζβ is a subword of Ψn(w). Similarly, if we have w ∈ (x1uα+1x2) (cid:1) Σ∗, then it
means that x1uα+1x2 is a subword of w and hence, by construction of Ψn, a
subword of Ψn(w).

We now assume that w ∈ (x1uαx2) (cid:1) Σ∗ ∩ (cid:0)(x1uα+1x2) (cid:1) Σ∗(cid:1)(cid:123)

while w /∈
(x1 (cid:1) Σ∗)u(x2 (cid:1) Σ∗). We want to show that in this case, there does not exist
any β ∈ [α] such that ζβ is a subword of Ψn(w). Suppose for a contradiction
that such a β exists; our goal is to show, through a careful observation of what
this implies on the letters in w by examining how Ψn decorates the letters, that
this contradictingly entails x1uα+1x2 is a subword of w.

Since ζβ is a subword of Ψn(w), it is not too diﬃcult to see there exist

p1, . . . , p|x1|+(β−1)·|u|, q1, . . . , q3|u|−2, r1, . . . , r(α−β)·|u|+|x2| ∈ [n]

verifying that

and

wp1 · · · wp|x1|+(β−1)·|u| = x1uβ−1 ,

wq1 · · · wq3|u|−2 = u

|u|−1
(cid:89)

j=1

u|u|−j

|u|
(cid:89)

j=2

uj ,

wr1 · · · wr(α−β)·|u|+|x2| = uα−βx2

(p1, f (0)) · · · (p|x1|+(β−1)·|u|, f (0))(q1, f (0)) · · · (q|u|, f (0))
(q|u|+1, f (1)) · · · (q2|u|−1, f (|u|−1))(q2|u|, f (|u|)) · · · (q3|u|−2, f (2|u|−2))
(r1, f (0)) · · · (r(α−β)·|u|+|x2|, f (0))

is a subword of Ψn. By construction of Ψn, we have

p1 < · · · < p|x1|+(β−1)·|u| < q1 < · · · < q|u| < r1 < · · · < r(α−β)·|u|+|x2| ,

so this implies that w can be decomposed as w = y1zy2 where y1 ∈ x1 (cid:1) Σ∗,
where z ∈ uα (cid:1) Σ∗ and y2 ∈ x2 (cid:1) Σ∗, the positions p1, . . . , p|x1| corres-
ponding to letters in y1, the positions p|x1|+1, . . . , p|x1|+(β−1)·|u|, q1, . . . , q|u|,
r1, . . . , r(α−β)·|u| corresponding to letters in z and the positions r(α−β)·|u|+1, . . . ,
r(α−β)·|u|+|x2| corresponding to letters in y2.

We are now going to show that, in fact, q|u| < q2|u|−1 < q2|u| < · · · <
q3|u|−2 < r1, which implies z ∈ uα+1 (cid:1) Σ∗ and thus the contradiction we are
aiming for. Since w /∈ (x1 (cid:1) Σ∗)u(x2 (cid:1) Σ∗), we have z /∈ Σ∗uΣ∗, hence as
wq|u| = u|u| and |u| > 1, there must exist j ∈ [|u| − 1] such that wq|u|−j (cid:54)= u|u|−j
and wq|u|−ι = u|u|−ι for all ι ∈ [[0, j − 1]]. By construction of Ψn, we know that
q|u|+j ≥ q|u| − j (because the instructions with f (j) after an instruction with

28

f (0) querying position p ∈ [n] all query a position at least equal to p − j), but
since u|u|−j (cid:54)= wq|u|−j and u|u|−j (cid:54)= u|u|−ι = wq|u|−ι for all ι ∈ [[0, j − 1]] as the
letters in u are all distinct, we get that q|u|+j > q|u|. By (backward) induction,
we can show that for all ι ∈ [[j + 1, |u| − 1]], we have q|u|+ι > q|u|. Indeed, given
ι ∈ [[j + 1, |u| − 1]], we have q|u|+ι−1 > q|u|, either by inductive hypothesis or
directly in the base case ι = j + 1 by what we have just seen. So by construction
of Ψn, we know that q|u|+ι ≥ q|u| (because the instructions with f (ι) after an
instruction with f (ι−1) querying position p ∈ [n] all query a position at least
equal to p − 1), but since u|u|−ι (cid:54)= u|u| = wq|u| as the letters in u are all distinct,
it follows that q|u|+ι > q|u|. Therefore, we have that q2|u|−1 > q|u|. Moreover,
by construction of Ψn, we also have q2|u|−1 < q2|u| < · · · < q3|u|−2 < r1 (because
for each ι ∈ [[0, |u| − 2]], the instructions with f (|u|+ι) after an instruction with
f (|u|+ι−1) querying position p ∈ [n] all query a position at least equal to p + 1
and similarly for the instructions with f (0) after an instruction with f (2|u|−2)).
So, to conclude, we have p1 < · · · < p|x1|+(β−1)·|u| < q1 < · · · < q|u| < q2|u|−1 <
q2|u| < · · · < q3|u|−2 < r1 < · · · < r(α−β)·|u|+|x2| and

wp1 · · · wp|x1 |+(β−1)·|u|wq1 · · · wq|u|wq2|u|−1wq2|u| · · · wq3|u|−2 wr1 · · · wr(α−β)·|u|+|x2 |

=x1uβ−1uu1u2 · · · u|u|uα−βx2 = x1uα+1x2 .

This implies that w ∈ (x1uα+1x2) (cid:1) Σ∗, a contradiction. So there does not exist
β ∈ [α] such that ζβ is a subword of Ψ(w).

Therefore, in every case Ψn(w) /∈ K =s(n), and since this is true for all
n (As(n) \ K =s(n)), which is equivalent to

w ∈ Σn \ L=n, we have Σn \ L=n ⊆ Ψ−1
L=n ⊇ Ψ−1

n (K =s(n)).

This concludes the proof of the claim.

And the one of the lemma.

B.4 Proof of Proposition 4.11
Proof of Proposition 4.11. Let Σ be an alphabet, l ∈ N>0 and u1, . . . , uk ∈ Σ+
(k ∈ N>0) such that for each i ∈ [k], the letters in ui are all distinct. Let
α ∈ [l]k.

For each i ∈ [k] verifying αi < l, we deﬁne

Li =(u1
(cid:0)(u1

α1 · · · uk
α1 · · · ui−1

αk ) (cid:1) Σ∗ ∩ (cid:0)(u1
αi−1) (cid:1) Σ∗(cid:1)ui

α1 · · · ui
(cid:0)(ui+1

αi+1 · · · uk
αi+1 · · · uk

αk ) (cid:1) Σ∗(cid:1)(cid:123)
αk ) (cid:1) Σ∗(cid:1) .

∩

It is immediate to show that

Rα

l (u1, . . . , uk) ∩ Sα

l (u1, . . . , uk) = (u1

α1 · · · uk

αk ) (cid:1) Σ∗ ∩

(cid:92)

Li .

i∈[k],αi<l

By Lemma 4.10, Li ∈ P(J) for each i ∈ [k] verifying αi < l. Moreover,
αk ) (cid:1) Σ∗ obviously is a piecewise testable language, it belongs
l (u1, . . . , uk) belongs

since (u1
to P(J). Thus, we can conclude that Rα
to P(J) by closure of P(J) ∩ Reg under intersection, Proposition 2.1.

l (u1, . . . , uk) ∩ Sα

α1 · · · uk

29

B.5 Proof of Proposition 4.13
Proof of Proposition 4.13. Let Σ be an alphabet, l ∈ N>0 and u1, . . . , uk ∈ Σ+
(k ∈ N>0).

Let d = maxi∈[k] |ui|. If d = 1, then the result is straightforward because
the language [u1, . . . , uk]l then belongs to L(J), so now we assume d ≥ 2. We
let Σd = Σ × Z/d Z and for all w ∈ Σ∗, for all i ∈ Z/d Z, we deﬁne (cid:101)wi =
(cid:81)|w|

j=1(wj, (j + i − 1) mod d). We also let (cid:101)w = (cid:101)w0 for all w ∈ Σ∗.
For all v ∈ Σ+, |v| ≤ d, we deﬁne µ(v, 1) = v and

µ(v, l) = v1, . . . , v|v|, . . . . . . . . . , v1, . . . , v|v|
(cid:125)

(cid:124)

(cid:123)(cid:122)
l times

.

For all v1, . . . , vk(cid:48) ∈ Σ+ (k(cid:48) ∈ N>0) such that |vi| ≤ d for each i ∈ [k(cid:48)], we let

[v1, . . . , vk(cid:48)]l,d =

(cid:91)

[ (cid:101)v1

i1 , . . . , (cid:102)vk(cid:48)

ik(cid:48) ]l ,

i1,...,ik(cid:48) ∈Z/d Z

a language over Σd, that does belong to P(J) by Corollary 4.12 and closure of
P(J) ∩ Reg under ﬁnite union (Proposition 2.1), because since |vi| ≤ d for each
i ∈ [k(cid:48)], each (cid:101)vi

j for j ∈ Z/d Z has all distinct letters.

This implies that for all q1, . . . , qk ∈ {1, l}, we have that [µ(u1, q1), . . . ,

µ(uk, qk)]l,d does belong to P(J), so that

(cid:91)

q1,...,qk∈{1,l}

[µ(u1, q1), . . . , µ(uk, qk)]l,d

is a language over Σd belonging to P(J).
Now, it is not so diﬃcult to see that

[u1, . . . , uk]l =

(cid:91)

(u1,q1) · · · L(l)
L(l)

(uk,qk)

q1,...,qk∈{1,l}
(cid:110)
w ∈ Σ∗ (cid:12)

(cid:12) (cid:101)w ∈

=

(cid:91)

[µ(u1, q1), . . . , µ(uk, qk)]l,d

(cid:111)

,

q1,...,qk∈{1,l}

which allows us to conclude that the sequence (Ψn)n∈N of Σd-programs such that
Ψn(w) = (cid:101)w for all n ∈ N and w ∈ Σn is a program-reduction from [u1, . . . , uk]l
to (cid:83)
q1,...,qk∈{1,l}[µ(u1, q1), . . . , µ(uk, qk)]l,d of length n. Hence, [u1, . . . , uk]l does
also belong to P(J) by Proposition 2.2.

30

