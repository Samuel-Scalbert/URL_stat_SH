Counting Queries over ELHI⊥ Ontologies
Meghyn Bienvenu, Quentin Manière, Michaël Thomazo

To cite this version:

Meghyn Bienvenu, Quentin Manière, Michaël Thomazo. Counting Queries over ELHI⊥ Ontologies.
KR 2022 - 19th International Conference on Principles of Knowledge Representation and Reasoning,
Jul 2022, Haifa, Israel. pp.53-62, ￿10.24963/kr.2022/6￿. ￿hal-03820249￿

HAL Id: hal-03820249

https://hal.science/hal-03820249

Submitted on 18 Oct 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Counting Queries over ELHI ? Ontologies

Meghyn Bienvenu1 , Quentin Mani`ere1 , Micha¨el Thomazo2
1CNRS, University of Bordeaux, Bordeaux INP, LaBRI, Talence, France
2Inria, DI ENS, ENS, CNRS, University PSL, Paris, France
fmeghyn.bienvenu, quentin.maniereg@u-bordeaux.fr, michael.thomazo@inria.fr

Abstract

While ontology-mediated query answering most often adopts
(unions of) conjunctive queries as the query language, some
recent works have explored the use of counting queries cou-
pled with DL-Lite ontologies. The aim of the present paper
is to extend the study of counting queries to Horn descrip-
tion logics outside the DL-Lite family. Through a combi-
nation of novel techniques, adaptations of existing construc-
tions, and new connections to closed predicates, we achieve
a complete picture of the data and combined complexity of
answering counting conjunctive queries (CCQs) and cardi-
nality queries (a restricted class of CCQs) in ELHI? and
its various sublogics. Notably, we show that CCQ answer-
ing is 2EXP-complete in combined complexity for ELHI?
and every sublogic that extends EL or DL-LiteH
pos. Our study
not only provides the ﬁrst results for counting queries beyond
DL-Lite, but it also closes some open questions about the
combined complexity of CCQ answering in DL-Lite.

1

Introduction

Ontology-mediated query answering (OMQA) facilitates ac-
cess to data through the use of ontologies, which provide
a convenient vocabulary for query formulation and capture
domain knowledge that can be exploited to obtain more
complete query results. The OMQA approach has been ex-
tensively studied over the past ﬁfteen years (Poggi et al.
2008; Bienvenu and Ortiz 2015; Xiao et al. 2018), leading to
the identiﬁcation of ontology languages that are well suited
to OMQA due to their attractive computational properties.
Particular attention has been paid to Horn description log-
ics of the DL-Lite and EL families (Calvanese et al. 2007;
Baader, Brandt, and Lutz 2005).

While most work on OMQA considers that the user query
is a conjunctive query (CQ), there has been signiﬁcant inter-
est in exploring the possibility of adopting more expressive
query languages for OMQA. In particular, several works
have investigated ways of equipping CQs with some form of
counting (Calvanese et al. 2008; Kostylev and Reutter 2015;
Feier, Lutz, and Przybylko 2021). A recent approach, pro-
posed in (Bienvenu, Mani`ere, and Thomazo 2020) as a gen-
eralization of (Kostylev and Reutter 2015), considers count-
ing conjunctive queries (CCQs) that are syntactically de-
ﬁned like standard CQs except that some variables may be
designated as counting variables.
In each model of the

knowledge base, we can count the number of possible as-
signments to the counting variables that make the query an-
swer hold. As the count value may differ between models,
the goal is to identify intervals that provide upper and lower
bounds on the count values across all models.

The problem of answering CCQs is intractable, in both
data and combined complexity, for common DL-Lite di-
alects such as DL-Litecore and DL-LiteH
core(Kostylev and
Reutter 2015). Recent works have shown that intractabil-
ity arises even for simple forms of CCQs (Calvanese et al.
2020a; Bienvenu, Mani`ere, and Thomazo 2021). However,
some interesting tractable cases have also been identiﬁed,
notably, rooted CCQs (Bienvenu, Mani`ere, and Thomazo
2020; Calvanese et al. 2020a; Nikolaou et al. 2019) and car-
dinality queries (Bienvenu, Mani`ere, and Thomazo 2021)
coupled with DL-Litecore ontologies. Query rewriting tech-
niques have also begun to be explored (Calvanese et al.
2020b). However, despite these advances, we still have only
a partial understanding of CCQ answering in common DL-
Lite dialects, and the precise combined complexity has re-
mained elusive: the current bounds for DL-LiteH
core are be-
tween coNEXP and coN2EXP (Kostylev and Reutter 2015).
Moreover, to the best of our knowledge, CCQ answering has
not yet been studied for DLs outside the DL-Lite family.

In this paper, we extend the study of CCQ answering to
other well-known Horn description logics, such as EL and
the more expressive ELHI⊥. The techniques used in the
DL-Lite context do not readily transfer to EL due to the
presence of conjunction, and in any case, our results show
that they do not achieve the optimal combined complexity
even for DL-Lite. We therefore develop a new approach
based upon the observation that there exists a model min-
imizing the count value that consists of an arbitrary struc-
ture I ∗ containing all assignments for the counting vari-
ables, augmented with structures that are tree-shaped, pro-
vided we ignore edges to and from I ∗. Importantly, we can
bound the size of the central component I ∗, which enables
us to explore all possible options for I ∗. Checking whether
a given I ∗ can be extended to a model preserving the min-
imum count value can be done by specifying a set of pat-
terns (intuitively representing a pair of adjacent elements),
and testing via local consistency conditions whether they
can be coherently assembled. This latter step takes inspi-
ration from a CQ answering technique for existential rules

Proceedingsofthe19thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack53DL-Litepos DL-Litecore DL-LiteH

Concept
Role
CCQ

NL
NL
coNEXP†

coNP
coNP
coNEXP†

Combined complexity
pos DL-LiteH
core
coNP†
coNP†
2EXP

NL
coNP†
2EXP

EL(H⊥), EL(HI)

EXP
EXP
2EXP

EL(H)I ⊥
coNEXP
coNEXP
2EXP

Data complexity
EL(HI ⊥)

coNP
coNP
coNP

Figure 1: Complexity results for CCQs and cardinality queries, all bounds are tight. y/ y: previously known upper / lower bound.

(Thomazo et al. 2012), and is also similar in spirit to type-
elimination style procedures, which have been employed for
reasoning with expressive DLs, see e.g. (Rudolph, Kr¨otzsch,
and Hitzler 2012; Eiter et al. 2009).

Using this new approach, we are able to establish a 2EXP
upper bound in combined complexity for ELHI⊥. A match-
ing lower bound, which applies to both EL and DL-LiteH
pos,
is obtained by establishing a novel connection between CCQ
answering and OMQA with closed predicates. This yields
2EXP-completeness for a wide range of Horn DLs and
closes the combined complexity gap for CCQ answering
in DL-LiteH
core. We further prove a coNEXP lower bound
for DL-Litepos, which matches an existing coNEXP up-
per bound, yielding the precise combined complexity for
DL-Litecore as well. We also explore how to shrink the size
of the models implicitly generated by our procedure, pro-
ducing models with bounded size which we use to show that
CCQ answering is coNP-complete in data complexity for all
logics between EL and ELHI⊥.

In addition to CCQs, we also investigate the special case
of cardinality queries, which correspond to Boolean atomic
CCQs and allow us to ask for (bounds on) the number of
members of a given concept or role. We obtain a com-
plete picture of data and combined complexity of answer-
ing cardinality queries in ELHI⊥ and its various sublogics.
While the data complexity is coNP-complete for all con-
sidered logics, the combined complexity ranges from NL or
coNP in DL-Lite logics to EXP or coNEXP for EL and its
extensions. We achieve these results using a variety of the
techniques: reﬁnements of our approach for general CCQs,
adaptations of existing constructions, and further reductions
involving closed predicates. Figure 1 summarizes the com-
plexity results for both CCQs and cardinality queries.

Paper Organization Section 2 introduces the necessary
preliminaries, in particular, the syntax and semantics of the
considered DLs and the deﬁnition of CCQs. Sections 3
and 4 present our complexity results for CCQs and cardi-
nality queries, respectively, and sketch the underlying tech-
niques (an appendix with full proofs can be found in the
long version of this paper, available on arXiv). Section 5
concludes with a discussion of future work.

2 Preliminaries
Knowledge Bases We assume mutually disjoint sets NC,
NR, and NI of concept, role, and individual names. A knowl-
edge base (KB) K = (T ; A) consists of an ABox A and a
TBox T . An ABox is a ﬁnite set of concept assertions A(b)
(with A 2 NC, b 2 NI) and role assertions P(a; b) (with

P 2 NR, a; b 2 NI). We denote by Ind(A) the set of individ-
uals occurring in an ABox A.

A TBox is a ﬁnite set of axioms.

In ELHI⊥, TBoxes
consist of concept inclusions B1 v B2, positive role inclu-
sions R1 v R2, and negative role inclusions1 R1 u R2 v ?,
where the Ri are roles drawn from N±
R = fP; P− j P 2 NRg
and the Bi are (complex) concepts constructed as follows:

B := ? j > j A j B1 u B2 j 9R:B with A 2 NC; R 2 N±
R

Various sublogics of ELHI⊥ can be obtained by disallow-
ing role inclusions, inverse roles, and/or the bottom con-
struct. For example, EL is obtained by removing all three
features, while ELI ⊥ corresponds to disallowing role inclu-
sions (retaining inverse roles and ?). We shall also consider
some DL-Lite dialects that are fragments of ELHI⊥. The
most expressive, DL-LiteH
core, allows positive and negative
role inclusions, and restricted forms of concept inclusions:

D1 v D2 D1 u D2 v ? Di := A j 9R:>

with A 2 NC; R 2 N±
pos, DL-Litecore,
and DL-Litepos are obtained respectively by dropping nega-
tive inclusions, role inclusions, or both features.

R . The logics DL-LiteH

We shall use sig(T ) (resp. sig(K)) to denote the signature
of a TBox T (resp. KB K), i.e. the set of concept and role
names appearing in T (resp. K).

Semantics of KBs An interpretation takes the form I =
((cid:1)I; (cid:1)I), where (cid:1)I is a non-empty set (called the domain)
and (cid:1)I is the interpretation function that maps each A 2 NC
to AI (cid:18) (cid:1)I, each P 2 NR to PI (cid:18) (cid:1)I (cid:2) (cid:1)I, and each
a 2 NI to aI.
In this paper, we will make the Standard
Names Assumption by setting aI = a. Note however that our
results only rely upon the weaker Unique Names Assumption
(UNA), which stipulates that aI 6= bI whenever a 6= b.

1 \ BI

The function (cid:1)I naturally extends to roles and complex
concepts: (P−)I = f(y; x) j (x; y) 2 PIg, ?I = ;, >I =
2 and (9P:B)I = fd j (d; e) 2
(cid:1)I, (B1 u B2)I = BI
PI; e 2 BIg. An inclusion G v H is satisﬁed in I if GI (cid:18)
HI; an assertion A(b) (resp. P(a; b)) is satisﬁed in I if b 2
AI (resp. (a; b) 2 PI). An interpretation is a model of a
TBox T (resp. KB K) if it satisﬁes all axioms in T (resp.
axioms and assertions in K). A KB is satisﬁable if it has at
least one model. An inclusion (resp. assertion) (cid:8) is entailed
from T (resp. K), written T j= (cid:8) (resp. K j= (cid:8)), if (cid:8) is
satisﬁed in every model of T (resp. K).

1We follow e.g. (Bienvenu et al. 2014) by including negative
core as a sublogic.

role inclusions in ELHI?, so that it has DL-LiteH

Proceedingsofthe19thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack54Example 1. Consider the ABox Ae := fA1(a); B(b)g and
the ELHI⊥ TBox Te:
A1 v 9R:A2 A2 v 9R:A1 B v 9R:B R u R− v ?
A2 v 9R:B
B u B v ?
Our example KB is Ke := (Te; Ae). Figures 2a and 2c
depict models of Ke.

B v 9R:C

B v C

We can view an interpretation I as a (possibly inﬁnite) set
of assertions AI = fA(e) j e 2 AI; A 2 NCg [ fP(e; e0) j
(e; e0) 2 PI; P 2 NRg. We say that I is T -satisﬁable if
T [ AI has a model, and it is T -saturated if AI contains
every assertion entailed by (T ; AI).

Counting Queries We consider counting queries as de-
ﬁned in (Bienvenu, Mani`ere, and Thomazo 2020) (which
generalizes the queries considered in (Kostylev and Reut-
ter 2015; Calvanese et al. 2020a)). A counting conjunctive
query (CCQ) takes the form q(x) = 9y9z  (x; y; z), where
x; y; z are tuples of answer, existential, and counting vari-
ables, respectively, and   is a conjunction of concept and
role atoms with terms from NI [ x [ y [ z. We use terms(q)
for the set of all terms occurring in q, and we treat queries as
sets of atoms when convenient. The usual notion of con-
junctive query (CQ) is captured by CCQs without count-
ing variables (i.e. z = ;). A CCQ q is Boolean if x = ;.
Concept cardinality queries are Boolean CCQs of the form
9z A(z) (A 2 NC), while role cardinality queries have the
form 9z1; z2 R(z1; z2) (R 2 NR).

A match for a CCQ q in an interpretation I is a homomor-
phism from q into I, i.e. a function (cid:25) that maps each term
in q to an element of (cid:1)I such that (cid:25)(t) = t when t 2 NI,
(cid:25)(t) 2 AI for every A(t) 2 q, and ((cid:25)(t); (cid:25)(t0)) 2 PI for
every P(t; t0) 2 q. If a match (cid:25) maps x to a, then the re-
striction of (cid:25) to z is called a counting match (c-match) of
q(a) in I. The set of answers to q in I, denoted qI, contains
all pairs (a; [m; M ]), with m; M 2 N [ f+1g, such that
the number of distinct c-matches of q(a) in I belongs to the
interval [m; M ]. A certain answer to q w.r.t. K is an answer
in every model of K, that is a pair from T

I|=K qI.

it

As usual,

to consider

is sufﬁcient

the Boolean
case: (a; [m; M ]) is a certain answer to a CCQ q(x) iff
(;; [m; M ]) is a certain answer to the Boolean CCQ q(a)
obtained by replacing x with a. Thus, from now on, we
focus on Boolean CCQs, and work with candidate answers
[m; M ] in place of (;; [m; M ]).

We further observe that since ELHI ⊥ cannot restrict the
size of models, the least upper bound M in a certain answer
[m; M ] is: 0 if the underlying CQ is unsatisﬁable w.r.t. T ,
1 if q has a match in every model but z = ;; and +1 oth-
erwise. As the ﬁrst two cases can be readily handled using
existing techniques, we focus on identifying certain answers
of the form [m; +1].
Example 2. Let qe := 9y 9z R(y; z) ^ C(z) be a Boolean
CCQ. Intervals [0; +1] and [1; +1] are certain answers to
qe over Ke. Interval [4; +1] is not as the models depicted
on Figures 2a and 2c contain only 3 matches for qe.

To clarify how our notion of certain answer relates to stan-
dard OMQA semantics, we note that a Boolean CQ q is en-
tailed from K iff [1; +1] is a certain answer to q over K.

Complexity Given a ELHI⊥ knowledge base K =
(T ; A), a Boolean CCQ q, and an integer m (cid:21) 0 (in binary),
we are interested in the complexity of deciding whether
[m; +1] is a certain answer to q w.r.t. K. We will consider
the two usual complexity measures: combined complexity
which is in terms of the size of the whole input, and data
complexity which is only in terms of the size of A and m
(T and q are treated as ﬁxed). If O is a TBox, ABox, KB,
or CCQ, then the size of O, denoted jOj, is the number of
occurrences of concept and role names in O.

Normal form As is standard (see e.g. (Bienvenu et al.
2014)), we work with ELHI⊥ TBoxes in a convenient nor-
mal form, where every concept inclusion has one of the fol-
lowing restricted shapes:

A v ?

> v A

A1 u A2 v A

A1 v 9R:A2

9R:A1 v A2

with A; A1; A2 2 NC; R 2 N±
R . Through the introduction of
fresh concept names, we can transform in polynomial time
any TBox T into a normal-form TBox T 0 that is a model-
conservative extension of T (hence, indistinguishable from
T from the point of view of queries). We therefore assume
w.l.o.g. that all considered TBoxes are in normal form.

Closed Predicates A KB with closed predicates consists
of a KB (T ; A) and a set (cid:6) (cid:18) NC [ NR of closed predicates.
An interpretation I is a model of (T ; A; (cid:6)) if it is a model
of (T ; A) which interprets the closed predicates according
to A, i.e. AI = fa j A(a) 2 Ag for every A 2 (cid:6) \ NC and
PI = f(a; b) j P(a; b) 2 Ag for every P 2 (cid:6) \ NR. Query
entailment is then deﬁned as for classical KBs, but using this
modiﬁed notion of model.

3 General Case of CCQs
This section presents our main contributions: a decision pro-
cedure and associated tight complexity bounds for CCQ an-
swering in ELHI⊥ and its sublogics.

To improve readability, we have split the section into sev-
eral parts. Section 3.1 presents a double-exponential-time
decision procedure, whose correctness proof is detailed in
Section 3.2. We explain, in Section 3.3, how to shrink the
size of the models implicitly generated by our procedure,
which we use to show coNP data complexity. Finally, in
Section 3.4, we prove the required lower bounds.

3.1 Decision Procedure
In this subsection, we devise a procedure that computes in
double-exponential time the minimum amount of c-matches,
which immediately yields the following upper bound:

Theorem 1. CCQ answering in ELHI⊥ is in 2EXP w.r.t.
combined complexity.

Let us ﬁx a satisﬁable KB K = (T ; A) and a (Boolean)
CCQ q. The next lemma provides an upper bound on the
minimal number of c-matches.

Lemma 1. There exists a model of K with less than M :=
(jInd(A)j + 3 jT j 2|T |)|q| c-matches for q.

Proceedingsofthe19thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack55A2
(cid:14)

(cid:14)

A1; B; C
(cid:15)
a

(cid:14)A1

B
(cid:14)

(cid:14) A1

P2; R:A1

P2; R:A1

P3; R:A2

P∗; ;

P1; R:A2

P4; R:B

(cid:14) A2

P4; R:B

P5; R:C

B; C
(cid:15)b

(cid:14)(cid:13)

B; C

P5; R:C

A1
(cid:14)

(cid:14) A2

A1
(cid:14)

(cid:14) A2

(cid:14) B

(cid:14) B

B; C
(cid:15)b

(cid:14)(cid:13)

B; C

A1; B; C
(cid:15)
a

(a) A model Ie of Ke.

(b) Pattern tree Pe.

(c) Model I }

e built from P(cid:3)
e.

Figure 2: Interpretations and pattern tree used along our examples, labels for the only role R have been omitted for readability.

Proof sketch. We can exhibit a model having at most
jInd(A)j + 3 jT j 2|T | elements.

It follows that in any model I having a minimum num-
ber of c-matches, the set (cid:1)∗ (cid:18) (cid:1)I of elements appearing
in the image of a c-match has size at most M (cid:1) jqj. We can
thus iterate over all such (cid:1)∗, and even over all induced in-
terpretations I ∗ = I|(cid:1)(cid:3) , in double-exponential time w.r.t.
combined complexity. The core task will then be to deter-
mine, given such a candidate I ∗, whether we can extend I ∗
into a model of K without introducing new c-matches.

Let us ﬁx our candidate I ∗ and see how to check for a
suitable extension. The challenging axioms to handle are
those of the form A v 9R:B, as they might require us to
introduce new elements. We deﬁne the set (cid:10) := fR:B j
A v 9R:B 2 T g and call its members (existential) heads.
Importantly, as our correctness proof will establish, it is suf-
ﬁcient to consider extensions of I ∗ which are obtained by
adding tree-shaped structures of new elements, plus some
edges between the new elements and (cid:1)I(cid:3)
(we may need to
use elements from (cid:1)I(cid:3)
as witnesses for existential heads to
avoid new query matches). This property enables us to build
such an extension by piecing together local interpretations
corresponding to the addition of a single edge, using two
distinguished symbols } and ~ as placeholders for fresh el-
ements. We shall call these building blocks patterns, as they
are inspired by a notion of the same name introduced for CQ
answering with existential rules (Thomazo et al. 2012).

Patterns not only consist of a local interpretation, but
also other information needed to ensure that assembled pat-
terns do not violate any TBox axioms or introduce any new
matches. In particular, we shall keep track of (partial) query
matches involving the local elements using the notion of a
coherent speciﬁcation. Intuitively, such a speciﬁcation tells
us which matches should be realized in the constructed ex-
tension, and naturally contains at least the matches of sub-
queries of q already realized in the local interpretation.
Deﬁnition 1. Let I be an interpretation.
(cid:15) The speciﬁcation MI induced by I is the set of pairs
(r; (cid:25)) such that r (cid:18) q and (cid:25) : r ! I is a (full) match.
(cid:15) A coherent speciﬁcation M over I is a set of pairs (r; (cid:25))
where r (cid:18) q and (cid:25) is a partial mapping from terms(r) to
(cid:1)I such that M contains MI and if (r1; (cid:25)1); (r2; (cid:25)2) 2

M with (cid:25)1 and (cid:25)2 deﬁned and equal on var(r1) \ var(r2),
then (r1 [ r2; (cid:25)1 [ (cid:25)2) 2 M.
To check the compatibility of different speciﬁcations, we

will need to be able to restrict them to a subdomain:
Deﬁnition 2. The restriction of a speciﬁcation M over an
interpretation I to a domain (cid:1) (cid:18) (cid:1)I, denoted M|(cid:1) , is the
set of pairs (r; (cid:25)0) such that (cid:25)0 is the restriction of some (cid:25) to
(cid:25)−1((cid:1)) for some (r; (cid:25)) 2 M.
Remark 1. Induced speciﬁcations and restrictions of coher-
ent speciﬁcations are both coherent speciﬁcations.

Patterns will contain a further kind of information called
a prediction, deﬁned next. The purpose will be explained in
more detail once we introduce links between patterns, but
roughly it serves to coordinate the successor patterns of a
pattern to avoid violating negative role inclusions.
Deﬁnition 3. A prediction is a function next
(cid:1)I(cid:3)
T j= R1 u R2 v ?, then next(R1:B1) 6= next(R2:B2).

: (cid:10) !
for all R1:B1; R2:B2 2 (cid:10), if

[ (cid:10) verifying that:

We now formally deﬁne the central notion of pattern, rel-

ative to I ∗ and a candidate speciﬁcation M∗ over I ∗.
Deﬁnition 4. A pattern P (w.r.t. I ∗ and M∗) is a tuple
(frP ; genP ; IP ; MP ; nextP ) where:
(cid:15) The frontier and generated domains frP and genP are dis-

joints sets of elements from (cid:1)I(cid:3)

[ f}; ~g;

(cid:1)IP

(cid:15) IP is a T -saturated and T -satisﬁable interpretation with
[ frP [ genP and such that IP
(cid:15) MP is a coherent speciﬁcation of q over IP that preserves

|(cid:1)I(cid:3) = I ∗;

= (cid:1)I(cid:3)

M∗, that is (MP )|(cid:1)I(cid:3) = M∗;

(cid:15) nextP is a prediction.

We shall be interested in two types of patterns. The
(unique) initial pattern P∗ := (;; (cid:1)I(cid:3)
; I ∗; M∗; Id) simply
represents I ∗ and M∗. All other patterns of interest repre-
sent additions of a pair of adjacent elements, and frP
and
genP will be singletons (representing these two elements).
Example 3. In our running example, (cid:1)∗
:= fa; b; (cid:13)g
e
(z maps to only these elements). The initial pattern P∗
e
has frontier ;, generated terms (cid:1)∗
e :=
e :=
(Ie)|(cid:1)(cid:3)
(MIe )|(cid:1)(cid:3)

e, interpretation I ∗
depicted in Figure 3a, and speciﬁcation M∗
. Non-initial patterns will be illustrated later.

e

e

Proceedingsofthe19thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack56B; C
(cid:15)b

(cid:14)(cid:13)

B; C

A1; B; C
(cid:15)
a

B; C
(cid:15)b

(cid:14)(cid:13)

B; C

A1; B; C
(cid:15)
a

A2
(cid:14)
}

(I ∗
e )

A2
(cid:14)
}

A1
(cid:14)
~

(I ∗
e )

A1
(cid:14)
~

A2
(cid:14)
}

(I ∗
e )

A2
(cid:14)
}

B
(cid:14)
~

(a) Interp. I (cid:3)
e .

(b) Interp. of Pe
1.

(c) Interp. of Pe
2.

(d) Interp. of Pe
3.

(e) Interp. of Pe
4.

B; C
(cid:15)b

(cid:14)(cid:13)

B; C

A1; B; C
(cid:15) a

B
(cid:14)
~

(f) Interp. of Pe
5.

Figure 3: Interpretations of patterns from Example 4.

We now deﬁne how to combine patterns together, and

ﬁrst, when it is necessary to combine them.
Deﬁnition 5. We say that R:B 2 (cid:10) is applicable to e in a
pattern P if e 2 genP and there exists A v 9R:B 2 T with
e 2 AIP

but e =2 (9R:B)IP

.

When a head is applicable to a pattern, we need to ﬁnd
another pattern that can realize the head. This is formalized
by the following notion of link between patterns, which re-
quires that the two patterns are compatible (Conditions 1, 2,
3), the second pattern realizes the head (Condition 4), and
certain consistency conditions hold (Conditions 5, 6).
Deﬁnition 6. Let R:B be an applicable head on e1 in a
pattern P1. There is a (R:B; e1)-link from P1 to P2 if:
1. frP2 = fe1g and genP2 is a singleton, say fe2g;
2. For all concept name A, we have e1 2 AIP1 iff e1 2 AIP2 ;
3. MP1
4. e2 2 BIP2 and for all P 2 NR: PIP2 = PI(cid:3)
T j= R v Pg [ f(e2; e1) j T j= R− v Pg

|(cid:1)I(cid:3) ∪{e1} = MP2

|(cid:1)I(cid:3) ∪{e1};

[ f(e1; e2) j

, then e2 = nextP1 (R:B).

\ frP1 , then IP1 [ IP2 is T -satisﬁable.

the set of patterns P2 such that there is a

5. If ever e2 2 (cid:1)I(cid:3)
6. If e2 2 (cid:1)I(cid:3)
We denote LR:B
P1;e1
(R:B; e1)-link from P1 to P2.
Remark 2. Predictions are used in Condition 6 to avoid
problematic situations where two successor patterns merge
back to the same element of (cid:1)I(cid:3)
. Speciﬁcally, if we have
a R1:B1-link from P0 to P1 and a R2:B2-link from P0 to
P2, with T j= R1 u R2 v ?, then nextP0 (R1:B1) 6=
nextP0 (R2:B2), preventing P1 and P2 from using the same
element of (cid:1)I(cid:3)
as generated term (which would violate T ).
Condition 5 is similar in spirit, handling the case of the pat-
tern P1 using the frontier element of P0 as a generated term.
Example 4. We consider patterns Pe
5 whose inter-
pretations are depicted in Figure 3. Frontier terms are indi-
cated by square-purple and generated terms by circle-green.
, which maps R:C to (cid:13).
Predictions are Id except for nextPe
Speciﬁcations Mi are given by: M1 = M∗
e [f((cid:11)R; (y; z) 7!
(a; })); ((cid:11)R; z 7! }); ((cid:11)R; y 7! })g; M5 = M∗
e [
f(qe; (y; z) 7! (~; (cid:13))); ((cid:11)R; (y; z) 7! (~; (cid:13))); ((cid:11)R; z 7!
~)g; M4 = M1 [ M5 [ f((cid:11)R; (y; z) 7! (}; ~))g; M2 =
M4 n f((cid:11)R; z 7! ~)g; M3 = M5 [ f((cid:11)R; (y; z) 7!
(a; })); ((cid:11)R; (y; z) 7! (~; })); ((cid:11)R; y 7! })g, where (cid:11)R
denotes R(y; z). Observe that Mi may include (partial)

1; : : : ; Pe

4

matches which are not present in Pe
i ’s interpretation but are
useful for linking patterns, e.g. (qe; (y; z) 7! (~; (cid:13))) in M4
enables a (R:C; ~)-link from Pe

5 (see Example 5).

4 to Pe

We now characterize patterns that cannot be used to sat-

isfy a head without introducing a new c-match.
Deﬁnition 7. A pattern P is rejecting if one of the two fol-
lowing conditions holds:
(cid:15) There exists (q; (cid:25)) 2 MP with (cid:25)(z) \ f}; ~g 6= ;;
(cid:15) There exists an existential head R:B that applies on e in

P such that all patterns P0 2 LR:B

P;e are rejecting.

A pattern is accepting if it is not rejecting.

The acceptance of the initial pattern P∗ is a sufﬁcient con-
dition ensuring I ∗ extends to a model having no more c-
matches than encoded in M∗, i.e.
the pairs (q; (cid:25)) 2 M∗
such that (cid:25) is deﬁned for all counting variables.
Lemma 2. If P∗ := (;; (cid:1)∗; I ∗; M∗; Id) is accepting, then
there exists a model I ♦ such that I ∗ (cid:18) I ♦ and if (cid:25) : q !
I ♦ is a c-match, then (q; (cid:25)) 2 M∗. In particular, I ♦ has at
most as many c-matches as those encoded in M∗.

Furthermore,

the minimum amount of c-matches is

reached among initial patterns due to the following result:
Lemma 3. If I is a model of K with m c-matches, then
there exists an accepting initial pattern whose speciﬁcation
encodes exactly m c-matches.

Before proving Lemmas 2 and 3, let us recap the overall

double-exponential procedure underlying Theorem 1:

Proof of Theorem 1. We consider all possible initial pat-
terns P∗ with an interpretation domain (cid:1)∗ such that
Ind(A) (cid:18) (cid:1)∗ and j(cid:1)∗j (cid:20) M jqj (recall Lemma 1). Every
such P∗ is of single-exponential size w.r.t. combined com-
plexity (observe that its speciﬁcation M∗ corresponds to a
subset of 2q (cid:2) ((cid:1)∗ [ f"g)q, where " is a fresh symbol wit-
nessing the use of partial mappings), and thus are double-
exponential in number (up to isomorphism) and can be enu-
merated in double-exponential time. For each such P∗, we
construct in double-exponential time the set of all possible
descendant patterns of P∗ (which are of single-exponential
size, having at most j(cid:1)∗j + 2 elements). We then check
whether each possible pattern (P∗ or candidate descendant)
is in fact a well-deﬁned pattern, in particular, its interpreta-
tion is T -satisﬁable and T -saturated. These veriﬁcations can
be done in double-exponential time, recalling that KB satis-
ﬁability and instance checking are in EXP for ELHI⊥ (even

Proceedingsofthe19thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack57the variant with negative role inclusions, see e.g. (Bienvenu
et al. 2014)). Acceptance of P∗ is tested (again in determin-
istic exponential time) by repeatedly iterating over the set of
patterns and removing those that are rejecting either due to
their speciﬁcation, or due to the removal of all patterns that
could provide a link for an applicable head. If P∗ is found to
be accepting and M∗ encodes m c-matches, then Lemma 2
ensures the existence of a model with at most m c-matches.
Conversely, Lemma 3 ensures that we can ﬁnd the smallest
such m among the accepting initial patterns.

3.2 Proofs of Lemmas 2 and 3
We now prove the central lemmas of the correctness proof.

From Accepting Patterns to Models To prove Lemma 2,
let us suppose we are given an initial pattern P∗
:=
(;; (cid:1)∗; I ∗; M∗; Id) that is accepting. Our aim is to construct
a model I ♦ that extends I ∗ and is such that (q; (cid:25)) 2 M∗ for
every c-match (cid:25) : q ! I ♦.

We proceed as follows. For each accepting descendant
pattern P (w.r.t. I ∗ and M∗) and each head R:B applicable
to e in P, we choose an accepting pattern chR:B
P;e from LR:B
P;e .
Then, starting from P∗, we build a tree-shaped set of words,
whose letters consist of an accepting pattern and existential
head, and which witnesses the acceptance of P∗.
Deﬁnition 8. The pattern tree P is deﬁned as the smallest
set of words such that:
(cid:15) (P∗; ;) 2 P;
(cid:15) If w (cid:1) (P; h) 2 P and R:B is applicable to e in P, then

P;e ; R:B) 2 P.

w (cid:1) (P; h) (cid:1) (chR:B
It remains to ‘glue’ together the interpretations IP accord-
ing to the structure of P. Since a pattern P may occur more
than once, we create a copy of IP for each node in P of
the form w (cid:1) (P; h). We do not duplicate however elements
from I ∗ as they precisely are those we want to reuse. Hence
only the frontier term and the generated term may be dupli-
cated (provided they do not belong to (cid:1)∗). When a node
w (cid:1) (P1; h1) (cid:1) (P2; h2) is encountered, we merge the frontier
term of P2 with the already-introduced copy of the gener-
ated element from P1 on which h2 is applied (which is the
only element in frP2 ). Therefore, when considering such a
node w (cid:1) (P1; h1) (cid:1) (P2; h2), the only element we might have
to introduce is a copy of the generated term e of P2 (unless
e 2 (cid:1)∗), which we shall simply name w (cid:1) (P1; h1) (cid:1) (P2; h2).
Formally, the copying and merging of elements is achieved
by the following family of duplicating functions, deﬁned in-
ductively for each w (cid:1) (P; h) 2 P.

(cid:21)w·(P;h) : (cid:1)IP

[ fw; w (cid:1) (P; h)g

! (cid:1)I(cid:3)
8
e
<
w
w (cid:1) (P; h)

:

e 7!

if e 2 (cid:1)I(cid:3)
if e 2 frP n (cid:1)I(cid:3)
if e 2 genP n (cid:1)I(cid:3)

Note that if e 2 frP2 n (cid:1)I(cid:3)

, hence
(cid:21)w·(P1;h1)·(P2;h2)(e) = (cid:21)w·(P1;h1)(e) = w (cid:1) (P1; h1):

, then e 2 genP1 n (cid:1)I(cid:3)

The desired model I ♦ can then be deﬁned as follows:
[

(cid:21)w·(P;h)(IP ):

I ♦ :=

w·(P;h)∈P

Example 5. The patterns introduced in Example 4 are sufﬁ-
cient to witness that P∗
e is accepting. The initial part of Pe is
depicted in Figure 2b. The resulting I ♦
e is depicted in Fig-
ure 2c. Notice how it inherits the tree-shaped structure of
Pe up to roles collapsing back in I ∗
e .

By deﬁnition, each (cid:21)w·(P;h) is a homomorphism from IP
to I ♦. Due to Condition 2, the shared element of linked pat-
terns must belong to the same concepts, so concept member-
ship in I ♦ transfers back to IP :
Lemma 4. For all w (cid:1) (P; h) 2 P, for all e 2 (cid:1)IP
all A 2 NC, if (cid:21)w·(P;h)(e) 2 AI}

, then e 2 AIP

and for

.

P;e and P2 = chh2

An analogous property fails however for roles, as two pat-
terns P1 = chh1
P;e may reuse the same ele-
ment from (cid:1)∗, that is, genP1 = genP2 2 (cid:1)∗. In that case,
|(cid:1) where (cid:1) := (cid:21)w·(P;h)·(P1;h1)(IP1 ) may
satisﬁed roles in I ♦
not be satisﬁed in IP1 . Conditions 5 and 6 allow us to show
the following weaker property, sufﬁcient for our purposes:
Lemma 5. For all w (cid:1) (P; h) 2 P, d; e 2 (cid:1)IP
NR: if ((cid:21)w·(P;h)(d); (cid:21)w·(P;h)(e)) 2 PI}
T -satisﬁable if we add (d; e) to PIP

, and P 2
, then IP remains

.

A similar lemma (given in the appendix) allows us to lift
query matches from I ♦ to patterns, yielding the following:
Proposition 1. I ♦ is a model of K whose c-matches are
included in those encoded in M∗.

From a Model to an Accepting Initial Pattern We now
turn to the proof of Lemma 3. We ﬁx a model I of K, and
our task is to construct an accepting initial pattern having the
same number of c-matches as I.

Let (cid:1)∗ be the subset of (cid:1)I consisting of all individuals
in A and all elements e such that e = (cid:25)(z) for some (cid:25) :
q ! I and counting variable z. Set I ∗ := I|(cid:1)(cid:3) and M∗ :=
(MI)|(cid:1)(cid:3) . Notice in particular that the number of c-matches
for q encoded in M∗ is exactly the number of c-matches for q
in I. We claim that P∗ := (;; (cid:1)∗; I ∗; M∗; Id) is accepting.
To prove this, we shall build a set of patterns, whose every
pattern P is not trivially rejecting, i.e. P does not satisfy the
base-case condition of a rejecting pattern, and which is real-
ized in I, meaning that IP homomorphically embeds into I.
Observe that the initial pattern P∗ satisﬁes both conditions.
To pursue the construction, given any pattern P satisfying
the two conditions and a head h applicable to P, we show
how to extract from I another Q which satisﬁes the condi-
tions and which makes h hold for P. Since the number of
patterns is ﬁnite, every sequence of patterns constructed in
such a manner either leads to a trivially accepting pattern
(i.e. one with no applicable heads) or loops back to an al-
ready explored pattern satisfying the conditions. It follows
that all patterns in the set are accepting (in particular, P∗).

To formalize the construction, we shall introduce a func-
tion (cid:28) associating to each pattern P a homomorphism IP !
I. Furthermore, we shall assume that, for every R:A 2 (cid:10),
we have chosen a function succI
R:A that maps every element
e 2 (9R:A)I to an element e0 2 (cid:1)I such that (e; e0) 2 RI
and e0 2 AI. The construction begins with P∗, for which

Proceedingsofthe19thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack58we set (cid:28) (P∗) := IdI(cid:3)→I. Next we take some already con-
structed pattern P1 with its associated function (cid:28) (P1), and
consider a head R:B that is applicable to e1 in P1. Since R:B
applies to e, there must exist A 2 NC such that e 2 AIP1
1 := (cid:28) (P1)(e1). Since
and T j= A v 9R:B. Set e0
(cid:28) (P1) is a homomorphism and I is a model of T , we obtain
e0
1 2 (9R:B)I and can set e0
R:B(e0
2 2 (cid:1)∗,
2, otherwise we set e2 to either } or ~
then we set e2 := e0
such that e1 6= e2.

2 := succI

1). If e0

We can now deﬁne the new pattern P2. Its frontier is e1

and its generated term is e2. Its interpretation is given by:

CIP2
PIP2

:= CI(cid:3)
:= PI(cid:3)

[ fek j e0
k 2 CI; k = 1; 2g
[ f(e1; e2) j T j= R v Pg
[ f(e2; e1) j T j= R− v Pg

1 and e2 to e0

2} in which e0

1 (resp. e0
Its speciﬁcation is (MI)|(cid:1)(cid:3)∪{e0
2)
1;e0
has been replaced by e1 (resp. e2).
Its prediction maps a
head h to the value of succI
h(e0
2) if it is deﬁned, else to h.
Finally, we let (cid:28) (P2) be the function that maps elements of
(cid:1)∗ to themselves, e1 to e0
2. Recalling that I is
a model, of K it is then straightforward to verify that P2 is a
well-deﬁned not-trivially-rejecting pattern, satisfying P2 2
LR:B
, and such that (cid:28) (P2) is indeed a homomorphism.
P1;e1
Example 6. In the model Ie, depicted in Figure 2a, we
can set succIe
(a) := (cid:14) (other choices of successors are
unique), and then apply the preceding construction to ob-
tain the accepting patterns from Example 4.

R:A2

3.3 Obtaining Bounded-Size Optimal Models
To obtain optimal models of bounded size, we start from
the pattern tree P and model I ♦ we constructed from an
accepting initial pattern.
It remains to merge elements of
I ♦ to obtain a model of the required size. To identify similar
elements, we consider their neighbourhoods.
Deﬁnition 9. Consider an interpretation I and an element
c 2 (cid:1)I. Its n-neighbourhood N I;(cid:1)
(c) w.r.t. a subdomain
n
(cid:1) (cid:18) (cid:1)I is deﬁned inductively as:
N I;(cid:1)
(c) := fcg
0
N I;(cid:1)
n+1 (c) := N I;(cid:1)

9d 2 N I;(cid:1)
(c) n (cid:1);
n
9R 2 N±
R ; (d; e) 2 RI

(cid:26)
e

(c) [

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:27)

n

Observe that we stop adding successors when we reach (cid:1).
To characterize neighbourhoods in I ♦ (w.r.t. domain (cid:1)∗),
we focus on the tree-like structure inherited from P. Recall
that we kept a single pattern for each head R:B applicable to
an element e of a pattern P, namely chR:B
P;e . We can thus con-
sider the bijection (cid:27) mapping (P∗; ;) (cid:1) (P1; h1) (cid:1) (cid:1) (cid:1) (Pn; hn)
(with n (cid:21) 1) to ah1 : : : hn, where a is such that frP1 = fag;
we extend (cid:27) to (cid:1)∗ by letting (cid:27)(e) = e for e 2 (cid:1)∗. In-
spired by the notion of interleaving used in the DL-Lite set-
ting (Kostylev and Reutter 2015), we deﬁne the interlacing
I 0 := (cid:27)(I ♦), obtained by renaming elements of I ♦ using (cid:27).
Denote by (cid:1)◦ := (cid:1)∗ [ (cid:27)(P n P∗) the forest-shaped domain
that is to I 0 what P is to I ♦. We deﬁne an associated map-
ping f 0 : (cid:1)◦ ! I 0 by setting f 0 := (cid:27) (cid:14) f (cid:14) (cid:27)−1 where f
maps each element of (cid:1)∗ to itself and each w (cid:1) (P; h) 2 P
to (cid:21)w·(P;h)(e) where genP = feg.

n

The deﬁnition of I 0 ensures that every c 2 (cid:1)I0

n (cid:1)∗ be-
longs to (cid:27)(P n P∗) and thus c = aw for some a 2 (cid:1)∗ and
word w 2 (cid:10)∗. The tree-shaped structure of (cid:1)◦ ensures that
for all n, there exists a unique preﬁx rn;c of aw such that (i)
f 0(rn;c) 2 N I0;(cid:1)(cid:3)
(c), there
exists a unique word wd
n;c).

(c) and (ii) for any d 2 N I0;(cid:1)(cid:3)

n;c such that d = f 0(rn;c (cid:1) wd

This leads us to characterize the n-neighbourhood of an
element c 2 I 0 via the following function (cid:31)n;c, whose do-
main (cid:10)n is the set of words over (cid:10) with length (cid:20) 2n. Notice
that, departing from (Kostylev and Reutter 2015), we keep
track of sets of satisﬁed concepts, in order to handle con-
junctions of concepts in the left-hand sides of axioms.

n

(cid:31)n;c : (cid:10)n ! (cid:1)∗ [ 2sig(T ) [ f;g

w 7!

8
<

:

;
f 0(rn;cw)
fA 2 sig(T ) j f 0(rn;cw) 2 AI0

if f 0(rn;cw) undeﬁned
if f 0(rn;cw) 2 (cid:1)∗
otherwise

g

We can now introduce the equivalence relation we use to

merge elements:
Deﬁnition 10. The equivalence relation (cid:24)n on (cid:1)I0
is de-
ﬁned as follows: an element e 2 (cid:1)∗ is (cid:24)n-equivalent only
to itself; elements c1; c2 from (cid:1)I0
n (cid:1)∗ are (cid:24)n-equivalent iff
wc1
, (cid:31)n;c1 = (cid:31)n;c2 , and jc1j = jc2j mod 2jqj+3.
n;c1
We obtain a ﬁnite model of the required size by merging

= wc2

n;c2

elements with respect to (cid:24)|q|+1.
Theorem 2. The interpretation J := I 0=(cid:24)|q|+1 is a model
of K that has at most as many c-matches for q as I ♦. Its
size is polynomial w.r.t. data complexity, double-exponential
w.r.t. combined complexity, and single-exponential if the size
of the CCQ q is ﬁxed.

|q|

(c) ! N I0;(cid:1)(cid:3)

Proof sketch. The key to proving that the amount of c-
matches does not increase through the quotient operation is
to exhibit suitable local homomorphisms. Indeed, a match
of q in J maps each connected component C of q into a
jqj-neighbourhood N J ;(cid:1)(cid:3)
(c), where c denotes the equiv-
alence class of c w.r.t. (cid:24)|q|+1 and (cid:1)∗ stands for the set
fe j e 2 (cid:1)∗g. By exhibiting a homomorphism (cid:26)c
:
N J ;(cid:1)(cid:3)
(c) such that (cid:26)−1
n;c((cid:1)∗) (cid:18) (cid:1)∗, we can
|q|
ﬁnd a match of C in I 0. Such matches for q’s connected
components together form a match of the full q in I 0. It is
mostly straightforward to show that J is a model, except for
negative role inclusions, where the homomorphisms (cid:26)c are
needed to move violations of R1 u R2 v ? in J back into
I 0. The claimed upper bounds are obtained by analyzing
the size of J (i.e. counting the equivalence classes in (cid:1)J ),
keeping in mind that due to Lemma 1, we may assume that
j(cid:1)∗j (cid:20) jInd(A)j + jqj (jInd(A)j + 3 jT j 2|T |)|q|.

|q|

From Theorem 2, it follows that there exists a model min-
imizing the amount of c-matches with polynomial size w.r.t.
data complexity. One can therefore non-deterministically
guess this interpretation before verifying it is indeed a model
and comparing its amount of c-matches with the input in-
teger. The two latter steps can be done in (deterministic)
polynomial time w.r.t. data complexity, yielding an upper

Proceedingsofthe19thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack59bound in data complexity for CCQ answering, matching the
corresponding results in the DL-Lite setting (Kostylev and
Reutter 2015; Bienvenu, Mani`ere, and Thomazo 2020).
Theorem 3. CCQ answering in ELHI⊥ is in coNP w.r.t.
data complexity.

3.4 Matching Lower Bounds
We now provide 2EXP lower bounds for EL and DL-LiteH
pos,
which together with Theorem 1, establish the 2EXP-
completeness of CCQ answering for ELHI and every
sublogic that extends EL or DL-LiteH
pos. The proofs are by
reduction from the problem of answering Boolean union of
conjunctive queries (BUCQs) over KBs with closed predi-
cates, proven 2EXP-hard in (Ngo, Ortiz, and ˇSimkus 2016).
Theorem 4. CCQ answering in EL is 2EXP-hard w.r.t. com-
bined complexity.

Proof sketch. Consider an EL KB K = (T ; A; (cid:6)) with
closed predicates and a BUCQ q = Wl
k=1 qk. Examining the
2EXP-hardness proof from (Ngo, Ortiz, and ˇSimkus 2016),
we may assume that (cid:6) consists only of concept names and
each qk is connected and has only variables as terms.

Pick a fresh individual aux not used in A, and let A0 be ob-
tained from A by adding A(aux) for every concept name A
in K and P(aux; aux) for every role name P in K. Consider
the KB K0 = (T ; A0) and the CCQ q0 built as the conjunc-
tion of (i) all of the CQs qk in q (with all variables treated
as counting variables), (ii) the query qA = 9zA A(zA) for
each A 2 (cid:6), and (iii) the queries q+
P = 9z+
P ; aux) and
P = 9z−
q−
P P(aux; z−
P ) for each role name P from K. For
each A 2 (cid:6), let nA be the number of individuals a such that
A(a) 2 A, and set N := Q
A∈(cid:6)(nA + 1). To complete the
proof, one can show that N + 1 is a certain answer to q0 over
K0 iff K entails q.

P P(z+

4 Cardinality Queries
In this section, we focus on the restricted class of cardinality
queries, which allow one to count the number of elements
belonging to a given concept or role name.

To reduce the number of cases to be studied, we ﬁrst no-
tice that role cardinality queries are always harder than con-
cept cardinality queries for the logics we consider.
Theorem 7. Let L be a sublogic of ELHI⊥ that can express
A v 9P:> (A 2 NC, P 2 NR). Then concept cardinality
query answering over L KBs can be polynomially reduced
to role cardinality query answering over L KBs.

Proof. Take a concept cardinality query qA = 9zA(z) and a
KB K = (T ; A). We pick a fresh role name P 62 sig(K), and
consider the role cardinality query qP = 9z1; z2 P(z1; z2)
and modiﬁed TBox T 0 := T [ fA v 9P:>g.

Any model I of K can be extended to a model I 0 of
K0 = (T 0; A) by setting PI0
:= f(e; e) j e 2 AIg. Indeed,
this ensures satisfaction of the additional axiom A v 9P:>.
Moreover, as no new domain elements were introduced, ax-
ioms > v B from T remain satisﬁed, and all other axioms
are not affected since P =2 sig(T ).

Notice that qA has exactly as many matches in I as qP has
in I 0, hence an interval [m; +1] is a certain answer to qA
over K iff it is a certain answer to qP over K0.

4.1 Results for EL and its Extensions
The next two results, together with Theorem 7, establish
that cardinality query answering is coNEXP-complete w.r.t.
combined complexity in ELHI⊥ and ELI⊥.
Theorem 8. Role cardinality query answering in ELHI⊥
is in coNEXP w.r.t. combined complexity.

Proof. Theorem 2 proves that
matches is reached with a model of exponential size.

the minimal number of

Theorem 5. CCQ answering in DL-LiteH
w.r.t. combined complexity.

pos is 2EXP-hard

Theorem 9. Concept cardinality query answering in ELI⊥
is coNEXP-hard w.r.t. combined complexity.

Proof. As the 2EXP-hardness proof for DL-LiteH
core from
(Ngo, Ortiz, and ˇSimkus 2016) does not involve negative
inclusions, we can employ the same approach as for EL (the
added aux assertions cannot lead to inconsistency).

We thus close the open question of the combined com-
plexity of CCQ answering in DL-LiteH
core. Note that our
lower bound applies even to the subclass of CCQs whose
every variable is a counting variable, as considered in
(Kostylev and Reutter 2015; Calvanese et al. 2020a).

The preceding lower bound does not apply to DL-Litepos,
for which coNEXP membership has been shown (Kostylev
and Reutter 2015; Bienvenu, Mani`ere, and Thomazo 2020).
We pinpoint the exact complexity by giving a matching
lower bound, via a reduction from the exponential grid tiling
problem. Here again the lower bound holds even when re-
stricted to CCQs with only counting variables.
Theorem 6. CCQ answering in DL-Litepos is coNEXP-hard
w.r.t. combined complexity.

Proof sketch. The proof proceeds by reduction from the
complement of the Succinct-3COL problem, known to be
NEXP-complete (Papadimitriou and Yannakakis 1986).

The coNEXP lower bound relies on KBs that only ad-
mit exponentially large models.
For logics admitting
polynomial-sized models, the complexity slightly decreases.
Theorem 10. Let L be a sublogic of ELHI⊥ for which ev-
ery satisﬁable KB admits a polynomial-sized model. Then
role cardinality query answering over L KBs is in EXP.

Proof sketch. The key observation is that, for logics with
polysize models and single-atom queries, the optimal num-
ber of matches is bounded polynomially in the size of the
KB. We can thus iterate over all polynomial-sized ABoxes
that could represent the restriction of an optimal model to
the ABox and elements in matches. We test whether such
an ABox extends to a model without new matches by per-
forming a satisﬁability check, taking the query role as closed
predicate. This gives a deterministic single-exponential time

Proceedingsofthe19thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack60procedure, since satisﬁability of ELHI⊥ KBs with closed
predicates is in EXP (Ngo, Ortiz, and ˇSimkus 2016).

Corollary 1. Role cardinality query answering in ELH⊥ is
in EXP w.r.t. combined complexity.

Proof sketch. We observe that a variant of the compact
canonical model used in the combined approach (Lutz,
Toman, and Wolter 2009), provides a model also for ELH⊥
KBs with negative role inclusions.

Corollary 2. Role cardinality query answering in ELHI is
in EXP w.r.t. combined complexity.

Proof. Existence of polynomial-sized models is trivial due
to the absence of negative inclusions. For example, extend-
ing A with every possible fact constructed from Ind(A) and
sig(K) yields a model of K = (T ; A).

We conclude this subsection by providing matching lower

bounds for concept cardinality queries in EL.
Theorem 11. Concept cardinality query answering in EL is
EXP-hard w.r.t. combined complexity.

Proof sketch. The proof is by reduction from the problem of
deciding if an EL KB with closed predicates is satisﬁable,
proven EXP-hard in (Ngo, Ortiz, and ˇSimkus 2016).

Theorem 12. Concept cardinality query answering in EL is
coNP-hard w.r.t. data complexity.

Proof sketch. We reduce the complement of the graph 3-
colorability problem to answering the cardinality query
9z B(z) w.r.t. the TBox T containing A v 9R:B and
9R:Ck u 9E:(9R:Ck) v B for k 2 f1; 2; 3g.

4.2 Results for DL-Lite
The data complexity picture being already known from the
literature (Bienvenu, Mani`ere, and Thomazo 2021), we fo-
cus on combined complexity.

We start by establishing tractabililty for DL-Lite(H)

pos KBs.
Theorem 13. Concept cardinality query answering in
DL-Litepos is NL-hard w.r.t. combined complexity.

Proof sketch. We
st-connectivity problem,
(Immerman 1999).

proceed

by

reduction

from the
known to be NL-complete

Theorem 14. Concept cardinality query answering in
DL-LiteH

pos is in NL w.r.t. combined complexity.

Proof. Let qC = 9z C(z) be a concept cardinality query.
Starting from the canonical model CK of a KB K = (T ; A),
the minimal number of matches can easily be computed.

(cid:15) If there exists an individual a 2 Ind(A) such that K j=
C(a), then we can collapse all anonymous elements onto
one such individual (the choice doesn’t matter), obtaining
a model in which matches are exactly such individuals a,
which is clearly minimal (recall we make the UNA). We
can check whether K j= C(a) in NL (Artale et al. 2009)

(cid:15) Otherwise, if there exists an anonymous match in CK,
then we collapse all anonymous elements onto a chosen
ABox individual, obtaining a model with a single match
for qC, which is clearly optimal. Existence of an anony-
mous match can be checked in NL (Artale et al. 2009).
(cid:15) Otherwise, there are no matches in CK, hence 0 is the min-

imal number of matches.

Notice that we do not need to actually compute the model
corresponding to the optimal number of matches, and we
only need to compare that number to the input integer.

Theorem 15. Role
DL-Litepos is in NL w.r.t. combined complexity.

cardinality query answering in

Proof sketch. The proof relies on the same principle as The-
orem 14, with a more sophisticated case analysis.

rather than DL-LiteH
in DL-LiteH

Note that the preceding theorem concerns DL-Litepos
pos, as role cardinality query answering

pos is coNP-hard even w.r.t. data complexity.

The introduction of disjointness axioms also leads to in-

tractability, even for concept cardinality queries.
Theorem 16. Concept cardinality query answering in
DL-Litecore is coNP-hard w.r.t. combined complexity.

Proof. Let G = (V; E) be an undirected graph, and consider

TG =

[

v∈V

fA v 9V; 9V− v Cg[

[

{v1;v2}∈E

f9V−

1 v :9V−

2 g:

It is easily veriﬁed that G 2 3COL iff [4; +1] =2 qKG for the
KB KG := (TG; fA(a)g) and query q = 9z C(z).

Theorem 17. Role
DL-LiteH

core is in coNP w.r.t. combined complexity.

cardinality query answering in

Proof sketch. One guesses a small counterexample to
[m; +1] being a certain answer, relying on the existence
of small models, atomicity of the query, and Theorem 3 of
(Ngo, Ortiz, and ˇSimkus 2016).

5 Outlook
In this paper, we have extended the study of CCQ answer-
ing to Horn DLs outside the DL-Lite family, establishing a
complete picture of the combined and data complexity of
the problems of answering CCQs and cardinality queries in
ELHI⊥ and its various sublogics.
Interestingly, the new
techniques we devised also allowed us to close some open
questions concerning the combined complexity of CCQ an-
swering in DL-Lite. Going forward, the main challenge is
to develop practical algorithms. A ﬁrst direction is to look
for restrictions on the query or ontology that ensure polyno-
mial data complexity for logics of the EL family. Second, it
would be desirable, for EL but also for DL-Lite, to develop
more reﬁned coNP procedures that are amenable to imple-
mentation using SAT solvers. We believe that our improved
understanding of the structure of optimal models will prove
helpful for both of these research directions.

Proceedingsofthe19thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack61Lutz, C.; Toman, D.; and Wolter, F. 2009. Conjunctive
query answering in the description logic EL using a rela-
In Proceedings of the 21st Inter-
tional database system.
national Joint Conference on Artiﬁcial Intelligence (IJCAI),
2070–2075.
Ngo, N.; Ortiz, M.; and ˇSimkus, M. 2016. Closed pred-
icates in description logics: results on combined complex-
In Proceedings of the 15th International Conference
ity.
on Principles of Knowledge Representation and Reasoning
(KR), 237–246.
Nikolaou, C.; Kostylev, E. V.; Konstantinidis, G.; Kaminski,
M.; Grau, B. C.; and Horrocks, I. 2019. Foundations of
ontology-based data access under bag semantics. Journal of
Artiﬁcial Intelligence (AIJ) 91 – 132.
Papadimitriou, C. H., and Yannakakis, M. 1986. A note on
succinct representations of graphs. Information and Control
71(3):181–185.
Poggi, A.; Lembo, D.; Calvanese, D.; De Giacomo, G.;
Lenzerini, M.; and Rosati, R. 2008. Linking data to on-
tologies. Journal of Data Semantics (JoDS) 10:133–173.
Rudolph, S.; Kr¨otzsch, M.; and Hitzler, P.
2012.
Type-elimination-based reasoning for the description logic
SHIQbs using decision diagrams and disjunctive datalog.
Logical Methods in Computer Science (LMCS) 8(1).
Thomazo, M.; Baget, J.; Mugnier, M.; and Rudolph, S.
2012. A generic querying algorithm for greedy sets of ex-
In Proceedings of the 13th International
istential rules.
Conference on Principles of Knowledge Representation and
Reasoning (KR).
Xiao, G.; Calvanese, D.; Kontchakov, R.; Lembo, D.; Poggi,
A.; Rosati, R.; and Zakharyaschev, M. 2018. Ontology-
based data access: a survey. In Proceedings of the 27th Inter-
national Joint Conference on Artiﬁcial Intelligence (IJCAI),
5511–5519.

Acknowledgments
Partially supported by ANR project CQFD (ANR-18-CE23-
0003).

References
Artale, A.; Calvanese, D.; Kontchakov, R.; and Za-
kharyaschev, M. 2009. The DL-Lite family and relations.
Journal of Artiﬁcial Intelligence Research (JAIR) 36:1–69.
Baader, F.; Brandt, S.; and Lutz, C. 2005. Pushing the
EL envelope. In Proceedings of the 19th international joint
conference on Artiﬁcial intelligence (IJCAI), 364–369.
Bienvenu, M., and Ortiz, M. 2015. Ontology-mediated
query answering with data-tractable description logics.
In
Tutorial Lectures of the 11th Reasoning Web International
Summer School (RW), 218–307.
Bienvenu, M.; Calvanese, D.; Ortiz, M.; and Simkus, M.
2014. Nested regular path queries in description logics. In
Proceedings of the 14th International Conference on Prin-
ciples of Knowledge Representation and Reasoning (KR),
218–227.
Bienvenu, M.; Mani`ere, Q.; and Thomazo, M. 2020. An-
swering counting queries over DL-Lite ontologies. In Pro-
ceedings of the 29th International Joint Conference on Arti-
ﬁcial Intelligence (IJCAI), 1608–1614.
Bienvenu, M.; Mani`ere, Q.; and Thomazo, M. 2021. Car-
dinality queries over DL-Lite ontologies. In Proceedings of
the 30th International Joint Conference on Artiﬁcial Intelli-
gence (IJCAI), 1801–1807.
Calvanese, D.; Giacomo, G. D.; Lembo, D.; Lenzerini, M.;
and Rosati, R. 2007. Tractable reasoning and efﬁcient query
answering in description logics: The DL-Lite family. Jour-
nal of Automated Reasoning (JAR) 39(3):385–429.
Calvanese, D.; Kharlamov, E.; Nutt, W.; and Thorne, C.
2008. Aggregate queries over ontologies. In Proceedings
of the 2nd International Workshop on Ontologies and Infor-
mation Systems for the Semantic Web (ONISW), 97–104.
Calvanese, D.; Corman, J.; Lanti, D.; and Razniewski, S.
2020a. Counting query answers over a DL-Lite knowledge
base. In Proceedings of the 29th International Joint Confer-
ence on Artiﬁcial Intelligence (IJCAI), 1658–1666.
Calvanese, D.; Corman, J.; Lanti, D.; and Razniewski, S.
2020b. Rewriting count queries over DL-Lite TBoxes with
In Proceedings of the 33rd Interna-
number restrictions.
tional Workshop on Description Logics (DL).
Eiter, T.; Lutz, C.; Ortiz, M.; and Simkus, M. 2009. Query
answering in description logics: the knots approach. In Pro-
ceedings of the 16th International Workshop on Logic, Lan-
guage, Information and Computation (WoLLIC), 26–36.
Feier, C.; Lutz, C.; and Przybylko, M. 2021. Answer count-
ing under guarded TGDs. In Proceedings of the 24th Inter-
national Conference on Database Theory (ICDT).
Immerman, N. 1999. Descriptive complexity.
Kostylev, E. V., and Reutter, J. L. 2015. Complexity of
answering counting aggregate queries over DL-Lite. Journal
of Web Semantics (JWS) 94–111.

Proceedingsofthe19thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack62