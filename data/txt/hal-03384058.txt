Exact Boolean Abstraction of Linear Equation Systems
Emilie Allart, Joachim Niehren, Cristian Versari

To cite this version:

Emilie Allart, Joachim Niehren, Cristian Versari. Exact Boolean Abstraction of Linear Equation
Systems. Computation, 2021, 9 (11), pp.32. ￿10.3390/COMPUTATION9110113￿. ￿hal-03384058v2￿

HAL Id: hal-03384058

https://inria.hal.science/hal-03384058v2

Submitted on 20 Oct 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Article
Exact Boolean Abstraction of Linear Equation Systems

Emilie Allart 1,2,‡ 0000-0003-4965-1819, Joachim Niehren 1,3,‡ and Cristian Versari 1,2,‡*

1

BioComputing Team, CRIStAL Lab, Lille,

2 University of Lille,
3

Inria Lille

* Correspondence: cristian.versari@univ-lille.fr
‡ These authors contributed equally to this work.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

Abstract: We study the problem of how to compute the boolean abstraction of the solution set of
a linear equation system over the positive reals. We call a linear equation system φ exact for the
boolean abstraction if the abstract interpretation of φ over the structure of booleans is equal to the
boolean abstraction of the solution set of φ over the positive reals. Abstract interpretation over
the booleans is thus complete for the boolean abstraction when restricted to exact linear equation
systems, while it is not complete more generally. We present a new rewriting algorithm that makes
linear equation systems exact for the boolean abstraction while preserving the solutions over the
positive reals. The rewriting algorithm is based on the elementary modes of the linear equation
system. The computation of the elementary modes may require exponential time in the worst
case, but is often feasible in practice with freely available tools. For exact linear equation systems
we can compute the boolean abstraction by ﬁnite domain constraint programming. This yields a
solution of the initial problem that is often feasible in practice. Our exact rewriting algorithm has
two further applications. First, it can be used to compute the sign abstraction of linear equation
systems over the reals, as needed for analysing function programs with linear arithmetics. And
second it can be applied to compute the difference abstraction of a linear equation system as used
in change prediction algorithms for ﬂux networks in systems biology.

17

Keywords: Linear equation systems; abstract interpretation; program analysis; systems biology.

18

19

20

21

22

23

24

25

1. Introduction

We develop approaches to remedy the incompleteness of abstract interpretation
[1] of linear equation systems over the reals, in the algebra of booleans B = {0, 1} and
the structure of signs S = {−1, 0, 1}. These abstractions have various applications: In
systems biology, the boolean abstraction underlies abstractions of chemical reactions
networks into Boolean networks [2,3]. In program analysis, the sign abstraction can be
applied to functional programs with arithmetics, for analysing the signs of the possible
values of ﬂoating-point variables [4,5].

The soundness of abstract interpretations of ﬁrst-order logic formulas without
negation was shown by John [6–8]. It applies to the interpretation in any concrete
structure S, as long as it is connected by a homomorphism h : S → ∆ to the abstract
structure ∆. The concrete interpretation of a ﬁrst-order formula φ is the set of concrete
∆(φ).
solutions solS(φ) and its abstract interpretation is the set of its abstract solutions sol
John’s soundness theorem (see Theorem 1 below) states that the set of abstract solutions
of overapproximates the abstraction by h of the set of concrete solutions:

h ◦ solS(φ) ⊆ sol

∆(φ)

26

27

28

29

30

31

When choosing the operators in Σ
bool = {+, ∗, 0, 1}, the class of negation-free ﬁrst-order
formulas with operators in Σ
bool extends on the classes of linear and polynomial equa-
tion systems. In this article, we consider the boolean abstraction which is the unique
homomorphism hB : R+ → B, and the sign abstraction which is the unique homomor-
phism hS : R → S with respect to the operators in Σ
bool. The boolean abstraction maps
any strictly positive real to 1 and 0 to 0. The sign abstraction extends on the boolean

Citation: Allart, E.; Niehren, J.;

Versari, C. Exact Boolean Abstraction

of Linear Equation Systems. Preprints

2021, 1, 0. https://doi.org/

Received:

Accepted:

Published:

Publisher’s Note: MDPI stays neutral

with regard to jurisdictional claims in

published maps and institutional af-

ﬁliations.

2 of 33

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

67

68

69

70

71

72

73

74

75

76

abstraction while mapping all strictly negative reals to −1. We note that the structure of
signs S is not an algebra since the sum of a positive and a negative number may have
any sign.

Problematics

A natural question is whether abstract interpretation is complete [9] for the ab-
straction of formulas induced by a homomorphisms h : S → ∆, i.e, whether for all
negation-free ﬁrst-order formulas φ with the same operators:

h ◦ solS(φ) = sol

∆(φ)

◦= x + z. Here we write

We call a formula φ h-exact if it satisﬁes this property. A counter example against the
completeness of abstraction interpretation for the boolean and the sign abstraction is
◦= for the equality symbol
the linear equation φ0 equal to x + y
inside the logic, in order to point out its difference from equality in the language of
mathematics. Formula φ0 is neither hB-exact nor hS-exact. This can be seen as follows.
◦= z, so that all assignments τ that are abstractions
Over the reals φ0 is equivalent to y
of concrete solutions of φ0 must satisfy τ(y) = τ(z). When interpreted abstractly over
B or S, however, φ0 admits the abstract solution τ = [x/1, y/1, z/0] which is not the
abstraction of any concrete solution since τ(y) (cid:54)= τ(z).

In order to deal with the incompleteness of abstract interpretation, we propose to
study the following two questions for homomorphism h : S → ∆ where h is either the
boolean abstraction hB or the sign abstraction hS.

Exact Rewriting Can we rewrite linear equation systems to h-exact formulas?
Computing Abstractions Can we can compute the abstraction h ◦ solS(φ) exactly for a

given system of homogeneous linear equations φ?

R(φ) of homogeneous
Geometrically speaking, the concrete solution sets sol
linear equation systems φ are polytopes – i.e. ﬁnite intersections of half spaces in Rfv(φ).
The problem of computing boolean abstractions or sign abstraction is thus to compute
the h∆ abstraction of a polytope given by a linear equation system.

R+ (φ) and sol

For any h-exact formula φ, the computation of abstractions h ◦ solS(φ) is equivalent
∆(φ). Since the abstract structure ∆ is ﬁnite for the boolean and
to the computation of sol
sign abstraction, we can compute the set of abstract solutions in at most exponential
time by a naive generate and test algorithm. Finite domain constraint programming
[10] can by used to avoid the naive generation of all variable assignments to ∆ in many
practical cases. Therefore, any algorithm for exact rewriting induces an algorithm for
computing abstractions that may be feasible in practice.

Contributions

Our main result is the ﬁrst algorithm for exact rewriting that applies to linear
equation systems for the Boolean abstraction. Based on this algorithm, we present a
novel algorithm for computing the sign abstraction of linear equation systems.

Exact Rewriting for the Boolean Abstraction. In the ﬁrst step, we study exact rewriting of
(homogeneous) linear equation systems for boolean abstraction. The counter example φ0,
◦= z. The idea is to take the system of
for instance, can be rewritten to hB-exact formula y
all linear consequences over R+ of the linear equation system. There may be inﬁnitely
many such consequences, but all of them are linear combinations of the extreme rays of
R+ (φ0). Up to normalization, there are only ﬁnitely many extreme directions,
the cone sol
which are known as the elementary modes of the linear equation system [11–14]. These
can be computed by libraries from computational geometry [15] in at most exponential
time. Nevertheless, the computation is often well-behaved in practice.

Based on the elementary modes (Folklore Theorem 2), we can rewrite any (ho-
mogeneous) linear equation system into quasi-positive and strongly-triangular linear

3 of 33

77

78

79

80

81

82

83

84

85

86

87

88

89

90

91

92

93

94

95

96

97

98

99

100

101

102

103

104

105

106

107

108

109

110

111

112

113

114

115

116

117

118

119

120

121

122

123

124

125

126

equation system that is equivalent over R+ (Corollary 1), that can be computed in at
most exponential time. As we will prove, such systems are always hB-exact (Theorem 3).
Hence, any system of linear equations can be converted in at most exponential time to
some R+-equivalent hB-exact formula.

Note that hB-exact formulas may still not be S-exact. A counter example is the
◦= y. It is not hS-exact,
strongly-triangular quasi-positive linear system u + v
◦= y over R but still has the abstract solution [u/1, v/−1, x/1, y/−1]
since it entails x
over S which maps x and y to distinct signs. Indeed, we don’t have any idea of how to
do exact rewriting for the sign abstraction. The problem is that positivity is essential
for our approach. And since the addition of positive and negative numbers may have
any sign, S fails to be an algebra, making the analogous argument as in the proof of
B-exactness fail.

◦= x ∧ u + v

Extension to hB-Mixed Systems. In the second step, we introduce hB-mixed systems, which
linear equations, 2. positive polynomial
by Theorem 4 generalize on systems of 1.
◦= 0, and 3. positive polynomial inequations p (cid:54) ◦= 0, where p is a positive
equations p
polynomial without constant term. We then show our main result:

Theorem 5 (Main). Any hB-mixed systems can be converted to a hB-exact formula by
converting its linear subsystem to an hB-exact formula.

The correctness of the algorithm for hB-mixed systems relies on the notion of hB-
invariant formulas that we introduce. The class of hB-invariant formulas subsume
◦= 0 and inequations p (cid:54) ◦= 0, where p is a
systems of positive polynomial equations p
positive polynomials without constant terms.

Computing Sign Abstractions. In the third step, we present an algorithm for computing the
sign abstraction of (homogeneous) systems of linear equations based on exact rewriting
for the boolean abstraction (Theorem 6). For this, we decompose the sign abstraction
into the boolean abstraction based on a function that is deﬁnable in ﬁrst-order logic. This
function decomposes real numbers into their positive part x and negative part y. At least
one of these two parts must be zero, which can be expressed by the polynomial equation
◦= z ∗ z and the positivity of y
x ∗ y
R(φ) to the
in analogy. In this way, we can reduce the problem of computing hS ◦ sol
R+ (φ(cid:48)) for some existentially quantiﬁed hB-mixed system
problem of computing hB ◦ sol
φ(cid:48) that we can make hB-exact based on our main Theorem 5.

◦= 0. The positivity of x can be expressed by ∃z.x

Application to Program Analysis. We show how to apply the computation of the sign
abstraction of linear equation systems in order to improve the analysis of functional
programs with arithmetics. For ﬁnding program errors there it can be useful to know
about the possible signs of the values of program variables. We elaborate an example in
the ﬁnal Section 10.

Implementation. We implemented the hB-exact rewriting algorithm for hB-mixed systems
from the main Theorem 5 in Python and plan to freely publish our tool soon. For this we
used the cddlib tool from computational geometry [16] for computing elementary modes.
We also used ﬁnite domain constraint programming with Minizinc [17] for computing
the set of boolean solutions over logical formulas. Some successful experiments are
mentioned in the related work subsection below. We did not yet implemented the
algorithm for computing sign abstractions, nor its application to program analysis
though.

Related Work

We start with related work by the authors and then move to related work by others.

Change Prediction of Reaction Networks. Our main Theorem 5 was recently applied to the
change prediction of reaction networks in systems biology [6]. Indeed, the development
of the present article was originally motivated by this application. The problem there is to

4 of 33

127

128

129

130

131

132

133

134

135

136

137

138

139

140

141

142

143

144

145

146

147

148

149

150

151

152

153

154

155

156

157

158

159

160

161

162

163

164

165

166

167

168

169

170

171

172

173

174

175

176

3

: R2

+ → {(cid:97), (cid:96), ≈} and a reﬁnement thereof h∆

compute the difference abstraction of linear equation systems, expressing the steady state
semantics of chemical reaction networks. Two difference abstractions were considered,
+ → {↑, ↓, ∼, ⇑, ⇓, ≈}. In
h∆
analogy to the approach adopted for computing sign abstractions (step three above), the
algorithmic approach presented there is to decompose the difference abstractions h∆
and h∆
6 into the boolean abstraction hB and functions that are deﬁnable in ﬁrst-order
logic. The elaboration of this approach, however, is quite different for reﬂecting the
nature of the difference abstractions.

: R2

6

3

Experimentation. We tested our implementation of the exact rewriting algorithm for the
boolean abstraction successfully for computing difference abstractions in the application
of change prediction in systems biology. The experimental results are presented in [6] are
generally encouraging. They show that hB-exact rewriting based on elementary modes
in combination with ﬁnite domain constraint programming may indeed avoid naive
generate and test in many practical examples. In some of these examples, however, the
overall computation time still took some hours.

Abstracting Reaction Networks to Boolean Networks. Independently, the authors proposed an
abstraction of chemical reaction networks to boolean networks in [18], whose precision
can be improved by using the hB-exact rewriting of hB-mixed equation systems.

Alternative Algorithm for Computing Sign Abstractions. An alternative algorithm for com-
puting the sign abstraction of linear equation systems (and thus also the boolean ab-
straction) can be obtained by John’s overapproximation theorem [6]. It shows that it
S(φ) and then to
is sufﬁcient to generate the ﬁnitely many abstract solutions in τ ∈ sol
check for each of them whether there exists a concrete solution σ such that τ = hS ◦ σ. In
order to perform this latter test, note that h∆(x) ◦= 1 is equivalent to the strict inequation
◦= 0. Similarly, hS(x) ◦= −1 can be deﬁned
x > 0 and hS(x) ◦= 0 by the equation x
R(φ)
by the strict inequation x < 0. Whether there exists a concrete solution σ ∈ sol
x∈fv(φ) hS(x) ◦= τ(x) over
such τ = h ◦ σ is thus equivalent to the satisﬁability of φ ∧ (cid:86)
R, where fv(φ) is the set of free variables of φ. The satisﬁability of systems of strict
linear inequations and homogeneous linear equations without constant terms over R
are known to be decidable since at least 1926 [19]. But still one has to generate the set
S(φ). The new algorithm presented above avoids generating
of all abstract solutions sol
this set.
Abstract Program Interpretation over Numerical Domains. In abstract interpretation [20],
non relational domains permit to approximate the set of values of program variables
while ignoring the relationship to the values of others. Well-known non-relational
numerical domains include the interval domain [21] describing invariants of the form
(cid:86)m
i and the constant propagation domain for invariants of
the form (cid:86)m

i] with reals ri ≤ r(cid:48)

i=1 xi ∈ [ri, r(cid:48)
i=1 xi

◦= ri [22].

Abstract interpretation of relational domains may yield better approximations
that with non relational domains, since relationships between the values of different
variables can be taken into account. Well-known relational numerical domains include
the polyhedral domain [4]. A polyhedron is the solution set of systems of inhomogeneous
linear inequations of the form n1x1 + . . . + nmxm ≤ r. Alternatively, the linear equality
domain [23] was considered. These are deﬁned by system of inhomogeneous linear
equations n1x1 + . . . + nmxn

◦= r.

In the present paper, we study the problem of computing the sign abstraction of
polytopes represented by homogeneous linear equation systems. The polytopes can be
obtained by existing methods for the abstract program interpretation over the polyhedral
domain. One weakness of our approach is that we study the homogeneous case only, so
that we can only abstract polytope and not more general polyhedrons.

5 of 33

Outline

In Section 2 we recall preliminaries on homomorphisms between Σ-structures. In
Section 3 the ﬁrst-order logic is recalled. John’s theorem and its relation to the soundness
and completeness of abstract interpretation in the classical framework are discussed in
Section 4. We discuss how to make linear equation system quasi-positive and strongly
triangular based on elementary modes in Section 5. These properties can be used to
prove hB-exactness as we show in Section 6, and thus to obtain an hB-exact rewriting of
linear equation systems. We introduce the notion of hB-invariance in Section 7 and apply
it in Section 8 to lift the hB-exact rewriting algorithm from linear to hB-mixed systems.
This allows us to deﬁne the sign abstraction of linear equation systems on Section 9. We
ﬁnally apply this result in Section 10 to the sign analysis of functional programs with
arithmetic.

2. Homomorphisms on Σ-Structures

We need some basic notation from set theory and standard notion of universal

algebra such as Σ-algebras, Σ-structures and homomorphism.

For any set A and n ∈ N, the set of n-tuples of elements in A is denoted by An.
For ﬁnite sets A the number of elements of A is denoted by |A|. Furthermore, for any
function f : A → B we deﬁne the function f 2 : A2 → B2 such that f 2(a, a(cid:48)) = ( f (a), f (a(cid:48))
for all a, a(cid:48) ∈ A.

2.1. Σ-Algebras

We next recall the notion of Σ-algebras. Let Σ = ∪n≥0F(n) (cid:93) C be a ranked signature.
We call the elements of f ∈ F(n) are called n-ary function symbols, even though we may
also use them as n + 1-ary relation symbols later on when moving to Σ-structures. The
elements in c ∈ C are called the constants of Σ.

Deﬁnition 1. A Σ-algebra S = (dom(S), .S) consists of a set dom(S) and an interpretation .S
such that cS ∈ dom(S) for all c ∈ C, and f S : dom(S)n → dom(S) for all f ∈ F(n).

Let B = {0, 1} be the set of booleans, N the set of natural numbers including 0, Z
the set of integers, R the set of real numbers, and R+ the set of positive real numbers
including 0. Note that B ⊆ N ⊆ R+ ⊆ R and N ⊆ Z ⊆ R. Let the addition on the
reals be the binary function +R
: R2 → R and the multiplication the binary function
∗R
+ → R+ be equal
to the restriction +R
+ → R+ be the restriction
∗R

: R2 → R. Let the addition on the positive real numbers +R+ : R2

|R+×R+ and the multiplication ∗R+ : R2

bool = {+, ∗} ∪ {0, 1} be the set of boolean operators where + and ∗ are binary
function symbols and 0 and 1 constants. Note that constant 0 is freely overloaded with
the boolean 0 and the constant 1 with the boolean 1.

|R+×R+ .
Let Σ

Example 2. The set of positive reals R+ can be turned into a Σ
bool-algebra, in which the functions
symbols are interpreted as binary functions +R+ and ∗R+ . The constants are interpreted by
themselves 0

R+ = 0 and 1

R+ = 1.

Example 3. The set of Booleans B = {0, 1} ⊆ R+ equally deﬁnes a Σ
the function symbols are interpreted as a disjunction +B = ∨B
Booleans. The constants are interpreted by themselves 0

B = 0 and 1

B = 1.

and conjunction ∗B = ∧B

bool-algebra. There,
on

2.2. Σ-Structures

We next recall the usual generalization of Σ-algebras to Σ-structures. The objective
is to generalize from functions to relations. For this, we consider n-ary function symbols
as n+1-ary relation symbols.

177

178

179

180

181

182

183

184

185

186

187

188

189

190

191

192

193

194

195

196

197

198

199

200

201

202

203

204

205

206

207

208

209

210

211

212

213

214

215

216

217

218

219

220

221

222

6 of 33

d ∗S
d(cid:48)
{−1}
{0}
{1}

d −S
d(cid:48)
{−1}
{−1}
{−1, 0, 1}

S

d(cid:48)
d /
{−1}
∅
{1}

d(cid:48)
d
−1 1
−1 0
−1 −1

d d(cid:48)
0 1
0 0
0 −1

d +S
d(cid:48)
{−1, 0, 1}
{−1}
{−1}
d +S
{1}
{0}
{−1}

d(cid:48)

d +S
{1}
{1}

d d(cid:48)
1 1
1 0
1 −1 {−1, 0, 1}

d(cid:48) d ∗S
{0}
{0}
{0}
d ∗S
d(cid:48)
{1}
{0}
{−1}

d(cid:48) d −S

d(cid:48) d /

S

d(cid:48)

{−1}
{0}
{1}
d −S
d(cid:48)
{−1, 0, 1}
{1}
{1}

{0}
∅
{0}

d /

S

d(cid:48)

{1}
∅
{−1}

Figure 1. Evaluation in the Σ

arith-structure of signs S.

Deﬁnition 4. A Σ-structure ∆ = (dom(∆), .
∆ ∈ dom(∆) for all c ∈ C and f
∆
.

such that c

∆) consists of a set dom(∆) and an interpretation
∆ ⊆ dom(∆)n+1 for all f ∈ F(n).

Clearly, any Σ-algebra is also a Σ-structure. Note also that symbols in F(0) are
interpreted as monadic relations, i.e., as subsets of the domain, in contrast to constants
in C that are interpreted as elements of the domain.

We denote the subtraction on the reals by the binary function −R

: R2 → R and the
R ⊆ R2 × R. Note that division by zero is

division on the reals by the ternary relation /
undeﬁned. Note also that subtraction on R+ would yield only a partial function.

Let Σ

arith = {+, ∗, −, /} ∪ {0, 1} be the arithmetic signature, where 0 and 1 are
constants, and all other operators are binary function symbols. Again, we freely overlead
to constant 0 with real number 0 and the constant 1 with the real number 1.

Example 5. The set of reals R can be turned into a Σ
of the binary functions symbols as the ternary relations +R
R
interpreted by themselves 0
since division by 0 is not deﬁned. So we must see /
Σ

R = 1. Note that /

R = 0 and 1

arith-algebra. It still is a Σ

bool-algebra though.

R

, −R

arith-structure, with the interpretation
, ∗R
R
. The constants are
is a partial but not a total function,
as a ternary relation, so that R is not a

, /

S) with the interpretation +S

arith-structure S =
Example 6. The set of signs {−1, 0, 1} ⊆ R can be turned into a Σ
({−1, 0, 1}, .
given in Fig. 1. The constants
contains (−1, 1, −1),
are interpreted by themselves 0
(−1, 1, 1) and (−1, 1, 0) meaning that the sum of a strictly negative and a strictly positive real
has a sign in −1 +S
1, so it may either be strictly positive, strictly negative, or zero. So S is a
Σ
arith-structure and even when restricting the signature to Σ
bool-structure
that is not a Σ

, −S
and, /
S = 1. Note that all +S

bool it remains a Σ

S = 0 and 1

, ∗S

S

bool-algebra.

2.3. Homomorphisms

We recall the standard notion of homomorphism for Σ-structures which can also be

applied to Σ-algebras.

Deﬁnition 7. A homomorphism between two Σ-structures S and ∆ is a function h : dom(S) →
dom(∆) such that for c ∈ C, n ∈ N, f ∈ F(n), and s1, . . . , sn+1 ∈ dom(S):
1.
2.

h(cS) = c
if (s1, . . . , sn+1) ∈ f S then (h(s1), . . . , h(sn+1)) ∈ f

, and

∆

∆

.

223

224

225

226

227

228

229

230

231

232

233

234

235

236

237

238

239

240

241

242

243

244

245

246

247

248

249

250

251

252

7 of 33

σ,S = {cS}
σ,S = {σ(x)}

c
(cid:75)
x
(cid:75)
f (e1, . . . , en)

(cid:75)

(cid:74)
(cid:74)
(cid:74)

Figure 2. Set-valued interpretation of expressions

e

(cid:74)

(cid:75)

σ,S = ∪{ f S(s1 . . . , sn) | si ∈

ei

σ,S for 1 ≤ i ≤ n}

(cid:74)

(cid:75)
σ,S ⊆ dom(S).

253

254

255

256

257

258

259

260

261

262

263

264

265

266

267

268

269

270

271

272

273

274

275

276

277

278

279

280

281

282

283

284

285

286

287

288

We can convert any n + 1-ary relation to a n-ary set valued functions. In this
way any n-function is converted to a n-ary set valued n-functions. In other words,
functions of type Dn → D are converted to functions of type Dn → 2D where D =
dom(∆). In set-valued notation, the second condition on homomorphism can then be
∆(h(s1), . . . , h(sn)). A homomorphism
rewritten equivalently as h( f S(s1, . . . , sn)) ⊆ f
and for all function symbols f ∈ F(n) and
for Σ-algebras thus satisﬁes h(cS) = c
s1, . . . , sn ∈ dom(S) it satisﬁes h( f S(s1, . . . , sn)) = f

∆(h(s1), . . . , h(sn)).

The boolean abstraction is the function hB : R+ → B with hB(0) = 0 and hB(r) = 1

∆

if r > 0.

Lemma 8. The boolean abstraction hB is a homomorphism between Σ

bool-algebras.

Proof For all r, r(cid:48) ∈ R+ we have:

hB(r +R+ r(cid:48)) = 1 ⇔ r +R+ r(cid:48) (cid:54)= 0 ⇔ r (cid:54)= 0 ∨ r(cid:48) (cid:54)= 0 ⇔ hB(r) = 1 ∨ hB(r(cid:48)) = 1
hB(r ∗R+ r(cid:48)) = 1 ⇔ r ∗R+ r(cid:48) (cid:54)= 0 ⇔ r (cid:54)= 0 ∧ r(cid:48) (cid:54)= 0 ⇔ hB(r) = 1 ∧ hB(r(cid:48)) = 1

Hence hB(r +R+ r(cid:48)) = hB(r) +B
both constants c ∈ C we have that hB(c

hB(r(cid:48)) and hB(r ∗R+ r(cid:48)) = hB(r) ∗B
R+ ) = hB(c) = c = c

B

.

hB(r(cid:48)). Finally, for

The sign abstraction is the function hS : R → S with hS(0) = 0, hS(r) = −1 for all

strictly negative reals r < 0 and hS(r) = 1 for all strictly positive reals r > 0.

Lemma 9. The sign abstraction hS is a homomorphism between Σ

arith-structures.

r(cid:48)) ∈ {hS(r) ∗R

Proof Let r, r(cid:48) ∈ R. For the multiplication we have hS(r ∗R
thus hS(r ∗R
distinguish cases. If r and r(cid:48) have the same sign, so r +R
we have hS(r +R
hS(r) +S
S
/

r(cid:48)) = hS(r) ∗R
hS(r(cid:48)) and
hS(r(cid:48)). For the addition, we have to
r(cid:48) has the same sign, so that
hS(r(cid:48)). If r > 0 and r(cid:48) < 0 or vice versa then we have
and

hS(r(cid:48)) = S so that hS(r +R
is similar. For the constants we have hS(0

hS(r(cid:48)). The treatment of −S
S
R) = 1
.

hS(r(cid:48))} = hS(r) ∗S

r(cid:48)) ∈ S = hS(r) +S

r(cid:48)) ∈ hS(r) +S

S
R) = 0

and hS(1

3. First-Order Logic

We recall the syntax and semantics of ﬁrst-order logic with equality. For this, we ﬁx

a countably inﬁnite set of variables V that will be ranged over by x, y, z.

3.1. Expressions

Given a ranked signature with constants and function symbols Σ = C ∪ (cid:83)

n≥0 F(n),
the set of Σ-expressions contains all terms that can be constructed from constants and
variables by using function symbols:

e1, . . . , en ∈ EΣ

::= x | c |

f (e1, . . . , en) where c ∈ C, n ≥ 0, f ∈ F(n), x ∈ V

Let fv(e) be the set of all variables that occur in e. Given a subset V ⊆ V let EΣ(V) be the
subset of expression e ∈ EΣ with fv(e) ⊆ V.

The semantics of Σ-expressions is deﬁned in Fig. 2. For any Σ-structure S and
variable assignment σ : V → dom(S), any expression e ∈ EΣ(V) denotes a set of values
σ,S ⊆ dom(S). This set is deﬁned recursively by set-valued interpretation of the
e
(cid:74)
operators of the expressions in the structure S. If S is a Σ-algebra, then the result will
always be a singleton.

(cid:75)

◦= e(cid:48)

e

σ,S =

(cid:75)

(cid:26)

1
0

e
if
(cid:74)
else

(cid:75)

σ,S ∩

e(cid:48)

(cid:74)

(cid:75)

σ,S (cid:54)= ∅

σ,S = ¬B(

¬φ

(cid:75)

σ,S)

φ

(cid:74)

(cid:75)

(cid:74)

(cid:74)

(cid:74)

(cid:74)

8 of 33

σ,S

φ ∧ φ(cid:48)

(cid:75)

σ,S =

σ,S ∧B

φ(cid:48)

(cid:74)

(cid:75)

φ

(cid:75)
1

(cid:74)





0

σ,S =

∃x.φ

(cid:75)

if exists s ∈ dom(S).
σ[x/s],S = 1

φ
(cid:74)
else

(cid:75)

Figure 3. Interpretation of formulas φ ∈ FΣ(V) as truth values
given a variable assignment σ : V → dom(S).

φ

(cid:75)

(cid:74)

σ,S ∈ B over a Σ-structure S

3.2. Logic Formulas

The set of ﬁrst-order formulas is the set of terms constructed with the usual ﬁrst-

order connectives from equations with symbols in Σ and variables in V:
◦= e(cid:48) | ∃x.φ | φ ∧ φ | ¬φ

where e, e(cid:48) ∈ EΣ and x ∈ V

φ ∈ FΣ

::= e

A Σ-formula φ ∈ FΣ is a term, which either is a Σ-equation e

◦= e(cid:48) with variables
in V, an existentially quantiﬁed formula ∃x.φ, a conjunction φ ∧ φ(cid:48), or a negation ¬φ.
A system of Σ-equations is a conjunction of equations e1
n where
e1, e(cid:48)

1, . . . , en, e(cid:48)
The set of free variables fv(φ) contains all those variables of φ that occur outside
the scope of any existential quantiﬁer in φ. Given a subset V ⊆ V we write FΣ(V) for
the subset of formulas φ ∈ FΣ such that fv(φ) ⊆ V.

1 ∧ . . . ∧ en

n ∈ EΣ.

◦= e(cid:48)

◦= e(cid:48)

First-order formulas can be deﬁned for providing the missing logical operators.
First, we can deﬁne disjunctions φ ∨ φ(cid:48) =def ¬(¬φ ∧ ¬φ(cid:48)) and implications φ → φ(cid:48) =def
¬φ ∨ φ(cid:48), and second universally quantiﬁed formulas ∀x.φ =def ¬∃x.¬φ. Note that these
formulas are not negation-free (and thus John’s theorem cannot be applied to them).
Third, we deﬁne the valid formula true =def ∃x.x
i=1 φi instead
of φ1 ∧ . . . ∧ φn. In the case n = 0 the conjunction is true. Fourth, for any vector of
variables y = (y1, . . . , yn) ∈ V n we will write ∃y.φ instead of ∃y1 . . . ∃yn.φ.

◦= x. Fourth, we write (cid:86)n

For any V ⊆ V, the semantics of ﬁrst-order formulas φ ∈ FΣ(V) for a Σ-structure S
σ,S ∈ B deﬁned in Fig. 3.
and a variable assignment σ : V → dom(S) is the truth value
◦= e(cid:48)
◦= is interpreted as nondisjointness, i.e., an equation e
Note that the equality symbol
◦=
e(cid:48)
σ,S (cid:54)= ∅. In the case of Σ-algebras, the equality symbol
is true if and only if
is indeed interpreted as equality of singletons. In the case of more general Σ-structures,
though, it is not interpreted as set equality.

σ,S ∩

φ

(cid:75)

(cid:75)

(cid:74)

(cid:74)

(cid:75)

(cid:74)

e

The set of solutions with domain V of a formula φ ∈ FΣ(V) over a Σ-algebra S is:

solS

V(φ)={σ : V → dom(S) |

φ

σ,S = 1}

(cid:75)
(cid:74)
If V = fv(φ) we omit the index V, i.e., solS(φ) = solS
V(φ).

Two formulas φ, φ(cid:48) ∈ FΣ are called S-equivalent if they have the same solution sets
◦= y is equivalent to
V(φ) = solS

V(φ(cid:48)). Note that y

over S on V = fv(φ) ∪ fv(φ(cid:48)), that is solS
◦= x.
z

◦= z and also to true, i.e., to ∃x.x

289

290

291

292

293

294

295

296

297

298

299

300

301

302

303

304

305

306

307

308

309

310

311

312

313

314

315

316

317

3.3. Examples

Since B ⊆ R+ we can deﬁne the boolean abstraction by a formula y
over R+ with two variables x, y ∈ V:

bool

FΣ

◦= hB(x) in

(x

◦= 0 ∧ y

◦= 0) ∨ (¬x

◦= 0 ∧ y

◦= 1)

9 of 33

Since S ⊆ R we can deﬁne the sign abstraction by a formula y

over R with two variables x, y ∈ V:

◦= hS(x) in FΣ

bool

(x

◦= 0 ∧ y

◦= 0) ∨ (x > 0 ∧ y

◦= 1) ∨ (x < 0 ∧ y + 1

◦= 0)

where:

x ≥ 0 =def ∃z. x
x > 0 =def
x < 0 =def ¬x ≥ 0

◦= z ∗ z
x ≥ 0 ∧ ¬(x

◦= 0)

These deﬁnitions illustrate that both abstraction are closely related to strict inequations
x > 0 and x < 0. The boolean abstraction is concerned with strict positivity x > 0 while
the sign abstraction is also concerned with strict negativity x < 0.

3.4. Semantic Properties of Free and Bound Variables

We will need the following two standard lemmas on the rôle of free and bound
variables for the solution sets of logic formulas. For any subset of variable assignments R
of type V(cid:48) → dom(S) and any disjoint sets of variables V ∩ V(cid:48) = ∅ we deﬁne extS
V(R) =
{σ ∪ σ(cid:48) | σ : V → dom(S), σ(cid:48) ∈ R}.

Lemma 10 Cylindriﬁcation. If V ∩ fv(φ) = ∅ then solS

V∪fv(φ)(φ) = extS

V(solS(φ)).

e

σ,S =

σ|fv(e),S for all expressions e ∈ EΣ with fv(e) disjoint
Proof We can show that
to V and any variable assignment σ : fv(e) ∪ V → dom(S) by induction on the structure
of expressions. From this we can prove for all formulas φ ∈ FΣ such that fv(φ) is disjoint
σ|fv(φ),S by induction on the structure
from V and σ : fv(φ) ∪ V → dom(S) that
of Σ-formulas. This implies the lemma.

σ,S =

φ

φ

(cid:75)

(cid:74)

(cid:74)

(cid:75)

(cid:75)

(cid:74)

(cid:75)

(cid:74)

e

The projection πa( f ) of a function f : A → B is its restriction f|A\{a}. The projection

of a set F of functions f : A → B is πa(F) = {πa( f ) | f ∈ F}.

Lemma 11 Quantiﬁcation is projection. solS(∃x. φ) = πx(solS(φ)).

Proof This is follows from the semantics of existential quantiﬁed formulas as follows:

solS(∃x. φ) = {σ|fv(φ)\{x} | σ ∈ solS(φ)} = πx(solS(φ))

4. Abstract Interpretation

We recall the notion of Σ-abstractions and use them for abstracting set of concrete
solutions of logic formulas within the usual framework of abstract interpretation. Due
to John’s theorem, this abstraction of logic formulas can be soundly approximated by
abstract interpretation over target structure of the Σ-abstraction. We then argue that the
notion of soundness shown by John’s theorem [8] does indeed coincide with the notion of
soundness abstract interpretation in the classical framework of Cousot & Cousot [1]. We
then introduce the notion of exactness of a logic formula with respect to a Σ-abstraction
and relate it to the completeness of abstract interpretation.

4.1. John’s Overapproximation for Σ-Abstractions

The notion of Σ-abstraction from [6] generalizes at the same time over the boolean

abstraction and the sign abstraction.

Deﬁnition 12. A Σ-abstraction is a homomorphism h : S → ∆ between Σ-structures such that
dom(∆) ⊆ dom(S).

318

319

320

321

322

323

324

325

326

327

328

329

330

331

332

333

334

335

336

337

338

339

340

341

342

343

344

345

346

347

348

349

350

351

352

353

354

355

356

357

358

359

360

361

362

363

364

365

366

367

368

369

370

371

372

373

374

375

10 of 33

bool-abstraction by Lemma 8. The sign abstraction

The boolean abstraction hB is a Σ
bool-abstraction by Lemma 9.

hS is a Σ

Let h : S → ∆ be a Σ-abstraction and V ⊆ V. For any subset of assignments R of

type V → dom(S) we deﬁne the abstraction:

h ◦ R = {h ◦ σ : V → dom(∆) | σ ∈ R}

Theorem 1 John’s Overapproximation [6–8]. For any Σ-abstraction h : S → ∆ between
Σ-structures and any negation-free Σ-formula φ ∈ FΣ:

h ◦ solS(φ) ⊆ sol

∆(φ)

John’s theorem states that the abstraction with respect to h of the concrete solution
set of a ﬁrst-order formula can be overapproximated by abstract interpretation of the
formula in the target structure of h.

We only give a brief sketch of the full proof which can be found in [6]. Let V = fv(φ)
and σ : V → dom(S). For any expression e ∈ EΣ(V) we can show h(
by
(cid:75)
induction on the structure of e. It then follows for any negation-free formula φ ∈ FΣ(V)
∆
. This is equivalent to that {h ◦ σ | σ ∈ solS
σ,S ≤
V(φ) and
φ
that
∆(φ) as
∆
(cid:74)
(cid:75)
V(φ). Since V = fv(φ) it follows that h ◦ solS(φ) ⊆ sol
thus h ◦ solS
required.

(cid:74)
V(φ)} ⊆ sol

h◦σ,∆
φ
(cid:75)
V(φ) ⊆ sol

σ,S) =

h◦σ,∆

(cid:74)

(cid:75)

(cid:74)

e

e

4.2. Exactness of Σ-Formulas for Σ-Abstractions

As a new contribution, we introduce the notion of exactness of ﬁrst-order formulas

with respect to a Σ-abstraction.

Deﬁnition 13 h-Exactness. Let h : S → ∆ be a Σ-abstraction and φ ∈ FΣ(V) a formula. We
∆
call φ h-exact with respect to V if h ◦ solS
V(φ). We call φ h-exact if φ is h-exact
with respect to fv(φ).

V(φ) = sol

For instance, the linear equation system φ equal to x + y

nor hS-exact. However it is equivalent to y
see this note that τ = [x/1, y/1, z/0] belongs to sol
τ(y) (cid:54)= τ(z). The same assignment also belongs to sol
τ(y) (cid:54)= τ(z).

◦= x + z is neither hB-exact
◦= z which is both hB-exact and hS-exact. To
R+ (φ) since
B(φ) but not to hB ◦ sol
R(φ) since
S(φ) but not to hS ◦ sol

4.3. Soundness and Completeness of Abstract Interpretation

John’s theorem is related to the soundness of abstract interpretation and the notion
of exactness to its completeness. In order to state the precise relationship, we need to
embed our setting into the classical framework of abstract interpretation [1,9].

When considering formulas as programs, the usual framework of abstract interpre-
tation of programs applies to the interpretation of the formulas (programs) in the target
structure of the Σ-abstraction. More formally, we ﬁx a ﬁnite subset of variables V ⊆ V
and consider the subset of formulas as programs:

P = {φ ∈ FΣ(V) | φ is negation-free}

The semantics of a program φ ∈ P over a given Σ-structure S is the set of its solutions
over S:

= solS(φ)

φ

(cid:74)

(cid:75)

The range of the semantics mapping is the space of concrete values C = 2{σ|σ:V→dom(S)}.
Note that (C, ⊆, ∩, ∪) is a complete lattice. An abstract interpretation of a program
φ ∈ P maps φ to the set of its solutions over ∆:

(cid:93) = sol

∆(φ)

φ

(cid:75)

(cid:74)

376

377

378

379

380

381

382

383

384

385

386

387

388

389

390

391

392

393

394

395

396

397

398

399

400

401

402

403

404

405

406

The range of the abstract interpretation is the abstract domain A = 2{τ|τ:V→dom(∆)}.
Clearly, (A, ⊆, ∩, ∪) is also a complete lattice. We deﬁne the abstraction function αh :
C → A of our Galois connection such that for subsets of concrete assignments R ⊆ C:

αh(R) = h ◦ R

11 of 33

Deﬁnition 14 Cousot & Cousot [1], Giacobazzi, Ranzato & Scozzari [9]. An abstract
(cid:93) : P → A is sound for an abstraction α : C → A with respect to the program
interpretation
.
(cid:74)
(cid:93). It is complete if
: P → C if for all programs φ ∈ P it holds that α(
semantics
all programs φ ∈ P satisfy α(
φ

) ⊆

) =

.
(cid:74)

(cid:93).

φ

φ

φ

(cid:74)

(cid:75)

(cid:74)

(cid:75)

(cid:75)

(cid:75)

(cid:74)

(cid:75)

(cid:74)

(cid:75)

John’s theorem states that the abstract interpretation αh of negation free-formulas
φ ∈ P over ∆ is sound for the abstraction of solS(φ) with respect to the Σ-abstraction
h : S → ∆. Furthermore, if all formulas of P are h-exact then abstract interpretation
over ∆ is complete for abstraction αh. As illustrated above abstract interpretation over B
fails to be complete for the abstraction αhB , and similarly, abstract interpretation over
S fails to be complete for the abstraction αhS . Note that the completeness of abstract
interpretations has been largely studied in the context of program analysis (see e.g.
Section 8 of [9] for an overview).

In the present article, we study the problem of exact rewriting for hB. The question
bool-formula into a hB-exact formula that is R+-equivalent. Note
is how to rewrite a Σ
that exact rewriting of linear equation system for hB is a different problem than to decide
whether abstract interpretation is complete for αhB on linear equation systems. Still, both
notions are closely related: exact rewriting can help to improve the precision of abstract
interpretation just in the case where it is not already complete, i.e., maximally precise.
Otherwise, exact rewriting is trivial.

In the case of the sign abstraction, we do not have any algorithmic idea of how to
do exact rewriting for linear equation systems. Therefore, we study the easier problem
of exact rewriting for the boolean abstraction of linear equation systems in the ﬁrst place.
B(φ)
Given an hB-exact formula φ, we can compute the abstraction hB ◦ sol
by ﬁnite domain constraints programming. We then use exact rewriting for the boolean
R(φ), rather
abstraction to compute sign abstractions of linear equation systems hS ◦ sol
than relying on exact rewriting for the sign abstraction itself. For this we use ﬁrst-order
deﬁnitions beside of ﬁnite domain constraint programming.

R+ (φ) = sol

4.4. Galois Connection

We ﬁnally introduce the concretization operation that corresponds to the abstraction
of the solution set of a logic formula with respect to a Σ-abstraction, and show that the
pair of abstraction and concretization forms a Galois connection.

Given a Σ-abstraction h : S → ∆, and a set R of variable assignments to dom(∆),
we deﬁne the left-decomposition of R with respect to h as the following set of variable
assignments to dom(S):

h ◦−R =def {σ | h ◦ σ ∈ R}
So let αh : C → A be the abstraction induced by Σ-abstraction h. We deﬁne the cor-
responding concretization function γh : A → C such that for all abstract assignments
R ⊆ A:

γh(R) = h ◦−R =def {σ ∈ C | h ◦ σ ∈ R}

Lemma 15. (A, C, αh, γh) is a Galois connection, i.e. for all R ∈ C and T ∈ A:

αh(R) ⊆ T if and only if R ⊆ γh(T)

407

408

409

410

411

412

413

414

415

416

417

418

419

420

421

422

423

424

425

426

427

12 of 33

Proof If h ◦ R ⊆ T then h ◦−h ◦ R ⊆ h ◦−T and since R ⊆ h ◦−h ◦ R we have R ⊆ h ◦−T.
If conversely R ⊆ h ◦−T then h ◦ R ⊆ h ◦ h ◦−T and since h ◦ h ◦−T = T it follows that
h ◦ R ⊆ T.

5. Equation Systems, Positivity, and Triangularity

We study systems of Σ

bool-equations for positivity and triangularity. These notions
will be essential for showing B-exactness. We are not only interested in homogeneous
linear equations but also in more general polynomial equations without constant term.

5.1. Classes of Equation Systems
Let e1, . . . , en ∈ EΣ

i=1 ei =def e1 + . . . + en and ∏n

∑n
and ∏n

bool be a sequence of expressions and n ∈ N. If n (cid:54)= 0 we deﬁne
i=1 ei =def e1 ∗ . . . ∗ en. For n = 0, we deﬁne ∑n
i=1 ei = 0

i=1 ei = 1. Furthermore, for any expression e ∈ EΣ

bool we deﬁne:

ne =def

n
∑
i=1

e

and

en =def

n
∏
i=1

e

A polynomial (with natural coefﬁcients) is a Σ

bool-expression of the following form:

l
∑
j=1

nj

ij
∏
k=1

mj,k
j,k

x

where l and ij are natural numbers, x1,1, . . . , xl,il variables, all nj (cid:54)= 0 are natural numbers
called the coefﬁcients, and all mj,k (cid:54)= 0 are natural numbers called the exponents. The
products ∏ij

mj,k
j,k are called the monomials of the polynomial.

k=1 x

Deﬁnition 16. A polynomial ∑l
(cid:54)= 0 has no
constant term if none of its monomials is equal to 1, i.e., ij (cid:54)= 0 for all 1 ≤ j ≤ l. It is linear if
all its monomials are variables, i.e. ij = 1 and mj,1 = . . . = mj,ij = 1 for all 1 ≤ j ≤ l.

mj,k
j,k with natural coefﬁcients nj

j=1 nj ∏ij

k=1 x

A polynomial equation is a Σ

bool-equation p

◦= p(cid:48) between polynomials. A polynomial

equation system is a system of polynomial equations.

Linear polynomials have the form ∑l

j=1 njxj,1 where l and all nj (cid:54)= 0 are naturals
and all xj,1 are variables. In particular, linear polynomials do not have a constant term.
Note that the constant 0 is equal to the linear polynomial with l = 0. A (homogeneous)
linear equation is a polynomial equation with linear polynomials, so without constant
terms. A (homogeneous) linear equation system is a system of linear equations.

A (homogeneous) integer matrix equation has the form Ay

◦= 0 where A is a n × m
matrix of integers for some naturals m, n such that y ∈ V m and 0 ∈ {0}n. Any integer
matrix equation can be turned into a linear equation system with natural coefﬁcients,
by bringing the negative coefﬁcients positively on the right-hand side. For instance, the
linear integer matrix equation:

(cid:18) 3

0
2 −5

(cid:19)(cid:18) x
y

(cid:19) ◦=

(cid:19)

(cid:18) 0
0

corresponds to the following system of linear Σ

bool-equations:

◦= 0 ∧ 2x

◦= 5y

3x

428

429

430

Therefore, we will sometimes confuse an integer matrix equations with the correspond-
ing system of linear Σ
bool-equations
can be converted into a integer matrix equation, by moving the positive right-hand sides

bool-equations. Conversely any system of linear Σ

13 of 33

negatively to the left and factorizing the expressions for the different occurrences of the
same variable.

5.2. Positivity and Triangularity

We next deﬁne positivity and triangularity properties for equation systems. These

will be key properties to show B-exactness of linear equation systems.

Deﬁnition 17. A Σ
it has the form e
positive respectively quasi-positive if all its equations are.

◦= ny, where n ∈ N, y ∈ V, and e ∈ EΣ

bool-equation is called positive if it has the form e

bool . We call a system of Σ

◦= 0 and quasi-positive if
bool-equations

This deﬁnition makes sense, since all constants in Σ

and all operators of Σ
equation is quasi-positive since the constant 0 is equal to the polynomial 0y.

bool-expressions are positive
bool-expressions preserve positivity. Note also that any positive

This above system of linear equations is quasi-positive, but not positive since 5y
appears on a right-hand side. More generally, the linear equation system for a integer
◦= 0 is positive if and only if all integers in A are positive, and
matrix equation Ay
quasi-positive, if each line of A contains at most one negative integer.

l=1 el

Deﬁnition 18. We call a quasi-positive system of Σ
bool-equations triangular if it has the form
◦= e(cid:48)
◦= nlyl such that the variables yl are l-fresh for all 1 ≤ l ≤ n, i.e., yl (cid:54)∈ fv((cid:86)l−1
(cid:86)n
i)
and if nl (cid:54)= 0 then yl (cid:54)∈ fv(el). We call the quasi-positive polynomial system strongly-triangular
if it is triangular and satisﬁes nl (cid:54)= 0 for all 1 ≤ l ≤ n.

i=1 ei

The above linear equation system is triangular, but not strongly triangular since the
◦= 0. If
right-hand side of the ﬁrst equation is 0. Consider an integer matrix equation Ay
A is positive and triangular, then the corresponding linear equation system is positive
and triangular too. For being quasi-positive and strongly-triangular, the integers below
the diagonal of A must be negative, those on the diagonal must be strictly negative, and
those on the right of the diagonal must be positive.

5.3. Linear Equation Systems and Elementary Modes

We next show that elementary modes [11–14] can be used to transform systems of
linear equations into R+-equivalent systems that are quasi-positive and strongly-triangular.
We ﬁrst recall the necessary deﬁnitions and folklore results on elementary modes
and the double description method. We will limit the presentation to equations with in-
teger coefﬁcients solved in R+, since more general deﬁnitions and results for elementary
modes in R are not needed for this paper.

Deﬁnition 19. The support of a function σ : V → R is supp(σ) = {y ∈ V | σ(y) (cid:54)= 0}.

Deﬁnition 20 Elementary Modes. An elementary mode of an integer matrix A ∈ Zn,m is
a vector n ∈ Nn such that for any sequence of pairwise distinct variables y ∈ V n the function
◦= 0) such that:
σ = [y/n] is a solution in sol
supp(σ) is minimal, i.e. there exist no σ(cid:48) ∈ solS(φ) such that supp(σ(cid:48)) (cid:40) supp(σ),
•
σ is normalized, i.e. there exist variables y, y(cid:48) in y such that σ(y) and σ(y(cid:48)) are coprimes
•
(their greatest common divisor is 1).

R+ (Ay

R+ (Ay

The elementary modes of a matrix A are the extreme directions of the polyhedral
◦= 0). This implies that any solution of the linear system can be expressed
cone sol
as a weighted sum of its elementary modes, where all the weights are non negative. Due
to normalization, the number of elementary modes is ﬁnite for all integer matrices.

431

432

433

434

435

436

437

438

439

440

441

442

443

444

445

446

447

448

449

450

451

452

453

454

455

456

457

458

459

460

461

462

463

464

465

466

467

468

469

470

471

472

473

(cid:26)

φ0 =def

y1 = y2 + y3
∧ y1 = y2 + y4

(cid:18) −1

1
1 −1

1
0
0 −1

14 of 33

(cid:19)







y1
y2
y3
y4







◦=













0
0
0
0

Figure 4. :A linear equation system and the corresponding integer matrix equation.

emr(φ0) =def ∃x0.∃x1.

◦= y1





x0 + x1
◦= y2
◦= y3
◦= y4

∧ x1
∧ x0
∧ x0







1
0
1
1

1
1
0
0



(cid:18) x0
x1





(cid:19) ◦=













y1
y2
y3
y4

Figure 5. The elementary mode rewriting and the corresponding matrix equation.

Theorem 2 (Folklore). For any integer matrix A ∈ Zm,n one can compute a matrix of natural
◦= 0 and
numbers E ∈ Nn,o in at most exponential time, such that the Σ
◦= y are R+-equivalent for all vectors y ∈ V n and x ∈ V o of pairwise distince variables.
∃x.Ex
Furthermore, the o columns of E are the elementary modes of A.

bool-formulas for Ay

The pair of matrices (A, E) is called a double description in Motzkin’s double
description method [11]. We note that Theorem 2 can be lifted to matrices of rational
◦= 0 can be rewritten to a integer
numbers Q, since any rational matrix equation Ay
matrix equation with the same R+-solution set, by multiplying with the natural numbers
in the denominators of the rational numbers. The freely available cddlib tool [16] in the
rational mode inputs a matrix A ∈ Qn,m, and outputs the list of (integer) elementary
modes of A. From this list, we can construct the matrix E for A by aligning the elementary
modes of A as the columns of E.

The service of the cddlib tool is even more general, in that it applies to rational
matrix inequations interpreted over the reals, rather than to rational matrix equations
interpreted over the positive reals: it permits to compute the normalized extreme di-
R(By ≥ 0) for any rational matrix inequation B. If
rections of the polyedral cones sol
one wants to compute the elementary modes of integer matrix equations A – that is
the normalized extreme directions of the polyhedral cone of a rational matrix equation

492

over the positive reals sol

R+ (Ay

◦= 0) –, then one can chose B =

is the identity matrix with as many columns than A, since sol
0 ∧ Ay ≤ 0 ∧ y ≥ 0) = sol

R+ (Ay

◦= 0).







A
−A
Id
R(By ≥ 0) = sol

 where Id

R(Ay ≥

Corollary 1 Elementary Mode Rewriting. For any system of linear equations φ ∈ FΣ
one can compute in at most exponential time an R+-equivalent formula emr(φ) ∈ FΣ
has the form ∃x.φ(cid:48) where φ(cid:48) is quasi-positive and strongly-triangular system of equations.

bool

bool
that

bool

can be converted into an R+-equivalent
Proof Any system of linear equations φ ∈ FΣ
◦= 0 where y is a vector that contains all variables in fv(φ)
integer matrix equation Ay
exactly once. Let E be a matrix of elementary modes of A from Theorem 2. The theorem
◦= y for some vector of fresh variables x. So
states that Ay
◦= y. Since all entries of E are positive, the variables in y
let emr(φ) be ∃x.φ(cid:48) and φ(cid:48) be Ex
are pairwise distinct, and the variables in x are chosen freshly, it follows that φ(cid:48) is both
quasi-positive and strongly-triangular.

◦= 0 is R+-equivalent to ∃x.Ex

474

475

476

477

478

479

480

481

482

483

484

485

486

487

488

489

490

491

493

494

495

496

497

498

499

500

501

502

503

504

15 of 33

We have implemented the elementary mode rewriting in Python based on the
cddlib tool [16] and plan to freely publish our tool soon. An example input is the system
of linear Σ
bool-equations φ0 given in Fig. 4. The corresponding integer matrix equation
system is given there too. The elementary modes of the matrix of this system are the
vectors (1, 0, 1, 1) and (1, 1, 0, 0). When putting these vectors in the columns of a new
matrix, our tool returns the elementary mode rewriting emr(φ0) in Fig. 5.

6. hB-Exact Rewriting of Linear Equation Systems

Our next objective is to study the preservation of h-exactness by logical operators.
The main difﬁculty of this paper is the fact that h-exactness is not preserved by conjunc-
tion. Nevertheless, as we will show next, it is preserved by disjunction and existential
quantiﬁcation.

In order to do so we ﬁrst show that h-exactness is preserved when adding variables.
For this we have to assume that the Σ-abstraction h is surjective, which will be the case
of all Σ-abstractions of interest.

Lemma 21 Variable extension preserves exactness. Let h : S → ∆ be a Σ-abstraction that
is surjective and φ ∈ FΣ(V) a formula. Then the h-exactness of φ implies the h-exactness of φ
with respect to V.

Proof This follows from that abstractions of solutions of φ can be extended arbitrarily to
variables that do not appear freely in φ as stated by the following claim.

Claim 22. For all σ : V → ∆: σ ∈ h ◦ solS(φ) iff σ|fv(φ) ∈ h ◦ solS(φ).

For the one direction let σ ∈ h ◦ solS

V(φ) such that
σ = h ◦ σ. Since V ⊇ fv(φ) it follows that σ|fv(φ) ∈ solS(φ). Furthermore σ|fv(φ) =
h ◦ σ|fv(φ) and thus σ|fv(φ) ∈ h ◦ solS(φ).

V(φ). Then there exists σ ∈ solS

For the other direction let σ|fv(φ)) ∈ h ◦ solS(φ). Then there exists σ ∈ solS(φ) such
that σ|fv(φ) = h ◦ σ. For any y ∈ V \ fv(φ) let sy ∈ dom(S) be such that h(sy) = σ(y).
Such values exists since h is surjective. Now deﬁne σ(cid:48) = σ[y/sy | y ∈ V \ fv(φ)]. Since
V ⊇ fv(φ) it follows that σ(cid:48) ∈ solS

V(φ). Furthermore, σ = h ◦ σ(cid:48), so σ ∈ h ◦ solS

V(φ).

For the case of disjunction, we need a basic property of unions (joins) which fails

for intersections (meets).

Lemma 23 Abstraction αh preserves joins. Let V be a set of variables, R1 and R2 be subsets
of assignments of type V → dom(S) and h : S → ∆ be a Σ-abstraction. Then:

h ◦ (R1 ∪ R2) = h ◦ R1 ∪ h ◦ R2

Proof This lemma follows from the following equivalences:

τ ∈ h ◦ (R1 ∪ R2) ⇔ ∃σ.σ ∈ R1 ∪ R2 ∧ τ = h ◦ σ

⇔ ∃σ.(σ ∈ R1 ∨ σ ∈ R2) ∧ τ = h ◦ σ
⇔ ∃σ.(σ ∈ R1 ∧ τ = h ◦ σ) ∨ (σ ∈ R2 ∧ τ = h ◦ σ)
⇔ τ ∈ h ◦ R1 ∨ τ ∈ h ◦ R2
⇔ τ ∈ h ◦ R1 ∪ h ◦ R2

505

506

507

508

509

510

511

512

513

514

515

516

517

518

519

520

521

522

523

524

525

526

527

528

529

530

531

532

533

534

535

Proposition 24. The disjunction of h-exact formulas is h-exact.

16 of 33

Proof Let φ1 and φ2 be negation free formulas that are h-exact. Let V = fv(φ1) ∪ fv(φ2).
Lemma 21 shows that φ1 and φ2 are also h-exact with respect to the extended variable
set V, i.e., for both i ∈ {1, 2}:

h ◦ solS

V(φi) = sol

∆
V(φi)

The h-exactness of the disjunction φ1 ∨ φ2 can now be shown as follows:

h ◦ solS(φ1 ∨ φ2) = h ◦ (solS
= h ◦ solS
= sol
= sol

∆
V(φ1) ∪ sol
∆(φ1 ∨ φ2)

V(φ1) ∪ solS
V(φ1) ∪ h ◦ solS
∆
V(φ2)

V(φ2))

V(φ2) by Lemma 23

by h-exactness of φ1 and φ2 wrt. V

Lemma 25 Projection commutes with abstraction. For any Σ-abstraction h : S → ∆,
subset R of assignments of type V → S, and variable x ∈ V: h ◦ πx(R) = πx(h ◦ R).

Proof For all σ : V → dom(S) we have h ◦ πx(σ) = h ◦ σ|V\{x} = (h ◦ σ)|V\{x} =
πx(h ◦ σ).

Proposition 26 Quantiﬁcation preserves exactness. For any surjective Σ-abstraction h :
S → ∆ and formula ∃x.φ ∈ FΣ, if φ is h-exact then ∃x.φ is h-exact.

Proof Let φ be h-exact. By deﬁnition φ is h-exact with respect to V = fv(φ). Since h is
assumed to be surjective, Lemma 21 implies that φ is h-exact with respect to V ∪ {x}
(independently of whether x occurs freely in φ or not). Hence:

h(solS(∃x.φ)) = h(πx(solS(φ)))
= πx(h(solS(φ)))
= πx(sol
= sol

∆(φ))
∆(∃x.φ)

by Lemma 11
by Lemma 25
since φ is h-exact
by Lemma 11

We next study the h-exactness for strongly-triangular systems of Σ

bool-equations,
bool-algebras with unique division

under the condition that h is an abstraction between Σ
(see Deﬁnition 28).

Lemma 27 Singleton property. If S is a Σ-algebra, e ∈ EΣ(V), and σ : V → S a variable
assignment, then the set

σ,S is a singleton.

e

(cid:74)

(cid:75)

Proof By induction on the structure of expressions e ∈ EΣ(V):
Case of constants c ∈ C. The set
Case of variables x ∈ V. The set
Case f (e1, . . . , en) where ei ∈ EΣ(V) and f ∈ F(n).

σ,S = {cS} is a singleton.
σ,S = {σ(x)} is a singleton.

c
(cid:75)
x
(cid:75)

(cid:74)
(cid:74)

f (e1, . . . , en)

σ,S = { f S(s1, . . . , sn) | si ∈

ei

σ,S}

(cid:74)

(cid:75)
σ,S are singletons by induction hypothesis, meaning that

(cid:74)

(cid:75)

This set is a singleton since
f S(

ei

(cid:74)

(cid:75)

σ,S, . . . ,

σ,S) is also a singleton since S is a Σ-algebra.

e1
(cid:75)
A Σ-algebra is a Σ-structure with the singleton property. Let ele be the function that

en

(cid:75)

(cid:74)

(cid:74)

maps any singleton to the element that it contains.

Deﬁnition 28. We say that a Σ
formula ∀x.∃=1y. ny

◦= x for all nonzero natural numbers n ∈ N.

bool-structure S has unique division, if it satisﬁes the ﬁrst-order

536

537

538

539

540

541

542

543

544

545

546

547

548

549

550

551

552

553

554

555

556

557

17 of 33

Clearly, the Σ

bool-structures R+, B, and S have unique division. Note however,
bool-algebra, so that the following two Propositions 30 and 33 cannot be

that S is not a Σ
applied to S instead of B.

For any element s of the domain of a Σ
any nonzero natural number n ∈ N, we denote by s
solS(ny

◦= z), σ(z) = s}.

bool-structure S with unique division and
n the unique element of {σ(y) | σ ∈

Lemma 29. Let φ ∈ FΣ
natural number n, variable y (cid:54)∈ fv(φ), and expression e ∈ EΣ(fv(φ)):

be a formula and S a Σ

bool

bool-algebra with unique division. For nonzero

solS(φ ∧ ny

◦= e) = {σ[y/

σ,S)

ele(

e
(cid:74)
(cid:75)
n

] | σ ∈ solS(φ)}

e

σ,S)

Proof We ﬁx some σ : fv(φ) → dom(S) arbitrarily. Since S is a Σ
is a singleton and fv(e) ⊆ V(φ), ele(
unique division, so that ele(
y (cid:54)∈ fv(φ), σ[y/ ele(

σ,S
σ,S) is deﬁned uniquely. Furthermore S has
is well deﬁned element of dom(S). Therefore and since
◦= e that extends on σ.
] is a

First we prove the inclusion “⊇”. Let σ ∈ solS(φ), y (cid:54)∈ fv(φ), and σ[y/ ele(
e
(cid:74)
(cid:75)
n

◦= e.
Second, we prove the inverse inclusion “⊆”. Let σ ∈ solS(φ ∧ ny

] is the unique solution of the equation ny

◦= e, it follows that σ[y/ ele(

] is a solution of φ ∧ ny

solution of ny

bool-algebra,

e
(cid:74)
(cid:75)
n

e
(cid:74)
(cid:75)
n

e
(cid:74)
(cid:75)
n

σ,S)

σ,S)

σ,S)

(cid:74)

(cid:75)

(cid:74)

(cid:75)

e

σ,S)

e
(cid:74)
(cid:75)
n

σ[y/ ele(
follows that σ(y) = ele(

] is the unique solution of the equation ny
σ,S)

σ,S)

so that σ = σ(cid:48)[y/ ele(

e
(cid:74)
(cid:75)
n

e
(cid:74)
(cid:75)
n

◦= e). Since
◦= e that extends on σ(cid:48) = σ|fv(φ) it
] while σ(cid:48) ∈ solS(φ).

Proposition 30. Let φ ∈ FΣ
expression, y /∈ V, and h : S → ∆ a Σ
division. Under these conditions, if φ is h-exact then φ ∧ e

bool

bool-abstraction between Σ

◦= ny is h-exact.

(V) a formula, n (cid:54)= 0 a natural number, e ∈ EΣ

(V) an
bool-algebras with unique

bool

576

Proof Let e ∈ EΣ

(V) an expression.

bool

Claim 31. For any σ : V → R+: h(ele(

σ,S)) = ele(

e

(cid:75)

(cid:74)

h◦σ,∆).

e

(cid:74)

(cid:75)

This can be seen as follows. For any σ : V → S Theorem 1 on homomorphism
h◦σ,∆
. Since S and ∆ are both Σ-algebras, the sets
h◦σ,∆).
(cid:74)
e

yields h(
are both singletons by Lemma 27, so that h(ele(

σ,S)) = ele(

σ,S and

σ,S) ⊆

h◦σ,∆

(cid:75)

(cid:74)

(cid:75)

(cid:75)

(cid:74)

(cid:74)

(cid:75)

e

e

e

e

e

(cid:74)
(cid:75)
n ) = h(s)
Claim 32. For any s ∈ dom(S) and n (cid:54)= 0 a natural number: h( s
n .

(cid:74)

(cid:75)

Since S is assumed to have unique division s(cid:48) = s

element of dom(S) such that s(cid:48) +S . . . +S s(cid:48)
(cid:125)

(cid:124)

(cid:123)(cid:122)
n

since h is a homomorphism, it follows that h(s(cid:48)) +∆

n is well-deﬁned as the unique
) = h(s) and

= s. Hence, h(s(cid:48) +S . . . +S s(cid:48)
(cid:125)

= h(s). Since ∆ is

(cid:124)
. . . +∆
(cid:123)(cid:122)
n

(cid:123)(cid:122)
n
h(s(cid:48))
(cid:125)

(cid:124)

assumed to have unique division, this implies that h(s(cid:48)) = h(s)
n .

558

559

560

561

562

563

564

565

566

567

568

569

570

571

572

573

574

575

577

578

579

580

581

582

583

584

585

The Proposition can now be shown based on these two claims. Let φ be h-exact,

y (cid:54)∈ V, and fv(e) ⊆ V. We have to show that φ ∧ ny

◦= e is h-exact too:

18 of 33

h ◦ solS(φ ∧ e

◦= ny) = h ◦ {σ[y/ ele(

σ,S)

e
(cid:74)
(cid:75)
n

by Lemma 29

)] | σ ∈ solS(φ)} elementary

= {(h ◦ σ)[y/h( ele(
σ,S)
= {σ[y/h( ele(
= {σ[y/ h(ele(
= {σ[y/ ele(
e
(cid:74)
∆(φ ∧ e
= sol

e
(cid:75)
(cid:74)
n
σ,S))
e
(cid:75)
(cid:74)
n
h◦σ,∆)
(cid:75)
n
◦= ny)

] | σ ∈ solS(φ)}
σ,S)
e
(cid:74)
(cid:75)
n
)] | σ ∈ sol
] | σ ∈ sol
] | σ ∈ sol

∆(φ)}
∆(φ)}
∆(φ)}

h-exactness of φ

by Claim 32

by Claim 31
by Lemma 29

586

587

588

589

590

591

592

593

594

595

596

Proposition 33. Let h : S → ∆ be a Σ
Then any strongly-triangular system of Σ

bool-abstraction between algebras with unique division.

bool-equations is h-exact.

◦= niyi where n
Proof Any strongly-triangular system of equations has the form (cid:86)n
and ni (cid:54)= 0 are naturals and yi is i-fresh for all 1 ≤ i ≤ n. The proof is by induction on n.
In the case n = 0, the conjunction is equal to true which is h-exact since h(solS(true)) =
◦= njyj is
sol
◦= njyj is
h-exact. Since ni (cid:54)= 0 it follows from Proposition 30 that that ei
h-exact.

∆(true). In the case n > 0, we have by induction hypothesis that (cid:86)i−1
j=1 ej
◦= niyi ∧ (cid:86)i−1
j=1 ej

i=1 ei

We notice that Proposition 33 remains true for triangular systems that are not
strongly-triangular. This will follow from results that we can only present in the next
section (Theorem 4 and Proposition 41), since they require an additional argument.

597

Theorem 3 hB-Exactness. Quasi-positive strongly-triangular polynomial systems are hB-exact.

598

599

600

601

602

603

604

605

606

607

608

609

610

611

612

613

614

615

616

Proof The Σ
33 for proving the theorem.

bool-algebras R+ and B have unique division, so we can apply Proposition

We note that the analogous statement for S instead of B fails, even though S has
bool-algebra. As a counter-example,

unique division. The problem is that S is not a Σ
reconsider the strongly-triangular system of quasi-positive system equations:

u + v

◦= x ∧ u + v

◦= y

◦= y over R but accept the abstract solution [u/1, v/−1, x/1, y/−1]
This system implies x
mapping x and y to distinct signs, so it is not hS-exact. Nevertheless it is hB-exact by
Theorem 3.

Corollary 2 hB-exact rewriting of linear equation systems. For any linear Σ
φ the elementary mode rewriting emr(φ) ∈ FΣ
computed in at most exponential time from φ.

bool-equations
is R+-equivalent, hB-exact, and can be

bool

Proof The elementary modes rewriting Corollary 1 shows that any linear Σ
bool-equation
system φ is R+-equivalent a formula emr(φ) of the form ∃z.φ(cid:48) such that φ(cid:48) is a quasi-
positive strongly-triangular linear equation system. Theorem 3 shows that any quasi-
positive strongly-triangular linear equation system is hB-exact, so is φ(cid:48). Existential
quantiﬁcation preserves hB-exactness by Proposition 26, so emr(φ) is hB-exact too.

This hB-exact rewriting permits us to compute the boolean abstraction of any system
bool-equations by computing the B-solutions of the R+-equivalent hB-exact

of linear Σ
formula. The latter can be done by ﬁnite domain constraint programming.

Our objective to ﬁnd an algorithm for computing the sign abstraction of a system of
linear Σ
bool-equations remains open. We will ﬁnally approach it in Section 9. While the
idea is to use the hB-exact rewriting algorithm, we ﬁrst need to generalize it from linear

19 of 33

systems to mixed systems. This will be done in Section 8. The generalization will rely on
the notion of hB-invariance that we discuss next in Section 7.

7. Invariance

A problem that we need to overcome is that conjunctions of two h-exact formulas
may not be h-exact. The situation changes when assuming the following notion of
h-invariance for at least one of the two formulas.

Deﬁnition 34 Invariance. Let h : S → ∆ be a Σ-abstraction and V ⊆ V a subset of variables.
We call a subset R of variable assignments of type V → dom(S) h-invariant iff:

∀σ, σ(cid:48) : V → dom(S). (σ ∈ R ∧ h ◦ σ = h ◦ σ(cid:48) =⇒ σ(cid:48) ∈ R).

We call a Σ-formula φ h-invariant if its solution set solS(φ) is.

The relevance of the notion of invariance for exactness of conjunctions – that we

will formalize in Proposition 41 – is due to the the following lemma:

Lemma 35. If either R1 or R2 are h-invariant then: h ◦ (R1 ∩ R2) = h ◦ R1 ∩ h ◦ R2.

Proof The one inclusion is straightforward without invariance:

h ◦ (R1 ∩ R2) = {h ◦ σ | σ ∈ R1, σ ∈ R2}

⊆ {h ◦ σ | σ ∈ R1} ∩ {h ◦ σ | σ ∈ R2}
= h ◦ R1 ∩ h ◦ R2

For the other inclusion, we can assume without loss of generality that R1 is h-invariant.
So let τ ∈ h ◦ R1 ∩ h ◦ R2. Then there exist σ1 ∈ R1 and σ2 ∈ R2 such that τ = h ◦ σ1 =
h ◦ σ2. By h-invariance of R1 it follows that σ1 ∈ R2. So σ1 ∈ R1 ∩ R2, and hence,
τ ∈ h ◦ (R1 ∩ R2).

We can now present the algebraic characterization of h-invariance based on the
concretization function γh of the Galois connection of h. Recall that R ⊆ h ◦−(h ◦ R) for
all subsets of concrete variable assignments R. The inverse inclusion characterizes the
h-invariance of R.

Lemma 36 Algebraic characterization. Let h : S → ∆ be a Σ-abstraction. A subset R of
concrete variable assignment V → dom(S) is h-invariant for h iff h ◦−(h ◦ R) ⊆ R.

Proof “⇒”. Let R be h-invariant and σ ∈ h ◦−(h ◦ R). Then there exists σ(cid:48) ∈ R such that
h ◦ σ = h ◦ σ(cid:48). The h-invariance of R thus implies that σ ∈ R.
“⇐”. Suppose that h ◦−(h ◦ R) ⊆ R. Let σ, σ(cid:48) : V → dom(S) such that h ◦ σ = h ◦ σ(cid:48) and
σ ∈ R. We have to show that σ(cid:48) ∈ R. From h ◦ σ = h ◦ σ(cid:48) and σ ∈ R it follows that
σ(cid:48) ∈ h ◦−(h ◦ R) and thus σ(cid:48) ∈ R as required.

Lemma 37 Variable extension preserves invariance. Let h be a surjective abstraction and
R a subset of functions of type V(cid:48) → dom(S) and V a subset of variables disjoint from V(cid:48). If R
is h-invariant then extS

V(R) is h-invariant too.

Proof This will follow straightforwardly from the characterization of h-invariance in
Lemma 36 and the following two claims:

Claim 38. If h is surjective then h ◦ extS

V(R) = ext

∆
V(h ◦ R).

This follows from h ◦ extS

V(R) = {h ◦ σ | σ ∈ extS

V(R)} = ext

where we use the surjectivity of h in the last step.

∆

V({h ◦ σ(cid:48) | σ(cid:48) ∈ R})

617

618

619

620

621

622

623

624

625

626

627

628

629

630

631

632

633

634

635

636

637

638

639

640

641

642

643

644

645

646

647

648

649

650

Claim 39. h ◦−ext

∆

V(R(cid:48)) = extS

V(h ◦−R(cid:48)) for any subset R(cid:48) of functions of type V(cid:48) → dom(∆).

20 of 33

∆

h ◦−ext

V(R(cid:48)) = {σ : V ∪ V(cid:48) → dom(S) | h ◦ σ ∈ ext

∆

V(R(cid:48))}

= {σ : V ∪ V(cid:48) → dom(S) | h ◦ σ|V(cid:48) ∈ R(cid:48)}
V({σ(cid:48) : V(cid:48) → dom(S) | h ◦ σ(cid:48) ∈ R(cid:48)}
= extS
V(h ◦−R(cid:48))
= extS

Lemma 40. Let h : S → ∆ be a surjective Σ-abstraction, φ be a Σ-formula, and V ⊇ fv(φ).
Then the h-invariance of φ implies the h-invariance of solS

V(φ).

Proof This follows from the cylindriﬁcation Lemma 10 and that extension preserves
h-invariance as shown in Lemma 37.

Proposition 41 Exactness is preserved by conjunction when assuming invariance. Let
h be a surjective Σ-abstraction. If φ1 and φ2 are h-exact Σ-formulas and φ1 or φ2 are h-invariant
then the conjunction φ1 ∧ φ2 is h-exact.

Proof Let φ1 and φ2 be h-exact Σ-formulas. We assume without loss of generality that
φ1 is h-invariant. Let V = fv(φ1 ∧ φ2). Since fv(φ2) ⊆ V the set solS
V(φ2) is h-invariant
too by Lemma 40. We can now show that φ1 ∧ φ2 is h-exact as follows:

h ◦ solS(φ1 ∧ φ2) = h ◦ (solS
= h ◦ solS
= sol
= sol

∆
V(φ1) ∩ sol
∆(φ1 ∧ φ2)

V(φ1) ∩ solS
V(φ1) ∩ h ◦ solS
∆
V(φ2)

V(φ2))

V(φ2) by Lemma 35

by h-exactness of φ1 and φ2 wrt V

Our next objective is to show that h-invariant formulas are closed under conjunction,
disjunction, and existential quantiﬁcation. The two former closure properties rely on the
following two algebraic properties of abstraction decomposition.

Lemma 42 Concretization γh preserves join and meet. For any Σ-abstraction h : S → ∆,
any subsets of assignments of type V → dom(S) R1 and R2 and V a subset of variables:
•
•

h ◦−(R1 ∩ R2) = h ◦−R1 ∩ h ◦−R2.
h ◦−(R1 ∪ R2) = h ◦−R1 ∪ h ◦−R2.

For general Galois connections, concretization is well-known to preserve joins but
may not preserve meets. Still, meets are preserved for any Galois connections where the
the concrete and abstract domains C and A are powersets as in our setting, so that joins
are unions and meets intersections.

Proof The case of unions follows straightforwardly from the deﬁnitions:

h ◦−(R1 ∪ R2) = {σ | h ◦ σ ∈ R1 ∪ R2}

= {σ | h ◦ σ ∈ R1 ∨ h ◦ σ ∈ R2}
= {σ | h ◦ σ ∈ R1} ∪ {σ | h ◦ σ ∈ R2}
= h ◦−R1 ∪ h ◦−R2

The case of intersection is symmetric:

h ◦−(R1 ∩ R2) = {σ | h ◦ σ ∈ R1 ∩ R2}

= {σ | h ◦ σ ∈ R1 ∧ h ◦ σ ∈ R2}
= {σ | h ◦ σ ∈ R1} ∩ {σ | h ◦ σ ∈ R2}
= h ◦−R1 ∩ h ◦−R2

651

652

653

654

655

656

657

658

659

660

661

662

663

664

665

666

667

668

669

670

671

21 of 33

672

673

674

675

676

677

678

679

680

681

682

683

684

Lemma 43 Intersection and union preserve invariance. Let h : S → ∆ be a Σ-abstraction.
Then the intersection and union of any two h-invariant subsets R1 and R2 of variables assign-
ments of type V → dom(S) is h-invariant.

Proof This follows from the algebraic characterization Lemma 36 for invariance, in
combination with the algebraic properties of composition and decomposition given in
Lemmas 23, 35, and 42.

Lemma 44 Concretization γh commutes with projection.. h ◦−πx(R) = πx(h ◦−R).

Proof For all σ : V → dom(∆) we have h ◦−πx(σ) = h ◦−σ|V\{x} = (h ◦−σ)|V\{x} =
πx(h ◦−σ).

Proposition 45 Invariance is preserved by conjunction, disjunction, and quantiﬁca-
tion. If h is a surjective abstraction then the class of h-invariant FO-formulas is closed under
conjunction, disjunction, and existential quantiﬁcation.

Proof Let h : S → ∆ be a Σ-abstraction.
Case of conjunction: Let φ1 and φ2 be h-invariant and V = fv(φ1 ∧ φ2). By Lemma 40 the
sets solS
V(φ2) are both h-invariant, and so by Lemma 43 is their intersection.
Hence:

V(φ1) and solS

h ◦−(h ◦ solS(φ1 ∧ φ2))

= h ◦−(h ◦ (solS
⊆ solS
= solS(φ1 ∧ φ2)

V(φ1) ∩ solS

V(φ1) ∩ solS
V(φ2)

V(φ2)))

by h-invariance and Lemma 36

685

686

By Lemma 36 in the other direction, this implies that φ1 ∧ φ2 is h-invariant.
Case of disjunction: Analogous to the case of conjunction.
Case of existential quantiﬁcation:

h ◦−(h ◦ solS(∃x.φ1))

= h ◦−(h ◦ πx(solS(φ1))) by Lemma 11
= h ◦−(πx(h ◦ solS(φ1))) by Lemma 25
= πx(h ◦−(h ◦ solS(φ1))) by Lemma 44
⊆ πx(solS(φ1))
= solS(∃x.φ1)

by h-invariance of φ1 and Lemma 36
by Lemma 11

687

688

689

690

691

692

693

694

695

696

697

By Lemma 36, this implies that ∃x.φ1 is h-invariant.

We do not known whether negation preserves h-invariance in general, but for ﬁnite
∆ it can be shown that if φ is h-exact and h-invariant, then ¬φ is h-exact and h-invariant
too.

Proposition 46. Let h be a surjective Σ-abstraction. Then the class of h-exact and h-invariant
Σ-formulas is closed under conjunction, disjunction and existential quantiﬁcation.

Proof Closure under conjunction follows from Propositions 41 and 45, closure under
disjunction from Propositions 24 and 45, and closure under existential quantiﬁcation by
Propositions 26 and 45.

Theorem 4 hB-invariance and hB-exactness of polynomial equations. Any positive
polynomial equation p

◦= 0 such that p has no constant term is hB-exact and hB-invariant.

22 of 33

698

699

700

Proof Consider a positive polynomial equation p
and only positive coefﬁcients. Thus p has the form ∑l
and nj, ij, mj,k > 0.

◦= 0 such that p has no constant term
mj,k
◦= 0 where l ≥ 0,
j,k

j=1 nj ∏ij

k=1 x

701

Claim 47. For both algebras S ∈ {B, R+}: solS(p

◦= 0) = solS((cid:86)l

j=1

(cid:87)ij

k=1 xj,k

◦= 0).

702

703

704

705

The polynomial has values zero if and only if all its monomials do, that is: ∏ij
0 for all 1 ≤ j ≤ l. Since constant terms are ruled out, we have ij (cid:54)= 0. Furthermore, we
assumed for all polynomials that mj,k (cid:54)= 0. So for all 1 ≤ j ≤ l there must exist 1 ≤ k ≤ ij
such that xj,k = 0.

k=1 x

mjk
j,k =

706

Claim 48. The equation x

◦= 0 is hB-exact and hB-invariant.

707

This proof of this claim is straightforward from the deﬁnitions.

With these two claims we are now in the position to prove the Theorem 4. Since the
class of hB-exact and hB-invariant formulas is closed under conjunction and disjunction
◦= 0 is both hB-exact
by Proposition 46, it follows from by Claim 48 that ∧l
and hB-invariant. Since this formula is equivalent over R+ to the polynomial equation
◦= 0. The hB-exactness also carries over
by Claim 47, the hB-invariance carries over to p
based on the equivalence for both structures R+ and B:

ij
k=1 xj,k

j=1 ∨

hB ◦ sol

R+ (p

◦= 0) = hB ◦ sol
B(∧l
= sol
B(p
= sol

R+
V (∧l
j=1 ∨
ij
j=1 ∨
k=1 xj,k
◦= 0)

ij
k=1 xj,k
◦= 0)

◦= 0) by Claim 47 for R+
by hB exactness
by Claim 47 for B.

708

709

710

711

712

713

714

715

716

717

718

719

720

721

722

8. hB-Exact Rewriting of hB-Mixed Systems

In this section, we lift our main result to hB-mixed system, presenting a rewrite

algorithm that makes any hB-mixed system hB-exact.

Deﬁnition 49. A hB-mixed system is a formula in FΣ
system of linear Σ

bool-equations and φ(cid:48) a hB-invariant and hB-exact ﬁrst-order formula.

of the form ∃z. φ ∧ φ(cid:48) where φ is a

bool

Note that linear equation systems Ay

◦= 0, with A an integer matrix and y a
sequence of pairwise distinct variables, need not to be hB-exact, if A is not positive.
However, as shown by the elementary mode rewriting Corollary 1 any linear equation
systems is R+-equivalent to some quasi-positive strongly-triangular linear system, that
is hB-exact by Theorem 3.

Our next objective is to rewrite formulas in order to reduce the overapproximation
coming with the abstract interpretation over the Booleans by John’s theorem. The idea is
to make a linear equation system hB-exact that are used as subformulas as for instance
of hB-mixed systems.

We recall from Corollary 1 that the elementary mode rewriting emr(φ) of a linear
equation system is an hB-exact formula that is R+-equivalent to φ. We now introduce the
boolean rewriting by lifting the elementary mode rewriting to a richer class of formulas.
Given a vector z ∈ V ∗, a linear equation system φ ∈ FΣ
,
the boolean rewriting is deﬁned by:

, and a formula φ(cid:48) ∈ FΣ

bool

bool

br(∃z. (φ ∧ φ(cid:48))) =def ∃z. (emr(φ) ∧ φ(cid:48))

723

724

The boolean rewriting may indeed reduce the overapproximation coming with abstract
interpretation of formulas over the booleans, as show by the following proposition.

725

Proposition 50. hB ◦ sol

R+ (ψ) ⊆ sol

B(br(ψ)) ⊆ sol

B(ψ).

23 of 33

Proof Let φ be a linear equation system, z ∈ V ∗, φ(cid:48) ∈ FΣ

and ψ =def ∃z.φ ∧ φ(cid:48).
Since φ is R+-equivalent to emr(φ), it follows that br(ψ) is R+-equivalent to ψ. Hence,
sol

R+ (br(ψ)) so that:

R+ (ψ) = sol

bool

hB ◦ sol

R+ (ψ) = hB ◦ sol

R+ (br(ψ))

By John’s theorem, we have:

hB ◦ sol

R+ (br(ψ)) ⊆ sol

B(br(ψ))

Furthermore, by hB-exactness, R+-equivalence, and again John’s theorem, we have:

B(emr(φ)) = hB ◦ sol

R+ (emr(φ)) = hB ◦ sol

R+ (φ) ⊆ sol

B(φ)

sol

Therefore, it follows that:

B(br(ψ)) ⊆ sol

B(ψ)

sol

726

In combination this yields the inclusions of the proposition.

727

728

729

730

731

732

733

734

735

736

737

738

739

740

741

742

743

744

745

746

747

748

749

750

751

752

753

754

755

Theorem 5 (Main). For any hB-mixed system ψ ∈ FΣ the boolean rewriting br(ψ) is hB-exact,
R+-equivalent to ψ, and can be computed in at most exponential time.

Proof Let ψ be a hB-mixed system ∃x. (φ ∧ φ(cid:48)). where φ is a linear equation system
and φ(cid:48) a ﬁrst-order formula that is hB-exact and hB-invariant. Based on the elementary
modes rewriting Corollary 1, the linear equation system φ can be transformed in at
most exponential time to the form emr(ψ) = ∃z.φ(cid:48)(cid:48) where φ(cid:48)(cid:48) is a quasi-positive strongly-
triangular system of linear equations. Such polynomial equation systems are hB-exact
by Theorem 3, and so is φ(cid:48)(cid:48). The Invariance Proposition 41 shows that the conjunction
φ(cid:48)(cid:48) ∧ φ(cid:48) is hB-exact too, since φ(cid:48) was assumed to be hB-exact and hB-invariant. The
hB-exactness is preserved by existential quantiﬁcation by Proposition 26, so the formula
br(ψ) = ∃x. emr(φ) ∧ φ(cid:48) is hB-exact too.

Corollary 3. The hB-abstraction of the R+-solution set of a hB-mixed system φ, that is hB ◦
sol

R+ (φ), can be computed in at most exponential time in the size of the system φ.

Proof Given a hB-mixed system φ, we can apply Theorem 5 to compute in at most
exponential time a R+-equivalent formula φ(cid:48)(cid:48) that is hB-exact. It is then sufﬁcient to
B(φ(cid:48)(cid:48)) in exponential time in the size of φ. This can be done in the naive
compute sol
manner, that is by evaluating the formula φ(cid:48)(cid:48) – which may be of exponential size – over
all possible boolean variable assignments – of which there may be exponentially many.
For each assignment the evaluation can be done in PSPACE and thus in exponential
time. The overall time required is thus a product of two exponentials, which remains
exponential.

The algorithm from the proof Corollary 3 can be improved so that it becomes
sufﬁciently efﬁcient for practical use. For this the two steps with exponential worst case
complexity must be made polynomial for the particular instances. First note that the
computation of the elementary modes (Corollary 1) is known to be computationally
feasible. Various algorithms for this purpose were implemented [15,16,24,25] and applied
successfully to problems in systems biology [13]. The second exponential step concerns
the enumeration of all boolean variable assignments. This enumeration may be avoided
B(φ(cid:48)(cid:48)).
by using constraint programming techniques for computing the solution set sol

24 of 33

For those hB-mixed systems for which both steps can be done in polynomial time, we
can compute the boolean abstraction of the R+-solution set in polynomial time too. The
practical feasibility of this approach was demonstrated recently at an application to
knockout prediction in systems biology [6], where previously only over-approximations
could be computed.

9. Computing Sign Abstractions

We next show how to compute the sign abstraction hS ◦ sol

R(φ) for systems φ of
bool-equations. In order to apply hB-exact rewriting, we will decompose the sign

linear Σ
abstraction into the boolean abstraction and functions deﬁnable in ﬁrst-order logic.

756

757

758

759

760

761

762

763

764

765

9.1. Decomposition

We can decompose any real number r ∈ R into a pair of two positive numbers

dec(r) ∈ R2

+ – negative and the positive part – as follows:

766

767

768

769

770

771

772

773

774

775

776

777

778

dec(r) =def

(cid:26) (0, r)

(−r, 0)

if r ≥ 0
if r ≤ 0

The image of this sujective function is {0} × R+) ∪ (R+ × {0}, so it has an inverse
dec-1 : ({0} × R+) ∪ (R+ × {0}) → R, which satisﬁes for all pairs (r1, r2) in the domain:
dec-1(r1, r2) = r2 −R

r1

Furthermore, recall that h2

B : R2

+ → B2 satisﬁes h2

B(r1, r2) = (hB(r1), hB(r2)).

Lemma 51 Decomposition. hS = dec-1 ◦ h2

B ◦ dec

Proof If r is negative then dec-1(h2
= −hB(−r) = hS(r). Otherwise if r is positive then dec-1(h2
= dec-1((0, hB(r)) = hB(r) = hS(r).

B(dec(r))) = dec-1(h2

B((−r, 0))) = dec-1((hB(−r), 0))
B((0, r)))

B(dec(r))) = dec-1(h2

9.2. Positivity

We will show in a ﬁrst step that ﬁrst-order formulas over the reals can be rewritten,

such that interpretation over the positive reals is enough.

We call a formula φ ∈ FΣ

ﬂat if all equations contained in φ have the form
◦= x1 + x2, x
◦= 1 for some variables x, x1, x2. Note that
x
any formula φ ∈ FΣ
can be converted to an equivalent ﬂat formula in linear time
by introducing fresh existentially quantiﬁed variables, so that we can assume ﬂatness
without loss of generality.

◦= x1 ∗ x2, x

◦= 0, or x

bool

bool

We ﬁx two generators of fresh variable ν(cid:9), ν⊕ : V → V. For any x ∈ V, the intention
is that ν⊕(x) stands for the positive part of x and ν(cid:9)(x) for its negative part. We will
preserve the invariants x = ν⊕(x) − ν(cid:9)(x) and ν⊕(x) ∗ ν(cid:9)(x) = 0. Furthermore, we
deﬁne ν : V → V 2 such that for all x ∈ V:

ν(x) =def (ν(cid:9)(x), ν⊕(x))

For any ﬂat formula φ ∈ FΣ(V) we deﬁne a formula decν(φ) ∈ FΣ(ν(cid:9)(V) ∪ ν⊕(V))
with the variables ν(cid:9)(x) and ν⊕(x) instead of x for all x ∈ V. Otherwise the formula
(cid:103)decν(φ) has the same meaning as over the reals than φ.

(cid:103)decν(φ) = decν(φ) ∧ (cid:94)
x∈V

ν⊕(x) ∗ ν(cid:9)(x) ◦= 0

where

25 of 33

decν(x

◦= x1 + x2) =

ν⊕(x) + ν(cid:9)(x1) + ν(cid:9)(x2) ◦=
ν(cid:9)(x) + ν⊕(x1) + ν⊕(x2)

◦= 0) = ν⊕(x) ◦= ν(cid:9)(x)
decν(x
decν(∃x.φ) = ∃ν(cid:9)(x).∃ν⊕(x).

decν(x

◦= x1 ∗ x2) =

ν⊕(x) + ν⊕(x1) ∗ ν(cid:9)(x2) + ν(cid:9)(x1) ∗ ν⊕(x2) ◦=
ν(cid:9)(x) + ν⊕(x1) ∗ ν⊕(x2) + ν(cid:9)(x1) ∗ ν(cid:9)(x2)

◦= 1) = ν⊕(x) ◦= ν(cid:9)(x) + 1
decν(x
decν(φ ∧ φ(cid:48)) = decν(φ) ∧ decν(φ(cid:48))

ν⊕(x) ∗ ν(cid:9)(x) ◦= 0 ∧ decν(φ) decν(¬φ) = ¬decν(φ)

779

780

781

782

783

784

785

786

in the structure of reals is the inverse of addition +R

Note that the deﬁnition in the case of addition, the deﬁnition relies on that subtraction
−R
. The expressions that are to be
subtracted on one side of the equation are added to the other side instead. This is also
used in the case of multiplication, in combination with the distributivity law for addition
+R
. Furthermore, (cid:103)decν(φ) belongs to FΣ
(ν(cid:9)(V) ∪ ν(cid:9)(V)) and
can be computed in linear time from φ.

and multiplication ∗R

bool

Proposition 52 Positivity. For any ﬂat formula φ ∈ FΣ

(V):

bool

dec ◦ sol

R
V (φ) = {σ2 ◦ ν|V | σ ∈ sol

R+ ( (cid:102)decν(φ))}

Proof By induction on the structure of φ. In the ﬁrst case of reals, can use that −R
inverse of +R

and that the distributivity laws holds for +R

and ∗R

.

is the

787

Lemma 53. For any ﬂat linear equation system φ the formula (cid:102)decν(φ) is a hB-mixed system.

788

789

790

791

792

793

794

795

Proof If φ is a ﬂat linear system, then decν(φ) is a linear system, so that (cid:103)decν(φ) is a
hB-mixed system.

9.3. Computing Sign Abstractions

We now have developed all the prerequisite for computing the sign abstraction of

linear equation systems by using hB-exact boolean rewriting of hB-mixed systems.

Theorem 6. For any linear equation system φ ∈ FΣ
computed in at most exponential time and satisﬁes:

bool

(V) the formula br( (cid:102)decν(φ)) can be

hS ◦ sol

R

V (φ) = {[y/τ(ν⊕(y)) −R

τ(ν(cid:9)(y)) | y ∈ V] | τ ∈ sol

B(br( (cid:102)decν(φ)))}

bool

Proof Let φ ∈ FΣ
(V) be a system of linear equations. Without loss of generality, we
can assume that φ is ﬂat. Let: ˜φ =def (cid:103)decν(φ). The formula ˜φ is a hB-mixed system by
Lemma 53 with fv( ˜φ) = ν(cid:9)(V) ∪ ν⊕(V) so that we can apply the Main Theorem 5 to it. It
shows that boolean rewriting br( ˜φ) is an R+-equivalent formula in FΣ(ν⊕(V) ∪ ν(cid:9)(V))
that is hB-exact and can be computed in at most exponential time. We can now conclude
as follows:

hS ◦ sol

R
V (φ)

R
V (φ)
= dec-1 ◦ h2
= dec-1 ◦ h2
= dec-1 ◦ h2
= {dec-1 ◦ τ2 ◦ ν|V | τ ∈ sol
= {[y/τ(ν⊕(y)) −R

B ◦ dec ◦ sol
B ◦ {σ2 ◦ ν|V | σ ∈ sol
B ◦ {σ2 ◦ ν|V | σ ∈ sol

B(br( ˜φ))}
τ(ν(cid:9)(y)) | y ∈ V]
B(br( ˜φ))}

| τ ∈ sol

Decomposition Lemma 51
Positivity Proposition 52

R+ ( ˜φ)}
R+ (br( ˜φ)} R+-equivalence of ˜φ and br( ˜φ)
hB-exactness of br( ˜φ)
deﬁnition of dec-1

The sign abstraction of a system φ of Σ

bool-equations with free variables in V = fv(φ)
can thus be computed by ﬁrst computing the hB-exact formula br( ˜φ) ∈ FΣ(ν⊕(V) ∪

26 of 33

s h o u l d n e v e r happen ’ )

d e f

f l o a t ,

s :

f l o a t ) :

r a i s e V a l u e E r r o r ( ’ T h i s

I ( a :
i f a < 0 :
i f
s > a :

r e t u r n 0

e l s e :

r e t u r n s * f ( a ) + I ( a = s ,

s )

796

797

798

799

800

801

802

803

804

805

806

807

808

809

810

811

812

813

814

815

816

817

818

819

Figure 6. Python function approximating the integral (cid:82) a
0

f(x)dx for a given function f : R → R.

ν(cid:9)(V)) from Theorem 6 by applying the Positivity Proposition 52 and the Main Theorem
B(br( ˜φ)) by ﬁnite domain constraint programming, and ﬁnally
5, then computing sol
inferring hS ◦ sol

R(φ) thereof based on the equation of Theorem 6.

Corollary 4. The sign abstraction hS ◦ sol
time in the size of φ.

R
V (φ) can be computed in at most single exponential

Proof The formula br( ˜φ) is of exponential size but contains only twice as many variables
R
V (φ) by testing 62n variable
than φ. Let n = |fv(φ)|. We can the compute hS ◦ sol
R(br( ˜φ)). Each such test is linear in the size of br( ˜φ)
assignments for membership to sol
and thus in O(2m) where m is the size of φ. So the overall time is in O(62n2m) and since
n ≤ m in O(63m).

We ﬁnally show that the same algorithm as for computing the sign abstraction for
linear equation systems can be lifted to a richer class of formulas to obtain another and
possibly more precise overapproximation of the sign abstraction than John’s.

Proposition 54. Let ψ = ∃z. φ ∧ φ(cid:48) in FΣ
formula φ(cid:48) ∈ FΣ
abstraction of φ:

(V) for some linear equation system φ and
. The formula br( (cid:102)decν(ψ)) then yields an overapproximation of the sign

bool

bool

hS ◦ sol

R

V (ψ) ⊆ {[y/τ(ν⊕(y)) −R

τ(ν(cid:9)(y)) | y ∈ V] | τ ∈ sol

B(br( (cid:102)decν(ψ)))}

Proof Along the lines of the proof of Theorem except that br((cid:103)decν(ψ)) is not hB-exact.
Therefore, the equality where the hB-exactness was used must be weakened to an
inclusion.

10. Application to Program Analysis

We illustrate our results by applying the sign abstraction for program analysis
based on abstract interpretation. We consider the Python implementation in Fig. 6 of
the function I : R2 → R. A call I(a, s) supposedly computes the approximation of
the integral (cid:82) a
f(x)dx with step width s for some total function f : R → R. Abstract
interpretation allows us to ﬁnd out the conditions that must hold on the input parameters
for I((a : f loat, s : f loat) to work properly, and in particular to avoid exception throwing.

0

We can ﬁrst interpret numeric programs abstractly as a formula of ﬁrst-order logic
arith. We illustrate this in an ad hoc manner on the integral example I:

with signature Σ

φI =def

∃retf∃retI∃result.
(a < 0 ⇐⇒ raise_exception
((s > a ∧ do_recursion
(¬(s > a) ∧ do_recursion
◦= s · retf + retI))

◦= 1) ∧
◦= 0 ∧ result
◦= 1 ∧ arec

result

◦= 0) ∨
◦= a − s ∧ srec

◦= s ∧

820

821

The variables a and s are the formal parameters in the deﬁnition of I(a : f loat, s :
f loat). The others are fresh variables introduced to handle exceptions or function

#
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

s
raise_exception do_recursion a
1
0
1
1
1
1
1
1
0
0
1
0
0 -1
1
1
1 -1
1
1

0
0
0
0
0
0
0
0
0
0

0
0
0
0
1
1
1
1
1
1

27 of 33

arec
-1
0
-1
1
0
1
1
0
1
-1

srec
1
1
1
1
0
0
-1
1
-1
1

#
11.
12.
13.
14.
15.
16.
17.
18.
19.

raise_exception do_recursion

0
1
1
1
1
1
1
1
1

1
0
0
0
0
0
1
1
1

s
a
1
1
-1
0
-1 -1
-1 -1
-1 -1
-1
1
-1 -1
-1 -1
-1 -1

arec
1
-1
0
-1
1
-1
0
-1
1

srec
1
0
-1
-1
-1
1
-1
-1
-1

Table 1: The set of abstract solutions in sol
color are unjustiﬁed since outside hS ◦ sol

S(φI). The 6 solutions with gray background
R(φI).

822

823

824

825

826

827

828

829

830

831

832

833

834

835

836

837

838

839

840

841

842

843

844

845

846

847

848

849

850

851

852

853

854

855

856

857

858

859

860

861

862

863

864

calls: the boolean ﬂag raise_exception represents exception throwing, the boolean ﬂag
do_recursion has a true value only when a recursive call is made to I with actual parame-
ters represented by the variables arec, srec and return value represented by retI, while retf
is the variable for the return value of the call to the function f. The ﬁnal return value of
I is represented by the variable result. In what follows, we are not interested in the signs
of the last three variables, so we quantify them existentially.

The sign behaviour of function I is given by the formula’s sign abstraction hS ◦
R(φI). Given that φI is not hB-mixed system, we cannot apply the algorithm from
sol
Theorem 6 directly to compute this sign abstraction. Nevertheless, it will be beneﬁcial as
we will illustrate below.

By John’s theorem, the sign abstraction hS ◦ sol

R(φI) can be overapproximated
S(φI). Since S is a ﬁnite structure, this abstract inter-
by the abstract interpretation sol
pretation can be computed by ﬁnite domain constraint programming. For this, we
implemented a solver for ﬁrst-order formulas over the structure S with Minizinc [17].
S(φI) given in Table 1. This
When applied to φI it returns the set of abstract solutions sol
R(φI).
set contains the 6 unjustiﬁed abstract solutions 2, 4, 10, 13, 15, 18 outside hS ◦ sol
In the table they are distinguished by gray background color. We also note that the last
three solutions 17, 18, 19 could be ruled out when using a more precise abstract program
interpretation, taking into account that no recursive call is possible when an exception is
thrown.

The sets of abstract solutions provide information on possible sign of values of the
parameters in a call I(a : f loat, s : f loat). For example, solution 1 in Table 1 states that
when called with values of signs [a/0, s/1] the function I will not raise an exceptions nor
make a recursive call. Solution 8 states that when called with values of signs [a/1, s/1]
function I may go into recursion with signs [arec/0, srec/1] without raising an exception.
Any set of abstract solutions deﬁnes an abstract call graph. The abstract call graphs
R(φI) from Table 1 are given in Fig. 7. Solution 1 in Table 1
S(φI) and hS ◦ sol
of sol
implies a solid edge from the node IS(1, 1) to the node IS(0, 1). The edge is solid since
solution 1 is justiﬁed. Edges induced by unjustiﬁed solutions are dashed. The unjustiﬁed
solution 10 for instance induces the dashed edge from IS(1, 1) to IS(1, −1). It should be
noticed that solutions with do_recursion = 0 and raise_exception = 0 do not induce any
edge. Instead, they show that the computation may stop, producing ﬁnal nodes that
are surrounded by a double circle. The ﬁnal nodes are IS(1, 1) and IS(0, 1). Note that
for all non-ﬁnal nodes, either an exception is raised or the computation loops endlessly.
Solutions with raise_exception = 1 induce an edge to the EXCEPT node.

Given that only 2 unjustiﬁed solutions with do_recursion = 0 and raise_exception = 0
(10 and 18), there are only 2 dashed edges in the graph. Furthermore, the edges induced
by the last three solutions 17, 18, 19 are drawn in blue, since these could be removed
with a more precise abstract program interpretation than φI.

The sign analysis without the unjustiﬁed dashed edges yields the following result:
the program in state IS(1, 1), where a > 0 and s > 0 may either terminate, loop
indeﬁnitely, or go to state IS(0, 1) and terminate there immediately. With the unjustiﬁed
dashed edges, however, it wrongly seems possible that the program may also raise an

28 of 33

IS

(-1,-1)

IS

(1,1)

IS

(1,0)

IS

(-1,0)

IS

(-1,1)

IS

(1,-1)

IS

(0,1)

EXCEPT

IS

(0,-1)

IS

(0,0)

Figure 7. Sign call graph of the function I in Fig. 6 created from the sets of abstract solutions
R(φI) while dashed lines
in Table 1. The solid lines correspond to abstract solutions in hS ◦ sol
S(φI). For example, IS(1, −1) represents the
correspond to unjustiﬁed abstract solutions in sol
assignment [a/1, s/ − 1], that is the signs of a and s in calls I(a : f loat, s : f loat) where a > 0 and
s < 0. Light blue edges may be removed by improving φI so that solutions 17, 18, 19 become
impossible. The computation may terminate without raising an exception in the nodes surrounded
by a double circle.

865

866

exception by passing through IS(−1, 1). This overapproximation would be particularly
unfortunate since state IS(1, 1) is the only useful state to call I.

We next show how to remove the unjustiﬁed solutions by applying the overapprox-
mation algorithm for the sign abstraction from Proposition 54, that lifts the algorithm
for exact sign abstraction from Theorem 6 to a richer class of formulas. The idea is to
split the formula φI into its linear part and the rest. Before doing so, we preprocess the
◦= signvar,
inequation s > a: We introduce a fresh variable signvar, add the equation s − a
and rewrite s > a to signvar > 0. The linear part of φI then becomes:

s − a

◦= signvar ∧ arec

◦= a − s ∧ srec

◦= s

We can then rewrite the linear part into the signature Σ
positively onto the other side. This yields the following linear equation system:

bool by moving the negative parts

◦= signvar + a ∧ arec + s

◦= a ∧ srec

◦= s

s

The remainder of φI can be rewritten as follows:

((a < 0 ∧ raise_exception > 0) ∨ (a ≥ 0 ∧ raise_exception
∧((signvar > 0 ∧ do_recursion

◦= 0 ∧ result
(signvar ≤ 0 ∧ do_recursion > 0 ∧ result

◦= 0)∨
◦= s ∗ retf + retI))

◦= 0))

867

868

869

870

871

872

873

874

875

876

It is not clear whether the conjunction of both parts is a hB-mixed system, since it is not
◦= s ∗ retf + retI. Still we can
clear how to show the hB-invariance of the equation result
apply the overapproximation algorithm of the sign abstraction from Proposition 54. It
indeed improves on John’s approximation, ruling out both unjustiﬁed solutions. The
details are worked out in Appendix 11.

In the general case, linear equation systems are not enough, in which case our
algorithm from Theorem 6 for computing sign abstractions cannot be applied. But
then we can still apply the overapproximation algorithm from Proposition 54 which
rewrites a linear part of the formula exactly. As illustrated by the present example, this
overapproximation is often way more precise than John’s.

29 of 33

877

11. Example for the Overapproximation of the Sign Abstraction

We reconsider conjunction of the linear part obtained and the rest of φI, that is

I ∧ φrest
φlin

I where:

φlin
I =def






◦= signvar + a
◦= a

s
∧ arec + s
◦= s
∧ srec





(
∨ (a ≥ 0 ∧ raise_exception

(a < 0 ∧ raise_exception > 0)
◦= 0))

φrest
I =def

∧ (

(signvar > 0 ∧ do_recursion

◦= 0 ∧ result
∨ (signvar ≤ 0 ∧ do_recursion > 0 ∧ result

◦= 0)
◦= s ∗ retf + retI))
I ) for interpretation over B as
deﬁned in Section 9 is obtained by splitting each variable x into two fresh variables
ν⊕(x) and ν(cid:9)(x) representing its positive and negative part:

The decomposition of the linear subsystem decν(φlin

decν(φlin

I ) =






ν⊕(s) + ν(cid:9)(a) + ν(cid:9)(signvar) ◦= ν(cid:9)(s) + ν⊕(a) + ν⊕(signvar)

∧ ν⊕(arec) + ν(cid:9)(a) + ν⊕(s) ◦= ν(cid:9)(arec) + ν⊕(a) + ν(cid:9)(s)
∧ ν⊕(srec) + ν(cid:9)(s) ◦= ν(cid:9)(srec) + ν⊕(s)

The additional constraints on the decomposition variables are:

ν⊕(s) ∗ ν(cid:9)(s) ◦= 0
∧ ν⊕(a) ∗ ν(cid:9)(a) ◦= 0
∧ ν⊕(signvar) ∗ ν(cid:9)(signvar) ◦= 0
∧ ν⊕(arec) ∗ ν(cid:9)(arec) ◦= 0
∧ ν⊕(srec) ∗ ν(cid:9)(srec) ◦= 0
∧ ν⊕(result) ∗ ν(cid:9)(result) ◦= 0
∧ ν⊕(retI) ∗ ν(cid:9)(retI) ◦= 0
∧ ν⊕(retf) ∗ ν(cid:9)(retf) ◦= 0

878

879

The elementary mode rewriting emr(decν(φlin
bool-formula obtained via Corollary 1:

hB-exact Σ

I )) is the following R+-equivalent

∃x0 . . . ∃x10.

∧ ν(cid:9)(a) ◦= x10 + x8 + x9
∧ ν⊕(a) ◦= x10 + x6 + x7
∧ ν(cid:9)(arec) ◦= x4 + x5 + x9
∧ ν⊕(arec) ◦= x3 + x5 + x7
∧ ν(cid:9)(signvar) ◦= x2 + x3 + x7
∧ ν⊕(signvar) ◦= x2 + x4 + x9
∧ ν(cid:9)(s) ◦= x1 + x3 + x8
∧ ν⊕(s) ◦= x1 + x4 + x6
∧ ν(cid:9)(srec) ◦= x0 + x3 + x8
∧ ν⊕(srec) ◦= x0 + x4 + x6

880

881

882

The nonlinear remainder also needs to be rewritten with the decomposition vari-
I ) except that we simpliﬁed

ables for interpretation over B. The formula below is decν(φlin
the rewriting of inequations a bit.

30 of 33

(¬ν(cid:9)(a) ◦= 0 ∧ ¬ν⊕(raise_exception) ◦= 0)

(
∨ (ν(cid:9)(a) ◦= 0 ∧ ν(cid:9)(raise_exception) ◦= 0 ∧ ν⊕(raise_exception) ◦= 0))
(¬ν⊕(signvar) ◦= 0 ∧ ν(cid:9)(do_recursion) ◦= 0 ∧ ν⊕(do_recursion) ◦= 0

∧ (

∧ ν(cid:9)(result) ◦= 0 ∧ ν⊕(result) ◦= 0)
∨ (ν⊕(signvar) ◦= 0 ∧ ¬ν⊕(do_recursion) ◦= 0

∧ ν⊕(result) + ν(cid:9)(s) ∗ ν⊕(retf) + ν⊕(s) ∗ ν(cid:9)(retf) + ν(cid:9)(retI))
◦= ν(cid:9)(result) + ν⊕(s) ∗ ν⊕(retf) + ν(cid:9)(s) ∗ ν(cid:9)(retf) + ν⊕(retI)))

For any solution τ of the conjunction of the above three blocks of formulas over
R(φI) according to

the algebra of booleans B we then obtain an assignment σ ∈ hS ◦ sol
Theorem 6:

τ(ν(cid:9)(s))
τ(ν(cid:9)(a))

σ(s) = τ(ν⊕(s)) −R
σ(a) = τ(ν⊕(a)) −R
σ(signvar) = τ(ν⊕(signvar)) −R
σ(arec) = τ(ν⊕(arec)) −R
σ(srec) = τ(ν⊕(srec)) −R
σ(result) = τ(ν⊕(result)) −R
σ(retf) = τ(ν⊕(retf)) −R
σ(retI) = τ(ν⊕(retI)) −R

τ(ν(cid:9)(arec))
τ(ν(cid:9)(srec))

τ(ν(cid:9)(retf))
τ(ν(cid:9)(retI))

τ(ν(cid:9)(result))

τ(ν(cid:9)(signvar))

883

884

885

886

887

888

889

890

891

892

893

894

895

896

897

898

899

900

901

902

903

904

905

906

907

908

909

910

911

912

913

12. Conclusion and Future Work

We have shown that any hB-mixed system can be rewritten into an hB-exact formula,
by computing the elementary modes of the linear subsystem. In previous work hB-exact
rewriting hB-mixed systems was applied to compute difference abstractions exactly. In
the present paper, we have show that hB-exact rewriting can also be used to compute
sign-abstractions exactly.

We have illustrated the usefulness of the computation of sign abstraction for linear
formulas for the sign analysis of function programs. Using John’s overapproximation is
often not good enough for such applications, since the relationships between the signs
of different variables are quickly lost. We have seen that elementary mode rewriting
yields better a better approximation of the sign abstraction even for nonlinear equation
systems, that may preserve these relationships.

The time for computing abstractions exactly strongly depends on the time needed
to compute the elementary modes. Some experiments were reported in [6] in the case of
the difference abstraction. There, one has to compute the elementary modes for a linear
equation system that contains two copies of the linear equation system given with the
input. The copying doubles the size and may increase the time for the computation of
the elementary modes seriously. In the application of difference abstraction to change
prediction of reaction networks, we observed cases where John’s overapproximation
of the difference abstraction could be computed in circa 10 minutes, while the exact
computation required circa 10 hours.

In the future, it would we of interest to ﬁnd heuristics for approximating abstrac-
tions of linear equation systems that reduce the computation time of the exact algorithm
while improving John’s overapproximation in precision. In the case of difference abstrac-
tions, the minimal support heuristics was proposed for this purpose [6]. In the example
mentioned above, this heuristics could be computed in circa 10 minutes, like John’s
overapproximation, while yielding the exact result. In general, however, the minimal
support heuristics is not exact.

Another interesting question for future work is how to compute more quantitative
abstractions exactly, as for instance with intervals. In this case however the structure of

31 of 33

914

915

abstract values is inﬁnite, therefore ﬁnite domain constraint programming is no longer
sufﬁcient to compute the set of abstract solutions.

916

Appendix A

The system of linear Σ

bool-equations decν(φlin

I ) corresponds to the following linear

integer matrix equation:





−1
0

1 −1

0
0
1 1 −1
0
0 0

1 −1 −1
0
0
0
0

0
1
1 −1
0
1 −1 −1





0
0
1




















ν(cid:9)(a)
ν⊕(a)
ν(cid:9)(arec)
ν⊕(arec)
ν(cid:9)(signvar)
ν⊕(signvar)
ν(cid:9)(s)
ν⊕(s)
ν(cid:9)(srec)
ν⊕(srec)




















◦=







































0
0
0
0
0
0
0
0
0
0

The elementary mode rewriting emr(decν(φlin

I )) corresponds to the linear integer

matrix equation :




















0
0
0
0
0
0
0
0
1
1

0 1
0 1
0 0
0 0
0 0
0 0
1 0
1 0
0 0
0 0

0
0
0
0
1
1
0
0
0
0

0
0
0
1
1
0
1
0
1
0

0
0
1
0
0
1
0
1
0
1

0
0
1
1
0
0
0
0
0
0

0
1
0
0
0
0
0
1
0
1

0
1
0
1
1
0
0
0
0
0

1
0
0
0
0
0
1
0
1
0









































1
0
1
0
0
1
0
0
0
0






















x0
x1
x10
x2
x3
x4
x5
x6
x7
x8
x9

◦=




















ν(cid:9)(a)
ν⊕(a)
ν(cid:9)(arec)
ν⊕(arec)
ν(cid:9)(signvar)
ν⊕(signvar)
ν(cid:9)(s)
ν⊕(s)
ν(cid:9)(srec)
ν⊕(srec)




















917

918

919

920

921

922

923

924

925

926

927

928

929

930

931

932

933

934

935

936

937

938

References

1.

2.

3.

4.

5.

Cousot, P.; Cousot, R. Systematic Design of Program Analysis Frameworks. Conference
Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, San
Antonio, Texas, USA, January 1979; Aho, A.V.; Zilles, S.N.; Rosen, B.K., Eds. ACM Press,
1979, pp. 269–282. doi:10.1145/567752.567778.
Paulevé, L.; Sené, S. Non-Deterministic Updates of Boolean Networks. 27th IFIP WG 1.5
International Workshop on Cellular Automata and Discrete Complex Systems, AUTOMATA
2021, July 12-14, 2021, Aix-Marseille University, France; Castillo-Ramirez, A.; Guillon, P.;
Perrot, K., Eds. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2021, Vol. 90, OASIcs, pp.
10:1–10:16. doi:10.4230/OASIcs.AUTOMATA.2021.10.
Paulevé, L. Most Permissive Reaction Networks. Preprint available at https://loicpauleve.
name/md/ak8WJ5d2TqKpmJBtP_8BaQ#.
Cousot, P.; Halbwachs, N. Automatic Discovery of Linear Restraints Among Variables
of a Program. Conference Record of the Fifth Annual ACM Symposium on Principles
of Programming Languages, Tucson, Arizona, USA, January 1978; Aho, A.V.; Zilles, S.N.;
Szymanski, T.G., Eds. ACM Press, 1978, pp. 84–96. doi:10.1145/512760.512770.
Granger, P. Static Analysis of Linear Congruence Equalities among Variables of a Program.
TAPSOFT’91: Proceedings of the International Joint Conference on Theory and Practice of
Software Development, Brighton, UK, April 8-12, 1991, Volume 1: Colloquium on Trees in
Algebra and Programming (CAAP’91); Abramsky, S.; Maibaum, T.S.E., Eds. Springer, 1991,
Vol. 493, Lecture Notes in Computer Science, pp. 169–192. doi:10.1007/3-540-53982-4\_10.

6.

Allart, E.; Niehren,
Equation Systems.
https://doi.org/10.1016/j.tcs.2021.06.030.

J.; Versari, C.
Theoretical Computer Science 2021.

Computing Difference Abstractions of Linear
Journal extension of [26], doi:

32 of 33

Biosyst. 2016, 149, 113–124.

7. Niehren, J.; Versari, C.; John, M.; Coutte, F.; Jacques, P. Predicting changes of reac-
doi:

tion networks with partial kinetic information.
10.1016/j.biosystems.2016.09.003.
John, M.; Nebut, M.; Niehren, J. Knockout Prediction for Reaction Networks with Partial
Kinetic Information. Veriﬁcation, Model Checking, and Abstract Interpretation, 14th Interna-
tional Conference, VMCAI 2013, Rome, Italy, January 20-22, 2013. Proceedings; Giacobazzi,
R.; Berdine, J.; Mastroeni, I., Eds. Springer, 2013, Vol. 7737, Lecture Notes in Computer Science,
pp. 355–374. doi:10.1007/978-3-642-35873-9\_22.
Giacobazzi, R.; Ranzato, F.; Scozzari, F. Making abstract interpretations complete. J. ACM
2000, 47, 361–416. doi:10.1145/333979.333989.

8.

9.

10. Nethercote, N.; Stuckey, P.J.; Becket, R.; Brand, S.; Duck, G.J.; Tack, G. MiniZinc: Towards a
Standard CP Modelling Language. Principles and Practice of Constraint Programming - CP
2007, 13th International Conference, CP 2007, Providence, RI, USA, September 23-27, 2007,
Proceedings; Bessiere, C., Ed. Springer, 2007, Vol. 4741, Lecture Notes in Computer Science, pp.
529–543. doi:10.1007/978-3-540-74970-7_38.

12.

11. Motzkin, T.; Raiffa, H.; Thompson, G.; Thrall, R. The double description method. Contri-
butions to theory of games; Kuhn, H.; A.W.Tucker., Eds. Princeton University Press, 1953,
Vol. 2.
Fukuda, K.; Prodon, A. Double Description Method Revisited. Combinatorics and Computer
Science, 8th Franco-Japanese and 4th Franco-Chinese Conference, Brest, France, July 3-5,
1995, Selected Papers; Deza, M.; Euler, R.; Manoussakis, Y., Eds. Springer, 1995, Vol. 1120,
Lecture Notes in Computer Science, pp. 91–111. doi:10.1007/3-540-61576-8\_77.

13. Gagneur, J.; Klamt, S. Computation of elementary modes: a unifying framework and the

new binary approach. BMC Bioinform. 2004, 5, 175. doi:10.1186/1471-2105-5-175.

14. Zanghellini, D.; Ruckerbauer, D.E.; Hanscho, M.; Jungreuthmayer, C. Elementary ﬂux
modes in a nutshell: Properties, calculation and applications. Biotechnology Journal 2013,
8(9), 1009–1016. doi:10.1002/biot.201200269.

15. Bagnara, R.; Hill, P.M.; Zaffanella, E. The Parma Polyhedra Library: Toward a complete set
of numerical abstractions for the analysis and veriﬁcation of hardware and software systems.
Sci. Comput. Program. 2008, 72, 3–21. doi:10.1016/j.scico.2007.08.001.
Fukuda, K. cddlib – An efﬁcient implementation of the Double Description Method, 2018.
Available at https://github.com/cddlib/cddlib.

16.

17. Rendl, A.; Guns, T.; Stuckey, P.J.; Tack, G. MiniSearch: A Solver-Independent Meta-Search
Language for MiniZinc. Principles and Practice of Constraint Programming - 21st Inter-
national Conference, CP 2015, Cork, Ireland, August 31 - September 4, 2015, Proceedings;
Pesant, G., Ed. Springer, 2015, Vol. 9255, Lecture Notes in Computer Science, pp. 376–392. doi:
10.1007/978-3-319-23219-5\_27.

18. Allart, E.; Niehren, J.; Versari, C. Reaction Networks to Boolean Networks. Preprint available

at https://hal.archives-ouvertes.fr/hal-02279942.

19. Dines, L.L. On Positive Solutions of a System of Linear Equations. Annals of Mathematics

1926, 28, 386–392.

20. Miné, A. A Few Graph-Based Relational Numerical Abstract Domains. Static Analysis, 9th
International Symposium, SAS 2002, Madrid, Spain, September 17-20, 2002, Proceedings;
Hermenegildo, M.V.; Puebla, G., Eds. Springer, 2002, Vol. 2477, Lecture Notes in Computer
Science, pp. 117–132. doi:10.1007/3-540-45789-5\_11.

21. Cousot, P.; Cousot, R. Static determination of dynamic properties of programs. Proceedings
of the Second International Symposium on Programming. Dunod, Paris, France, 1976, pp.
106–130.

22. Granger, P. Static analysis of arithmetical congruences.

International Journal of Com-
puter Mathematics 1989, 30, 165–190, [https://doi.org/10.1080/00207168908803778]. doi:
10.1080/00207168908803778.

23. Karr, M. Afﬁne relationships among variables of a program. Acta Informatica 1976, 6, 133–151.
FluxAnalyzer: exploring structure,
24. Klamt, S.; Stelling, J.; Ginkel, M.; Gilles, E.D.
pathways, and ﬂux distributions in metabolic networks on interactive ﬂux maps.
Bioinformatics 2003, 19, 261–269,
[https://academic.oup.com/bioinformatics/article-
pdf/19/2/261/1059937/190261.pdf]. doi:10.1093/bioinformatics/19.2.261.

939

940

941

942

943

944

945

946

947

948

949

950

951

952

953

954

955

956

957

958

959

960

961

962

963

964

965

966

967

968

969

970

971

972

973

974

975

976

977

978

979

980

981

982

983

984

985

986

987

988

989

990

991

992

993

994

995

996

997

33 of 33

998

999

1000

1001

1002

1003

1004

25. Avis, D.; Jordan, C. mplrs: A scalable parallel vertex/facet enumeration code. Math. Program.

Comput. 2018, 10, 267–302. doi:10.1007/s12532-017-0129-y.

26. Allart, E.; Versari, C.; Niehren, J. Computing Difference Abstractions of Metabolic Networks
Under Kinetic Constraints. CMSB 2019 - 17th International Conference on Computational
Methods in Systems Biology; Luca Bortolussi and Guido Sanguinetti, Springer: Trieste, Italy,
2019; Vol. 11773, Lecture Notes in Computer Science, pp. 266–285. doi:10.1007/978-3-030-31304-
3\_14.

Conﬂicts of Interest: The authors declare no conﬂict of interest.

