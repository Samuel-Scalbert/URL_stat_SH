Flattening a Hierarchical Clustering through Active
Learning
Fabio Vitale, Anand Rajagopalan, Claudio Gentile

To cite this version:

Fabio Vitale, Anand Rajagopalan, Claudio Gentile. Flattening a Hierarchical Clustering through Ac-
tive Learning. Conference on Neural Information Processing Systems, Dec 2019, Vancouver, Canada.
￿hal-02376981￿

HAL Id: hal-02376981

https://inria.hal.science/hal-02376981

Submitted on 22 Nov 2019

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

9
1
0
2

t
c
O
2
1

]

G
L
.
s
c
[

2
v
8
5
4
9
0
.
6
0
9
1
:
v
i
X
r
a

Flattening a Hierarchical Clustering through Active
Learning

Fabio Vitale
Department of Computer Science
INRIA Lille (France) &
Sapienza University of Rome (Italy)
fabio.vitale@inria.fr

Anand Rajagopalan
Google (New York, USA)
arajagopalan@google.com

Claudio Gentile
Google (New York, USA)
cgentile@google.com

Abstract

We investigate active learning by pairwise similarity over the leaves of trees orig-
inating from hierarchical clustering procedures.
In the realizable setting, we
provide a full characterization of the number of queries needed to achieve perfect
reconstruction of the tree cut. In the non-realizable setting, we rely on known
important-sampling procedures to obtain regret and query complexity bounds. Our
algorithms come with theoretical guarantees on the statistical error and, more
importantly, lend themselves to linear-time implementations in the relevant pa-
rameters of the problem. We discuss such implementations, prove running time
guarantees for them, and present preliminary experiments on real-world datasets
showing the compelling practical performance of our algorithms as compared to
both passive learning and simple active learning baselines.

Introduction

1
Active learning is a learning scenario where labeled data are scarse and/or expensive to gather, as they
require careful assessment by human labelers. This is often the case in several practical settings where
machine learning is routinely deployed, from image annotation to document classiﬁcation, from
speech recognition to spam detection, and beyond. In all such cases, an active learning algorithm
tries to limit human intervention by seeking as little supervision as possible, still obtaining accurate
prediction on unseen samples. This is an attractive learning framework offering substantial practical
beneﬁts, but also presenting statistical and algorithmic challenges.
A main argument that makes active learning effective is when combined with methods that exploit
the cluster structure of data (e.g., [11, 20, 10], and references therein), where a cluster typically
encodes some notion of semantic similarity across the involved data points. An obiquitous solution to
clustering is to organize data into a hierarchy, delivering clustering solutions at different levels of
resolution. An (agglomerative) Hierarchical Clustering (HC) procedure is an unsupervised learning
method parametrized by a similarity function over the items to be clustered and a linkage function
that lifts similarity from items to clusters of items. Finding the “right” level of resolution amounts to
turning a given HC into a ﬂat clustering by cutting the resulting tree appropriately. We would like
to do so by resorting to human feedback in the form of pairwise similarity queries, that is, yes/no
questions of the form “are these two products similar to one another ?” or “are these two news items
covering similar events ?”. It is well known that such queries are relatively easy to respond to, but are
also intrinsically prone to subjectiveness and/or noise. More importantly, the hierarchy at hand need
not be aligned with the similarity feedback we actually receive.
In this paper, we investigate the problem of cutting a tree originating from a pre-speciﬁed HC
procedure through pairwise similarity queries generated by active learning algorithms. Since the

 
 
 
 
 
 
tree is typically not consistent with the similarity feedback, that is to say, the feedback is noisy, we
are lead to tackle this problem under a variety of assumptions about the nature of this noise (from
noiseless to random but persistent to general agnostic). Moreover, because different linkage functions
applied to the very same set of items may give rise to widely different tree topologies, our study also
focuses on characterizing active learning performance as a function of the structure of the tree at
hand. Finally, because these hierarchies may in practice be sizeable (in the order of billion nodes),
scalability will be a major concern in our investigation.
Our contribution. In the realizable setting (both noiseless and persistent noisy, Section 3), we
introduce algorithms whose expected number of queries scale with the average complexity of tree
cuts, a notion which is introduced in this paper. A distinctive feature of these algorithms is that they
are rather ad hoc in the way they deal with the structure of our problem. In particular, they cannot
be seen as ﬁnding the query that splits the version space as evenly as possible, a common approach
in many active learning papers (e.g., [12, 24, 14, 15, 26, 23], and references therein). We then show
that, at least in the noiseless case, this average complexity measure characterizes the expected query
complexity of the problem. Our ad hoc analyses are beneﬁcial in that they deliver sharper guarantees
than those readily available from the above papers. In addition, and perhaps more importantly for
practical usage, our algorithms admit linear-time implementations in the relevant parameters of the
problem (like the number of items to be clustered). In the non-realizable setting (Section 4), we
build on known results in importance-weighted active learning (e.g., [5, 6]) to devise a selective
sampling algorithm working under more general conditions. While our statistical analysis follows
by adaptating available results, our goal here is to rather come up with fast implementations, so as
to put the resulting algorithms on the same computational footing as those operating under (noisy)
realizability assumptions. By leveraging the speciﬁc structure of our hypothesis space, we design
a fast incremental algorithm for selective sampling whose running time per round is linear in the
height of the tree. In turn, this effort paves the way for our experimental investigation (Section
5), where we compare the effectiveness of the two above-mentioned approaches (realizable with
persistent noise vs non-realizable) on real data originating from various linkage functions. Though
quite preliminary in nature, these experiments seem to suggest that the algorithms originating from
the persistent noise assumption exhibit more attractive learning curves than those working in the
more general non-realizable setting.
Related work. The literature on active learning is vast, and we can hardly do it justice here. In
what follows we conﬁne ourselves to the references which we believe are closest to our paper. Since
our sample space is discrete (the set of all possible pairs of items from a ﬁnite set of size n), our
realizable setting is essentially a pool-based active learning setting. Several papers have considered
greedy algorithms which generalize binary search [1, 19, 12, 24, 14, 23]. The query complexity can
be measured either in the worst case or averaged over a prior distribution over all possible labeling
functions in a given set. The query complexity of these algorithms can be analyzed by comparing it
to the best possible query complexity achieved for that set of items. In [12] it is shown that if the
probability mass of the version space is split as evenly as possible then the approximation factor
for its average query complexity is O(log(1/pm)), where pm is the minimal prior probability of
any considered labeling function. [14] extended this result through a more general approach to
approximate greedy rules, but with the worse factor O(log2(1/pm)). [19] observed that modifying
the prior distribution always allows one to replace O(log(1/pm)) by the smaller factor O(log N ),
where N is the size of the set of labeling functions. Results of a similar ﬂavor are contained in
[24, 23]. In our case, N can be exponential in n (see Section 2), making these landmark results too
broad to be tight for our speciﬁc setting. Furthermore, some of these papers (e.g., [12, 24, 23]) have
only theoretical interest because of their difﬁcult algorithmic implementation. Interesting advances
on this front are contained in the more recent paper [26], though when adapted to our speciﬁc setting,
their results give rise to worse query bounds than ours. In the same vein are the papers by [7, 8],
dealing with persistent noise. Finally, in the non-realizable setting, our work fully relies on [6], which
in turns builds on standard references like [9, 5, 16] – see, e.g., the comprehensive survey by [17].
Further references speciﬁcally related to clustering with queries are mentioned in Appendix A.

2 Preliminaries and learning models
We consider the problem of ﬁnding cuts of a given binary tree through pairwise similarity queries
over its leaves. We are given in input a binary1 tree T originating from, say, an agglomerative

1 In fact, the trees we can handle are more general than binary: we are making the binary assumption

throughout for presentational convenience only.

2

Figure 1: Left: A binary tree corre-
sponding to a hierarchical clustering of
the set of items L = {x1, . . . , x8}. The
cut depicted in dashed green has two
nodes above and the rest below. This cut
induces over L the ﬂat clustering C1 =
{{x1, x2, x3, x4, x5}, {x6}, {x7, x8}}
corresponding to the leaves of
the
subtrees rooted at the 3 green-bordered
nodes just below the cut (the lower
boundary of the cut). Clustering C1 is
therefore realized by T . On the contrary,
clustering C2 = {{x1, x2, x3}, {x4, x5, x6}, {x7, x8}} is not. Close to each node i is also displayed the
number N (i) of realized cuts by the subtree rooted at i. For instance, in this ﬁgure, 7 = 1 + 3 · 2, and
22 = 1 + 7 · 3, so that T admits overall N (T ) = 22 cuts. Right: The same ﬁgure, where below each node i are
the probabilities P(i) encoding a uniform prior distribution over cuts. Notice that P(i) = 1/N (i) so that, like
all other cuts, the depicted green cut has probability (1 − 1/22) · (1 − 1/3) · (1/7) · 1 · (1/2) = 1/22.

(i.e., bottom-up) HC procedure (single linkage, complete linkage, etc.) applied to a set of items
L = {x1, . . . , xn}. Since T is the result of successive (binary) merging operations from bottom to
top, T turns out to be a strongly binary tree2 and the items in L are the leaves of T . We will denote
by V the set of nodes in T , including its leaves L, and by r the root of T . The height of T will be
denoted by h. When referring to a subtree T (cid:48) of T , we will use the notation V (T (cid:48)), L(T (cid:48)), r(T (cid:48)),
and h(T (cid:48)), respectively. We also denote by T (i) the subtree of T rooted at node i, and by L(i) the set
of leaves of T (i), so that L(i) = L(T (i)), and r(T (i)) = i. Moreover, par(i) will denote the parent
of node i (in tree T ), left(i) will be the left-child of i, and right(i) its right child.
A ﬂat clustering C of L is a partition of L into disjoint (and non-empty) subsets. A cut c of T of size
K is a set of K edges of T that partitions V into two disjoint subsets; we call them the nodes above c
and the nodes below c. Cut c also univocally induces a clustering over L, made up of the clusters
L(i1), L(i2), . . . , L(iK), where i1, i2, . . . , iK are the nodes below c that the edges of c are incident
to. We denote this clustering by C(c), and call the nodes i1, i2, . . . , iK the lower boundary of c. We
say that clustering C0 is realized by T if there exists a cut c of T such that C(c) = C0. See Figure 1
(left) for a pictorial illustration. Clearly enough, for a given L, and a given tree T with set of leaves
L, not all possible clusterings over L are realized by T , as the number and shape of the clusterings
realized by T are strongly inﬂuenced by T ’s structure. Let N (T ) be the number of clusterings
realized by T (notice that this is also equal to the number of distinct cuts admitted by T ). Then N (T )
can be computed through a simple recursive formula. If we let N (i) be the number of cuts realized
by T (i), one can easily verify that N (i) = 1 + N (left(i)) · N (right(i)), with N (xi) = 1 for all
xi ∈ L. With this notation, we then have N (T ) = N (r(T )). If T has n leaves, N (T ) ranges from
n, when T is a degenerate line tree, to the exponential (cid:98)αn(cid:99), when T is the full binary tree, where
α (cid:39) 1.502 (e.g., http://oeis.org/A003095). See again Figure 1 (left) for a simple example.
A ground-truth matrix Σ is an n × n and ±1-valued symmetric matrix Σ = [σ(xi, xj)]n×n
i,j=1 encoding
a pairwise similarity relation over L. Speciﬁcally, if σ(xi, xj) = 1 we say that xi and xj are similar,
while if σ(xi, xj) = −1 we say they are dissimilar. Moreover, we always have σ(xi, xi) = 1 for all
xi ∈ L. Notice that Σ need not be consistent with a given clustering over L, i.e., the binary relation
deﬁned by Σ over L need not be transitive.
Given T and its leaves L, an active learning algorithm A proceeds in a sequence of rounds. In a purely
active setting, at round t, the algorithm queries a pair of items (xit, xjt), and observes the associated
label σ(xit, xjt). In a selective sampling setting, at round t, the algorithm is presented with (xit, xjt)
drawn from some distribution over L × L, and has to decide whether or not to query the associated
label σ(xit, xjt). In both cases, the algorithm is stopped at some point, and is compelled to commit
to a speciﬁc cut of T (inducing a ﬂat clustering over L). Coarsely speaking, the goal of A is to come
up with a good cut of T , by making as few queries as possible on the entries of Σ.
Noise Models. The simplest possible setting, called noiseless realizable setting, is when Σ itself
is consistent with a given clustering realized by T , i.e., when there exists a cut c∗ of T such that
C(c∗) = {L(i1), . . . , L(iK)}, for some nodes i1, . . . , iK ∈ V , that satisﬁes the following: For all
r = 1, . . . , K, and for all pairs (xi, xj) ∈ L(ir) × L(ir) we have σ(xi, xj) = 1, while for all

2 A strongly binary tree is a rooted binary tree for which the root is adjacent to either zero or two nodes, and

all non-root nodes are adjacent to either one or three nodes.

3

5x4x6x1/71/21/2211111/31/211/311/217x2x8x1x12x3x4x5x6x7x8x1x2x3x4x5x6x7x8x1x3xC  r 12C T 5x4x6x7222111132131217x2x8x1x13xr T 2

2

other pairs we have σ(xi, xj) = −1. We call (persistent) noisy realizable setting one where Σ is
generated as follows. Start off from the noiseless ground-truth matrix, and call it Σ∗. Then, in
order to obtain Σ from Σ∗, consider the set of all (cid:0)n
(cid:1) pairs (xi, xj) with i < j, and pick uniformly
at random a subset of size (cid:98)λ (cid:0)n
(cid:1)(cid:99), for some λ ∈ [0, 1/2). Each such pair has ﬂipped label in Σ:
σ(xi, xj) = 1 − σ∗(xi, xj). This is then combined with the symmetric σ(xi, xj) = σ(xj, xi), and
the reﬂexive σ(xi, xi) = 1 conditions. We call λ the noise level. Notice that this kind of noise is
random but persistent, in that if we query the same pair (xi, xj) twice we do obtain the same answer
σ(xi, xj). Clearly, the special case λ = 0 corresponds to the noiseless setting. Finally, in the general
non-realizable (or agnostic) setting, Σ is an arbitrary matrix that need not be consistent with any
clustering over L, in particular, with any clustering over L realized by T .
Error Measure. If Σ is some ground-truth matrix over L, and (cid:98)c is the cut output by A, with
(cid:98)C(xi, xj)]n×n
induced clustering (cid:98)C = C((cid:98)c), we let Σ
i,j=1 be the similarity matrix associated
with (cid:98)C, i.e., σ
(cid:98)C(xi, xj) = 1 if xi and xj belong to the same cluster, and −1 otherwise. Then the
Hamming distance dH (Σ, (cid:98)C) simply counts the number of pairs (xi, xj) having inconsistent sign:
dH (Σ, (cid:98)C) = (cid:12)
(cid:98)C(xi, xj)}(cid:12)
(cid:12) . The same deﬁnition applies in particular
to the case when Σ itself represents a clustering over L. The quantity dH , sometimes called correlation
clustering distance, is closely related to the Rand index [25] – see, e.g., [22].
Prior distribution. Recall cut c∗ deﬁned in the noiseless realizable setting and its associated Σ∗.
Depending on the speciﬁc learning model we consider (see below), the algorithm may have access
to a prior distribution P(·) over c∗, parametrized as follows. For i ∈ V , let P(i) be the conditional
probability that i is below c∗ given that all i’s ancestors are above. If we denote by AB(c∗) ⊆ V the
nodes of T which are above c∗, and by LB(c∗) ⊆ V those on the lower boundary of c∗, we can write
(1 − P(i))

(cid:12){(xi, xj) ∈ L2 : σ(xi, xj) (cid:54)= σ

(cid:98)C = [σ

P(c∗) =

(cid:16) (cid:89)

(cid:16) (cid:89)

P(j)

(cid:17)
·

(cid:17)

(1)

,

i∈AB(c∗)

j∈LB(c∗)

where P(i) = 1 if i ∈ L. In particular, setting P(i) = 1/N (i) ∀i yields the uniform prior P(c∗) =
1/N (T ) for all c∗ realized by T . See Figure 1 (right) for an illustration. A canonical example of a
non-uniform prior is one that favors cuts close to the root, which are thereby inducing clusterings
having few clusters. These can be obtained, e.g., by setting P(i) = α, for some constant α ∈ (0, 1).
Learning models. We consider two learning settings. The ﬁrst setting (Section 3) is an active
learning setting under a noisy realizability assumption with prior information. Let C∗ = C(c∗) be
the ground truth clustering induced by cut c∗ before noise is added. Here, for a given prior P(c∗),
the goal of learning is to identify C∗ either exactly (when λ = 0) or approximately (when λ > 0),
while bounding the expected number of queries (xit, xjt) made to the ground-truth matrix Σ, the
expectation being over the noise, and possibly over P(c∗). In particular, if (cid:98)C is the clustering produced
by the algorithm after it stops, we would like to prove upper bounds on E[dH (Σ∗, (cid:98)C)], as related to
the number of active learning rounds, as well as to the properties of the prior distribution. The second
setting (Section 4) is a selective sampling setting where the pairs (xit, xjt) are drawn i.i.d. according
to an arbitrary and unknown distribution D over the n2 entries of Σ, and the algorithm at every round
can choose whether or not to query the label. After a given number of rounds the algorithm is stopped,
and the goal is the typical goal of agnostic learning: no prior distribution over cuts is available
anymore, and we would like to bound with high probability over the sample (xi1 , xj1), (xi2, xj2 ), . . .
the so-called excess risk of the clustering (cid:98)C produced by A, i.e., the difference

P(xi,xj )∼D

(cid:0)σ(xi, xj) (cid:54)= σ

(cid:98)C(xi, xj)(cid:1) − min

c

P(xi,xj )∼D

(cid:0)σ(xi, xj) (cid:54)= σC(c)(xi, xj)(cid:1) ,

(2)

the minimum being over all possible cuts c realized by T . Notice that when D is uniform the excess
risk reduces to 1
. At the same time, we would like to bound with
dH (Σ, (cid:98)C) − minc dH (Σ, C(c))
n2
high probability the total number of labels the algorithm has queried.

(cid:17)

(cid:16)

3 Active learning in the realizable case
As a warm up, we start by considering the case where λ = 0 (no noise). The underlying cut c∗ can
be conveniently described by assigning to each node i of T a binary value y(i) = 0 if i is above c∗,
and y(i) = 1 if i is below. Then we can think of an active learning algorithm as querying nodes,
instead of querying pairs of leaves. A query to node i ∈ V can be implemented by querying any
pair (xi(cid:96), xir ) ∈ L(left(i)) × L(right(i)). When doing so, we actually receive y(i), since for any

4

Figure 2: Left: The dotted green cut c∗
can be described by the set of values of
{y(i), i ∈ V }, below each node. In this
tree, in order to query, say, node i2, it suf-
ﬁces to query any of the four pairs (x1, x3),
(x1, x4), (x2, x3), or (x2, x4). The base-
line queries i1 through i6 in a breadth-ﬁrst
manner, and then stops having identiﬁed c∗.

Right: This graph has N (T ) = n. On the depicted cut, the baseline has to query all n − 1 internal nodes.

such (xi(cid:96), xir ), we clearly have y(i) = σ∗(xi(cid:96), xir ). An obvious baseline is then to perform a kind
of breadth-ﬁrst search in the tree: We start by querying the root r, and observe y(r); if y(r) = 1 we
stop and output clustering (cid:98)C = {L}; otherwise, we go down by querying both left(r) and right(r),
and then proceed recursively. It is not hard to show that this simple algorithm will make at most
2K − 1 queries, with an overall running time of O(K), where K is the number of clusters of C(c∗).
See Figure 2 for an illustration. If we know beforehand that K is very small, then this baseline is a
tough competitor. Yet, this is not the best we can do in general. Consider, for instance, the line graph
in Figure 2 (right), where c∗ has K = n.
Ideally, for a given prior P(·), we would like to obtain a query complexity of the form log(1/P(c∗)),
holding in the worst-case for all underlying c∗. As we shall see momentarily, this is easily obtained
when P(·) is uniform. We ﬁrst describe a version space algorithm (One Third Splitting, OTS) that
admits a fast implementation, and whose number of queries in the worst-case is O(log N (T )). This
will in turn pave the way for our second algorithm, Weighted Dichotomic Path (WDP). WDP leverages
P(·), but its theoretical guarantees only hold in expectation over P(c∗). WDP will then be extended to
the persistent noisy setting through its variant Noisy Weighted Dichotomic Path (N-WDP).
We need a few ancillary deﬁnitions. First of all note that, in the noiseless setting, we have a clear
hierarchical structure on the labels y(i) of the internal nodes of T : Whenever a query reveals a label
y(i) = 0, we know that all i’s ancestors will have label 0. On the other hand, if we observe y(i) = 1
we know that all internal nodes of subtree T (i) have label 1. Hence, disclosing the label of some
node indirectly entails disclosing the labels of either its ancestors or its descendants. Given T , a
bottom-up path is any path connecting a node with one of its ancestors in T . In particular, we call
a backbone path any bottom up path having maximal length. Given i ∈ V , we denote by St(i) the
version space at time t associated with T (i), i.e., the set of all cuts of T (i) that are consistent with
the labels revealed so far. For any node j (cid:54)= i, St(i) splits into Sy(j)=0
(i), the subsets
of St(i) obtained by imposing a further constraint on y(j).
OTS (One Third Splitting): For all i ∈ V , OTS maintains over time the value |St(i)|, i.e., the size
of St(i), along with the forest F made up of all maximal subtrees T (cid:48) of T such that |V (T (cid:48))| > 1 and
for which none of their node labels have been revealed so far. OTS initializes F to contain T only,
and maintains F updated over time, by picking any backbone of any subtree T (cid:48) ∈ F , and visiting it
in a bottom-up manner. See the details in Appendix B.1. The following theorem (proof in Appendix
B.1) crucially relies on the fact that π is a backbone path of T (cid:48), rather than an arbitrary path.
Theorem 1 On a tree T with n leaves, height h, and number of cuts N , OTS ﬁnds c∗ by making
O(log N ) queries. Moreover, an ad hoc data-structure exists that makes the overall running time
O(n + h log N ) and the space complexity O(n).
Hence, Theorem 1 ensures that, for all c∗, a time-efﬁcient active learning algorithm exists whose
number of queries is of the form log(1/P(c∗)), provided P(c∗) = 1/N (T ) for all c∗. This query
bound is fully in line with well-known results on splittable version spaces [12, 24, 23], so we cannot
make claims of originality. Yet, what is relevant here is that this splitting can be done very efﬁciently.
We complement the above result with a lower bound holding in expectation over prior distributions
on c∗. This lower bound depends in a detailed way on the structure of T . Given tree T , with set of
leaves L, and cut c∗, recall the deﬁnitions of AB(c∗) and LB(c∗) we gave in Section 2. Let T (cid:48)
c∗ be
the subtree of T whose nodes are (AB(c∗) ∪ LB(c∗)) \ L, and then let (cid:101)K(T, c∗) = |L(T (cid:48)
c∗ )| be
the number of its leaves. For instance, in Figure 2 (left), T (cid:48)
c∗ is made up of the six nodes i1, . . . , i6,
so that (cid:101)K(T, c∗) = 3, while in Figure 2 (right), T (cid:48)
c∗ has nodes i1, . . . , in−1, hence (cid:101)K(T, c∗) = 1.
Notice that we always have (cid:101)K(T, c∗) ≤ K, but for many trees T , (cid:101)K(T, c∗) may be much smaller
than K. A striking example is again provided by the cut in Figure 2 (right), where (cid:101)K(T, c∗) = 1,
but K = n. It is also helpful to introduce Ls(T ), the set of all pairs of sibling leaves in T . For
instance, in the tree of Figure 2, we have |Ls(T )| = 3. One can easily verify that, for all T we have

(i) and Sy(j)=1

t

t

5

x1 T 4x3x5x010111101116x2x2x1T xxx 1n11110001n-17x1i2i5i6i4in-1i1i3i2imaxc∗ (cid:101)K(T, c∗) = |Ls(T )| ≤ log2 N (T ) . We now show that there always exist families of prior
distributions P(·) such that the expected number of queries needed to ﬁnd c∗ is Ω(E[ (cid:101)K(T, c∗)]). The
quantity E[ (cid:101)K(T, c∗)] is our notion of average (query) complexity. Since the lower bound holds in
expectation, it also holds in the worst case. The proof can be found in Appendix B.2.

Theorem 2 In the noiseless realizable setting, for any tree T , any positive integer B ≤ |Ls(T )|, and
any (possibly randomized) active learning algorithm A, there exists a prior distribution P(·) over
c∗ such that the expected (over P(·) and A’s internal randomization) number of queries A has to
make in order to recover c∗ is lower bounded by B/2, while B ≤ E[ (cid:101)K(T, c∗)] ≤ 2B, the latter
expectation being over P(·).

Next, we describe an algorithm that, unlike OTS, is indeed able to take advantage of the prior
distribution, but it does so at the price of bounding the number of queries only in expectation.
WDP (Weighted Dichotomic Path): Recall prior distibution (1), collectively encoded through the
values {P(i), i ∈ V }. As for OTS, we denote by F the forest made up of all maximal subtrees T (cid:48)
of T such that |V (T (cid:48))| > 1 and for which none of their node labels have so far been revealed. F is
updated over time, and initially contains only T . We denote by π(u, v) a bottom-up path in T having
as terminal nodes u and v (hence v is an ancestor of u in T ). For a given cut c∗, and associated labels
{y(i), i ∈ V }, any tree T (cid:48) ∈ F , and any node i ∈ V (T (cid:48)), we deﬁne3
(cid:89)

q(i) = P(y(i) = 1 ∧ y(par(i)) = 0) = P(i) ·

(1 − P(j)) .

(3)

j∈π(par(i),r(T (cid:48)))

We then associate with any backbone path of the form π((cid:96), r(T (cid:48))), where (cid:96) ∈ L(T (cid:48)), an en-
tropy H(π((cid:96), r(T (cid:48)))) = − (cid:80)
i∈π((cid:96),r(T (cid:48))) q(i) log2 q(i). Notice that at the beginning we have
(cid:80)
i∈π((cid:96),r(T )) q(i) = 1 for all (cid:96) ∈ L. This invariant will be maintained on all subtrees T (cid:48). The
prior probabilities P(i) will evolve during the algorithm’s functioning into posterior probabilities
based on the information revealed by the labels. Accordingly, also the related values q(i) w.r.t. which
the entropy H(·) is calculated will change over time.
Due to space limitations, WDP’s pseudocode is given in Appendix B.3, but we have included an
example of its execution in Figure 3. At each round, WDP ﬁnds the path whose entropy is maximized
over all bottom-up paths π((cid:96), r(cid:48)), with (cid:96) ∈ L and r(cid:48) = r(T (cid:48)), where T (cid:48) is the subtree in F containing
(cid:96). WDP performs a binary search on such π((cid:96), r(cid:48)) to ﬁnd the edge of T (cid:48) which is cut by c∗, taking
into account the current values of q(i) over that path. Once a binary search terminates, WDP updates
F and the probabilities P(i) at all nodes i in the subtrees of F . See Figure 3 for an example. Notice
that the P(i) on the selected path become either 0 (if above the edge cut by c∗) or 1 (if below). In
turn, this causes updates on all probabilities q(i). WDP continues with the next binary search on the
next path with maximum entropy at the current stage, discovering another edge cut by c∗, and so on,
until F becomes empty. Denote by P>0 the set of all priors P(·) such that for all cuts c of T we have
P(c) > 0. The proof of the following theorem is given in Appendix B.3.

Theorem 3 In the noiseless realizable setting, for any tree T of height h, any prior distribution
P(·) over c∗, such that P(·) ∈ P>0, the expected number of queries made by WDP to ﬁnd c∗ is
O

, the expectations being over P(·).

(cid:105)
(cid:104)
(cid:101)K(T, c∗)

log h

E

(cid:16)

(cid:17)

For instance, in the line graph of Figure 2 (right), the expected number of queries is O(log n) for
any prior P(·), while if T is a complete binary tree with n leaves, and we know that C(c∗) has O(K)
clusters, we can set P(i) in (1) as P(i) = 1/ log K, which would guarantee E[ (cid:101)K(T, c∗)] = O(K),
and a bound on the expected number of queries of the form O(K log log n). By comparison, observe
that the results in [12, 14, 26] would give a query complexity which is at best O(K log2 n), while
those in [24, 23] yield at best O(K log n). In addition, we show below (Remark 1) that our algorithm
has very compelling running time guarantees.
It is often the case that a linkage function generating T also tags each internal node i with a coherence
level αi of T (i), which is typically increasing as we move downwards from root to leaves. A common
situation in hierarchical clustering is then to ﬁgure out the “right” level of granularity of the ﬂat
clustering we search for by deﬁning parallel bands of nodes of similar coherence where c∗ is possibly

3 For deﬁniteness, we set y(par(r)) = 0, that is, we are treating the parent of r(T ) as a “dummy super–root”

with labeled 0 since time t = 0. Thus, according to this deﬁnition, q(r) = P(r).

6

Figure 3: An example of input tree T
before (left) and after (right) the ﬁrst
binary search of WDP. The green node
is a dummy super-root. The nodes in
yellow are the roots of the subtrees cur-
rently included in forest F . The num-
bers in red within each node i indicate
the probabilities P(i), while the q(i)
values are in blue, and viewed here as
associated with edges (par(i), i). The
magenta numbers at each leaf (cid:96) give the entropy H(π((cid:96), r(T (cid:48)))), where r(T (cid:48)) is the root of the subtree in F
that contains both (cid:96) and r(T (cid:48)). Left: The input tree T at time t = 0. No labels are revealed, and no clusters of
C(c∗) are found. Right: Tree T after a full binary search has been performed on the depicted light blue path.
Before this binary search, that path connected a leaf of a subtree in F to its root (in this case, F contains only
T ). The selected path is the one maximazing entropy within the forest/tree on the left. The dashed line indicates
the edge of c∗ found by the binary search. The red, blue and magenta numbers are updated accordingly to the
result of the binary search. The leaves enclosed in the grey ellipse are now known to form a cluster of C(c∗).

located. For such cases, a slightly more involved guarantee for WDP is contained in Theorem 6 in
Appendix B.3, where the query complexity depends in a more detailed way on the interplay between
T and the prior P(·). In the above example, if we have b-many edge-disjoint bands, Theorem 6
replaces factor log h of Theorem 3 by log b.
N-WDP (Noisy Weighted Dichotomic Path): This is a robust variant of WDP that copes with
persistent noise. Whenever a label y(i) is requested, N-WDP determines its value by a majority vote
over randomly selected pairs from L(left(i)) × L(right(i)). Due to space limitations, all details are
contained in Appendix B.4. The next theorem quantiﬁes N-WDP’s performance in terms of a tradeoff
between the expected number of queries and the distance to the noiseless ground-truth matrix Σ∗.
Theorem 4 In the noisy realizable setting, given any input tree T of height h, any cut c∗ ∼ P(·) ∈
P>0, and any δ ∈ (0, 1/2), N-WDP outputs with probability ≥ 1 − δ (over the noise in the labels) a
(cid:17)
(cid:16) log(n/δ)
(1−2λ)2 E (cid:101)K(T, c∗) log h
clustering (cid:98)C such that 1
queries in expectation (over P(·)).
Remark 1 Compared to the query bound in Theorem 3, the one in Theorem 4 adds a factor due to
noise. The very same extra factor is contained in the bound of [21]. Regarding the running time of
WDP , the version we have described can be naively implemented to run in O(n E (cid:101)K(T, c∗)) expected
time overall. A more time-efﬁcient variant of WDP exists for which Theorem 3 and Theorem 6 still
hold, that requires O(n + h E (cid:101)K(T, c∗)) expected time. Likewise, an efﬁcient variant of N-WDP exists
for which Theorem 4 holds, that takes O

n2 dH (Σ∗, (cid:98)C) = O

(log(n/δ))3/2
(1−2λ)3

expected time.

by asking O

(cid:17)
E (cid:101)K(T, c∗)

h + log2 n
(1−2λ)2

(cid:16) 1
n

n +

(cid:17)

(cid:17)

(cid:16)

(cid:16)

4 Selective sampling in the non-realizable case
In the non-realizable case, we adapt to our clustering scenario the importance-weighted algorithm in
[6]. The algorithm is a selective sampler that proceeds in a sequence of rounds t = 1, 2, . . .. In round
t a pair (xit, xjt) is drawn at random from distribution D over the entries of a given ground truth
matrix Σ, and the algorithm produces in response a probability value pt = pt(xit, xjt). A Bernoulli
variable Qt ∈ {0, 1} is then generated with P(Qt = 1) = pt, and if Qt = 1 the label σt = σ(xit, xjt)
is queried, and the algorithm updates its internal state; otherwise, we skip to the next round. The
way pt is generated is described as follows. Given tree T , the algorithm maintains at each round t an
importance-weighted empirical risk minimizer cut ˆct, deﬁned as ˆct = argminc errt−1(C(c)) , where
the “argmin” is over all cuts c realized by T , and errt−1(C) = 1
{σC(xis, xjs ) (cid:54)=
t−1
σs} , being {·} the indicator function of the predicate at argument. This is paired up with a
perturbed empirical risk minimizer ˆc(cid:48)
t = argminc : σC(c)(xit ,xjt )(cid:54)=σC(ˆct)(xit ,xjt ) errt−1(C(c)) , the
“argmin” being over all cuts c realized by T that disagree with ˆct on the current pair (xit, xjt). The
value of pt is a function of dt = errt−1(C(ˆc(cid:48)
pt = min (cid:8)1, O (cid:0)1/d2

t)) − errt−1(C(ˆct)), of the form
t + 1/dt

(cid:1) log((N (T )/δ) log t)/t(cid:9) ,

(cid:80)t−1
s=1

Qs
ps

(4)

where N (T ) is the total number of cuts realized by T (i.e., the size of our comparison class), and δ is
the desired conﬁdence parameter. Once stopped, say in round t0, the algorithm gives in output cut
ˆct0+1, and the associated clustering C(ˆct0+1). Let us call the resulting algorithm NR (Non-Realizable).

7

0.50.9110.3110.250.111(1-0.25)*0.5=0.375(1-0.25)*(1-0.5)*0.9=0.3375(1-0.25)*(1-0.5)*(1-0.9)*1=0.03750.03750.11250.0750.6750.6750.26250.2625«0»0.250.0375*log_2(1/0.0375)+0.3375*log_2(1/0.3375)+0.375*log_2(1/0.375)+0.25*log_2(1/0.25)=1.737…1.737…1.891…1.891…1.163…1.163…00.91111100.11100.9(1-0.9)*1=0.10.110.10.90.900«0»00.1*log_2(1/0.1)+0.9*log_2(1/0.9)=0.468…0.468…0.468…0.468…Tree
SING
MED
COMP

BEST’s K
4679
1603
557

Avg depth
2950
186.4
17.1

BEST’s error
8.26%
8,51%
8.81%

Std. dev
1413.6
41.8
3.3
Table 1: Statistics of the trees used in our experiments. These trees result from applying the linkage functions
SING, COMP, and MED to the MNIST dataset (ﬁrst 10000 samples). Each tree has the same set of n = 10000
leaves. “Avg depth” is the average depth of the leaves in the tree, “Std. dev” is its standard deviation. For
reference, we report the performance of BEST (i.e., the minimizer of dH over all possible cuts realized by the
trees), along with the associated number of clusters K.
Despite N (T ) can be exponential in n, there are very efﬁcient ways of computing ˆct, ˆc(cid:48)
t, and
hence pt at each round. In particular, an ad hoc procedure exists that incrementally computes these
quantities by leveraging the sequential nature of NR. For a given T , and constant K ≥ 1, consider
the class C(T, K) of cuts inducing clusterings with at most K clusters. Set R∗ = R∗(T, D) =
(cid:0)σ(xi, xj) (cid:54)= σC(c)(xi, xj)(cid:1), and Bδ(K, n) = K log n + log(1/δ). The
minc∈C(T,K) P(xi,xj )∼D
following theorem is an adaptation of a result in [6]. See Appendix C.1 for a proof.

Theorem 5 Let T have n leaves and height h. Given conﬁdence parameter δ, for any t ≥ 1, with
probability at least 1 − δ, the excess risk (2) achieved by the clustering C(ˆct+1) computed by NR w.r.t.
the best cut in class C(T, K) is bounded by O

(cid:18)(cid:113) Bδ(K,n) log t

, while the (expected)

(cid:19)

+ Bδ(K,n) log t
t

t

s=1 ps is bounded by O

number of labels (cid:80)t
,
θ
where θ = θ(C(T, K), D) is the disagreement coefﬁcient of C(T, K) w.r.t. distribution D. In
particular, when D is uniform we have θ ≤ K. Moreover, there exists a fast implementation of NR
whose expected running time per round is E(xi,xj )∼D[de(lca(xi, xj))] ≤ h, where de(lca(xi, xj)) is
the depth in T of the lowest common ancestor of xi and xj.

R∗t + (cid:112)t Bδ(K, n) log t + Bδ(K, n) log3 t

(cid:16)

(cid:16)

(cid:17)(cid:17)

5 Preliminary experiments
The goal of these experiments was to contrast active learning methods originating from the persistent
noisy setting (speciﬁcally, N-WDP) to those originating from the non-realizable setting (speciﬁcally,
NR). The comparison is carried out on the hierarchies produced by standard HC methods operating
on the ﬁrst n = 10000 datapoints in the well-known MNIST dataset from http://yann.lecun.
com/exdb/mnist/, yielding a sample space of 108 pairs. We used Euclidean distance combined
with the single linkage (SING), median linkage (MED), and complete linkage (COMP) functions. The
n × n ground-truth matrix Σ is provided by the 10 class labels of MNIST.

We compared N-WDP with uniform prior and NR to two baselines: passive learning based on empirical
risk minimization (ERM), and the active learning baseline performing breadth-ﬁrst search from the
root (BF, Section 3) made robust to noise as in N-WDP. For reference, we also computed for each
of the three hierarchies the performance of the best cut in hindsight (BEST) on the entire matrix Σ.
That is essentially the best one can hope for in each of the three cases. All algorithms except ERM are
randomized and have a single parameter to tune. We let such parameters vary across suitable ranges
and, for each algorithm, picked the best performing value on a validation set of 500 labeled pairs.

In Table 1, we have collected relevant statistics about the three hierarchies. In particular, the single
linkage tree turned out to be very deep, while the complete linkage one is quite balanced. We
evaluated test set accuracy vs. number of queries after parameter tuning, excluding these 500
pairs. For N-WDP, once a target number of queries was reached, we computed as current output the
maximum-a-posteriori cut. In order to reduce variance, we repeated each experiment 10 times.

The details of our empirical comparison are contained in Appendix C.3. Though our experiments
are quite preliminary, some trends can be readily spotted: i. N-WDP signiﬁcantly outperforms NR.
E.g., in COMP at 250 queries, the test set accuracy of N-WDP is at 9.52%, while NR is at 10.1%. A
similar performance gap at low number of queries one can observe in SING and MED. This trend was
expected: NR is very conservative, as it has been designed to work under more general conditions
than N-WDP. We conjecture that, whenever the speciﬁc task at hand allows one to make an aggressive
noise-free algorithm (like WDP) robust to persistent noise (like N-WDP), this outcome is quite likely
to occur. ii. BF is competitive only when BEST has few clusters. iii. N-WDP clearly outperforms
ERM, while the comparison between NR and ERM yields mixed results.

Ongoing activity. Beyond presenting new algorithms and analyses for pairwise similarity-based
active learning, our goal was to put different approaches to active learning on the same footing for

8

comparison on real data. Some initial trends are suggested by our experiments, but a more thorough
investigation is underway. We are currently using other datasets, of different nature and size. Further
HC methods are also under consideration, like those based on k-means.

References

[1] E. Arkin, H. Meijer, J. Mitchell, D. Rappaport, and S. Skiena. Decision trees for geometric

models. In Proc. Symposium on Computational Geometry, pages 369–378, 1993.

[2] H. Ashtiani, S. Kushagra, and S. Ben-David. Clustering with same-cluster queries. In Proc.

30th NIPS, 2016.

[3] P. Awasthi, M. F. Balcan, and K. Voevodski. Local algorithms for interactive clustering. Journal

of Machine Learning Research, 18, 2017.

[4] M. F. Balcan and A. Blum. Clustering with interactive feedback. In Proc. of the 19th Interna-

tional Conference on Algorithmic Learning Theory, pages 316–328, 2008.

[5] Alina Beygelzimer, Sanjoy Dasgupta, and John Langford. Importance weighted active learning.

In Proc. ICML, pages 49–56. ACM, 2009.

[6] Alina Beygelzimer, Daniel Hsu, John Langford, and Tong Zhang. Agnostic active learning
without constraints. In Proc. 23rd International Conference on Neural Information Processing
Systems, NIPS’ 10, pages 199–207, 2010.

[7] Yuxin Chen, S. Hamed Hassani, Amin Karbasi, and Andreas Krause. Sequential information
maximization: When is greedy near-optimal? In Proc. 28th Conference on Learning Theory,
PMLR 40, pages 338–363, 2015.

[8] Yuxin Chen, S. Hamed Hassani, and Andreas Krause. Near-optimal bayesian active learning
with correlated and noisy tests. In Proc. 20th International Conference on Artiﬁcial Intelligence
and Statistics, 2017.

[9] D. Cohn, L. Atlas, and R. Ladner. Improving generalization with active learning. Machine

Learning, 15:201–221, 1994.

[10] C. Cortes, G. DeSalvo, C. Gentile, M. Mohri, and N. Zhang. Region-based active learning. In

Proc. 22nd International Conference on Artiﬁcial Intelligence and Statistics, 2019.

[11] S. Dasgupta and D. Hsu. Hierarchical sampling for active learning.

In Proc. of the 25th

International Conference on Machine Learning, 2008.

[12] Sanjoy Dasgupta. Coarse sample complexity bounds for active learning. In Advances in neural

information processing systems, pages 235–242, 2005.

[13] S. Davidson, S. Khanna, T. Milo, and S. Roy. Top-k and clustering with noisy comparisons.

ACM Trans. Database Syst., 39(4):35:1–35:39, 2014.

[14] Daniel Golovin and Andreas Krause. Adaptive submodularity: A new approach to active

learning and stochastic optimization. In arXiv:1003.3967, 2017.

[15] Alon Gonen, Sivan Sabato, and Shai Shalev-Shwartz. Efﬁcient active learning of halfspaces:
An aggressive approach. Journal of Machine Learning Research, 14:2583–2615, 2013.

[16] S. Hanneke. A bound on the label complexity of agnostic active learning.
International Conference on Machine Learning, pages 353–360, 2007.

In Proc. 24th

[17] S. Hanneke. Theory of disagreement-based active learning. Foundations and Trends in Machine

Learning, 7(2-3):131–309, 2014.

[18] Dov Harel and Robert E. Tarjan. Fast algorithms for ﬁnding nearest common ancestors. SIAM

Journal on Computing, 13(2):338–355, 1984.

[19] S. Kosaraju, T. Przytycka, and R. Borgstrom. On an optimal split tree problem. In Proc. 6th

International Workshop on Algorithms and Data Structures, pages 157–168, 1999.

[20] S. Kpotufe, R. Urner, and S. Ben-David. Hierarchical label queries with data-dependent

partitions. In Proc. 28th Conference on Learning Theory, pages 1176–1189, 2015.
[21] A. Mazumdar and B. Saha. Clustering with noisy queries. In arXiv:1706.07510v1, 2017b.
[22] M. Meila. Local equivalences of distances between clusterings?a geometric perspective. Ma-

chine Learning, 86(3):369–389, 2012.

9

[23] Stephen Mussmann and Percy Liang. Generalized binary search for split-neighborly problems.
In Proc. 21st International Conference on Artiﬁcial Intelligence and Statistics (AISTATS) 2018,
2018.

[24] Robert D. Nowak. The geometry of generalized binary search. IEEE Transactions on Informa-

tion Theory, 57(12):7893–7906, 2011.

[25] W. M. Rand. Objective criteria for the evaluation of clustering methods. Journal of the American

Statistical Association, 66:846–850, 1971.

[26] C. Tosh and S. Dasgupta. Diameter-based active learning.

In Thirty-fourth International

Conference on Machine Learning (ICML), 2017.

10

A Missing material from Section 1

A.1 Further related work

Further papers related to our work are those dealing with clustering with queries, e.g., [13, 2, 21, 4, 3].
In [13] the authors show that O(Kn) similarity queries are both necessary and sufﬁcient to achieve
exact reconstruction of an arbitrary clustering with K clusters on n items. This is generalized by
[21] where persistent random noise is added. [2] assume the feedback is center-based with a margin
condition on top. Because we are constrained to a clustering produced by cutting a given tree, the
results in [13, 2, 21] are incomparable to ours, due to the different assumptions. In [4, 3]) the authors
consider clusterings realized by a given comparison class (as we do here). Yet, the queries they are
allowing are different from ours, hence their results are again incomparable to ours.

B Missing material from Section 3

B.1 One Third Splitting (OTS)

For all i ∈ V , OTS maintain over time the value |St(i)|, i.e., the size of St(i), along with the forest
F made up of all maximal subtrees T (cid:48) of T such that |V (T (cid:48))| > 1 and for which none of their node
labels have been revealed so far. Notice that we will not distinguish between labels y(i) revealed
directly by a query or indirectly by the hierarchical structure. By maximal here we mean that it
is not possible to extend any such subtrees by adding a node of V whose label has not already
been revealed. OTS initializes F (when no labels are revealed) to contain T only, and maintains F
updated over time. Let subtree T (cid:48) ∈ F be arbitrarily chosen, and π be any backbone path of T (cid:48).
At time t, OTS visits π in a bottom-up manner, and ﬁnds the lowest node i∗
t in this path satisfying
(cid:12)
(cid:12)
(cid:12)
(cid:12)Sy(i∗
(cid:12)Sy(i∗
(cid:12) ≤ 2
(cid:12)
(cid:12)
(cid:12)
(r)
t . We repeat the
above procedure until |St(r)| = 1, i.e., until we ﬁnd c∗.
The next lemma is key to showing the logarithmic number of queries made by OTS.

3 |St(r)|, then query node i∗

(cid:12)
(cid:12)
(r)
(cid:12), i.e.,

(cid:12)
(cid:12)Sy(i∗
(cid:12)

(cid:12)
(cid:12)
(cid:12) ≤ 2

t )=1

t )=1

t )=0

(r)

t

t

t

Lemma 1 With the notation introduced in Section 3, at each time t, the query y(i∗
splits the version space St(r) in such a way that4

t ) made by OTS

min

(cid:110)(cid:12)
(cid:12)Sy(i∗
(cid:12)

t

t )=0

(cid:12)
(cid:12)
(cid:12) ,
(r)

(cid:12)
(cid:12)Sy(i∗
(cid:12)

t

t )=1

(cid:111)

(cid:12)
(cid:12)
(r)
(cid:12)

≥

|St(r)|
3

.

Proof. At each time t, |St(r)| is the product of the cardinality of St((cid:101)r) over all roots (cid:101)r of the trees
currently contained in F . Let π be a backbone of one such tree, say tree T (cid:48), with root r(cid:48). Since T (cid:48) is
arbitrary, in order to prove the statement, it is sufﬁcient to show that

t

t

(cid:111)

(cid:12)
(cid:12)
(cid:12)

≥

t )=0

t )=1

min

(cid:12)
(cid:12)
(cid:12) ,

(r(cid:48))

(r(cid:48))

|St(r(cid:48))|
3

(cid:110)(cid:12)
(cid:12)Sy(i∗
(cid:12)

(cid:12)
(cid:12)Sy(i∗
(cid:12)
Let h(π) be the length of π, i.e., the number of its edges, and (cid:104)j0, j1, . . . , jh(π)(cid:105) be the sequence of
its nodes, from bottom to top. For any k < h(π), we denote by js
k the sibling of jk in T (cid:48) (hence, by
this deﬁnition js
k does not belong to π). Now, observe that the number of possible labelings of π is
equal to h(π) + 1, that is, each labeling of π corresponds to an integer z ∈ {0, 1, . . . , h(π)} such
that y(jk) = 1 for all k ≤ z and y(jk) = 0 for all z < k ≤ h(π). Then, given any labeling of the
nodes of π (represented by the above z), we have
(cid:40)(cid:81)h(π)−1
k=z

|St(js

k)|

.

|St(r(cid:48))| =

1

if z < h(π) ,
if z = h(π) .

In fact, the disclosure of all labels of the nodes in π when z < h(π) would decompose T (cid:48) into (h(π)−
z)-many subtrees whose labelings are independent of one another. For all z ∈ {0, 1, . . . , h(π) − 1},
let us denote for brevity (cid:81)h(π)−1
(r(cid:48))|
by Sh(π) Notice that, by deﬁnition, |Sy(r(cid:48))=1
(r(cid:48))| = 1, and corresponds to the special case z =

k)| by Sz, and also denote for convenience |Sy(r(cid:48))=1

|St(js

k=z

t

t

4 This bound is indeed tight for this strategy when the input is a full binary tree of height 3.

11

Figure 4: A backbone path π selected by OTS and the associated quantities needed to prove the main properties
of the selected node i∗
t . Leaves are represented by squares, subtrees by triangles. For simplicity, in this picture π
is starting from the leftmost leaf of T (cid:48), but it can clearly be chosen to start from any of its deepest leaves. The
sum of all terms on the right of each subtree equals |St(r(cid:48))|. The cornerstone of the proof is that i∗
t (and hence
z∗) corresponds to the lowest among the h(π) = 4 horizontal lines depicted in this ﬁgure for which the sum of all
products below the chosen line is at least half the sum of all the products above the line. Furthermore, the fact that
|St(js
0)| = 1 guarantees that S0 = S1. Combined with the fact that Sz ≥ Sz+1 for all z ∈ {0, . . . , h(π) − 1},
this ensures that the abovementioned horizontal line always exists, and splits the sum of all h(π) + 1 terms into
two parts such that the smaller one is at least 1

3 of the total.

h(π). With this notation, it is now important to note that i∗
(cid:12)
(cid:12)Sy(i∗
(cid:12)
z∗ ∈ {0, 1, . . . , h(π) − 1}, and that
(h(π) + 1) labelings of π, the cardinality of St(r(cid:48)) can be written as follows:

t must be the parent of js
z∗ , for some
(cid:12)
(cid:12)
(r(cid:48))
(cid:12) = Sz∗ . Thus, taking into account all possible

t )=0

t

|St(r(cid:48))| =

h(π)
(cid:88)

z=0

Sz .

At this point, by deﬁnition, we have:

(i) S0 = S1, as |St(js
(ii) Sz ≥ Sz+1 for all z ∈ {0, . . . , h(π) − 1} .

0)| = 1, which in turn implies maxz Sz ≤ |St(r(cid:48))|

, and

2

See Figure 4 for a pictorial illustration.
The proof is now concluded by contradiction. If our statement is false, then there must exist a value z(cid:48)
3 |St(r(cid:48))| and Sz(cid:48)+1 < 1
such that Sz(cid:48) > 2
3 |St(r(cid:48))|. However, because the sequence (cid:104)S0, S1, . . . Sh(π)(cid:105)
is monotonically decreasing and we have S0 ≤ |St(r(cid:48))|
, implying S0 ≤ (cid:80)h(π)
z=1 Sz, such value z(cid:48)
cannot exist. Thus, it must exist z such that

2

1
3

|St(r(cid:48))| ≤ Sz ≤

2
3

|St(r(cid:48))| .

Let z∗ be the smallest z satisfying the above inequalities. Note that i∗
z∗ , because of
the bottom-up search on π performed by OTS. Exploiting again the monotonicity of the sequence
(cid:104)S0, S1, . . . Sh(π)(cid:105) and recalling that Sz∗ = (cid:81)h(π)−1

t is the parent of js

k=z∗

|St(r(cid:48))| ≤

(cid:12)
(cid:12)Sy(i∗
(cid:12)

t

t )=0

|St(js
(cid:12)
(r(cid:48))
(cid:12)
(cid:12) ≤

k)|, we conclude that
2
3

|St(r(cid:48))| .

Since

(cid:12)
(cid:12)Sy(i∗
(cid:12)

t

t )=1

(cid:12)
(cid:12)
(r(cid:48))
(cid:12) +

t )=0

(cid:12)
(cid:12)
(r(cid:48))
(cid:12) = |St(r(cid:48))|, we must also have

1
3
(cid:12)
(cid:12)Sy(i∗
(cid:12)

t

1
3
thereby concluding the proof. (cid:3)

|St(r(cid:48))| ≤

(cid:12)
(cid:12)Sy(i∗
(cid:12)

t

t )=1

(r(cid:48))

(cid:12)
(cid:12)
(cid:12) ≤

2
3

|St(r(cid:48))|,

From the above proof, one can see that it is indeed necessary that π is a backbone path, since the proof
hinges on the fact that |St(js
z=1 |Sz|, that is larger than
3 |St(r(cid:48))| (which may happen if π is not a backbone path), we would not have maxz Sz ≤ |St(r(cid:48))|
2
,
hence Sz would not be guaranteed to be at least 2

0)| is larger than 2 (cid:80)h(π)

0)| = 1. In fact, if |St(js

3 |St(r(cid:48))| for all z.

2

12

3Backbone 0124Proof of Theorem 1
Proof. By Lemma 1, we immediately see that OTS ﬁnds c∗ through O(log N ) queries. This is because
|St+1(r)| ≤ 2
3 |St(r)| for all time steps t, implying by induction that the total number of queries is
upper bounded by log3/2 N = O(log N ).

We now sketch an implementation of OTS which requires O(n + h log N ) time and O(n) space.

In a preliminary phase, we compute in a bottom-up fashion the values |S0(i)| for all nodes i ∈ V (T ).
This requires O(n). Thereafter, we perform a breath-ﬁrst search on T , and each time we visit a leaf
of T , we insert a pointer to it in a an array A in a sequential way. Thus, the j-th record of A will
contain a reference to the j-th leaf found during this visit, which entails that the leaves referred by
the pointers of A are sorted in ascending order of depth.

We recall that in the noiseless setting, each time the label of a node is revealed and is equal to 1 (to 0),
also the labels of its descendants (ancestors) are indirectly revealed, because they are known to be
equal to 1 (to 0). The total time OTS takes for assigning all indirectly revealed labels is clearly O(n).
Each time OTS needs to ﬁnd a backbone of a tree in the current forest F , we look for the largest index
j for which the record A[j] does not point to a leaf whose parent label has not been revealed yet.
Observe that, at any time t, the deepest leaf (cid:96) ∈ L(T ) satisfying this property must be the terminal
node of a backbone path of a tree in F . Furthermore, the highest node of such backbone is either
r(T ) or the lowest ancestor of (cid:96) whose label has not been revealed yet, and can therefore be found in
O(h) time.

In order to accomplish this leaf search operation, we simply maintain over time an index that scans
A from A[n] to A[1], looking for a leaf satisfying the above property. The total time OTS uses for
scanning A is again linear in n. Finally, for each query, OTS traverses bottom-up a backbone π,
exploiting the information previously stored to ﬁnd i∗
t ) is revealed. Note
that only the information of the nodes in π has to be updated. In fact, the disclosure of the label of
any node i ∈ V (T ) cannot affect the values of St(j) for all nodes j ∈ V (T ) that are not ancestors of
i. Besides, we are free to disregard the descendants of i since they will simply be indirectly labeled
(by 1).

t , and updates it after y(i∗

Overall, the total time required by this implementation of OTS is the sum of O(n) and O(h) times
the total number of queries the algorithm makes, which results in the claimed O(n + h log N ) upper
bound. The claim on the memory requirement immediately follows from the above description. (cid:3)

B.2 Proof of the lower bound in Theorem 2

Proof. Let T (cid:48) be the subtree of T constructed by visiting T from its root (for instance by a breadth-ﬁrst
or a depth-ﬁrst visit), and such that |L(T (cid:48))| = B. Note that the construction of T (cid:48) satisfying this
constraint is always possible because the maximum cardinality of L(T (cid:48)) is equal to |Ls(T )| (which
is also equal to maxc∗ (cid:101)K(T, c∗)). For each leaf (cid:96) ∈ L(T (cid:48)), consider all cuts c∗ that can be generated
by cutting either the edge connecting (cid:96) with its parent or the two edges connecting (cid:96) with its children.
The total number of such cuts is 2|L(T (cid:48))| = 2B. We set the prior P(·) to be uniform over these
2B-many cuts. Hence, for each leaf (cid:96) ∈ L(T (cid:48)), the probability (w.r.t. P(·)) that c∗ cuts the edge
connecting (cid:96) with its parent is 1/2, and so is the probability that c∗ cuts the two edges connecting (cid:96)
with its children.
Now, observe that, by construction, we have B ≤ (cid:101)K(T, c∗) ≤ 2B for all such cuts c∗ and, as a
consequence, B ≤ E[ (cid:101)K(T, c∗)] ≤ 2B, the expectation being over P(·). Since for each leaf of T (cid:48) any
2 mistake in expectation (over P(·)
(possibly randomized) active learning algorithm A has to make 1
and its internal randomization), we conclude that B/2 queries are always necessary to ﬁnd c∗, as
claimed. (cid:3)

B.3 Weighted Dichotomic Path (WDP)

In Algorithm 1 we give the pseudocode of WDP. At each round, WDP ﬁnds the path whose entropy
is maximized over all bottom-up paths π((cid:96), r(cid:48)), with (cid:96) ∈ L and r(cid:48) = r(T (cid:48)), where T (cid:48) is the subtree
in F containing (cid:96). Ties are broken arbitrarily. WDP performs a binary search on such π((cid:96), r(cid:48)) to
ﬁnd the edge of T (cid:48) which is cut by c∗, taking into account the current values of q(i) over that path.
Speciﬁcally, let (cid:104)i0 = (cid:96), i1, . . . , ih−1, ih = r(cid:48)(cid:105) be the sequence of nodes in π((cid:96), r(cid:48)) in descending

13

Algorithm 1: WDP (Weighted Dichotomic Path)
(cid:46) INPUT : T , {P(i), i ∈ V }.
(cid:46) OUTPUT : (cid:98)C = C∗.
Init: • (cid:98)C ← ∅; /* (cid:98)C contains all the clusters of C(c∗) found so far */

• F ← {T }; /* Forest of maximal subtrees T (cid:48) of T */
• y(par(r)) ← 0; /* Dummy node par(r) */
• for i ∈ V do q(i) ← P(i) · (cid:81)

j∈π(par(i),r(T ))(1 − P(j));

–- Path with maximum entropy –-

/*
while F (cid:54)= ∅ do

*/

Let L(F ) be the set of all leaves of T belonging to the subtrees in F .
Let R(F ) be the set of all roots of the subtrees in F .
π((cid:96), r(cid:48)) ← arg max(cid:96)∈L(F ),r(cid:48)∈R(F ) H(π((cid:96), r(cid:48)));
T = {T (cid:48) ∈ F : (cid:96), r(cid:48) ∈ V (T (cid:48))};

–- Binary search on path π((cid:96), r(cid:48)) –-

/*
u ← (cid:96);
while u (cid:54)= v do

v ← r(cid:48);

*/

Let (cid:104)i0 = u, i1, . . . , ih−1, ih = v(cid:105) be the sequence of nodes lying on π(u, v) in descending
order of depth.
Q ← (cid:80)
k∈{0,1,...,h−1} q(ik);
(cid:12)
(cid:12)
k∗ = arg mink∈{0,1,...,h−1}
(cid:12)
i∗ ← par(ik∗ );
Query y(i∗);
if y(i∗) = 0 then
v ← ik∗ ;

(cid:12)
(cid:12)
j∈{i0,...,ik} q(j)
(cid:12);

2 − (cid:80)

Q

else

u ← i∗;

Set P(i) = y(i) = 1 for all descendants i of u;
Set P(i) = y(i) = 0 for all ancestors i (cid:54)= u of u;
q(u) ← 1;
Set q(i) = 0 for all descendants and ancestors i (cid:54)= u of u;
Update P(i) and q(i) for all descendants of all i ∈ V (π(par(u), r(cid:48))) such that i (cid:54)= r(cid:48);
(cid:98)C ← (cid:98)C ∪ {L(u)}; /* L(u) is a cluster of C∗ */
*/
/*
F ← F \ T ; /* Remove from F the subtree containing π((cid:96), r(cid:48)) */
j ← par(u); /* Lowest node in π((cid:96), par(r(cid:48))) with label known to be 0 */
while j ∈ V (π((cid:96), r(cid:48))) do

–- Update F –-

Let jc be the child of j that is not in π((cid:96), r(cid:48)).
if jc ∈ L then

(cid:98)C ← (cid:98)C ∪ {jc}; /* Add to (cid:98)C a singleton cluster */

else

F ← F ∪ {T (jc)}; /* jc is the root of a subtree that will be
processed later */
Update q(i) for all i ∈ V (T (jc));

j ← par(j); /* j is a node whose label is known to be 0 */

return (cid:98)C .

order of depth. WDP ﬁnds an index k∗ that corresponds to the middle point in π((cid:96), r(cid:48)), taking into
account the current values of q(i) over that path. Let i∗ = par(ik∗ ). WDP queries the label of
i∗: If y(i∗) = 0, WDP continues the binary search on π ((cid:96), ik∗ ); if instead y(i∗) = 1, the binary
search continues on π (i∗, r(cid:48)), and so on. During the binary search, whenever WDP ﬁnds a node
u ∈ V (π((cid:96), r(cid:48))) with queried labels y(u) = 0 and y(par(u)) = 1, then the edge of π((cid:96), r(cid:48)) cut by c∗
has been found, and the binary search on this backbone path terminates. In the special case where

14

y(r(cid:48)) = 1, the binary search also ends, and we know that all nodes in L(r(cid:48)) form a cluster of C(c∗).
Once a binary search terminates, WDP updates F and the probabilities P(i) at all nodes i in the
subtrees of F , so as to reﬂect the new knowledge gathered by the queried labels.

Below, we prove WDP’s query complexity. The proofs are split into a series of lemmas.

Lemma 2 Given tree T with set of leaves L, any prior P(·) ∈ P>0 over c∗, and any c∗ ∼ P(·), let
j0 be a node of AB(c∗), having as children a leaf (cid:96) ∈ L and an internal node j(cid:48) of T (see Figure 5,
left). Then, during its execution, WDP will never select the bottom-up path starting from (cid:96).

Proof. Let T0 be the tree made up of all nodes of AB(c∗), and consider any given round with q(i) in
(3) deﬁned by the current posterior distribution maintained by the algorithm. We ﬁrst show that, for
all ancestors a of j0, path π((cid:96), a) cannot be selected by WDP, because its entropy5 H(π((cid:96), a)) will
always be strictly smaller than H(π((cid:96)(cid:48), a)) for all leaves (cid:96)(cid:48) ∈ L(j(cid:48)). To this effect, we can write

H(π((cid:96), a)) − H(π((cid:96)(cid:48), a)) =

−q((cid:96)) log2 q((cid:96)) −





q(u) log2 q(u)



(cid:88)

u∈π(j0,a)

(cid:32)

−

H(π((cid:96)(cid:48), j(cid:48)) −

(cid:88)

q(u) log2 q(u)

(cid:33)

= −q((cid:96)) log2 q((cid:96)) +

u∈π(j0,a)
(cid:88)

q(v) log2 q(v) .

v∈π((cid:96)(cid:48),j(cid:48))

(5)

Now, since
(cid:88)

q(u) +

(cid:88)

q(v) =

(cid:88)

q(u) =

(cid:88)

q(u) = q((cid:96)) +

(cid:88)

q(u) ,

u∈π((cid:96)(cid:48),j(cid:48))
we have q((cid:96)) = (cid:80)

v∈π((cid:96)(cid:48),j(cid:48)) q(v).

v∈π(j0,a)

u∈π((cid:96)(cid:48),a)

u∈π((cid:96),a)

u∈π(j0,a)

Consider the function f (x) = −x log2 x, for x ∈ [0, 1]. For all x, x1, x2 ∈ (0, 1) such that
x1 + x2 = x, it is easy to verify that we have f (x) < f (x1) + f (x2). More generally, for all
x, x1, x2, . . . , xm ∈ (0, 1) with (cid:80)m
i=1 f (xi). Since
|V (π((cid:96)(cid:48), j(cid:48)))| ≥ 2 (holding because j(cid:48) (cid:54)∈ L implies (cid:96)(cid:48) (cid:54)= j(cid:48)), the above inequality on f (·) allows us
to write

i=1 xi = x, one can show that f (x) < (cid:80)m

−q((cid:96)) log2 q((cid:96)) < −

q(v) log2 q(v) ,

(cid:88)

v∈π((cid:96)(cid:48),j(cid:48))

i.e., (5) < 0. Notice that the assumption P(·) ∈ P>0 implies q(v) > 0 at any stage of the execution of
WDP where node v has an unrevealed label. This is because, after any binary search on a path selected
by WDP, for all v belonging to any tree in F , in the update phase each value q(v) is multiplied by a
strictly positive value. This ensures that we can use the above inequality about f (·), as its argument
will always lie in the open interval (0, 1).
The inequality in (5) implies that there always exists a leaf (cid:96)(cid:48) of T (j(cid:48)) such that WDP selects the path
connecting (cid:96)(cid:48) with the root of the tree containing (cid:96) in the current forest F . This selection entails the
disclosure of either cut edge (j(cid:48), j0) (if j0 ∈ L(T0)), or a cut edge in T (j(cid:48)) (if j0 (cid:54)∈ L(T0)), which in
turn implies that the labels of i0 and all its ancestors will be disclosed to the algorithm to be equal
to 0, thereby indirectly revealing also cut edge ((cid:96), i0). Since F contains only trees whose height is
larger than 1, after this cut edge disclosure the tree made up of leaf (cid:96) alone cannot be part of F , thus
preventing WDP’s selection of a path starting from (cid:96). (cid:3)

Lemma 3 For any input tree T and any cut c∗ with P(·) ∈ P>0, the number of paths selected by
WDP before stopping is (cid:101)K(T, c∗).

Proof. If c∗ has only one cluster the statement is clearly true, since the binary search performed
by WDP on the ﬁrst selected path reveals that y(r) = 1 (hence y(v) = 1 for all v ∈ V ). We then
continute by assuming y(r) = 0, so that c∗ has least two clusters.

5 Here, we are deﬁning the entropy of a path π as − (cid:80)
v∈V (π) q(v) < 1.

(cid:80)

v∈V (π) q(v) log2 q(v), even for paths π for which

15

Figure 5: Illustration of all possible cases of Lemma 2 and Lemma 3. Nodes belonging to T0 (see main text)
are black, all remaining nodes are white. Leaves and subtrees of T are represented by squares and triangles,
respectively. Each node of T (cid:48)
c∗ is enclosed in a circle. Above: The two possible cases illustrating Lemma 2, that
is, j(cid:48) (cid:54)∈ V (T0) on the left, and j(cid:48) ∈ V (T0) on the right. Below: The ﬁve cases described in Lemma 3.

Let Π be the set of all paths selected by WDP during the course of its execution. The binary search
perfomed by WDP on each of such paths, discloses exactly one edge of c∗. Let c∗
wdp be the set
0 be the set of the remaining cut edges of c∗. We show that, for
containing all these cut edges, and c∗
any T and any cut c∗ of T , |c∗
0 are indirectly disclosed by WDP,
although none of them belongs to paths in Π.
Let T0 be the subtree of T made up of all nodes in AB(c∗). The edges of c∗ can be partitioned into
the ﬁve disjoint sets S1, . . . , S5 (see Figure 5 for reference):

wdp| = (cid:101)K(T, c∗), while all edges in c∗

S1: The set of all pairs of edges connecting a leaf (cid:96)0 of T0 to two sibling leaves (cid:96)1 and (cid:96)2 of T

(Figure 5, below, 1);

S2: The set of all pairs of edges connecting a leaf (cid:96)0 of T0 to two sibling internal nodes i1 and

i2 of T (Figure 5, below, 2);

S3: The set of all pairs of edges connecting a leaf (cid:96)0 of T0 to a leaf (cid:96) ∈ L and an internal node i

of T (Figure 5, below, 3);

S4: The set of all edges connecting an internal node i0 of T0 to an internal node i of T , so that

the sibling node of i belongs to V (T0) (Figure 5, below, 4);

S5: The set of all edges connecting an internal node i0 of T0 to a leaf (cid:96) of T , so that the sibling

node of (cid:96) belongs to V (T0) (Figure 5, below, 5).

Recall that T (cid:48)
number of its leaves. The leaves of T (cid:48)
D (see again Figure 5 for reference):

c∗ is the subtree of T whose nodes are (AB(c∗) ∪ LB(c∗)) \ L, and that (cid:101)K(T, c∗) is the
c∗ can be partitioned into the following four sets A, B, C, and

A: The set of all leaves of T (cid:48)
B: The set of all sibling leaves of T (cid:48)
C: The set of all leaves of T (cid:48)

leaf of T ;

c∗ that are also leaves of T0, i.e., that belong to AB(c∗);

c∗ that are also (sibling) internal nodes of T ;

c∗ that are also internal nodes of T such that their sibling node is a

D: The set of all leaves of T (cid:48)

c∗ that are also internal nodes of T such that their sibling node

belongs to T0.

We will not show a one-to-one mapping between L(T (cid:48)
possible cases.

c∗ ) and the cut edges of c∗

wdp covering all

S1 ↔ A: For each pairs of cut edges in S1), WDP clearly selects a path starting from either (cid:96)1 or (cid:96)2,
which will indirectly disclose the cut edge incident to the sibling leaf ((cid:96)2 or (cid:96)1, respectively).
S1 is therefore about all leaves of set A.

16

1---A2---B3---C4---D5---0aaS2 ↔ B: For each pairs of cut edges in S2, WDP selects two paths, one per cut edge. Each of these
two paths clearly contains one of these two cut edges, and corresponds to all leaves of T (cid:48)
c∗
that are also leaves of T . Hence we are covering all leaves of set B.

S3 ↔ C: For the edges in S3, WDP selects only one path, starting from a leaf of T (i). This path
clearly contains edge (i, (cid:96)0), and covers all leaves of set C. Observe that, by Lemma 2, edge
((cid:96)0, (cid:96)) is always indirectly revealed and never contained in a path selected by WDP.
S4 ↔ D: For the edges in S4, whenever WDP selects a path starting from a leaf of T (i), all the nodes
in V (T (i)) are indirectly labeled 1, and from that point on, they will not be included in a
tree in F . This path clearly contains edge (i0, i), hence we are covering all leaves of set D.
S5 ↔ ∅: Finally, Lemma 2 ensures that all cut edges in S5 are indirectly disclosed whenever WDP
0 is the sibling node of (cid:96).

selects a path starting from a leaf belonging to T (i(cid:48)
Hence this case is ruled out by Lemma 2, and does not correspond to any leaf.

0), where i(cid:48)

From the above, we conclude that the number of paths selected by wdp is always equal to (cid:101)K(T, c∗),
as claimed. (cid:3)

The next lemma provides an entropic bound on the (condionally) expected number of queries WDP
makes on a given path. Notice that the posterior distribution maintained by WDP never changes
during each binary search, but only between a binary search and the next. Consider then q(i) deﬁned
in (3) at the beginning of a given binary search in terms of the current posterior distribution, and let π
be the selected path, after having observed the labels that generated the current posterior.

Lemma 4 Let π be any path selected by WDP during the course of its execution, and {q(i)} be
the current distribution (3) at the time π is selected. Then the expected number of queries WDP
makes on π, conditioned on past revealed labels, is O ((cid:100)H(π)(cid:101)) = O (log(|V (π)|)) . Here, both the
conditional expectation and H(π) are deﬁned i.t.o. {q(i)}.

Proof. Let π be the currently selected path, and denote by Epar(π) the set made up of the edges in π
along with the edge connecting the top node of π to its parent (recall that in the special case where
r is a terminal node of π, we can view r as the child of a dummy “super-root”). The binary search
performed on π guarantees that the number of queries Q(π, (u, v)) made by WDP to ﬁnd a cut edge
(u, v) lying on π can be quantiﬁed as follows:

(cid:38)

log2

(cid:32) (cid:80)

(u(cid:48),v(cid:48))∈Epar(π)

P((u(cid:48), v(cid:48)) ∈ c∗)

(cid:33)(cid:39)

P((u, v) ∈ c∗)

(cid:18)

(cid:24)
log2

=

1
P((u, v) ∈ c∗)

(cid:19)(cid:25)

,

where the probabilities above are deﬁned w.r.t. the posterior distribution at the beginning of the binary
search. The expected number of queries made on π, conditioned on past labels can thus be bounded
as

(cid:88)

P((u(cid:48), v(cid:48)) ∈ c∗)

(u(cid:48),v(cid:48))∈Epar(π)

(cid:24)

(cid:18)

log2

1
P((u(cid:48), v(cid:48)) ∈ c∗)

(cid:19)(cid:25)

=

(cid:88)

u∈V (π)

(cid:24)

q(i)

log2

(cid:19)(cid:25)

(cid:18) 1
q(i)

= O ((cid:100)H(π)(cid:101))
= O (log(|V (π)|)) ,

as claimed. (cid:3)

We are now ready to prove Theorem 3 and Theorem 6.
Proof.[Theorem 3] For given c∗, let Π = Π(c∗) = (cid:104)π1, . . . , π|Π|(cid:105) be the sequence of paths selected
by WDP, sorted in the temporal order of selection during WDP’s run. Also, denote by Q(πj) the
number of queries made by WDP on πj ∈ Π. Notice that the sequence Π is fully determined by
c∗. Moreover, the paths in Π are orderer in such a way to guarantee that πj contains a unique edge
(par(uj), uj) which c∗ cuts across. Then, if we denote by {qj(·)} the value of q(·) at the time path πj
is selected, it is easy to see that cut c∗ can be alternatively generated by sequentially generating edge
(par(u1), u1) according to distribution {q1(·)} over π1, then (par(u2), u2) according to (posterior)
distrubution {q2(·)} over π2, then (par(u3), u3) according to (posterior) distrubution {q3(·)} over
π3, and so on until |Π| cuts have been generated. From Lemma 3, we have |Π| = (cid:101)K(T, c∗).
Let us then denote by E[·] the expectation w.r.t.
the prior distribution, and by Ej[·] be the
conditional expectation E[· | (par(u1), u1), (par(u2), u2), . . . , (par(uj−1), uj−1)]. Notice that

17

the sequence of random variables par(u1), u1), (par(u2), u2), . . . , (par(uj−1), uj−1) fully deter-
mines the posterior distribution {qj(·)} before the selection of the j-th path πj, and so, πj it-
self. This way of viewing c∗ makes (cid:101)K = (cid:101)K(T, c∗) a (ﬁnite) stopping time w.r.t.
the se-
quence of random variables par(u1), u1), (par(u2), u2), . . . ,, in that { (cid:101)K ≥ j} is determined by
(par(u1), u1), (par(u2), u2), . . . , (par(uj−1), uj−1). This allows us to write





(cid:101)K
(cid:88)



Q(πj)

 =

n
(cid:88)

i
(cid:88)

(cid:104)

E

Q(πj){ (cid:101)K = i}

(cid:105)

E

j=1

i=1

j=1

n
(cid:88)

(cid:104)

E

=

Q(πj){ (cid:101)K ≥ j}

(cid:105)

j=1
n
(cid:88)

j=1
n
(cid:88)

E

(cid:104)

(cid:105)
{ (cid:101)K ≥ j}Ej[Q(πj)]

(since (cid:101)K is a stopping time)

n
(cid:88)

E

(cid:104)

(cid:105)
{ (cid:101)K = i}Ej[Q(πj)]

j=1

i=j

n
(cid:88)

i
(cid:88)

E

(cid:104)

(cid:105)
{ (cid:101)K = i}Ej[Q(πj)]

=

=

=

=



Ej[Q(πj)]



(cid:101)K
(cid:88)

j=1


i=1

n
(cid:88)

j=1


E

{ (cid:101)K = i}

i=1


= E

= O

(cid:101)K
(cid:88)



j=1



E



Ej[Q(πj)]



(cid:101)K
(cid:88)

(cid:100)Hj(πj)(cid:101)

j=1

= O

(cid:16)

(cid:17)
E[ (cid:101)K] log h

,









(by Lemma 4, where Hj(·) is w.r.t. {qj(·)})

(6)

as claimed (cid:3)
A slightly more involved guarantee for WDP is given by the following theorem, where the query
complexity depends in a more detailed way on interplay between T and the prior P(·). Given
any bottom-up path π in T , we denote by (cid:101)H(π) the normalized entropy of π, deﬁned as (cid:101)H(π) =
− (cid:80)
i∈V (π) q(i), and q(i) is deﬁned according to the
prior distribution P(·), as in (3). Notice that we may have (cid:80)
i∈V (π) q(i) < 1. Further, denote by D
the family of all sets Π of all vertex-disjoint bottom-up paths starting from T ’s leaves such that the
top terminal node of each path π ∈ Π is either the root r of T or a node of another path of Π. The
upper bound in the following theorem is never worse than the upper bound in Theorem 3.

i∈V (π) (cid:98)q(i) log((cid:98)q(i)) , where (cid:98)q(i) = q(i)/ (cid:80)

(cid:16)
maxΠ∈D (cid:80)m(Π)

for any tree T , any prior distribution P(·)
Theorem 6 In the noiseless realizable setting,
over c∗ such that P(·) ∈ P>0, the expected number of queries made by WDP to ﬁnd c∗ is
, and paths πi1, πi2, . . .
O
in Π ∈ D are sorted in non-increasing value of normalized entropy (cid:101)H(·). In the above, the expecta-
tions is again over P(·).

(cid:109)
E (cid:101)K(T, c∗)

, where m(Π) = min

j=1 (cid:100) (cid:101)H(πij )(cid:101)

, |Π|

(cid:110)(cid:108)

(cid:111)

(cid:17)

As an application of the above result, consider that oftentimes a linkage function generating T also
tags each internal node i with a coherence level αi of T (i), which is typically increasing as we move
downwards from root to leaves. A common situation in hierarchical clustering is then to ﬁgure out
the “right" level of granularity of the ﬂat clustering we are looking for through the deﬁnition of bands
of nodes (i.e., bands of clusters) of similar coherence. This may be encoded through a prior P(·) that

18

uniformly spreads (1 − (cid:15))/b probability mass over b-many edge-disjoint cuts of T , for b (cid:28) h, and an
arbitrarily small (cid:15) > 0, and the remaining mass (cid:15) over all remaining cuts (this is needed to comply
with the condition P(·) ∈ P>0). As we said in the main body of the paper, Theorem 6 gives a bound
of the form E (cid:101)K(T, c∗) log b as opposed to the bound E (cid:101)K(T, c∗) log h provided by Theorem 3.
Proof of Theorem 6
Proof. Given T and prior P(·), let Dwdp be the set made up of all sets Π of bottom-up paths in T that
WDP can potentially select during the course of its executions. Each set Π is uniquely determined by
c∗ ∼ P(·). The family of sets D is clearly a superset of Dwdp. We prove the theorem by showing that
the expected number of queries made by WDP is upper bounded by



O

 max
Π∈Dwdp

m(Π)
(cid:88)

j=1

(cid:108)
(cid:101)H(πij )



(cid:109)
 ,

(7)

where, for any given Π ∈ Dwdp, π1, π2, . . . is the sequence of paths of Π in the order they are
selected by WDP , while πi1, πi2, . . . is the same sequence rearranged in non-increasing order of
(cid:101)H(·). Using the same notation as in the proof of Theorem 3, we observe that at the time when πj gets
selected by WDP the distribution {qj(·)} sitting along path πj is precisely the normalized distribution
{(cid:98)q(·)} such that (cid:80)|V (πj )|
(cid:98)q(i) = 1, so that Hj(πj) = (cid:101)H(πj). Then, Eq. (6) combined with Lemma
4 allows us to write

i=1





(cid:101)K
(cid:88)


 = E

Q(πj)



O

E





(cid:101)K
(cid:88)





(cid:100) (cid:101)Hj(πj)(cid:101)



 .

j=1

j=1

In the sequel, we show how to upper bound the right-hand side of the last (in)equality by (7). Set for
brevity E[ (cid:101)K] = (cid:100)µ(cid:101). We have

(cid:101)K
(cid:88)

j=1

(cid:100) (cid:101)Hj(πj)(cid:101) =

(cid:101)K
(cid:88)

j=1

{ (cid:101)K < µ}(cid:100) (cid:101)Hj(πj)(cid:101) +

(cid:101)K
(cid:88)

{ (cid:101)K ≥ µ}(cid:100) (cid:101)Hj(πj)(cid:101)

j=1

µ
(cid:88)

(cid:100) (cid:101)Hj(πij )(cid:101) +

≤

j=1

(cid:101)K
µ

(cid:101)K
(cid:88)

(cid:100) (cid:101)Hj(πj)(cid:101)

j=1

m(Π)
(cid:88)

(cid:100) (cid:101)Hj(πij )(cid:101) +

(cid:101)K
µ

max
Π∈Dwdp

m(Π)
(cid:88)

j=1

(cid:100) (cid:101)Hj(πij )(cid:101)

≤ max
Π∈Dwdp

(cid:32)

=

1 +

j=1
(cid:33)

(cid:101)K
µ

max
Π∈Dwdp

m(Π)
(cid:88)

(cid:100) (cid:101)Hj(πij )(cid:101) ,

j=1

so that, taking the expectation of both sides,




(cid:101)K
(cid:88)

E



(cid:100) (cid:101)Hj(πj)(cid:101)

 ≤ 2 max
Π∈Dwdp

m(Π)
(cid:88)

(cid:100) (cid:101)Hj(πij )(cid:101) .

j=1

j=1

This concludes the proof. (cid:3)

B.4 N-WDP (Noisy Weighted Dichotomic Path)

N-WDP is a robust variant of WDP that copes with persistent noise. Given an internal node i ∈ V \ L,
let L(i) be the set of all possible queries that can be made to determine y(i), i.e., the set ((cid:96), (cid:96)(cid:48)) ∈
L(left(i)) × L(right(i)). Then, given conﬁdence δ ∈ (0, 1], and noise level λ ∈ [0, 1/2), N-WDP:

1. Preprocesses T and prior P(·) by setting y(i) = 1 for all nodes i ∈ V \ L such that
|L(i)| < α log(n/δ)
(1−2λ)2 , for a suitable constant α > 0. P(·) is also updated (all j ∈ T (i) have
P (j) = 1). At the end of this phase, each node in V is either unlabeled or labeled with 1.

19

2. Let Tλ be the subtree of T made up of all unlabeled nodes of T , together with all nodes
whose label has been set to 1 that are children of unlabeled nodes. N-WDP operates on Tλ as
WDP, with the following difference: Whenever a label y(i) is requested, N-WDP determines
(cid:17)
its value by a majority vote over Θ
-many queries selected uniformly at random
from L(i).

(cid:16) log(n/δ)
(1−2λ)2

Proof sketch of Theorem 4
Proof. Let Λ be the set of pairs of leaves whose label has been corrupted by noise. A standard
Chernoff bound implies that for any ﬁxed subset of L × L containing at least α log(1/δ)
(1−2λ)2 pairs (for
a suitable constant α > 0), the probability that the majority of them belongs to Λ is at most δ. Let
us set for brevity f (n, λ, δ) = α log(n/δ)
(1−2λ)2 . A union bound over the at most n − 1 internal nodes
of V guarantees that for all queries y(i) made by N-WDP operating on Tλ the majority vote over
f (n, λ, δ)-many queries on pairs of leaves of L(i) will produce the correct label (i.e., before noise)
of that node with probability at least 1 − δ.
Moreover, since the cut (cid:98)c found by N-WDP on Tλ can be obtained with probability at least 1 − δ from
c∗ by merging zero or more clusters on T , it is immediate to see that (cid:101)K(Tλ, (cid:98)c) ≤ (cid:101)K(T, c∗). It is also
easy to verify that this inequality holds even in expectation over the prior distributions of cut c∗ on T
and (cid:98)c on Tλ, that is, EPλ (cid:101)K(Tλ, (cid:98)c) ≤ EP (cid:101)K(T, c∗), where Pλ denotes the modiﬁed prior on tree Tλ
produced after N-WDP’s initial preprocessing (Step 1 in the main body of the paper).
Recall that, with probability ≥ 1 − δ, the behavior of n − wdp on T with prior P(·) is the same as
that of wdp on Tλ with the updated prior Pλ(·). Then we can use Lemma 3 by replacing c∗ with (cid:98)c to
claim that the number of paths selected by N-WDP before stopping is (cid:101)K(Tλ, (cid:98)c), and then Lemma 4 to
conclude that the expected (w.r.t. P(·)) number of queries made by N-WDP is upper bounded with
probability 1 − δ (over the noise in the labels) by
(cid:17)

(cid:19)

(cid:16)

O

f (n, λ, δ) EPλ (cid:101)K(Tλ, (cid:98)c) log(h(Tλ))

= O

EP (cid:101)K(T, c∗) log h

.

(cid:18) log(n/δ)
(1 − 2λ)2

(cid:17)

(cid:16) n(log(n/δ))3/2
(1−2λ)3

We conclude the proof by showing that with probability at least 1 − δ we have dH (Σ∗, (cid:98)C) =
O
. Since all labels requested by N-WDP are simultaneously correct with probability
at least 1−δ, the distance dH (Σ∗, (cid:98)C) is upper bounded with the same probability by (cid:80)
i∈L(Tλ) |L(i)|2.
For each tree Tλ constructed by N-WDP , and any i ∈ L(Tλ), we have
f (n, λ, δ)1/2(cid:17)
(cid:17)

O(f (n, λ, δ)) = |L(i)| = Ω

(cid:16)

(cid:16)

.

n
(f (n,λ,δ))1/2

, and the quantity (cid:80)

i∈L(Tλ) |L(i)|2,

Hence, the maximum number of leaves of Tλ is O
contributing to dH (Σ∗, (cid:98)C) is upper bounded by
f (n, λ, δ))3/2(cid:17)

O(n

(cid:16)

= O

(cid:18) n(log(n/δ))3/2
(1 − 2λ)3

(cid:19)

,

as claimed. (cid:3)

C Missing material from Section 4

C.1 Proof sketch of Theorem 5

Proof. The proof follows from Theorem 2 and 3 in [6], together with the following observations.

1. For any tree T with n leaves, we have |C(T, K)| = O(nK).
2. When D is uniform, the disagreement coefﬁcient θ = θ(C(T, K), D) is O(K). To show

this statement, consider the following. For any c∗ ∈ C(T, K) and r > 0, let

DIS(c∗, r) =

(cid:110)

(x1, x2) ∈ L × L : ∃c(cid:48) ∈ C(T, K) : σC(c(cid:48))(x1, x2) (cid:54)= σC(c∗)(x1, x2)

∧ dH (ΣC(c(cid:48)), ΣC(c∗)) ≤ r

(cid:111)

.

20

Then in our case θ is deﬁned as

θ = sup
r>0

|{(x1, x2) ∈ DIS(c∗, r)}|
r n2

.

Now, for any budget r in DIS(c∗, r), and any c∗ ∈ C(T, K), the number of times we can
replicate the perturbation of c∗ so as to obtain c(cid:48) satisfying dH (ΣC(c(cid:48)), ΣC(c∗)) ≤ r is at
most K. This is because any such perturbation will involve a different cluster of C(c∗), and
therefore disjoint sets of leaves. Moreover, each such perturbation covers rn2 leaves. The
worst case that makes θ = K is when T is a full binary tree, and C(c∗) has equally-sized
clusters. In all other cases θ ≤ K.

3. Regarding the expected running time per round, we give the pseudocode (see Algorithm
2 in this appendix) of a sequential algorithm, which operates as follows. In a preliminary
phase the input tree T is preprocessed in order to be able to ﬁnd in constant time at any time
t (i) the leftmost and rightmost descendent leaf of any internal node of T , and (ii) the lowest
common ancestor of any two given leaves.6 At each time t, it receives (cid:104)(xit, xjt), σt, wt(cid:105),
for some weight wt ≥ 0, and label σt ∈ {−1, +1}, and outputs errt(C(ˆct+1)), based on the
past computation of C(ˆct) and errt−1(C(ˆct)). This can be directly used to compute at each
round errt−1(C(ˆct)) needed by the algorithm, but also the perturbed cut ˆc(cid:48)
t and its associated
empirical error errt−1(C(ˆc(cid:48)
t)), once we repeat the computation by perturbing the last item
(cid:104)(xit, xjt), σt, wt(cid:105) in the training set as follows: σt = −σC(ˆct)(xit , xjt), and wt = ∞. In
turn, the above can be used to compute dt = errt−1(C(ˆc(cid:48)
t)) − errt−1(C(ˆct)) and probability
pt.
The cornerstone of this procedure is to maintain updated over time for each internal node v
of T a record storing eight values:

• 1st, 2nd, 3rd and 4th values: positive and negative inter-cluster total weight of all

leaves in L(left(v)) and L(right(v));

• 5th and 6th values: positive and negative inter-cluster sum of weights w(xi, xj) for all

xi ∈ L(left(v)) and all xj ∈ L(left(v)), and

• 7th and 8th values: total intra-cluster negative weight of all the clusters of leaves in

L(left(v)) and L(right(v)).

When this procedure receives in input triplet (cid:104)(xit, xjt), σt, wt(cid:105), it ﬁnds at = lca(xit, xjt).
Then the eight records associated with each node on the bottom-up path π(at, r) are updated
in a bottom-up fashion according to the input, whenever necessary. This requires a constant
time per node in V (π(at, r)). Finally, errt(C(ˆct+1)) is obtained by simply summing the
total intra-cluster negative weight of all clusters of leaves in L(left(r)) and L(right(r))
to the total inter-cluster positive weight of all leaves in L(left(r)) and L(right(v)), plus
the inter-cluster sum of positive weights of the pairs w(xi, xj) for all xi ∈ L(left(r)) and
xj ∈ L(left(r)). In the special case where the updated clustering is made up of a single
cluster containing all leaves of T , the procedure outputs the sum of all negative values in the
record associated with r. In any event, computing this sum requires constant time.
Hence the total time required for performing all operations required at any time t is simply
O(|V (π(at, r)|).

This concludes the proof. (cid:3)

Finally, in order to compute the clustering at the end of the training phase, it sufﬁces to perform a
breadth-ﬁrst visit of T to ﬁnd all leaves of T (cid:48)
c∗ . This requires a time linear in the number of clusters
of the clustering found by the algorithm. Then the algorithm outputs the indices of the leftmost and
rightmost descendant of each leaf of T (cid:48)
c∗ , which requires Θ(1) time per cluster. The total time for
giving in output the computed clustering is therefore linear in the number of its own clusters.

C.2 Pseudocode of the NR algorithm in the non-realizable setting

Each internal node of T is associated with a record containing eight values that are maintained
updated over time. We start by providing the semantics of these eight values:

6 Note that at can always be found in constant time after a Θ(n) time preprocessing phase of T – see [18].

21

• weight(v, left, −1) and weight(v, left, +1): negative and positive inter-cluster total weight

of leaves in L(left(v)).

• weight(v, middle, −1) and weight(v, middle, +1): negative and positive inter-cluster sum

of weights w((cid:96)l, (cid:96)r), where (cid:96)l ∈ L(left(v)) and (cid:96)r ∈ L(right(v)), respectively.

• weight(v, right, −1) and weight(v, right, +1): negative and positive inter-cluster total

weight of leaves in L(right(v)).

• cost(v, left) and cost(v, right): intra-cluster total negative weight of clusters of leaves in

L(left(v)) and L(right(v)), respectively.

Finally, for any internal node v of T , we denote by s(v) the following sum:

s(v) def== weight(v, left, −1) + weight(v, left, +1) + weight(v, middle, −1)

+ weight(v, middle, +1) + weight(v, right, −1) + weight(v, right, +1) .

22

Algorithm 2: Sequential algorithm for the non-realizable case (NR).
(cid:46) INPUT : Sequence of pairs of labeled leaves of the form (cid:104)((cid:96), (cid:96)(cid:48)), σ((cid:96), (cid:96)(cid:48))(cid:105)
(cid:46) OUTPUT : Clustering C with minimum cost over all clusterings realized by T .

Init:

if v ∈ L is_cluster(v) ← 1; else is_cluster(v) ← 0;

• for v ∈ V do
• current_tot_cost ← 0;
• Preprocess T in a bottom-up fashion and store for each internal node of T the leftmost and
rightmost leaf descendant index. /* Necessary to output C in linear time */

• Preprocess T to ﬁnd the lowest common ancestor of any pair of leaves in constant time.

for t = 1 to . . . do

Receive pair of leaves ((cid:96), (cid:96)(cid:48));
w((cid:96), (cid:96)(cid:48)) ← 0; /* initialize w((cid:96), (cid:96)(cid:48)) */
a ← lowest common ancestor of (cid:96) and (cid:96)(cid:48); /* we assume (cid:96) (cid:54)= (cid:96)(cid:48) */
/* save all records for the rollback that will be done later */
S ← list of saved records (eight values per node) of the path π(a, r);
/* ––––– verify whether (cid:96) and (cid:96)(cid:48) are in the same cluster of the current
optimal clustering ––––– */
while a (cid:54)= r ∧ is_cluster(a) = 0 do

a ← par(a);

if is_cluster(a) = 1 then same_cluster((cid:96), (cid:96)(cid:48)) ← 1; else same_cluster((cid:96), (cid:96)(cid:48)) ← 0;

/* ––––– compute optimal cost under constraint ––––– */
if same_cluster((cid:96), (cid:96)(cid:48)) = 1 then

/* compute the optimal cost of the current clustering constrained by
the assumption that (cid:96) and (cid:96)(cid:48) are in different clusters; −∞ is
simulated using a very large negative number */
total_modiﬁed_cost ←add_weight((cid:96), (cid:96)(cid:48), −∞);

else

/* compute the optimal cost of the current clustering constrained by
the assumption that (cid:96) and (cid:96)(cid:48) are in the same cluster; +∞ is simulated
using a very large positive number */
total_modiﬁed_cost ←add_weight((cid:96), (cid:96)(cid:48), +∞);

/* rollback of the clustering preceding the add of weight −/ + ∞ */
Restore all records of S;
/* ––––– add weight w((cid:96), (cid:96)(cid:48)) if necessary ––––– */
Set:

t−1 (total_modiﬁed_cost − current_tot_cost) ;

• Difference dt ← 1
• Probability pt as a function of dt as in Eq. (4);
• w((cid:96), (cid:96)(cid:48)) ← σ((cid:96),(cid:96)(cid:48))
• With probability pt, current_tot_cost ←add_weight((cid:96), (cid:96)(cid:48), w((cid:96), (cid:96)(cid:48)));

pt

;

/* ––––– find the current optimal clustering/partition of L ––––– */
Perform a breadth-ﬁrst search on T , starting from its root r, to create the set V (cid:48) formed by all nodes
v ∈ V such that is_cluster(v) = 1 and for all ancestors a of v we have is_cluster(a) = 0;

C ← ∅;
for v ∈ V (cid:48) do

C ← C ∪ {L(v)};

return C .

23

Procedure Procedure add_weight((cid:96), (cid:96)(cid:48), w((cid:96), (cid:96)(cid:48)))
(cid:46) INPUT : Pair of leaves (cid:96), (cid:96)(cid:48) ∈ L (with (cid:96) (cid:54)= (cid:96)(cid:48)) and weight w((cid:96), (cid:96)(cid:48))
(cid:46) OUTPUT : Total clustering cost after adding weight w((cid:96), (cid:96)(cid:48))

a ← lowest common ancestor of (cid:96) and (cid:96)(cid:48);

update middle weight record of node a */

/*
weight(a, middle, sgn(w((cid:96), (cid:96)(cid:48))) ← weight(a, middle, sgn(w((cid:96), (cid:96)(cid:48))) + w((cid:96), (cid:96)(cid:48));

set cluster flag of node a */

/*
if s(a) ≥ 0 then

is_cluster(a) ← 1;

else

is_cluster(a) ← 0;

/* ––––– record update of all a’s ancestors ––––– */
while a (cid:54)= r do

set variable dir to left or right direction from par(a) to a */

/*
if a = left(par(a)) then

dir ← left;

else

dir ← right;

update positive and negative inter-cluster weights of node par(a) */

/*
for σ ∈ {+1, −1} do

if is_cluster(a) = 0 then

weight(par(a), dir, σ) ←
weight(a, left, σ) + weight(a, middle, σ) + weight(a, right, σ);

else

weight(par(a), dir, σ) ← 0;

update par(a)’s cost record relative to node a */

/*
if is_cluster(a) = 0 then

cost(par(a), dir) ← cost(a, left) + cost(a, right);

else

cost(par(a), dir) ← cost(a, left) + |weight(a, left, −1)| + |weight(a, middle, −1)| +
|weight(a, right, −1)| + cost(a, right);

update cluster flag of par(a) */

/*
if s(par(a)) ≥ 0 then

is_cluster(par(a)) ← 1;

else

is_cluster(par(a)) ← 0;

a ← par(a);

/* ––––– compute the total cost of the current optimal clustering ––––– */
if is_cluster(r) = 0 then

cost_after_adding_weight ← cost(r, left) + weight(r, left, +1) + weight(r, middle, +1) +
weight(r, right, +1) + cost(r, right)

else

cost_after_adding_weight ← cost(r, left) + |weight(r, left, −1)| +
|weight(r, middle, −1)| + |weight(r, right, −1)| + cost(r, right);

return cost_after_adding_weight .

C.3 Missing material from Section 5

In Table 2 we report the results of our preliminary experiments. Notice that N-WDP, NR, and
BF are randomized algorithms. Hence, for these three algorithms we give average results and

24

No. of queries

250

500

1000

2000

5000

10000

20000

Tree
SING

MED

COMP

Algorithm
ERM
N-WDP
NR
BF
ERM
N-WDP
NR
BF
ERM
N-WDP
NR
BF

8.81
8.29±0.0
11.0±2.0
89.0±0.0
10.30
9.41±0.1
10.17±0.0
89.4±0.0
10.65
9.52±0.0
10.1±0.0
13.5±0.0

8,78
8.28±0.0
8.77±0.0
89.0±0.0
10.16
9.07±0.1
9.37±0.0
88.1±0.0
10.30
9.47±0.0
10.0±0.0
13.5±0.0

8.39
8.28±0.0
8.43±0.0
88.0±0.0
9.36
8.88±0.1
9.0±0.0
87.0±0.0
10.04
9.44±0.0
10.0±0.0
9.2±0.0

8.29
8.29±0.0
8.31±0.0
86.0±2.0
8.91
8.92±0.1
8.85±3.0
63.1±0.0
9.26
9.43±0.0
11.4±0.6
9.1±0.0

8.29
–
8.29±0.0
87.0±3.0
8.91
8.8±0.1
–
18.2±5.0
9.06
–
10.8±0.5
9.0±0.0

8.29
–
–
72.0±10.0
8.69
8.8±0.1
–
18.0±3.0
8.99
–
9.0±0.0
9.0±0.0

8.29
–
–
67.0±10.0
8.65
8.7±0.1
–
10.9±1.0
8.93
–
8.9±0.0
8.9±0.0

Table 2: Test error (in percentage) vs. number of queries for the various algorithms we tested on the hierarchies
SING, MED, and COMP originating from the MNIST dataset (see main body of the paper). Standard deviations
are also reported. Missing values on N-WDP are due to the fact that the algorithm stops before reaching the
desired number of labels. Missing values on NR are instead due to the fact that we stopped the algorithm’s
execution once we obseved no further test error improvement.

standard deviation across 10 independent runs of each one of them. As a reference, consider that
the performance of BEST (see Section 5 in the main body of the paper) on the three datasets is the
following: SING: 8.26%, MED: 8,51%, COMP: 8.81%. Moreover, since in this dataset we have
10 class labels with approximately the same frequency, both a random clustering and a degenerate
clustering having n = 10000 singletons would roughly give 10% error.

In light of the above, notice that on both SING and MED, the robust breadth-ﬁrst strategy BF goes
completely off trail, in that it tends to produce clusterings with very few clusters. This behavior is
due to the presence in the two hierarchies of long paths starting from the root, which is in turn caused
by the way the single and the median linkage functions deal with the outliers contained in the MNIST
dataset.

Finally, one should take into account the fact that when training our active learning algorithms we
have used the ﬁrst 500 labels for parameter tuning. Hence, a fair comparison to ERM is one that
contrasts the test error of N-WDP, NR, and BF at a given number of queries q to the test error of ERM
at q + 500 queries. From Table 2 one can see that, even with this more careful comparison, N-WDP
outperforms ERM. On the other hand, NR looks similar to ERM on MED and COMP, and worse than
ERM on SING.

25

