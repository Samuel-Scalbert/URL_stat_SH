Fragments of bag relational algebra: Expressiveness and
certain answers
Marco Console, Paolo Guagliardo, Leonid Libkin

To cite this version:

Marco Console, Paolo Guagliardo, Leonid Libkin. Fragments of bag relational algebra: Expressiveness
￿hal-
and certain answers.
03934340￿

Information Systems, 2022, 105, pp.101604.

￿10.1016/j.is.2020.101604￿.

HAL Id: hal-03934340

https://inria.hal.science/hal-03934340

Submitted on 5 Dec 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Information Systems xxx (xxxx) xxx

Contents lists available at ScienceDirect

Information Systems

journal homepage: www.elsevier.com/locate/is

Fragments of bag relational algebra: Expressiveness and certain
answers✩,✩✩
Marco Console, Paolo Guagliardo
School of Informatics, University of Edinburgh, United Kingdom

∗
, Leonid Libkin

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 20 November 2019
Received in revised form 1 June 2020
Accepted 17 July 2020
Available online xxxx
Recommended by Gottfried Vossen

Keywords:
Bag semantics
Relational algebra
Expressiveness
Certain answers
Complexity

1. Introduction

While all relational database systems are based on the bag data model, much of theoretical research
still views relations as sets. Recent attempts to provide theoretical foundations for modern data
management problems under the bag semantics concentrated on applications that need to deal with
incomplete relations, i.e., relations populated by constants and nulls. Our goal is to provide a complete
characterization of the complexity of query answering over such relations in fragments of bag relational
algebra. The main challenges that we face are twofold. First, bag relational algebra has more operations
than its set analog (e.g., additive union, max-union, min-intersection, duplicate elimination) and the
relationship between various fragments is not fully known. Thus we first fill this gap. Second, we look
at query answering over incomplete data, which again is more complex than in the set case: rather
than certainty and possibility of answers, we now have numerical information about occurrences of
tuples. We then fully classify the complexity of finding this information in all the fragments of bag
relational algebra.

© 2020 Elsevier Ltd. All rights reserved.

While all relational database management systems (DBMSs)
use bags as the basis of their data model, much of relational
database theory uses a model based on sets, thus disallowing rep-
etitions of tuples. The presence of duplicates in real-life databases
is a very important consideration that is reflected in practically
all aspects of data management, such as querying, storing, and
accessing data [2,3]. Theoretical research has raised this issue
several times. By the early 1990s there was agreement on what
the standard collection of bag relational algebra operations is [4],
and in the mid 1990s their expressiveness and complexity were
thoroughly studied [5,6], albeit in the context of the model of
nested relations, or complex objects, which was the research
focus back then [7,8]. Around the same time it was noticed that
the well developed theory of query optimization, especially for
conjunctive queries, does not apply to bag semantics [9], and de-
spite many attempts and partial results [10,11], the key problem

✩
✩✩

∗

Work supported by EPSRC, United Kingdom grants M025268 and N023056.

This is the full version of a paper of the same title that appeared in
the proceedings of ICDT 2019, the 22nd International Conference on Database
Theory [1]. This work was also presented at AMW 2019, the 13th Alberto
Mendelzon International Workshop on Foundations of Data Management, where
it was invited to this special issue.

Corresponding author.
E-mail addresses: mconsole@ed.ac.uk (M. Console),

paolo.guagliardo@ed.ac.uk (P. Guagliardo), libkin@inf.ed.ac.uk (L. Libkin).

https://doi.org/10.1016/j.is.2020.101604
0306-4379/© 2020 Elsevier Ltd. All rights reserved.

of the decidability of such optimizations remains unsolved [12].
Other languages, in particular those with aggregates and fixpoints
in the spirit of Datalog, have been studied under bag semantics
as well [6,13,14].

More recently, bag semantics has been considered in modern
data management applications that combine traditional databases
and reasoning tasks. In [15], fundamental problems of data inte-
gration and data exchange are studied under bag semantics and
are shown to differ rather drastically from their set semantics
counterparts. In [16], a similar program is carried out for ontol-
ogy based data access (OBDA), where an ontology supplements
information provided by a relational database in which dupli-
cates are allowed. What is common to these applications is that
in both of them one needs to query incomplete data, that is,
databases with null values. The standard approach to querying
such databases, which is used in data integration, data exchange,
and OBDA applications, is based on the classical notion of certain
answers [17].

However, when it comes to bags, the notion of certain answers
becomes more complex than under set semantics. In general, an
= {D1, D2, . . .}
incomplete database D represents a collection
of complete databases, obtained by interpreting incomplete data
in D. A tuple ¯a is a certain answer to a query q if it is in q(D′) for
every D′ ∈
; see [17,18]. Under bag semantics, we have more
D
information: for each tuple, we know the number #(¯a, q(D′)) of
(cid:75)
(cid:74)
occurrences of ¯a in q(D′). Thus, as D′ ranges over
, we have a
D
(cid:75)
(cid:74)
range of numbers that define an interval between
#(¯a, q(D
min(¯a, q, D) = min
D

D
(cid:74)

))

(cid:75)

′

D′∈
(cid:74)

(cid:75)

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

2

and

max(¯a, q, D) = max
D

D′∈
(cid:74)

(cid:75)

#(¯a, q(D

′

)).

Under set semantics, min(D, q, ¯a) = 1 means that ¯a is a
certain answer to q on D, and max(D, q, ¯a) = 1 means that ¯a
is a possible answer. On sets, these can be easily checked for
positive relational algebra, but it is hard (coNP-complete and
NP-complete, respectively) for full relational algebra [19]. This
tells us that, in terms of relational algebra operations, selection,
projection, Cartesian product and union are easy, but difference
makes things hard. Our goal is to paint a similar picture for bags.
The problems that we face are:

(1) there are more operations that are included in bag rela-
tional algebra, and we have less understanding of them;
(2) even for basic operations, there is very little knowledge of
the complexity of answering queries over incomplete data.

We now explain these points in more detail.

Bag algebra fragments. Under set semantics, we have well un-
derstood fragments of relational algebra: SPC (select-project-
Cartesian product) queries, positive relational algebra RA+ that
adds union, and full relational algebra RA that adds difference.
Moreover, intersection is expressible as the natural join of two
relations over the same attributes. Under bag semantics, however,
the situation is different:

• SPC queries follow their set-theoretic analogs but they keep

duplicates.

• For union, there are two options: max-union, which takes
the maximum number of occurrences of a tuple, and additive
union, which adds up multiplicities (and corresponds to
UNION ALL in SQL).

• Intersection (SQL’s INTERSECT ALL) takes the minimum
number of occurrences of a tuple and it can no longer be
expressed as a join in general.

• Difference (SQL’s EXCEPT ALL) subtracts multiplicities of

tuples up to zero.

Example 1. For bags R = {a, a, b, b, c} and S = {a, b, b, b}, we
have:
R ⊎ S = {a, a, a, b, b, b, b, b, c} ;
R ∪ S = {a, a, b, b, b, c} ;
R ∩ S = {a, b, b} ;

R − S = {a, c} ;
ε(R) = {a, b, c} ,
ε(S) = {a, b} .

We remark that, differently from additive union ⊎, the max-union
operation ∪ is not explicitly implemented in any standard query
language. To see how it could be used in practice, consider a
scenario with two sensors, r and s, logging data about events
a1, a2, etc. into unary relations R and S, as follows: whenever an
event ai is detected by r (resp., s), an occurrence of ai is added
to R (resp., S). Now assume that for any given event, one of the
sensors can reliably detect all of its occurrences, while the other
may, or may not. Then, R ∪ S correctly collates the data from the
two sensors’ logs, returning all the reliably detected occurrences
of every event, but R ⊎ S does not.

To understand how query answering behaves in the fragments
of RA, we first need to understand their relative expressiveness.
It might appear that these questions have already been answered
in [6,20]. However, this was done in the context of nested rela-
tions, and the results used the power of nesting in an essential
way. For the usual bag algebra with non-nested relations, as
implemented in all DBMSs, these basic results are surprisingly
lacking. Thus, as our first task, we shall produce a full picture of
the expressiveness of bag relational algebra fragments (which will
indeed be different from the known results in the nested case).

Incomplete information and bags. There is a much bigger variety
of relational algebra fragments for bags, but little is known about
finding min(¯a, q, D) and max(¯a, q, D) for queries in those frag-
ments. We know that min is easy to compute for RA+ queries
and that for full RA the problem is computationally hard: check-
ing whether min(¯a, q, D) ≥ n is NP-complete [19,21]. Checking
whether max(¯a, q, D) ≥ n is NP-complete even for SPC queries
[21]. The complexity of actually computing min and max (or, in
terms of a decision problem, checking whether min(D, q, D) = n,
and likewise for max) is still open.

• There is the duplicate elimination operation, which sets the

Outline of the results. Our main results are summarized in Fig. 1.

multiplicities of tuples to 1.

When the multiplicities of tuples in the input relations are
at most 1, the bag operations of difference, intersection and
max-union coincide with set-theoretic difference, intersection
and union, respectively. SQL’s EXCEPT, INTERSECT and UNION
(without the ALL modifier) are variants of difference, intersection
and max-union, respectively, that treat input relations as sets
by removing duplicates from them; UNION can also be seen as
additive union followed by duplicate elimination.

The language RA of bag relational algebra consists of the

following operations [4–6]:

• multiplicity-preserving versions of selection (σ ), projection
(π ) and Cartesian product (×), which form the class of SPC
queries;

• additive union ⊎ that adds up multiplicities of tuples; to-
gether with SPC queries it forms the positive relational al-
gebra RA+;

• max-union ∪ that keeps the maximum number of occur-

rences of a tuple;

• min-intersection ∩ that keeps the minimum number of oc-

currences of a tuple;

• difference − that subtracts the number of occurrences of a
tuple up to zero, i.e., #(¯a, R−R′) = max(#(¯a, R)−#(¯a, R′), 0);

• duplicate elimination ε that turns a bag into a set.

Expressiveness We characterize the relative expressive power
of RA fragments, as shown in the diagram. Furthermore, adding
duplicate elimination to a fragment that does not have it results
in a language that is strictly more expressive (than the origi-
nal fragment), and incomparable with RA+{−} (i.e., RA+ with
difference). The relative expressiveness of bag operations is in-
deed different from what was known in the nested relational
case [5,6,20]. For example, over nested relations, adding min-
intersection to the analog of RA+ suffices to express max-union,
but in the usual relational algebra over bags these two operations
are incomparable in their expressiveness.

Complexity of min For fragments in the shaded area, comput-
ing min(¯a, q, D) is tractable, and it can be done by evaluating
the query naively on the incomplete database. For all fragments
outside the shaded area, and all fragments with duplicate elimi-
nation (from SPC{ε} to the full RA), the complexity is intractable:
checking whether min(¯a, q, D) θ n is NP-complete when θ is ≤,
coNP-complete when θ is ≥, and DP-complete when θ is = .
Recall that DP is the class of problems that are the intersection
of an NP problem and a coNP problem [22].

Complexity of max For all the fragments, inside and outside the
shaded area, and with or without duplicate elimination, comput-
ing max is intractable: checking max(¯a, q, D) θ n is NP-complete
when θ is ≥, coNP-complete when θ is ≤, and DP-complete when
θ is =.

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

3

Fig. 1. Summary of the results. An edge indicates a more expressive fragment. Adding duplicate elimination makes every fragment more expressive, and incomparable
with RA+{−}. Extending RA+{−} with duplicate elimination results in a fragment that has the expressive power of full RA. The shaded area includes the fragments
for which computing the minimum occurrences of certain answers is tractable, while this is intractable whenever duplicate elimination is added. Computing the
maximum number of occurrences is intractable for all fragments.

Organization. Bag relational algebra is defined in Section 2, and
the relative expressive power of its fragments is studied in Sec-
tion 3. Query answering over bags with nulls is discussed in
Section 4, and its complexity is classified in Section 5. Concluding
remarks are given in Section 6.

2. Bag relational algebra

We now describe the standard operations of bag relational al-
gebra and provide their semantics [4–6,20]. A bag is a collection of
elements with associated multiplicities (numbers of occurrences);
if an element b occurs n times in a bag B, we write #(b, B) = n.
If #(b, B) = 0, it means that b does not occur in B. Sets are just a
special case when #(b, B) ∈ {0, 1}.

In a database D, each k-ary relation name R of the schema is
associated with a bag RD of k-tuples; we will omit the superscript
D whenever it is clear from the context. We assume that the
attributes of a k-ary relation are 1, . . . , k, i.e., we adopt the
unnamed perspective [18].

Syntax. The syntax of relational algebra (RA) expressions is de-
fined as follows:

′

e, e

::= R

| σi=j(e)
| πα(e)
′
e × e
|
′
e ⊎ e
|
e ∪ e
|
e ∩ e
|
|
e − e
| ε(e)

′

′

′

(base relations)

(selection)

(projection)

(Cartesian product)

(additive union)

(max-union)

(intersection)

(difference)

(duplicate elimination)

where i and j in σi=j(e) are positive integers, and α in πα(e) is a
possibly empty tuple of positive integers.

The arity of RA expressions is defined as follows: for base
relations, it is given by the schema; for σi=j(e) and ε(e), it is the
arity of e; for πα(e), it is the arity of α; for e × e′, it is the sum
of the arities of e and e′; for e ⋆ e′ with ⋆ ∈ {∪, ⊎, ∩, −}, it is the
arity of e.

We then say that an RA expression is well-formed w.r.t. a
schema if: it mentions only relation names from the schema;
i and j in σi=j(e) are less than or equal to the arity of e; the
elements of α in πα(e) are less than or equal to the arity of e;
the expressions e and e′ in e ⋆ e′, with ⋆ ∈ {∪, ⊎, ∩, −}, have the
same arity. In the rest of the paper, we implicitly assume that we
are always working with well-formed RA expressions.

Semantics. We give the semantics of (well-formed) RA expres-
sions e by inductively defining the quantity #(¯a, e, D), which is
the number of occurrences of a tuple ¯a (of appropriate arity) in
the result of applying e to a database D. This is done as follows:

#(¯a, R, D) = #(¯a, RD)

#(¯a, σi=j(e), D) =

{#(¯a, e, D)
0

#(¯a, πα(e), D) = ∑

#(¯a

if ¯a.i = ¯a.j
otherwise
′, e, D)

#(¯a¯a

′, e × e
#(¯a, e ⊎ e
#(¯a, e ∪ e
#(¯a, e ∩ e
#(¯a, e − e

¯a′:πα (¯a′)=¯a
′, D) = #(¯a, e, D) · #(¯a
′, D)
′, e
′, D) = #(¯a, e, D) + #(¯a, e
′, D)
′, D) = max{ #(¯a, e, D), #(¯a, e
′, D) = min { #(¯a, e, D), #(¯a, e
′, D) = max{ #(¯a, e, D) − #(¯a, e

′, D) }
′, D) }
′, D), 0 }

#(¯a, ε(e), D) = min { #(¯a, e, D), 1 }

where ¯a.i denotes the ith element of ¯a, πi1,...,in (¯a) is the tuple
(¯a.i1, . . . , ¯a.in), and the tuples ¯a and ¯a′ in the rule for e × e′ have
the same arity as e and e′, respectively.

Then, for an expression e and a database D, we define e(D) as
the bag of tuples ¯a of the same arity as e so that #(¯a, e(D)) =
#(¯a, e, D).

Fragments. The two main fragments of RA we consider are SPC,
consisting of selection (σ ), projection (π ) and Cartesian product
(×), and RA+, which is SPC extended with additive union (⊎).
, . . . , opn} to denote
Given a fragment L of RA, we write L{op1
, . . . , opn
the fragment obtained by adding the RA operations op1
to L. Thus, for instance, RA+ is SPC{⊎}.

A query is a mapping q from databases to bags of tuples. We
always assume that queries are generic, that is, invariant under
permutations of the domain [18]. A query q is expressible in a
fragment L of RA if there is an expression e in that fragment so
that e(D) = q(D) for every database D.

Then, given two fragments L and L′, we say that L′ is at least
as expressive as L, and write L ⊆ L′, if every query expressible in
L is also expressible in L′. We say that L′ is more expressive than
L, and write L ⊊ L′, if L′ is at least as expressive as L and there
is a query that is expressible in L′ but not in L. Notice that if L′
has all the operations of L, then L′ is at least as expressive as L.

3. Expressive power of bag relational algebra fragments

In this section, we study the relative expressiveness of RA
fragments. We present the results that justify the edges in Fig. 1,
along with additional results that are not explicitly captured in
that diagram.

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

4

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

We start by showing that extending positive relational algebra
with max-union or intersection results in a more expressive
fragment.

Proposition 1. RA+ ⊊ RA+{⋆} for ⋆ ∈ {∪, ∩}.

Proof. Trivially RA+{⋆} is at least as expressive as RA+, so we
only need to show that there exists a query that is expressible
in the former but not in latter. To this end, consider a schema
consisting of two nullary (i.e., of arity 0) relation symbols R and
S, and suppose that R ⋆ S is expressible in RA+, i.e., there exists
an RA+ expression e equivalent to R ⋆ S. For a database D, let
m = |RD| and n = |SD|; then, |e(D)| = f⋆(m, n), where f∪ = max
and f∩ = min. Moreover, |e(D)| is expressible by a polynomial
pe ∈ N[m, n], because e ∈ RA+ [23].

For n0 ∈ N, we define the polynomial p ∈ N[m] such that

p(m) = pe(m, n0) and distinguish the following two cases.

• When ⋆ = ∪, let n0 = deg(pe) ≥ deg(p). Then, p(m) =
max(m, n0) = n0 for every m ∈ {0, . . . , n0}. But this is
impossible, as the unique polynomial ˜p ∈ N[m] of degree
at most n0 that interpolates the n0 + 1 data points {(i, n0) |
i = 0, . . . , n0 } is the constant function ˜p(m) = n0, and
˜p(m) ̸= p(m) for m > n0.

• When ⋆ = ∩, let n0 be a positive integer. We have deg(p) ≥
1, as p(m) = min(m, n0) = n0 > 0 for every m ≥ n0,
while p(0) = 0. Then p is strictly increasing in the interval
[0, +∞), since its coefficients are in N. But this is impossible
because p(m) = n0 for every m ≥ n0. □

The proof of Proposition 1 also applies to show the following.

Corollary 1. SPC ⊊ SPC{⋆} for ⋆ ∈ {∪, ∩}.

We now show that additive union increases the expressive

power of SPC{∩} and SPC{∪}.

Proposition 2. SPC{⋆} ⊊ RA+{⋆} for ⋆ ∈ {∪, ∩}.

The proof of the above result is based on the fact that, on
databases consisting of nullary relations of size 1, there are RA+
expressions whose results size is greater than 1, whereas every
SPC{∪, ∩} expression can only yield a (nullary) relation of size 1,
as the following lemma shows.

Lemma 1.
Let D be a database over a schema consisting only of
nullary relation names and such that RD = {()} for every relation
name R in the schema. Then, for every SPC{∪, ∩} expression e, it is
the case that e(D) = {()}.

Proof. Let e be an SPC{∪, ∩} expression over the schema of D.
Observe that all subexpressions of e are nullary and, since there
are no attributes, none of them can be a selection. Moreover,
projection will be over an empty list of attributes and so it can be
discarded. Thus, assuming w.l.o.g. that there is no projection, we
proceed by induction on the structure of e to show that e(D) =
{()}.

The base case is when e is a relation name R; then trivially
e(D) = RD = {()}. For the inductive step, we have that e = e1 ⋆ e2
with ⋆ ∈ {×, ∪, ∩} and, by the inductive hypothesis, e1(D) =
e2(D) = {()}. Then, from the semantics of ×, ∩ and ∪, we get
e(D) = e1(D) ⋆ e2(D) = {()}. □

Proof of Proposition 2. Let ⋆ ∈ {∪, ∩}. Trivially RA+{⋆} is at least
as expressive as SPC{⋆}, thus we only need to show that there is
a query expressible in the former but not in latter. To this end,
consider a schema consisting of a nullary relation name R, and
suppose that e = R⊎R (which, in particular, is an RA+ expression)

is expressible in SPC{⋆}, i.e., there exists an SPC{⋆} expression e′
equivalent to e. Towards a contradiction of this equivalence, let D
be a database where RD = {()}. Then, since e′ is an SPC{∪, ∩}
expression, by Lemma 1 we have that e′(D) = {()}, whereas
e(D) = {(), ()}. □

In particular, the proof of Proposition 2 also applies to show

the following.

Corollary 2. SPC ⊊ RA+.

Next, we will show that ∪ increases the expressive power of
RA+{∩}, and ∩ increases the expressive power of RA+{∪}. In turn,
this implies that ∪ and ∩ are incomparable operations.

Proposition 3. RA+{⋆} ⊊ RA+{∪, ∩} for ⋆ ∈ {∪, ∩}.

To prove the above, we need some additional notions and
lemmas. We start by introducing a special syntactic form for
RA+{∩} expressions.

Definition 1. An RA+{∩} expression is in intersection normal form
(∩-NF) if it is of the form e1 ∩ · · · ∩ en where each ei is an
RA+ expression. Observe that this is well defined because ∩ is
commutative and associative.

Lemma 2.
can be equivalently rewritten to ∩-NF.

Every RA+{∩} expression over nullary relation names

Let e be an RA+{∩} expression over nullary relation
Proof.
names. As before, note that all subexpressions of e are nullary
and, since there are no attributes, none of them can be a selection.
Moreover, projection will be over an empty list of attributes and
therefore it can be discarded. Assuming w.l.o.g. that there is no
projection, we proceed by induction on the structure of e.

Base case: e is R. Then R ∩ R is obviously equivalent to e and in
∩-NF.
Inductive step: e is e′ ⋆ e′′ with ⋆ ∈ {⊎, ×}. By the induction
hypothesis, there are ∩-NF expressions e′
∩· · ·∩e′′
n
1
equivalent to e′ and e′′, respectively. Then, the following ∩-NF
expression:

m and e′′

∩· · ·∩e′

1

m
⋂

n
⋂

(e

)

′
i

⋆ e

′′
j

i=1

j=1

is equivalent to e because:
(min(x1, . . . , xm), min(y1, . . . , yn))
= min(f⋆(x1, y1), . . . , f⋆(x1, yn), . . . , f⋆(xm, y1), . . . , f⋆(xm, yn))

f⋆

where:

• f×(x, y) = x · y and f⊎(x, y) = x + y; and,
• for any given database D, we have that each xi = |e′

i(D)| and

each yj = |e′′

j (D)|. □

The proofs of the next two lemmas can be found in Appendix.

Lemma 3.
Let D be a database over a schema with a nullary
relation symbol R, and let e be an RA+{∪} expression that mentions
only R. Then, |e(D)| ≥ |RD|.

Lemma 4.
Let D be a database over a schema consisting of two
nullary relation symbols R and S, and let e be an RA+{∪} expression
that mentions both R and S. Then, |e(D)| ≥ |RD| and |e(D)| ≥ |SD|.

We are now ready to prove the result on the expressiveness

of RA+{∪, ∩} stated earlier.

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

5

Proof of Proposition 3.

• RA+{∪} ⊊ RA+{∩, ∪}

Trivially RA+{∩, ∪} is at least as expressive as RA+{∪};
therefore, we only need to show that there exists a query
expressible in RA+{∩, ∪} that is not expressible in RA+{∪}.
To this end, consider a schema consisting of two nullary
relation symbols R and S, and the RA+{∩, ∪} expression
e = R ∩ S. Towards a contradiction, suppose that e is ex-
pressible in RA+{∪}, i.e., there exists an RA+{∪} expression
e′ equivalent to e.
Let us first consider the case when e′ mentions only either
R or S; w.l.o.g., say R. Take D such that |RD| > |SD|; then
|e(D)| = |SD|, and |e′(D)| ≥ |RD| by Lemma 3. Therefore,
|e′(D)| > |e(D)|, which contradicts the equivalence of e and
e′.
When e′ mentions both R and S, we can again take D such
that |RD| > |SD|, which leads to the same contradiction,
since |e(D)| = |SD|, and |e′(D)| ≥ |RD| by Lemma 4.

Trivially RA+{∩, ∪} is at least as expressive as RA+{∩};
therefore, we only need to show that there exists a query
expressible in RA+{∩, ∪} that is not expressible in RA+{∩}.
To this end, consider a schema consisting of two nullary
relation symbols R and S, and the RA+{∩, ∪} expression e =
R ∪ S. Towards a contradiction, suppose that e is expressible
in RA+{∩}, i.e., there exists an RA+{∩} expression e′ equiv-
alent to e. By Lemma 2, e′ is equivalent to an expression of
the form e1 ∩ · · · ∩ ek where each ei is an RA+ expression.
Then, for every database D, whenever m = |RD| and n = |SD|
we have that

• RA+{∩} ⊊ RA+{∩, ∪}

max(m, n)



|e(D)|

= min(p1, . . . , pk

)




|e′(D)|



where each pi is a bivariate polynomial in N+[m, n]. Let d
be the maximum degree of a polynomial among p1, . . . , pk,
and let n0 = (d + 1)k + 1. Then for each m < n0 we have
n0 = max(m, n0) = min(p1(m, n0), . . . , pk(m, n0)). Consider
now univariate polynomials p′
i(m) = pi(m, n0) − n0 for i ≤ k.
k(m)) for all
We have 0 = n0 − n0 = min(p′
m < n0. By pigeonhole, it means that there is a polynomial
p′
j(m) and at least d + 1 distinct values m1, . . . , md+1 smaller
than n0 such that p′
j(md+1) = 0. Since the
degree of p′
j(m) is identically
zero, and thus pj(m, n0) = n0 for all m.
Now, using max(m, n) = min(p1(m, n), . . . , pk(m, n)), we
have
n0 + 1 = max(n0 + 1, n0)

j(m1) = . . . = p′
j is at most d, this implies that p′

1(m), . . . , p′

= min(p1(n0 + 1, n0), . . . , pk(n0 + 1, n0))
≤ pj(n0 + 1, n0) = n0 ,

which contradicts the assumption that ∪ is expressible in
RA+{∩}. □

The following is a direct consequence of Proposition 3.

Corollary 3. L{∪} and L{∩} are incomparable, for L ∈ {SPC, RA+}.

Finally, we show that with additive union and difference one
can express both intersection and max-union, therefore RA+{−}
is the most expressive fragment of RA without duplicate elimina-
tion.

Proposition 4. RA+{∩, ∪} ⊊ RA+{−}.

Proof. Let e ∈ RA+{∩, ∪}; by induction on the structure of e
we will show that there exists an expression e′ ∈ RA+{−} that
is equivalent to e. The base case is when e ∈ RA+, which is
trivially also in RA+{−}. For the inductive step, let e = e1⋆e2, with
e1, e2 ∈ RA+{∩, ∪} and ⋆ ∈ {∩, ∪}. By the induction hypothesis,
, e′
there exist e′
≡ ei for i = 1, 2. Consider
2
1
the RA+{−} expressions e∩ = e′
2) and e∪ = e′
1);
we will show that e⋆ ≡ e1 ⋆ e2 for ⋆ ∈ {∩, ∪}. To this end, let D
be a database and let ¯a be a tuple; moreover, let m = #(¯a, e′
, D)
1
and n = #(¯a, e′
2

∈ RA+{−} such that e′
i
−e′

−(e′
1

⊎(e′
2

, D). Then, we have the following:
, D) ´ (#(¯a, e

, D) ´ #(¯a, e

k∩ = #(¯a, e∩, D) = #(¯a, e

−e′

1

1

, D))

′
2

′
1

′
1

= m ´ (m ´ n)

k∪ = #(¯a, e∪, D) = #(¯a, e

, D) + (#(¯a, e

′
2

′
1

, D) ´ #(¯a, e

, D))

′
1

= m + (n ´ m)

If m ≥ n, we have that 0 ≤ m ´ n = m − n ≤ m and n ´ m = 0,
therefore k∩ = m − (m − n) = n and k∪ = m. Otherwise, when
n > m, we have that m ´ n = 0 and n ´ m = n − m, so
k∩ = m ´ 0 = m and k∪ = m + n − m = n. Thus, k∩ = min(m, n)
and k∪ = max(m, n).
Now, since e′
1

≡ e2 by the induction hypothesis,
#(¯a, e1, D) = m and #(¯a, e2, D) = n. Hence, for ⋆ ∈ {∩, ∪}, we
have k⋆ = #(¯a, e1 ⋆ e2, D) and, as D and ¯a were chosen arbitrarily,
e⋆ ≡ e1 ⋆ e2. This proves that RA+{∩, ∪} ⊆ RA+{−}.

≡ e1 and e′

2

We are left to show that the containment is strict. This follows
from the fact that every query q expressible in RA+{∩, ∪} is
monotonic, that is, q(D) ⊆ q(D′) for all databases D and D′ such
that D ⊆ D′. However, in RA+{−}, one can express queries that
are not monotonic. Indeed, consider e = R− S over unary relation
names R and S, and let D = {R(a), S(b)} and D′ = {R(a), S(a), S(b)};
then, D ⊆ D′ but e(D) = {R(a)} ̸⊆ e(D′) = ∅. □

Then, obviously, we immediately get the following.

Corollary 4. RA+{−, ε} and RA have the same expressive power.

We conclude this section by showing that adding duplicate
elimination to a fragment that does not already have it increases
its expressive power.

Proposition 5. L ⊊ L{ε} for every fragment L of RA without
duplicate elimination.

The proof of Proposition 5 is based on the fact that, on
databases with relations of even size, every RA+{−} expression
can only yield a relation of even size, as the following lemma
shows.

Lemma 5.
Let L be a fragment of bag relational algebra without
duplicate elimination, let e be an RA+{−} expression, and let D
be a database such that, for every relation name R, the number
of occurrences of every tuple in RD is even. Then, the number of
occurrences of every tuple in e(D) is even.

Let ¯a be a tuple that occurs k times in e(D), and let
Proof.
k > 0 (for k = 0 we have nothing to show). By induction on
the structure of e, we will show that k is even.
Base case: e is a relation name R. Then, k = #(r, RD) is even by
assumption.

Inductive step:

• e = πα(e′). Then, k is the sum of the number of occurrences
of all tuples ¯a′ ∈ e′(D) such that πα(¯a′) = ¯a. The number of
occurrences of every tuple in e′(D) is even by the induction
hypothesis, hence k is even as well.

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

6

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

• e = σi=j(e′). Then k = #(¯a, e′, D), which is even by the

induction hypothesis.

• e = e1 × e2. Then, there are tuples ¯a1 ∈ e1(D) and ¯a2 ∈ e2(D)
such that ¯a = ¯a1 ¯a2 and k = m · n, where m = #(¯a1, e1, D)
and n = #(¯a2, e2, D). As k > 0, both m and n are positive
and, by the induction hypothesis, even. Hence, k is even as
well.

• e = e1 ⊎ e2. Then, k = m + n where m = #(¯a, e1, D) and
n = #(¯a, e2, D). Since k > 0, at least one of m and n must
be positive. Assume w.l.o.g. that m > 0; then, m is even
by the induction hypothesis. If n = 0, then k = m is even;
otherwise, n is even by the induction hypothesis as well, and
therefore k is the sum of two positive even numbers, which
is obviously even.

• e = e1 − e2. Then, k = m ´ n where m = #(¯a, e1, D) and
n = #(¯a, e2, D). As k > 0, we have that m > n; in turn, m
is positive and, by the induction hypothesis, even. If n = 0,
then k = m is even; otherwise, n is even as well by the
induction hypothesis, so k = m − n is obviously even. □

Proof of Proposition 5. Let L be a fragment of bag relational
algebra without duplicate elimination. Clearly, L{ε} is at least as
expressive as L, so we only need to show that there exists a query
that is expressible in the former but not in latter. To this end,
consider a schema consisting of a nullary relation name R, and
take any database D such that |RD| is a positive even number.
Then, for every L expression over R, we have that |e(D)| is even
by Lemma 5. Hence, the L{ε} expression ε(R) is not expressible
in L, since |ε(RD)| = 1. □

4. Certain and possible answers under bag semantics

Dealing with incomplete information is a recurring topic in
many different areas of logic and computer science. In database
theory, the main way to deal with the lack of information is via
incomplete databases. Intuitively, an incomplete database D is a
of
compact representation of a possibly infinite collection
complete databases, which define the semantics of D.

D
(cid:75)
(cid:74)

In this paper, we use incomplete databases with marked (or
labeled) nulls. This model of incompleteness is very common
in the database literature [17,18] and naturally occurs in many
different scenarios, e.g., in data exchange and integration (cf. [24–
26]). In this model databases are populated by constants and nulls,
coming from two disjoint and countably infinite sets denoted by
Const and Null, respectively. More formally, a k-ary relation is a
finite bag of k-ary tuples over Const ∪ Null. A database D then
maps each k-ary relation symbol R in the schema to a k-ary bag
}, we write Const(D)
relation RD. Given a database D = {RD
1
and Null(D) for the set of constants and nulls occurring in the RD
i s,
respectively. The active domain of D is the set Const(D) ∪ Null(D),
denoted by adom(D). We say that D is complete if Null(D) = ∅.

, . . . , RD
n

(cid:75)

D
(cid:74)

The semantics

of a database D is defined by means of
valuations. A valuation v is a map v: Null(D) → Const, and the
result of applying v to D is the complete database v(D) obtained
by replacing each null ⊥ ∈ Null(D) with v(⊥). Observe that
applying v to each relation RD in D preserves multiplicities, i.e., for
v(D) the
each relation name R in the schema and each tuple ¯c ∈ R
following equality holds:
v(D)) = ∑
#(¯c, R
¯a:v(¯a)=¯c

#(¯a, RD).

The set

is defined as

= {v(D) | v is a valuation}.

D
(cid:74)

(cid:75)

D
(cid:75)
(cid:74)

When relations are sets, the standard way to answer a query
q on an incomplete database D is to compute certain answers,
i.e., tuples that are in q(D′) for every D′ ∈
, and possible
D
answers, i.e., tuples that are in q(D′) for some D′ ∈
(cid:75)
(cid:74)
. When
D
(cid:75)
(cid:74)

relations are bags, however, one must also take multiplicities into
account. In what follows, this is done by computing the minimum
and maximum number of occurrences of a tuple in the answers
across all databases in
(cf. [21]). Let D be a database, let q be
a relational algebra expression of arity n, and let ¯a ∈ Const(D)n
be a tuple of constants, we define min(¯a, q, D) and max(¯a, q, D)
as follows:

D
(cid:75)
(cid:74)

min(¯a, q, D) = min
D
(cid:74)
(cid:75)
max(¯a, q, D) = max
D

D′∈

D′∈

(cid:74)

(cid:75)

#(¯a, q(D

′

)) ;

#(¯a, q(D

′

)) .

(1a)

(1b)

(cid:75)

D
(cid:74)

Intuitively, min(¯a, q, D) and max(¯a, q, D) are extensions of cer-
tain and possible answers to bag databases. Indeed, min(¯a, q, D) ≥
1 if and only if ¯a is in q(D′) for every D′ ∈
(and thus it is a
certain answer), and max(¯a, q, D) ≥ 1 if ¯a is in q(D′) for some
D′ ∈

(and thus it is a possible answer).

D
(cid:74)

(cid:75)

Thus, from now on we assume min(¯a, q, D) and max(¯a, q, D)
as our standard notion of query answers and study their com-
plexity. More specifically, we will focus on data complexity, that
is, computing min(¯a, q, D) and max(¯a, q, D) for a fixed query q.
Depending on the type of comparison we use, several decision
problems arise from the computation of min and max. These
decision problems are defined as follows.

Problem: MIN

θ [q], for θ ∈ {>, =, <}

Inputs:

Question:

and a query q of arity n.
an incomplete database D,
a tuple ¯a ∈ Const(D)n,
a non-negative integer k.
is min(¯a, q, D) θ k?

Problem: MAX

θ [q], for θ ∈ {>, =, <}

Inputs:

Question:

and a query q of arity n.
an incomplete database D,
a tuple ¯a ∈ Const(D)n,
a non-negative integer k.
is max(¯a, q, D) θ k?

Whether the number k is represented in unary or binary form
does not matter: the results will be the same regardless. All
tractability results are shown assuming binary representation,
and all matching hardness results will be proved for the case
when k is represented in unary. The choice of inequalities, i.e., <
vs ≤ or > vs ≥, is not important: since k is an integer, ≤ k is the
same condition as < k + 1.

As for the case of certain and possible answers, the complexity
of the above problems depends on the fragment of RA in which
the query q is expressed. While for some of these fragments the
problems can be proved to be intractable, there are fragments of
RA for which computing min(¯a, q, D) is tractable and can actually
be done via naive evaluation. The naive evaluation of a query q
of arity n on a bag database D is defined as the bag obtained by
assuming that each null value in Null(D) is a distinct constant and
evaluating q directly over D. In what follows, we will denote by
naive(¯a, q, D) the number of occurrences of a tuple ¯a ∈ Const(D)n
in the result of the naive evaluation of an RA query q on an
incomplete database D. It is well known that naive(¯a, q, D) can
be computed in DLogSpace in data complexity [5,6].

Example 2. On a database with relations R = {a, ⊥1, ⊥1} and
S = {⊥1, ⊥2}, the naive evaluation of σ1=2(R × S), ε(R) and R ∩ S
gives {(⊥1, ⊥1), (⊥1, ⊥1)}, {a, ⊥1} and {⊥1}, respectively.

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

7

5. Complexity of certain and possible answers

We now turn our attention to the complexity of evaluating bag
relational algebra expressions on incomplete databases, that is,
θ [q] for queries in various
θ [q] and MAX
solving the problems MIN
fragments of RA. As already explained, these problems are natural
bag analogs of the notions of certainty and possibility over set
databases.

In Section 5.1, we first provide upper and lower bounds for full
RA. When the relation θ is < or >, the results are easily derivable
from the results for the set case in [19]; we complement them
with the exact complexity for equality.

After introducing our technical framework in Section 5.2, we
θ [q], proving the
then focus – in Section 5.3 – on the problem MIN
exact tractability boundary shown in Fig. 1. We start by showing
that in all fragments up to RA+{∩}, the value of min can be
computed by naive evaluation of queries, which extends a result
in [21]. We then show that beyond this fragment the problem
becomes intractable: NP-complete for <, coNP-complete for >,
and DP-complete for =. In particular, we show that the problem is
intractable for all fragments containing SPC{∪}, and all fragments
containing SPC{ε}.

Next, in Section 5.4, we look at MAX

θ [q]. It was shown in
[21] that for > the problem is NP-complete, even for very simple
queries. Here, we complete the picture and settle the case for =,
even when q is a query that simply returns a relation from the
database.

Finally, in Section 5.5, we discuss what happens with more

complex selection conditions in queries.

5.1. Upper and lower bounds for full RA

Before delving into the complexity of the different fragments
of RA, we briefly look at the complexity of evaluating general ex-
pressions. First, observe that RA queries are generic, i.e., invariant
under permutations of the domain. In the bag case, this is stated
as follows.

Let D and D′ be complete databases, let ρ be a
Proposition 6.
bijection between adom(D) and adom(D′) such that D′ = ρ(D), and
let q ∈ RA be a query of arity n. Then, #(¯a, q, D) = #(ρ ¯a, q, D′) for
every tuple ¯a ∈ adom(D)n.

Proof. By induction on the structure of q.

Base case:

• q = R. Trivial.

Inductive step:

• q = σγ (q′). Suppose such ρ exists. Since ρ is a bijection, ¯a
satisfies γ if and only if ρ ¯a does. If ¯a does not satisfy γ then
#(¯a, q, D) = #(ρ ¯a, q, D′) = 0. Suppose now that ¯a satisfies
γ . From the inductive hypothesis, we can conclude that
#(¯a, q′, D) = #(ρ ¯a, q′, D′) hence #(¯a, q, D) = #(ρ ¯a, q, D′).
• q = πα(q′). Assume that q′ has arity m and suppose that
there exists a bijection ρ with the properties defined above.
Let ¯b ∈ adomm(D) be a generic tuple that is equal to ¯a on
the attributes in α, then #(¯a, q, D) = ∑
¯b:πα (¯b)=¯a #(¯b, q′, D).
We now apply the inductive hypothesis and obtain that
#(¯b, q′, D) = #(ρ ¯b, q′, D′) for each such tuple. Clearly ρ ¯b
is equal to ρ ¯a on the attributes in α, proving #(¯a, q, D) ≤
#(ρ ¯a, q, D′). To prove that this is actually an equality, we
simply notice that ρ is a bijection, hence for each ¯u′ ∈
adomm(D′) there exists a tuple ¯u ∈ adomm(D) such that
¯u′ = ρ ¯u and ¯u is equal to ¯a on α if and only if ¯u′ is equal to
ρ ¯a on α.

• q = q′ × q′′. Assume that q′ has arity m′, q′′ has arity
m′′, and suppose that there exists a bijection ρ with the
properties defined above. Let ¯a1 and ¯a2 be two tuples of
arity m′ and m′′ respectively, such that ¯a = ¯a1 ◦ ¯a2, then
#(¯a, q, D) = #(¯a1, q′, D) · #(¯a2, q′′, D). From the inductive
hypothesis, #(¯a1, q′, D) = #(ρ ¯a1, q′, D′) and #(¯a2, q′′, D) =
#(ρ ¯a2, q′′, D′). The claim follows from ρ ¯a = ρ ¯a1 ◦ ρ ¯a2.

• q = ε(q′). By the inductive hypothesis, we have that
#(¯a, q′, D) = #(ρ ¯a, q′, D′). Then the claim follows from the
definition of ε.

• q = q′ ⋆ q′′, for ⋆ ∈ {∩, ⊎, ∪, −}. By the inductive hypothesis,
we have that #(¯a, q′, D) = #(ρ ¯a, q′, D′) and #(¯a, q′′, D) =
#(ρ ¯a, q′′, D′). Then, the claim follows from the definition of
∩, ⊎, ∪, and −. □

Intuitively, the above tells us that we need to take into account
only finitely many valuations in order to compute the values
in (1a) and (1b). Upper bounds of NP, coNP, and DP follow
straightforwardly.

Proposition 7.

Let q be an expression in RA. Then:

<[q] and MAX
>[q] and MAX

• MIN
• MIN
• MIN=[q] and MAX=[q] are in DP.

>[q] are in NP;
<[q] are in coNP;

Proof. Let D be an incomplete bag database, let ¯a be a tuple in
adomn(D), and let k be a positive integer. Assume a set C ⊆ Const
such that C is disjoint with adom(D) and the cardinality of C is the
same as the cardinality of Null(D). Let V be the set of valuations
for Null(D) defined as follows: V = {v | range(v) ⊆ (C∪Const(D))}.
there exists a valuation v ∈ V and a
Clearly, for each D′ ∈
bijection ρ from adom(vD) to adom(D′) such that ρ is the identity
over Const(D) and ρ(vD) = D′.

D
(cid:75)
(cid:74)

<[q] and MAX

Using this observation, to check whether min(¯a, q, D) < k we
can simply guess a valuation v′ ∈ V such that #(v′ ¯a, q, v′D) < k.
If such valuation exists, v′D is itself a witness of min(¯a, q, D) < k.
If such valuation does not exist, due to Proposition 6 we can con-
clude that there exists no v′D ∈
such that #(v′ ¯a, q, v′D) < k. A
D
(cid:74)
similar technique can be used to check whether max(¯a, q, D) > k.
From these considerations we can conclude what follows. In
>[q] for input D and k, one
order to solve MIN
can simply guess a valuation v for Null(D) and check whether
#(v ¯a, q, vD) < k and #(v ¯a, q, vD) > k respectively. To solve
>[q], one can guess a valuation v for Null(D) such that
MIN
#(v ¯a, q, vD) < k + 1 and use it as a counterexample for
<[q] can be solved by guessing a
min(¯a, q, D) > k. Similarly, MAX
valuation v for Null(D) such that #(v ¯a, q, vD) > k−1 and use it as
a counterexample for max(¯a, q, D) < k. Finally, to solve MIN=[q],
<[q] with input D, a, and
one can simply solve an instance of MIN
>[q] with input D, a, and k − 1. The
k + 1, and an instance of MIN
same technique can be used to solve MAX=[q].

(cid:75)

To prove the claim, we observe the following. For a given
valuation v, checking whether #(v ¯a, q, vD)θ k can be done in
DLogSpace in the size of D for q ∈ RA and θ ∈ {<, >}. Moreover,
valuations for Null(D) can be guessed using a number of bits that
is polynomial in the size of D. □

For general RA expressions, all of these problems are complete

in their respective classes.

Proposition 8.

Let q be an expression in RA. Then:
>[q] are NP-hard;
<[q] are coNP-hard;

<[q] and MAX
>[q] and MAX

• MIN
• MIN
• MIN=[q] and MAX=[q] are DP-hard.

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

8

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

Proof. The results for < and > follow directly from the fact
that set databases can be simulated by bag databases. Hence, the
hardness results presented in [19] apply. For =, we can show
a reduction from a very well known DP-complete problem; see
Theorem 2 for the case of MIN=[q] and Theorem 4 for the case of
MAX=[q]. □

Despite these high bounds, one may expect that some frag-
ments of RA will behave better; this is what we investigate
next.

5.2. Technical tools

To prove our results, we will use reductions from two well-
known decision problems: satisfiability (SAT) and satisfiability–
unsatisfiability (SAT-UNSAT) of propositional formulae in conjunc-
tive normal form (CNF). We use the following standard terminol-
ogy:

• a literal is a propositional variable or its negation;
• a clause is a (non-empty) disjunction of literals;
• a k-CNF formula is a conjunction of clauses, where each

clause consists of exactly k distinct literals.

We also assume that complementary literals (i.e., a propositional
variable and its negation) do not appear in the same clause; this is
without loss of generality, as such clauses can be removed with-
out compromising equivalence to the original formula. Thus, we
consider k-CNF formulae where each clause mentions precisely k
distinct variables.

We write Var(ϕ) and |ϕ| for the set of variables and the
number of clauses of ϕ, respectively. A truth assignment for ϕ is
a function from Var(ϕ) to either t (true) or f (false). The formula
ϕ is satisfiable if there exists a truth assignment that makes all of
its clauses true.

if τ (xi) = t and to ¯uf
xj

(1) For each truth assignment τ that makes C true, we add a
single occurrence of the tuple ¯u1 · · · ¯uk, where each ¯ui is
if τ (xi) = f, and the
equal to ¯ut
xi
variables are considered in the order we assumed on Var.
(2) We then remove duplicates from the resulting relation,
which amounts to considering only truth assignments that
are unique with respect to what they assign to the variables
mentioned in the clause C we are encoding.
If the clauses of ϕ are C1, . . . , Cn, we define Rϕ = ⨄n

j=1 enc(Cj).
Note that the number of tuples in each enc(Cj) is exactly 2k − 1
and so the total number of tuples in Rϕ is |ϕ|·(2k −1). Thus, when
k is considered fixed, the size of Rϕ is polynomial w.r.t. the size
of ϕ.

Example 4. The encoding Rϕ of the 3-CNF formula (2), assuming
the ordering x1 < x2 < x3 < x4 and the mapping ρ(xi) = ⊥i for
i ∈ {1, . . . , 4}, is as follows:
⊥2
⊥1
0
0
⊥2 ⊥4
⊥1
0
⊥1 ⊥2
0
1
⊥4
⊥1 ⊥2
1
⊥2 ⊥4
0
1
⊥2
0
1
1
⊥4
⊥2
1
1

⊥4
1
⊥4
1
1
⊥4
1

0
0
0
0
⊥1
⊥1
⊥1

⨄





0
0
0
⊥1
⊥1
⊥1
⊥1


enc(C1)

⊥1
0
⊥1
0
⊥1 ⊥2
0
1
0
1
⊥2
1
⊥2
1

⊥2
0
⊥2 ⊥3
0
1
⊥2
0
⊥2 ⊥3
0
1
⊥3
1


enc(C2)





⊥3
1
⊥3
⊥3
1
⊥3
1

The relations Rϕ enjoy the following properties that will be

(2)

central in our proofs.

Example 3. The following 3-CNF formula
ϕ = (¬x1 ∨ x2 ∨ x4)


∧ (x1 ∨ ¬x2 ∨ ¬x3)


C2


C1





has two clauses, C1 and C2, each consisting of three literals. We
have Var(ϕ) = {x1, x2, x3, x4} and |ϕ| = 2. The formula is
satisfiable because there is a truth assignment that makes both
C1 and C2 true; e.g., the one mapping every variable in Var(ϕ) to
t.

We let k-SAT refer to the problem of checking whether a given
k-CNF formula is satisfiable; this problem is well known to be
NP-complete for k ≥ 3. Given two k-CNF formulae ϕ and ψ , SAT-
UNSAT is the problem of checking whether ϕ is satisfiable while
ψ is not. For k ≥ 3, this is known to be DP-complete [22].

In our reductions, we will use CNF formulae encoded as re-
lations. To this end, we assume that formulae are built from a
countably infinite and linearly ordered set Var of propositional
variables. Assuming a bijection ρ from Var to Null, for each
variable x ∈ Var we define the pairs:
x = (0, ρ(x)) ,
¯ut
= (ρ(x), 1) .
¯uf
x
x do not unify: there exists no valuation v of
Observe that ¯ut
nulls such that v(¯ut
x) = (0, 1). We denote concatenation
of tuples, in particular of pairs of the above form, by juxtaposi-
tion; for example, ¯ut
x

z is the tuple (0, ρ(x), ρ(y), 1, ρ(z), 1).
¯uf

Given a k-CNF formula ϕ, with each clause C of ϕ we associate

x) = v(¯uf

x and ¯uf

(3b)

(3a)

¯uf
y

a relation enc(C ) of arity 2k constructed as follows:

Lemma 6.

For every k-CNF formula ϕ, all of the following hold:

(a) Let R be the relation that encodes a clause of ϕ. Then, for every

valuation v of nulls, #((0, 1)k, v(R)) ≤ 1.

(b) Let v be a valuation with range in {0, 1}, and let τ be the
truth assignment such that, for each x ∈ Var(ϕ), τ (x) = t iff
v(ρ(x)) = 1. Then, τ makes a clause C of ϕ true if and only
if #((0, 1)k, v(R)) = 1, where R = enc(C ).

(c) There is a truth assignment satisfying exactly m clauses of ϕ
if and only if there is a valuation v with range in {0, 1} such
that #((0, 1)k, v(Rϕ)) = m.

(d) For every valuation v, there is a valuation v′ with range in
{0, 1} such that #((0, 1)k, v′(Rϕ)) ≥ #((0, 1)k, v(Rϕ)).

Proof.

(a) By construction, all tuples in R are of the form

¯ut1
x1

· · · ¯u

tk
xk

, with x1, . . . , xk ∈ Var(ϕ)
and t1, . . . , tk ∈ {t, f} .

(4)

Moreover, for any two distinct tuples there exists i such
tk
that one of them is of the form ¯ut1
· · · ¯ut
xk while the
x1
xi
tk
other has the form ¯ut1
xk . Let v be a valuation;
· · · ¯u
x1
clearly, it cannot be that v(¯ut
) = (0, 1), so
xi
no two distinct tuples in R both unify with (0, 1)k. Thus,
#((0, 1)k, v(R)) ≤ 1.

) = v(¯uf
xi

· · · ¯uf
xi

· · · ¯u

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

9

(b) By construction, τ makes C true if and only if there is a
tuple ¯a ∈ R of the form (4) such that ti = τ (xi) for each
i ∈ {1, . . . , k}. In turn, by definition of τ and as v has
range in {0, 1}, this is the case iff v(¯u
) = (0, 1) for each
i ∈ {1, . . . , k}, and so iff v(¯a) = (0, 1)k. By Lemma 6(a), this
is the case iff #((0, 1)k, v(R)) = 1.

τ (xi)
xi

(c) ‘‘if’’. Let v be a valuation with range in {0, 1} such that
#((0, 1)k, v(Rϕ)) = m. Then, by Lemma 6(b), there are
exactly m distinct clauses C1, . . . , Cm of ϕ such that, for
each i ∈ {1, . . . , k}, we have #((0, 1)k, v(Ri)) = 1, where
Ri ⊆ Rϕ is the relation encoding Ci. Consider the truth
assignment τ such that, for each x ∈ Var(ϕ), τ (x) = t iff
v(ρ(x)). Then, by Lemma 6(b), τ satisfies C1, . . . , Cm but no
other clause of ϕ. To see this, let C be a clause of ϕ distinct
from C1, . . . , Cm and encoded by R ⊆ Rϕ, and suppose
that τ makes C true. But then #((0, 1)k, v(R)) = 1 and so
#((0, 1)k, v(Rϕ)) > m, against the initial assumption.
‘‘only if’’. Let ϕ = {C1, . . . , Cm, Cm+1, . . . , Cn}, and let Ri be
the relation that encodes clause Ci, for each i ∈ {1, . . . , n}.
Let τ be a truth assignment that τ makes C1, . . . , Cm true
and Cm+1, . . . , Cn false. Consider the valuation v such that,
for each ⊥ ∈ Null,

v(⊥) =

{1 if ρ−1(⊥) = x ∈ Var(ϕ) and τ (x) = t ,
0 otherwise .

Then, due to Lemma 6(a) and Lemma 6(b), for i ∈ {1, . . . , n}
we have that #((0, 1)k, v(Ri)) is 1 if i ≤ m, and 0 otherwise.
Thus, #((0, 1)k, v(Rϕ)) = ∑n

i=1 #((0, 1)k, v(Ri)) = m.

(d) For any given valuation v, we can always define the val-
uation v′ such that, for every ⊥ ∈ Null, v′(⊥) = v(⊥) if
v(⊥) ∈ {0, 1}, and v′(⊥) = 0 otherwise. As v′ agrees with v
on the values assigned to the nulls in the preimage of {0, 1}
under v, we have that v(¯a) = v′(¯a) whenever v(¯a) unifies
with (0, 1)k. Thus, #((0, 1)k, v′(Rϕ)) ≥ #((0, 1)k, v(Rϕ)). □

We also define a variant of the encoding described above,
by associating each clause with an identifier in the relation that
encodes the formula. To make this formal, let ϕ be a k-CNF
formula, and let ι be an injection from the clauses of ϕ to Const;
for each clause C of ϕ, we then define
enc(C, ι) = (B × enc(C )) ⊎ B
where B and B′ are tables consisting of a single occurrence of
the tuples (ι(C )) and (ι(C )(0, 1)k), respectively. Intuitively, we
compute the relation enc(C ), add one occurrence of (0, 1)k, and
then prefix every tuple with the value ι(C ). Note that, for distinct
clauses C and C ′, no tuple of enc(C, ι) unifies with any of the
tuples in enc(C ′, ι). For ϕ = C1 ∧ · · · ∧ Cn, we let enc(ϕ, ι) =
⨄n

i=1 enc(Ci, ι), whose size is exactly 2k · |ϕ|.

′

Example 5. Consider the encoding of the 3-CNF formula (2) in
Example 4. If ι(C1) = a ∈ Const, then enc(C1, ι) is the following
table:

0
a
0
a
0
a
a
0
a ⊥1
a ⊥1
a ⊥1
0
a

⊥1
0
⊥1
0
⊥1 ⊥2
⊥1 ⊥2
0
1
⊥2
1
⊥2
1
0
1

⊥2
0
⊥2 ⊥4
0
1
⊥4
1
⊥2 ⊥4
0
1
⊥4
1
0
1

⊥4
1
⊥4
1
1
⊥4
1
1

the other is not. To this end, for a k-CNF formula ϕ and a literal
ℓ ∈ {x, ¬x} with x ̸∈ Var(ϕ), we denote by ϕℓ
the (k + 1)-CNF
formula obtained by adding ℓ to each clause of ϕ. Moreover, for
a (finite) set Σ of propositional variables, we let ϕf(Σ) denote
the |Σ|-CNF formula consisting of all maxterms over Σ,1 except
⋁
x∈Σ x. Observe that ϕf(Σ) has size 2|Σ| − 1, and it is satisfied
only by the truth assignment that maps all of the variables in Σ
to f.

Then, given two k-CNF formulae f and g, we define the (k +

1)-CNF formula
h(f , g) = f x ∧ g

¬x ∧ g

¬y ∧ ϕf({z1, . . . , zk+1})

∧ (x ∨ z2 ∨ · · · ∨ zk+1)
∧ (¬x ∨ y ∨ z3 ∨ · · · ∨ zk+1) ,

(5)

where none of the variables x, y, z1, . . . , zk+1 appears in Var(f ) ∪
Var(g). This formula has the following property:

Lemma 7. Let f and g be k-CNF formulae. Then, f is satisfiable and
g is unsatisfiable if and only if the maximum number of clauses of
h(f , g) that can be satisfied by a single truth assignment is exactly
|h(f , g)| − 1.

Proof. We denote by ∥ϕ∥ the maximum number of clauses that
can be satisfied in ϕ by a single truth assignment, while |ϕ|
denotes the number of clauses in ϕ. To avoid the clutter, we let ϕf
refer to ϕf({z1, . . . , zk+1}) in (5), and h refer to h(f , g) itself; note
that |h| = |f | + 2 · |g| + 2k+1 + 1.
‘‘if’’. Assume that ∥h∥ = |h| − 1. We will prove that f
is satis-
fiable while g is unsatisfiable by showing that all other possible
combinations lead to a contradiction.

Let us start by supposing that there exists a satisfying truth
assignment τ for g. Then, the extension of τ that assigns t to all
the variables in Var(f ) ∪ {x, y} and f to those in Var(ϕf) satisfies h,
in contradiction of the initial assumption.

We now consider the case when both f and g are unsatisfiable.
To examine ∥h∥, let h1 denote f x ∧ g ¬x ∧ g ¬y, and h2 consist of
all clauses of h that are not in h1, so that h = h1 ∧ h2. Note
that ∥h∥ ≤ ∥h1∥ + ∥h2∥; moreover, h2 depends on the variables
in Var(ϕf) while h1 does not. We denote ∥h2∥ by M when all
variables in Var(ϕf) are mapped to f, and by N otherwise. Then,
we examine ∥h1∥, M, and N for each of the four possible truth
assignments for x and y:

Assignment

∥h1∥

M

N

x ↦→ f
x ↦→ f
x ↦→ t
x ↦→ t

y ↦→ f = ∥f ∥ + |g| + |g| = |ϕf| + 1 < |ϕf| + 2
y ↦→ t ≤ ∥f ∥ + |g| + ∥g∥ = |ϕf| + 1 < |ϕf| + 2
y ↦→ f = |f | + ∥g∥ + |g| = |ϕf| + 1 < |ϕf| + 2
y ↦→ t = |f | + ∥g∥ + ∥g∥ = |ϕf| + 2 < |ϕf| + 2

As f and g are unsatisfiable, ∥f ∥ < |f | and ∥g∥ < |g|. Therefore,
in all of the above cases, both ∥h1∥ + M and ∥h1∥ + N are strictly
less than |f |+2·|g|+|ϕf|+1, and so ∥h∥ < |h|−1, in contradiction
of the initial assumption.
‘‘only if’’. Let τ be a satisfying assignment for f , and assume that
g is unsatisfiable. The extension of τ that maps all variables in
Var(g) ∪ {x, y} ∪ Var(ϕf) to f clearly satisfies all clauses of h but
one, namely (x∨ z2 ∨· · ·∨ zk+1). Now, suppose there exists a truth
assignment τ ′ satisfying all the clauses of h. Then, τ ′ satisfies g ¬y
and, since g is unsatisfiable, τ ′(y) = f. Moreover, τ ′ also satisfies
ϕf and thus τ ′(zi) = f for every i ∈ {1, . . . , k+ 1}. In turn, to make
the clause (¬x ∨ y ∨ z3 ∨ · · · ∨ zk+1) true, we must have τ ′(x) = f.
Therefore, the clause (x ∨ z2 ∨ · · · ∨ zk+1) of h is not satisfied by
τ ′, which is a contradiction. □

Our second technical tool is a (k+1)-CNF formula derived from
two k-CNF formulae, to check whether one is satisfiable while

1 That is, all disjunctions where each variable in Σ appears exactly once, in

either positive or negated form.

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

10

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

The following result is a critical lemma that will allow us to
show the hardness of min problems by exhibiting a polynomial-
time procedure that constructs a database for every CNF formula
(based on the encodings given above), and query with specific
properties.

Let q be an RA query of arity 0.2 Let dbenc be a
Lemma 8.
procedure that for each k-CNF formula ϕ builds, in polynomial time
w.r.t. the size of ϕ, a database Dϕ such that the following properties
hold:
(P1) There exists a polynomially computable number χ , dependent
only on k and |ϕ|, for which: there is a truth assignment
that satisfies exactly m clauses of ϕ if and only if there is a
valuation v with range in {0, 1} such that #((), q, v(Dϕ)) =
χ − m.

(P2) For every valuation v, there exists a valuation v′ with range
in {0, 1} such that #((), q, v(Dϕ)) ≥ #((), q, v′(Dϕ)).

positive relational algebra [17] consisting of selection, projection,
Cartesian product, and union. Notice that over sets the intersec-
tion of two relations is expressible by join, but over bags this is
no longer the case. It turns out that the good behavior of join
with respect to certain answers extends to bags, when we add
intersection explicitly. Indeed, for RA+{∩}, one can compute min
simply by using naive evaluation.

Let q be an RA+{∩} expression of arity n, let D
Theorem 1.
be a database, and let ¯a ∈ Const(D)n. Then, min(¯a, q, D) =
naive(¯a, q, D).

Proof. This is an immediate consequence of a more general result
that we shall see later on (Proposition 9). □

From the fact that bag relational algebra queries are in
DLogSpace with respect to data complexity [5,6], we then im-
mediately get the following:

Then, (a) MIN
MIN=[q] is DP-hard.

<[q] is NP-hard, (b) MIN

>[q] is coNP-hard, and (c)

Proof. Observe that (P2) directly implies the following:
(P3) min((), q, Dϕ

) = min { #((), q, v(Dϕ)) | v is a valuation

with range in {0, 1} }.

(a) Let k ≥ 3. We show that dbenc provides a reduction from
<[q]. To this end, let ϕ be a k-CNF formula,

k-SAT to MIN
and let Dϕ = dbenc(ϕ).
) = χ − |ϕ| iff there exists a valuation
By (P3), min((), q, Dϕ
v with range in {0, 1} such that #((), q, v(Dϕ)) = χ −|ϕ|. In
turn, by (P1), this is the case iff there is a truth assignment
satisfying |ϕ| clauses of ϕ. Therefore, ϕ is satisfiable iff Dϕ,
() and χ − |ϕ| form a positive instance of MIN

(b) Since MIN

<[q] is the complement of MIN

<[q].
>[q], its complex-

ity follows directly from the previous point.

(c) We show that dbenc and (5) together give a reduction from
<[q]. To this end, let f and g be two
SAT-UNSAT to MIN
k-CNF formulae with k ≥ 3, let ϕ denote the formula h(f , g)
defined as in (5), and let Dϕ = dbenc(ϕ).
By Lemma 7, f
is satisfiable and g is unsatisfiable iff the
maximum number of clauses of ϕ that can be satisfied by
the same truth assignment is exactly |ϕ| − 1, which is the
case iff ϕ is unsatisfiable and there is a truth assignment
that satisfies |ϕ| − 1 clauses of ϕ. In turn, by (P1), this is
the case iff both of the following hold:

• there is no valuation v′ with range in {0, 1} such that

#((), q, v′(Dϕ)) = χ − |ϕ|, and

• there exists a valuation v with range in {0, 1} for
which #((), q, v(Dϕ)) = χ − (|ϕ| − 1) = χ − |ϕ| + 1.
By (P3), the above hold (together) iff min((), q, Dϕ
) = χ −
|ϕ| + 1. Therefore, f is satisfiable and g is unsatisfiable if
and only if Dϕ, () and χ − |ϕ| + 1 form a positive instance
of MIN=[q]. □

5.3. Computing min: intractability beyond RA+{∩}

While computing min is hard in the general case, there exists
a large fragment of RA for which min can be computed via naive
evaluation. In the set case this fragment is well known to be

2 We will consider queries that project onto the empty tuple, so the only
possible answers are either the empty bag, or bags containing one or more
occurrences of (). This is only for technical convenience: the results hold even
if we disallow projection over the empty tuple.

Corollary 5.
MIN

For expressions q in RA+{∩}, the problems MIN

<[q],

>[q] and MIN=[q] are all in DLogSpace. □
As a matter of fact, RA+{∩} is the best fragment for which we
can compute certain answers efficiently under bag semantics. To
show this, from the diagram in Fig. 1, it suffices to prove that the
problem is intractable for SPC{∪}, as well as for all fragments with
duplicate elimination. This is what we do next; in particular, we
shall see that in all of these fragments the intractable complexity
is exactly the same, namely NP-complete, coNP-complete, and
DP-complete, when θ is <, >, and =, respectively.

Hardness for SPC{∪}. We first study the max-union operator ∪.
Recall that, in the set case, adding union is harmless and preserves
the property that certain answers can be found by naive evalu-
ation. But under bag semantics, adding ∪ to SPC gives rise to a
substantial increase in the complexity of computing min.

Theorem 2. There exists an SPC{∪} query q for which MIN
NP-hard, MIN

>[q] is coNP-hard, and MIN=[q] is DP-hard.

<[q] is

Proof. Let ϕ be a k-CNF formula, and define dbenc(ϕ) as the
database with relations R and T , where R is the encoding Rϕ of
ϕ, and T consists of precisely |ϕ| occurrences of (0, 1)k. Consider
the query q = π()(R ∪ T ); we will show that dbenc and q satisfy
the properties of Lemma 8.

Let v be a valuation, let A = adom(v(Dϕ))2k

, and let ¯u =

(0, 1)k. First, we will show that
#((), q, v(Dϕ)) = 2k · |ϕ| − #(¯u, v(Rϕ)) ≥ (2k − 1) · |ϕ|
By definition of projection, #((), π()(R ∪ T ), v(Dϕ)) is equal to
∑

#(¯a, R ∪ T , v(Dϕ)) .

(6)

(6.1)

¯a∈A
As R = Rϕ and T does not contain any tuple distinct from ¯u, (6.1)
equals
∑

#(¯a, v(Rϕ)) + #(¯u, R ∪ T , v(Dϕ))



.

¯a∈A:¯a̸=¯u

(6.2)


(†)

The summation above amounts to |v(Rϕ)| − #(¯u, v(Rϕ)), and by
definition of ∪ we have that (†) is equal to max { #(¯u, v(Rϕ)),
#(¯u, v(T )) }. By construction, T consists of exactly |ϕ| occurrences
of the constant tuple ¯u, so #(¯u, v(T )) = #(¯u, T ) = |ϕ|. In turn,
since |v(Rϕ)| = |Rϕ| = (2k − 1) · |ϕ|, we have that (6.2) is equal
to
(2k − 1) · |ϕ| − #(¯u, v(Rϕ)) + max{#(¯u, v(Rϕ)), |ϕ|}


(6.3)



.


(††)

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

11

Obviously #(¯u, v(Rϕ)) ≤ |ϕ| by Lemma 6, so (††) = |ϕ|. Thus,
from (6.3) we directly get (6).

By Lemma 6, there exists a truth assignment that satisfies m
clauses of ϕ iff there exists a valuation v with range in {0, 1}
such that #(¯u, v(Rϕ)) = m. In turn, from (6), this is the case iff
#((), q, v(Dϕ)) = 2k · |ϕ| − m, thus proving that (P1) holds for
χ = 2k · |ϕ|. In addition, from (6) and Lemma 6(d) it directly
follows that (P2) holds as well. □

Handling duplicate elimination.
In terms of tractability, no frag-
ment survives the addition of duplicate elimination. Indeed, for all
fragments from SPC{ε} to full relational algebra RA, the decision
problems are NP-complete, coNP-complete, and DP-complete for
<, > and =, respectively.

Theorem 3. There exists an SPC{ε} query q for which MIN
NP-hard, MIN

>[q] is coNP-hard, and MIN=[q] is DP-hard.

<[q] is

Proof. Let ϕ be a k-CNF formula, define dbenc(ϕ) as the database
Dϕ consisting of the relation S = enc(ϕ, ι), for some injection ι
(ε(S)).3 We will
from ϕ to Const, and consider the query q = π()
show that dbenc and q satisfy the properties of Lemma 8.

By construction and by Lemma 6(a), for every valuation v, the
number of occurrences of ι(C )(0, 1)k in v(enc(C, ι)) is either 1 or
2, and any other tuple occurs at most once. Recall also that, for
distinct clauses C and C ′, no tuple in enc(C, ι) unifies with any
tuple in enc(C ′, ι).

From Lemma 6(c) it follows that (P1) holds for χ = 2k · |ϕ| if

we show that, for every valuation v,
#((), q, v(Dϕ)) = 2k · |ϕ| − m ⇐⇒ #((0, 1)k, v(Rϕ)) = m ,
(7)
where Rϕ = enc(ϕ). In addition, from (7) and Lemma 6(d) it also
follows that (P2) holds.

Let v be a valuation, and let Sj denote the set of tuples that

occur precisely j times in v(S). Then,
#((), q, v(Dϕ)) = ∑
¯a∈S1

1 + ∑
¯a∈S2

1 = |v(S)| − ∑
¯a∈S2

1.

Since |v(S)| = |S| = 2k · |ϕ|, we have that #((), q, v(Dϕ)) =
2k · |ϕ| − m if and only if ∑
1 = m. In turn, this is the case iff

¯a∈S2

(†) there exist exactly m distinct clauses C1, . . . , Cm in ϕ such
that, for every i ∈ {1, . . . , m}, #(ι(Ci)(0, 1)k, v(enc(Ci, ι))) is
equal to 2.

By construction, we have that #(ι(C )(0, 1)k, v(enc(C, ι))) = 2 iff
#((0, 1)k, v(enc(C ))) = 1, for every C ∈ ϕ. So, by Lemma 6(a), (†)
holds iff #((0, 1)k, v(Rϕ)) = m. □

5.4. Computing max: hardness for simple queries

The problem of computing max is hard already for very simple
>[q] is NP-complete for a query q that
queries: in fact, MAX
returns a base relation [21]. Here, we complete the picture by
proving that deciding MAX=[q] for the same class of queries is
complete for DP.

Theorem 4. The problem MAX=[q] is DP-hard even for a query q
that returns a base relation.

Proof. We provide a reduction from SAT-UNSAT. To this end, let
f and g be two 3-CNF formulae, let ϕ denote h(f , g), let Dϕ be the
database consisting of the single relation R = Rϕ, and consider

3 The output of this query is always either the empty bag, or the bag

consisting of a single occurrence of the empty tuple ().

the query q = R. Observe that ϕ is a 4-CNF formula and, for every
valuation v, we have that #((0, 1)4, q, v(Dϕ)) = #((0, 1)4, v(Rϕ)).
is satisfiable and g is unsatisfiable iff the
maximum number of clauses of ϕ that can be satisfied by a single
truth assignment is |ϕ|−1. By Lemma 6(c), this is the case iff both
of the following hold:

By Lemma 7, f

(†) there exists a valuation v with range in {0, 1} such that

#((0, 1)4, v(Rϕ)) = |ϕ| − 1, and

(‡) there is no valuation v′ with range in {0, 1} such that

#((0, 1)4, v′(Rϕ)) = |ϕ|.

Observe that Lemma 6(d) directly implies that

{#((0, 1)k, v(Rϕ))} = max
v∈V ′

max
v∈V
where V is the set of all valuations, and V ′ ⊆ V consists of all
valuations with range in {0, 1}.

{#((0, 1)k, v(Rϕ))},

Thus, (†) and (‡) hold together iff max((0, 1)4, q, Dϕ

) = |ϕ|−1.
Therefore, f is satisfiable and g is unsatisfiable iff Dϕ, (0, 1)k, and
|ϕ| − 1 are a positive instance of MAX=[q] for q = R. □

5.5. Complex selection conditions

In our definition of relational algebra, we assumed that se-
lection conditions are equalities of the form i = j, where i
and j denote positions within a table. Selection conditions γ can
be generalized to arbitrary Boolean combinations of equalities,
according to following the grammar:
:= (i = j) | γ ∧ γ | γ ∨ γ | ¬γ

γ

We briefly describe how more complex conditions affect our
results.

If we only add conjunction (that is, selection conditions are
conjunctions of equalities), there is no change at all. This is
because the cascade-of-selections equivalence,
σγ ∧γ ′ (e) ≡ σγ

(σγ ′ (e)),

applies under bag semantics as well.

If we add disjunction, it might at first appear that this leads to

intractability, because the following equivalence
σγ ∨γ ′ (e) ≡ σγ (e) ∪ σγ ′ (e)

holds under bag semantics, and we have seen that the frag-
ment SPC{∪} is intractable. However, adding disjunction to selec-
tion conditions is weaker than adding max-union, and preserves
tractability.

Let q be an RA+{∩} query of arity n, where
Proposition 9.
selection conditions are positive Boolean combinations of equalities;
>[q] can be solved in DLogSpace. More
then, MIN
precisely, for every database D and for every n-tuple ¯a of constants,
min(¯a, q, D) = naive(¯a, q, D).

<[q] and MIN

Proof. For every valuation v, we have v(¯a) = ¯a and
naive(¯a, q, D) ≤ ∑

′, q, D) ≤ #(¯a, q, v(D)) ,

naive(¯a

(8)

¯a′:v(¯a′)=¯a

where the rightmost inequality is by Lemma 9, which is given in
Appendix. Let us now define a valuation ˜v whose restriction to
Null(D) is injective and such that the image of Null(D) under it is
disjoint with Const(D). In other words, each null in D is mapped
to a distinct constant that does not appear in D.

From the definition of naive evaluation, it then follows that
#(¯a, q, ˜v(D)) = naive(¯a, q, D). This, together with (8), proves that
naive(¯a, q, D) = min(¯a, q, D). □

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

12

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

The problems become intractable when conditions are unre-
stricted Boolean combinations of equalities, even when these are
added to the SPC fragment.

Appendix. Additional proofs

Proposition 10.
In the extension of SPC that allows arbitrary
Boolean combinations of equalities as selection conditions, there is
>[q] is coNP-
a query q for which MIN
complete, and MIN=[q] is DP-complete.

<[q] is NP-complete, MIN

Proof. Let ϕ be a k-CNF formula, and define dbenc(ϕ) as the
database Dϕ with relations R and T , where R is the encoding Rϕ
of ϕ and T consists of a single occurrence of (0, 1)k. Consider
(σγ (R × T )), where γ is the disjunction of all
the query q = π()
inequalities i ̸= j for every i ∈ {1, . . . , 2k} and j = 2k + 1. We will
show that dbenc and q satisfy the properties of Lemma 8.

For a valuation v, the answer to q on v(Dϕ) consists of as many
occurrences of () as there are tuples different from (0, 1)k in Rϕ.
More precisely,
#((), q, v(Dϕ)) = ∑
¯a̸=(0,1)k

#(¯a, v(Rϕ))

(9)

= |v(Rϕ)| − #((0, 1)k, v(Rϕ)) .

Therefore, (P1) holds for χ = (2k − 1) · |ϕ| = |Rϕ| = |v(Rϕ)| by
Lemma 6(c). In addition, from (9) and Lemma 6(d) it also follows
that (P2) holds. □

6. Conclusions

We have provided two complete classifications: of the ex-
pressive power of fragments of bag relational algebra, and of
the complexity of computing certain and possible answers in
those fragments. For the complexity of certain answers, we have
a dichotomy: either they can be computed efficiently by naive
evaluation, or their complexity is intractable, which means NP-
complete, or coNP-complete, or DP-complete (depending on how
the problem is turned into a decision problem).

Directions for future work are motivated by the recent work
on bag semantics in data management applications where in-
completeness naturally occurs, such as data exchange [15] and
OBDA [16]. Notice that we have primarily concentrated on the
closed-world semantics, which as of late has been actively studied
in those contexts; see, e.g., [27–31]. Thus we believe our results
could be relevant to understanding the complexity of these appli-
cations under the closed-world assumption. As another direction
for future work, we would like to study the complexity of finding
certain and possible answers in the fragments of bag relational
algebra under the open-world assumption. The general case is
of course undecidable, but the picture for the fragments studied
here is not clear. Finally, we would like to use our results as the
starting point for the study of answering queries with grouping
and aggregation over incomplete data, as such queries rely on bag
semantics.

Declaration of competing interest

The authors declare that they have no known competing finan-
cial interests or personal relationships that could have appeared
to influence the work reported in this paper.

Acknowledgments

The authors would like to thank the anonymous reviewers
for their constructive comments and suggestions, which have
contributed to the improvement of this work.

Proof of Lemma 3. We proceed by induction on the structure of
e. Note that all subexpressions of e are nullary and, since there are
no attributes, none of them can be a selection. Moreover, accord-
ing to the syntax of bag relational algebra defined in Section 2,
every subexpression of e must mention R at least once (and it
does not mention any other symbol of the schema due to the
assumptions of the lemma).

Base case: e is R. Then, |e(D)| = |RD|.

Inductive step:

• e is π()(e′). Then, |e(D)| = |e′(D)| and by the induction

hypothesis |e′(D)| ≥ |RD|.

• e is e′ × e′′. Then, |e(D)| = |e′(D)| · |e′′(D)|. By the induction
hypothesis |e′(D)| and |e′′(D)| are both ≥ |RD|, and thus their
product is as well.

• e is e′ ∪ e′′. Then, |e(D)| = max{|e′(D)|, |e′′(D)|} ≥ |e′(D)| and

by the induction hypothesis |e′(D)| ≥ |RD|.

• e is e′ ⊎ e′′. Then, |e(D)| = |e′(D)| + |e′′(D)| ≥ |e′(D)|. By the
induction hypothesis both |e′(D)| and |e′′(D)| are ≥ |RD|, and
therefore their sum is as well. □

Proof of Lemma 4. We proceed by induction on the structure of
e. Note that all subexpressions of e are nullary and, since there
are no attributes, none of them can be a selection.
Base case: e is eR ⋆ eS , where ⋆ ∈ {×, ⊎, ∪} and eR, eS are RA+{∪}
expressions such that eR mentions only R and eS mentions only S.
(|eR(D)|, |eS (D)|), where f×(m, n) = m·n,
Then, we have |e(D)| = f⋆
f⊎(m, n) = m + n and f∪(m, n) = max(m, n). Clearly, for every
m, n ∈ N and for each ⋆ ∈ {×, ⊎, ∪}, we have that f⋆(m, n) ≥ m
and f⋆(m, n) ≥ n. Thus, since |eR(D)| ≥ |RD| and |eS (D)| ≥ |SD| by
Lemma 3, the claim follows trivially.

Inductive step: Straightforward application of the induction hy-
pothesis as in Lemma 3. □

Let q be a n-ary expression in RA+{∩} and let D be a
Lemma 9.
bag semantics database. For every tuple ¯a ∈ adomn(D) and every
valuation v for Null(D) the following inequality holds:

naive(¯b, q, D) ≤ #(v ¯a, q, vD)

∑

{¯b∈adomn (D)
| v ¯b=v ¯a}

Proof. We proceed by induction on the structure of q.

Base case:

• q = R. Trivially, each occurrence of ¯a in RD results in one

occurrence of v(¯a) in R

v(D).

Inductive step:

• q = πα(q′). Assume that q′ has arity m. Due to the defi-
nition of Projection, the following equality holds for every
valuation v for Null(D):

′
#(v ¯a, πα(q

), vD) = ∑

#(¯c, q

′, vD) .

(A.1)

{¯c∈adomm (vD)
| πα (¯c)=v ¯a}

Notice that ¯c in Eq. (A.1) is a tuple of constants, hence from
the definition of semantics for incomplete databases we can
conclude that there exists at least one tuple ¯u ∈ adomm(D)
such that v ¯u = ¯c. We now apply the inductive hypothesis

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

13

to q′ and ¯u and derive the following:

naive(¯b, q

′, D) ≤ #(v ¯u, q

′, vD) .

(A.2)

∑

{¯b∈adomm (D)
| v ¯u=v ¯b}

By assumption, v ¯u in Eq. (A.2) is equal to ¯c. For this rea-
son, we can substitute v ¯u with ¯c obtaining the following
inequality:
∑

naive(¯b, q

′, D) ≤ #(¯c, q

′, vD) .

(A.3)

{¯b∈adomm (D)
| v ¯b=¯c}

Observe now that v is a function, hence for every ¯b ∈
adomm(D) there exists one and only one tuple ¯c of constants
such that v ¯b = ¯c. In light of this consideration, we can apply
Eq. (A.3) to each tuple ¯c in the right-hand side of Eq. (A.1)
and obtain the following inequality.

∑

naive(¯b, q

′, D)

⎛

⎜
⎜
⎝

∑

{¯c∈adomm (vD)
| πα (¯c)=v ¯a}
∑

{¯c∈adomm (vD)
| πα (¯c)=v ¯a}

{¯b∈adomm (D)
| v ¯b=¯c}
′, vD) .

#(¯c, q

⎞

⎟
⎟
⎠

≤

(A.4)

The double summation on the left-hand side of Eq. (A.4)
can now be re-written as a single summation over all those
tuples ¯b such that v ¯b is equal to v ¯a on α. Hence:
′, vD) .

′, D) ≤ ∑

naive(¯b, q

#(¯c, q

(A.5)

∑

{¯c∈adomm (vD)
| πα (¯c)=v ¯a}

{¯b∈adomm (D)
| πα (v ¯b)=v ¯a}
Consider now naive(¯a, πα(q′), D), and let ¯z be a generic tuple
in adomm(D) such that ¯z is equal to ¯a on the attributes in α.
Since
Z = {¯z ∈ adomm(D) | ¯z is equal to ¯a on α}

is a subset of
B = {¯b ∈ adomm(D) | v ¯bis equal to v ¯a on α} ,

the following inequality holds:
∑

naive(¯z, q

naive(¯b, q

′, D) .

′, D) ≤ ∑
¯b∈B

¯z∈Z

The claim now follows from the definition of projection, that
is,

′
naive(¯a, πα(q

), D) = ∑
¯z∈Z

naive(¯z, q

′, D) .

i(⋀

• q = σγ (q′), where γ is a positive Boolean combination of
equalities. W.l.o.g. we assume γ to be in disjunctive normal
form, that is, γ = ⋁
j(ai,j = bi,j)).
If this is the case, a tuple ¯a satisfies γ if it satisfies all the
equalities in one of the disjuncts of γ .
Let A be the set of n-tuples that unify with ¯a; for every
valuation v we have
∑

naive(¯a

′
′, σγ (q

¯a′∈A

(A.6)

naive(¯a

), D) ≤ ∑
¯a′∈A
≤ #(v(¯a), q

′, v(D)) ,

′, q

′, D)

where the left inequality is by definition of the selection
operation, and the right one is by the inductive hypothesis.
If v(¯a) satisfies γ , then
#(v(¯a), σγ (q
′

), v(D)) = #(v(¯a), q

′, v(D))

and so the claim follows by Eq. (A.6). Otherwise, when v(¯a)
does not satisfy γ , for each disjunct of γ there is an equality
i = j not satisfied by v(¯a). Then, from the definition of
selection we have #(v(¯a), σγ (q′), v(D)) = 0.
Observe now that valuations are functions, hence v ¯a.i
̸=
v ¯a.j implies that ¯a.i
̸= ¯a.j. In turn, this implies all the
tuples ¯b ∈ adomn(D) such that v ¯b = v ¯a do not satisfy the
equality conditions violated by v ¯a. From this consideration,
we can conclude that ∑
{¯b∈adomn(D) | v ¯b=v ¯a} naive(¯b, σγ (q′), D)
= 0, proving the claim.

• q = q1 ⊎ q2. From the definition of ⊎ we have the following:

∑

naive(¯b, q1 ⊎ q2, D) =

{¯b∈adomn (D)
| v ¯b=v ¯a}
∑

{¯b∈adomn (D)
| v ¯b=v ¯a}

naive(¯b, q1, D) + ∑

naive(¯b, q2, D) .

(A.7)

{¯b∈adomn (D)
| v ¯b=v ¯a}

Applying the inductive hypothesis to q1 and q2 we obtain:

naive(¯b, q1, D) ≤ #(v ¯a, q1, vD) ;

naive(¯b, q2, D) ≤ #(v ¯a, q2, vD) .

∑

{¯b∈adomn (D)
| v ¯b=v ¯a}
∑

{¯b∈adomn (D)
| v ¯b=v ¯a}

(A.8)

(A.9)

Finally, we apply the definition of additive union to vD and
obtain the following:
#(v ¯a, q1 ⊎ q2, vD) = #(v ¯a, q1, vD) + #(v ¯a, q2, vD) .

(A.10)

The claim now follows from Eqs. (A.7), (A.8), (A.9), (A.10).
• q = q1 × q2. Suppose that the arity of q1 is a and the
arity of q2 is b, and assume two tuples ¯a1 ∈ adoma(D) and
¯a2 ∈ adoma(D) such that ¯a = ¯a1 ◦ ¯a2. From the definition of
Cartesian product we obtain the following.
#(v ¯a, q1 × q2, vD) = #(v ¯a1, q1, vD) · #(v ¯a2, q2, vD) .
(A.11)
Applying the inductive hypothesis on v ¯a1 and v ¯a2, we obtain
the following inequalities:

naive(¯b1, q1, D) ≤ #(v ¯a1, q1, vD) ;

(A.12)

naive(¯b2, q2, D) ≤ #(v ¯a2, q2, vD) .

(A.13)

∑

{¯b1∈adoma (D)
| v ¯b1=v ¯a1}
∑

{¯b2∈adomb (D)
| v ¯b2=v ¯a2}

We now apply Eqs. (A.12) and (A.13) to Eq. (A.11), and we
derive the following:

∑

naive(¯b1, q1, D) ·

{¯b1∈adoma (D)
| v ¯b1=v ¯a1}
∑

{¯b2∈adomb (D)
| v ¯b2=v ¯a2}

naive(¯b2, q2, D) ≤ #(v ¯a, q1 × q2, vD) .

(A.14)

Let S = {¯b ∈ adomn(D) | v ¯b = v ¯a}. From the definition of
Cartesian product we can derive the following equality:

∑

¯b∈S
∑

naive(¯b, q1 × q2, D) =

naive(¯b1, q1, D) · naive(¯b2, q2, D) .

(A.15)

{¯b1

,¯b2
| ¯b1◦¯b2∈S}

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

14

M. Console, P. Guagliardo and L. Libkin / Information Systems xxx (xxxx) xxx

To prove the claim, observe that the left-hand side of
Eq. (A.14) is always greater or equal to the right-hand side
of Eq. (A.15).

• q = q1 ∩ q2. From the definition of ∩ we can derive the

following:
∑

naive(¯b, q1 ∩ q2, D) =

{¯b∈adomn (D)
| v ¯b=v ¯a}
∑

{¯b∈adomn (D)
| v ¯b=v ¯a}

min{ naive(¯b, q1, D), naive(¯b, q2, D) } .

[6] L. Libkin, L. Wong, Query languages for bags and aggregate functions, J.

Comput. System Sci. 55 (2) (1997) 241–272.

[7] P. Buneman, S.A. Naqvi, V. Tannen, L. Wong, Principles of programming
with complex objects and collection types, Theoret. Comput. Sci. 149 (1)
(1995) 3–48.

[8] R.G.G. Cattell, The Object Database Standard: ODMG-93, Morgan Kaufmann,

1993.

[9] S. Chaudhuri, M.Y. Vardi, Optimization of real conjunctive queries,

in:

PODS, 1993, pp. 59–70.

(A.16)

[10] T.S.

Jayram, P.G. Kolaitis, E. Vee, The containment problem for real

conjunctive queries with inequalities, in: PODS, 2006, pp. 80–89.

[11] S. Cohen, Equivalence of queries combining set and bag-set semantics, in:

We now apply the inductive hypothesis to q1 and q2 and
obtain the following:

naive(¯b, q1, D) ≤ #(v ¯a, q1, vD) ;

(A.17)

ICDT, 1997, pp. 461–475.

∑

{¯b∈adomn (D)
| v ¯b=v ¯a}
∑

{¯b∈adomn (D)
| v ¯b=v ¯a}

naive(¯b, q2, D) ≤ #(v ¯a, q2, vD) .

(A.18)

Finally, we apply the definition of intersection to vD and
obtain the following.

#(v ¯a, q1 ∩ q2, vD) = min{#(v ¯a, q1, vD), #(v ¯a, q2, vD)} .

(A.19)

We now observe that the right-hand side of Eq. (A.16) is
always lesser or equal to the left-hand side of Eqs. (A.17) and
(A.18). This is due to the application of the min operator. In
turn, together with Eq. (A.19) this proves that the following
inequality holds:

naive(¯b, q1 ∩ q2, D) ≤ #(v ¯a, q1 ∩ q2, vD) .

∑

{¯b∈adomn (D)
| v ¯b=v ¯a}

This in turn proves the claim. □

References

[1] M. Console, P. Guagliardo, L. Libkin, Fragments of bag relational algebra:
Expressiveness and certain answers, in: ICDT, in: LIPIcs, vol. 127, Schloss
Dagstuhl - Leibniz-Zentrum fuer Informatik, 2019, pp. 8:1–8:16.

[2] C.J. Date, H. Darwen, A Guide to the SQL Standard, Addison-Wesley, 1996.
[3] R. Ramakrishnan, J. Gehrke, Database Management Systems, McGraw-Hill,

[4]

2003.
J. Albert, Algebraic properties of bag data types,
211–219.

in: VLDB, 1991, pp.

[5] S. Grumbach, T. Milo, Towards tractable algebras for bags, J. Comput.

System Sci. 52 (3) (1996) 570–588.

PODS, 2006, pp. 70–79.

[12] P.G. Kolaitis, The query containment problem: Set semantics vs. bag

semantics, in: AMW, 2013.

[13] L.E. Bertossi, G. Gottlob, R. Pichler, Datalog: Bag semantics via set

semantics, in: ICDT, 2019, pp. 16:1–16:19.

[14] L.S. Colby, L. Libkin, Tractable iteration mechanisms for bag languages, in:

[15] A. Hernich, P.G. Kolaitis, Foundations of information integration under bag

semantics, in: LICS, IEEE Computer Society, 2017, pp. 1–12.

[16] C. Nikolaou, E.V. Kostylev, G. Konstantinidis, M. Kaminski, B.C. Grau, I.
Horrocks, The bag semantics of ontology-based data access, in: IJCAI, 2017,
pp. 1224–1230.

[17] T. Imielinski, W. Lipski, Incomplete information in relational databases, J.

ACM 31 (4) (1984) 761–791.

[18] S. Abiteboul, R. Hull, V. Vianu, Foundations of Databases, Addison-Wesley,

1995.

[19] S. Abiteboul, P. Kanellakis, G. Grahne, On the representation and querying

of sets of possible worlds, Theoret. Comput. Sci. 78 (1) (1991) 158–187.

[20] S. Grumbach, L. Libkin, T. Milo, L. Wong, Query languages for bags:
expressive power and complexity, SIGACT News 27 (2) (1996) 30–44.
[21] M. Console, P. Guagliardo, L. Libkin, On querying incomplete information
in databases under bag semantics, in: IJCAI, ijcai.org, 2017, pp. 993–999.
[22] C.H. Papadimitriou, M. Yannakakis, The complexity of facets (and some
facets of complexity), J. Comput. System Sci. 28 (2) (1984) 244–259.
[23] T.J. Green, G. Karvounarakis, V. Tannen, Provenance semirings, in: PODS,

ACM, 2007, pp. 31–40.

[24] M. Arenas, P. Barceló, L. Libkin, F. Murlak, Foundations of Data Exchange,

Cambridge University Press, 2014.

[25] M. Bienvenu, M. Ortiz, Ontology-mediated query answering with

data-tractable description logics, in: Reasoning Web, 2015, pp. 218–307.

[26] M. Lenzerini, Data integration: a theoretical perspective, in: PODS, 2002,

pp. 233–246.

[27] S. Ahmetaj, M. Ortiz, M. Simkus, Polynomial datalog rewritings for ex-
in: IJCAI, 2016, pp.

pressive description logics with closed predicates,
878–885.

[28] G. Amendola, N. Leone, M. Manna, P. Veltri, Enhancing existential rules by

closed-world variables, in: IJCAI, 2018, pp. 1676–1682.

[29] A. Hernich, Answering non-monotonic queries in relational data exchange,

Log. Methods Comput. Sci. 7 (3) (2011).

[30] A. Hernich, L. Libkin, N. Schweikardt, Closed world data exchange, ACM

Trans. Database Syst. 36 (2) (2011) 14:1–14:40.

[31] C. Lutz,

I. Seylan, F. Wolter, Ontology-mediated queries with closed

predicates, in: IJCAI, 2015, pp. 3120–3126.

Please cite this article as: M. Console, P. Guagliardo and L. Libkin, Fragments of bag relational algebra: Expressiveness and certain answers, Information Systems (2020)
101604, https://doi.org/10.1016/j.is.2020.101604.

