Improved Complexity Results and an Eﬀicient Solution
for Connected Multi-Agent Path Finding
Isseïnie Calviac, Ocan Sankur, François Schwarzentruber

To cite this version:

Isseïnie Calviac, Ocan Sankur, François Schwarzentruber. Improved Complexity Results and an Eﬀi-
cient Solution for Connected Multi-Agent Path Finding. AAMAS 2023 - 22nd International Confer-
ence on Autonomous Agents and Multiagent Systems, May 2023, London, United Kingdom. pp.1-9.
￿hal-04075393￿

HAL Id: hal-04075393

https://hal.science/hal-04075393

Submitted on 20 Apr 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Improved Complexity Results and an Efficient Solution for
Connected Multi-Agent Path Finding
Ocan Sankur
Univ Rennes, Inria, CNRS
Rennes, France
ocan.sankur@cnrs.fr

Isseïnie Calviac
Univ Rennes, Inria, CNRS
Rennes, France
isseinie.calviac@ens-rennes.fr

François Schwarzentruber
Univ Rennes, CNRS
Rennes, France
francois.schwarzentruber@ens-
rennes.fr

ABSTRACT
Connected multi-agent path finding (CMAPF) consists in comput-
ing paths for multiple agents which must reach a goal configuration
while remaining connected at all steps. We prove the PSPACE-
hardness of the problem when the underlying graph is a subgraph
of a 3D grid and with range-based connectivity. Moreover, we pro-
vide an application of the WHCA∗ algorithm and show that it
outperforms previously given algorithms by an order of magnitude
in terms of the sizes of the instances it can handle.

KEYWORDS
AI planning; multi-agent path finding; connectivity; CA*

ACM Reference Format:
Isseïnie Calviac, Ocan Sankur, and François Schwarzentruber. . Improved
Complexity Results and an Efficient Solution for Connected Multi-Agent
Path Finding. In Proc. of the 22nd International Conference on Autonomous
Agents and Multiagent Systems (AAMAS 2023), London, United Kingdom,
May 29 – June 2, 2023, IFAAMAS, 9 pages.

1 INTRODUCTION
Multiple agents may have to cooperate in various situations in
order to achieve a goal, such as search and rescue missions, or nu-
clear decommissioning. Some applications require agents to remain
connected during the mission, for example, in order to transmit a
video stream or other data to human operators [1].

In this article, we study the so-called Connected Multi-Agent
Path Finding (CMAPF) problem [3, 6, 11, 16] which is the extension
of the multi-agent path finding problem [8] to deal with connectiv-
ity constraints between agents. In this setting, the environment is
modeled by a graph whose nodes are locations that can be occu-
pied by a single agent at any time. There are two types of edges:
movement and communication edges. Agents start in some start-
ing locations (sources) and have to reach target locations, while
forming a connected graph through communication edges at each
step.

In [16], the authors prove that CMAPF is PSPACE-complete in
general graphs, and give one deterministic and two randomized
algorithms which consist in greedily selecting a successor configu-
ration at each step so as to build an execution towards the targets.
Surprisingly, their algorithms do not consider the collision con-
straints (i.e. allow collisions between agents). This study however
does not fully settle the theoretical complexity of the problem. In
fact, PSPACE-hardness result requires arbitrary graphs. Although

Proc. of the 22nd International Conference on Autonomous Agents and Multiagent Systems
(AAMAS 2023), A. Ricci, W. Yeoh, N. Agmon, B. An (eds.), May 29 – June 2, 2023, London,
United Kingdom.

the movement edges form a planar graph in their reduction, the
communication graph has a very particular shape, and is far from
being planar. So the PSPACE-hardness holds but on graphs that may
look artificial. Many applications of MAPF are actually restricted
to subgraphs of grids [7], and communication is often determined
by range [1], that is, two agents can communicate whenever their
distance is smaller than a given threshold. Our first objective in
this paper was therefore to establish the complexity of the problem
for subgraphs of grids and range-based communication. Second,
algorithmic solutions given in [16] do not scale beyond about 10-20
agents (despite allowing collisions between agents). Our second
objective was to show that it is possible to derive much more effi-
cient algorithmic solutions for the CMAPF problem by exploiting
the multi-agent planning literature. Moreover, we enforce collision
constraints, since we believe that the CMAPF problem only makes
sense when both collision and connectivity constraints are taken
into consideration.

This paper provides two contributions.

(1) First we show that CMAPF is PSPACE-hard even when
agents move in a subgraph of a 3D grid, and with range-
based communication, that is, when two agents can com-
municate when their distance is within a given range. Our
reduction is from non-deterministic constraint logic (NCL) [5],
and is based on [16]. NCL is a computation model based on
a so-called AND/OR graph in which edges are to be flipped
sequentially. The main technical challenge we solve is to
provide gadgets that mimic the sequential flips of edges.
(2) Second, we provide an algorithmic solution based on win-
dowed hierarchical cooperative A∗ (WHCA∗), and provide
a randomized conflict resolution mechanism well adapted
to connectivity constraints, which scales to instances with
an order of magnitude more agents than [16]. This solution
has the advantage of being simple, and finding plans often
quickly, and thus significantly improves over the previously
given algorithms. Moreover, the randomization we introduce
allows us to address the incompleteness of the basic WHCA∗
algorithm and solve more instances. For example, on some
benchmarks, we were able to solve instances with about 80
agents where the performance of the previous algorithm
dropped after about 10-20 agents.

Related Work. Connectivity constraints are very different in na-
ture than collision constraints alone, so most techniques developed
for MAPF in the literature do not easily apply to connectivity con-
straints. In fact, while collisions are often local (occur at a given
time step) and mostly involve two or a few agents, connectivity
constraints are global and continuous, that is, they involve the set

of all agents and a violation of connectivity can span a large time
window, if not the whole execution. So these conflicts cannot be
dealt locally, unlike collision constraints.

The popular conflict-based search algorithm for MAPF [13] (with-
out connectivity) is difficult to generalize connectivity constraints
although some attempt was made [10] which allows collisions be-
tween agents and only focus on connectivity; but the scalability
seemed limited. We also observe that allowing collisions has lit-
tle interest in practice, and it renders the problem easier (this can
also be observed in the experiments of [16]). In instances with par-
ticular communication graphs called sight-moveable, and in the
presence of a basis vertex to which the group of agents are to be
constantly connected, the problem was shown to be in LOGSPACE
[3]. However, this does not apply to grid graphs with range-based
communication.

MAPF with imperfect information has been considered in the
literature, for instance [17] or [9]. The closer work seems to be [11].
They also use topological graphs with both movement and com-
munication edges. The connectivity is then taken into account to
compute the knowledge of each agents. In our work, we consider the
perfect information case where connectivity must be maintained.
Improvements over WHCA∗ have been considered e.g. [2] that
specifically target conflicts due to collisions. Some other algorithms
that target collisions are [18, 19]. Algorithms combining plans for
groups of agents such as [15] are also difficult to apply here due to
connectivity being a global constraint on all agents.

Outline In Section 2 we recall the background about CMAPF.
In Section 3, we first recall NCL and then explain our reduction
to prove that CMAPF is PSPACE-hard for 3D instances. Section 4
provides our algorithm and its performance against the state-of-art
ones. Section 5 is the conclusion.

2 SETTING
The environment of the CMAPF problem is represented by a so-
called topological graph 𝐺 = (𝑉 , 𝐸𝑀, 𝐸𝐶 ) with a non-empty finite set
𝑉 of vertices, and with two types of undirected edges: the movement
edges (set 𝐸𝑀 ) and the communication edges (set 𝐸𝐶 ). We denote
𝐺𝑀 = ⟨𝑉 , 𝐸𝑀 ⟩ and 𝐺𝐶 = ⟨𝑉 , 𝐸𝐶 ⟩. Figure 1 shows such a graph
which contains 8 vertices. The solid lines represent the movement
edges and the dashed ones the communication edges. The agents
can thus move along the solid lines and communicate with other
agents along the dashed ones.

𝑠1

𝑠2

𝑣

𝑡2

movement

communication

𝑠3

𝑢

𝑡1

𝑡3

Figure 1: Example of a topological graph for the CMAPF
problem.

We consider 𝑛 agents that must move in 𝐺𝑀 from their initial

vertices to their target ones.

A configuration 𝑐 of 𝑛 agents in 𝑉 is a tuple of 𝑛 distinct vertices
of 𝑉 , denoted (𝑐1, ...𝑐𝑛) where for 𝑖 ∈ {1, ..., 𝑛}, 𝑐𝑖 is the position

𝑠1
𝑎1
⌣

𝑎3
⌣
𝑠3

𝑣

𝑡2

𝑠1

𝑠2
𝑎2
⌣

𝑢

𝑡1

𝑡3

𝑠3

𝑠2
𝑎1
⌣

𝑎3
⌣
𝑢

𝑡2

𝑣
𝑎2
⌣

𝑡1

𝑡3

(a) Step 0: agents are at the
initial configuration
(𝑠1, 𝑠2, 𝑠3)
𝑠2

𝑠1

𝑣
𝑎1
⌣

𝑡2
𝑎2
⌣

(b) Step 1: agents move to
configuration (𝑠2, 𝑣, 𝑢)

𝑠1

𝑠2

𝑣

𝑡2
𝑎2
⌣

𝑎3
⌣
𝑡3

𝑠3

𝑢

𝑎3
⌣
𝑡1

𝑡3

𝑠3

𝑢

𝑎1
⌣
𝑡1

(c) Step 2: agents move to
configuration (𝑣, 𝑡2, 𝑡1)

(d) Step 3: agents are at the
final configuration
(𝑡1, 𝑡2, 𝑡3)

Figure 2: Example of connected execution.

of the agent 𝑎𝑖 . The initial configuration is 𝑠 = (𝑠1, ..., 𝑠𝑛) and the
final one 𝑡 = (𝑡1, ..., 𝑡𝑛). Two configurations 𝑐 and 𝑐 ′ of length
𝑛 are consequent if and only if for each 𝑖 ∈ {1, ..., 𝑛} we have
(𝑐𝑖, 𝑐 ′
𝑖 ) ∈ 𝐸𝑀 ; thus, each agent makes one move in 𝐺𝑀 . We allow
agents to idle. Moreover, the agents must stay connected along their
movements. We say that a configuration 𝑐 of 𝑛 agents is connected if
and only if it forms a connected sub-graph of 𝐺𝐶 . In Figure 1, assume
that we have 3 agents that must move from (𝑠1, 𝑠2, 𝑠3) to (𝑡1, 𝑡2, 𝑡3).
The configuration (𝑠1, 𝑠2, 𝑠3) is connected because (𝑠1, 𝑠2), (𝑠1, 𝑠3) ∈
𝐸𝐶 . Intuitively, agent at 𝑠3 can communicate with the agent at 𝑠2
via the agent at 𝑠1 (multi-hop).

An execution 𝑒 of length ℓ is a sequence of configurations, de-
noted (𝑐1, ..., 𝑐ℓ ) such that for each 𝑖 ∈ {1, ..., ℓ − 1}, 𝑐𝑖 and 𝑐𝑖+1 are
consequent. An execution 𝑒 of length ℓ is connected in the graph
of communication 𝐺𝐶 if for each 𝑖 ∈ {1, ..., ℓ }, 𝑐𝑖 is connected. We
want a connected execution from 𝑠 to 𝑡.

Importantly, as in MAPF (unlike [16]), we suppose that agents
do not collide. In other words, agents have distinct positions in all
configurations. We thus consider here a simple form of collision
constraints; one could as well consider forbidding taking the same
edge in opposite directions [20].

Example 2.1. Figure 2 shows an example of a connected exe-
cution from the Figure 1. Agents start in configuration (𝑠1, 𝑠2, 𝑠3)
(see Figure 1(a)). Note that agent 𝑎2 communicates indirectly with
agent 𝑎3, via the agent 𝑎1. Then the agents move synchronously to
configuration (𝑠2, 𝑣, 𝑢): agent 𝑎1 moves to 𝑠2 by taking the move-
ment edge (𝑠1, 𝑠2) ∈ 𝐸𝑀 , agent 𝑎2 takes the edge (𝑠2, 𝑣) ∈ 𝐸𝑀
and 𝑎3 takes (𝑠3, 𝑢) ∈ 𝐸𝑀 . At step 2, the configuration is (𝑣, 𝑡2, 𝑡1).
Note that now agent 𝑎2 communicates directly with agent 𝑎3 via
the communication edge (𝑡2, 𝑡1) ∈ 𝐸𝐶 ; 𝑎1 communicates with 𝑎3
indirectly via 𝑎2.

𝑧

𝑥

𝑦

𝑣

𝑤

𝑢

𝜌 = 2

Figure 3: 3D grid topological graph, with 13 vertices and with
a radius 𝜌 = 2.

Definition 2.2 (CMAPF Problem). Given ⟨𝐺, 𝑠, 𝑡⟩ decide if there
is a connected execution (𝑐1, ..., 𝑐ℓ ) such that 𝑐1 = 𝑠 and 𝑐ℓ = 𝑡. We
say that the execution is from 𝑠 to 𝑡.

The CMAPF problem was proven to be PSPACE-complete on
general graphs [16]. However, the reduction requires a connectivity
graph 𝐺𝐶 that is arbitrary and unrealistic. In the next section, we
establish the PSPACE-hardness of the problem on instances defined
on subgraphs of 3D grids, and with range-based communication.

3 PSPACE-COMPLETENESS IN 3D
We focus on 3D grid instances where the communication is range-
based.

Definition 3.1. A 3D grid topological graph is a triplet (𝐺, 𝑝𝑜𝑠, 𝜌)
where 𝐺 = (𝑉 , 𝐸𝑀, 𝐸𝐶 ) is a topological graph, 𝑝𝑜𝑠 is a position
function 𝑝𝑜𝑠 : 𝑉 → N3, which is injective, and a radius 𝜌 which
respects the following conditions:

(1) for all (𝑢, 𝑣) ∈ 𝐸𝑀 ,

|pos(𝑢).𝑥 − pos(𝑣).𝑥 | + |pos(𝑢).𝑦 − pos(𝑣).𝑦|+
|pos(𝑢).𝑧 − pos(𝑣).𝑧| ≤ 1,

where pos(𝑢).𝑥, pos(𝑢).𝑦, pos(𝑢).𝑧 denote the three compo-
nents of pos(𝑢);

(2) and (𝑢, 𝑣) ∈ 𝐸𝐶 if and only if 𝑑 (pos(𝑢), pos(𝑣)) ≤ 𝜌, where
𝑑 is the Euclidean distance (range-based communication).

Example 3.2. Figure 3 shows a 3D grid topological graph with
13 vertices and with a radius 𝜌 = 2. The graph consists of two
layers: the bottom layer (𝑧 = 0) contains 9 vertices, while the
top layer (𝑧 = 1) contains 4 vertices. As shown, the graph can be
seen a subgraph of the 3D grid. For instance, 𝑝𝑜𝑠 (𝑢) = (0, 2, 0),
𝑝𝑜𝑠 (𝑣) = (0, 1, 1) and 𝑝𝑜𝑠 (𝑤) = (2, 0, 0). An agent can move from
layer 0 to layer 1 throw a movement edge from the node at position
(1, 0, 0) to the node at position (1, 0, 1). We have:

• (𝑢, 𝑣) ∈ 𝐸𝐶 because
• (𝑢, 𝑤) ∉ 𝐸𝐶 because

√
02 + 12 + 12 =
√
22 + 22 + 0 =

√
√

2 ≤ 2;
8 > 2.

Now, a 3D grid instance for the CMAPF problem is described
by a 3D topological graph (𝐺, 𝑝𝑜𝑠, 𝜌, 𝑠, 𝑡) where (𝐺, 𝑝𝑜𝑠, 𝜌) is a 3D
grid topological graph, and two connected configurations 𝑠 and 𝑡.
In this section, we prove the following theorem:

Theorem 3.3. CMAPF is PSPACE-complete, even for a graph which

is a 3D grid instance.

𝑒2

2

𝑒1
2

𝑒3
2

𝑒2

2

𝑒1
1

𝑒3
1

Figure 4: The two types of nodes in an AND/OR graph: OR
node (left) and AND node (right). An OR node has three inci-
dent edges of weight 2 (blue), while an AND has two incident
edges of weight 1 (red) and one of weight 2.

PSPACE membership holds because CMAPF is in PSPACE in the
general case [16]. The PSPACE-hardness on arbitrary graphs relies
on a reduction from the the PSPACE-complete problem related to
Nondeterministic Constraint Logic (NCL) [5]. Here, we also provide
a reduction from NCL, while our technical contribution consists in
defining the reduction with the restrictions of a 3D grid graph, and
only using range-based communication.

3.1 Nondeterministic Constraint Logic
Let us recall that a graph is planar if there exists an injective em-
bedding of the set of nodes in N2 such that edges do not cross. An
AND/OR graph is an undirected planar graph 𝔊 such that:

• each edge has a weight of either 1 or 2;
• each node is either an OR node, or an AND node (see Figure 4;

ignore the direction of edges for now).

As shown in Figure 4, a node has three incident edges 𝑒1, 𝑒2, 𝑒3.
All are of weight 2 for an OR node. For an AND node, two of them,
say 𝑒1, 𝑒3, are of weight 1 while the third one, 𝑒2, is of weight 2.

Given an AND/OR graph 𝔊, a configuration 𝛾 is an orientation of
𝔊, defining a direction for each edge in 𝔊; 𝛾 is valid if the in-flow
of each node (the sum of the weights of the incoming edges) is at
least 2 (in the directed graph defined by the pair (𝔊, 𝛾)). Concretely,
for an OR node, at least one edge must enter the node. For an
AND node, either 𝑒2 enters the node or 𝑒1 and 𝑒3 both enter the
node. Given two valid configurations 𝛾, 𝛾 ′, we define an elementary
flip
−−→ 𝛾 ′, iff 𝛾 ′ is obtained from 𝛾 by flipping the
step denoted, 𝛾
direction of exactly one edge. An NCL execution is a sequence of

valid configurations 𝛾0, . . . , 𝛾ℓ with 𝛾𝑖

flip
−−→ 𝛾𝑖+1.

Definition 3.4. The NCL reconfiguration problem is defined as
follows: given an AND/OR graph 𝔊 and two valid configurations
𝛾0, 𝛾𝑓 , does there exist an execution 𝛾0

flip
−−→ 𝛾𝑓 ?

flip
−−→ . . .

Theorem 3.5. [5] The NCL reconfiguration problem is PSPACE-

complete.

3.2 Description of the reduction
Let us consider a NCL instance (𝔊, 𝛾0, 𝛾𝑓 ). We show how to con-
struct in poly-time a 3D CMAPF instance written 𝑡𝑟 (𝔊, 𝛾0, 𝛾𝑓 ) =

(𝐺, 𝑝𝑜𝑠, 𝜌, 𝑠, 𝑡) such that 𝛾0
execution from 𝑠 to 𝑡.

flip
−−→ . . .

flip
−−→ 𝛾𝑓 iff there is a connected

The 3D grid topological graph (𝐺, 𝑝𝑜𝑠, 𝜌) contains 5 layers as
shown in Figure 5. Each layer lies in a 𝑂𝑥𝑦-plane (a plane in which

the 𝑧-coordinate is constant). As we will see, each layer contains
some gadgets. As indicated in Figure 5, layer 0 and 1 are at distance
2, and the 𝑂𝑥𝑦-plane between layer 0 and 1 does not contain any
node (in other words, it is an obstacle). In the same way, layer 1
and 2 are at distance 8 and are separated by 7 𝑂𝑥𝑦-planes without
any node (obstacle), and so on. Let 𝜌 = 10 be our communication
radius.

8

2

8

2

𝑧

•𝑦

𝑥

layer 4: complete grid of agents

layer 3: relay agent
layer 2: stationary agents

layer 1: edge-paths
layer 0: inflow constraints

Figure 5: Sectional view of the organisation of the 3D topo-
logical graph 𝐺. Layers contain gadgets. Each layer is given
with a summary of its contents.

Encoding of the AND/OR graph 𝔊. We consider an embedding
of 𝔊 in a 2D grid in which edges do not cross each other and
follow the lines of the grid; such an embedding always exists and
is computable in poly-time [12].

In layer 1, we place flipping agents that will simulate the di-
rections of the edges on 𝔊. This layer has the same shape as the
embedding of the AND/OR graph 𝔊 and each node in 𝔊 is replaced
by a gadget of the form given in Figure 6. The edge 𝑒𝑖 in Figure 4 is
symbolized by the path between nodes 𝑢𝑖 and 𝑣𝑖 , called an edge-path.
For simplicity, in Figure 4, the edge-path is depicted as a straight
line, but in general it follows the shape of that edge in the planar
AND/OR graph embedding. The flip of 𝑒𝑖 corresponds to the agent
moving from 𝑢𝑖 to 𝑣𝑖 , or from 𝑣𝑖 to 𝑢𝑖 . We say that a flipping agent
is near 𝑢𝑖 (resp. 𝑣𝑖 ) when it is placed at a distance of at most 6
from 𝑢𝑖 (resp. 𝑣𝑖 ) on the layer 1. When the agent is placed near
𝑢𝑖 (resp. near 𝑣𝑖 ), it means that the edge 𝑒𝑖 is going in (resp. out)
the AND/OR node (in Figure 4). A flipping agent can in general be
anywhere on its edge-path between 𝑢𝑖 and 𝑣𝑖 . But when they are
all near extremities 𝑢𝑖 or 𝑣𝑖 , this corresponds to an AND/OR graph
configuration.

In order to impose the dynamics of NCL, we introduce layer 4
which is far from layer 1 and thus is not connected to it directly.
Layer 4 contains just a complete grid of stationary agents (see Fig-
ure 9) that are connected. We will introduce layer 2 and 3 that
respectively impose that a configuration of the agents should rep-
resent a AND/OR configuration, and that a single flip occurs each
time.

Connectivity for AND/OR configurations. Layer 2, shown in Fig. 7,
provides connectivity to flipping agents who are near some edge-
path extremities 𝑢𝑖 or 𝑣𝑖 . It consists of stationary agents placed at
the vertices 𝑢 ′
𝑖 (resp. 𝑣 ′
𝑖 ) is placed exactly above 𝑢𝑖
(resp. 𝑣𝑖 ). Layer 2 is placed at a distance of 8 from layer 1. Thereby,
a stationary agent only communicates with the flipping agent that
is just below them (or almost below but near the extremity). More
precisely, the flipping agent is near the extremity if and only if

𝑖 : vertex 𝑢 ′

𝑖 and 𝑣 ′

62 + 82 = 10. For instance, the stationary agent at 𝑢 ′

it communicates directly with the stationary agent above it, as
√
𝑖 communi-
cates with the agent near 𝑢𝑖 if there is one. Note that the stationary
agents are all connected to layer 4.

Flips. An elementary step 𝛾

flip
−−→ 𝛾 ′ consists in flipping exactly
one edge. In other words, we should ensure that at most one flipping
agent should move from an extremity to another. To do that, we
introduce layer 3 made of a fully connected grid with a relay agent
on it (Figure 8). The idea is that the relay agent follows the flipping
agent while she moves from 𝑢𝑖 to 𝑣𝑖 (or conversely). The layer 3
is at a distance of 10 from layer 1 to ensure that the relay agent
provides the connectivity of layer 4 to at most one flipping agent
that attempts to move.

NCL configurations should be valid. Last, we add layer 0 to ensure
that the incoming flow in each AND/OR node is at least 2 (Figure
10).

√

62 + 62 + 22 =

(a) An OR node must be pointed to by at least one edge, since all
edges 𝑒1, 𝑒2 and 𝑒3 are of weight 2. In our construction, we
need thus to ensure that at least one flipping agent must be
near 𝑢1, 𝑢2 or 𝑢3. To this aim, we introduce a line of agents
𝑎1, 𝑎2, 𝑎3 that are all connected (see Figure 10a). For them to
be connected with all the other agents, one flipping agent
must be near 𝑢1, 𝑢2 or 𝑢3.
For instance, a flipping agent in 𝑢1 provides direct connec-
tivity to 𝑎1: the distance between 𝑢1 and the position 𝑎1 is
√
76 < 10. Note that agents 𝑎1 − 𝑎2 − 𝑎3 will
not be connected otherwise: agents in layer 2 are too far
from 𝑎1 − 𝑎2 − 𝑎3 to provide connectivity to 𝑎1 − 𝑎2 − 𝑎3.
(b) For an AND node, recall that the edges 𝑒1, 𝑒2 and 𝑒3 are of
weights 1, 2 and 1 respectively. The constraint of having an
in-flow of at least 2 can be reformulated by:
(i) either 𝑒1 or 𝑒2 is pointing in (or both);
(ii) and either 𝑒2 or 𝑒3 is pointing in (or both).
1 − 𝑎′

2 − 𝑎′′
We therefore add the line of agents 𝑎′
3 )
for handling condition (i) (resp. (ii)). If 𝑒1 and 𝑒2 are pointing
out (condition (i) is unsatisfied), then it means no agent is
in 𝑢1 (or nearby) and no agent is in 𝑢2 (or nearby), then the
agents 𝑎′
2 are disconnected from the rest of the group.
We defined the vertices of 𝑡𝑟 (𝔊, 𝛾0, 𝛾𝑓 ) = (𝐺, 𝑠, 𝑡) as well as their
positions. It remains to define 𝑠 and 𝑡. We show how to map and
AND/OR graph configuration 𝛾 to a configuration of agents 𝑐𝛾 .
We define 𝑠 := 𝑐𝛾0 and 𝑡 := 𝑐𝛾𝑓 . For an AND/OR configuration 𝛾,
𝑐𝛾 is the configuration in which, at each AND or OR node, in the
corresponding gadget of Figure 6, if 𝑒𝑖 enters that node, then the
corresponding agent is in 𝑢𝑖 (and if 𝑒𝑖 leaves that node, she is near
𝑣𝑖 ). The relay agent is, say, at the bottom-left corner as in Figure 8.
The other agents are stationary so their positions are obvious.

2 (resp. 𝑎′′

1 − 𝑎′

3.3 Properties of the reduction

Proposition 3.6. 𝑡𝑟 (𝔊, 𝛾0, 𝛾𝑓 ) = (𝐺, 𝑝𝑜𝑠, 𝜌, 𝑠, 𝑡) is computable in

time polynomial in the size of 𝔊, 𝛾0, 𝛾𝑓 .

Proof. The computation starts by computing an embedding for
the graph 𝔊 in a grid in 𝑝𝑜𝑙𝑦 (|𝔊|) (this is doable via the result of

𝑣2

⌣

𝑣 ′
2

𝑦

•𝑧

𝑥

6

⌣

𝑢1

⌣

𝑢2

𝑢3

𝑦

•𝑧

𝑥

6

⌣

𝑢 ′
1

⌣

𝑢 ′
2

⌣

𝑢 ′
3

𝑣1

⌣

𝑣3

⌣

𝑣 ′
1

⌣

𝑣 ′
3

Figure 6: Layer 1: Three edge-paths that simulate an AND
or OR vertex in the AND/OR graph. Each path 𝑢𝑖 − 𝑣𝑖 , called
an edge-path, corresponds to an edge in the AND/OR graph.
For instance, the agent at 𝑢1 can move along its edge-path
until 𝑣1.

[12]). That embedding will then give the positions of the gadget on
□
layer 0 and 1.

Proposition 3.7. With 𝑡𝑟 (𝔊, 𝛾0, 𝛾𝑓 ) = (𝐺, 𝑠, 𝑡), we have: 𝛾0

flip
−−−→

. . . flip

−−−→ 𝛾𝑓 iff there is a connected execution from 𝑠 to 𝑡.

Proof. ⇒ Suppose 𝛾0

flip
flip
−−→ 𝛾𝑓 . We construct an ex-
−−→ . . .
ecution from that sequence of flips as follows. For each flip of a
given edge, we move the corresponding flipping agent to the other
extremities (𝑢𝑖 to 𝑣𝑖 , or 𝑣𝑖 to 𝑢𝑖 ) with the relay agent moving above
that flipping agent on the same way in its own layer 3. The obtained
execution is connected. On the one hand, when flipping agents are
at some 𝑢𝑖 /𝑣𝑖 , the connectivity is guaranteed by the agents of layer
2. On the other hand, when a flipping agent is moving, its connec-
tivity is guaranteed by the relay agent. Agents 𝑎1 − 𝑎2 − 𝑎3 and
𝑎′
1 − 𝑎′
3 of Figure 10 remain connected to the rest of the
group because the in-flow at each AND/OR node is at least 2.

2 − 𝑎′′

2 − 𝑎′′

⇐ Conversely, consider a connected execution from 𝑠 to 𝑡.
We extract a sequence of flips as follows. When a flipping agent
moves far from an edge-path extremity, it must be accompanied
by the relay agent in order to remain connected to the rest of the
agents. During its move, it starts near some 𝑢𝑖 (or 𝑣𝑖 ). If it goes
back near the same extremity (𝑢𝑖 to 𝑢𝑖 , or 𝑣𝑖 to 𝑣𝑖 ), the move is
simply ignored. Otherwise, if the flipping agent goes near the other
extremity (𝑢𝑖 to 𝑣𝑖 , or 𝑣𝑖 to 𝑢𝑖 ), that move is interpreted as a flip
of the corresponding edge. The sequence of flips extracted in that
way transform 𝛾0 into 𝛾𝑓 . Again, as the agents of layer 0 are always
connected, it guarantees that the in-flow at each AND/OR node
□
during the extracted sequence of flips is at least 2.

4 ALGORITHM
In this section, we will present a simple algorithm to solve the
connected MAPF problem. We first review previously published
algorithms from [16], which will be the baseline for comparison.

Figure 7: Layer 2: Stationary isolated agents placed above the
extremities of the edge-paths.

𝑦

•𝑧

𝑥

...

. . .

1

⌣
relay agent

Figure 8: Layer 3: a complete connected grid with a single
so-called relay agent being moving on it.

𝑦

•𝑧

𝑥

...

. . .

⌣
⌣
⌣
⌣
⌣
⌣
⌣

⌣
⌣
⌣
⌣
⌣
⌣
⌣

⌣
⌣
⌣
⌣
⌣
⌣
⌣

⌣
⌣
⌣
⌣
⌣
⌣
⌣

⌣
⌣
⌣
⌣
⌣
⌣
⌣

⌣
⌣
⌣
⌣
⌣
⌣
⌣

⌣
⌣
⌣
⌣
⌣
⌣
⌣

1

Figure 9: Layer 4: a complete grid of isolated agents.

One of the main difficulties in multi-agent path finding is com-
binatorial explosion due to the number of agents. In fact, from
each configuration, there is, in general, an exponential number
of successor configurations despite the connectivity constraints.
Searching for a plan in an exponentially-branching state space is
infeasible, and even choosing a good successor configuration is a
nontrivial task. To deal with the large branching factor, a greedy
approach was presented [16] in which a heuristic A∗ search is used
to select a successor configuration step by step to minimize the
remaining distance to the target configuration. This becomes theo-
retically complete with an additional backtracking mechanism. The
resulting algorithm is similar to a DFS over the configuration space
guided by a heuristic; so it will be named simply DFS in our experi-
ments. We use here the authors’ own implementation modified to
take collision constraints into account; this was a straightforward
adaptation. The authors also present sampling-based algorithms

𝑦

•𝑧

𝑥

𝑎1
⌣
⌣

⌣

⌣
⌣
𝑎2

⌣

𝑎3
⌣
⌣

6

(a) Simulating an OR node: agents from 𝑎1 − 𝑎2 − 𝑎3 must be
connected.

𝑦

•𝑧

𝑥

6

⌣
𝑎′
1

⌣
𝑎′
2

⌣
𝑎′′
2

⌣
𝑎′′
3

(b) Simulating an AND node: agents from 𝑎′
be connected.

1 −𝑎′

2 and 𝑎′′

2 −𝑎′′

3 must

Figure 10: Layer 0: handling the inflow of at least 2 at each
node. Agents 𝑎1 − 𝑎2 − 𝑎3, 𝑎′1, 𝑎′
3 are all isolated and
thus stationary. Vertices shown in gray are those in Layer 1.

2 , 𝑎′′

2, 𝑎′′

in which the successors are selected with a randomization scheme.
These scale up to 10 agents [16] but become inefficient above 20
agents. We will only consider the deterministic DFS algorithm as a
representative of this approach. An algorithm is described in [6]
but within a different setting requiring only periodic connectivity.

4.1 Our suggestion
We show here that a straightforward application of the windowed
hierarchical cooperative A∗ (WHCA∗) [14] with a simple random-
ized conflict resolution mechanism performs much better than the
above algorithms from the literature. The idea of CA∗, explained
in our setting, is the following. In order to compute a plan for 𝑛
agents, we select a random total order of the agents. We first com-
pute a shortest path 𝜌1 for the first agent from their source to target
vertices. At iteration 𝑖, we compute a shortest path 𝜌𝑖 for the 𝑖-th
agent from their source to target, but subject to the constraints of
the previous agents: the 𝑖-th agent cannot occupy the same ver-
tex as a previous agent at the same time step (that is, 𝜌𝑖
𝑡 for
all 1 ≤ 𝑗 < 𝑖 and all 𝑡), and moreover they must be connected to

𝑡 ≠ 𝜌 𝑗

𝑡 , 𝜌𝑖

one of the previous agents at all moments (that is, for each 𝑡, there
exists 1 ≤ 𝑗 < 𝑖 such that (𝜌 𝑗

𝑡 ) ∈ 𝐸𝐶 ).
The algorithm retries different orderings until an execution is
found. The window optimization consists in changing the order
randomly after a certain number of steps. Furthermore, the hierar-
chical version uses heuristic values that are shortest path distances
computed by ignoring all interactions between agents. With both
optimizations, this defines the WHCA∗ algorithm. We call each
iteration that starts from the source a trial.

It is known however that WHCA∗ is not complete [14]: on some
instances that a solution, WHCA∗ does not find one. The source
of incompleteness is due to the fact that the algorithm assumes
that one of the agents follows a shortest path. Such a situation is
depicted in Fig. 11. In the figure, the target of the upper agent is
𝑡1, and their shortest path moves upwards, and disconnects from
the bottom agent. The bottom agent’s situation is symmetric: they
want to reach the vertex 𝑡2, and their shortest path moves down,
disconnecting from the other agent. The only solution is to pass
through the path at the middle; but then none of the agents use a
shortest path, and WHCA∗ fails. WHCA∗ can also fail due to colli-
sion conflicts if the execution requires agents to idle, for instance,
to let other agents pass.

𝜌 = 4

⌣𝑠1

𝑠2

⌣

𝑡1

𝑡2

Figure 11: An instance that is difficult for WHCA∗. Agent
at 𝑠1 should reach 𝑡1, agent at 𝑠2 should reach 𝑡2.

Randomized conflict resolution. We focus here on conflicts due
to connectivity constraints, and introduce a simple mechanism
to resolve such conflicts, well adapted to connectivity constraints.
While running WHCA∗, if no solution is found after 𝜃 trials, then
we start each subsequent trial by randomly selecting a direction,
and moving all agents from the source towards that direction for
a number ℓ of steps using WHCA∗, and continuing the trial from
this new configuration to target. We also apply randomization
inside each trial: if the execution has not been extended in the last
𝜃 ′ windows, then we move towards a random configuration, and
continue our way towards target. We slowly increment ℓ after each
trial so that if a longer execution towards a particular direction
is necessary, this will be tried eventually. In Fig. 11, moving the
agents towards left (including upper or bottom left), for a few steps
suffices to unblock the situation, a solution is found eventually.

The resulting algorithm is probabilistically complete. In fact,
when ℓ is sufficiently large, if there is a connected execution from
the current configuration to goal configuration, then, there is a
nonzero probability to pick precisely that execution. This holds at
each step with a uniform lower bound on the probability; thus, it
will eventually be picked with probability 1. Of course, no useful
bound on the expected time can be obtained from this reasoning.
Thus, we rather evaluate the algorithm empirically.

Offices 2D

Cubicles 2D

Pyramid 3D

Obstacles 3D

Size: 80 x 60

Size: 36 x 43

Size: 21 x 15 x 5

Size: 70 x 60 x 5

Figure 12: The four maps used to obtain topological graphs. Obstacles are black pixels. The communication range is 1 pixel
for Offices and Obstacles, and 3 pixels for Cubicles and Pyramid.

(a) Offices 2D

(b) Cubicles 2D

(c) Pyramid 3D

(d) Obstacles 3D

Figure 13: Average success rate of the algorithms as a function of the number of agents. Each point (𝑥, 𝑦) means that a percent-
age of 𝑦 among the 20 instances with 𝑥 agents were solved each within the timeout (5 minutes).

(a) Offices 2D

(b) Cubicles 2D

(c) Pyramid 3D

(d) Obstacles 3D

Figure 14: Cactus plots of the execution times: point (𝑥, 𝑦) means that 𝑥 instances were solved each within 𝑦 seconds.

The approach of WHCA∗ is particularly well adapted for con-
nected MAPF. In fact, due to connectivity, agents are tightly depen-
dent on each other since none of them can travel far from the group.
This makes the problem quite different than the disconnected case
where interactions between agents can be sparse and local (only a
few collisions might have to be addressed at distinct instants). In
WHCA∗, once an execution is found for a few agents, this can create
a lot of room for the rest of the agents, and the search can find an
execution quickly, or make progress towards the goal. Blocking
situations are overcome by conflict resolution.

4.2 Experiments
We evaluate the WHCA∗ approach in comparison with the DFS
algorithm from [16] on four benchmarks: the maps Offices and
Cubicles are 2D grids; Obstacles and Pyramid are in 3D. The bitmap
images corresponding to each map are shown in Fig. 12. The 3D
maps were obtained from the bitmap image by copying it 5 times
towards a third dimension, and adding obstacles at the free cells
with a density of 15%. Similar benchmarks were considered in
[6, 16]; Offices appears in [6]. For each 2 ≤ 𝑛 ≤ 80, we created 20
random instances with 𝑛 agents, on each map. The instances on the

Cubicles were particular: we placed two agents at a position similar
to that of Fig. 11 while others were assigned random positions.

In our implementation, at each trial, we compute the longest pos-
sible execution before changing the order of the agents. So trials do
not necessarily change the ordering of the agents at predetermined
window sizes, but only when the current ordering does not allow
to make further progress. The program attempts to extend each
trial 100 times with a random order; let us call these extension trials.
This parameter was observed to work well on our benchmarks. A
too small value meant that trials ended without making enough
progress so solutions were found less often; and a too large value
meant that too much time was spent in each trial so less time could
be spent for remaining trials. We show the performance with 300
extension trials in Fig. 15 where a performance drop was observed.
We allowed the solver 5 minutes per instance. The parameters used
in conflict resolution was 𝜃 = 5, ℓ = 10. A small (arbitrary) value
for 𝜃 was convenient here because WHCA∗ alone could not make
any progress from the source configuration in Cubicles, a small
value meant that this initial conflict could be resolved quickly. Mov-
ing towards a random direction for a small number of steps does
not affect the feasibility of the instance; it can only slightly increase
the total length of the computed plan.

(a) Offices 2D

(b) Cubicles 2D

(c) Pyramid 3D

(d) Obstacles 3D

Figure 15: Success rates of WHCA∗ with 100, 200, and 300 extension trials with a 5 minute timeout per instance.

In Fig. 16, we show the effect of randomized conflict resolution
on performance, particularly in the Cubicles instances which con-
tain at least two agents placed in a position depicted in Fig. 11. The
success rate without randomization is 0 for small instances. For
larger numbers of agents, this varies, in a rather unpredictable way
but stays clearly lower than the success rate with randomization.
This is due to randomly generated instances in which some agents
can be placed near the problematic situation and render the instance
solvable by WHCA∗. Overall, randomization helped increase and
stabilize the success rate. It did not have a large impact on per-
formance on other maps (not shown here) where instances were
generated completely randomly. However, on several instances of
Offices and Obstacles we noticed that situations similar to Figure 11
did occur, and randomization did help solve the instances; these
were however not frequent enough to be noticed on average plots
because instances were generated randomly.

5 CONCLUSION
In this work, we proved the PSPACE-hardness of the CMAPF prob-
lem when the topological graph is a subgraph of a 3D grid un-
der range-based communication, establishing the computational
complexity in a more realistic setting than in the literature. The
hardness for subgraphs of the 2D grid is open. Our experiments
contained both 2D and 3D maps, but the shape of the map seemed
to have more impact on performance than its dimension. An im-
portant question is automatizing the choice of the parameters used
in WHCA∗ (such as ℓ, 𝜃, 𝜃 ′). We chose them empirically and specif-
ically for our benchmarks, but other values might be preferable for
maps of different shapes and sizes.

The connected coverage problem consists in finding an execution
that visits all vertices and is similar to CMAPF [4]. In particular, it
is also PSPACE-complete. We conjecture that our reduction could
be adapted to prove the PSPACE-hardness of the coverage problem
in 3D.

Figure 16: Success rates of WHCA∗ with and without ran-
domized conflict resolution (for 100 extension trials).

The results are shown in Fig. 13 which gives the average success
rates for the instances per number of agents. The success rate of
WHCA∗ was systematically higher than that of DFS. The former
scaled up to 80 agents on Pyramid and Obstacles maps, and up
to about 30-40 on Offices and Cubicles. The performance of DFS
dropped quickly, often after 10 agents. Figure 14 compares the
execution times; the WHCA∗ solved a large number of instances;
for instance, in Obstacles, the algorithm solved about 1200 instances
(out of 1580) each under a minute, while the DFS algorithm could
only solve about 400 instances each under a minute.

Figure 15 compares the success rates of the WHCA∗ algorithm
with 100, 200, and 300 extension trials. A larger number means that
the algorithm insists in trying to extend each trial. The performance
in Offices improved as this number increased, presumably because
a larger number of ordering changes is often required in this map,
but that in Cubicles was better with a smaller number. A smaller
number has the advantage of inducing more fresh trials within the
given deadline. There was no substantial difference in performance
in Pyramid and Obstacles maps.

ACKNOWLEDGMENTS
This work was supported by the ANR EpiRL project ANR-22-CE23-
0029.

REFERENCES
[1] F. Amigoni, J. Banfi, and N. Basilico. 2017. Multirobot Exploration of
Communication-Restricted Environments: A Survey. IEEE Intelli. Sys. 32, 6 (2017),
48–57. https://doi.org/10.1109/MIS.2017.4531226

[2] Zahy Bnaya and Ariel Felner. 2014. Conflict-Oriented Windowed Hierarchical
Cooperative A*. In 2014 IEEE International Conference on Robotics and Automation
(ICRA). 3743–3748. https://doi.org/10.1109/ICRA.2014.6907401

[3] Tristan Charrier, Arthur Queffelec, Ocan Sankur, and François Schwarzentruber.
2020. Complexity of planning for connected agents. Auton. Agents Multi Agent
Syst. 34, 2 (2020), 44. https://doi.org/10.1007/s10458-020-09468-5

[4] Tristan Charrier, Arthur Queffelec, Ocan Sankur, and François Schwarzentruber.
2020. Complexity of planning for connected agents. Auton. Agents Multi Agent
Syst. 34, 2 (2020), 44. https://doi.org/10.1007/s10458-020-09468-5

[5] Robert A. Hearn and Erik D. Demaine. 2005. PSPACE-completeness of sliding-
block puzzles and other problems through the nondeterministic constraint logic
model of computation. Theor. Comput. Sci. 343, 1-2 (2005), 72–96. https://doi.
org/10.1016/j.tcs.2005.05.008

[6] Geoffrey A. Hollinger and Sanjiv Singh. 2012. Multirobot Coordination With
Periodic Connectivity: Theory and Experiments. IEEE Transactions on Robotics
28, 4 (2012), 967–973. https://doi.org/10.1109/TRO.2012.2190178

[7] Jiaoyang Li, Andrew Tinka, Scott Kiesel, Joseph W Durham, TK Satish Kumar, and
Sven Koenig. 2021. Lifelong multi-agent path finding in large-scale warehouses.
In Proceedings of the AAAI Conference on Artificial Intelligence, Vol. 35. 11272–
11281.

[8] Hang Ma and Sven Koenig. 2017. AI Buzzwords Explained: Multi-Agent Path
Finding (MAPF). AI Matters 3 (2017). https://doi.org/10.1145/3137574.3137579
[9] Bernhard Nebel, Thomas Bolander, Thorsten Engesser, and Robert Mattmüller.
2019. Implicitly Coordinated Multi-Agent Path Finding under Destination Uncer-
tainty: Success Guarantees and Computational Complexity. J. Artif. Intell. Res. 64
(2019), 497–527. https://doi.org/10.1613/jair.1.11376

[10] Arthur Queffelec, Ocan Sankur, and François Schwarzentruber. 2020. Conflict-
arXiv preprint

based search for connected multi-agent path finding.

arXiv:2006.03280 (2020).

[11] Arthur Queffelec, Ocan Sankur, and François Schwarzentruber. 2021. Planning
for Connected Agents in a Partially Known Environment. In AI 2021 - 34th
Canadian Conference on Artificial Intelligence. Vancouver / Virtual, Canada, 1–23.
https://hal.archives-ouvertes.fr/hal-03205744

[12] Walter Schnyder. 1990. Embedding Planar Graphs on the Grid. In Proceedings of
the First Annual ACM-SIAM Symposium on Discrete Algorithms (San Francisco,
California), David S. Johnson (Ed.). SIAM, 138–148. http://dl.acm.org/citation.
cfm?id=320176.320191

[13] Guni Sharon, Roni Stern, Ariel Felner, and Nathan R Sturtevant. 2015. Conflict-
based search for optimal multi-agent pathfinding. Artificial Intelligence 219 (2015),
40–66.

[14] David Silver. 2005. Cooperative Pathfinding. In Proceedings of the First AAAI
Conference on Artificial Intelligence and Interactive Digital Entertainment (Marina
del Rey, California) (AIIDE’05). AAAI Press, 117–122.

[15] Trevor Scott Standley and Richard Korf. 2011. Complete Algorithms for Cooper-
ative Pathfinding Problems. In Twenty-Second International Joint Conference on
Artificial Intelligence.

[16] Davide Tateo, Jacopo Banfi, Alessandro Riva, Francesco Amigoni, and Andrea
Bonarini. 2018. Multiagent Connected Path Planning: PSPACE-Completeness and
How to Deal With It. Proceedings of the AAAI Conference on Artificial Intelligence
32, 1 (Apr. 2018). https://doi.org/10.1609/aaai.v32i1.11587

[17] Glenn Wagner and Howie Choset. 2017. Path Planning for Multiple Agents under
Uncertainty. In Proceedings of the Twenty-Seventh International Conference on
Automated Planning and Scheduling, ICAPS 2017, Pittsburgh, Pennsylvania, USA,
June 18-23, 2017, Laura Barbulescu, Jeremy Frank, Mausam, and Stephen F. Smith
(Eds.). AAAI Press, 577–585. https://aaai.org/ocs/index.php/ICAPS/ICAPS17/
paper/view/15756

[18] Ko-Hsin Cindy Wang and Adi Botea. 2011. MAPP: A Scalable Multi-Agent Path
Planning Algorithm with Tractability and Completeness Guarantees. J. Artif. Int.
Res. 42, 1 (sep 2011), 55–90.

[19] Ko-Hsin Cindy Wang, Adi Botea, et al. 2008. Fast and Memory-Efficient Multi-

Agent Pathfinding.. In ICAPS. 380–387.

[20] Zheng Zhang, Qing Guo, Juan Chen, and Peijiang Yuan. 2018. Collision-Free
Route Planning for Multiple AGVs in an Automated Warehouse Based on Colli-
sion Classification. IEEE Access 6 (2018), 26022–26035. https://doi.org/10.1109/
ACCESS.2018.2819199

