Containment of Shape Expression Schemas for RDF
Slawomir Staworko, Piotr Wieczorek

To cite this version:

Slawomir Staworko, Piotr Wieczorek. Containment of Shape Expression Schemas for RDF. PODS 2019
- 38th ACM SIGMOD-SIGACT-SIGAI Symposium on PRINCIPLES OF DATABASE SYSTEMS,
Jun 2019, Amsterdam, Netherlands. pp.303-319, ￿10.1145/3294052.3319687￿. ￿hal-01959143￿

HAL Id: hal-01959143

https://inria.hal.science/hal-01959143

Submitted on 27 Jun 2019

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Containment of Shape Expression Schemas for RDF

Sławek Staworko
CRIStAL, INRIA LINKS, CNRS
University of Lille
France
slawomir.staworko@inria.fr

Piotr Wieczorek
Institute of Computer Science
University of Wrocław
Poland
piotr.wieczorek@cs.uni.wroc.pl

ABSTRACT
We study the problem of containment of shape expression
schemas (ShEx) for RDF graphs. We identify a subclass of
ShEx that has a natural graphical representation in the form
of shape graphs and whose semantics is captured with a
tractable notion of embedding of an RDF graph in a shape
graph. When applied to pairs of shape graphs, an embedding
is a sufficient condition for containment, and for a practical
subclass of deterministic shape graphs, it is also a necessary
one, thus yielding a subclass with tractable containment.
Containment for general shape graphs is EXP-complete. Fi-
nally, we show that containment for arbitrary ShEx is decid-
able.

CCS CONCEPTS
• Information systems → Graph-based database mod-
els; Resource Description Framework (RDF); • Theory
of computation → Database theory; Database interoper-
ability.

KEYWORDS
RDF, Schema, ShEx, containment, counter-example

ACM Reference Format:
Sławek Staworko and Piotr Wieczorek. 2019. Containment of Shape
Expression Schemas for RDF. In 38th ACM SIGMOD-SIGACT-SIGAI
Symposium on Principles of Database Systems (PODS’19), June 30-
July 5, 2019, Amsterdam, Netherlands. ACM, New York, NY, USA,
17 pages. https://doi.org/10.1145/3294052.3319687

1 INTRODUCTION
Although RDF has been originally introduced schema-free,
it has since become a standalone database format and the
need for a schema language has been identified, with the

Publication rights licensed to ACM. ACM acknowledges that this contribu-
tion was authored or co-authored by an employee, contractor or affiliate of
a national government. As such, the Government retains a nonexclusive,
royalty-free right to publish or reproduce this article, or to allow others to
do so, for Government purposes only.

PODS’19, June 30-July 5, 2019, Amsterdam, Netherlands
© 2019 Copyright held by the owner/author(s). Publication rights licensed
to ACM.
ACM ISBN 978-1-4503-6227-6/19/06. . . $15.00
https://doi.org/10.1145/3294052.3319687

emergence of new RDF applications previously reserved to
relational and semi-structured databases [2, 37]. Recently
introduced by W3C, and under continuous development,
shape expression schema (ShEx) is a formalism for defining
valid RDF graphs [21–23, 38]. ShEx allows to define a set of
types, each type defined with a rule describing the admissible
types of the outbound neighborhood of a node. Inspired by
versatility of schema languages for XML [4, 19], the rules of
ShEx are based on regular expressions.

An example of shape expression schema for RDF graphs
storing bug reports is presented in Figure 1. The schema
requires a bug report to have a description and a user who
reported it. Optionally, a bug report may have an employee
who successfully reproduced the bug. Also, a bug report can
have a number of related bug reports. A user has a name and
an optional email address while an employee has a name and
a mandatory email address.

In this paper, we investigate the classical problem of con-
tainment: given two schemas S and S ′, is the set of instances
satisfying S contained in the set of instances satisfying S ′?
This problem has applications to a vast number of problems
that perform non-trivial reasoning tasks such as data ex-
change, query optimization, and inference [1, 3, 9, 10, 14, 16,
40]. The task at hand is difficult for a number of reasons.

Because the neighborhood of a node in an RDF graph is
unordered, regular expressions define bag languages, also
known as commutative languages [18], where the relative or-
der among symbols is irrelevant. This lack of order gives raise
to a significant degree of nondeterminism when working
with regular bag expressions (RBE). For instance, membership
for RBE i.e., deciding whether a bag of symbols belongs to the
language defined by an RBE, is NP-complete [20]. Similarly,
validation for ShEx i.e., deciding whether a RDF graph satis-
fies a ShEx, is NP-complete too [34]. The need for nondeter-
minism can be limited by disallowing disjunction and permit-
ting the Kleene closure on atomic symbols only. This yields
the class RBE0 with tractable membership and tractable
validation for the corresponding class of shape expression
schemas ShEx0. Similarly, single-occurrence regular bag ex-
pressions (SORBE) have tractable membership and give rise
to deterministic shape expression schemas (DetShEx), where
the same symbol can be used only once. Their validation is
also tractable [34]. Both restrictions offer enough room to

related
*

Bug

y
B
d
e
t
r
o
p
e
r

1

r

e

p

r

o

d

u

?

c

e

d

B

y

r
c
s
e
d

1

User

e

n

a

m

e

m

a

1

?

i

l

name

1

Literal

Employee

email

1

descr

d

e

t

a

l

e

r

“Boom!”

descr

“Kaboom!”

d

e

t

a

l

e

r

y
B
d
e
t
r
o
p
e
r

r

e

p

o

r

t

e

d

B

y

user1

bug3

r
c
s
e
d

“Kabang!”

e

m

a

n

“John”

bug1

related

bug4

e
s
c
r

reportedBy d

“Bang!”

r

e

p

r

o

d

u

c

e

d

B

y

emp1

name

“Mary”

“m@h.org”

bug2

r
e
p
o
r
t
e
d
B
y

user2

name e

m

a

i

e

m

a

i

l

“Steve”

l

“stv@m.pl”

Bug → descr :: Literal, reportedBy :: User, reproducedBy :: Employee?, related :: Bug*
User → name :: Literal, email :: Literal?
Employee → name :: Literal, email :: Literal

Figure 1: An RDF graph with bug reports (top right) together with a shape expression schema (bottom) and the
corresponding shape graph (top left).

accommodate practical uses, and in particular, the schema
in Figure 1 belongs to them both.

Since ShEx is a schema language based on types, com-
paring two schemas requires the ability to compare types,
and consequently, testing S ⊆ S ′ revolves around ques-
tions whether a type t of S is covered by the union of types
s1, . . . , sk of S ′. Indeed, suppose that in the schema in Fig-
ure 1 we replace the type User with two types depending on
whether or not the user has an email address:

User1 → name :: Literal
User2 → name :: Literal, email :: Literal

and adapt the rest of the schema by replacing Bug with

Bug1 → descr :: Literal, reportedBy :: User1,
reproducedBy :: Employee?,
related :: Bug*

1, related :: Bug*
2

Bug2 → descr :: Literal, reportedBy :: User2,
reproducedBy :: Employee?,
related :: Bug*

1, related :: Bug*
2

Although no longer deterministic (the symbol related is
used twice in the type definitions of Bug1 and Bug2), the
modified schema is equivalent to the original one as the type
Bug is covered by the union of the types Bug1 and Bug2, and
the type User by the union of User1 and User2 (the latter
also being equivalent to Employee).

Naturally, the fact that a type might be covered by a union
of types is a source of complexity of the containment problem,
and it is an interesting question if there is a class of schemas
for which comparison on pairs of types alone would suffice.
To answer this question, we use shape graphs, which are
natural graphical representation of ShEx0 (cf. Figure 1), and
propose a graph-theoretic notion of an embedding between
pairs of shape graphs. In essence, an embedding identifies
in a simulation-like manner when a type is covered by an-
other type, and therefore, is a sufficient condition for con-
tainment. We also identify a class DetShEx−
for which em-
0
bedding is a necessary condition for containment. DetShEx−
0
is the class of deterministic shape expressions schema using
RBE0, which furthermore forbids the use of + and, intuitively,
requires every ? to be referenced through *. In particular, the
schema in Figure 1 belongs to DetShEx−
because the type
0
User using email :: Literal? is (indirectly) referenced by
related :: Bug* in type Bug.

Because embeddings are carefully crafted to be tractable,
we obtain a class with tractable containment. The additional
are necessary as we show the con-
restrictions of DetShEx−
0
tainment problem for full DetShEx0 to be intractable. Inter-
estingly, for a schema S in DetShEx−
we construct a charac-
0
terizing graph G such that G is satisfied by any schema S ′ in
DetShEx−
0

if and only if S ⊆ S ′.

Checking the containment S ⊆ S ′ involves implicit nega-
tion: checking whether there is no counter-example, an in-
stance that satisfies S and does not satisfy S ′. The implicit
negation allows to encode disjunction even in classes of
schemas that explicitly forbid using disjunction in type defi-
nitions, such as ShEx0. This renders ShEx0 very powerful and
allows for pairs of schemas for which the smallest counter-
example is of exponential size. Not surprisingly, we observe
a significant impact on complexity: testing containment for
shape graphs is EXP-complete.

The picture of containment for arbitrary shape expres-
sion schemas is far from obvious. It is known that ∃MSO
on graphs is alone insufficient to capture ShEx and needs
to be enriched with Presburger arithmetic [34]. However,
monadic extensions of Presburger arithmetic quickly become
undecidable [13, 31]. The question whether containment for
ShEx is decidable at all is non-trivial but we answer it posi-
tively and give an initial characterization of its complexity:
coNEXP-hard and in co2NEXPNP. The precise complexity of
containment for ShEx remains an open question.

Our study has a number of outcomes:
• a thorough characterization of complexity of contain-

ment for classes of shape expression schemas;

• a set of bounds on the size of a minimal graph that

satisfies one schema and violates another;

• a tractable notion of embeddings that is a sufficient
condition for containment, and a necessary one of a
subclass of deterministic shape expression schemas.

Related work. There is a large body of literature dealing
with the containment problem for various database schema
formalisms. The expressivity of ShEx has been studied in
[34]. ShEx is not comparable to neither FO logic on graphs,
nor to ∃MSO on graphs. In order to capture the cardinality
contraints e.g., (a || b)*, expressible by RBE, ∃MSO has to be
extended with Presburger Arithmetic (PA). Such extensions,
as we have already mentioned, can easily get to be undecid-
able [13, 31]. It is, also, a classic result that MSO theory of
N with addition is undecidable, it has been shown in [30]
that even MSO theory of naturals with the double function,
⟨N, +1, 2x, 0⟩, is undecidable.

Schema languages for trees have been extensively studied
in the context of XML. Most of the work, however, has been
devoted to the case of ordered trees. Typically, schema lan-
guages for ordered trees (DTD, XML Schema) are captured by
tree automata. A survey of basic decision problems for tree
automata can be found in [36]. In particular, containment for
nondeterministic tree automata is EXPTIME-complete [33]
but becomes polynomial for deterministic tree automata. The
containment of DTDs over the usual (ordered) nondetermin-
istic regular expressions is PSPACE-complete and remains
intractable even for very simple nondeterministic regular

expressions [24] but drops to PTIME [25] if deterministic reg-
ular expressions are used as mandated by the XML standard
[7]. We point out that in our case, however, determinism
alone is not sufficient, in order to obtain tractability of the
containment we need to enforce additional structural condi-
tions on the shape graphs.

Various forms of DTDs with regular expressions inter-
preted under the commutative closure [28] have been stud-
ied. In the context of trees many formalisms have been intro-
duced to express the numerical constrains on the occurrences
of the different symbols among the children of some node,
e.g., Presburger automata [31, 32], sheaves automata[12],
TQL logic[8]. Unfortunately, the containment problem in all
this settings is NP-hard [20].

The problem of containment of regular expressions with
interleaving is EXPSPACE-complete [26]. A number of ex-
pressive formalisms with interleaving have been shown in
[15] to have highly intractable inclusion.

Disjunctive multiplicity schemas (DMS) for unordered
XML have been studied in [5]. A DMS is a formalism that
defines for each label the language of allowed children labels
using disjunctive multiplicity expressions (DIME) that are
similar to RBE0 but allow a limited form of disjunction. DMS
assume similar form of determinism as DTDs since types of
nodes are identified with their labels. Additionaly, DIMEs
require each of the alphabet symbols from Σ to appear at
most once. Nevertheless, the containment for DMS is in
PTIME.

Organization. The paper is organized as follows. In Sec-
tion 2 we present basic notions and introduce embeddings
of shape graphs. In Section 3 we investigate decidability of
containment for the full fragment of ShEx by bounding the
size of a counter-example. In Section 4 we analyze the com-
plexity of containment for shape graphs (ShEx0) and show
a tight exponential bound on the size of a counter-example.
In Section 5 we identify a tractable subclass of deterministic
shape expression schemas and investigate the complexity
of constructing embeddings. We summarize our work and
outline directions of further study in Section 6.

2 BASIC NOTIONS
Throughout this paper we employ elements of function no-
tation to relations, and conversely, often view functions as
relations. For instance, for a binary relation R ⊆ A × B we
set dom(R) = {a ∈ A | ∃b ∈ B. (a, b) ∈ R}, ran(B) = {b ∈
B | ∃a ∈ A. (a, b) ∈ R}, R(a) = {b ∈ B | (a, b) ∈ R} for a ∈ A,
and R−1(b) = {a ∈ A | (a, b) ∈ R} for b ∈ B.
Intervals. We use pairs of numbers including the infinite
constant ∞ to represent intervals: the pair [n; m], with n ≤
m ≤ ∞, represents the set {i
| n ≤ i ≤ m}. We assume
that both n and m are stored in binary. We use a number

of operators on intervals: every interval I = [n; m] has its
lower bound min(I ) = n and its upper bound max(I ) = m.
The point-wise addition of two intervals A ⊕ B = {a +b | a ∈
A, b ∈ B} has a natural interpretation: [n1; m1] ⊕ [n2; m2] =
[n1 + n2; m1 + m2]. Note that [0; 0] is the neutral element of
⊕, and hence, for k = 0 the expression I1 ⊕ . . . ⊕ Ik evaluates
to [0; 0]. Also [n1; m1] ⊆ [n2; m2] iff n2 ≤ n1 ≤ m1 ≤ m2.

Four basic intervals are commonly employed in popular
schema languages for semi-structured databases, listed here
together with their shorthand notation: 1 stands for [1; 1],
? for [0; 1], + for [1; ∞], and * for [0; ∞]. We use I to denote
the set of all intervals and M to denote the the set of basic
intervals.

Bags. Let ∆ be a finite set of symbols. Unordered words are
represented with bags. Formally, a bag over ∆ is a function w :
∆ → N that maps a symbol to the number of its occurrences.
The empty bag ε has 0 occurrences of every symbol i.e.,
ε(a) = 0 for every a ∈ ∆. Bags are often presented using the
notation {|a, . . .|} with elements possibly being repeated. For
example, when ∆ = {a, b, c}, w0 = {|a, a, a, c, c |} represents
the function w0(a) = 3, w0(b) = 0, and w0(c) = 2. A bag
language is a set of bags.

The equivalent of concatenation for unordered words is
the bag union w1 ⊎w2 of two bags w1 and w2 is [w1 ⊎w2](a) =
w1(a) + w2(a) for all a ∈ ∆. We also extend this operator to
bag languages: L1 ⊎ L2 = {w1 ⊎ w2 | w1 ∈ L1, w2 ∈ L2}.
Also, for a given bag language L, we define L0 = {ε} and
Li = L ⊎ Li−1 for i > 0.
Regular bag expressions. Regular bag expressions (RBE)
are analogues of regular expressions for defining bag lan-
guages and use disjunction “|,” unordered concatenation “||,”
and unordered repetition. Formally, they are defined with
the following grammar:

E ::= ϵ | a | (E|E) | (E || E) | EI ,
where a ∈ ∆ and I is an interval. Their semantics is defined as
follows: L(ϵ) = {ε}, L(a) = {{|a|}}, L(E1 | E2) = L(E1) ∪ L(E2),
L(E1 || E2) = L(E1) ⊎ L(E2), and L(EI ) = (cid:208)
i ∈I L(E)i . By RBE0
|| . . . || aMn
we denote the class of expressions of the form aM1
n ,
1
where ai ∈ Σ and Mi ∈ M for i ∈ {1, . . . , n}. We point out
that occurrences of symbols need not be distinct e.g., a ||a+ ||b*
is RBE0.
Graphs. We employ a general graph model that allows to
capture RDF graphs as well as an important subclass of
shape expression schemas (ShEx0). Because shape expres-
sions schemas do not constrain the predicates of the edges of
an RDF graph, we assume a fixed set Σ of predicates names
used to label edges of graphs. To represent (a subclass of)
shape expression schemas as graphs, we additionally label
each edge with an occurrence interval, which intuitively
indicate the admissible number of edges of the given kind

(cf. Definition 2.2). Also, the general graph model allows
multiple edges connecting the same pair of nodes with the
same predicate label, which is not allowed in standard RDF.

Definition 2.1. A graph is a tuple

G = (NG , EG , sourceG , targetG , labG , occurG ),
where NG is a finite set of nodes, EG is a finite set of edges,
: EG → NG
the functions sourceG : EG → NG and targetG
identify resp. the origin node and end point node of an edge,
labG : EG → Σ assigns a (predicate) label to an edge, and
occurG : EG → I assigns an occurrence interval to an edge.
A graph is simple if it uses only the interval 1 and has
no two edges with the same origin, the same end point, and
the same label. By G0 we denote the set of all simple graphs.
A shape graph is a graph that uses only basic occurrence
intervals (in M) and we denote the class of all shape graphs
□
with ShEx0.

For the purposes of studying containment of shape expres-
sion schemas the class of simple graph captures adequately
RDF graphs. Although RDF nodes are labeled with URIs,
literal values, and blank identifiers, and shape expression
schemas can constraint node labels, in general these con-
straints can, to some extent, be “simulated.” For instance, if
the schema imposes a type of admissible literal nodes (inte-
ger, date, etc.), literal nodes can be modified to include an
outgoing edge labeled with the type name.

Shape expression schemas constrain the outbound neigh-
borhood of a node, and for that purpose we identify the set
of all outgoing edges of a node n ∈ NG with

outG (n) = {e ∈ EG | sourceG (e) = n}.
Sometimes, if a node n has an outgoing edge leading to m, we
shall call m a child of n (even if n and m are the same node).
Also, we call an a-edge any edge labeled with a ∈ Σ, and
analogously, an I -edge any edge with occurrence interval I .

Shape Expression Schemas. Again, we assume a fixed set
of predicate labels Σ. Given a set of type names Γ, a shape
expression over Γ is an RBE over Σ × Γ and in the sequel
we write (a, t) ∈ Σ × Γ simply as a :: t. A shape expression
schema (ShEx) is a pair H = (ΓH , δH ), where ΓH is a finite
set of types, and δH is a type definition function that maps
elements of ΓH to shape expressions over ΓH . Typically, we
present a ShEx H as a collection of rules of the form t → E
to indicate that δH (t) = E, where E is a shape expression. For
a class of RBEs C, by ShEx(C) we denote the class of shape
expression schemas using only shape expressions in C.

We recall the formal semantics of ShEx [34] and illustrate
it on the example of a simple graph G0 and a schema H0 in
Figure 2. A typing of a simple graph G w.r.t. H is a relation
T ⊆ NG × ΓH . For instance, a typing of G0 w.r.t. H0 is (for

G0:

b

H0:

n0

a

n1

c

n2

t0 → a :: t1
t1 → b :: t *
t2 → b :: t2
t3 → ϵ

2 || c :: t3
? || c :: t3

Figure 2: A simple graph G0 and a schema H0.

clarity, we employ functional notation)

T1(n0) = {t0}, T1(n1) = {t1, t2}, T1(n2) = {t3}.
Note that a node may have a number of types. The signature
of a node n ∈ NG w.r.t. T is an RBE expression

signT

(cid:12)
G (n) = (cid:12)
(cid:12)e ∈outG (n)
(cid:12)
For instance, the signature of n1 in G0 w.r.t. T1 is

(cid:0)(cid:12)
(cid:12)t ∈T (targetG (e))labG (e) :: t (cid:1)

signT1
G0

(n1) = (b :: t1 | b :: t2) || c :: t3.

A node n satisfies a shape expression E w.r.t. a typing T iff
G (n)) ∩ L(E) (cid:44) ∅. For instance, n1 satisfies the type
L(signT
definition δH0(t2) of H0 w.r.t.T1. The typing T is valid iff every
node satisfies the type definition of every type assigned to the
G (n))∩L(δH (t)) (cid:44) ∅ for every (n, t) ∈ T . Valid
node i.e., L(signT
typings of G w.r.t. H form a semi-lattice, with the union as
the meet operation [34]. Consequently, there exists a unique
maximal typing, which we denote by TypingG:H
, and in the
sequel we say that a node n has type t if (n, t) ∈ TypingG:H
.
Now, G satisfies H if every node of G has at least one type
i.e., dom(TypingG:H ) = NG . By L(H ) we denote the set of all
simple graphs that satisfy H .
Containment. In this paper, we investigate the containment
problem for ShEx: given two shape expression schemas H
and K we say that H is contained in K, in symbols H ⊆ K,
if L(H ) ⊆ L(K). A counter-example for H ⊆ K is any graph
G ∈ L(H ) \ L(K).
Embeddings. We define a natural notion of embedding that
allows to treat shape graphs as an alternative representation
of ShEx(RBE0).

Definition 2.2. Given two graphs G and H , a binary re-
lation R ⊆ NG × NH is a simulation of G in H iff for any
(n, m) ∈ R there exists a witness of simulation of n by m w.r.t.
R, i.e., a function λn,m : outG (n) → outH (m) such that for
every e ∈ outG (n)

1. labG (e) = labH (λn,m(e)),
2. (targetG (e), targetH (λn,m(e))) ∈ R,

and for every f ∈ outH (m)

3. (cid:201){occurG (e) | e ∈ EG , λn,m(e) = f } ⊆ occurH (f ).
An embedding of G in H is a simulation R of G in H such
that dom(R) = NG , and we write G ≼ H if G there is an
□
embedding of G in H .

Figure 3 presents an example of an embedding between
the simple graph G0 and the shape graph corresponding to
the shape expression schema H0 in Figure 2.

G0:

b

H0:

n0

a

n1

c

n2

t0

a

t1

b*

c

b?

t2

t3

c

Figure 3: An embedding of G0 in H0.

The set of simulations of G in H is a semi-lattice (with the
meet operation interpreted with the set union), and conse-
quently, there exists exactly one maximal simulation of G
in H . We use embeddings to treat graphs as schemas. The
language of a graph H is the set of all simple graphs that can
be embedded in H i.e., L(H ) = {G ∈ G0 | G ≼ H }.

There is a natural correspondence between shape expres-
sion schemas using RBE0 only and shape graphs, and we
show that the existence of a witness of a simulation is equiv-
alent to type satisfaction.

Proposition 2.3. ShEx0 captures precisely ShEx(RBE0),
i.e., for every ShEx(RBE0) schema there is a shape graph in
ShEx0 defining the same language and for every shape graph
in ShEx0 there is a ShEx(RBE0) schema defining the same
language.

Embeddings are closed under composition, which imme-

diately gives the following.

Lemma 2.4. For any G and H , G ≼ H implies G ⊆ H .
The converse does not hold as illustrated in Figure 4, where
two equivalent graphs are given but embedding holds only in
one direction. This example basically illustrates that a shape

H1 :

K1 :

a *

b *

a*

a

*

a *

b

b b

*

Figure 4: Containment does not imply an embedding:
H1 ⊆ K1 but H1 (cid:36) K1.

expression b :: t * is equivalent to ϵ | b :: t | b :: t +, a (disjoint)
union that enumerates cases of the original expression. In
Section 5 we identify a practical subclass of shape graphs for
which embedding is also a necessary condition for contain-
ment and then, we analyze the complexity of constructing
an embedding.

3 SHAPE EXPRESSION SCHEMAS
In this section, we address the question of decidability of con-
tainment for ShEx, which is far from obvious as ShEx caries
some expressive power of ∃MSO on graphs combined with
Presburger arithmetic [34] and monadic extensions of Pres-
burger arithmetic easily become undecidable [13]. We show
a triple-exponential upper bound on the size of a counter-
example, which can be compressed to double-exponential
size. The compression does not change the complexity of
validation, which permits us to give a preliminary upper
bound on the complexity of testing containment for ShEx

3.1 Counter-example
To illustrate the analysis of the size of a counter-example we
present in Figure 5 two shape expression schemas H2 and K2
and a counter-example G2 for the containment H2 ⊆ K2. We

H2 :

t0 → a :: t *
1
t1 → b :: t ?
1

K2 :

s0 → a :: s1 | (a :: s1 || a :: s2)*
s1 → b :: s?
2

s2 → ϵ

({t1}, {s1})

G2:

({t0}, ∅)

a

b

a

a

b

({t1}, {s1, s2})

F2:

a

({t0}, ∅)

a

2

b

({t1}, {s1})

({t1}, {s1, s2})

({t1}, {s1})

Figure 5: Two schemas H2 ⊈ K2 (top), a counter-
example G2 (bottom left), and its compression F2 (bot-
tom right).

associate with every node of G2 its kind (T , S), the set of all
types T of H2 and the set of all types S of K2 that the node
satisfies. Our goal is to construct a graph that has at most one
node of any possible kind. We point out that in any counter-
example there is at least one node that does not satisfy any
type of K2 (while it satisfies some types of H2). In G2 there
is a single such node and its kind is ({t0}, ∅). This node has
two a-children of the kind ({t1}, {s1}) and one a-child of
the kind ({t1}, {s1, s2}). Notice that none of the ({t1}, {s1})-
nodes can be removed or the ({t0}, ∅)-node would satisfy
the type s0 and the resulting graph would not longer be a
counter-example. Instead, we fuse the ({t1}, {s1})-nodes into
a single one, and use a singleton interval 2 to indicate two
copies of the a-edge. Essentially, this allows to compress the
counter-example into a graph with at most exponentially
many nodes. We then use the existing results on solutions
to Presburger arithmetic formulas to characterize bounds
on the sizes of the intervals necessary in the compressed
counter-examples.

Compression. Simple graphs do not allow multiple edges
with the same label between the same pair of nodes. We

propose a model that allows it by attaching to every edge
a cardinality indicating the number of such edges. More
precisely, a singleton interval is an interval of the form [k; k]
for any natural k, and a compressed graph is a graph that
uses only singleton intervals on its edges and like simple
graphs allows only one edge per label in Σ between a pair of
nodes. Given a compressed graph F , its unpacking is a simple
graph obtained by making a sufficient number of copies of
each node, each copy has the same outbound neighborhood
but receiving at most one incoming edge.Since intervals are
stored in binary, the unpacking of a compressed graph F is
of size at most exponential in the size of F .

Proposition 3.1. The size of the unpacking of a compressed

graph F is at most exponential in the size of F .

We adapt the definition of validation of ShEx to com-
pressed graphs by extending the definition of node signature.
Given a shape expression schema H and a compressed graph
F , the signature of a node n ∈ N F w.r.t. a typing T ⊆ N F ×ΓH
is

signT

(cid:12)
G (n) = (cid:12)
(cid:12)e ∈outF (n)
(cid:12)

(cid:0)(cid:12)
(cid:12)t ∈T (targetF (e))labF(e) :: t (cid:1) occurF (e).

G (n)) ∩ L(δH (t)) (cid:44) ∅
Again, the typing T is valid iff L(signT
for every (n, t) ∈ T , there exists a unique maximal valid
typing TypingF:H
of F w.r.t. H , and also F satisfies H if
dom(TypingF:H ) = N F. Naturally, if F satisfies H , then its
unpacking also satisfies H . Checking the satisfaction of ShEx
for compressed graphs remains in NP and to prove it we
employ known results on Presburger arithmetic that we
present next.

Presburger Arithmetic. The Presburger arithmetic (PA) is
the first-order logical theory of natural numbers with addi-
tion that has decidable satisfiability [29]. We point out that
any natural number n can be easily defined with an existen-
tially quantified formula of length linear in log(n). Since we
use PA formulas to define bags, we use a convenient nota-
tion. When the set of symbols ∆ = {a1, . . . , ak } is known
from the context, a bag w over ∆ can be represented as a
(Parikh) vector of k natural numbers ⟨w(a1), . . . , w(ak )⟩ and
if a vector of variables ¯x is used to describe a bag over ∆,
we use elements of ∆ to index elements of ¯x: xai
designates
w(ai ), for 1 ≤ i ≤ k. Also, we write φ(w) to say that φ is
valid for w.

We extend RBE with intersection L(E1 ∩ E2) = L(E1) ∩
L(E2) because intersection is used to define satisfiability of
a graph w.r.t. a schema and intersection is easily expressed
in Presburger arithmetic. Now, for a regular bag expression
E we recursively construct a formula ψE ( ¯x) = ψ ( ¯x, 1) as

follows.

ψϵ ( ¯x, n) := (cid:211)
a xa = 0
ψa( ¯x, n) := xa = n ∧ (cid:211)
ψE [k ;ℓ] ( ¯x, n) := (n = 0 ∧ (cid:211)

b(cid:44)a xb = 0
a xa = 0) ∨

(n > 0 ∧ ∃m. k ≤ m ∧ m ≤ ℓ ∧ ψE ( ¯x, m))

ψE1 |E2( ¯x, n) := ∃ ¯x1, ¯x2, n1, n2. n = n1 + n2 ∧

¯x = ¯x1 + ¯x2 ∧ ψE1( ¯x1, n1) ∧ ψE2 ( ¯x2, n2)

ψE1 ||E2( ¯x, n) := ∃ ¯x1, ¯x2. ¯x = ¯x1 + ¯x2 ∧ ψE1( ¯x1, n) ∧

ψE2( ¯x2, n)

ψE1∩E2( ¯x, n) := ψE1( ¯x, n) ∧ ψE2( ¯x, n)

The main claim, proven with a simple induction, is that
ψE (w, n) iff w ∈ L(E)n for any bag w over ∆ and any n ≥
0. It follows that L(E) (cid:44) ∅ iff ∃ ¯x .ψE ( ¯x) is valid. Validity
of existentially quantified PA formulas is known to be in
NP [17], and consequently, we obtain an upper bound on
complexity of validation of compressed graphs.

Proposition 3.2. Validation of compressed graphs w.r.t.

ShEx is in NP.

The following result is instrumental in our analysis of

upper bounds on the size of a counter-example for ShEx.

Proposition 3.3 ([39]). Let Φ = Q1 ¯x1 . . . Qk ¯xk .φ be a
closed formula of Presburger arithmetic in prenex normal
form with k quantifier alternations over the variables ¯x =
¯x1∪. . .∪ ¯xk (φ is quantifier-free). Then Φ is valid if and only if Φ
is valid when restricting the first-order variables of Φ to be inter-
preted over elements of {0, . . . , B}, where log(B) = O(|φ|3| ¯x |k ).

Compressed counter-example. We take two schemas H
and K such that H ⊈ K and fix a counter-example G ∈
L(H ) \ L(K). We know that there is at least one node of G
that satisfies at least one type of H but no type of K. In
general, for a node n of G we identify a pair (T , S) consisting
of a set T of types of H and a set of types S of K that n
satisfies. We say that the node n is of the (T , S)-kind and we
identify the set C of all kinds present in G.

kind(n) = (TypingG:H (n), TypingG:K (n)),
C = {kind(n) | n ∈ NG }.

Shape expression schemas may only inspect the labels of the
outgoing edges of a node and the types of the nodes at the
end points of the edges. Consequently, if we replace a node
by a node of the same kind, or more precisely we redirect
all incoming edges of the node to the other node, then the
types of the nodes in the graph do not change, in particular,
it remains a counter-example. Furthermore, we can fuse the
set of all nodes of the same kind into a single node that
belongs to the same kind, and still obtain a graph that is a
counter-example. When fusing several nodes we gather the

incoming edges into a fused node but for the outgoing edges
we use only the outgoing edges of one (arbitrarily chosen)
of the fused nodes, while discarding the outgoing edges of
the remaining nodes. We point out that the obtained graph
needs not longer to be simple, fusing a set of nodes may lead
to several incoming edges with the same label originating
from the same node. Such multiple edges can, however, be
easily compressed to a single one.

We describe the construction of the compressed counter-
example F more precisely. First for every kind κ ∈ C we
pick an (arbitrarily chosen) representative node nκ ∈ G such
that kind(nκ ) = κ. The set of nodes of F is the set of all kinds
of G, N F = C. For every edge connecting two representative
nodes F has a corresponding edge:

E F = {⟨κ, a, κ ′⟩ | ∃e ∈ EG . sourceG (e) = nκ ,

targetG (e) = nκ′, labG (e) = a}

and for ⟨κ, a, κ ′⟩ ∈ E F

sourceF(⟨κ, a, κ ′⟩) = κ,
targetF(⟨κ, a, κ ′⟩) = κ ′,

labF(⟨κ, a, κ ′⟩) = a,
occurF(⟨κ, a, κ ′⟩) = [k; k],

where

k = |{e ∈ outG (nκ ) | labG (e) = a, kind(targetG (e)) = κ ′}|.
The main claim is that G and F satisfy precisely the same
schemas. Furthermore, the number |C| of possible kinds is
at most exponential in the number of types in H and K, and
from the above construction, F has at most one node per
kind.

Bounding the node degree. The remaining question is
how big the cardinalities of the edges of F must be. We
answer this question with the help of Proposition 3.3 by de-
scribing the outbound neighborhood of a node of F with
Presburger arithmetic formula.

For the kind (T , S) ∈ C the formula Φ(T ,S ) examines the
existence of an outbound neighborhood of a node of that
kind that satisfies all types in T and all types in S. This
neighborhood is captured as a bag ¯x over ∆C = {a :: (T ′, S ′) |
a ∈ Σ, (T ′, S ′) ∈ C}, where an occurrence of the symbol
a :: (T ′, S ′) corresponds to one outgoing edge labeled with a
and leading to a node of the kind (T ′, S ′).

Φ(T ,S ) := ∃ ¯x .

(cid:219)

t ∈T
(cid:219)

s ∈S

(cid:219)

φt ( ¯x) ∧

¬φt ( ¯x) ∧

t ∈ΓH \T
(cid:219)

φs ( ¯x) ∧

¬φs ( ¯x).

s ∈ΓK \S

The formulas φt ( ¯x) and φs ( ¯x) verify whether the types t
of H and s of K are satisfied in this neighborhood. This is
done in two phases and we present it only for φt ( ¯x); the
formula φs ( ¯x) is defined analogously. The variable xa::(T ′,S ′)
represents the number of outgoing edges with label a to
nodes that satisfy all types in T ′ (and types in S ′). In the

context of satisfying definition of the type t each outgoing
edge is used with exactly one type. Consequently, the next
formula partitions the number of outgoing edges xa::(T ′,S ′)
into all types in T ′. Here, we use a vector ¯y of variables over
{a :: (T ′, S ′) → a :: t ′ | a ∈ Σ, (T ′, S ′) ∈ C, t ′ ∈ T ′}, where
ya::(T ′,S ′)→a::t ′ represents the part of xa::(T ′,S ′) edges that is to
be used with the type t ′.

φt ( ¯x) := ∃ ¯y.

(cid:219)

xa::(T ′,S ′) = (cid:213)
t ′ ∈T ′

a::(T ′,S ′)∈∆C

ya::(T ′,S ′)→a::t ′ ∧ φ ′

t ( ¯y).

Finally, the edges with the same label and type of the end
point are aggregated in the vector ¯z representing a bag over
∆H = Σ × ΓH , which is then is fed to the formula ψδH (t ) that
defines the type definition of t (cf. proof of Proposition 3.2).

φ ′
t ( ¯y) := ∃¯z.

(cid:219)

za::t ′ = (cid:213)

ya::(T ′,S ′)→a::t ′ ∧ ψδH (t )(¯z).

a::t ′ ∈∆H

a::(T ′,S ′)∈∆C
s.t. t ′ ∈ T ′
The formula Φ(T ,S ) can be easily converted to prenex normal
form, and then, it is of exponential length, uses an exponen-
tial number of quantified variables, and has only one alter-
nation of quantifiers. Since Φ(T ,S ) is valid for any (T , S) ∈ C,
by Proposition 3.3 the satisfying values for the variables ¯x
are bound by a triple exponential, and consequently, have
a binary representation whose size is bounded by double-
exponential function in the size of H and K.

Theorem 3.4. For any two ShEx H and K, if H ⊈ K, then
there exists a compressed graph F that satisfies H , does not
satisfy K, and whose size is at most double-exponential in the
size of H and K.

3.2 Complexity
Very recently containment for RBE has been shown to be
coNEXP-complete [18], and immediately, we obtain this
lower bound.

Proposition 3.5. Containment for ShEx is coNEXP-hard.
The upper bound follows from Theorem 3.4 and Proposi-
tion 3.2. A (universally) nondeterministic Turing machine
for an input pair (H, K) guesses a compressed graph F and
uses an NP oracle to verify that F satisfies the schema H
and violates the schema K. The input pair is accepted if the
test is passed on every computation path.

Corollary 3.6. Containment for ShEx is in co2NEXPNP.

4 SHAPE GRAPHS
In this section we consider shape graphs ShEx0, which cor-
respond to the subclass ShEx(RBE0) of shape expression
schemas that use only RBE0 expression for type definitions
(cf. Proposition 2.3). First, we show that the size of a counter-
example is at most exponential and that the bound is tight.
Then, we show that the complexity of the containment prob-
lem for ShEx0 is EXP-complete.

4.1 Counter-example
In Section 3 we have presented an argument showing that a
smallest counter-example has at most exponential number
of nodes, and next we show that for ShEx0 this bound is in
fact tight.

Lemma 4.1. For any n, there exist two shape graphs H and
K such that H ⊈ K and the smallest graph G ∈ L(H ) \ L(K)
is of size exponential in n.

Proof. In our construction the counter-example i.e., G ∈
L(H ) \ L(K), is essentially a binary tree of depth n modeled
with the rules (for i ∈ {1, . . . , n})

t (i) → L :: t (i+1) || R :: t (i+1)

The leaves of this tree store each a subset of A = {a1, . . . , an },
modeled with the two rules

t (n+1) → a1 :: t ?

o || . . . || an :: t ?
o

to → ϵ

The schema H consists exactly of all the above rules while
the schema K contains all but the rule defining type t (1).
Clearly, at this point a counter-example of H ⊈ K exists, one
whose root node has type t (1) in H but no type in K, how-
ever, it may be small as it suffices to use a dag. To eliminate
small counter-examples, by adding them to the language
of K, we ensure that all leaves of the counter-example are
labeled with distinct subsets of A. In essence, we require
in the counter-example a node at level i to have all leaves
of its left subtree labeled with subsets containing ai and all
leaves of its right subtree labeled with subsets missing ai . For
that purpose, we introduce types s(j)
), which identify
nodes at level j that are using (missing resp.) the symbol ai ;
the additional parameter d ∈ {L, R} is used to handle dis-
junction and essentially indicates the subtree from which
the usage information comes from. The rules for leaves are
(for i ∈ {1, . . . , n}, M ∈ {0, 1}, and d ∈ {L, R})

(s(j)
i,0,d

i,1,d

s(n+1)
i, M,d

→ a1 :: t ?

o || . . . || ai−1 :: t ?
o ||
|| ai+1 :: t ?

ai :: t M
o

o || . . . || an :: t ?
o

The information of using a symbol ai in a branch is propa-
gated upward but only to the level i + 1 with the rules (for
i ∈ {1, . . . , n}, j ∈ {i + 1, . . . , n}, and M ∈ {0, 1})

s(j)
i, M, L
s(j)
i, M, R

→ L :: s(j+1) ?
i, M, L
→ L :: t (j) || R :: s(j+1) ?
i, M, L

|| L :: s(j+1) ?
i, M,R

|| R :: t (j)
|| R :: s(j+1) ?
i, M, R

Finally, a tree is invalid for our purposes if a node at depth i
is missing the symbol ai in a leaf of its left subtree or is using
the symbol ai in a leaf of its right subtree. This situation is
identified and propagated to the root node with the rules

(for i ∈ {1, . . . , n} and j ∈ {1, . . . , i − 1})
→ L :: s(i+1) ?
|| L :: s(i+1) ?
i,0,R
i,0, L
→ L :: t (i+1) || R :: s(i+1) ?
i,1, L
→ L :: p(j+1) ?
|| L :: p(j+1) ?
i, R
→ L :: t (j+1) || R :: p(j+1) ?

p(i)
i, L
p(i)
i, R
p(j)
i, L
p(j)
i, R

i, L

i, L

|| R :: t (i+1)
|| R :: s(i+1) ?
i,1, R
|| R :: t (j+1)
|| R :: p(j+1) ?
i, R

Now, the claim, proven with a simple induction, is that for
any G ∈ L(H ) unless G contains an exponential tree, any
node that has the type t (1) of H also has a type p(1)
of K for
i,d
□
some i ∈ {1, . . . , n}, M ∈ {0, 1}, and d ∈ {L, R}.

The lower bound on the size of a minimal counter-example

for ShEx0 is tight.

Theorem 4.2. For any H , K ∈ ShEx0 such that H ⊈ K
there exists a graph G ∈ L(H ) \ L(K) whose size is at most
exponential in the size of H and K.

The proof consists of two parts. The first shows that there
are at most exponentially many kinds of nodes, and we use
the same argument in the proof of Theorem 3.4 in Section 3.
The second part uses a pumping argument to show that the
outbound degree of a minimal counter-example is polyno-
mially bounded.

4.2 Complexity
The lower bound on the complexity of containment for ShEx0
is obtained with a reduction from nondeterministic top-down
tree automata known to be EXP-complete [11]. The reduc-
tion is non-trivial because RBE0 does not allow directly the
disjunction necessary to express nondeterminism, and the
proof needs to account for graphs that might have cycles
and do not represent trees.

Theorem 4.3. Containment for ShEx0 is EXP-hard.
Since validation for ShEx0 is polynomial [34], the bound
on the size of a counter-example yields a coNEXP procedure
for testing containment. We provide, however, a tight EXP
bound with an exponential procedure for deciding contain-
ment of shape graphs. We outline the main ideas with the
examples that follow. The first example gives a rough sketch
of the framework, while the remaining examples present
more challenging aspects of the problem at hand and how
we address them.

Example 4.4. We consider the two shape graphs H3 and K3
in Figure 6, that represent the two shape expression schemas
presented in Section 1. First, we introduce the notion of type
covering, which essentially for every type t of H3 identifies
sets of types of K3 that capture t. For instance, the type U is
covered by {U1, U2} and the type B is covered by the types
{B1, B2}. Then, we prove an important property of support

H3:

r *

B

u

e

?

U

d

n

n

m

?

L

E

m

K3:

r *

B2

r *

B1

r *
r *
e?

e

?

u

d

E

d

u

U2

n

n

m

U1

m

L

n

Figure 6: Covering between two shape graphs.

of type t being covered by a set of types S: the definition of
the type t can be unfolded to a disjunction of type definitions
of (a subset of) S. For instance, we take the type definition
of U

δH3(U ) = n :: L || m :: L?,

and decompose m :: L? into the following disjunction

(n :: L) | (n :: L || m :: L)
which is equal to δK3(U1) | δK3(U2). This indeed shows that
U is covered by {U1, U2}. Here, the types L and E are the
same in both schemas and for simplicity use the same name.
Because shape expression schemas are recursive, the no-
tion of support needs to be defined in a (co)inductive fashion.
For instance, for the type definition of B

δH3 (B) = r :: B* || u :: U || d :: L || e :: E?

since U is covered by {U1, U2} we get
(r :: B* || u :: U1 || d :: L || e :: E?) | (r :: B* || u :: U2 || d :: L || e :: E?)
and since B is covered by {B1, B2}

(r :: B*

1 || r :: B*

2 || u :: U1 || d :: L || e :: E?) |
1 || r :: B*
which is equal to δK3(B1) | δK3(B2). This shows that B is
covered by {B1, B2} even though this very fact is assumed
□
to hold when constructing the unfolding.

2 || u :: U2 || d :: L || e :: E?)

(r :: B*

While unfolding atoms a::t 1 and a::t ? is relatively straight-
forward, the next example shows that unfolding atoms a :: t *
is more complicated than the previous example might sug-
gest.

Example 4.5. Consider the following two schemas:

H4: t0 → a :: t *

t → a :: t∅ || a :: t ?
∅
t∅ → ϵ

K4: s0 → a :: s*
1

s ′
0 → a :: s+

2 || a :: s*
1
s1 → a :: s∅ s2 → a :: s∅ || a :: s∅
s∅ → ϵ

Clearly, t∅ is covered by {s∅}, and consequently, t is covered
by {s1, s2}. We also point out that s1 and s2 are incomparable
0. Essentially, s0 allows only outgoing edges
and so are s0 and s ′
0 requires at least one
that lead to nodes of type s1, while s ′
outgoing edge that leads to a node of type s2 and an arbitrary
number of edges that lead to nodes of type s1. Naturally, t0
0}. When constructing the unfolding of
is covered by {s0, s ′
δH4(t) = a :: t *
0 we observe that since t is covered by {s1, s2}
the type definition a :: t * can be unfolded to
a :: s*

1 | (a :: s2 || a :: t *)

and then again to

a :: s*

1 || a :: s*
2 )

1 | (a :: s2 || a :: s*
which after a simple normalization yields δK4(s0) | δK4 (s ′

0). □
The next example illustrates why we trace the lineage of
atoms in unfolding and why we additionally consider the
problem of testing emptiness of intersection. In this example
we use arbitrary intervals for brevity, and for instance, a::t [1;2]
is short for a :: t || a :: t ?.

Example 4.6. Consider the following two schemas:
H5: t0 → c :: t

∅ || b :: t [1;2]

∅

t → a :: t [1;2]
t∅ → ϵ
K5: p0 → c :: p1

p ′
0 → c :: p2

p1 → a :: t∅ || b :: t∅
p2 → a :: t [1;2]
∅ || b :: t 2
∅
p3 → a :: t [2;3]
∅ || b :: t∅

s0 → c :: s1
s1 → a :: t 2
s2 → a :: t 3
t∅ → ϵ

∅ || b :: t [1;2]
∅ || b :: t [1;2]

∅

∅

It is easy to see that t is covered by {p1, p2, p3} and p3 is
covered by {s1, s2}. We shall prove that t0 is covered by
0, s0} by constructing an unfolding of δH5(t0) = c ::t. We
{p0, p ′
first use the fact that t is covered by {p1, p2, p3} and obtain
the following disjunction

c :: p1 | c :: p2 | c :: p3 = δK5(p0) | δK5(p ′

0) | c :: p3

To further unfold the atom c :: p3 one use the fact that p3 is
covered by {s1, s2}, which yields

δK5(p0) | δK5(p ′

0) | δK5(s0) | c :: s2

The remaining atom c ::s2 is in fact void and can be discarded.
Indeed, if we inspect its lineage, we observe that the type t
has been initially replaced by p3 and then by s2. However,
the intersection of the types t ∩ p3 ∩ s2 is empty i.e., there is
□
no graph with a node having the three types.

4.2.1 Emptiness of intersection. To identify void atoms in
derivations we present a method for identifying sets of types
whose intersection is empty, a problem of independent in-
terest. The method is based on techniques that are simpler

versions of those central in proving Lemma 4.11, which are
too complex to be presented in full detail.

We introduce the notion of rooted graph, which is a simple
graph with one distinguished root node. We fix a shape graph
H and for a shape expression E by [[E]] we denote the set of
rooted graphs whose root nodes satisfy E. We extend this
notion to sets of shape expressions [[E]] = (cid:208){[[E]] | E ∈ E}.
Since shape expressions use RBE0 and the unordered concate-
nation operator is commutative, we view shape expressions
as unordered collections (bags) of atoms of the form a :: t M
without repetitions of atoms using *. We also use the empty
atom ϵ that is the neutral element of the unordered con-
catenation operator i.e., E = E || ϵ. W.l.o.g. we assume that
the interval + is not used: indeed a :: t + can be replaced by
a :: t || a :: t *.

Our method is based on pumping and tagging shape ex-
pressions, which reduces the problem to (disjunctions) of
single-occurrence expressions that use only the interval 1,
denoted SORBE0(1). Let m = max{|δH (t1)|, . . . , |δH (tk )|}+1,
where |E| is the number of atoms in E and ΓH = {t1, . . . , tk }.
Pumping removes ? and * by producing expressions with
none or one occurrences of atoms using ? and up to m oc-
currences of atoms using *. For instance, for m = 2 pumping
a :: t ? || b :: s || c :: t * yields

b :: s,
b :: s || c :: t,
b :: s || c :: t || c :: t,

a :: t || b :: s,
a :: t || b :: s || c :: t,
a :: t || b :: s || c :: t || c :: t .

Note that after pumping the obtained shape expression use
only the interval 1. To obtain single-occurrence expressions
we use tagging, which considers all permutations of atoms
in an expression and numbers the symbols accordingly. For
instance, the expression a :: t || a :: s || b :: t has the following
taggings

a1 :: t || a2 :: s || b3 :: t,
a2 :: t || a1 :: s || b3 :: t,
a3 :: t || a1 :: s || b2 :: t,

a1 :: t || a3 :: s || b2 :: t,
a2 :: t || a3 :: s || b1 :: t,
a3 :: t || a2 :: s || b1 :: t .

Our procedure constructs the set XH of all subsets of types

of H whose intersection is nonempty
XH = {{t1, . . . , tk } ⊆ ΓH | [[δH (t1)]] ∩ . . . ∩ [[δH (tk )]] (cid:44) ∅}
Initially, we begin X0 = P(ΓH ) and we iteratively refine it as
follows. Suppose, at an iteration we have a set X ⊆ P(ΓH ).
Let E1, . . . , Ek be SORBE0(1) expressions each having the
same number n of atoms and using precisely the same labels
a1, . . . , an i.e., Ei = a1::ti,1 ||. . .||an ::ti,n for i ∈ {1, . . . , k}. We
say that E1, . . . , Ek are supported by X if {t1, j , . . . , tk, j } ∈ X
for every j ∈ {1, . . . , n}. Take any {t1, . . . , tk } ∈ X and
for i ∈ {1, . . . , k} let Ei be the set of SORBE0(1) expres-
sions obtained by pumping and tagging δH (ti ). We say that

{t1, . . . , tk } is supported by X if for every i ∈ {1, . . . , k}
there is Ei ∈ Ei such that E1, . . . , Ek are supported by X.
The one-step refinement function is

Refine(X) = {T ∈ X | T is supported by X}.
Naturally, the above function is monotone, and therefore,
when iteratively applied to X0 = P(ΓH ) it has a fix-point
Refine∗(X0). We claim that this fix point is in fact XH . To
prove that this procedure works in time exponential in the
size of H it suffices to observe that each iteration of Refine
removes from X at least one element, and therefore, the
number of iteration is at most exponential in the number
of types of H , and each iteration works in time exponential
since the sets Ei have a number of expressions exponential
in m and each expression is of size at most m2.

Lemma 4.7. Checking emptiness of intersection of a set of

types of a shape graph is in EXP.

4.2.2 Type coverings. We begin with a natural notion of cov-
erage that captures the disjunction introduced by schemas.
For technical reasons and in the interest of simplicity of pre-
sentation, the definitions in the reminder of this section are
for a single shape graph H that is obtained by taking the
disjoint union H ⊎ K of the two shape graphs H and K.

Definition 4.8. Given a shape expression schema H , a type
t ∈ N H is covered by a set of types S ⊆ N H iff in any simple
graph G all nodes satisfying the type t also satisfy one of the
types in S i.e.,

∀G ∈ G0. Typing−1

G:H(t) ⊆ (cid:208)

s ∈S Typing−1

G:H(s).

The type covering of H is the relation

CoveringH

= {(t, S) ∈ N H × P(N H) | t is covered by S }.
□

Type covering allows us to decide containment in a straight-

forward fashion.

Proposition 4.9. H ⊆ K if and only if for every t ∈ NH

there is S ⊆ NK such that (t, S) ∈ CoveringH ⊎K .

We now fix a shape graph H = H ⊎ K and propose an
iterative algorithm for constructing the type covering of H
using a local characterization of support for elements of type
covering (Definition 4.10). The algorithm begins with the full
relation R = N H × P(N H) and iteratively removes any (t, S)
from R that is not supported by R. It returns the maximal self-
supported relation R which is precisely the type covering
(Lemma 4.11). We show that testing whether an element of R
is supported can be done in exponential time (Lemma 4.12),
and since R has an exponential number of elements and
at most exponential number of iterations is performed, the
algorithm works in exponential time (Theorem 4.13).

Unfolding. Again, we view shape expressions as unordered
collections (bags) of atoms of the form a :: t M , without repe-
titions of atoms using *, and we assume that the interval +
is not used. We propose a method that for a pair (t, S) ∈ R
uses R and basic properties of RBE0 to unfold the type defi-
nition of t into a disjunction of shape expressions. If t can
be unfolded into a disjunction contained in S, then (t, S) is
supported by R and there is no reason to believe that t is not
covered by S, and consequently, no reason to remove (t, S)
from R (at this iteration).

The unfolding is defined with a set of unfolding operations
on RBE0 atoms that return a disjunction of RBE0 expressions.
This set captures: the disjunction from RBE0
a::t * → ϵ | (a::t || a::t *)

a::t ? → ϵ | a::t

(1)

from every (t, {s1, . . . , sm }) ∈ R the straightforward disjunc-
tion

a::t 1 → a::s1
a::t ? → a::s?

1 | . . . | a::s1
m
1 | . . . | a::s?
m

(2a)

(2b)

as well as disjunction from a :: t * atoms (for 0 ≤ k ≤ m)
a::t * → (a::s*
k ) |

1 || . . . || a::s*
(a::sk+1 || a::t *) | . . . | (a::sm || a::t *)

(2c)

and finally, the containment of RBE0
ϵ → a::t ?

a::t → a::t ?

a::t ? → a::t *

(3)

An unfolding tree w.r.t. R is a unranked tree whose nodes
are labeled with RBE0 expressions and if a non-leaf node is
labeled with an expression E || e, then there is an unfolding
operation (w.r.t. R) e → e1 | . . . | em and the children of
the node are labeled with the expressions E || e1,. . . , E || em.
Furthermore, with a type t in a node we associate its lineage:
the set of types {t, t1, . . .} of its ancestors that have led to
the type. A type used at a node is void if the intersection of
its lineage is empty. A type t that is void at a node n of an
unfolding tree is pruned as follows: if t is used in an atom
a :: t, then the node and all its descendants are removed; if t
is used in an atom a :: t ? or a :: t *, then the atom is removed
from that the expression at that node and so is any derived
atom in the descendants of the node. Now, an unfolding of
an RBE0 E w.r.t. R is a unfolding tree w.r.t. R whose root is
labeled with all types pruned.

Support. We use unfolding to identify a defining property
of the type covering.

Definition 4.10. Given a shape graph H and R ⊆ N H ×
P(N H), a pair (t, S) ∈ N H × P(N H) is supported by R if δ H(t)
has an unfolding w.r.t. R contained in δ H(S) = {δ H(s) | s ∈
S }. R ⊆ N H × P(N H) is self-supported if every (t, S) ∈ R is
□
supported by R.

Because the union of two self-supported relations is also
self-supported, there exists precisely one maximal self-supported
relation. The support property is an alternative definition
of the type covering, which is the base of our algorithm for
constructing the type covering.

known to be P-complete. This gives us an exponential upper
bound on testing the existence of a relevant unfolding.

Lemma 4.12. For H ∈ ShEx0 and R ⊆ N H × P(N H), check-
ing that (t, S) ∈ R is supported by R can be done in time
exponential in the size of H .

Lemma 4.11. For any H ∈ ShEx0, the type covering of H

Lemmas 4.11 and 4.12 together with Proposition 4.9 give.

is the maximal self-supported relation.

Proof. The proof is non-trivial, technically complex, and
we outline only the main key ideas. We show that type cov-
ering is self-supported i.e., if t is covered by S then δ H(t)
has an unfolding (w.r.t. the type uncovering) contained in
δ H(S), using a series of complex arguments. We generalize
the notion of covering to shape expressions in the natural
fashion.

First, we use a pumping and tagging technique, similar
to the one in Section 4.2.1. We obtain the set of SORBE0(1)
expression E from δ H(t) and the set E ′ from δ H(S), and we
show that every E ∈ E is covered by E ′. We view a shape
expression E = a1 ::t1 || . . . ||an ::tn as defining a n-cube Q that
is covered by a set {Q1, . . . , Qk } of n-cubes corresponding
to expressions from E ′. We then show that Q is covered
by a single n-cube, which is captured with (3) operations
or it can be decomposed into smaller n-cubes each covered
by a proper subset of {Q1, . . . , Qk }, which is captured with
(2a) operations. This yields an unfolding of E into E ′ that
we use as a skeleton for constructing an unfolding of δ H(t)
into δ H(S). Furthermore, we observe that the height of the
constructed unfolding is polynomially-bounded.

To show that the type covering is the maximal self-sup-

ported relation, we first prove the following claim.

Claim. Let R be the maximal self-supported relation for H .
For any (t, S) ∈ R that is supported by R with an unfolding
using the facts (t1, S1), . . . , (tk , Sk ) ∈ R, for any graph G and
any node n ∈ NG of type t, if for every child m of n the fact
that m has a type ti also implies that m has a type in Si , then
n has a type in S.
We use the above claim to show that for any (t, S) ∈ R, in
any graph G, any node of type t has also a type in S, and
□
consequently, (t, S) ∈ CoveringH

.

Search graph. The polynomial bound on the depth of an
unfolding allows to show that the number of relevant expres-
sions derived from δ H(t) is bounded exponentially, even if
we store the lineage information with every type. We con-
struct an oriented hypergraph, whose nodes are all relevant
expressions and oriented hyperedges represent one-step un-
foldings with void atoms pruned with the help of Lemma 4.7.
We reduce the problem of checking the existence of an un-
folding to the reachability problem in alternating graphs,

Theorem 4.13. Containment for ShEx0 is in EXP.

5 DETERMINISM
In this section we identify a tractable subclass of determin-
istic shape expression schemas that is arguably of practical
use (recall that determinism forbids using the same edge
label twice in type definition). We show that containment of
deterministic shape expression schemas is intractable even if
type definitions use RBE0 only (Theorem 5.7). Interestingly,
if the set of intervals is further restricted to 1 and *, con-
tainment is equivalent to the existence of embedding, which
we show to be tractable (Theorem 5.4). Adding support for
other basic intervals is tricky as unrestricted use of ? leads
to intractability. Consequently, we employ the technique of
characterizing example [27, 35] to find a relatively rich and
tractable subclass of deterministic shape graphs that allows
unrestricted use of 1 and * and a restricted use of ?. We
believe this subclass is of potential practical interest, and
in particular it includes the schema in Figure 1. While our
technique does allow to include +, the further restriction
this addition causes render the class impractical, and conse-
quently, we forbid + altogether (in practice using * instead
of + is often acceptable).

We first illustrate the method of characterizing example on
the example in Figure 7, where we generate a characterizing
example G6 for the schema H6 (which is a representation of
the schema in Figure 1). The central property of G6 is that any

H6:

u

U

r *

B

e

?

G6:

r

r

b1

b2

u

e

u

d

n

n

d

E

u1

u2
e
mn mn

m

?

L

m

n

l1

l2

W6:

r *

B0

e*

u

d

U0

d

m?

n

L0

Figure 7: Constructing embedding of H6 into W6 from
embedding of the characterizing example G6 into W6.

schema K (in DetShEx−
0

) that satisfies G6 is satisfied by all

graphs that satisfy H6. In other words, H6 can be embedded
in any K such that G6 ∈ L(K) and hence for any G ′ ∈ L(H6)
we have G ′ ∈ L(K). The proof takes the embedding of G6 in K
and constructs an embedding of H6 in K. Such a construction
is feasible due to a key observation, which we illustrate on the
schemaW6. Since the node b1 has the type B0, by determinism
of W6 the nodes b1 and b2 have the same type B0. Transitively,
the nodes u1 and u2 have the same type U0 and similarly the
nodes l1 and l2 have the same type L0. The characterizing
example G6 is constructed in such a manner as to make sure
that every type of H6 is described by a set of nodes of G6, all
embedded into a corresponding type of W6, which ensures
embedding of the type of H6 in the corresponding type of
W6. For instance, u1 and u2 are embedded into U0 and since
u1 has an outgoing m-edge and u2 does not, the definition of
the corresponding type in W6 must use m :: L?

0.
0 or m :: L*

We now define formally the subclass of shape expression
schemas in question. Given a shape graph H and a type
t ∈ NH , a reference to t is any edge e ∈ EH that leads to t i.e.
targetH (e) = t. A reference e is *-closed if occurH (e) = * or
all references to sourceH (e) are *-closed.

Definition 5.1. A shape graph H is deterministic if for every
node n ∈ NH and every label a ∈ Σ, n has at most one
outgoing edge labeled with a. By DetShEx0 we denote the
we
class of all deterministic shape graphs. By DetShEx−
0
denote the class of deterministic shape graphs that do not
use + and any type using ? is referenced at least once and
□
all references to it are *-closed.

Intuitively, we require that any type using ? must be ref-
erenced and can only be referenced (directly or indirectly)
through *. The schema in Figure 1 belongs to DetShEx−
since
0
both uses of the ? operator are closed by the edge related
with interval *.

5.1 Characterizing example
Interestingly, the class DetShEx−
0
that characterize any schema in DetShEx−
0
ment.

allows construction of graphs

up to contain-

Lemma 5.2. For any H ∈ DetShEx−

0 , there exists a simple
graph G ∈ L(H ) of size polynomial in the size of H such that
0 we have that G ≼ K implies H ≼ K.
for any K ∈ DetShEx−
The precise construction of the graph G that characterizes
H is in Appendix B. Here, we outline the main ideas and
illustrate them on an example in Figure 8. In essence, for
every type t ∈ NH the graph G needs to contain a number of
nodes of type t that serve the purpose of characterizing t. If t
has an outgoing *-edge e labeled with a that leads to the type
s, then at least one node n of G that characterizes t needs to
have at least two outgoing edges labeled with a that lead to
nodes A that characterize the type s. When n is mapped to a

H7:

G7:

*

?

*

*

?

*

Figure 8: Characterizing example. Different colors de-
note different labels.

type t ′ of K that has an outgoing edge e ′ labeled with a and
leading to s ′, all a-children A must to be mapped to s ′. This
shows that e ′ is an *-edge. Interestingly, this observation
propagates to descendants of A. If the type s has an outgoing
edge with label b that leads to the type u, then any b-child
of a node in A must have the type u, and furthermore, they
are all mapped to a type u ′ that is reachable from s ′ with an
edge labeled with b, etc.

Now, for a type t with an outgoing ?-edge labeled with a
we need two nodes in G that characterize t, which guarantee
that the corresponding type in K uses the right occurrence
interval: one node with one outgoing edge with label a and
one node with no such outgoing edge. Naturally, we need
to make sure that those two nodes are mapped to the same
type in K and this is accomplished by making sure there is
an ascending path from every ?-edge to every closest *-edge.
In general, every type in H is characterized by a number
of nodes that is at most 2 plus the number of ?-edges in H .
Lemma 5.2 renders containment and embeddings equivalent.

Corollary 5.3. For H, K ∈ DetShEx−

0 , H ⊆ K iff H ≼ K.

5.2 Complexity
To characterize the complexity of containment for DetShEx−
0
we study the complexity of testing embedding between two
graphs. Interestingly, it turns out that constructing embed-
dings for shape graphs, which use only basic occurrence
intervals, is tractable and becomes intractable if arbitrary
intervals may be used. This rise in computational complexity
does not come from binary encoding of intervals, in fact
the results remain negative even if the arbitrary intervals
are encoded in unary. We also point out that shape graphs
using only basic intervals are as expressive as graphs using
arbitrary intervals because RBE0 with basic intervals and rep-
etition are equivalent to RBE0 with arbitrary intervals. The
difference in complexity is not a contradiction but merely

H8:

r

x3

x2

x1

v

f ?

t?

o

K8:

r d
2

r d
1

x

3
x 2
x1

x 3
x2

x1

f

t

t?

f?

?

t

f ?

f

t

v2
3
v2
2
v2
1

v1
3
v1
2
v1
1

f
t

o

f ?

r 1
3

r 1
2

x3

v1

x2

x
1

r 1
1

t?

x2
x
1
x1
x3
x 3

x 2

x2

x1
x1
x3

v

x
3

x
2

r 0
3

r 0
2

r 0
1

x
3

v0

x2

x1

Figure 9: An example of reduction on φ = (x1 ∧ ¬x2) ∨ (x2 ∧ ¬x3).

reflects the fact that containment does not necessarily imply
embedding.

Theorem 5.4. Testing the existence of embeddings between

shape graphs is in P.

The proof of the above theorem consisting of a polynomial
algorithm constructing embeddings between two graphs can
be found in Appendix A. As a result of Corollary 5.3 and
Theorem 5.4, we obtain.

Corollary 5.5. Containment for DetShEx−
Constructing an embedding becomes intractable if arbi-

0 is in P.

trary intervals can be employed.

Theorem 5.6. Testing the existence of embeddings between

graphs with arbitrary intervals is NP-complete.

Finally, we observe that lifting the additional restrictions

we impose on DetShEx−
0

leads to intractability.

Theorem 5.7. Containment for DetShEx0 is coNP-hard.
Proof (sketch). The proof is by reduction from tautology
of DNF formulas, which we illustrate on the example of
φ = (x1 ∧ ¬x2) ∨ (x2 ∧ ¬x3). We construct two deterministic
schemas H8 and K8 presented in Figure 9. The schema H8 is
satisfied by all graphs defining a valuation of the variables
of φ: a node with the root type r has outgoing edges labeled
with the name of the variable leading to a node of type v that
represents the value of the variable t or f . Because DetShEx0
does not allow disjunction, nodes of type v may also have
both outgoing edges t and f , or neither of them. These cases
are covered in K8 by the types r 1
’s respectively. The
i
types r d
’s capture precisely the valuations that satisfy the
j
clauses of φ. Hence, K8 is not satisfied by the graphs that
correctly define a valuation that does not satisfy φ. Naturally,
□
H8 ⊆ K8 iff φ is a tautology.

’s and r 0
i

6 CONCLUSIONS AND FUTURE WORK
This work was prompted by our recent work on data ex-
change for RDF [6] and ongoing work on schema inference

for RDF, where not only do we ask the questions of type
implication but are also interested in instances satisfying
constraints expressed with the help of ShEx. In this paper,
we have considered ShEx and its two practical subclasses
ShEx0 and DetShEx−
. While the precise complexity of con-
0
tainment for ShEx remains open, the complexity results we
have obtained, summarized in Figure 10, provide a good sep-
aration of the presented schema classes. Determinism shows

DetShEx−
0

ShEx0

P

EXP-complete

ShEx

coNEXP-hard

co2NEXPNP

Figure 10: Summary of complexity results

promise in allowing reduction in complexity. For instance,
containment for DetShEx is in co2NEXP since validation for
DetShEx is in P. But its precise impact on complexity of con-
tainment needs to be studied further. It is an open question
whether using arbitrary intervals in shape graphs has an
impact on the complexity of testing containment; interest-
ingly the answer to this question is negative for ShEx and
. The class of regular bag expression
positive for DetShEx−
0
DIME that permits restricted use of disjunction yet allows for
tractable containment for schemas for unordered XML [5]
and it would also be interesting to see if there are any com-
putational benefits that can be drawn for shape expression
schemas using DIME.

ACKNOWLEDGMENT
We would like to thank the referees for many useful com-
ments. This work has been supported by Polish National
Science Center grant UMO-2014/15/D/ST6/00719. Part of
this work has been done when one of authors was a fellow at
the University of Edinburgh, funded by the EU DIACHRON
project.

REFERENCES
[1] A. Abbas, P. Genevès, C. Roisin, and N. Layaïda. Optimising
SPARQL query evaluation in the presence of shex constraints.
In BDA 2017, pages 1–12, Nancy, France, November 2017.
[2] M. Arenas, C. Gutierrez, and J. Pérez. Foundations of RDF
databases. In Reasoning Web, International Summer School on
Semantic Technologies for Information Systems, pages 158–
204, 2009. Invited Tutorial.

[3] M. Arenas, J. Pérez, Reutter J., C. Riveros, and J. Sequeda. Data
International
exchange in the relational and RDF worlds.
Workshop on Semantic Web Information Management (SWIM),
June 2011. Invited talk.

[4] G. J. Bex, F. Neven, and J. Van den Bussche. DTDs versus XML
Schema: A practical study. In WebDB, pages 79–84, 2004.
[5] I. Boneva, R. Ciucanu, and S. Staworko. Schemas for unordered
XML on a DIME. Theoretical Computer Science (TCS), 57(2):337–
376, 2015.

[6] I. Boneva, J. Lozano, and S. Staworko. Relational to RDF data
exchange in presence of a shape expression schema. In Al-
berto Mendelzon International Workshop on Foundations of Data
Management, May 2018.

[7] A. Brüggemann-Klein and D. Wood. One-unambiguous regular
languages. Information and Computation, 142(2):182–206, 1998.
[8] L. Cardelli and G. Ghelli. TQL: a query language for semistruc-
tured data based on the ambient logic. Mathematical Structures
in Computer Science, 14(3):285–327, 2004.

[9] Š. Čebirić, F. Goasdoué, P. Guzewicz, and I. Manolescu. Com-
pact Summaries of Rich Heterogeneous Graphs. Research
Report RR-8920, INRIA Saclay ; Université Rennes 1, July 2018.
[10] Š. Čebirić, F. Goasdoué, and I Manolescu. A Framework for
Efficient Representative Summarization of RDF Graphs.
In
International Semantic Web Conference (ISWC), Vienna, Austria,
October 2017.

[11] H. Comon, M. Dauchet, R. Gilleron, C. Löding, F. Jacquemard,
D. Lugiez, S. Tison, and M. Tommasi. Tree automata techniques
and applications. 1997. Release 2007.

[12] S. Dal-Zilio and D. Lugiez. XML schema, tree logic and sheaves
automata. In Rewriting Techniques and Applications, pages 246–
263, 2003.

[13] C. C. Elgot and M. O. Rabin. Decidability and undecidability
of extensions of second (first) order theory of (generalized)
successor. Journal of Symbolic Logic, 31(2):169–181, 1966.
[14] M. F. Fernandez and D. Suciu. Optimizing regular path ex-
pressions using graph schemas. In International Conference on
Data Engineering (ICDE), pages 14–23, 1998.

[15] W. Gelade, W. Martens, and F. Neven. Optimizing schema
languages for XML: Numerical constraints and interleaving.
SIAM Journal on Computing, 38(5):2021–2043, 2009.

[16] F. Goasdoué, P. Guzewicz, and I. Manolescu. Incremental struc-
tural summarization of RDF graphs. In International Conference
on Extending Database Technology (EDBT), Lisbon, Portugal,
March 2019.

[17] Erich Grädel. The complexity of subclasses of logical theories.

PhD thesis, Universität Basel, 1987.

[18] C. Haase and P. Hofman. Tightening the complexity of equiv-
alence problems for commutative grammars. In Symposium on
Theoretical Aspects of Computer Science (STACS), pages 41:1–
41:14, 2016.

[19] A. Klarlund, T. Schwentick, and D. Suciu. XML: Model,
schemas, types, logics and queries. In J. Chomicki, R. van der
Meyden, and G. Saake, editors, Logics for Emerging Applications

of Databases. Springer-Verlag, 2003.

[20] E. Kopczynski and A. To. Parikh images of grammars: Com-
plexity and applications. In Logic in Computer Science (LICS),
pages 80–89, 2010.

[21] J. E. Labra Gayo, E. Prud’hommeaux, I. Boneva, and D. Kon-
tokostas. Validating RDF data. Synthesis Lectures on the Se-
mantic Web: Theory and Technology, 7(1):1–328, 2017.

[22] J. E. Labra Gayo, E. Prud’hommeaux, I. Boneva, S. Staworko,
H. R. Solbrig, and S. Hym. Towards an RDF validation lan-
guage based on regular expression derivatives. In EDBT/ICDT
Workshops (GraphQ & LWDM), pages 197–204, March 2015.
[23] J. E. Labra Gayo, E. Prud’hommeaux, H. Solbrig, and J. M. Al-
varez Rodriguez. Validating and describing linked data portals
using RDF Shape Expressions. In Workshop on Linked Data
Quality, September 2015.

[24] W. Martens, F. Neven, and T. Schwentick. Complexity of deci-
sion problems for XML schemas and chain regular expressions.
SIAM Journal on Computing, 39(4):1486–1530, 2009.

[25] W. Martens, F. Neven, T. Schwentick, and G. J. Bex. Expres-
siveness and complexity of XML schema. ACM Transactions
on Database Systems (TODS), 31(3):770–813, 2006.

[26] A. J. Mayer and L. J. Stockmeyer. The complexity of word
problems - this time with interleaving. Information and Com-
putation, 115(2):293–311, 1994.

[27] G. Miklau and D. Suciu. Containment and equivalence for a
fragment of XPath. Journal of the ACM, 51(1):2–45, 2004.
[28] F. Neven and T. Schwentick. XML schemas without order.

1999.

[29] D. C. Oppen. A 222pn

upper bound on the complexity of
Presburger arithmetic. Journal of Computer and System Sciences,
16(3):323–332, 1978.

[30] R. M. Robinson. Restricted set-theoretical definitions in arith-
metic. In Proceedings of the American Mathematical Society,
pages 238–242, 1958.

[31] H. Seidl, T. Schwentick, and A. Muscholl. Numerical document
queries. In ACM Symposium on Principles of Database Systems
(PODS), pages 155–166, 2003.

[32] H. Seidl, T. Schwentick, and A. Muscholl. Counting in trees.
In Logic and Automata: History and Perspectives [in Honor of
Wolfgang Thomas]., pages 575–612, 2008.

[33] Helmut Seidl. Haskell overloading is dexptime-complete. In-
formation Processing Letters, 52(2):57–60, October 1994.
[34] S. Staworko, I. Boneva, J. E. Labra Gayo, S. Hym, E. G.
Prud’hommeaux, and H. Solbrig. Complexity and expressive-
ness of ShEx for RDF. In International Conference on Database
Theory (ICDT), pages 195–211, March 2015.

[35] S. Staworko and P. Wieczorek. Characterizing XML twig
queries with examples. In International Conference on Database
Theory (ICDT), pages 144–160, March 2015.

[36] M. Veanes. On computational complexity of basic problems of
finite tree automata. Technical Report 133, UPMAIL, January
1997.

[37] W3C. RDF validation workshop report: Practical assurances

for quality RDF data. September 2013.
[38] W3C. Shape expressions language 2.0, 2017.
[39] V. Weispfenning. The complexity of almost linear diophantine
problems. Journal of Symbolic Computation, 10(5):395–404,
1990.

[40] H. Zhang, Y. Duan, X. Yuan, and Y. Zhang. ASSG: adaptive
structural summary for RDF graph data. In International Se-
mantic Web Conference (ISWC), pages 233–236, October 2014.

A CONSTRUCTING EMBEDDINGS

Theorem 5.4. Testing the existence of embeddings between
shape graphs is in P.

Proof. We fix shape graphs G and H and present a itera-
tive procedure for constructing an embedding of G in H . The
procedure begins with R0 = NG × NH and iteratively refines
it Ri = Refine(Ri−1) by removing any pair of nodes with no
simulation witness

Refine(R) = {(n, m) ∈ R | there exists a

witness λ of simulation of n by m w.r.t. R}.

This process terminates at the earliest iteration k when a fix-
point is reached Refine∗(R0) = Rk = Refine(Rk ). The fix-point
is in fact the maximal simulation of G in H and naturally, it is
an embedding if its domain contains all nodes of G. The core
difficulty is in testing the existence of a witness of simulation.
We fix a relation R ⊆ NG × NH and a pair of nodes
(n, m) ∈ R. We abstract the problem of existence of a witness
of simulation of n by m w.r.t. R as a flow routing problem,
where we are given a set of sources V = outG (n), a set of
sinks U = outH (m), and a source-to-sink connection table

E = {(v, u) ∈ V × U | labG (v) = labH (u) ∧

(targetG (v), targetH (u)) ∈ R},

every source v ∈ V outputs a volume of water between
v.min = min(occurG (v)) and v.max = max(occurG (v)), and
every sink u ∈ U requires an input of at least u.min =
min(occurH (u)) but no more than u.max = max(occurH (u)).
The flow routing problem is to find a valid routing λ : V → U
i.e., a routing such that (v, f (v)) ∈ E for every source v ∈ V
and there are no deficits or overflows at any source. Formally,
given a routing λ we estimate the inflow at a sink u with

min-inflowλ(u) = (cid:205)
max-inflowλ(u) = (cid:205)

λ(v)=u v.min,
λ(v)=u v.max.

A sink u is in deficit if min-inflowλ(u) < u.min and u is in
overflow if max-inflowλ(u) > u.max. Observe that the con-
ditions 1 and 2 in Definition 2.2 are ensured by the definition
of E while the condition 3 follows from lack of deficits and
overflows. Also, w.l.o.g. we can assume that in E every source
is paired with at least one sink.

In essence, the algorithm for constructing a valid routing
(1) starts with an empty routing, (2) assigns it assigns a sink
to every source while distributing any overflow by pushing
it forth to other sinks, and (3) solves any deficit at a sink by
pulling back the input from sources assigned to other sinks.
The main reason why this approach is successful is the
use of basic occurrence intervals in shape graphs, which
implies that the lower bounds are only 0 and 1 while the
upper bounds are 1 and ∞. When constructing the routing λ

we need to pay attention to saturated sinks that are unable
to accept any additional inflow. However, saturated sinks are
exactly those u’s with u.max = 1 and max-inflowλ(u) = 1.
Furthermore, w.l.o.g. we can assume that v.max ≤ u.max for
(v, u) ∈ E, and in particular a source with ∞ upper bound can
only be routed to a sink with upper bound ∞. Consequently,
any overflow created by the algorithm at a sink u is singular
i.e., max-inflowλ(u) = 2 and u.max = 1.

Given a (partial) routing λ and a source v with no assigned
sink, the algorithm assigns to v any admissible sink u0 i.e.,
such that (v, u0) ∈ E. If an overflow is created at u0, the
algorithm attempts to find an acyclic path π from u0 to fin
= (N , A), where the nodes are
in the push-forth graph G→
λ
N = V ∪ U ∪ {fin} and the oriented edges A are (for v ∈ V
and u ∈ U ):

• u → v if λ(v) = u and u is saturated; an additional
inflow of 1 at sink u must be redirected further and this
can be done by redirecting the output of v to another
sink.

• v → u if (v, u) ∈ E but λ(v) (cid:44) u; the source v can be
routed to u and any additional inflow at u is at most 1.
• u → fin if u is not saturated; the sink can accept an

additional inflow of 1.

Rerouting λ in accordance with a path from u to fin gives us
a overflow-free routing.

When a total overflow-free routing λ is constructed, the
algorithm identifies any sink u0 with a deficit and tries to
solve it by finding an acyclic path π from u0 to fin in the
= (N , A), where the nodes are N =
pull-back graph G←
λ
V ∪ U ∪ {fin}, and oriented edges A are (for v ∈ V and
u ∈ U ):

• u → v if λ(v) (cid:44) u and v.min = 1; rerouting v to u will
solve a deficit of 1 at u and may create a overflow at u
but only if u = u0 and then the overflow is singular.
• v → u if λ(v) = u, u.min = 1, and v is the only source
such that λ(v) = u and v.min = 1; rerouting v away
from u will create a deficit of 1 at u.

• v → fin if λ(v).min (cid:44) 1, v.min = 1, and there is v ′ (cid:44) v
such that λ(v ′) = λ(v) and v ′.min = 1; rerouting the
source v from the sink λ(v) will not create a deficit at
λ(v).

Rerouting λ in accordance with π renders λ deficit-free at
u0. If the rerouting creates a singular overflow at u0, the
algorithm uses the push-forth graph G→
to find an acyclic
λ
path π ′ from u0 to fin that is deficit-free i.e., with no edge
u → v such that u.min = v.min = 1, which guarantees that
further rerouting λ in accordance with π ′ yields a overflow-
free routing with one sink node u0 less in deficit.

Naturally, the algorithm is polynomial because the sizes
of the push-forth and pull-back graphs are bounded by the
□
size of E, and all constructed paths are acyclic.

label a from u to some v ∈ R(s). We can make the following
observations about the occurrence interval on f :

• In general occurG (f ) ∈ {1, ?, *}, which is adequate if

occurH (e) = 1;

• If occurH (e) = *, then we observe that tm+1 has m+2 ≥
2 outgoing edges labeled with a, all of witch must be
embedded in f , and therefore, occurK (f ) = *.

• If occurH (e) = ?, then we diligently construct a path

ek , . . . , e1, e0 = e such that occurH (ek ) = *, occurH (ej ) (cid:44)
* for j ∈ {k − 1, . . . , 1}, and targetH (ei ) = source(ei−1)
for i ∈ {k, . . . , 1}, together with two sequences of
types (tk +1, . . . , t1) and (uk +1, . . . , u1) such that ti =
sourceH (ei−1) for i ∈ {k + 1, . . . , 1}, (ti , ui ) ∈ R for
i ∈ {k + 1, . . . , 1} and there is an edge fi ∈ EK from
ui+1 to ui for i ∈ {k + 1, . . . , 1}. We let t1 = t and
u1 = u. Assume we have constructed the path up to ei
with type ti = sourceH (ei ) and the type ui such that
(ti , ui ) ∈ R. If occurH (ei ) = *, we terminate the con-
struction of the path. Otherwise, from construction of
R there is a type of u ′ that is a parent of ui with an
edge with label a′ as well as a type t ′ ∈ NH connected
to ti with an edge e ′ ∈ EH such that (t ′, u ′) ∈ R. We
set ti+1 = t and ui+1 = u ′, and ei+1 = e ′. This process
terminates thanks to the definition of DetShEx−
0
Now, let the edge e be the ℓ-th element in the ordering
E?. we take two corresponding paths in G:
1 ;
k . . . , t ℓ

tm+1
k+1 , tm+1

and tm+1

. . . , tm+1
1

k +1 , t ℓ

k

.

both following the edges ek , . . . , e1. With a simple in-
1 and tm+1
have the
ductive proof we show that both t ℓ
same type u1, and since t ℓ
1 does not have any outgoing
edge labeled with a, the interval occurK (f ) must be
either ? or *.
This concludes the proof.

□

1

B CHARACTERIZING EXAMPLES FOR
DETERMINISTIC SHAPE GRAPHS

, there exists a simple
Lemma 5.2. For any H ∈ DetShEx−
0
graph G ∈ L(H ) of size polynomial in the size of H such that
we have that G ≼ K implies H ≼ K.
for any K ∈ DetShEx−
0

Proof. Let E? = (e1, . . . , em) be all edges in H with occur-
rence interval ?, in an arbitrary but fixed order. The graph
G is constructed as follows. The graph has m + 2 nodes per
type of H : NG = NH × {0, 1, . . . , m + 1}, and for simplicity
we shall write t i for (t, i) ∈ NG . The nodes are used to char-
acterize the occurrence intervals used on the outgoing edges
of the type. For an edge e ∈ EH such that t = sourceH (e),
s = targetH (e), and a = labH (e), we construct the following
edges:

(1) if occurH (e) = 1, then t i has one outgoing edge with

label a that leads to si for i ∈ {0, . . . , m + 1};

(2) if occurH (e) = ? and e = eℓ i.e., ℓ is the position of
e on the list E?, then t i has one outgoing edge with
label a that leads to si for i ∈ {0, . . . , m + 1} \ {ℓ} and
tℓ has no outgoing edges with label a;

(3) if occurH (e) = *, then for i ∈ {0, . . . , m} the node t i
has no outgoing edge with label a and the node tm+1
has an outgoing edge with label a that leads to tj for
every j ∈ {0, . . . , m + 1}.

We now assume that G ∈ L(K) and construct the following

embedding of H in K:
R = {(t, u) | u ∈ TypingG:K (tm+1), inH (t) = ∅} ∪

{(t, u) | u ∈ TypingG:K (tm+1), ∃e ∈ inH (t). ∃f ∈ inK (u).
labH (e) = labK (f ) ∧ sourceH (e) = s ∧
sourceK (f ) ∈ TypingG:K (sm+1)},
where inH (t) = {e ∈ EH | tarдetH (e) = t }. Essentially,
R uses types of the nodes tm+1 but only essential ones: all
types for root nodes (with no incoming edges) and for nodes
with incoming edges only those types that are needed to
ensure satisfaction of their predecessors. It is easy to see that
dom(R) = NH . To prove that it is indeed an embedding we
make several observations. First, we point out that for deter-
ministic shape graphs the concept of witness is redundant
since an edge with a given label can be mapped only to an
edge with the same label. Consequently, we only need to
make sure that R maps nodes in a manner consistent with
the labels of the connecting edges and in quantities within
the bounds of the occurrence interval.

Now we take any edge e ∈ EH and let t = sourceH (e),
s = targetH (e), and a = labH (e). We take any u ∈ R(t), which
implies that tm+1 of G has the type u. Since tm+1 has an edge
labeled a and leading to sm+1, there is an edge f ∈ EK with

