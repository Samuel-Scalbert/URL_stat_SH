Linear high-order deterministic tree transducers with
regular look-ahead
Paul D Gallot, Aurélien Lemay, Sylvain Salvati

To cite this version:

Paul D Gallot, Aurélien Lemay, Sylvain Salvati. Linear high-order deterministic tree transducers with
regular look-ahead. MFCS 2020 : The 45th International Symposium on Mathematical Foundations of
Computer Science, Andreas Feldmann; Michal Koucky; Anna Kotesovcova, Aug 2020, Prague, Czech
Republic. ￿10.4230/LIPIcs.MFCS.2020.34￿. ￿hal-02902853v2￿

HAL Id: hal-02902853

https://hal.science/hal-02902853v2

Submitted on 18 Sep 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Linear High-Order Deterministic Tree
transducers with Regular look-ahead

Paul D. Gallot
INRIA,Université de Lille
paul.gallot@inria.fr

Aurélien Lemay
Université de Lille, INRIA, CNRS
aurelien.lemay@univ-lille.fr

Sylvain Salvati
Université de Lille, INRIA, CNRS
sylvain.salvati@univ-lille.fr

Abstract

We introduce the notion of high-order deterministic top-down tree transducers (HODT) whose outputs
correspond to simply-typed lambda-calculus formulas. These transducers are natural generalizations
of known models of top-tree transducers such as: Deterministic Top-Down Tree Transducers, Macro
Tree Transducers, Streaming Tree Transducers. . . We focus on the linear restriction of high order
tree transducers with look-ahead (HODTRlin), and prove this corresponds to tree to tree functional
transformations deﬁned by Monadic Second Order (MSO) logic. We give a specialized procedure for
the composition of those transducers that uses a ﬂow analysis based on coherence spaces and allows
us to preserve the linearity of transducers. This procedure has a better complexity than classical
algorithms for composition of other equivalent tree transducers, but raises the order of transducers.
However, we also indicate that the order of a HODTRlin can always be bounded by 3, and give a
procedure that reduces the order of a HODTRlin to 3. As those resulting HODTRlin can then be
transformed into other equivalent models, this gives an important insight on composition algorithm
for other classes of transducers. Finally, we prove that those results partially translate to the case of
almost linear HODTR: the class corresponds to the class of tree transformations performed by MSO
with unfolding (not closed by composition), and provide a mechanism to reduce the order to 3 in
this case.

2012 ACM Subject Classiﬁcation Theory of computation → Transducers; Theory of computation →
Lambda calculus; Theory of computation → Tree languages

Keywords and phrases Transducers,λ-calculus,Trees

Digital Object Identiﬁer 10.4230/LIPIcs.MFCS.2020.34

Related Version A full version of the paper is available at https://hal.archives-ouvertes.fr/
hal-02902853v1.

Funding Paul D. Gallot: ANR-15-CE25-0001 – Colis
Aurélien Lemay: ANR-15-CE25-0001 – Colis
Sylvain Salvati: ANR-15-CE25-0001 – Colis

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

© Paul Gallot, Aurélien Lemay and Sylvain Salvati;
licensed under Creative Commons License CC-BY

45th International Symposium on Mathematical Foundations of Computer Science (MFCS 2020).
Editors: Javier Esparza and Daniel Král’; Article No. 34; pp. 34:1–34:14

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

34:2

Linear High-Order Deterministic Tree transducers with Regular look-ahead

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

67

68

69

70

71

72

73

74

75

76

77

78

79

80

81

82

83

84

1

Introduction

Tree Transducers formalize transformations of structured data such as Abstract Syntax Trees,
XML, JSON, or even ﬁle systems. They are based on various mechanisms that traverse tree
structures while computing an output: Top-Down and Bottom-Up tree transducers [17, 4]
which are direct generalizations of deterministic word transducers [8, 7, 3], but also more
complex models such as macro tree transducers [11] (MTT) or streaming tree transducers [1]
(STT) to cite a few.

Logic oﬀers another, more descriptive, view on tree transformations.

In particular,
Monadic Second Order (MSO) logic deﬁnes a class of tree transformations (MSOT) [5, 6] which
is expressive and is closed under composition. It coincides with the class of transformations
deﬁnable with MTT enhanced with a regular look-ahead and restricted to ﬁnite copying
[9, 10], and also with the class of STT [1].

We argue here that simply typed λ-calculus gives a uniform generalisation of all these
diﬀerent models. Indeed, they can all be considered as classes of programs that read input
tree structures, and, at each step, compose tree operations which in the end produce the
ﬁnal output. Each of these tree operations can be represented using simply typed λ-terms.
In this paper, we deﬁne top-down tree transducers that follow the usual deﬁnitions of such
machines, except that rules can produce λ-terms of arbitrary types. We call these machines,
High-Order Top-down tree transducers, or High-Order Deterministic Tree Transducers
(HODT) in the deterministic case. This class of transducers naturally contains top-down
tree transducers, as they are HODT of order 0 (the output of rules are trees), but also MTT,
which are HODT of order 1 (outputs are tree contexts). They also contain STT, which can
be translated directly into HODT of order 3 with some restricted continuations. Also, STT
traverse their input tree represented as a string in a leftmost traversal (a stream). This
constraint could easily be adapted to our model but would yield technical complications that
are not the focus of this paper. Finally, our model generalizes High Level Tree Transducers
deﬁned in [12], which also produce λ-term, but restricted to the safe λ-calculus case.

In this paper we focus on the linear and almost linear restrictions of HODT. In terms of
expressiveness, linear HODTR (HODTRlin) corresponds to the class of MSOT. This links
our formalism to other equivalent classes of transducers, such as ﬁnite-copying macro-tree
transducers [9, 10], with an important diﬀerence: the linearity restriction is a simple syntactic
restriction, whereas ﬁnite-copying or the equivalent single-use-restricted condition are both
global conditions that are harder to enforce. For STT, the linearity condition corresponds to
the copyless condition described in [1] and where the authors prove that any STT can be
made copyless.

The relationship of HODTRlin to MSOT is made via a transformation that reduces the
order of transducers. We indeed prove that for any HODTRlin, there exists an equivalent
HODTRlin whose order is at most 3. This transformation allows us to prove then that
HODTRlin are equivalent to Attribute Tree Transducers with the single use restriction
(ATTsur). In turn, this shows that HODTRlin are equivalent to MSOT [2].

One of the main interests of HODTRlin is that λ-calculus also oﬀers a simple composition
algorithm. This approach gives an eﬃcient procedure for composing two HODTRlin. In
general, this procedure raises the order of the produced transducer. In comparison, com-
position in other equivalent classes are either complex or indirect (through MSOT). In any
case, our procedure has a better complexity. Indeed, it beneﬁts from higher-order which
permits a larger number of implementations for a given transduction. The complexity of the
construction is also lowered by the use of a notion of determinism slightly more liberal than

P. D. Gallot, A. Lemay and S. Salvati

34:3

85

86

87

88

89

90

91

92

93

94

95

96

97

98

99

100

101

102

103

104

105

106

107

108

109

110

111

112

113

114

115

116

117

118

119

120

121

122

123

124

125

126

127

128

129

usual that we call weak determinism.

The last two results allow us to obtain a composition algorithm for other equivalent
classes of tree transducer, such as MTT or STT: compile into HODTRlin, compose, reduce
the order, and compile back into the original model. The advantage of this approach over
the existing ones is that the complex composition procedure is decomposed into two simpler
steps (the back and forth translations between the formalisms are unsurprising technical
procedures). We believe in fact that existing approaches [12, 1] combine in one step the two
elements, which is what makes them more complex.

The property of order reduction also applies to a wider class of HODT, almost linear
HODT (HODTRal). Again here, this transformation allows us to prove that this class of
tree transformations is equivalent to that of Attribute Tree Transducers which is known to
be equivalent to MSO tree transformations with unfolding [2], i.e. MSO tree transduction
that produce Directed Acyclic Graphs (i.e. trees with shared sub-trees) that are unfolded to
produce a resulting tree. We call these transductions Monadic Second Order Transductions
with Sharing (MSOTS). Note however that HODTRal are not closed under composition.

Section 2 presents the technical deﬁnitions used throughout the paper. In particular, it
gives the deﬁnitions of the various notions of transducers studied in the paper and also the
notion of weak determinism. Section 3 studies the expressivity of linear and almost linear
higher-order transducer by relating them to MSOT and MSOTS. It focuses more speciﬁcally
on the order reduction procedure that is at the core of the technical work. Section 4 presents
the composition algorithm for linear higher-order transducers. This algorithm is based on
Girard’s coherence spaces and can be interpreted as a form of partial evaluation for linear
higher-order programs. Finally we conclude.

2 Deﬁnitions

This section presents the main formalisms we are going to use throughout the paper, namely
simply typed λ-calculus, ﬁnite state automata and high-order transducers.

2.1 λ-calculus

Fix a ﬁnite set of atomic types A, we then deﬁne the set of types over A, types(A), as the
types that are either an atomic type, i.e. an element of A, or a functional type (A → B), with
A and B being in types(A). The operator → is right-associative and A1 → · · · → An → B
denotes the type (A1 → (· · · → (An → B) · · · )). The order of a type A is inductively deﬁned
by order(A) = 0 when A ∈ A, and order(A → B) = max(order(A) + 1, order(B)).

A signature Σ is a triple (C, A, τ ) with C being a ﬁnite set of constants, A a ﬁnite set of

atomic types, and τ a mapping from C to types(A), the typing function.

We allow ourselves to write types(Σ) to refer to the set types(A). The order of a signature
is the maximal order of a type assigned to a constant (i.e. max{order(τ (c)) | c ∈ C}). In this
work, we mostly deal with tree signatures which are of order 1 and whose set of atomic types
is a singleton. In such a signature with atomic type o, the types of constants are of the form
o → · · · → o → o. We write on → o for an order-1 type which uses n + 1 occurrences of o,
for example, o2 → o denotes o → o → o. When c is a constant of type A, we may write cA
to make explicit that c has type A. Two signatures Σ1 = (C1, A1, τ1) and Σ2 = (C2, A2, τ2)
so that for every c in C1 ∩ C2 we have τ1(c) = τ2(c) can be summed, and we write Σ1 + Σ2
for the signature (C1 ∪ C2, A1 ∪ A2, τ ) so that if c is in C1, τ (c) = τ1(c) and if c is in C2,
τ (c) = τ2(c). The sum operation over signatures being associative and commutative, we
write Σ1 + · · · + Σn to denote the sum of several signatures.

M F C S 2 0 2 0

34:4

Linear High-Order Deterministic Tree transducers with Regular look-ahead

130

131

132

133

134

135

136

137

138

139

140

141

142

143

144

145

146

147

148

149

150

151

152

153

154

155

156

157

158

159

160

161

162

163

164

165

166

167

168

169

170

171

172

173

174

175

176

177

We assume that for every type A, there is an inﬁnite countable set of variables of type A.
When two types are diﬀerent the set of variables of those types are of course disjoint. As
with constants, we may write xA to make it clear that x is a variable of type A.

When Σ is a signature, we deﬁne the family of simply typed λ-terms over Σ, denoted

Λ(Σ) = (ΛA(Σ))A∈types(Σ), as the smallest family indexed by types(Σ) so that:

if cA is in Σ, then cA is in ΛA(Σ),
xA is in ΛA(Σ),
if A = B → C and M is in ΛC(Σ), then (λxB.M ) is in ΛA(Σ),
if M is in ΛB→A(Σ) and N is in ΛB(Σ), then (M N ) is in ΛA(Σ).

The term M is a pure λ-term if it does not contain any constant cA from Σ. When the type
is irrelevant we write M ∈ Λ(Σ) instead of M ∈ ΛA(Σ). We drop parentheses when it does
not bring ambiguity. In particular, we write λx1 . . . xn.M for (λx1(. . . (λxn.M ) . . . )), and
M0M1 . . . Mn for ((. . . (M0M1) . . . )Mn).

The set fv(M ) of free variables of a term M is inductively deﬁned on the structure of M :
fv(c) = ∅,
fv(x) = {x},
fv(M N ) = fv(M ) ∪ fv(N ),
fv(λx.M ) = fv(M ) − {x}.

Terms which have no free variables are called closed. We write M [x1, . . . , xk] to emphasize that
fv(M ) is included in {x1, . . . , xk}. When doing so, we write M [N1, . . . , Nk] for the capture
avoiding substitution of variables x1, . . . , xk by the terms N1, . . . , Nk. In other contexts,
we simply use the usual notation M [N1/x1, . . . , Nk/xk]. Moreover given a substitution θ,
we write M.θ for the result of applying this (capture avoiding) substitution and we write
θ[N1/x1, . . . , Nk/xk] for the substitution that maps the variables xi to the terms Ni but is
otherwise equal to θ. Of course, we authorize such substitutions only when the λ-term Ni
has the same type as the variable xi.

We take for granted the notions of β-contraction, noted →β, β-reduction, noted ∗→β,

β-conversion, noted =β, and β-normal form for terms.

Consider closed terms of type o that are in β-normal form and that are built on a tree
signature, they can only be of the form a t1 . . . tn where a is a constant of type on → o and
t1, . . . , tn are closed terms of type o in β-normal form. This is just another notation for
ranked trees. So when the type o is meant to represent trees, types of order 1 which have
the form o → · · · → o → o represent functions from trees to trees, or more precisely tree
contexts. Types of order 2 are types of trees parametrized by contexts. The notion of order
captures the complexity of the operations that terms of a certain type describe.

A term M is said linear if each variable (either bound or free) in M occurs exactly once
in M . A term M is said syntactically almost linear when each variable in M of non-atomic
type occurs exactly once in M . Note that, through β-reduction, linearity is preserved but
not syntactic almost linearity.

For example, given a tree signature Σ1 with one atomic type o and two constants f of type
o2 → o and a of type o, the term M = (λy1y2.f y1 (f a y2)) a (f x a) with free variable x of type
o is linear because each variable (y1, y2 and x) occurs exactly once in M . The term M contains
a β-redex so: (λy1y2.f y1 (f a y2)) a (f x a) →β (λy2.f a (f a y2)) (f x a) →β f a (f a (f x a)).
The term f a (f a (f x a)) has no β-redex so it is the β-normal form of M .

Another example: the term M2 = (λy.f y y) (x a) with free variable x of type o → o is
syntactically almost linear because the variable y which occurs twice in the term is of the
atomic type o. It β-reduces to the term M (cid:48)
2 = f (x a) (x a) which is not syntactically almost
linear, so β-reduction does not preserve syntactical almost linearity.

P. D. Gallot, A. Lemay and S. Salvati

34:5

178

179

180

181

182

183

184

185

186

187

188

189

190

191

192

193

194

195

196

197

198

199

200

201

202

203

204

205

206

208

207
209

210

211

212

213

214

215

216

217

218

219

220

221

222

We call a term almost linear when it is β-convertible to a syntactically almost linear

term. Almost linear terms are characterized also by typing properties (see [15]).

2.2 Tree Automata

We present here the classical deﬁnition of deterministic bottom-up tree automaton (BOT)
adapted to our formalism. A BOT A is a tuple (ΣP , Σ, R) where:

Σ = (C, {o}, τ ) is a ﬁrst-order tree signature, the input signature,
ΣP = (P, {o}, τP ) is the state signature, and is such that for every p ∈ P , τP (p) = o.
Constants of P are called states,
R is a ﬁnite set of rules of the form a p1 . . . pn → p where:

p,p1, . . . , pn are states of P ,
a is a constant of Σ with type on → o.

An automaton is said deterministic when there is at most one rule in R for each possible
left hand side. It is non-deterministic otherwise.

Apart from the notation, our deﬁnition diﬀers from the classical one by the fact there are no
ﬁnal states, and hence, the automaton does not describe a language. This is due to the fact
that BOT will be used here purely for look-ahead purposes.

2.3 High-Order Deterministic top-down tree Transducers

From now on we assume that Σi is a tree signature for every number i and that its atomic
type is oi.

A Linear High-Order Deterministic top-down Transducer with Regular look-ahead

(HODTRlin) T is a tuple (ΣQ, Σ1, Σ2, q0, R, A) where:

Σ1 = (C1, {o1}, τ1) is a ﬁrst-order tree signature, the input signature,
Σ2 = (C2, {o2}, τ2) is a ﬁrst-order tree signature, the output signature,
ΣQ = (Q, {o1, o2}, τs) is the state signature, and is such that for every q ∈ Q, τs(q) is of
the form o1 → Aq where Aq is in types(Σ2). Constants of Q are called states,
q0 ∈ Q is the initial state,
A is a BOT over the tree signature Σ1, the look-ahead automaton, with set of states P ,
R is a ﬁnite set of rules of the form
q(a−→x )(cid:104)−→p (cid:105) → M (q1x1) . . . (qnxn)

where:

q, q1, . . . , qn ∈ Q are states of ΣQ,
a is a constant of Σ1 with type on
−→x = x1, . . . , xn are variables of type o1, they are the child trees of the root labeled a,
−→p = p1, . . . , pn are in P (the set of states of the look-ahead A),
M is a linear term of type Aq1 → · · · → Aqn → Aq built on signature Σ2 + ΣQ.
there is one rule per possible left-hand side (determinism).

1 → o1,

Notice that we have given states a type of the form o1 → A where A ∈ types(o2). The
reason why we do this is to have a uniform notation. Indeed, a state q is meant to transform,
thanks to the rules in R, a tree built in Σ1 into a λ-term built on Σ2 with type Aq. So
we simply write q M N1 . . . Nn when we want to transform M with the state q and pass
N1,. . . , Nn as arguments to the result of the transformation. We write ΣT for the signature
Σ1 + Σ2 + ΣQ. Notice also that the right-hand part of a rule is a term that is built only
with constants of Σ2, states from ΣQ and variables of type o1. Thus, in order for this
term to have a type in types(Σ2), it is necessary that the variables of type o1 only occur as

M F C S 2 0 2 0

34:6

Linear High-Order Deterministic Tree transducers with Regular look-ahead

223

224

225

226

227

228

229

230

231

232

233

234

235

236

237

238

239

240

241

242

243

244

245

246

247

248

249

250

251

252

253

254

255

256

257

258

259

260

261

262

263

264

265

266

267

268

269

270

271

the ﬁrst argument of a state in ΣQ. Finally, remark that we did not put any requirement
on the type of the initial state. So as to restrict our attention to transducers as they are
usually understood, it suﬃces to add the requirement that the initial state is of type o1 → o2.
However, we consider as well that transducers may produce programs instead of ﬁrst order
terms.

The linearity constraint on M aﬀects both bound variables and the free variables
x1, . . . , xn, meaning that all of the subtrees x1, . . . , xn are used in computing the out-
put. That will be important for the composition of two transducers because if the ﬁrst
transducer fails in a branch of its input tree then the second transducer, applied to that tree,
must fail too. This restriction forcing the use of input subtrees does not reduce the model’s
expressivity because we can always add a state q which visits the subtree but only produces
the identity function on type o2 (this state then has type Aq = o1 → o2 → o2).

Almost linear high-order deterministic top-down transducer with regular look-ahead
(HODTRal) are deﬁned similarly, with the distinction that a term M appearing as a right-
hand side of a rule should be almost linear.

As we are concerned with the size of the composition of transducers, we wish to re-
lax a bit the notion of HODTRlin. Indeed, when composing HODTRlin we may have to
determinize the look-ahead so as to obtain a HODTRlin, which may cause an exponen-
tial blow-up of the look-ahead. However if we keep the look-ahead non-deterministic, the
transducer stays deterministic in the weaker sense that only one rule of the transducer
can apply when it is actually run. For this we adopt a slightly relaxed notion of determ-
inistic transducer that we call high-order weakly deterministic top-down transducer with
regular look-ahead (HOWDTRlin). They are similar to HODTRlin but they can have non-
deterministic automata as look-ahead with the proviso that when q(a x1 . . . xn)(cid:104)p1, . . . , pn(cid:105) →
n(cid:105) → M (cid:48)[x1, . . . , xn] are two distinct rules of the
M [x1, . . . , xn] and q(a x1 . . . xn)(cid:104)p(cid:48)
transducer then it must be the case that for some i there is no tree that is recognized by
both pi and p(cid:48)
i. This property guarantees that when transforming a term at most one rule
can apply for every possible state. Notice that it suﬃces to determinize the look-ahead so as
to obtain a HODTRlin from a HOWDTRlin, and therefore the two models are equivalent.

1, . . . , p(cid:48)

Given a HODTRlin, a HODTRal or a HOWDTRlin T , we write T :: Σ1 −→ Σ2 to mean

that the input signature of T is Σ1 and its output signature is Σ2.

A transducer T induces a notion of reduction on terms. A T -redex is a term of the form
q(a M1 . . . Mn) if and only if q(a x1 . . . xn)(cid:104)p1, . . . , pn(cid:105) → M [x1, . . . , xn] is a rule of T and
(the β-normal forms of) M1, . . . , Mn are respectively accepted by A with the states p1, . . . , pn.
In that case, a T -contractum of q(a M1 . . . Mn) is M [M1, . . . , Mn]. Notice that T -contracta
are typed terms and that they have the same type as their corresponding T -redices. The
relation of T -contraction relates a term M and a term M (cid:48) when M (cid:48) is obtained from M
by replacing one of its T -redex with a corresponding T -contractum. We write M →T M (cid:48)
when M T -contracts to M (cid:48). The relation of β-reduction is conﬂuent, and so is the relation
of T -reduction as transducers are deterministic, moreover, the union of the two relations is
terminating. It is not hard to prove that it is also locally conﬂuent and thus conﬂuent. It
follows that →β,T (which is the union of →β and →T ) is conﬂuent and strongly normalizing.
Given a term M built on ΣT , we write |M |T to denote its normal form modulo =β,T .

Then we write rel(T ) for the relation:
{(M, |q0M |T ) | M is a closed term of type o1 and |q0M |T ∈ Λ(Σ2)} .
Notice that when |q0M |T contains some states of T , as it is usual, the pair (M, |q0M |T )

is not in the relation.

Given a ﬁnite set of trees L1 on Σ1 and L2 included in ΛAq0 , we respectively write T (L1)

and T −1(L2) for the image of L1 by T and the inverse image of L2 by T .

272

273

274

275

276

277

278

279

280

281

282

283

284

285

286

287

288

289

290

291

292

293

294

295

296

297

298

299

300

301

302

303

304

305

306

307

308

309

310

311

312

313

314

315

P. D. Gallot, A. Lemay and S. Salvati

34:7

We give an example of a HODTRlin T that computes the result of additions of numeric
expressions (numbers being represented in unary notation). For this we use an input tree
signature with type o1, and constants Z o1, So1 and addo1→o1→o1 which respectively denote
zero, the successor function and addition. The output signature is similar but diﬀerent to
avoid confusion: it uses the type o2 and constants Oo2, N o2→o2 which respectively denote
zero and successor.

We do not really need the look-ahead automaton for this computation, so we omit it for
this example. We could have a blank look-ahead automaton A with one state l and rules:
A(Z) = l, A(S l) = l, A(add l l) = l; which would not change the result of the transducer.

The transducer has two states: q0 of type o1 → o2 (the initial state), and qi of type

o1 → o2 → o2. The rules of the transducer are the following:

q0(Z) → O, q0(S x) → N (qi x O),
q0(add x y) → qi x (qi y O),
qi(Z) → λx.x,
qi(S x) → λy.N (qi x y),
qi(add x y) → λz.qi x (qi y z),

As an example, we perform the transduction of the following term add(S(S Z))(S(S(S Z))):

q0(add(S(S Z))(S(S(S Z)))) →T

(qi(S(S Z)))(qi(S(S(S Z)))O)

(λy1.N ((λy2.N ((λx.x)y2))y1))((λy3.N ((λy4.N ((λy5.N ((λx.x)y5))y4))y3))O)

∗→T
∗→β N (N (N (N (N O))))

The state qi transforms a sequence of n symbols S into a λ-term of the form λx.N n(x),
and the add maps both its children into such terms and composes them. The state q0 simply
applies O to the resulting term.

Note that our reduction strategy here has consisted in ﬁrst computing the T -redices
and then reducing the β-redices. This makes the computation simpler to present. As we
mentioned above a head-reduction strategy would lead to the same result.

The order of the HODTRlin T is max{order(Aq) | q ∈ Q}. Before going further, we want
to discuss how our framework relates to other transduction models. More speciﬁcally how
the notion of order of transformations generalizes the DTOP and MTT transduction models:
if we relax the constraint of linearity of our transducers, then DTOP and MTT can be
seen as non-linear transducers of order 0 and 1 respectively. In contrast of these, we chose
to study the constraint of linearity instead of the constraint of order and, in this paper,
we will explore the beneﬁts of this approach. Firstly we will explain why increasing the
order beyond order 3 does not increase the expressivity of neither HODTRlin nor HODTRal.
Next we will show how HODTRlin and HOWDTRlin both capture the expressivity of tree
transformations deﬁned by monadic second order logic. Lastly, we will prove that, contrary
to MTT, the class of HODTRlin transformations is closed under composition, we will give an
algorithm for computing the composition of HODTRlin and HOWDTRlin, and explain why
using HOWDTRlin avoids an exponential blow-up in the size of the composition transducer.

3 Order reduction and expressiveness

In this section we outline a construction that transforms a transducer of HODTRlin or
HODTRal into an equivalent linear or almost linear transducer of order ≤ 3. These two
constructions are similar and central to proving that HODTRlin and HODTRal are respect-
ively equivalent to Monadic Second Order Transductions from trees to trees (MSOT) and to
Monadic Second Order Transductions from trees to terms (i.e. trees with sharing) (MSOTS).
We will later show that there are translations between HODTRlin of order 3 and attribute tree

M F C S 2 0 2 0

34:8

Linear High-Order Deterministic Tree transducers with Regular look-ahead

316

317

318

319

320

321

322

323

324

325

326

327

328

329

330

331

332

333

334

335

336

337

338

339

340

341

342

343

344

345

346

347

348

349

350

351

352

353

354

355

356

357

358

359

360

transducers with the single use restriction and between HODTRal of order 3 and attribute
tree transducers. These two models are known to be respectively equivalent to MSOT and
MSOTS [2].

The central idea in the construction consists in decomposing λ-terms M into pairs (cid:104)M (cid:48), σ(cid:105)
where M (cid:48) is a pure λ-term and σ is a substitution of variables with the following properties:

M =β M (cid:48).σ,
the free variables of M (cid:48) have at most order 1,
for every variable x, σ(x) is a closed λ-term,
the number of free variables in M (cid:48) is minimal.

In such a decomposition, we call the term M (cid:48) a template. In case M is of type A, linear or
almost linear, it can be proven that M (cid:48) can be taken from a ﬁnite set [14]. The linear case is
rather simple, but the almost linear case requires some precaution as one needs ﬁrst to put
M in syntactically almost linear form and then make the decomposition. Though the almost
linear case is more technical the ﬁniteness argument is the same in both cases and is based
on proof theoretical arguments in multiplicative linear logic which involves polarities in a
straightforward way.

The linear case conveys the intuition of decompositions in a clear manner. One takes
the normal form of M and then delineates the largest contexts of M , i.e. ﬁrst order terms
that are made only with constants and that are as large as possible. These contexts are
then replaced by variables and the substitution σ is built accordingly. The fact that the
contexts are chosen as large as possible makes it so that no introduced variable can have
as argument a term of the form x M1 . . . Mn where x is another variable introduced in the
process. Therefore, the new variables introduced in the process bring one negative atom
and several (possibly 0) positive ones and all of them need to be matched with positive and
negative atoms in the type of M as, under these conditions, they cannot be matched together.
This explains why there are only ﬁnitely many possible templates for a ﬁxed type.

(cid:73) Theorem 1. For all type A built on tree signature Σ, the set of templates of closed linear
(or almost linear) terms of type A is ﬁnite.

Moreover, the templates associated with a λ-term can be computed compositionally (i.e.
from the templates of its parts). As a result, templates can be computed by the look-ahead
of HODTRlin or of HODTRal. When reducing the order, we enrich the look-ahead with
template information while the substitution that is needed to reconstruct the produced term
is outputted by the new transducer. The substitution is then performed by the initial state
used at the root of the input tree which then outputs the same result as the former transducer.
The substitution can be seen as a tuple of order 1 terms. It is represented as a tuple using
Church encoding, i.e. a continuation. This makes the transducer we construct be of order 3.

(cid:73) Theorem 2. Any HODTRlin (resp. HODTRal) has an equivalent HODTRlin (resp.
HODTRal) of order 3.

The proof of this result shows that every HODTRlin (or HODTRal) can be seen as mapping
trees to tuples of contexts and combining these contexts in a linear (resp. almost linear)
way. This understanding of HODTRlin and of HODTRal allows us to prove that they are
respectively equivalent to Attribute Tree Transducers with Single Use Restriction (ATTsur);
and to Attribute Tree Transducers (ATT). Then, using [2], we can conclude with the following
expressivity result:

(cid:73) Theorem 3. HODTRlin are equivalent to MSOT and HODTRal are equivalent to MSOTS.

361

362

363

364

365

366

367

368

369

370

371

372

373

374

375

376

377

378

379

380

381

382

383

384

385

386

387

388

389

390

391

392

393

394

395

396

397

398

399

400

401

402

P. D. Gallot, A. Lemay and S. Salvati

34:9

The full proofs of these are rather technical and are not detailed here, but they appear
in the full version of the article. The proof that HODTRlin are equivalent to MSOT could
have been simpler by using the equivalence with MTT with the single-use restricted property
instead of ATT, but we would still need to use ATT to show that HODTRal are equivalent
to MSOTS.

4

Composition of HODTRlin

As we are interested in limiting the size of the transducer that is computed, and even though
our primary goal is to compose HODTRlin, this section is devoted to the composition of
HOWDTRlin. Indeed, working with non-deterministic look-aheads allows us to save the
possibly exponential cost of determinizing an automaton.

4.1 Semantic analysis

q(a−→x )(cid:104)

Let T1 = (ΣQ, Σ1, Σ2, q0, R1, A1) and T2 = (ΣP , Σ2, Σ3, p0, R2, A2) be two Linear High-Order
Weakly Deterministic tree Transducers with Regular look-ahead. The rules of T1 can be
−→
written:
(cid:96) (cid:105) → M (q1 x1) . . . (qn xn) where q, q1, . . . , qn ∈ Q are states of T1,
−→
(cid:96) = (cid:96)1, . . . , (cid:96)n are states of A1 and the λ-term M is of type Aq1 → · · · → Aqn → Aq. Our
goal is to build a HOWDTRlin T :: Σ1 → Σ3 that does the composition of T1 and T2, so we
want to replace a rule such as that one with a new rule which corresponds to applying T2 to
the term M .

In order to do so, we need, for each o2 tree in M , to know the associated state (cid:96) ∈ L2
of T2’s look-ahead, and the state p ∈ P of T2 which is going to process that node. So
with any such tree we associate the pair (p, (cid:96)). In this case we call (p, (cid:96)) the token which
represents the behavior of the tree. In general, we want to associate tokens not only with
trees, but also with λ-terms of higher order. For example, we map an occurrence of a symbol
a ∈ Σ2 of type o2 → o2 → o2, whose arguments x1 and x2 (of type o2) respectively have
look-ahead states (cid:96)1 and (cid:96)2 and are processed by states p1 and p2 ∈ P of T2, to the token
(p1, (cid:96)1) (cid:40) (p2, (cid:96)2) (cid:40) (p, (cid:96)) where (p, (cid:96)) is the token of the tree a x1x2 (of type o2). We
formally deﬁne tokens as follows:

(cid:73) Deﬁnition 4. The set of semantic tokens
deﬁned by induction:

A
(cid:74)

(cid:75)

over a type A built on atomic type o2 is

(cid:75)

= {f (cid:40) g | f ∈

A → B

= {(p, (cid:96)) | p ∈ P, (cid:96) ∈ L2}

o2
(cid:74)
Naturally, the semantic token associated with a λ-term M of type A built on atomic type
o2 will depend on the context where the term M appears. For example a tree of atomic type
o2 can be processed by any state p ∈ P of T2, and a term of type A → B can be applied to
any argument of type A. But for any such M taken out of context, there exists a ﬁnite set
of possible tokens for it. For example, a given tree of type o2 can be processed by any state
p ∈ P depending on the context, but it has always the same look-ahead (cid:96) ∈ L2.

B
(cid:74)

A
(cid:74)

, g ∈

}

(cid:75)

(cid:75)

(cid:75)

(cid:74)

In order to deﬁne the set of possible semantic tokens for a term, we use a system of
derivation rules. The following derivation rules are used to derive judgments that associate
a term with a semantic token. So a judgment Γ (cid:96) M : f associates term M with token f ,
where Γ is a substitution which maps free variables in M to tokens. The rules are:

p(a −→x )(cid:104)(cid:96)1, . . . , (cid:96)n(cid:105) T2−→ M (p1 x1) . . . (pn xn)

A2(a ((cid:96)1, . . . , (cid:96)n)) = (cid:96)

(cid:96) a : (p1, (cid:96)1) (cid:40) · · · (cid:40) (pn, (cid:96)n) (cid:40) (p, (cid:96))

M F C S 2 0 2 0

34:10

Linear High-Order Deterministic Tree transducers with Regular look-ahead

403

404

405

406

407

408

409

410

411

412

413

414

415

416

417

418

419

420

421

422

423

424

425

426

427

428

429

430

431

432

433

434

Γ1 (cid:96) M : f (cid:40) g

Γ2 (cid:96) N : f

Γ1, Γ2 (cid:96) M N : g

Γ, xA : f (cid:96) M : g
Γ (cid:96) λxA.M : f (cid:40) g

f ∈

A

(cid:74)
xA : f (cid:96) xA : f

(cid:75)

Using this system we can derive, for any term M A, all the semantic tokens that correspond

to possible behaviours of M A when it is processed by T2.

4.2 Unicity of derivation for semantic token judgements

We will later show that we can compute the image of M from the derivation of the judgement
(cid:96) M : f , assuming that f is the token that represents the behaviour of T2 on M . But before
that we need to prove that for a given term M and token f the derivation of the judgement
(cid:96) M : f is unique:

(cid:73) Theorem 5. For every type A, for every term M of type A and every token f ∈
is at most one derivation D :: (cid:96) M : f .

A

(cid:75)

(cid:74)

, there

This theorem relies in part on the fact that tokens form a coherent space, as introduced
by Girard in [13]. The full proof of this theorem is not detailed here but can be found in the
full version of the article on Hal.

Now that we have shown that there is only one derivation per judgement (cid:96) M : f , we are
going to see how to use that derivation in order to compute the term N that is the image of
M by transducer T2.

4.3 Collapsing of token derivations

We deﬁne a function (we call it collapsing function) which maps every derivation D :: (cid:96) M : f
to a term D which corresponds to the output of transducer T2 on term M assuming that M
has behaviour f .

(cid:73) Deﬁnition 6. Let D be a derivation. We deﬁne D by induction on D, there are diﬀerent
cases depending on the ﬁrst rule of D:

If D is of the form:
p(a −→x )(cid:104)(cid:96)1, . . . , (cid:96)n(cid:105) T2−→ N (p1 x1) . . . (pn xn)

A2(a ((cid:96)1, . . . , (cid:96)n)) = (cid:96)

(cid:96) a : (p1, (cid:96)1) (cid:40) · · · (cid:40) (pn, (cid:96)n) (cid:40) (p, (cid:96))

then D = N ,

if D is of the form:

D1 :: Γ1 (cid:96) N1 : f (cid:40) g

D2 :: Γ2 (cid:96) N2 : f

Γ1, Γ2 (cid:96) N1 N2 : g

then D = D1 D2,

if D is of the form:

D1 :: Γ, xA : f (cid:96) N : g
Γ (cid:96) λxA.N : f (cid:40) g

435

then D = λx.D1,

436

437

438

439

440

441

442

443

444

445

446

447

448

449

450

451

452

453

454

455

456

457

458

459

460

461

462

463

464

465

466

467

468

469

470

471

472

473

474

475

476

477

478

479

480

P. D. Gallot, A. Lemay and S. Salvati

34:11

if D is of the form:

f ∈

A

(cid:74)
xA : f (cid:96) xA : f

(cid:75)

then D = xf .

We can check that, for all derivation D :: (cid:96) M : f , the term D is of type f given by:

(p, (cid:96)) = Ap and f (cid:40) g = f → g.

Now that we have associated, with any pair (M, f ) such that f is a semantic token of
term M , a term N = D which represents the image of M by T2, we need to show that
replacing M with N in the computation of transducers leads to the same results.

4.4 Construction of the transducer which realizes the composition

We recall some notations: T1 = (ΣQ, Σ1, Σ2, q0, R1, A1) and T2 = (ΣP , Σ2, Σ3, p0, R2, A2) are
two HOWDTRlin, Q = {q1, . . . , qm} is the set of states of T1 and, for every state qi ∈ Q, we
note Aqi the type of qi(t) when t is a tree of type o1. For all type A built on o2, the set of
and is ﬁnite.
tokens of terms of type A is noted

A

(cid:74)

(cid:75)

Previously, we saw how to apply transducer T2 to terms M of type A built on the
atomic type o2, so we can apply T2 to terms which appear on the left side of rules of T1:
−→
q(a −→x )(cid:104)
(cid:96) (cid:105) → M (qi1 x1) . . . (qin xn) . In a rule such as this one, in order to replace term M
with term N = D where D is the unique derivation of the judgement (cid:96) M : f , we need to
know which token f properly describes the behaviour of T2 on M . The computation of that
token is done in the look-ahead automaton A of T .
We deﬁne the set of states of A as: L = L1 ×

× · · · ×

Aqm

With any tree t (of type o1) we want to associate the look-ahead of T1 on t and, for each
state qi ∈ Q of T1, a token of qi(t). The transition function of the look-ahead automaton A
is deﬁned by, for all ((cid:96)1, f1,1, . . . , f1,n), . . . , ((cid:96)n, fm,1, . . . , fm,n) ∈ L:
a ((cid:96)1, f1,1, . . . , f1,m) . . . ((cid:96)n, fn,1, . . . , fn,m) A→ ((cid:96), f1, . . . , fm)
where a (cid:96)1 . . . (cid:96)n

A1→ (cid:96) and, for all state qi ∈ Q, fi is such that in T1 there exists a rule
qi(a −→x )(cid:104)(cid:96)1, . . . , (cid:96)n(cid:105) T1→ M (qi1 x1) . . . (qin xn) and a derivation of the judgement (cid:96) M : f1,i1
(cid:40)
· · · (cid:40) fn,in
(cid:40) fi. Note that this look-ahead automaton is non-deterministic in general,
but the transducer is weakly deterministic in the sense that, at each step, even if several
look-ahead states are possible, only one rule of the transducer can be applied.

Aq1
(cid:74)

(cid:75)

(cid:74)

(cid:75)

We deﬁne the set of states Q(cid:48) of transducer T by:
Q(cid:48) = {(q, f ) | q ∈ Q, f ∈
Then we deﬁne the set R of rules of transducer T as the set of rules of the form:
(q, f )(a −→x )(cid:104)((cid:96)1, f1,1, . . . , f1,m), . . . (cid:105) T→ D ((qi1, f1) x1) . . . ((qin , fn) xn)
such that there exists in T1 a rule: q(a −→x )(cid:104)(cid:96)1, . . . (cid:105) T1→ M (qi1 x1) . . . (qin xn) and D is a
(cid:40) · · · (cid:40) fn,in

derivation of the judgement (cid:96) M : f1,i1

} ∪ {q(cid:48)

Aq
(cid:74)

(cid:40) f .

0}

(cid:75)

Because of Theorem 5 that set of rules is weakly deterministic.
To that set R we then add rules for the initial state q(cid:48)

0, which simply replicate the rules of
states of the form (q0, (p0, (cid:96))): for all a ∈ Σ1, all ((cid:96)1, f1,1, . . . , f1,m), . . . , ((cid:96)n, fn,1, . . . , fn,m) ∈
L and all rule in R of the form:

(q0, (p0, l))(a −→x )(cid:104)((cid:96)1, f1,1, . . . , f1,m), . . . (cid:105) T→ M ((q1, f1) x1) . . . ((qn, fn) xn)
where p0 is the initial state of T2 and l ∈ L2 is a state of the look-ahead automaton of

T2, we add the rule :

0(a −→x )(cid:104)((cid:96)1, f1,1, . . . , f1,m), . . . (cid:105) T→ M ((q1, f1) x1) . . . ((qn, fn) xn)
q(cid:48)
This set R of rules is still weakly deterministic according to Theorem 5.
We have thus deﬁned the HOWDTRlin T = (ΣQ(cid:48), Σ1, Σ3, q(cid:48)

0, R, A).

M F C S 2 0 2 0

34:12

Linear High-Order Deterministic Tree transducers with Regular look-ahead

481

482

483

484

485

486

487

488

489

490

491

492

493

494

495

496

497

498

499

500

501

502

503

504

505

506

507

508

509

510

511

512

513

514

515

516

517

518

519

520

521

522

523

524

525

526

(cid:73) Theorem 7. T = T2 ◦ T1

Finally, we will analyze the complexity of this algorithm and show that using the
algorithm on HOWDTRlin instead of HODTRlin avoids an exponential blow-up of the size
of the produced transducer.

First the set of states Q(cid:48) of T is of size |Q(cid:48)| = 1 + Σq∈Q|
| is the number
(cid:74)
| = (|P | |L2|)|Aq| where |P | is the number of states of transducer
of tokens of type Aq. |
T2, |L2| is the number of states of the look-ahead automaton of transducer T2 and |Aq| is
the size of the type Aq. So the size of Q(cid:48) is O(Σq∈Q(|P | |L2|)|Aq|), that is a polynomial in
the size of T2 to the power of the size of types of states of T1.

| where |
(cid:75)
(cid:74)

Aq
(cid:74)

Aq

Aq

(cid:75)

(cid:75)

It is important to note that the set

of tokens of type Aq is where HOWDTRlin and
HODTRlin diﬀer in their complexity: the deterministic alternative to the weakly deterministic
T would require to store with the state not a single token, but a set of two-by-two coherent
tokens, that would bring the size of Q(cid:48) to 1 + Σq∈Q2|
| which would be exponential in the
Aq
(cid:74)
(cid:75)
size of T2 and doubly exponential in the size of types of T1.

Aq
(cid:74)

(cid:75)

(cid:75)

(cid:74)

(cid:74)

Aq1

× · · · ×

Then there is the look-ahead automaton: its set of states is L = L1 ×

Finally there is the set R of rules of T . For every judgement (cid:96) M : f1,i1

.
Aqm
(cid:75)
So the number of states is in O(|L1| (|P | |L2|)Σq∈Q|Aq|). The size of the set of rules of the
look-ahead automaton is in O(Σa(n)∈Σ1|L|n+1) where n is the arity of the constant a(n).
(cid:40) · · · (cid:40) fn,in

(cid:40)
f , ﬁnding a derivation D of that judgement and computing the corresponding D is in O(|M |2)
time where |M | is the size of M . The number of possible rules is in O(Σa(n)∈Σ1(|Q(cid:48)|)n+1).
So computing R is done in time O(|R|2 Σa(n)∈Σ1(|Q(cid:48)|)n+1) where R is the set of rules of T1.
With a ﬁxed input signature Σ1, the time complexity of the algorithm computing T is a
polynomial in the sizes of T1 and T2, with only the sizes of types of states of T1 as exponents.
Note that, as our model generalizes other classes of transducers, it is possible to perform
their composition in our setting. Thanks to results of Theorem 2, it is then possible to reduce
the order of the result of the composition, and obtain a HODTRlin that can be converted
back in those other models. This methods gives an important insight on the composition
procedure for those other formalisms.

In comparison, the composition algorithms for equivalent classes of transductions are
either not direct or very complex as they essentially perform composition and order reduction
at once. For instance, composition of single used restricted MTT is obtained through MSO
([11]). High-level tree transducers [12] go through a reduction to iterated pushdown tree
transducers and back. The composition algorithm for Streaming Tree Transducers described
in [1] is direct, but made complex by the fact that the algorithm hides this reduction of order.
The double-exponential complexity of composition of HODTRlin compares well to the
non-elementary complexity of composition in equivalent non-MSOT classes of transducers.
Although the simple exponential complexity of composition in MSOT is better, we should
account for the fact that the MSOT model does not attempt to represent the behavior of
programs.

5

Conclusion and future work

In this paper we have presented a new mechanical characterization of Monadic Second Order
Transductions. This characterization is based on simply typed λ-calculus which allows us to
generalize with very few primitives most of the mechanisms used to compute the output in
the transducer literature. The use of higher-order allows us to propose an arguably simple
algorithm for computing the composition of linear higher-order transducers which coincide
with MSOT. The correctness of this algorithm is based on denotation semantics (coherence

P. D. Gallot, A. Lemay and S. Salvati

34:13

527

528

529

530

531

532

533

534

535

536

537

spaces) of λ-calculus and the heart of the proof uses logical relations. Thus, the use of
λ-calculus allows us to base our work on standard tools and techniques rather than developing
our own tools as is often the case when dealing with transducers. Moreover, this work sheds
some light on how composition is computed in other formalisms. Indeed, we argue that for
M T Tsur, STT, or ARRsur, the composition must be the application of our composition
algorithm followed by the order reduction procedure that we use to prove the equivalence
with logical transductions.

The notion of higher-order transducer has already been studied [12, 18, 16], however,
there is still some work to be done to obtain direct composition algorithms. We plan to
generalize our approach of the linear case to the general one and devise a semantic based
partial evaluation for the composition of higher-order transducers.

M F C S 2 0 2 0

34:14

Linear High-Order Deterministic Tree transducers with Regular look-ahead

538

539

540

541

542

543

544

545

546

547

548

549

550

551

552

553

554

555

556

557

558

559

560

561

562

563

564

565

566

567

568

569

570

571

572

573

574

575

References

1 R. Alur and L. D’Antoni. Streaming tree transducers. J. ACM, 64(5):31:1–31:55, 2017.
2 Roderick Bloem and Joost Engelfriet. A comparison of tree transductions deﬁned by monadic
second order logic and by attribute grammars. J. Comput. Syst. Sci., 61(1):1–50, 2000. URL:
https://doi.org/10.1006/jcss.1999.1684, doi:10.1006/jcss.1999.1684.

3 C. Choﬀrut. A generalization of Ginsburg and Rose’s characterisation of g-s-m mappings. In

ICALP 79, number 71 in LNCS, pages 88–103. SV, 1979.

4 H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, C. Löding, S. Tison, and
M. Tommasi. Tree Automata Techniques and Applications. release October, 12th, 2007. URL:
http://tata.gforge.inria.fr/.

5 B. Courcelle. Monadic second-order deﬁnable graph transductions: a survey. Theoretical

Computer Science, 126(1):53–75, 1994.

6 B. Courcelle. Handbook of Graph Grammars and Computing by Graph Transformations,

Volume 1: Foundations. In Rozenberg, editor, Handbook of Graph Grammars, 1997.
S. Eilenberg. Automata, Languages and Machines. Acad. Press, 1974.

7
8 C. C. Elgot and G. Mezei. On relations deﬁned by generalized ﬁnite automata. IBM J. of

9

10

11
12

Res. and Dev., 9:88–101, 1965.
J. Engelfriet and S. Maneth. Macro tree transducers, attribute grammars, and mso deﬁnable
tree translations. Information and Computation, 154(1):34 – 91, 1999.
J. Engelfriet and S. Maneth. The equivalence problem for deterministic MSO tree transducers
is decidable. Inf. Process. Lett., 100(5):206–212, 2006.
J. Engelfriet and H. Vogler. Macro tree transducers. J. Comput. Syst. Sci., 31(1):71–146, 1985.
Joost Engelfriet and Heiko Vogler. High level tree transducers and iterated pushdown tree
transducers. Acta Informatica, 26(1):131–192, Oct 1988. URL: https://doi.org/10.1007/
BF02915449, doi:10.1007/BF02915449.
J. Y. Girard. Linear logic. TCS, 50:1–102, 1987.

13
14 M Kanazawa and R Yoshinaka. Distributional learning and context/substructure enumerability

in nonlinear tree grammars. In Formal Grammar, pages 94–111. Springer, 2016.

15 Makoto Kanazawa. Almost aﬃne lambda terms. National Institute of Informatics, 2012.
16 Naoki Kobayashi, Naoshi Tabuchi, and Hiroshi Unno. Higher-order multi-parameter tree
transducers and recursion schemes for program veriﬁcation. SIGPLAN Not., 45(1):495–
508, January 2010. URL: http://doi.acm.org/10.1145/1707801.1706355, doi:10.1145/
1707801.1706355.
J. Thatcher and J. Wright. Generalized Finite Automata Theory With an Application to a
Decision Problem of Second-Order Logic. Mathematical Systems Theory, 2(1):57–81, 1968.

17

18 Akihiko Tozawa. Xml type checking using high-level tree transducer. In Masami Hagiya and
Philip Wadler, editors, Functional and Logic Programming, pages 81–96, Berlin, Heidelberg,
2006. Springer Berlin Heidelberg.

