Knowledge-Preserving Certain Answers for SQL-like
Queries
Etienne Toussaint, Paolo Guagliardo, Leonid Libkin

To cite this version:

Etienne Toussaint, Paolo Guagliardo, Leonid Libkin. Knowledge-Preserving Certain Answers for SQL-
like Queries. KR 2020 - 17th International Conference on Principles of Knowledge Representation and
Reasoning, Sep 2020, Rhodes / Virtual, Greece. pp.758-767, ￿10.24963/kr.2020/78￿. ￿hal-03128504￿

HAL Id: hal-03128504

https://inria.hal.science/hal-03128504

Submitted on 2 Feb 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Knowledge-Preserving Certain Answers for SQL-like Queries

Etienne Toussaint1 , Paolo Guagliardo1 , Leonid Libkin1,2,3
1University of Edinburgh
2ENS-Paris, PSL
3Neo4j
{etienne.toussaint, paolo.guagliardo, libkin}@ed.ac.uk

Abstract

Answering queries over incomplete data is based on ﬁnding
answers that are certainly true, independently of how missing
values are interpreted. This informal description has given
rise to several different mathematical deﬁnitions of certainty.
To unify them, a framework based on “explanations”, or extra
information about incomplete data, was recently proposed. It
partly succeeded in justifying query answering methods for
relational databases under set semantics, but had two major
limitations. First, it was ﬁrmly tied to the set data model, and
a ﬁxed way of comparing incomplete databases with respect
to their information content. These assumptions fail for real-
life database queries in languages such as SQL that use bag
semantics instead. Second, it was restricted to queries that
only manipulate data, while in practice most analytical SQL
queries invent new values, typically via arithmetic operations
and aggregation.
To leverage our understanding of the notion of certainty for
queries in SQL-like languages, we consider incomplete data-
bases whose information content may be enriched by addi-
tional knowledge. The knowledge order among them is de-
rived from their semantics, rather than being ﬁxed a priori.
The resulting framework allows us to capture and justify ex-
isting notions of certainty, and extend these concepts to other
data models and query languages. As natural applications,
we provide for the ﬁrst time a well-founded deﬁnition of cer-
tain answers for the relational bag data model and for value-
inventing queries on incomplete databases, addressing the
key shortcomings of previous approaches.

1

Introduction

Many data analysis tasks that occur in traditional AI appli-
cations rely on the standard trusted database technology to
produce ﬁnal solutions to a problem. Most of such applica-
tions in a very natural way produce data that is incomplete;
in particular, data with missing values represented as NULLs
in SQL. Even though SQL has no explicit support for deal-
ing with incompleteness and does not even specify whether
NULL denotes a non-applicable or missing value, one can
always consider a setting where non-applicable nulls have
been removed – e.g., by using the techniques of (Franconi
and Tessaris 2012) – and NULLs only denote missing val-
ues. These commonly occur in ontology-mediated query
answering (Bienvenu and Ortiz 2015; Poggi et al. 2008;
Kontchakov et al. 2011), data integration (Lenzerini 2002;

Cal`ı, Lembo, and Rosati 2003), data exchange (Arenas et al.
2014), and handling inconsistent data (Bertossi 2011).

Reliance on database techniques imposes signiﬁcant lim-
its on queries that can be answered correctly. Indeed, an ex-
perimental study showed that common benchmark queries
with negation produce unreliable results (Guagliardo and
Libkin 2016). Unfortunately, our technical arsenal for cor-
rect query answering on incomplete databases is still rather
limited. This is especially so when it comes to queries most
commonly found in real-life scenarios.

Since the early days of database ﬁeld, the standard ap-
proach to answering queries over incomplete databases has
been based on ﬁnding answers one can be certain about,
regardless of the interpretation of the missing data. This
notion was introduced about 40 years ago (Grant 1977;
Jr. 1979; Codd 1979) and has since been studied on its
own, leading to varying mathematical deﬁnitions of cer-
tainty (Grahne 1991; van der Meyden 1998; Jr.
1984;
Imielinski and Jr. 1984; Abiteboul, Segouﬁn, and Vianu
2006; Libkin 2016a; Libkin 2016b). All these notions are
traditionally tested against a single setting: ﬁrst-order (or
closely related) queries over relational databases, interpreted
under set semantics. While understanding certainty and
its computational properties in this setting was very useful
(Console et al. 2020), it nonetheless falls short of what one
needs to deal with in realistic everyday queries, like those
written in SQL.

The key shortcomings of existing techniques are of two
kinds. To start with, real-life databases operate with bags
rather than sets. Syntactically straightforward extensions
of certainty notions have been studied over bags (Console,
Guagliardo, and Libkin 2017) but they were not properly
justiﬁed unlike their set-theoretic counterparts (and we shall
see later that this indeed leads to serious problems with exist-
ing deﬁnitions). Furthermore, existing notions only work for
queries that essentially manipulate data. Real-life queries
also generate new data values, by means of, for example,
In fact, in the stan-
arithmetic operations or aggregates.
dard TPC-H benchmark for evaluating SQL-database per-
formance, over 90% of queries are value-inventing (TPC
2014), and all of them use bag semantics.

Our goal is thus twofold. We want to build an abstract
framework for justifying the notion of certainty, and upon
validating it, we shall use it to explain what certainty is for

realistic SQL-like queries that use bag semantics and value-
invention. By validating we mean that it should capture
existing notions in the setting where they are well under-
stood, namely relational databases under set semantics, and
no value invention in queries.

We follow an approach advocated in (Libkin 2016a) that
has the advantage of being applicable in different data mod-
els. The key concept is that of informativeness of databases:
a database x is more informative than a database y if all the
possible worlds it represents are also possible worlds rep-
resented by y. Intuitively the more informative a database
is, the fewer worlds it may represent and the less ambigu-
ous it is. Then the certain answer to a query on an incom-
plete database x is the most informative database which is
not more informative than the query answer on every pos-
sible world of x. This however may be too permissive as it
misses the reason, or explanation, why a complete database
is a possible world for an incomplete database x. In general
an explanation can turn an incomplete object into a more
informative object; explanations compose, and certain an-
swers must preserve the informativeness order provided by
the explanation. Such an order essentially says that apply-
ing an explanation to a database results in a more informa-
tive database. Using this idea, (Amendola and Libkin 2018)
developed a framework that was capable of explaining the
commonly used deﬁnition of certainty of (Jr. 1984), for rela-
tional database queries under set semantics and informative-
ness orders naturally imposed by such a model. The main
drawback of the approach is that it is too closely tied to a
particular data model (relations as sets) and the informative-
ness orders it imposes, and to particular features of query
languages (no bags, no value invention).

To overcome those problems, we reﬁne the information-
based framework in a way that opens up an approach to
deﬁning certainty for most typical queries that occur in SQL-
like languages over real-life databases. The key concept is
that of knowledge preservation to improve the information
content of answers to queries on incomplete databases. In-
tuitively, the interpretation of missing data may be speciﬁed
by some additional knowledge, and hence the information
content of a database is deﬁned with respect to this knowl-
edge. Consequently, certainty of an answer to a query q on
a database x means two things. First, it is no more informa-
tive than answers to q in all possible worlds x. Second, if
c is a possible world for x obtained by providing some new
knowledge, then the answer to q on c must also be a possible
world for the answer to q on x with this new knowledge.

The main distinguishing feature of this approach is that
we derive the knowledge-preserving information pre-order
from the semantics of data, rather than have it as a basic no-
tion in the model. The latter restricted us to a handful of
cases where such an ordering already existed, such as fa-
miliar open- and closed-world interpretation of incomplete
databases under set semantics. The new approach allows us
to unify already existing notions of certain answers without
using any speciﬁc database model. The framework is very
natural to instantiate for other data models and for expres-
sive query languages. We demonstrate it by showing that it
allows us for the ﬁrst time to give a well-founded notion of

certain answers on bag relational databases. We demonstrate
its additional power with respect to query language features
by showing that we can deﬁne, again for the ﬁrst time, a
notion of certain answers for value-inventing queries. We
can further use the approach to devise an implementation-
friendly approximation scheme for such certain answers.

Organization Preliminary deﬁnitions and notation are in-
troduced in Section 2, and in Section 3 we present our frame-
work based a notion of certain answers that preserve knowl-
edge. We then apply the general framework to two cases of
practical interest: bag relational databases (Section 4) and
value-inventing queries (Section 5). We conclude with ﬁnal
remarks and a discussion of future work in Section 6.

2 Preliminaries
We begin by introducing the basic notions and notation that
we will use throughout the paper. The abstract framework is
largely adapted from (Libkin 2016a), which itself was based
on earlier work utilizing techniques from programming se-
mantics and domain theory in handling incompleteness in
databases such as (Buneman, Jung, and Ohori 1991; Rounds
1991; Libkin 1995). We refer the reader to (Libkin 2011;
Libkin 2016a) for more detailed information about such con-
nections.

·

(cid:74)

(cid:74)

(cid:74)

(cid:74)

(cid:75)

·
(cid:75)

·
(cid:75)

·
(cid:75)

Information-Based Certain Answers

2.1
A database domain D is a triple (I, C,
), where I is a set of
database objects,1 C ⊆ I is the set of complete databases in
I and
: I → P(C) is the semantic function that assigns a
set of complete databases (possible worlds) to a database ob-
ject. For notational convenience, we also use ID, CD,
D
to refer to the set of incomplete databases, the set of com-
plete databases, and the semantic function, respectively, of
a database domain D. Intuitively, the more possible worlds
an incomplete database represents, the more ambiguous it
is. To make this intuition formal, with a database domain
D = (I, C,
) we associate an information pre-order (cid:22)D
on I, deﬁned as follows: x (cid:22)D y iff
. That is, a
database x ∈ I is less informative than a database y ∈ I if
every possible world of y is also a possible world of x. This
is a pre-order (i.e., a reﬂexive transitive relation). The asso-
ciated equivalence relations, when x (cid:22)D y and y (cid:22)D x, is
denoted by x ≡D y. We shall be using the notation
for
(cid:83)

x∈X
Given two database domains S (for source) and T (for
target), a query from S to T is a mapping q from CS to
CT, i.e., it maps complete databases of a source database
domain S to complete databases of a target database domain
T. The standard way to deﬁne query answers on incomplete
databases is by considering answers that are true in all pos-
sible worlds, that is, answers that are no more informative
than the answers to the query on all possible worlds repre-
sented by the incomplete database. To this end, if C is a set

x
(cid:74)

y
(cid:74)

X

⊆

x

(cid:75)

(cid:75)

(cid:74)

(cid:75)

(cid:74)

(cid:75)

.

1The term “database objects” here refers to generic structures,
such as relational or graph databases, that store data. Some of these
objects are assumed to provide complete information, while others
do not.

of complete databases, we let

q(C) = (cid:8)q(c) | c ∈ C(cid:9)
Then, the information-based certain answer to a query q
from S to T on an incomplete source database x ∈ IS is the
greatest lower bound (denoted by glb ) of the query answers
on the possible worlds of x with respect to the information
pre-order:

x

q(
(cid:74)

S)
(cid:75)

cert(cid:3)(q, x) = glb(cid:22)T

(1)
In other words, the information based-certain answer is
the most informative database that is consistent, w.r.t. the in-
formation pre-order, with every possible answer to the query.
In particular, we have q(
S) ⊆
T. Note that
(cid:74)
for general pre-orders, the greatest lower bound may not ex-
ist, especially for inﬁnite sets, and even when it exists in (1),
it is deﬁned up to the ≡T equivalence relation.

cert(cid:3)(q, x)
(cid:75)

x

(cid:74)

(cid:75)

We will see an example of information-based certain an-

swers after introducing relational database domains.

2.2 Relational Databases
In the context of relational databases, the standard model for
representing incomplete data is that of marked nulls, where
databases are populated by two kinds of values, constants
and nulls. These come from two disjoint countably inﬁnite
sets, Const and Null, respectively. We denote the elements
of Null using the symbol ⊥ with subscripts.

A relational database schema is a ﬁnite set of table names
with associated arities, and a k-ary table is a ﬁnite bag (a.k.a.
multiset) of k-tuples over Const ∪ Null. The number of oc-
currences of a tuple ¯t in a table T is denoted by #(R, ¯t).
Then, a relational database d over a given schema maps each
table name R in the schema to a table Rd of appropriate ar-
ity. We write Const(d) and Null(d) for the set of constants
and nulls occurring in d, respectively. For convenience of
notation, we sometimes represent a relational database as
a bag of facts; e.g., d = {|R(1, ⊥1), S(⊥1, 2), R(1, ⊥1)|}
is the database d such that Rd = {|(1, ⊥1), (1, ⊥1)|} and
Sd = {|(⊥1, 2))|}.

A valuation is a partial function v from Null to Const. If
v is deﬁned on all elements of Null(d), we say that v is d-
complete. For ¯t = (t1, . . . , tk), we let v(¯t) denote the tuple
(cid:0)˜v(t1), . . . , ˜v(tk)(cid:1), where ˜v is the total function on Null ∪
Const such that ˜v(t) = v(t) whenever v(t) is deﬁned, and
˜v(t) = t otherwise.

When tables are constrained to be sets, the result of apply-
ing a valuation v to a table T is the table v(T ) = {v(¯t) | ¯t ∈
T }, and this extends to databases in the natural way. When
tables are bags, things are slightly more complicated, as we
shall see in Section 4.

A database domain (I, C,

) is relational if I is a set of
·
relational databases and, for every d ∈ C ⊆ I, Null(d) = ∅.
(cid:75)
(cid:74)
When tables are constrained to be sets, the two most com-
mon semantics of incompleteness, referred to as the seman-
tics under open-world and closed-world assumptions (OWA
and CWA), are deﬁned as follows (cf. (Imielinski and Jr. 1984;
Grahne 1991)):

OWA = {d(cid:48) complete | ∃ valuation v s.t. v(d) ⊆ d(cid:48)}
CWA = {d(cid:48) complete | ∃ valuation v s.t. v(d) = d(cid:48)}

d
(cid:75)
d
(cid:75)

(cid:74)

(cid:74)

In other words, under CWA we simply replace nulls with con-
stants, while under OWA we can also add extra tuples.

On relational databases, a query answer can be improved
in two ways: by ﬁnding more tuples, or by instantiating nulls
with values. This corresponds to the open-world semantics
of incompleteness. Therefore, we assume that the the target
domain of queries always uses the OWA semantics, while the
source can use either the CWA or OWA semantics; see (Console
et al. 2020).

Below, we recall two commonly used notions of cer-
tain answers due to (Jr.
1984; Libkin 2016b; Console,
Guagliardo, and Libkin 2017). These apply for queries from
relational database domains under OWA or CWA to relational
database domains under OWA.

The intersection-based certain answer to a query q on a
relational database d is the intersection of the answers to q
on every possible world represented by d:
(cid:92) (cid:8)q(d(cid:48)) | d(cid:48) ∈

cert∩(q, d) =

(2)

(cid:9)

d
(cid:74)

(cid:75)

The certain answer with nulls to a query q on a relational
database d is the table cert⊥(q, d) such that, for every d-
complete valuation v and for every c ∈
, the multi-
plicity of each tuple in v(cid:0)cert⊥(q, d)(cid:1) is less than or equal
to its multiplicity in q(c):

v(d)
(cid:75)
(cid:74)

,

v(d)
(cid:75)

(cid:74)

#(cid:0)cert⊥(q, d), ¯t (cid:1) = min (cid:8) #(cid:0)q(c), v(¯t)(cid:1) | c ∈

v is a d-complete valuation(cid:9) (3)
We remark that the above deﬁnition is implicit in (Con-
sole, Guagliardo, and Libkin 2017) and it is a natural exten-
sion of certain answers with nulls for sets (Libkin 2016b) to
bags.

The information-based notion of certain answers (1) is
able to capture intersection-based certain answers. Let S
be a relational database domains and T a complete rela-
tional database domain, i.e., relational databases without
null values. Then, for every query q from S to T, either
both the information-based certain answer cert(cid:3)(q, d) and
the intersection-based certain answer cert∩(q, d) exist and
coincide, or neither of them exists.

On the other hand, the information-based notion of certain
answers fails to capture certain answers with nulls. This is
due to the fact that it does not keep track of what nulls are
mapped to, as the following example shows.
Example 1. Consider the database d = {R(⊥1, 1)} and a
query q that returns the ﬁrst and second columns of R plus an
extra column with their sum. The most relevant answer one
could expect is (⊥1, 1, ⊥1 +1). But cert⊥(q, d) is the empty
table, because it cannot capture the value ⊥1 +1. Indeed, for
every null ⊥ there exits a valuation v such that v(cid:0)(⊥1, 1, ⊥)(cid:1)
is not in q(cid:0)v(d)(cid:1). On the other hand, the information-based
notion is more permissive, as cert(cid:3)(q, d) gives us a tuple
of the form (⊥i, 1, ⊥j), where ⊥i and ⊥j are fresh nulls.
However, since null labels are not preserved, there is no re-
lationship between ⊥i and ⊥j in the output, and ⊥1 in the
input. In particular, it is not enforced that the value ⊥i in the
output and the value ⊥1 in the input must be equal (and that
⊥j is equal to ⊥1 + 1).

We will later build on the above example to also show
that neither information-based certain answers nor certain
answers with nulls are entirely satisfactory. To reconcile the
two notions, we introduce the concept of knowledge preser-
vation.

3 Knowledge-preserving Certain Answers
As explained earlier, an incomplete database x is less infor-
mative than y if every possible world of y is also a possible
world of x. Suppose now that we discover some new infor-
mation that reduces the ambiguity of x by eliminating some
possible worlds; nothing ensures that this knowledge would
also reduce the incompleteness of y. Indeed, it may well be
the case that, in the presence of some additional knowledge,
x would become more informative than y.

To make this intuition formal, we deﬁne the notion of uni-
versal knowledge K. Its elements are viewed as pieces of
knowledge that can be applied to a database to make it po-
tentially more informative. Such pieces of knowledge can be
concatenated: applying ωω(cid:48) means applying ω ﬁrst and then
applying ω(cid:48) to the result of applying ω. Finally we have the
empty knowledge ε: applying it to any database x does not
change x. That is, K is a monoid as it has a binary concate-
nation operation ωω(cid:48) (which we assume to be associative)
and the identity ε satisfying εω = ωε = ω.
Then, for a database domain (I, C,

), the K-semantics
of an incomplete database x ∈ I under knowledge ω ∈ K
ω of complete databases in C represented by x
is the set
when ω is known. We assume that, for any given database
domain, such a semantic function from I × K to 2C always
for every x ∈ I. Intui-
ε =
exists and it is such that
(cid:75)
tively, the empty knowledge does not give us any extra in-
formation about the semantics of incomplete databases.

·
(cid:75)

x

x

x

(cid:74)

(cid:75)

(cid:74)

(cid:74)

(cid:75)

(cid:74)

As K contains all possible knowledge, it would be reason-
able to assume that the K-semantics, while always existing,
is not always fully known. Thus, we consider sub-monoids
of K, in particular those whose knowledge increases the in-
formation content of database objects.

Deﬁnition 1. A sub-monoid A of the universal knowledge
K is additional knowledge for a database domain D if

∅ (cid:40)

ωω(cid:48)
D ⊆

x

(cid:74)

(cid:75)

(cid:74)

(cid:75)

x

ω
D

(4)

for every x ∈ ID and for every ω, ω(cid:48) ∈ A.

Intuitively, the information content of an incomplete da-
tabase can only increase with the additional knowledge in A
and is consistent with it. Note that {ε} is additional knowl-
edge for every database domain and corresponds to the situ-
ation in which we only have “empty” knowledge.

We can now deﬁne the relative informativeness of incom-

plete databases in the presence of additional knowledge.

D y, if

Deﬁnition 2. Let A be additional knowledge for D, and let
x, y ∈ ID. We say that x is less A-informative than y, and
ω
write x (cid:22)A
D for every ω ∈ A.
(cid:75)

In other words, x is less informative than y under the addi-
tional knowledge A if, for every piece of knowledge ω ∈ A,
each possible world of y under ω is also a possible world of

ω
D ⊆
(cid:75)

x

y

(cid:74)

(cid:74)

x under ω. We omit the subscript in (cid:22)A
(cid:22)A, when the database domain is clear from the context.

D, and simply write

As shown below, additional knowledge conservatively ex-
tends the information-based framework of (Libkin 2016a):
if we do not have any knowledge beyond ε, we get the stan-
dard information pre-order (cid:22); but the more we discover – by
means of additional knowledge – of the K-semantics of in-
complete databases, the less permissive the information pre-
order becomes.

Proposition 1. The following are true:

(a) (cid:22)A is a pre-order;
(b) (cid:22){ε} is a equivalent to (cid:22);
(c) If x (cid:22)A y, then x (cid:22)B y for every sub-monoid B of A.

With this in place, our goal is to capture answers that are
consistent with the answers on every possible world under
every extra knowledge.

Deﬁnition 3 (Knowledge-preserving certain answer). Let q
be a query from S to T, let x ∈ IS, and let A be additional
knowledge for both S and T. The A-preserving certain an-
swer to q on x, denoted by certA(q, x), is the most informa-
tive database with respect to (cid:22)A that satisﬁes the following:

q(cid:0)

for every ω ∈ A.

(cid:1) ⊆

ω
S

x
(cid:74)

(cid:75)

certA(q, x)
(cid:75)

(cid:74)

ω
T

(5)

This notion generalizes the information-based certain an-
swer cert(cid:3) and it relies only on the existence of a possible-
worlds semantics for the additional knowledge in A.

The A-preserving certain answer can also be interpreted
as a kind of “synchronized” greatest lower bound, with re-
spect to (cid:22)A, of the query answers on the possible worlds of
the input:

(cid:74)

certA(q, d) = glb(cid:22)A q(x)
where, for every knowledge ω ∈ K, the K-semantics of the
ω
T = q(
artifact q(x) is given as

q(x)
(cid:75)
The expected behavior of query answering under incom-
plete information is that more informative query inputs yield
more informative query outputs. We show that this is indeed
the case for certain answers that preserve additional knowl-
edge. Moreover, the information-based certain answers are
precisely the certain answers that preserve the empty knowl-
edge.

x
(cid:75)

ω
S).

(cid:74)

Proposition 2 (Information preservation). Let A be a sub-
monoid of K, and let q be a query from S to T. Then, for all
x, y ∈ IS and every ω ∈ A, all of the following hold:

(a) If certA(q, x) and certA(q, y) exist and x (cid:22)A y, then

certA(q, x) (cid:22)A certA(q, y);

(b) certA(q, x) (cid:22)B certB(q, x) for every B ⊆ A;
(c) cert(cid:3)(q, x) = cert{ε}(q, x).
The above also implies that information-based certain an-
swers are the most informative answers one could expect
with empty knowledge; however, they do not preserve non-
empty knowledge in general. The following example shows
why this is important.

Example 2. Consider again the setting of Example 1, and
the extra piece of knowledge ω encoding the fact that the
value of ⊥j is 0. Clearly, the information content of the
original database d is not increased by this new knowledge,
since ⊥j (cid:54)∈ Null(d). But ⊥j occurs in the information-based
certain answer (⊥i, 1, ⊥j), whose possible worlds under ω
always contain the tuple (⊥i, 1, 0). Thus, the information-
based certain answer under additional knowledge is not less
informative than all possible answers under the same knowl-
edge, and it may contain false tuples.

What this means is that information-based certain answers
become irrelevant once we discover additional knowledge:
they must be recomputed on a more informative database, if
it exists. Knowledge-preserving certain answers do not have
this shortcoming, as we show next.
Theorem 1. Let q be a query from S to T, let x ∈ IS, and let
A be additional knowledge for both S and T. If certA(q, x)
exists, then

certA(q, x)

ω
T ⊆ q(
(cid:74)

x

ω
S)

(cid:75)
for every ω ∈ A. Moreover, there exist a query q, database
x ∈ IS and w ∈ A such that:

(cid:74)

(cid:75)

(6)

(a)
(b)

ω
cert(cid:3)(q, x)
T (cid:54)⊆ q(
(cid:75)
ω
certA(q, x)
T ⊆
(cid:75)

(cid:74)

(cid:74)
(cid:74)

ω
S), and
x
(cid:74)
cert(cid:3)(q, x)

(cid:75)

T.

(cid:75)

Informally, knowledge-preserving certain answers remain
relevant and consistent when new information is discovered.
Moreover, there are queries for which this notion gives more
informative answers under additional knowledge.

Next, we apply our general framework to relational data-
bases, under the bag semantics that is the standard in all re-
lational products. We do so in a setting where additional
knowledge is given by partial valuations of nulls. We then
show that the well-known certain answers with nulls corre-
sponds to the valuation-preserving certain answers. We also
use our results to justify notions used hitherto in the set se-
mantics context.

4 Certainty in Bag Relational Databases

Recall that an incomplete relational database is a ﬁnite set of
tables populated by constants and nulls, and its semantics of
incompleteness is given by instantiating nulls with constants
by means of valuations.

Deﬁnition 4. The monoid of partial valuations V ⊆ K con-
sists of all partial functions from Null to Const. Moreover,
for every v, v(cid:48) ∈ V, the K-semantics of incomplete rela-
tional databases is

v(cid:48)(cid:0)v(d)(cid:1)

=

.

d
(cid:74)

vv(cid:48)
(cid:75)

(cid:74)

(cid:75)

We immediately have that the knowledge encoded by V is
additional to the relational database domain for both closed
and open world semantics. However, so far we have not ex-
plained how a valuation v is applied to a relational database
d. When tables T are constrained to be sets, there is no am-
biguity on how to construct v(T ). But when they are bags,
there are several possibilities, each leading to different se-
mantics (Hernich and Kolaitis 2017).

4.1 Collapsing and Additive Semantics
The ﬁrst construction we study prescribes that, when a valu-
ation is applied to a table, distinct tuples that become equal
(i.e., unify) under the valuation are “collapsed” together, so
that the maximum number of occurrences of each such tuple
appears in the result.
Deﬁnition 5. The collapsing application of a valuation v on
a table T is the table v(T ) such that for every tuple ¯t

#(cid:0)v(T ), ¯t (cid:1) = max(cid:8)#(T, ¯u) | v(¯u) = t(cid:9)
For example, consider a table T given by the following bag:

{|(1, 2), (⊥1, 2), (1, ⊥2), (1, ⊥2)|}
(7)
and a valuation v such that v(⊥i) = i for every i. Then, the
collapsing application of v to T is the table v(T ) given by
the bag {|(1, 2), (1, 2)|}.

Intuitively, when valuations are applied in such a way, in-
complete facts only represent new information if they do not
unify with already existing data. Below we show that, under
this semantics of valuations, the certain answers with nulls
coincide with the valuation-preserving ones.
Proposition 3. Let S and T be relational database domains
under the collapsing application of valuations. Then, for
every query q from S to T and for every d ∈ IS, either both
certV (q, d) and cert⊥(q, d) exist and coincide, or neither of
them exists.

We remark that the above result holds for databases under
the bag data model, but also – in particular – when tables are
constrained to be sets.

Since the collapsing semantics negates the importance of
a tuple’s identity by disregarding – to some extent – its mul-
tiplicity, the most commonly used semantics is instead one
where the multiplicities of tuples that become equal under a
valuation are added up in the result.
Deﬁnition 6. The additive application of a valuation v on a
table T is the table v(T ) such that for every tuple ¯t

#(cid:0)v(T ), ¯t (cid:1) =

(cid:88)

#(T, ¯u)

¯u : v(¯u)=¯t

To see the difference with the collapsing semantics, con-
sider again the table T given by the bag in (7), and the same
valuation v such that ⊥i (cid:55)→ i. The additive application of
v to T results in a table v(T ) consisting of 4 (as opposed to
2) occurrences of the tuple (1, 2). When valuations are ap-
plied in such an additive way, incomplete facts always rep-
resent new information even if they unify with already exist-
ing data, in contrast with the collapsing semantics discussed
earlier.

However, while more natural, this semantics of valuations
leads to problems in terms of certain answers, as shown be-
low.
Theorem 2. There exists a union of conjunctive queries with
negation where the source and target database domain are
relational database with additive semantics, such that:

(a) the valuation-preserving certain answer does not ex-

ist;

(b) the {ε}-preserving certain answer does not exist.
(c) the certain answer with nulls is not less informative

than every possible answer.

the semantics of target. To do this under additive valuations,
we need to interpret query answers under the collapsing se-
mantics.

Below we give an example in which the certain answer
with nulls to a query q on a database d is not less informative
than the answer to q on some possible world of d.
Example 3. Consider the following database D:

R
B C
⊥1
2
1
2

A
1
⊥2

S

A B C
1

D
2 ⊥2 ⊥1

T
A B
2
1

and the following relational algebra query q:
(cid:0)σA(cid:54)=C∧B(cid:54)=C(R)(cid:1) (cid:93) πA,B

πA,B

(cid:0)σA=C∧B=D(S)(cid:1) (cid:93) T

(cid:74)

v(D)
(cid:75)

Then, cert⊥(q, D) is the bag {|(1, 2), (1, ⊥1), (⊥2, 2)|}. If
we take a valuation v such that v(⊥1) = 2 and v(⊥2) = 1,
then {|(1, 2); (1, 2)|} belongs to q(cid:0)
(cid:1). But with the ad-
cert⊥(q, D)
contains at least three tuples
ditive semantics
and so it cannot be less informative than q(cid:0)v(D)(cid:1).
(cid:74)

(cid:75)
The answers A1 = {|(1, 2)|} and A2 = {|(1, ⊥i), (⊥k, 2)|}
are both less informative than every element of q(
). Thus,
(cid:75)
cert(cid:3)(q, D) should be more informative than both A1 and
A2. We clearly have that A1 (cid:54)(cid:22) A2 and A2 (cid:54)(cid:22) A1; moreover,
it is easy to check that we cannot increase the information
content of A1 or A2 and still be less informative than the
answer to q on every possible world described by D. There-
fore, the information-based certain answer does not exist.

d
(cid:74)

The above result tells us that, under additive valuations,
the notion of certain answers with nulls is not well-founded,
as even for simple queries they may not be less informative
than the query answers on every possible world. Thus, some
fact in the certain answers with nulls might be false.

Moreover, Example 2 showed that the information-based
certain answer can be strictly less informative than the cer-
tain answer with nulls, and Proposition 2 states that, for ev-
ery knowledge, the knowledge-preserving certain answer is
no more informative than the information-based certain an-
swer. Therefore, there is no additional knowledge such that
knowledge-preserving certain answers capture certain an-
swers with nulls. We argue that this is due to the additive
semantics itself.

(cid:75)

(cid:75)

(cid:74)

(cid:75)

∩

=

=

d2

d1
(cid:74)

d1 ∪ d2
(cid:74)

To see this, consider two incomplete relational databases
d1 and d2 of the same schema. Then, under OWA and collaps-
ing valuations, we can always build a database d3 such that
, where ∪ denotes the union-
d3
max operator: #(T1 ∪T2, ¯t) = max(cid:0)#(T1, ¯t), #(T2, ¯t)(cid:1). This
(cid:74)
(cid:75)
ensures that, if we have a ﬁnite number of possible answers
to a query, then the certain answers always exist. However,
under additive valuations, we lose this property: as shown
in Example 3, there exist databases d1 and d2 such that, for
every database d3, we have
d3
. This can
(cid:74)
be interpreted as a mismatch between the semantics and the
set of incomplete objects.: there are not enough objects to
capture the complexity of the semantics.

d1

d2

(cid:54)=

∩

(cid:74)

(cid:75)

(cid:75)

(cid:75)

(cid:74)

Now that we have identiﬁed the problem, we can ﬁnally
capture the notion of certain answers with nulls by changing

Proposition 4. Let S and T be relational database domains
under the additive and collapsing application of valuations,
respectively. Then, for every query q from S to T and for ev-
ery database d ∈ IS, either both certV (q, d) and cert⊥(q, d)
exist and coincide, or neither of them exists.

Corollary 1. The result of Proposition 4 holds, in particular,
for relational databases under set, rather than bag, seman-
tics. In that context, the certain answer with nulls becomes:

cert⊥(q, d) = (cid:8)¯t | v(¯t) ∈ q(cid:0)v(d)(cid:1)

for every d-complete valuation v(cid:9)

which corresponds to the deﬁnition given by (Jr. 1984).

We have been able to justify the notion of certain answers
with nulls for both the additive and the collapsing semantics
of valuations, but neither is entirely satisfactory. On the one
hand, collapsing valuations decreases the expressiveness of
the relational data model based on bags. On the other hand,
certain answers with nulls under additive valuations must be
interpreted using the collapsing semantics, which is counter-
intuitive.

We will now propose a new semantics of incompleteness
for relational databases that overcomes these shortcomings.

4.2 Mixed Semantics

The main idea behind our proposed semantics is that apply-
ing a valuation to a table does not produce one table, as is the
case with the collapsing and additive semantics, but rather a
set of tables.

Deﬁnition 7. The mixed application of a valuation v to a k-
ary table T is the set v(T ) consisting of all tables B of arity
k such that, for every k-ary tuple ¯t of constants and nulls:

max(cid:8)#(B, ¯u) | v(¯u) = ¯t (cid:9) ≤ #(B, t) ≤

(cid:88)

#(B, ¯u)

¯u : v(¯u)=¯t

This extends to databases d as follows: v(d) is the set of all
databases d1 of the same schema as d such that Rd1 belongs
to v(Rd) for every table name R.

Finally, the mixed semantics of incompleteness under OWA

and CWA are given as follows:

(cid:75)

(cid:74)

CWA = {d1 complete | d1 ∈ v(d), v is a valuation}
OWA = {d2 complete | d2 ⊇ d1 ∈ v(d), v is a valuation}

d
(cid:74)
d
(cid:75)
As the name suggests, the mixed semantics combines the
collapsing and the additive ones, by taking into account that
incomplete facts unifying with already existing data may or
may not represent new information.

Below we show that, when using the mixed semantics of
valuations on both the source and target domain of queries,
the valuation-preserving certain answers and the certain an-
swers with nulls coincide.

Theorem 3. Let S and T be relational database domains
under the mixed application of valuations. Then, for every
query q from S to T and for every database d ∈ IS, either
both certV (q, d) and cert⊥(q, d) exist and coincide, or nei-
ther of them exists.

Note that when we consider the open world assumption,
the collapsing and mixed semantics are equivalent. And for
every valuation from V their K-semantics are also the same.
However, as illustrated in Example 4, there exists a query
such that valuation-preserving certain answers upon addi-
tive, collapsing and mixed semantics are different for closed-
world semantics.
Example 4. Let d be a relational database such that

Rd = {|1, ⊥1, ⊥2|} ; Sd = {|1, 1|} ;

and consider the following relational algebra query q:

π∅

(cid:0)(R − S) (cid:93) (S − R)(cid:1)
It is easy to see that the certain answers of q are empty iff
there exists a possible world c of d such that Rc = Sc. Since
Sd does not contain nulls, we focus on R.

Under the additive semantics of valuations, for every pos-
sible world c of d there are at least 3 tuples in Rc. As there
are always exactly 2 tuples in Sc, we have that Rc − Sc can-
not be empty. Thus, the valuation-preserving certain answer
to q on d is non-empty.

Under the collapsing semantics of valuations, {|1, 1|} (cid:54)=
v(Rd) for every valuation v because, even if v(⊥1) = 1 or
v(⊥2) = 1, they collapse into a single occurrence of value
1. Hence, for every possible world c of d, we have that Sc −
Rc cannot be empty, and therefore the valuation-preserving
certain answer to q on d is non-empty.

Under the mixed semantics of valuations, we consider ev-
ery possible multiplicity for each tuple, and {|1, 1|} ∈ v(Rd)
when v(⊥1) = v(⊥2) = 1. Thus, the empty bag is a possi-
ble answer to q, and the valuation-preserving certain answer
to q on d is empty.

In light of the above, we argue that the semantics of val-
uations one should use in the context of relational databases
is the mixed semantics, because it behaves consistently in-
dependently of whether a (relational) database domain is the
source or the target of queries. However, under mixed se-
mantics, the valuation-preserving certain answers coincide
with the certain answers with nulls, and these are still unsat-
isfactory as they cannot produce answers involving values
that were not present in the original data, as Example 1 il-
lustrates.

We would like to capture all the information-based certain
answers, while keeping the valuation-preservation property
of the certain answers with nulls. By Proposition 2, we know
that with the relational database domain as target it is impos-
sible to be valuation-preserving and more informative at the
same time. Therefore, we must modify the target domain;
this is what we do in the next section.

5 Certainty for Value-Inventing Queries
To handle queries whose answers may contain values not ap-
pearing in the original input, we extend relational databases

with the notion of persistent nulls. Informally, these are in-
formation placeholders with the same semantics as marked
nulls, but their incompleteness does not decrease in the pres-
ence of new knowledge: every interpretation of a persistent
null is consistent with any additional knowledge.

Relational database domains with persistent nulls are sim-
ply relational database domains, where databases are popu-
lated by constants, nulls and persistent nulls. The latter val-
ues come from a countably inﬁnite set PNull. We denote the
elements of PNull using the symbol (cid:62) with subscripts. For a
database d, we denote by PNull(d) the set of persistent nulls
appearing in it.

A P-valuation is a partial function v from Null ∪ PNull to
Const. We denote by v(d) the database obtained from d by
replacing each element e of Null ∪ PNull with v(e), if this is
deﬁned. We introduce P-valuations only as a means to de-
ﬁne the semantics of relational database domains with per-
sistent nulls; such P-valuations, however, do not provide ad-
ditional knowledge, as the incompleteness of persistent nulls
cannot be reduced. Indeed, we consider again the monoid V
of partial valuations introduced in Section 4, which is addi-
tional to relational database domains with persistent nulls.

In what follows, we will only use relational database do-
mains with persistent nulls as target, and we focus on open-
world semantics as before. For simplicity, we use the col-
lapsing semantics of P-valuations, which is deﬁned below
and is equivalent to the mixed one.

Deﬁnition 8. The collapsing application of a P-valuation v
to a k-ary table T is the k-ary table v(T ) such that, for every
tuple ¯t ∈ Constk we have:

#(cid:0)v(T ), ¯t (cid:1) = max(cid:8)#(R, ¯u) | v(¯u) = ¯t (cid:9)

The corresponding OWA semantics of incompleteness is de-

ﬁned as follows:

d
(cid:75)

OWA = {d(cid:48) complete | d(cid:48) ⊇ v(d), v is a P-valuation}

(cid:74)
With all of this in place, we can capture information-based
certain answers while still preserving knowledge from par-
tial valuations.

Below, we show that the valuation-preserving certain an-
swers with persistent nulls are as informative as information-
based certain answers, and more informative than valuation-
preserving certain answers without persistent nulls.

Proposition 5. Let R be a relational database domain, and
let P be a relational database domain with persistent nulls,
such that CR = CP. Let q be a query from R to R, and
let q(cid:48) be a query identical to q, but from R to P. Then, for
every d ∈ IR, all of the following hold:
(a) cert(cid:3)(q, d) ≡P certV (q(cid:48), d);
P certV (q(cid:48), d).
(b) certV (q, d) (cid:22)V
Since we are now able to capture information-based cer-
tain answers, the valuation-preserving certain answers will
not be empty. As an application, we look at a class UCQ-F
of value-inventing queries deﬁned by unions of conjunctive
queries with function application.

5.1 Query Answering for UCQ-F
Let F be a set of functions where each function f of arity k
is from Constk to Const.
Deﬁnition 9. The language UCQ-F of union of conjunctive
queries with function application is deﬁned by the following
grammar:

q := R | q × q | q (cid:93) q | π ¯α(q) | σαi=αj (q)
| Apply ¯α(f, q) with f ∈ F
where αi and αj are attributes, and ¯α is a tuple of attributes.
All of the operations above, except Apply, are deﬁned in
the standard way (Console, Guagliardo, and Libkin 2019).
The semantics of q(cid:48) = Applyα1,...,αk
(f, q), for every com-
plete relational database d and for every tuple ¯t of the same
arity as q, is deﬁned as follows:
(cid:26)#(cid:0)q(d), ¯t (cid:1)

if t = f (cid:0)¯t[α1], . . . , ¯t[αk](cid:1)
otherwise

#(cid:0)q(cid:48)(d), (¯t, t)(cid:1) =

0

While the query language UCQ-F is conceptually quite
simple, computing the valuation-preserving certain answers
for UCQ-F queries is intractable even if F consists of just
one unary function.
Proposition 6. There is a unary function f such that com-
puting the {ε}-preserving certain answer and the valuation-
preserving certain answer to Boolean queries in UCQ-{f },
on relational databases with or without persistent nulls, is
coNP-hard in data complexity.

For UCQ-F queries, the standard SQL evaluation is poly-
nomial, so it cannot compute any knowledge-preserving no-
tion of certain answers, which may result in counter-intuitive
results on database with nulls. An approach to approximate
certain answers when they are intractable is to build a query
evaluation algorithm with correctness guarantees that runs
in polynomial time.
Deﬁnition 10. Let S and T be database domains, and Q be
a query language. A query evaluation algorithm Eval : Q ×
IS → IT has A-preserving correctness guarantees for Q if,
for every query q ∈ Q, all of the following hold:

T certA(q, x) for every x ∈ IS, and

(a) Eval(q, x) (cid:22)A
(b) Eval(q, c) = q(c) for every c ∈ CS.
In other words, a query evaluation algorithm with correct-
ness guarantees produces answers that are consistent (w.r.t.
the A-preserving information ordering on the target domain)
with the query answers on incomplete databases, and equal
to them on complete databases.

In order to obtain a polynomial-time algorithm, we extend
the idea of naive evaluation on relational database domains
based on a free algebra of terms.

5.2 Relational Databases over Free Algebra
We consider a free algebra of terms T , where the basis of
T is the set Const ∪ Null of constants and (marked) nulls,
and the operations are functions from T × · · · × T to T .
The set of such functions is denoted by Γ. Then, a relational
database is over T if it is populated with elements of T .

Deﬁnition 11. An interpretation ·I of Γ over Const asso-
ciates each γ ∈ Γ of arity k with a function γI : Constk →
Const. The grounding of T under I is the function grd that
maps each t ∈ T to an element of Const ∪ Null ∪ PNull as
follows:

grd(t) =






t
γI(c1, . . . , ck)

(cid:62)grd(t)

if t ∈ Const ∪ Null
if t = γ(t1, . . . , tk) and
ci = grd(ti) ∈ Const
for every i ∈ {1, . . . , k}
otherwise

This naturally extends tables and relational databases over
T . The grounding of a table T is the table grd(T ) with per-
sistent nulls such that, for every tuple ¯t of the same arity as
T , we have:

#(cid:0)grd(T ), ¯t(cid:1) =

(cid:88)

#(T, ¯u)

¯u : grd(¯u)=t

Finally, the grounding of a relational database d over T is
the database grd(d) of the same schema such that, for every
table name R, we have Rgrd(d) = grd(Rd).

A relational database domain D is over the free algebra
T if every database in ID is over T and its grounding be-
longs to CD; in addition,
D uses OWA with the collapsing
(cid:75)
semantics of valuations as deﬁned below.
Deﬁnition 12. For every valuation v : Null → Const and
for every term t = γ(t1, . . . , tk) ∈ T , we let v(t) denote the
term γ(cid:0)v(t1), . . . , v(tk)(cid:1).

·
(cid:74)

The collapsing application of v to a k-ary table T over T
is the k-ary table v(T ) such that, for every ¯t ∈ T k, we have:
#(cid:0)v(T ), ¯t(cid:1) = max(cid:8)#(R, ¯u) | v(¯u) = ¯t(cid:9)
The corresponding OWA semantics of incompleteness is de-
ﬁned as follows:

d
(cid:75)

OWA = {d(cid:48) complete | d(cid:48) ⊇ v(d), v is a valuation}

(cid:74)
We will now use the relational database domain over T to

deﬁne naive evaluation for value-inventing queries.

5.3 Approximation Algorithms for UCQ-F
For the rest of this section, we consider the free algebra of
terms T deﬁned as above, with a set Γ of operations whose
interpretation I over Const is assumed to be computable in
polynomial time. We take F = {γI | γ ∈ Γ} as the set of
functions for UCQ-F queries.
Deﬁnition 13. The interpreted naive evaluation of a UCQ-
F query q is the query qi-naive from incomplete relational
databases to incomplete relational databases over T , where
qi-naive is the standard naive evaluation for relational alge-
bra (i.e., nulls are treated as new constants) and such that,
for every relational database d and for every tuple ¯t of ap-
propriate arity, we have:

• for q = Applyα1,...,αk
i-naive(d), t(cid:1)

(cid:26)#(cid:0)q(cid:48)
0

(γI, q(cid:48)); #(cid:0)qi-naive(d), (¯t, t)(cid:1) is
if t = γ(¯t[α1], . . . , ¯t[αk])
otherwise

• for q = σαi=αj (q(cid:48)); #(cid:0)qi-naive(d), ¯t(cid:1) is

(cid:26)#(q(cid:48)
0

i-naive(d), t)

if grd(¯t[αi]) = grd(¯t[αj])
otherwise

Informally, the interpreted naive evaluation behaves like
the classical naive evaluation for relational algebra, except
that it interprets the free algebra terms when checking for
equality in selections.
Proposition 7. For UCQ-F query q and for every relational
database d, the interpreted naive evaluation of q can be
computed in polynomial time in the size of d.

We have built a polynomial-time evaluation algorithm for
UCQ-F queries on relational database domains over T . In
addition, by means of grounding, we can provide an evalua-
tion algorithm with correctness guarantees.
Theorem 4. The grounding of the interpreted naive evalua-
tion is a query evaluation algorithm with correctness guar-
antees for UCQ-F. Thus, for every query q ∈ UCQ-F and
for every relational database d, we have:

(a) grd(cid:0)qi-naive(d)(cid:1) (cid:22)V
(b) if d is complete, then grd(cid:0)qi-naive(d)(cid:1) = q(d).
We conclude this section with a fully worked-out example

P certV (q, d); and

of how UCQ-F queries are evaluated and grounded.
Example 5. Consider a database D with a relation R =
{(3, 0, 1, 2), (1, ⊥1, 1, ⊥1), (2, ⊥2, ⊥2, 2) over attributes
A, B, C, D, and the following value inventing query q(cid:48):
(cid:0)Apply(C,D)(+, Apply(A,B)(+, R))(cid:1)

π(A+B);(C+D)

where +(c, c(cid:48)) = c + c(cid:48) for every c, c(cid:48) ∈ Const. The naive
evaluation of q(cid:48) on D gives the following answers:

i-naive(D) = q(cid:48)
q(cid:48)

naive(D) =

C + D
A + B
+(3, 0)
+(1, 2)
+(1, ⊥1) +(1, ⊥1)
+(2, ⊥2) +(⊥2, 2)

The naive evaluation of q = σ(A+B)=(C+D)
its grounding are:
qnaive(D)

(cid:0)q(cid:48)(cid:1) on D and

grd(cid:0)qnaive(D)(cid:1)
A + B C + D

(cid:62)i

(cid:62)i

A + B
C + D
+(1, ⊥1) +(1, ⊥1)

These return unsatisfactory answers, because they miss
some complete tuples. Naive evaluation cannot capture the
fact that +(0, 3) = +(1, 2) = 3, as it does not interpret the
function. On the other hand, the interpreted naive evaluation
and its grounding are:

qi-naive(D)

A + B
C + D
+(1, 2)
+(3, 0)
+(1, ⊥1) +(1, ⊥1)

grd(cid:0)qi-naive(D)(cid:1)
A + B C + D

3
(cid:62)j

3
(cid:62)j

The interpreted naive evaluation is able to capture all
complete tuples. It recognizes that constant terms such as
+(3, 0) and +(1, 2) are equal. Moreover, for this query,
the interpreted-naive evaluation captures more tuples than

the certain answers with nulls, but strictly less tuples than
the valuation-preserving certain answers on the relational
database domain with persistent nulls:

cert⊥(q, D)
A + B C + D

3

3

certV (q, D)
A + B C + D

3
(cid:62)j
(cid:62)k

3
(cid:62)j
(cid:62)k

The valuation-preserving certain answer captures more
tuples, because it is able to recognize that +(2, ⊥2) and
+(⊥2, 2) are equal for every valuation.

We have been able to build a polynomial query evaluation
algorithm with correctness guarantee for the applied union
of conjunctive query language UCQ-F. Moreover as illus-
trated in Example 5, there exist queries where the interpreted
naive evaluation algorithm is a strict improvement from the
certain answers with nulls: it returns more certain tuples.

6 Conclusions
A big obstacle in further developing areas where AI tech-
niques, in particular logic-based ones, interact with data
management is understanding notions of query answers over
incomplete data. Indeed, applications such as OBDA, data
integration, data exchange combine reasoning and query an-
swering tasks, but in the end need to rely on database tech-
nology to produce answers. This technology is to be applied
in settings where data is naturally incomplete, by the very
means of its construction. This in turn severely limits the
applicability of the techniques: one typically resorts to con-
junctive queries, or their unions, or a handful of very closely
related classes where we have an understanding of correct-
ness of query answers and an arsenal of techniques for com-
puting those answers.

However, if one looks at real life database queries (e.g., in
standard benchmarks, as those produced by the TPC), there
are very few queries from the classes for which we have
query answering techniques in the presence of incomplete
data. Real-life queries differ in the most basic semantics
of the underlying data model, and in their features, as cru-
cially they invent new values that form part of the output.
For those, we lacked notions of correctness, or certainty, of
query answering.

Our goal here was to remedy this situation by ﬁrst provid-
ing a general framework explaining what correctness is, and
second by showing how it can be applied in some cases that
go well beyond queries that we had known how to handle.
We have done so for the prevalent bag semantics, and for
queries that can invent new values by means, for example,
of arithmetic functions.

The most pressing next question to us is to extend these
techniques to aggregate queries that can produce new val-
ues by applying arithmetic functions to entire columns in
relations. These are extremely common in applications, as
witnessed again by benchmark queries, and theoretical liter-
ature still offers no insight into the notions of correctness of
query answering with aggregates over incomplete data. We
expect techniques presented here to open up new ways of
attacking this long standing open problem.

Hernich, A., and Kolaitis, P. G. 2017. Foundations of in-
formation integration under bag semantics. In LICS, 1–12.
IEEE Computer Society.
Imielinski, T., and Jr., W. L. 1984. Incomplete information
in relational databases. J. ACM 31(4):761–791.
Jr., W. L. 1979. On semantic issues connected with in-
complete information databases. ACM Trans. Database Syst.
4(3):262–296.
Jr., W. L. 1984. On relational algebra with marked nulls. In
PODS, 201–203. ACM.
Kontchakov, R.; Lutz, C.; Toman, D.; Wolter, F.; and Za-
kharyaschev, M. 2011. The combined approach to ontology-
based data access. In IJCAI, 2656–2661. IJCAI/AAAI.
Lenzerini, M. 2002. Data integration: A theoretical perspec-
tive. In PODS, 233–246. ACM.
Libkin, L. 1995. A semantics-based approach to design
of query languages for partial information. In Semantics in
Databases, volume 1358 of Lecture Notes in Computer Sci-
ence, 170–208. Springer.
Libkin, L. 2011.
swers in general data models. In PODS, 59–70. ACM.
Libkin, L. 2016a. Certain answers as objects and knowl-
edge. Artif. Intell. 232:1–19.
Libkin, L. 2016b. Sql’s three-valued logic and certain an-
swers. ACM Trans. Database Syst. 41(1):1:1–1:28.
Poggi, A.; Lembo, D.; Calvanese, D.; Giacomo, G. D.;
Lenzerini, M.; and Rosati, R. 2008. Linking data to on-
tologies. J. Data Semantics 10:133–173.
Rounds, B. 1991. Situation-theoretic aspects of databases.
In Situation Theory and Applications, Volume 2, volume 26
of CSLI Lecture Notes. CSLI Publications. 229–256.
Transaction Processing Performance Council. 2014. TPC
Benchmark™ H Standard Speciﬁcation. Revision 2.17.1.
van der Meyden, R. 1998. Logical approaches to incom-
plete information: A survey. In Logics for Databases and
Information Systems, 307–356. Kluwer.

Incomplete information and certain an-

Acknowledgements

Work partially supported by EPSRC grants M025268 and
N023056, EPSRC Centre for Doctoral Training in Data Sci-
ence, a grant from the Foundation Sciences Math´ematiques
de Paris under the FSMP Chairs program, and the Royal So-
ciety through a Wolfson Research Merit Award.

References

Abiteboul, S.; Segouﬁn, L.; and Vianu, V. 2006. Represent-
ing and querying XML with incomplete information. ACM
Trans. Database Syst. 31(1):208–254.
Amendola, G., and Libkin, L. 2018. Explainable certain
answers. In IJCAI, 1683–1690. ijcai.org.
Arenas, M.; Barcel´o, P.; Libkin, L.; and Murlak, F. 2014.
Foundations of Data Exchange. Cambridge University
Press.
Bertossi, L. E. 2011. Database Repairing and Consistent
Query Answering. Synthesis Lectures on Data Management.
Morgan & Claypool Publishers.
Bienvenu, M., and Ortiz, M. 2015. Ontology-mediated
query answering with data-tractable description logics.
In
Reasoning Web, volume 9203 of Lecture Notes in Computer
Science, 218–307. Springer.
Buneman, P.; Jung, A.; and Ohori, A. 1991. Using power-
domains to generalize relational databases. Theor. Comput.
Sci. 91(1):23–55.
Cal`ı, A.; Lembo, D.; and Rosati, R. 2003. Query rewriting
and answering under constraints in data integration systems.
In IJCAI, 16–21. Morgan Kaufmann.
Codd, E. F. 1979. Extending the database relational model
to capture more meaning. ACM Trans. Database Syst.
4(4):397–434.
Console, M.; Guagliardo, P.; Libkin, L.; and Toussaint, E.
2020. Coping with incomplete data: Recent advances. In
PODS, 33–47. ACM.
Console, M.; Guagliardo, P.; and Libkin, L. 2017. On query-
ing incomplete information in databases under bag seman-
tics. In IJCAI, 993–999. ijcai.org.
Console, M.; Guagliardo, P.; and Libkin, L. 2019. Frag-
ments of bag relational algebra: Expressiveness and certain
answers. In ICDT, volume 127 of LIPIcs, 8:1–8:16. Schloss
Dagstuhl - Leibniz-Zentrum f¨ur Informatik.
Franconi, E., and Tessaris, S. 2012. On the logic of SQL
nulls. In AMW, volume 866 of CEUR Workshop Proceed-
ings, 114–128. CEUR-WS.org.
Grahne, G. 1991. The Problem of Incomplete Information
in Relational Databases, volume 554 of Lecture Notes in
Computer Science. Springer.
Grant, J. 1977. Null values in a relational data base. Inf.
Process. Lett. 6(5):156–157.
Guagliardo, P., and Libkin, L. 2016. Making SQL queries
correct on incomplete databases: A feasibility study.
In
PODS, 211–223. ACM.

