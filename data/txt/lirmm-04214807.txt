Testing Logical Diagrams in Power Plants: A Tale
of LTL Model Checking
Aziz Sfar, David Carral, Dina Irofti, Madalina Croitoru

To cite this version:

Aziz Sfar, David Carral, Dina Irofti, Madalina Croitoru. Testing Logical Diagrams in Power Plants:
A Tale of LTL Model Checking. FMICS 2023 - Formal Methods for Industrial Critical Systems, Sep
2023, Antwerp, Netherlands. pp.189-204, ￿10.1007/978-3-031-43681-9_11￿. ￿lirmm-04214807￿

HAL Id: lirmm-04214807

https://hal-lirmm.ccsd.cnrs.fr/lirmm-04214807

Submitted on 22 Sep 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Testing Logical Diagrams in power plants: a tale
of LTL model checking

Aziz Sfar1,2[0000−0003−0359−0600], David Carral1[0000−0001−7287−4709], Dina
Irofti2[0000−0002−9254−7980], and Madalina Croitoru1[0000−0001−5456−7684]

1 LIRMM, Inria, University of Montpellier, CNRS, Montpellier, France
2 EDF R&D, France

Abstract. In this paper, we focus on the application of LTL (Linear
Temporal Logic) model checking on logical diagrams (LD), which are a
type of functional specification used for logical controllers in many nu-
clear power plants. The goal is to check properties on LDs and to generate
counter examples serving as validation tests for logical controllers. We
propose a sound and complete LTL encoding framework for LDs allowing
the use of model checking (MC) and evaluate different MC techniques
on real world LD to efficiently generate counterexamples for verifiable
properties.

Keywords: Validation tests · Symbolic Model Checking · Linear Tem-
poral Logic.

1

Introduction

We place ourselves in an applicative setting of the EDF company (French Elec-
tricity) where the behavior of Programmable Logical Controllers (PLC) used for
nuclear power plants is periodically updated and tested manually within expert
defined functional validation scenarios. A PLC is a system that embeds a pro-
gram running control and protection functions. In a critical domain like nuclear
energy production, the behavior of PLCs have to satisfy strict performance and
safety requirements. Therefore, during the life-cycle of nuclear reactors, several
updates are introduced to the PLC programs to keep up with last requirements
defined by nuclear authorities. The updated behavior has to be validated by
testing it against its functional specifications to ensure that no functional errors
were generated following the modification process.

In the case of our application, the functional specifications of the behavior
of PLCs are given in the form of Logical Diagrams (LD). These are graphical
representations of a number of inputs and outputs connected through different
types of logical blocks defining the expected behaviour of the machine (PLC).
In a nuclear power plant, the number and size of LDs used as specifications for
PLCs is enormous which makes the manual generation of test scenarios, as it
is today, a tedious and time consuming task. Moreover, a Logical Diagram may
contain feedback connections, i.e a number of blocks connected to each other in a
loop, which could lead to cyclic behavior. This is a situation where one or many

2

F. Author et al.

outputs keep changing indefinitely without any change on the inputs making the
specified behavior divergent.

In this paper, we address the problem of the stability property verification
(i.e. absence of cyclic behaviour) on the Logical Diagrams and the generation
of validation test cases for PLCs. Several works propose the transformation of
the PLC description languages into formal representations like finite state mod-
els and timed automata to make use of the already existing tools and methods
for test generation. For instance, Provost et al. [11] have proposed a translation
of Grafcet specification models into Mealy machines to generate conformance
test scenarios. In a previous work [12] inspired from [11], we have introduced a
transformation of Logical Diagrams into state/transition graphs. The aim was
to make use of the test generation techniques for transition systems as presented
in [10] and [13] as well as the formal verification techniques to prove stability in
Logical Diagrams. However, the exponential growth of the size of the generated
transition systems makes their generation complicated for the biggest sized LDs.
In [8], model-checking techniques were used to generate tests for PLC programs
developed in Function Block Diagram (FBD). The paper describes the transfor-
mation of FBDs into timed automata and the use of a Model-Checker to generate
test sequences. An experimental evaluation of their solution was made for many
train control systems programs. However, to the authors knowledge, no similar
approach was done for PLCs based on LD specifications used in nuclear power
plants. In this paper, we propose to automatise the checking process of PLC be-
haviour specified in Logical Diagrams using tools from the Model Checking (MC )
domain. We define a sound and complete transformation of Logical Diagrams
into Linear Temporal Logic (LTL) formulas. We demonstrate how the stability
property can be expressed into LTL expressions. We also show how test cases
could be generated by formulating properties like the activation and deactivation
of the outputs of the system in an LTL encoding and running Model-checkers
on them. Finally, we empirically evaluate the efficiency of existing MC tools
(NuSMV [5] and nuXmv [3]) on EDF logical diagrams. The empirical results
obtained show that techniques like k-MC [6] is useful for checking the stability
property while other techniques (BDD [7], BMC [1] and SBMC [9]) are timing
out. The counterexample generation for activation and deactivation of outputs
is possible for all techniques except BDD. We believe that the overview of the
practical usability of LTL Model Checking tools for our real world scenario could
be of use to researchers undergoing similar tasks (e.g. LTL encoding and LTL
Model Checking for test generation).

This paper is organized as follows. In section 2 we set a formal definition of
the Logical Diagram specification and we give an example. Section 3 introduces
the LTL formalism and presents the LTL encoding of the logical diagram and
the stability, activation and deactivation properties. Proof of the soundness and
completeness of the transformation is given in section 4. Finally, section 5 dis-
cusses the application and evaluation of Model-Checking tools and techniques
on our Logical Diagrams.

Testing Logical Diagrams in power plants: a tale of LTL model checking

3

2 Logical Diagram

A logical diagram (LD) is a graphical representation of a set of interconnected
blocks that perform logical functions. Before running a code implementing the
logical diagram on a controller, a few properties of the logical diagram have to
be studied. One of these properties is the stability property ensuring that the
outputs of the logical diagram converge for some fixed inputs. Moreover, in order
to test the implementation of a logical diagram on a controller, we would like to
be able to generate input values, that allow to activate or deactivate a chosen
output. Thus, we need to define the properties of activation and deactivation
of outputs and use these properties in the verification and validation (V&V)
process to validate the correct implementation of the logical diagram on the
logical controller. In this section, we introduce a formal definition for logical
diagrams and the properties of stability, activation and deactivation of outputs,
and we illustrate them on the logical diagram in Figure 1.

Fig. 1. A logical diagram example LD = ⟨V, E, O⟩: V (input) = {i1, i2, i3}, V (output) =
s−→ m2, v r−→
{o1, o2}, V (ME) = {m1, m2}, V (and) = {v}, E = {i1
m2, i3 → v, m2 → v, m1 → o1, m2 → o2}, O(m1) = 1 and O(m2) = 2.

r−→ m1, m1

s−→ m1, i2

A logical diagram is formally defined by a set of vertices V , and a set of
directed edges E connecting these vertices. Every vertex v ∈ V has a type that
defines the number and nature of its incoming and outgoing edges as formally
defined in Def. 1. Output vertices are denoted by V (output), input vertices by
V (input), memory vertices by V (M) and finally vertices of the type ‘and ’, ‘or ’
and ‘not’ are denoted V (and), V (or) and V (not), respectively. In a logical dia-
gram, we can find cycles. A cycle is a sequence of edges that starts and finishes
at the same vertex v. In the diagrams used by EDF all cycles contain at least
one memory vertex within the sequence. Consider the example of Figure 1: it
contains three input vertices i1, i2 and i3, two output vertices o1 and o2, two
memory vertices m1 and m2, one vertex v of type ’and’ and one cycle composed
of v and m2. Note that the memory vertices are represented in the diagram by
set/reset (RS) blocks that have two inputs: E for set and H for reset. In the case
s−→ m1
of m1, the incoming edge corresponding to the set is represented by i1

i1i2i3m1m2vo1o2order: ( m1, m2 )4

F. Author et al.

r−→ m1 represents the reset edge. The incoming edges of the other vertices
while i2
types is given by a simple arrow as in i3 → v. The letter ’p’ in ’Hp’ indicates
that reset has priority over set. Then, we denote MH as the type of the memory
vertex. This is the case for both m1 and m2. Otherwise, the memory vertex is
of type ME with the priority expressed by ’Ep’ in the set input of the block.

Definition 1 (Vertex type and LD). The set of vertex types is {input,
output, and, or, not, ME, MH }. Henceforth, we associate every vertex v with a
vertex type tp(v). Given a set V of vertices and a vertex type t, let V (t) = {v ∈
V | tp(v) = t}. Moreover, let V (M) = V (ME) ∪ V (MH ). Moreover, a directed
edge over V is an expression of the form u → v, u s−→ v, or u r−→ v with u, v ∈ V .
A logical diagram (LD) is a tuple ⟨V, E, O⟩ such that V is a set of vertices, E
is a set of directed edges (over V ), O is a bijection from V (M) to {1, . . . , |V (M)|},
and all of the following hold:

1. If u → v ∈ E for some u, v ∈ V ; then tp(v) is output, and, or, or not.
2. If u s−→ v or u r−→ v are in E for some u, v ∈ V , then tp(v) is ME or MH .
3. For every v ∈ V (not) ∪ V (output), there is exactly one edge of the form

u → v ∈ E.

4. For every v ∈ V (and) ∪ V (or), there are at least two edges of the form

u → v ∈ E.

5. For every v ∈ V (M), there is exactly one edge of the form u s−→ v ∈ E and

exactly one edge of the form w r−→ v ∈ E.

6. For every v1, . . . , vn ∈ V , either vn → v1 /∈ E or vi−1 → vi /∈ E for some
2 ≤ i ≤ n. That is, every cycle have to traverse at least one memory vertex.

Each vertex in a logical diagram has an associated logical value called the
output of the vertex. It takes the value true referred to by ⊤ or false referred to
by ⊥. Furthermore, the vertex output is evaluated in accordance to increasing
time steps and can vary from a step to another. The time step k starts at zero.
Initially, i.e. at k = 0, output values of memory and input vertices are given
by an initializing function f . Then, the output value of every vertex v at a
time step k ≥ 0, is defined by the function LDf (v, k). Specifically, the output
of memory vertices are evaluated one after the other according to an evaluation
order specified by the function O. The output value of only one memory vertex
can change at each time step if it is its turn, while the others maintain the same
value from the previous step. Note that the output of a memory vertex of type
ME (resp. MH ) is evaluated to True, denoted ⊤, (resp. False, denoted ⊥), when
both set and reset inputs are evaluated to True. The complete output evaluation
for different vertices types is given by Def. 3.

Definition 2 (ev function). The set B of Boolean expressions is defined by
the grammar B ::= ⊤ | ⊥ | ¬B | B ∧ B | B ∨ B. We define ev : B (cid:55)→ {⊤, ⊥} such
that for every a, b ∈ B:

– ev(⊤) = ⊤.
– ev(⊥) = ⊥.

Testing Logical Diagrams in power plants: a tale of LTL model checking

5

– ev(¬a) = ⊤ iff ev(a) = ⊥.
– ev(a ∨ b) = ⊤ iff ev(a) = ⊤ or ev(b) = ⊤.
– ev(a ∧ b) = ⊤ iff ev(a) = ⊤ and ev(b) = ⊤.

Definition 3 (Output function). Consider a diagram LD = ⟨V, E, O⟩ and
an initializing function f for LD; that is, a total function from V (input) ∪ V (M)
to {⊤, ⊥}. For every vertex v ∈ V (M), let turnO(v) be the set that contains
O(v) + n · |V (M)| for every n ≥ 0. Also, for every v ∈ V and k ≥ 0, we define
LDf (v, k) ∈ {⊤, ⊥} as follows:

– If v ∈ V (input), then LDf (v, k) = f(v).
– If v ∈ V (output), then LDf (v, k) = ev(LDf (u, k)) where u is the vertex in V

with u → v ∈ E.

– If v ∈ V (not), then LDf (v, k) = ev(¬LDf (u, k)) where u is the vertex with

u → v ∈ E.

– If v ∈ V (or), then LDf (v, k) = ev((cid:87)

u∈P LDf (u, k)) where P = {u ∈ V | u →

– If v ∈ V (and), then LDf (v, k) = ev((cid:86)

u∈P LDf (u, k)) where P = {u ∈ V |

v ∈ E}.

u → v ∈ E}.

– If v ∈ V (M) and k = 0, then LDf (v, k) = f (v).
– If v ∈ V (M), k ≥ 1, and k /∈ turnO(v) then LDf (v, k) = LDf (v, k − 1).
– If v ∈ V (M) and k ∈ turnO(v), we consider two cases:

• If tp(v) = ME, then LDf (v, k) = ev((LDf (v, k − 1) ∧ ¬LDf (h, k − 1)) ∨

LDf (e, k − 1)).

• If tp(v) = MH , then LDf (v, k) = ev(¬LDf (h, k − 1) ∧ (LDf (v, k − 1) ∨

LDf (e, k − 1))).

In the above, h ∈ V with h r−→ v ∈ E and e ∈ V with e s−→ v ∈ E.

In the example of Figure 1, the evaluation order of LD is O(m1) = 1 and
O(m2) = 2. The output function LDf depends on this evaluation order as well
as the initializing function as established in Def. 3. Note that input vertices
maintain the value given to them in the initial step.

Thus far, we have defined the different elements composing a logical diagram
and the output evaluation function. We define in the sequel the properties of
stability, activation and deactivation of outputs. For the stability property, we
want to make sure that in some future time step k, the output values of vertices
converge. In other words, having an initializing function f , the logical output
value of every vertex should not oscillate indefinitely between the values true
and false, from a step to the next. For this to be avoided, it suffices that the
outputs of memory vertices converge as mentioned in Def. 4. In this case, we
say that the logical diagram is stable for the initializing function f . We also say
that a logical diagram is uniformly stable if it is stable for every possible input
scenario, i.e. for every initializing function f .

Definition 4 (stability). A logical diagram LD = ⟨V, E, O⟩ is stable for some
initializing function f , if there exists k′ ≥ 0 such that for every k ≥ k′ and
v ∈ V (M), we have LDf (v, k) = LDf (v, k + 1). We say that a logical Diagram
LD is uniformly stable if it is stable for every initializing function f .

6

F. Author et al.

To illustrate, we consider the initializing function f (i1) = ⊤, f (i2) = ⊥, f (i3) =
⊤, f (m1) = ⊥ and f (m2) = ⊥ for the logical diagram of Figure 1. By applying
the evaluation function on the memory vertex m2, we can see that LDf (m2, k)
is not equal to LDf (m2, k + 2) for every k ≥ 0. Therefore, LD is not stable for
f . Hence LD is not uniformly stable.

Once the stability is verified, the next step consists in generating initializing
functions that allow to set to true (i.e activate) or set to false (i.e deactivate) an
output vertex o. It is also possible to set some initial conditions over the input
and output values before generating scenarios. We look to answer questions like:
is there an initializing function f that eventually activates an output o, when
initially, o is deactivated (i.e. LDf (o, 0) = ⊥) and the input i is activated (i.e.
LDf (i, 0) = ⊤). The chosen initial conditions are given by an initial configuration
function confS setting the initial values of a set of vertices S ⊆ V (output) ∪
V (input). Then, we say that the output o is activated (resp. deactivated) for an
initializing function f , if f satisfies the initial configuration confS , and grants
the activation (resp. deactivation) of o in some future step k (as per Def. 5).

Definition 5. Consider a logical diagram LD = ⟨V, E, O⟩ and an initial con-
figuration function confS ; that is a function from S ⊆ V (input) ∪ V (output)
to {⊤, ⊥}. An output vertex o ∈ V (output) is activated (resp. deactivated )
for some initial configuration confS , if there is an initializing function f and
k′ ≥ 0 such that; for every v ∈ S, LDf (v, 0) = confS (v) and for every k ≥ k′,
LDf (o, k) = ⊤ (resp. LDf (o, k) = ⊥).

Consider for instance the logical diagram of Figure 1, the set S = {o1, o2}
and the initial configuration confS (o1) = ⊥ and confS (o2) = ⊥. Let f1 be an
initializing function such that f1(i1) = ⊤, f1(i2) = ⊥, f1(i3) = ⊥, f1(m1) = ⊥
and f1(m2) = ⊥. By Def. 3, we have LDf (o1, 0) = ⊥, LDf (o2, 0) = ⊥ and
LDf (o2, k) = ⊤ for every k ≥ 2. Therefore, o2 is activated for f1.

3 LTL encoding of logical diagrams

In this section, we propose an encoding framework of the logical diagrams and
properties into a set of Linear Temporal Logic (LTL) formulas. An LTL formula is
built up from a set of propositional variables AP and a set of logical and temporal
operators. The set L of LTL formulas is defined by the following grammar:
L ::= p | ⊤ | ⊥ | ¬L | L ∧ L | L ∨ L | L → L | L ↔ L | ⃝L | □L | ♢L where
p ∈ AP . A word W is a sequence s0, s1, . . . of subsets of AP. Each element si of
the sequence is referred to by ⟨W, i⟩. Given a word W, a propositional variable
p, two LTL formulas φ and ψ, and some i ≥ 0; we write:

– ⟨W, i⟩ |= p iff p ∈ si.
– ⟨W, i⟩ |= ⊤.
– ⟨W, i⟩ ⊭⊥.
– ⟨W, i⟩ |= ¬φ iff ⟨W, i⟩ ⊭ φ.
– ⟨W, i⟩ |= φ ∧ ψ iff ⟨W, i⟩ |= φ and ⟨W, i⟩ |= ψ.

Testing Logical Diagrams in power plants: a tale of LTL model checking

7

– ⟨W, i⟩ |= φ ∨ ψ iff ⟨W, i⟩ |= φ or ⟨W, i⟩ |= ψ.
– ⟨W, i⟩ |= φ → ψ iff ⟨W, i⟩ |= ¬φ ∨ ψ.
– ⟨W, i⟩ |= φ ↔ ψ iff ⟨W, i⟩ |= (ψ → φ) ∧ (φ → ψ).
– ⟨W, i⟩ |= ⃝φ iff ⟨M, i + 1⟩ |= φ.
– ⟨W, i⟩ |= ♢φ iff ⟨M, j⟩ |= φ for some j ≥ i.
– ⟨W, i⟩ |= □φ iff ⟨M, j⟩ |= φ for every j ≥ i.

We say that a word W satisfies an LTL formula Φ at a time step i and we write
⟨M, i⟩ |= Φ. Moreover, W is a model of Φ (W |= Φ) if W satisfies Φ at the time
step 0. An LTL theory is a defined finite set of LTL formulas. A word W is a
model of an LTL theory T if it is a model of every formula Φ ∈ T . An LTL
theory T1 entails another theory T2 (T1 |= T2) when every model of T1 is also a
model of T2.

3.1

LTL encoding of logical diagrams and initializing functions

We introduce a sound and complete LTL encoding of logical diagrams. The
encoding will be given in two LTL theories. The first, denoted TLD, encodes
the vertices, edges and characteristics of a logical diagram LD; the second Tf
encodes the initial output values given by an initializing function f .

Let LD = ⟨V, E, O⟩ be a logical diagram. We define the LTL vocabulary
APLD of propositional variables: we associate to every vertex v ∈ V a propo-
sitional variable tv and to each number i ≥ 1 a variable ti. The set APLD
is composed of these tv and ti. Then, the LTL theory TLD contains an LTL
formula for every vertex v ∈ V . This formula represents the output function
of v at every time step. On the logical diagram of Figure 1, the LTL theory
TLD of our example contains the formulas {□(to1 ↔ tm1), □(to2 ↔ tm2)} for
the vertices o1 and o2, the formula □(tv ↔ ti3 ∧ tm2) for the vertex v, and
{□(⃝tm1 ↔ ((¬t1 ∧ tm1) ∨ (t1 ∧ ¬ti2 ∧ (tm1 ∨ ti1)))),
□(⃝tm2 ↔ ((¬t2 ∧ tm2 ) ∨ (t2 ∧ ¬tv ∧ (tm2 ∨ tm1))))} for the vertices m1 and
m2. In the last two formulas, the variable t1 indicates the evaluation turn of
m1, and likewise with t2 and m2. Therefore, we add to TLD the formulas that
translate the ordered evaluation of memory vertices. We construct these for-
mulas in a way that ensures that tO(v) is exclusively true at the time steps
dedicated for the evaluation of the memory vertex v according to O(v). For
the logical diagram LD in Fig. 1, we add to TLD the set of LTL formulas :
{(t1 ∧ ¬t2), □(t1 ↔ ⃝(¬t1 ∧ t2)), □(t2 ↔ ⃝(¬t2 ∧ t1))}. Finally, we add to
TLD the set of formulas that translate the fact that input vertices of the logical
diagram keep the same values assigned to them in the initial time step. We do
this by adding the LTL formula (□tv ∨ □¬tv) for every vertex v ∈ V (input).
The formulas {(□ti1 ∨ □¬ti1), (□ti2 ∨ □¬ti2 ), (□ti3 ∨ □¬ti3)} belong therefore
to the theory TLD of previous example. The full definition of TLD is established
in Def. 6

Definition 6 (TLD). The set of propositional variables APLD contains a vari-
able tv for every v ∈ V and a variable ti for every i ≥ 1. Consider a logical

8

F. Author et al.

i∈{1,...,|V (M)|−1}

i∈{2,...,|V (M)|} ¬ti).

□(ti ↔ ⃝(¬ti ∧ ti+1)).

diagram LD = ⟨V, E, O⟩ and some initializing function f . We define the TLD,
the LTL theory over APLD that contains all the following formulas :
– (t1 ∧ (cid:86)
– (cid:86)
– □(t|V (M)| ↔ ⃝(¬t|V (M)| ∧ t1)) ).
– For every v ∈ V (input), add (□tv ∨ □¬tv).
– For every v ∈ V (output), add □(tu ↔ tv) where u ∈ V with u → v ∈ E.
– For every v ∈ V (not), add □(tu ↔ ¬tv) where u ∈ V with u → v ∈ E.
– For every v ∈ V (or), add □(tv ↔ (cid:87)
– For every v ∈ V (and), add □(tv ↔ (cid:86)
– if tp(v) = ME, then add

u∈P tu) where P = {u | u → v ∈ E}.

u∈P tu) where P = {u | u → v ∈ E}.

(cid:16)

□

⃝ tv ↔ (cid:0)(¬tO(v) ∧ tv) ∨ (tO(v) ∧ ((tv ∧ ¬th) ∨ te))(cid:1)(cid:17)

– if tp(v) = MH with i = O(v), then:

(cid:16)

□

⃝ tv ↔ (cid:0)(¬tO(v) ∧ tv) ∨ (tO(v) ∧ ¬th ∧ (tv ∨ te))(cid:1)(cid:17)

In the above, h is the vertex with h r−→ v ∈ E and e is the vertex with e s−→ v ∈ E.

Let us now consider some initializing function f . The second LTL encoding is
given by the LTL theory Tf that contains, for every vertex v ∈ V (input) ∪ V (M),
the LTL formula (tv ↔ f (v)).

Definition 7 (Tf ). Consider some initiliazing function f for a logical diagram
LD = ⟨V, E, O⟩. Then, let Tf be the LTL theory over APLD such that (tv ↔
f (v)) ∈ Tf for every v ∈ V (input) ∪ V (M).

Consider a word W that is a model of the LTL encoding TLD of a logical diagram
LD and Tf of an initializing function f . At each time step k, W satisfies the
variables tv of the vertices v whose outputs LDf (v, k) are evaluated to True. In
other words, the proposed LTL encoding is sound and complete as stated by
Theorem 1 proven in section 4.

Theorem 1. Consider a logical diagram LD = ⟨V, E, O⟩, some initializing func-
tion f , and the LTL theories TLD and Tf . Let W |= TLD ∪ Tf . Then for every
v ∈ V and k ≥ 0, LDf (v, k) = ⊤ ⇔ ⟨W, k⟩ |= tv, where tv ∈ APLD.

3.2

LTL encoding of properties

In section 2, three types of properties were defined for logical diagrams. Here,
we introduce an LTL theory for each different property. We first specify the LTL
theory Tstable for the stability property. Then, we define the LTL theories T o
act
and T o
deact, respectively for the activation and deactivation properties.

Let us consider a logical diagram LD = ⟨V, E, O⟩ and an initializing function
f . The stability of LD is satisfied if in some future the output values of all

Testing Logical Diagrams in power plants: a tale of LTL model checking

9

the memory vertices remain unchanged. This can easily be expressed using the
temporal operators offered by LTL. We encode the stability property of a logical
diagram in the LTL theory Tstable that contains the formula ♢(□tv ∨ □¬tv)
for every v ∈ V (M). Using the LTL encoding, we can establish whether or
not a logical diagram is stable. In fact, if the model W of the theories TLD
and Tf is also a model of Tstable, then the logical diagram LD is stable for
f as stated in Theorem 2. In the case of the logical diagram of Figure 1, let
f1 be an initializing function such that f1(i1) = ⊤, f1(i2) = ⊥, f1(i3) = ⊤,
f1(m1) = ⊥ and f1(m2) = ⊥. Then, Tf1 = {ti1 ↔ ⊤, ti2 ↔ ⊥, ti3 ↔ ⊤, tm1 ↔ ⊥,
tm2 ↔ ⊥}. The LTL encoding of the stability property is Tstable = {♢(□tm1 ∨
□¬tm1), ♢(□tm2 ∨□¬tm2 )}. The LTL model checking proves that the satisfaction
relation TLD ∪ Tf1 |= Tstable is false. Therefore, we conclude that the logical
diagram is not stable for the initializing function f1. This also means that LD
is not uniformly stable.

Theorem 2. Consider a logical diagram LD = ⟨V, E, O⟩, some initializing func-
tion f , and the LTL theories TLD, Tf and Tstable. Then, LD is stable for f if
TLD ∪ Tf |= Tstable. The logical diagram is uniformly stable if TLD |= Tstable.

We next encode the activation and deactivation properties. Let o ∈ V (output)
be an output vertex and S a subset of vertices. The LTL theory T o
act represents
the activation property of o for an initial configuration confS . For every vertex
v ∈ S, it contains the formula (tv ↔ confS (v)) which translates the initial con-
figuration. It also contains the formula (♢□to) that translates the activation of
the output o in some future. Likewise, the LTL theory T o
deact that encodes the
deactivation property of the output vertex o for the initial configuration confS ,
contains the formulas (♢□¬to) and (v ↔ confS (v)), for every v ∈ S. Theorem 3
states that the satisfaction of the LTL theory TLD and the theories of the acti-
vation and deactivation properties means that the encoded logical diagram also
satisfies these properties. For the illustration example of Figure 1, consider the
subset of vertices S = {o1, o2} and the initial configuration confS (o1) = ⊥ and
confS (o2) = ⊥. The activation property encoding for the output vertex o2 is
T o2
act = {(to1 ↔ ⊥), (to2 ↔ ⊥), ♢□to2 }. We are looking to find some initializ-
ing function f1 such that TLD ∪ Tf1 |= T o2
act. In order to do so, we run an LTL
model checking on the formula TLD ∪ T o2
act |= ⊥. Using a BDD based model
checking algorithm [7], the property is declared as false with the counterexam-
ple W |= TLD ∪ Tf1 ∪ T o2
act where f1(i1) = ⊤, f1(i2) = ⊥, f1(i3) = ⊥, f1(m1) = ⊥
and f1(m2) = ⊥. The output o2 is therefore activated for f1.
Theorem 3. Consider a logical diagram LD = ⟨V, E, O⟩ and the LTL theory
TLD. An output vertex o ∈ V (output) is activated (resp. deactivated) for some
initial configuration confS , if there is an initializing function f such that TLD ∪
Tf |= T o

act (resp. TLD ∪ Tf |= T o

deact).

4 Proofs

In this section we include the proof of Theorem 1. Lines will be enumerated for
readability purposes and to make it easier to refer to different elements of the

10

F. Author et al.

proof. The proof of Theorem 1 is established on three steps (A), (B) and (C).
Moreover, we introduce and prove the following auxiliary lemma, which is later
used for the proof of (C).

Lemma 1. Consider a logical diagram LD = ⟨V, E, O⟩, and the LTL theory
TLD. Let W |= TLD and v ∈ V (M) then, for every k ≥ 1 ⟨W, k − 1⟩ |= tO(v) iff
k ∈ turnO(v).

Proof. Proof of Lemma 1.

1. Let LD = ⟨V, E, O⟩ be a logical diagram and TLD be the corresponding LTL

theory over APLD.

2. Let W be a word such that W |= TLD.
3. We prove the following by induction: if k ∈ turnO(v) then ⟨W, k − 1⟩ |= tO(v)

for every k ≥ 1.

4. We prove the statement for the base case: k=1.

4.a By Def. 3, we have k = 1 ∈ turnO(v) where v ∈ V (M) and O(v) = 1.
4.b By Def 6, we have ⟨W, 0⟩ |= t1.
4.c Based on 4.a and 4.b, the statement 3 holds for k = 1.

5. We assume that the statement in 3 holds for some k ≥ 1. We then prove

that it also holds for k + 1 and v ∈ V (M).

6. Let k ≥ 1 where k + 1 ∈ turnO(v). We prove that ⟨W, k⟩ |= tO(v).
7. If O(v) ∈ {2 . . . |V (M)|}:

7.a As established in 6, k +1 ∈ turnO(v). Then by Def 3, k ∈ turnO(w) where

w ∈ V (M) and O(w) = O(v) − 1.

7.b By 5 and 7.a, we conclude that ⟨W, k − 1⟩ |= tO(v)−1.
7.c By Def. 6 we have W |= (cid:86)
7.d Based on 7.c, ⟨W, k − 1⟩ |= (tO(v)−1 ↔ ⃝(¬tO(v)−1 ∧ tO(v))).
7.e From 7.b and 7.d we conclude that ⟨W, k⟩ |= tO(v). Thus, the statement

□(ti ↔ ⃝(¬ti ∧ ti+1)).

i∈{1,...,|V (M)|−1}

3 is true for k + 1.

8. Like in 7, we use 5, Def 3 and Def 6 to prove that 3 also holds when O(v) = 1.
9. Based on 7.e and 8, the statement 3 holds for k + 1. Consequently, for every

k ≥ 1, if k ∈ turnO(v) then ⟨W, k − 1⟩ |= tO(v).

10. Next, we prove the following by induction: for k ≥ 1, if ⟨W, k − 1⟩ |= tO(v)

then k ∈ turnO(v).

11. We prove the statement 10 for the base case: k = 1.

11.a By Def. 6 we have W |= (t1 ∧ (cid:86)
i∈{2,...,|V (M)|} ¬ti). Thus, ⟨W, 0⟩ |= t1.
11.b By Def. 3, we have k = 1 ∈ turnO(v) where v ∈ V (M) and O(v) = 1.
11.c Based on 11.a and 11.b, the statement 10 holds for k = 1.

12. We now assume that the statement 10 holds for some k ≥ 1. We prove that

it also holds for k + 1.

13. Let v ∈ V (M). Assuming that ⟨M, k⟩ |= tO(v), we prove that k+1 ∈ turnO(v).
14. If O(v) ∈ {2 . . . |V (M)| − 1}:

14.a By Def. 6 we have W |= (cid:86)
□(ti ↔ ⃝(¬ti ∧ ti+1)).
14.b Based on 14.a we have: ⟨W, k⟩ |= (tO(v) ↔ ⃝(¬tO(v) ∧ tO(v)+1)).
14.c By 13 we know that ⟨M, k⟩ |= tO(v). Therefore, based on 14.b we have

i∈{1,...,|V (M)|−1}

⟨M, k + 1⟩ |= tO(v)+1 and ⟨M, k + 1⟩ ⊭ tO(v).

Testing Logical Diagrams in power plants: a tale of LTL model checking

11

14.d Based on 14.a, we have ⟨W, k⟩ |= (tO(v)−1 ↔ ⃝(¬tO(v)−1 ∧ tO(v)))
14.e From 14.c we have ⟨M, k + 1⟩ ⊭ tO(v). Thus, based on 14.d we conclude

that ⟨M, k⟩ ⊭ tO(v)−1.

14.f Based on 14.a, we have ⟨W, k − 1⟩ |= (tO(v)−1 ↔ ⃝(¬tO(v)−1 ∧ tO(v))).
14.g From 13 and 14.e we have ⟨M, k⟩ |= tO(v) and ⟨M, k⟩ ⊭ tO(v)−1. Thus,

by 14.f ⟨M, k − 1⟩ |= tO(v)−1.

14.h As per 12, the statement 10 holds for k. By 14.g, ⟨M, k − 1⟩ |= tO(v)−1.

Thus, k ∈ turnO(w) where w ∈ V (M) and O(w) = O(v) − 1.

14.i Based on 14.h and Def. 3 we conclude that k + 1 ∈ turnO(v). The state-

ment 10 is therefore true for k + 1 as per 13.

15. Like in 14, we use 12 and Def 6 to prove that statement 10 also holds when

O(v) = 1 and O(v) = |V (M)|.

16. Based on 14.i and 15, the statement 10 holds for k + 1. Consequently, for

every k ≥ 1, if ⟨W, k − 1⟩ |= tO(v) then k ∈ turnO(v).

17. Conclusion: By 9 and 16 we conclude that Lemma 1 is true.

Next, we give the proof of Theorem 1. Consider a logical diagram LD = ⟨V, E, O⟩,
some initializing function f , and a word W |= TLD ∪ Tf ; we prove the following:
LDf (v, k) = ⊤ ⇔ ⟨W, k⟩ |= tv where tv ∈ APLD

(A) for every v ∈ V (input) and k ≥ 0,
(B) for every v ∈ V and k = 0 ,
(C) for every v ∈ V and k ≥ 1 .

Proof. Proof of Theorem 1 part (A): v ∈ V (input) and k ≥ 0.

18. Consider a logical diagram LD = ⟨V, E, O⟩ and an initializing function f .
The LTL theories are TLD and Tf . Let W |= TLD ∪ Tf . Let v ∈ V (input).

19. By Def. 3 we have LDf (v, k) = ⊤ iff f (v) = ⊤ for every k ≥ 0.
20. By Def. 6 we have W |= (□tv ∨□¬tv) and by Def. 7, ⟨M, 0⟩ |= tv iff f (v) = ⊤.

Thus, ⟨M, k⟩ |= tv iff f (v) = ⊤ for every k ≥ 0.

21. By 19 and 20 we conclude that Theorem 1 holds for v ∈ V (input) and k ≥ 0.

Proof. Proof of Theorem 1 part (B): v ∈ V and k = 0.

22. Consider a logical diagram LD = ⟨V, E, O⟩ and an initializing function f

and the LTL theories TLD and Tf . Let W |= TLD ∪ Tf and v ∈ V .

23. We assume that v ∈ V (M).
24. Based on Def. 3, we have LDf (v, 0) = ⊤ iff f (v) = ⊤.
25. By Def. 7, ⟨W, 0⟩ |= tv ↔ f (v). Consequently, ⟨W, 0⟩ |= tv iff f (v) = ⊤.
26. Based on 24 and 25 we conclude that LDf (v, 0) = ⊤ iff ⟨W, 0⟩ |= tv. Thus,

the theorem holds for k = 0 and for every v ∈ V (M).

27. Let s be a sequence of vertices s = v0, . . . , vn ∈ V with vi → vi+1 ∈ E
for every i ∈ 0, . . . , n − 1 and u → v0 /∈ E for every u ∈ V . From Def. 1,
we prove that v0 ∈ V (input) ∪ V (M). We define the position of a vertex v
in a logical diagram as follows: if v ∈ V (input) ∪ V (M) then pos(v) = 0.
Otherwise, pos(v) = max({pos(u) | u → v ∈ E}) + 1.

28. We prove Theorem 1 for v ∈ V (not) ∪ V (or) ∪ V (and) ∪ V (output) and k = 0.

12

F. Author et al.

29. We use the proof by induction. Base case: pos(v) = 1.
30. We assume that v ∈ V (output) and u → v ∈ E:

30.a By Def. 3, we have LDf (v, 0) = ev(LDf (u, 0)).
30.b By Def. 6, we have W |= □(tu ↔ tv). Thus, ⟨W, 0⟩ |= tv iff ⟨W, 0⟩ |= tu.
30.c As per 27, we have pos(u) = 0 and u ∈ V (input) ∪ V (M).
30.d As stated in (A) and 26, the theorem is true for k = 0 and for every

w ∈ V (input) ∪ V (M).

30.e By 30.c and 30.d we have ⟨W, 0⟩ |= tu iff LDf (u, 0) = ⊤.
30.f From 30.a, 30.b and 30.e we conclude that ⟨W, 0⟩ |= tv iff LDf (v, 0) = ⊤.
Consequently, Theorem 1 holds for pos(v) = 1, k = 0 and v ∈ V (output).
31. Similarly, we prove that Theorem 1 holds for k = 0 and pos(v) = 1 for the

vertices v ∈ V (not), v ∈ V (or) and v ∈ V (and).

32. Now, we assume that Theorem 1 holds up to some position pos(v) = j with
v ∈ V (not) ∪ V (or) ∪ V (and) ∪ V (output). We prove that it also holds for the
position j + 1.

33. We assume that v ∈ V (output) with pos(v) = j + 1 and u → v ∈ E:

33.a By Def. 3, we have LDf (v, 0) = ev(LDf (u, 0)).
33.b By Def. 6, we have W |= □(tu ↔ tv). Thus, ⟨W, 0⟩ |= tv iff ⟨W, 0⟩ |= tu.
33.c As per 27, we have pos(u) = j. Thus, based on 32 we have ⟨M, 0⟩ |= tu

iff LDf (u, 0) = ⊤.

33.d By 33.a, 33.b and 33.c, we conclude that Theorem 1 is true for the

position pos(v) = j + 1 with k = 0 and v ∈ V (output).

34. Similarly, we prove that the theorem holds for k = 0 and pos(v) = j + 1 for

the vertices v ∈ V (not), v ∈ V (or) and v ∈ V (and).

35. We conclude that Theorem 1 is true for k = 0 and v ∈ v ∈ V (not) ∪ V (or) ∪

V (and) ∪ V (output).

36. Conclusion: by (A), 26 and 35; Theorem 1 holds for k = 0 and v ∈ V .

Proof. Proof of Theorem 1 part (C): v ∈ V and k ≥ 1.

37. Consider a logical diagram LD = ⟨V, E, O⟩ and an initializing function f .

The LTL theories are TLD and Tf . Let W |= TLD ∪ Tf and v ∈ V

38. We prove Theorem 1 for k ≥ 1 by induction. We first prove it holds for
the base case k = 1 for v ∈ V (ME) then for v ∈ V (MH ) and finally for
v ∈ V (not) ∪ V (or) ∪ V (and) ∪ V (output).

39. Let v ∈ V (ME) with e s−→ v ∈ E, h r−→ v ∈ E, e ∈ V and h ∈ V .
40. Let k = 1. If O(v) = 1 then k = 1 ∈ turnO(v):

(cid:16)

⃝ tv ↔ (cid:0)(¬tO(v) ∧ tv) ∨ (tO(v) ∧ ((tv ∧ ¬th) ∨ te))(cid:1)(cid:17)

40.a By Def. 6, W |= □
40.b By Lemma 1 we have ⟨W, 0⟩ |= t1.
40.c By 40.a and 40.b we have ⟨W, 1⟩ |= tv iff ⟨W, 0⟩ |= (cid:0)(tv ∧ ¬th) ∨ te
40.d By Def. 3, we have LDf (v, 1) = ev((LDf (v, 0)∧¬LDf (h, 0))∨LDf (e, 0)).
40.e By 40.c and 40.d and knowing that Theorem 1 is true for k = 0 (proven

(cid:1).

.

in (B)), we conclude that ⟨W, 1⟩ |= tv iff LDf (v, 1) = ⊤.

41. Let k = 1. If O(v) ̸= 1 (i.e k /∈ turnO(v)):

41.a By Def. 6, W |= □
41.b By Lemma 1 we have ⟨W, 0⟩ ⊭ t1.

(cid:16)

⃝ tv ↔ (cid:0)(¬tO(v) ∧ tv) ∨ (tO(v) ∧ ((tv ∧ ¬th) ∨ te))(cid:1)(cid:17)

.

Testing Logical Diagrams in power plants: a tale of LTL model checking

13

41.c By 41.a and 41.b we have ⟨W, 1⟩ |= tv iff ⟨W, 0⟩ |= tv.
41.d By Def. 3, we have LDf (v, 1) = ev(LDf (v, 0)).
41.e By 41.c and 41.d and knowing that Theorem 1 is true for k = 0 (proven

in (B)), we conclude that ⟨W, 1⟩ |= tv iff LDf (v, 1) = ⊤.

42. By 40.e and 41.e we conclude that Theorem 1 holds for k = 1 and v ∈ V (ME).
43. In the same way we prove that Theorem 1 holds for k = 1 and v ∈ V (MH ).
44. Similarly to (B) from 27 to 35, we have Theorem 1 holds for k = 1 and

v ∈ V (not) ∪ V (or) ∪ V (and) ∪ V (output).

45. By (A), 42, 43 and 44, Theorem 1 holds for k = 1 and v ∈ V .
46. We assume that Theorem 1 holds for some k ≥ 1. We prove that it also
holds for k + 1 for v ∈ V (ME) then for v ∈ V (MH ) and finally for v ∈
V (not) ∪ V (or) ∪ V (and) ∪ V (output).

47. Let v ∈ V (ME) with e s−→ v ∈ E, h r−→ v ∈ E, e ∈ V and h ∈ V .
48. Let k + 1 ∈ turnO(v):
48.a By Def. 6, W |= □
48.b By Lemma 1 we have ⟨W, k⟩ |= tO(v).
48.c By 48.a and 48.b we have ⟨W, k + 1⟩ |= tv iff ⟨W, k⟩ |= (cid:0)(tv ∧ ¬th) ∨ te
(cid:1).
48.d Based on Def. 3, LDf (v, k+1) = ev((LDf (v, k)∧¬LDf (h, k))∨LDf (e, k)).
48.e By 48.c and 48.d and knowing that Theorem 1 holds for k as stated in

⃝ tv ↔ (cid:0)(¬tO(v) ∧ tv) ∨ (tO(v) ∧ ((tv ∧ ¬th) ∨ te))(cid:1)(cid:17)

(cid:16)

.

46, we conclude that ⟨W, k + 1⟩ |= tv iff LDf (v, k + 1) = ⊤.

49. Let k + 1 /∈ turnO(v):

(cid:16)

⃝ tv ↔ (cid:0)(¬tO(v) ∧ tv) ∨ (tO(v) ∧ ((tv ∧ ¬th) ∨ te))(cid:1)(cid:17)

49.a By Def. 6, W |= □
49.b By Lemma 1 we have ⟨W, k⟩ ⊭ tO(v).
49.c By 49.a and 49.b we have ⟨W, k + 1⟩ |= tv iff ⟨W, k⟩ |= tv.
49.d Based on Def. 3, we have LDf (v, k + 1) = ev(LDf (v, k)).
49.e By 49.c and 49.d and knowing that Theorem 1 holds for k as stated in

.

46, we conclude that ⟨W, k + 1⟩ |= tv iff LDf (v, k + 1) = ⊤.

50. By 48.e and 49.e we conclude that Theorem 1 holds for k +1 and v ∈ V (ME).
51. Likewise, Theorem 1 holds for k + 1 and v ∈ V (MH ).
52. Similarly to (B) from 27 to 35, Theorem 1 holds for k + 1 and v ∈ V (not) ∪

V (or) ∪ V (and) ∪ V (output).

53. By (A), 50, 51 and 52, Theorem 1 holds for every k ≥ 1 and v ∈ V .

Conclusion: theorem 1 holds for every k ≥ 0 and for every v ∈ V .

5 Evaluation and discussion

In this section, we evaluate different LTL model checking (MC) techniques on
a real world logical diagram used for a logical controller in a nuclear power
plant. The goal is to generate scenarios that could be used for validation tests.
These scenarios consist in a set of input values and the set of expected output
values. In the testing process, the generated inputs are applied on the logical
controller in order to observe the real output values and make sure that they are
conform to the expected output values of the generated scenario. However, before

14

F. Author et al.

Table 1. Evaluation of the MC techniques on Pact and Pdeact of all the 12 out-
puts. m: minutes; s: seconds; mean: median time of the 12 outputs; min/max : mini-
mum/maximum time out of the 12 outputs; (n): n is the length of the counterexample.

BDD BMC

Pact(o)

timeout

Pdeact(o) timeout

mean: 26s (33)
min: 4.2s (22)
max: 2m 11s (57)
mean: 18.2s (32)
min: 4s (22)
max: 35s (39)

SBMC
mean: 3.4s (33)
min: 1.3s (22)
max: 11.3s (57)
mean: 2.9s (32)
min: 1.3s (22)
max: 4.4s (39)

k-MC
mean: 6.2s (33)
min: 3.9s (24)
max: 12.9s (57)
mean: 5.3s (32)
min: 3.4s (22)
max: 7.5s (35)

generating these scenarios it is important to ensure that the logical diagram
satisfies the stability property. An unstable behavior is when a value of one
or many outputs keep changing indefinitely for fixed inputs. In this case, the
logical diagram has to be revised to satisfy the stability. This is because the
unstable behavior means that the expected value of the output is not defined
and therefore, generating tests for that output becomes meaningless. Verification
of the stability and generating test scenarios are the main focus of this evaluation.
The real world logical diagram chosen for the evaluation is representative
of many other logical diagrams used by EDF. It contains 16 input vertices, 12
output vertices, 19 memory vertices and 77 vertices of the types {and, or, not}.
First, the satisfaction of the stability property is verified. Then, the purpose is to
generate scenarios that set an output to the value true when it is initially set to
false (i.e. activation scenarios) and others that put it to false when it is initially
set to true (i.e. deactivation scenarios). These scenarios will be generated for
each different output. The concerned real world logical diagram will be referred
to as LDR. The results previously established in this paper were implemented to
generate the LTL theory TLDR that encodes the logical diagram LDR as well as
the theory Tstable encoding the stability of LDR and the theories T oi
for the activation and deactivation of every output vertex oi.

act and T oi

The LTL theory of stability is Tstable = {♢(□tmi ∨ □¬tmi) | i ∈ 1, 2, . . . , 19}.
We use the LTL model checking techniques to prove the truthfulness of the fol-
lowing LTL property: TLD |= Tstable. This property will be referred to as the
stability property Pstab. If it is proven to be true, then LDR is uniformly sta-
ble. If it is not, then we get a counterexample, i.e. a word W that is a model
of TLDR and the theory Tf of some initializing function f for which LDR is
unstable. The LTL theory that encodes the activation of an output oi which
is initially deactivated is T oi
act = {(toi ↔ ⊥), (♢□toi)}. Likewise, the LTL the-
ory that encodes the deactivation of an output oi which is initially activated is
T oi
deact = {(toi ↔ ⊤), (♢□¬toi)}. In order to generate activation and deactiva-
tion scenarios for an output oi, we apply the model checking on the property
TLD ∪T oi
deact |= ⊥ referred
to as Pdeact(oi). If Pact(oi) (resp. Pdeact(oi)) is true, then no activation (resp.
deactivation) scenarios exist. Otherwise, if Pact(oi) (resp. Pdeact(oi)) is not sat-
isfied we get a counterexample, i.e a word W that satisfies all the formulae of

act |= ⊥ referred to as Pact(oi) and the property TLD ∪T oi

deact

Testing Logical Diagrams in power plants: a tale of LTL model checking

15

the LDR theory TLDR , the activation theory T oi
act (resp. the deactivation theory
T oi
deact ) and the theory Tf of some initializing function f for which the output
oi is activated (resp. deactivated). The generated word expresses the testing sce-
nario to be applied on the logical controller. We check Pact(oi) and Pdeact(oi)
properties for every output vertex oi of the 12 outputs in LDR.

For this evaluation, the verification of each property was done using a well
known symbolic model checking tool called NuSMV [5]. Different techniques
were used for each property. In the following, we list the evaluated NuSMV LTL
model checking techniques presented in [4]:

– The Binary Decision Diagram (BDD) based LTL Model Checking [7].
– Bounded Model Checking (BMC ) based on SAT solvers as described in [1].
– Simple Bounded Model Checking (SBMC) based on SAT solvers as in [9].

The usage of the BDD based technique allows to verify whether an LTL prop-
erty is true or false and to generate a counterexample when it is false. On the
other hand, BMC based techniques prove that a property is false by increasingly
exploring the different lengths of counterexamples starting from zero to a preset
upper bound. When the maximum bound is reached and no counterexamples are
found, then the truth of the property is not decided. In other words, unlike the
BDD based technique, the BMC based ones are useful only in case the property
is false. In this evaluation, the upper bound of the BMC based techniques was
set to 1000. Another technique tested for the verification of the properties is the
k-liveness algorithm based model checking technique (k-MC ) as described in [6].
The technique was introduced in another tool called nuXmv [3]: an extension
for NuSMV. The usage of the technique is presented in [2]. For this evaluation,
the timeout delay for each of the mentioned techniques was set to two hours.

The verification of the uniform stability of LDR was done by checking the
property Pstab using the different techniques. The BDD, BMC, and SBMC tech-
niques timed-out. The stability could not therefore be concluded with these
techniques. However, the k-MC technique terminated successfully in 26 minutes
declaring that the property Pstab is true. Therefore, the logical diagram LDR is
uniformly stable. Each technique was then tested for the activation (Pact(oi))
and deactivation (Pdeact(oi)) property for every output oi. Except for the BDD
technique which timed-out in every single check, all the other techniques suc-
cessfully generated counterexamples of the same length for every output of LDR.
The evaluation results are given by table 1. The SBMC technique was the fastest
to generate the counterexample for every output while BMC was considerably
slower especially on the longest counterexamples.

This study shows that the proposed LTL encoding of the logical diagrams is a
good candidate for test generation, as multiple counterexamples can be generated
starting from different initial configuration defined by the verification process.
We tested the proposed LTL encoding on a real, representative logical diagram
by comparing different LTL model checking techniques. It turns out that k-MC
and SBMC techniques are particularly efficient for checking the properties we
defined, allowing us to test the controller’s outputs with respect to the LD.

16

F. Author et al.

Acknowledgments

David Carral is funded by the ANR project CQFD (ANR-18-CE23-0003).

References

1. Biere, A., Cimatti, A., Clarke, E., Zhu, Y.: Symbolic model checking without
BDDs. In: Tools and Algorithms for the Construction and Analysis of Systems:
5th International Conference, TACAS’99 Held as Part of the Joint European Con-
ferences on Theory and Practice of Software, ETAPS’99 Amsterdam, The Nether-
lands, March 22–28, 1999 Proceedings 5. pp. 193–207. Springer (1999)

2. Bozzano, M., Cavada, R., Cimatti, A., Dorigatti, M., Griggio, A., Mariotti, A.,
Micheli, A., Mover, S., Roveri, M., Tonetta, S.: nuXmv 2.0. 0 User Manual. Fon-
dazione Bruno Kessler, Tech. Rept., Trento, Italy (2019)

3. Cavada, R., Cimatti, A., Dorigatti, M., Griggio, A., Mariotti, A., Micheli, A.,
Mover, S., Roveri, M., Tonetta, S.: The nuXmv symbolic model checker. In: Com-
puter Aided Verification: 26th International Conference, CAV 2014, Held as Part
of the Vienna Summer of Logic, VSL 2014, Vienna, Austria, July 18-22, 2014.
Proceedings 26. pp. 334–342. Springer (2014)

4. Cavada, R., Cimatti, A., Jochim, C.A., Keighren, G., Olivetti, E., Pistore, M.,
Roveri, M., Tchaltsev, A.: Nusmv 2.4 user manual. CMU and ITC-irst (2005)
5. Cimatti, A., Clarke, E., Giunchiglia, E., Giunchiglia, F., Pistore, M., Roveri, M., Se-
bastiani, R., Tacchella, A.: Nusmv 2: An opensource tool for symbolic model check-
ing. In: Computer Aided Verification: 14th International Conference, CAV 2002
Copenhagen, Denmark, July 27–31, 2002 Proceedings 14. pp. 359–364. Springer
(2002)

6. Claessen, K., Sörensson, N.: A liveness checking algorithm that counts. In: 2012
Formal Methods in Computer-Aided Design (FMCAD). pp. 52–59. IEEE (2012)
7. Clarke, E.M., Grumberg, O., Hamaguchi, K.: Another look at LTL model checking.

Formal Methods in System Design 10, 47–71 (1997)

8. Enoiu, E.P., Čaušević, A., Ostrand, T.J., Weyuker, E.J., Sundmark, D., Pettersson,
P.: Automated test generation using model checking: an industrial evaluation. In-
ternational Journal on Software Tools for Technology Transfer 18, 335–353 (2016)
9. Latvala, T., Biere, A., Heljanko, K., Junttila, T.: Simple is better: Efficient bounded
model checking for past LTL. In: Verification, Model Checking, and Abstract In-
terpretation: 6th International Conference, VMCAI 2005, Paris, France, January
17-19, 2005. Proceedings 6. pp. 380–395. Springer (2005)

10. Lee, D., Yannakakis, M.: Principles and methods of testing finite state machines-a

survey. Proceedings of the IEEE 84(8), 1090–1123 (1996)

11. Provost, J., Roussel, J.M., Faure, J.M.: Translating Grafcet specifications into
Mealy machines for conformance test purposes. Control Engineering Practice
19(9), 947–957 (2011)

12. Sfar, A., Irofti, D., Croitoru, M.: A graph based semantics for Logical Functional
Diagrams in power plant controllers. In: Foundations of Information and Knowl-
edge Systems: 12th International Symposium, FoIKS 2022, Helsinki, Finland, June
20–23, 2022, Proceedings. pp. 55–74. Springer (2022)

13. Springintveld, J., Vaandrager, F., D’Argenio, P.R.: Testing timed automata. The-

oretical computer science 254(1-2), 225–257 (2001)

