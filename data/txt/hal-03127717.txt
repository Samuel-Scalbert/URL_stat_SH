Queries with Arithmetic on Incomplete Databases
Marco Console, Matthias Hofer, Leonid Libkin

To cite this version:

Marco Console, Matthias Hofer, Leonid Libkin. Queries with Arithmetic on Incomplete Databases.
International Conference on Management of Data, Jun 2020, Portland /
SIGMOD/PODS 2020 :
Virtual, United States. pp.179-189, ￿10.1145/3375395.3387666￿. ￿hal-03127717￿

HAL Id: hal-03127717

https://inria.hal.science/hal-03127717

Submitted on 1 Feb 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Queries with Arithmetic on Incomplete Databases

Marco Console
University of Edinburgh
mconsole@inf.ed.ac.uk

Matthias Hofer
University of Edinburgh
mhofer@inf.ed.ac.uk

Leonid Libkin
University of Edinburgh and
ENS-Paris/PSL
libkin@inf.ed.ac.uk

ABSTRACT
The standard notion of query answering over incomplete database is
that of certain answers, guaranteeing correctness regardless of how
incomplete data is interpreted. In majority of real-life databases,
relations have numerical columns and queries use arithmetic and
comparisons. Even though the notion of certain answers still applies,
we explain that it becomes much more problematic in situations
when missing data occurs in numerical columns.

We propose a new general framework that allows us to assign a
measure of certainty to query answers. We test it in the agnostic
scenario where we do not have prior information about values
of numerical attributes, similarly to the predominant approach in
handling incomplete data which assumes that each null can be
interpreted as an arbitrary value of the domain. The key technical
challenge is the lack of a uniform distribution over the entire domain
of numerical attributes, such as real numbers. We overcome this by
associating the measure of certainty with the asymptotic behavior
of volumes of some subsets of the Euclidean space. We show that
this measure is well-defined, and describe approaches to computing
and approximating it. While it can be computationally hard, or
result in an irrational number, even for simple constraints, we
produce polynomial-time randomized approximation schemes with
multiplicative guarantees for conjunctive queries, and with additive
guarantees for arbitrary first-order queries. We also describe a set
of experimental results to confirm the feasibility of this approach.

CCS CONCEPTS
• Theory of computation → Incomplete, inconsistent, and
uncertain databases; Complexity theory and logic; Stochastic ap-
proximation; • Information systems → Incomplete data;

KEYWORDS
incomplete information, numerical data, missing data, query an-
swering, measure of certainty, first-order queries, approximate
query answers, asymptotic behavior

ACM Reference Format:
Marco Console, Matthias Hofer, and Leonid Libkin. 2020. Queries with
Arithmetic on Incomplete Databases. In 39th ACM SIGMOD-SIGACT-SIGAI
Symposium on Principles of Database Systems (PODS’20), June 14–19, 2020,

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
PODS ’20, June 14–19, 2020, Portland, OR, USA
© 2020 Copyright held by the owner/author(s). Publication rights licensed to the
Association for Computing Machinery.
ACM ISBN 978-1-4503-7108-7/20/06. . . $15.00
https://doi.org/10.1145/3375395.3387666

Portland, OR, USA. ACM, New York, NY, USA, 11 pages. https://doi.org/10.
1145/3375395.3387666

1 INTRODUCTION
Handling incomplete or uncertain information is one of the central
topics in databases, as well as in multiple applications of databases
where uncertainty naturally arises. These applications include data
integration [25], data exchange [5], ontology-based data access
[7, 30], consistent query answering [6], probabilistic databases [31],
and others. The standard approach to query answering in all of
these is to find answers with some certainty guarantees [19]. Most
commonly, one looks for certain answers that are true under all
possible interpretations of missing data, although weaker guaran-
tees are possible. In the probabilistic model, for example, we can
talk about the probability of a tuple being an answer [31], and can
even do this in the absence of explicit distributions [27].

There is one element common to all these approaches. They all
start by the standard assumption prevalent in the database literature,
which essentially says: assume that there is one domain of values
𝑈 from which all database elements are drawn. In reality however
database columns are typed, and one would need to look hard for
a database that does not have numerical columns and arithmetic
operations in queries. For example, in the TPC-H benchmark [32], 7
out of 8 tables have numerical attributes, while over 85% of queries
use at least order comparisons, and over 70% of queries use standard
arithmetic operations such as addition and multiplication. Modeling
extra types theoretically is done by viewing relational databases
as many-sorted structures. Usually this is a mild assumption for
theoretical work, unless there are specific interpreted operations
on different types, such as for instance +, ·, < on numerical types.
The expressive power and complexity of such languages was ex-
tensively studied in the 1990s; see [24] for a summary. For handling
incomplete information, however, very little is known. We do know
however that the problem becomes considerably harder. For exam-
ple, under the single-domain assumption, unions of conjunctive
queries on databases with nulls can be evaluated efficiently if we
only compare values for equality [19], but already in the presence
of order comparisons data complexity jumps to coNP, cf. [1]. With
more complicated arithmetic, the complexity may jump even higher,
all the way to undecidability (we shall give an example later).

At this point we should ask ourselves: what kind of query an-
swers we would actually want in such scenarios. Look at a very
simple example: a query 𝜎𝐴>𝐵 (𝑅) on relation 𝑅 with attributes 𝐴
and 𝐵 and a single tuple (⊥1, ⊥2) with two nulls. Should the tuple
be selected? If we know nothing about ⊥1 and ⊥2, it seems reason-
able to say that with probability 1/2 the tuple will be in the answer.
We now give an example showing the utility of such answers.

Example. A team of sale analysts is asked to predict the ef-
fectiveness of the forthcoming sales campaign using data from a
database with three relations:

• Products(id, seg, rrp, dis) has product ids, their mar-
ket segment, recommended retail price (rrp), and intended
discount dis;

• Competition(id, seg, p) contains information about
competing products on the market including their ids, mar-
ket segment, and offered price p;

• Excluded(id, seg) has products excluded from the cam-

paign.

As often happens in any business environment, information in
these tables may be incomplete while the details of the campaign
are being worked out. Furthermore, Competition is likely to be
populated by an (automated) web extraction algorithm, leading to a
high chance of incomplete data in that relation. A sales analyst may
want to compile a list of market segments where the company will
have a strong competitive advantage, i.e., the price, after discount,
of all the products in that segment is below the competition. This
can be done with the following query, written in first-order (FO)
notation:

𝑞(𝑠) = ∀𝑖, 𝑟, 𝑑, 𝑖 ′ 𝑝 (cid:0)P(𝑖, 𝑠, 𝑟, 𝑑) ∧ ¬E(𝑖, 𝑠) ∧ C(𝑖 ′, 𝑠, 𝑝)) →

((𝑟 · 𝑑 ≤ 𝑝) ∧ (𝑟, 𝑑, 𝑝 ≥ 0))

Now consider a database 𝐷 in which Competition has tu-
ple (𝑐, 𝑠, ⊥), where ⊥ indicates a null, Products has tuples
(𝑖𝑑1, 𝑠, 10, 0.8) and (𝑖𝑑2, 𝑠, ⊥′, 0.7), where again ⊥′ indicates a null
(here we use the model of marked or labeled nulls), and Excluded
has a tuple (⊥′′, 𝑠) meaning that some product from the segment
is excluded from the campaign but we do not yet know which one.
We want to estimate how likely it is that 𝑠 is returned as the answer
to 𝑞 over 𝐷. This will happen iff ⊥, ⊥′ are interpreted as numbers
𝛼, 𝛼 ′ and ⊥′′ as some value 𝑢 such that 𝑢 ≠ 𝑖𝑑2 and

(𝛼 ′ ≥ 0) ∧ (𝛼 ≥ 8) ∧ (0.7 · 𝛼 ′ ≥ 𝛼) .

(1)

Thus, 𝑠 is not a certain answer to 𝑞 over 𝐷, but it is an answer under
conditions (1) and we thus would want to estimate the chance of
these conditions being true.

If we know nothing at all about the values that ⊥, ⊥′, ⊥′′ can
take, we assume that any value is equally likely. Then, it is rather
unlikely that 𝑖𝑑2 = 𝑢 and we can dismiss that constraint. For (1) it
seems reasonable then to say: pick 𝛼, 𝛼 ′ uniformly at random, and
compute the probability of (1). The problem is that, of course, we
cannot sample from all of R (or Z for that matter) uniformly, so
we need to restrict the range of numbers to do so. We look then at
vectors (𝛼, 𝛼 ′) whose length is at most 𝑟 , and estimate the fraction
of the area that constraint (1) covers among all vectors of such
length. This is shown in the picture below

The fraction depends on 𝑟 , but as 𝑟 increases, one can calculate
that it tends to ≈ 0.388 of the positive quadrant, which can be taken
as our estimate. Putting a higher discount (e.g., changing 0.7 to 0.5)
results in approximately half of the positive quadrant satisfying the
constraint, thus increasing our confidence in 𝑠 being an answer. □

Our goal is to provide a framework in which we can reason about
answers in the same manner as in the example. Note that above we
did not make any assumptions about probability distributions on
data stored in numerical attributes. That is a deliberate assumption,
for this initial study. We would like the framework to be general
enough to accommodate additional information such as distribu-
tions or constraints on data. But for now we follow what most of
the work on usual incomplete data in relational databases does.
There, the standard assumption is that we have a domain of values,
and every null can be interpreted as any of the elements of the
domain, cf. [19]. We take it further by assuming that we now have
a second numerical domain, and specifying that some columns take
values in that numerical domain. This is similar to stating attribute
types as int or float in create table statements. Then we let
nulls in numerical columns be interpreted as arbitrary elements of
the numerical domain.

Before outlining our contributions, we remark that dealing with
missing numerical data is common in data analysis, and typically
is dealt with via imputation, i.e., finding suitable replacements for
missing data, cf. [14]. There are many variations of the approach
that go from simple discarding of tuples with missing values to
the inference of missing values through complex statistical models.
Crucially though once the imputation is done, the data set is treated
as complete, and if it resides in a database, it will be queries using
standard techniques for querying complete data. Query answers
then will have no way of referring to the fact that some data was
initially missing. Our goal is different though: we want to query an
incomplete database as given to us, with the full knowledge that it
is incomplete, and provide the user with the additional information
about confidence levels for potential query answers. Moreover, we
want to do it even in the case when there is no prior information
about data, such as probability distribution.

Our main contributions are as follows.

(1) We define a model of relational databases with attributes of
two distinct types – a base type and a numerical type – with
nulls that may occur as values of attributes of both types. We
use, as a query language, an extension of relational calculus
(FO) with arithmetic operations and order comparisons. We
define a measure 𝜇 (𝑞, 𝐷, ¯𝑎) of certainty of a tuple ¯𝑎 as an
answer to query 𝑞 on database 𝐷. It takes values in the
interval [0, 1]. Value 1 means that the answer is almost surely

certain (essentially being a correct answer with probability
1).

(2) The measure 𝜇 relies on computing volumes of sets given
by arithmetic constraints, and analyzing their asymptotic
behavior. Indeed, we cannot have a uniform distribution
over the entire infinite numerical domain, so instead we
first analyze all numerical constraints under a bound that
all values are bounded by some number 𝑟 , but then, to avoid
dependence on an ad hoc bound, we look at the limit behavior
as 𝑟 grows. This approach poses the question whether the
measure is well-defined (i.e., all volumes exist, and limit
exists). We prove that it is indeed well-defined.

(3) We outline two approaches to computing the measure

𝜇 (𝑞, 𝐷, ¯𝑎): finding the exact value, and finding its approxi-
mation. The former could be computationally hard even for
conjunctive queries with inequalities, which is not surprising
in view of known complexity results. But with more com-
plex constraints (e.g., linear constraints), values of 𝜇 could
be irrational, so one needs to approximate.

(4) We then look at the common way of finding approximations,
namely constructing an FPRAS (fully polynomial-time ran-
domized approximation scheme), and prove that it exists for
conjunctive queries with linear constraints but does not exist
for FO queries even with order constraints.

(5) We then notice that values of 𝜇 are in the interval [0, 1], and
thus it is reasonable to look at slightly weaker approxima-
tions 𝑎 of 𝜇 so that |𝜇 −𝑎| < 𝜖 for some small 𝜖 (under FPRAS,
the condition is |𝑎/𝜇 − 1| < 𝜖). Then we prove the existence
of such a polynomial-time approximation scheme for all FO
queries, with the usual arithmetic (addition, multiplication,
order comparisons).

(6) We not only prove the theoretical bounds but also conduct
an experimental study to confirm the feasibility of the ap-
proach. We look at some decision support queries in an
example similar to the one shown earlier, and implement
the approximation algorithm for finding confidence levels
for candidate tuple answers. We show that its performance
is adequate, essentially a small number of seconds with 𝜖
ranging from 0.1 to 0.01.

Organization In Section 2 we define basic notations related to
databases with nulls. In Section 3 we present the model of databases
with numerical columns, and in Section 4 we define the measure of
certainty 𝜇. We prove that it is well-defined in 5. In Section 6 we
outline approaches to computing and approximating 𝜇. In Section 7
we present an FPRAS for conjunctive queries with linear constraints,
and in Section 8 we give an approximation scheme with additive
guarantees for all FO queries. The results of the experimental study
are in Section 9, and conclusions are in Section 10. Due to space
limitations, detailed proofs are in the appendix.

2 PRELIMINARIES
We now briefly recall the standard model of incomplete information,
where incompleteness is represented by nulls, and query answering
in this model. In this model, elements of the database come either
from a domain C, often viewed as the domain of constants, or known
values. They may also come from a domain N of nulls, which are

viewed as currently unknown values. A database schema is a set of
relation names and their arities. In a database 𝐷, a 𝑘-ary relation
𝑅 from the schema is interpreted as 𝑘-ary relation over C ∪ N, i.e.,
a finite set 𝑅𝐷 ⊆ (C ∪ N)𝑘 . Often 𝐷 is clear from the context, and
we then write 𝑅 in place of 𝑅𝐷 . We write C(𝐷) and N(𝐷) for the
set of all elements of C and N that appear in relations of 𝐷.

Incomplete databases are interpreted by means of valuations. A
valuation is a map 𝑣 : N(𝐷) → C that interprets nulls by constants.
Thus, an incomplete database 𝐷 represents complete (i.e., having
no nulls) databases 𝑣 (𝐷), where 𝑣 ranges over valuations, and 𝑣 (𝐷)
is the result of replacing each null ⊥ ∈ N(𝐷) with 𝑣 (⊥).

Suppose 𝑞 is a 𝑛-ary query that, on each complete database 𝐷
returns 𝑞(𝐷) ⊆ C(𝐷)𝑛. The standard notion of query answering
is that of certain answers [19], i.e., answers independent of the
valuation of nulls. For a database 𝐷 that now may have nulls, an
𝑛-tuple ¯𝑎 over C(𝐷) ∪ N(𝐷) is a certain answer if

𝑣 ( ¯𝑎) ∈ 𝑞 (cid:0)𝑣 (𝐷)(cid:1)

for each valuation 𝑣 .

This is the definition from [28]. One typically sees a restricted form
of it when ¯𝑎 has no nulls; then it says ¯𝑎 ∈ 𝑞 (cid:0)𝑣 (𝐷)(cid:1), see [19]. We
use the more permissive definition of [28], as it allows tuples with
nulls to be in the answer. Its advantages are explained, for example,
in [26]. As a simple example, if we have a relation 𝑅 with a single
tuple (1, ⊥), and a query returning 𝑅, then the definition of [19]
will return ∅, forgetting certain information that we have one tuple
in 𝑅, and its first component is 1. The definition of [28] that we use
here will, on the other hand, return (1, ⊥).

It is well-known that certainty comes at a computational price:
while for conjunctive queries and their unions and some small
extensions with restricted negation they can be computed efficiently
[15, 16, 19], for first-order queries (or full relational algebra queries)
finding certain answers is coNP-hard in data complexity. This cost
however can be significantly reduced if we are only interested in
almost certain answers, using a simple idea from [27].

Assume the domain of constants comes with some enumeration,

C = {𝑐1, 𝑐2, 𝑐3, . . .}. For a valuation 𝑣 : N(𝐷) → C, define

∥𝑣 ∥ = max{𝑟 | 𝑐𝑟 is in the range of 𝑣 } .
Next, for a query 𝑞 and a tuple ¯𝑎, define the 𝑟 -support of a tuple ¯𝑎
as an answer to 𝑞 as the set of valuations 𝑣 with ∥𝑣 ∥ ≤ 𝑟 such that
𝑣 ( ¯𝑎) ∈ 𝑞 (cid:0)𝑣 (𝐷)(cid:1), i.e.,

Supp𝑟 (𝑞, 𝐷, ¯𝑎) = {𝑣 | 𝑣 ( ¯𝑎) ∈ 𝑞 (cid:0)𝑣 (𝐷)(cid:1) and ∥𝑣 ∥ ≤ 𝑟 } .
We then take 𝜇𝑟 (𝐷, 𝑞, ¯𝑎) to be the probability that a valuation 𝑣
with ∥𝑣 ∥ ≤ 𝑟 picked uniformly at random is in Supp𝑟 (𝑞, 𝐷, ¯𝑎). As
there are only 𝑟 |N(𝐷) | valuations 𝑣 with ∥𝑣 ∥ ≤ 𝑟 on a database 𝐷,
this is well defined. Finally, to get rid of the dependence on 𝑟 , one
simply looks at the limit as 𝑟 grows and thus the set of valuations
with ∥𝑣 ∥ ≤ 𝑟 becomes close to the set of all valuations; that is,
𝜇 (𝑞, 𝐷, ¯𝑎) = lim𝑟 →∞ 𝜇𝑟 (𝑞, 𝐷, ¯𝑎).

Then, [27] established the following results:

• The value of 𝜇 (𝑞, 𝐷, ¯𝑎) does not depend on a particular enu-

meration of C.

• For a large class of queries the value of 𝜇 (𝑞, 𝐷, ¯𝑎) is either 0
or 1. These queries are generic, i.e., commuting with permu-
tations of their domain. All queries in languages such as FO,
relational algebra, datalog, etc., are generic.

• 𝜇 (𝑞, 𝐷, ¯𝑎) = 1 iff ¯𝑎 is returned by the naïve evaluation of 𝑞
on 𝐷, i.e., treating nulls as new distinct constants, different
from all the elements of C(𝐷).

Thus, a straightforward evaluation of a query on a database with
nulls results in answers that are almost certainly true. This happens
though in the absence of constraints on database entries, such
as their types (e.g., numbers), and in the absence of type-specific
operations in queries (e.g., addition and multiplication).

3 DATA MODEL AND QUERY LANGUAGES
We now move to a model where different columns in relations can
be of different types. This is a fairly standard multi-sorted model
where we allow for nulls as entries.

We assume that database columns can be of two types: either
a base type, denoted by base, which corresponds to the usual one-
domain assumption in the database literature, or a numerical type,
denoted by num. The domain of base type is denoted by Cbase
and the domain of the numerical type by Cnum. Thus, what we
previously viewed as the set of constants C is now a disjoint union
of Cbase and Cnum. We assume that the domain of the numerical
type Cnum is a subset of the real numbers R.

A schema then, instead of simply specifying the arity of each
relation, specifies types of columns. We assume that such specifica-
𝑘
num𝑚) saying that the first 𝑘 columns
tions are of the form 𝑅(base
of 𝑅 are of base type, and the remaining 𝑚 are of the numerical type.
Such columns, as declared in any real-life DDL, can be interspersed,
but here we assume, only for the simplicity of the notation, that all
base type columns come first.

Each column, whether of base type or numerical, may contain
null values. Using the same marked nulls model, we assume two
sets of nulls: Nbase = {⊥1, . . .} of nulls that occur in base type
columns, and Nnum = {⊤1, ⊤2, . . .} of numerical type nulls. Then a
𝑘
num𝑚) in a database 𝐷 is interpreted as a
relation of type 𝑅(base
finite set

𝑅𝐷 ⊂ (Cbase ∪ Nbase)𝑘 × (Cnum ∪ Nnum)𝑚 .
That is, entries of each base type column come from Cbase ∪ Nbase
and entries of each numerical type column come from Cnum ∪Nnum.
We use the same notations to denote sets of elements of each kind
in a database 𝐷: for example, Cbase (𝐷) is the set of all constants
of base type that occur in 𝐷, and Nnum (𝐷) is the set of all nulls in
numerical columns that occur in 𝐷.

Query languages. As our basic query language, we consider two-
sorted first-order logic with arithmetic, FO(+, ·, <). In this logic, every
variable is typed (i.e., of base or numerical type). Its terms and
formulae are defined inductively as follows.

Terms • a variable of a base type is a base type term;

• a variable of a numerical type is a numerical type term;
• every element 𝛼 ∈ Cnum is a numerical type term;
• if 𝑡 and 𝑡 ′ are numerical type terms, then so are 𝑡 + 𝑡 ′ and

𝑡 · 𝑡 ′.

𝑘
Atomic formulae • for a relation 𝑅(base

num𝑚), if ¯𝑥 is a
𝑘-tuple of base type variables and ¯𝑡 is an 𝑚-tuple of nu-
merical type terms, then 𝑅( ¯𝑥, ¯𝑡) is an atomic formula;
• if 𝑥 and 𝑦 are variables of the base type, then 𝑥 = 𝑦 is an

atomic formula;

• if 𝑡, 𝑡 ′ are numerical type terms, then 𝑡 < 𝑡 ′ and 𝑡 = 𝑡 ′ are

atomic formulae.

Formulae are closed under Boolean connectives and quanti-

fiers:
• If 𝜑,𝜓 are formulae then 𝜑 ∨𝜓, 𝜑 ∧𝜓 and ¬𝜑 are formulae;
• if 𝜑 is a formula then ∃𝑥 𝜑 and ∀𝑥 𝜑 are formulae.
We shall use the standard shortcuts, i.e., 𝑥 ≤ 𝑦 for 𝑥 < 𝑦 ∨ 𝑥 = 𝑦
or 2𝑥 and 𝑥 2 for 𝑥 + 𝑥 and 𝑥 · 𝑥, etc. Since atomic formulae are of
the form 𝑡 = 𝑡 ′ or 𝑡 < 𝑡 ′, we can assume that operations − and ÷
are allowed for building terms as well.

The notion of free variables and the semantics are standard.
When queries are interpreted over complete databases 𝐷, quan-
tifiers range over their domain. That is, ∃𝑥 means that a witness
is found among elements of Cbase (𝐷) if 𝑥 is of base type, and
among elements of Cnum (𝐷) if 𝑥 is of numerical type. For exam-
ple, ∃𝑦, 𝑧 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑦, 𝑧) ∧ 𝑦 > 𝑧2 for relations 𝑅(base num) and
𝑆 (num2) finds all 𝑥 of base type such that there are tuples (𝑥, 𝑦) ∈ 𝑅
and (𝑦, 𝑧) ∈ 𝑆 with 𝑦 > 𝑧2.

Sublanguages. If we restrict the use of arithmetic, we explicitly
indicate so; for example, FO(+, <) means that arithmetic terms are
linear functions, built with +, and comparisons 𝑡 < 𝑡 ′ are allowed.
Notice that with +, we also have subtraction: for example, 𝑡1−𝑡2 < 𝑡3
is 𝑡1 < 𝑡2 + 𝑡3.

We shall refer to the ∃, ∧-fragment of the language as conjunctive
queries and write CQ( ) listing allowed operations in parentheses.
For example, CQ(<) refers to conjunctive queries extended with
order comparisons.

4 QUERY ANSWERS: MEASURE OF

CERTAINTY

We now describe the approach to query answering in the presence
of arithmetic and nulls. As the first step, we need to provide the
semantics of incomplete databases over two types. Recall that under
the single-type assumption, the semantics was given by valuations,
which are functions from nulls to constants C. Now that the set of
constants is two-sorted, such valuations on an incomplete database
𝐷 are pairs 𝑣 = (𝑣base, 𝑣num) where 𝑣base : Nbase (𝐷) → Cbase
and 𝑣num : Nnum (𝐷) → Cnum. The database 𝑣 (𝐷) is, as before,
obtained by substituting each null ⊥ ∈ Nbase (𝐷) with 𝑣base (⊥)
and each null ⊤ ∈ Nnum (𝐷) with 𝑣num (⊤). Likewise, when we
have a tuple ¯𝑎, we write 𝑣 ( ¯𝑎) to denote a tuple obtained from ¯𝑎
by replacing base type nulls according to 𝑣base, numerical type
nulls according to 𝑣num, and leaving constants intact. For example,
𝑣 (⊥, ⊤, 2) = (𝑣base (⊥), 𝑣num (⊤), 2).

Of course with this, we could define certain answers as before:
a tuple ¯𝑎 is a certain answer to query 𝑞 if 𝑣 ( ¯𝑎) ∈ 𝑞 (cid:0)𝑣 (𝐷)(cid:1) for each
valuation 𝑣. However, it is well known that even adding simple order
comparisons < already leads to much higher complexity of query
answering. For example, finding certain answers to conjunctive
queries and their unions in the single-type scenario is well-known
to be the same as query evaluation [19], i.e., AC0 in data complexity
and NP in combined complexity. However, with order comparisons,
the complexity of the problem jumps coNP in data complexity
and Π𝑝
2 in combined complexity [1, 21, 35]. Order comparisons
lead to further complications when considered in typical scenarios

involving certain answers such as integrating and exchanging data
[3, 4].

When arithmetic operations are added, the situation is even

worse; in fact we have the following easy observation.

Proposition 4.1. If Cnum is Z, there is a CQ(+, ·, <) query 𝑞 such
that computing certain answers to 𝑞 is undecidable, even on a database
of a fixed schema, with a single relation consisting of a single tuple.

proof sketch. Indeed, consider a polynomial 𝑝 ∈ Z[𝑥1, . . . , 𝑥𝑘 ],
a relation 𝑅(num𝑘 ) with a single tuple (⊤1, . . . , ⊤𝑘 ), and 𝑞 given
by ∃ ¯𝑥 𝑅( ¯𝑥) ∧ 𝑝2 > 0. Then, a certain answer to this query is true iff
𝑝 has no integer roots. Since it is know that the problem of finding
solutions to Diophantine equations is undecidable even for a fixed
□
number of variable (in fact 𝑘 = 13 [29]), the result follows.

Thus, it is even more justified in the case of numerical constraints
to pass from absolute certainty to measures of certainty, as was
done in [27]. This is what we do next.

Measure of certainty. Now consider a query 𝑞( ¯𝑥, ¯𝑦), where ¯𝑥 are
of base type, ¯𝑦 are of numerical type, and let 𝐷 be a database. Let
¯𝑎 be a tuple of base type constants and nulls from 𝐷 of the same
arity as ¯𝑥, and let ¯𝑠 be a tuple of numerical type constants and
nulls from 𝐷 of the same arity as ¯𝑦. Our goal is to define a measure
𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) of the likelihood of a tuple ( ¯𝑎, ¯𝑠) being an answer to
𝑞 on 𝐷.

Given a database 𝐷, let its base type nulls be

Nbase (𝐷) = (⊥1, . . . , ⊥𝑚) and its numerical type nulls be
Nnum (𝐷) = (⊤1, . . . , ⊤𝑘 ). Then, for a valuation 𝑣 = (𝑣base, 𝑣num),
we have

𝑣 (Nbase (𝐷))
𝑣 (Nnum (𝐷))

∈ C𝑚
∈ C𝑘

base
num ⊆ R𝑘

since we assume always that Cnum ⊆ R.

As we did in the previous section, assume that we have an enu-
meration of base type constants Cbase as {𝑐1, 𝑐2, . . .} (we shall see
soon that the choice of a particular enumeration does not affect
the measure we define). When we had only one non-numerical do-
main we looked at the proportion of valuations 𝑣 with ∥𝑣 ∥ ≤ 𝑟 that
witness 𝑣 ( ¯𝑎) ∈ 𝑞 (cid:0)𝑣 (𝐷)(cid:1), and then analyzed its asymptotic behavior.
Here we do essentially the same. However, notice that 𝑣 (Nnum (𝐷))
is now a vector in R𝑘 , and thus there are infinitely many valuations
𝑣 with ∥𝑣 (Nnum (𝐷))∥ ≤ 𝑟 , where ∥ · ∥ refers to the usual (Euclidean)
norm in R𝑘 . Thus, to measure the number of valuations, instead of
cardinality we now look at their volume, denoted by Vol.

Thus, we mimic the definition from the previous section. Define

,

𝑣

(cid:12)
(cid:12)
(cid:12)
(cid:12)





𝑣 ( ¯𝑎) ∈ 𝑞 (cid:0)𝑣 (𝐷)(cid:1)
∥𝑣base ∥ ≤ 𝑟
∥𝑣num ∥ ≤ 𝑟

Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) =




where of course 𝑣 = (𝑣base, 𝑣num), and where we write ∥𝑣base ∥
for ∥𝑣base (Nbase (𝐷)) ∥ and likewise for ∥𝑣num ∥ when 𝐷 is clear
from the context. Next, the idea is essentially the same as before:
define the measure of certainty as the probability that a valuation
picked uniformly at random belongs to Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)). There
is a problems though: the set of valuations 𝑣base is discrete and
there are finitely many valuations 𝑣base with ∥𝑣base ∥ ≤ 𝑟 , while for
valuations 𝑣num we need to measure their volume. We thus need to
combine the two in one measure somehow.

To do this, we relativize Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) for each fixed valua-
tion 𝑣base on base-type nulls. That is, we define Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) |
𝑣base) as

{𝑣num | (𝑣base, 𝑣num) ∈ Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠))} .
Since we associate 𝑣num with 𝑣num (Nnum (𝐷)) ⊆ R𝑘 , we have
Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣base) ⊆ R𝑘 and thus, if it is measurable, we use
its volume as its measure. Then we define

Vol𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) =

(cid:213)

∥𝑣base ∥ ≤𝑟

Vol(cid:0)Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣base)(cid:1)

as the combined measure of Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) taking into account
the discrete nature of valuations on base type and continuous mea-
sure of valuations on the numerical type.

Of course as 𝑟 grows, so can Vol𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)), since vectors
𝑣num (Nnum (𝐷)) come from 𝐵𝑘
𝑟 , the 𝑘-dimensional ball of radius 𝑟 .
So we normalize this measure, to make it a number between 0 and 1
that determines the likelihood of ( ¯𝑎, ¯𝑠) being an answer. For that, we
divide by the largest possible value of Vol𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)). We have at
most ⌊𝑟 ⌋𝑚 valuations 𝑣base with ∥𝑣base ∥ ≤ 𝑟 (we take ⌊𝑟 ⌋ if 𝑟 is not
an integer), and for each of them Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣base) ⊆ 𝐵𝑘
𝑟
and thus its volume is bounded by Vol(𝐵𝑘
𝑟 ). Summing up, the maxi-
𝑟 ) · ⌊𝑟 ⌋𝑚 and thus we define
mum value of Vol𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) is Vol(𝐵𝑘
the likelihood as

𝜇𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) =

Vol𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠))
Vol(𝐵𝑘
𝑟 ) · ⌊𝑟 ⌋𝑚

∈ [0, 1]

(2)

to be this normalized value.

Finally, as before, we look at the asymptotic behavior of this

measure:

𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) = lim𝑟 →∞

(3)
Convention For Boolean queries 𝑞, we shall write 𝜇 (𝑞, 𝐷) instead
of the more formal 𝜇 (𝑞, 𝐷, ()), i.e., omitting the empty tuple of
arguments.

𝜇𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) .

Remark What if there are no numerical variables? In this case
Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣base) is a subset of R0, i.e., just a point. If we
assume that Vol(R0) = 1, then in this case 𝜇 (𝑞, 𝐷, ¯𝑎) can be easily
seen to coincide with the measure defined in [27] and presented
in the previous section. Thus we indeed provide a proper general-
ization of the framework of measuring certainty of answers to the
case of numerical domains.

5 THE MEASURE IS WELL DEFINED
We provided a formal definition of the measure of certainty
𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) as a number in the interval [0, 1], indicating how
likely a tuple ( ¯𝑎, ¯𝑠), consisting of elements of base and numerical
types, is to be an answer to 𝑞 on an incomplete database 𝐷. The
definition however took for granted the existence of certain quan-
tities, and thus we need to prove that 𝜇 is actually well defined.
Specifically, there are two elements of the definition of 𝜇 where
well-definedness needs to be formally proved.

• We defined measure 𝜇 using volumes of sets

Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣base) ⊆ R𝑘 . But even though
Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣base) is a bounded set, as a subset of 𝐵𝑘
𝑟 ,
a priori it does not mean that it is measurable and the volume
is defined.

• We then defined 𝜇 as the limit of some ratio (see equations
(2) and (3)) as 𝑟 grows. However, it is not clear a priori that
the limit always exists.

Our goal now is to prove that 𝜇 is well-defined for all queries
in FO(+, ·, <). In the process of showing this, we also reduce the
problem of computing 𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) to the problem of analyzing
asymptotic behavior of formulae in the first-order theory of the
reals. This connection will be essential for obtaining complexity
results.

The existence of volumes. For this, we need to prove that sets

Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣base) ⊆ R𝑘 are Lebesgue-measurable.

Proposition 5.1. For every query 𝑞 ∈ FO(+, ·, <), database 𝐷,
tuples ¯𝑎 and ¯𝑠, and valuation 𝑣base
of base type nulls in 𝐷, the set
Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣base) is Lebesgue-measurable, i.e., its volume
exits.

proof sketch. To see this, simply put in the definition of each
relation 𝑅 in 𝑣base (𝐷) (as an explicit disjunction of tuples) in 𝑞 to see
that Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣base) is definable in FO theory of the real
field ⟨R, +, ·, <⟩. The latter, by cell decomposition, is a finite union
□
of cells, each of which is open and thus measurable, cf. [34].

The existence of limits. We prove this in two steps. First, we
restate the definition of 𝜇 by fully eliminating its dependence on
valuations over the base type. Then we show how to eliminate
the database and reduce the question to the existence of limits of
volumes of some definable sets over the real field ⟨R, +, ·, <⟩, which
is actually known.

Eliminating base type. We now show that to compute the mea-
sure, we can completely disregard valuations 𝑣base. Recall that when
there is no numerical type, 𝜇 (𝑞, 𝐷, ¯𝑎) ∈ {0, 1}, and 𝜇 (𝑞, 𝐷, ¯𝑎) = 1
iff ¯𝑎 is returned by the naive evaluation of 𝑞 on 𝐷. This observa-
tion makes it possible to eliminate base type valuations from the
consideration of the asymptotic behavior of 𝜇𝑟 .

For 𝑞, 𝐷, and a tuple ¯𝑎, we say that a valuation 𝑣base is bijective
(with respect to 𝑞, 𝐷, ¯𝑎) if 𝑣base is a bijection and its range is disjoint
from Cbase (𝐷). Then it easy to see that for sufficiently large 𝑟 and
two bijective valuations 𝑣base and 𝑣 ′

base we have
Vol(cid:0)Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣base)(cid:1)
)(cid:1)
base

= Vol(cid:0)Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣 ′

Furthermore, as 𝑟 grows, almost all (asymptotically) valuations on
base type become bijective. This easily leads to the following.

Proposition 5.2. For a query 𝑞, a database 𝐷, and tuples ¯𝑎, ¯𝑠 of
be a bijective valuation with

values of free variables of 𝑞, let 𝑣base
respect to 𝑞, 𝐷, ¯𝑎. Then

𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) = lim𝑟 →∞

Vol(cid:0)Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣base)(cid:1)
Vol(𝐵𝑘
𝑟 )

.

proof sketch. Using Proposition 5.2 and the observation that
Supp𝑟 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠) | 𝑣base) = Supp𝑟 (𝑞, 𝑣base (𝐷), (𝑣base ( ¯𝑎), ¯𝑠)) ,
we conclude that for computing 𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) we only need to look
at databases 𝐷 without base type nulls. And once we have such
databases, we can further reduce the problem to that for formulae
□
that do not even mention database.

Eliminating database relations. We now look at databases that
have only numerical nulls. Consider such a database 𝐷 with
Nnum (𝐷) = {⊤1, . . . , ⊤𝑘 }, an FO(+, ·, <) query 𝑞( ¯𝑥, ¯𝑦), and tuples ¯𝑎
over Cbase (𝐷) and ¯𝑠 over Cnum (𝐷) ∪ Nnum (𝐷) of the same length
as ¯𝑥 and ¯𝑦 respectively. Let R stand for the structure ⟨R, +, ·, <⟩, i.e.,
the real closed field.

Proposition 5.3. Under the assumptions above, there exists,
and can be constructed in time polynomial in the size of 𝐷, a
quantifier-free formula 𝜑𝑞,𝐷, ¯𝑎,¯𝑠 (𝑧1, . . . , 𝑧𝑘 ) over R such that R |=
𝜑𝑞,𝐷, ¯𝑎,¯𝑠 (𝑧1, . . . , 𝑧𝑘 ) iff 𝑣 ¯𝑧 ( ¯𝑎, ¯𝑠) ∈ 𝑞 (cid:0)𝑣 ¯𝑧 (𝐷)(cid:1), where 𝑣 ¯𝑧 assigns 𝑧𝑖 to
each ⊤𝑖 for 𝑖 ≤ 𝑘.

proof sketch. To see this, first associate with each numerical
null ⊤𝑖 a new variable 𝑧𝑖 . Then replace all quantifiers ∃𝑥 over base
type variables by explicit disjunction (cid:212)𝑎 ∈Cbase (𝐷) and quantifiers
∃𝑦 over numerical type variables by (cid:212)𝑠 ∈Cnum (𝐷)∪Nnum (𝐷) . In the
resulting formula all atomic relational formulae are of the form
𝑅(¯𝑐, ¯𝑢), where ¯𝑐 is a tuple of base type constants, and ¯𝑢 is a tuple
of numerical type constants and nulls of some length 𝑝. We then
replace such formula by (cid:212) (cid:211)𝑝
𝑗 = 𝑤 ◦
𝑢◦
𝑗 where the disjunction is
taken over all tuples (¯𝑐, ¯𝑤) that occur in relation 𝑅 in 𝐷 and 𝑐◦ = 𝑐
for 𝑐 ∈ Cnum while ⊤◦

𝑖 = 𝑧𝑖 .

𝑗=1

, . . . , 𝑢◦

Next, using standard arithmetic, we can assume that each atom
𝑡 < 𝑡 ′ is given as a Boolean combinations of statements 𝑝 ( ¯𝑢){<, =
}𝑝 ′( ¯𝑢), where 𝑝, 𝑝 ′ are polynomials. We then again replace such for-
mulae by 𝑝 (𝑢◦
𝑝 ), resulting in the desired
1
formula 𝜑 ( ¯𝑧). Verifying correctness of the translation is routine.
Thus, the set of all valuations 𝑣 witnessing 𝑣 ( ¯𝑎, ¯𝑠) ∈ 𝑞 (cid:0)𝑣 (𝐷)(cid:1) is
defined by a formula over R. Now consider an arbitrary formula
𝜑 ( ¯𝑧) with | ¯𝑧| = 𝑘 over R and define

𝑝 ){<, =}𝑝 ′(𝑢◦
1

, . . . , 𝑢◦

𝜈 (𝜑) = lim𝑟 →∞

Vol(cid:0)𝜑 (R𝑘 ) ∩ 𝐵𝑘
𝑟
Vol(𝐵𝑘
𝑟 )

(cid:1)

,

(4)

where 𝜑 (R𝑘 ) = {¯𝑠 ∈ R𝑘 | R |= 𝜑 ( ¯𝑎)}. That is, the ratio
Vol(cid:0)𝜑 (R𝑘 ) ∩ 𝐵𝑘
𝑟 ) shows the proportion of the
𝑟
𝑘-dimensional ball of radius 𝑟 occupied by vectors satisfying 𝜑, and
□
𝜈 (𝜑) defines the asymptotic behavior of this ratio.

(cid:1)/Vol(𝐵𝑘

Next we use a known fact, namely that 𝜈 (𝜑) exists for every
formula 𝜑 over R. It was shown in [11], using results of [20, 22], how
to definably approximate volumes of sets definable in R. Combining
it with previous results, we obtain the main result of this section.

Theorem 5.4. For an FO(+, ·, <) query 𝑞, a database 𝐷, and tuples
¯𝑎, ¯𝑠 of values of free variables of 𝑞, the measure 𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) is well-
defined and its value is a number in in the interval [0, 1]. Moreover,
one can construct in polynomial time in the size of 𝐷 a formula 𝜑 ( ¯𝑧)
over R, where | ¯𝑧| is the number of numerical nulls in 𝐷, such that

𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) = 𝜈 (𝜑) .

We finish this section by returning to the example from the in-
troduction and computing 𝜇 (𝑞, 𝐷, (𝑠)), where 𝑠 refers to the only
market segment present in the database. Since a bijective valua-
tion 𝑣base will not map ⊥′′ to 𝑠, we conclude that by Proposition
5.2 and Theorem 5.4 that 𝜇 (𝑞, 𝐷, (𝑠)) = 𝜈 (𝜑) where 𝜑 is given

by (1). Then an easy calculation shows that for 𝑟 > 8, the ratio
Vol(𝜑 (R2) ∩ 𝐵2
𝑟 ) is in the interval
(cid:34) ( 𝜋

(cid:35)

−

8
𝜋𝑟

,

( 𝜋
2 − arctan( 10
2𝜋

7 ))

𝑟 )/Vol(𝐵2
2 − arctan( 10
2𝜋

7 ))

which shows that 𝜈 (𝜑) = ( 𝜋
2 −arctan( 10
7 ))/2𝜋 ≈ 0.097, or, if we are
only interested in the proportion of the positive quadrant satisfying
this constraint, it is four times that, i.e., ≈ 0.388 as shown in the
Introduction.

6 APPROACHES TO COMPUTING AND
APPROXIMATING THE MEASURE

Now that we have the measure of certainty defined, the question
is how to compute it. This would be an algorithm that computes
a value of a function in the interval [0, 1], rather than a decision
problem.

Of course one can attempt to compute the function 𝜇. We shall
see though that there are two obstacles along the way. First, the
value of 𝜇 may be irrational and thus needs to be approximated.
Second, computing the value of 𝜇, even if it is rational, may be
computationally hard. Ideally, we would like it to be in FP, the class
of functions computable in polynomial time. However, we will see
that even for simple queries, the problem could be hard for FP#𝑃 ,
the class of functions computable in polynomial time with calls to
a #𝑃 (and thus intractable) oracle.

Starting with the first issue we show the following.
Proposition 6.1. Consider the Boolean query 𝑞 = ∃𝑥, 𝑦 𝑅(𝑥, 𝑦) ∧
(𝑥 ≥ 0) ∧ (𝑦 ≤ 𝛼 · 𝑥) and a database 𝐷 in which 𝑅 has a single tuple
𝑅(⊤, ⊤′). Then 𝜇 (𝑞, 𝐷) ∈ Q iff 𝛼 = 0, ±1.

proof idea. Indeed, a simple calculation shows that 𝜇 (𝑞, 𝐷) =
arctan(𝛼)/2𝜋 + 1/2, and then one can show that it is irrational
□
except for 𝛼 = 0 or 𝛼 = ±1.

In some cases, we can guarantee rationality of 𝜇 (𝑞, 𝐷) but then

the complexity jumps.

Proposition 6.2. For queries in FO(<), the value 𝜇 (𝑞, 𝐷) is al-
ways rational. However, there are queries for which computing 𝜇 (𝑞, 𝐷)
for queries from CQ(<) is FP

#𝑃 -hard in data complexity.

proof sketch. Following [13], computing the rational number
𝑛
𝑚 = 𝜇 (𝑞, 𝐷) is FP#𝑃 -hard if we can find a query 𝑞 and databases 𝐷
such that computing the denominator 𝑚 is done in polynomial time,
and computing the numerator 𝑛 is #𝑃-hard. We can show how to use
a CQ(<) query to compute the number of satisfying assignments
to a 3DNF in 𝑘 variables which is known to be #𝑃-hard [33]; the
denominator in this case is 2𝑘 , the number of all assignments, and
□
thus can be computed efficiently in binary.

These propositions show that it is necessary to look for approxi-
mation schemes. Towards that, let us recall some basic definitions,
cf. [36]. Given a problem of computing a function 𝑓 ( ¯𝑥), we say that
a randomized algorithm 𝐴( ¯𝑥, 𝜖) is an FPRAS (fully polynomial-time
randomized approximation scheme) for it if 𝐴 runs in time poly-
nomial in the size of ¯𝑥 and 1/𝜖, and the value output[𝐴( ¯𝑥, 𝜖)] it
produces satisfies

(1 − 𝜖)𝑓 ( ¯𝑥) ≤ output[𝐴( ¯𝑥, 𝜖)] ≤ (1 + 𝜖) 𝑓 ( ¯𝑥) ,

4 . The confidence level 3

with probability at least 3
4 can be changed
to any arbitrary value 1−𝛿 for 𝛿 ∈ (0, 1) by running 𝐴 polynomially
many times over the same input; alternatively 𝛿 can be set up as a
parameter of the FPRAS and the algorithm 𝐴 then needs to run in
time that is also polynomial in log(1/𝛿).

However, even with order constraints, we cannot get an FPRAS
for general FO queries, under a widely believed complexity-
theoretic assumption.

Theorem 6.3. If NP ⊈ BPP, then there is no FPRAS for computing

𝜇 (𝑞, 𝐷) for FO(<) queries.

proof sketch. In this case, we produce an FO query 𝑞 ∈ FO(<)
and, for each 3CNF formula 𝜓 with 𝑛 variables, a database 𝐷𝜓
♯𝜓
2𝑛 , where ♯𝜓 is the number of satisfying
such that 𝜇 (𝑞, 𝐷𝜓 ) =
assignments to 𝜓 . In turn, this proves that 𝜓 is satisfiable if and
only if 𝜇 (𝑞, 𝐷𝜓 ) > 0, and therefore the associated decision problem
is NP-hard. This observation together with a standard complexity
theoretic argument allows us to conclude that, if an FPRAS for
□
𝜇 (𝑞, 𝐷) exists, then 𝑁 𝑃 ⊈ 𝐵𝑃𝑃.

Alternatives. Negative results shown earlier provide us with clear

limitations as to what our options could be:

• We could try to find an FPRAS for conjunctive queries, as

nothing in our results precludes that; or

• We can try to find a weaker form of approximations for

arbitrary FO(+, ·, <) queries.

This is exactly what we do. In the next section we prove the ex-
istence of an FPRAS for CQ(+, <), conjunctive queries with linear
constraints. Then, for a weaker form of approximation, we note
that the function 𝜇 has its values in the interval [0, 1]. Thus, unlike
FPRAS that provides multiplicative error guarantees, for small val-
ues of 𝜖 we can also settle for a randomized algorithm 𝐴(𝑞, 𝐷, ( ¯𝑎, ¯𝑠))
that returns an answer with additive error guarantees, i.e.,

|𝜇 (𝑞, 𝐷) − output[𝐴(𝑞, 𝐷, ( ¯𝑎, ¯𝑠))]| < 𝜖 .

We provide such an algorithm for all FO(+, ·, <) queries. The algo-
rithm is polynomial in data complexity, i.e., it runs in time polyno-
mial in the size of 𝐷 and 1/𝜖. We will then show experimentally that
its performance is feasible not only in theory but also in practice.

7 FRPAS FOR CONJUNCTIVE QUERIES
While, in the general case, computing the likelihood of an answer
is hard and cannot be efficiently approximated, in the important
restricted case of conjunctive queries with linear constraints ap-
proximation is still possible. These queries are essentially joins of
relations where join conditions can involve linear (in)equalities
such as rrp ≤ 0.9 · p in the notation of the example in the In-
troduction, saying that our price is less than 90% of that of the
competition.

We show that for this class of queries, CQ(+, <), we can design
an efficient approximation for the measure 𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) in terms
of data complexity. This is based on reduction to formulae in the
theory of addition over the reals, along the lines of Proposition 5.3,
and then applying an FPRAS for computing the volume of a union
of convex bodies based on the existence of some oracles [9].

Given a query 𝑞 ∈ CQ(+, <), we define the function problem
𝜇𝑞 (𝐷, ( ¯𝑎, ¯𝑠)) that asks for the values of 𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠), with input 𝐷
and ( ¯𝑎, ¯𝑠). In other words, this reformulation corresponds to the
function problem of computing 𝜇 with respect to data complexity.
Theorem 7.1. Let 𝑞( ¯𝑥, ¯𝑦) be a query in CQ(+, <). There exists
an FPRAS for 𝜇𝑞 (𝐷, ( ¯𝑎, ¯𝑠)), with input database 𝐷, tuple ( ¯𝑎, ¯𝑠), and
𝜖 ∈ (0, 1].

That is, there is a randomized algorithm 𝐴𝑞 (𝐷, 𝜖) that runs in
time polynomial in 𝐷 and 1/𝜖 and returns a value 𝑎 such that the
ratio 𝑎/𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) is in the interval [1 − 𝜖, 1 + 𝜖].

proof sketch. To prove this, we take 𝑞( ¯𝑥, ¯𝑦), a database 𝐷 with
𝑛 numerical nulls, and tuples ¯𝑎, ¯𝑠 and use Theorem 5.4 to produce a
formula 𝜑 ( ¯𝑧) with 𝑛 free variables over R so that 𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) =
𝜈 (𝜑). To get to the setting where we can define an FPRAS for
𝜇𝑞 (𝐷, ( ¯𝑎, ¯𝑠)), we need to analyze this translation in a bit more detail.
Recall that first we had to apply a bijective valuation 𝑣base to 𝐷 to
get base type nulls out of the way. Since this can be produced in
linear time, we can just assume that such a valuation already was
applied, and neither 𝐷 nor ¯𝑎 have base type nulls.

Next, analyzing the construction of 𝜑 given in Proposition 5.3
and given the fact that it is applied to a conjunctive query where
existential quantifiers translate into disjunctions and the rest of the
formula is a conjunction of predicates, we observe the following
about formula 𝜑:

• 𝜑 is a formula over ⟨R, +, <⟩, i.e., it does not use multiplica-

tion;

• 𝜑 is of the form (cid:212)𝑖 (cid:211)𝑗 𝛽𝑖 𝑗 ( ¯𝑧) where each 𝛽𝑖 𝑗 ( ¯𝑧) is an atomic
formula over ⟨R, +, <⟩, i.e., of the form ¯𝑐 · ¯𝑧{<, =}𝑐 ′, where
¯𝑐 · ¯𝑧 is the scalar product, ¯𝑐 ∈ R𝑛 and 𝑐 ′ ∈ R.

For such a formula 𝜑, let ˜𝜑 denote its homogenized version, i.e.,
the formula obtained from 𝜑 by replacing each atomic formula of
numerical type ¯𝑐 · ¯𝑧 < 𝑐 ′ by ¯𝑐 · ¯𝑧 < 0. Then we know (see [11]) that

𝜈 (𝜑) =

Vol( ˜𝜑 (R𝑛) ∩ 𝐵𝑛
1 )
Vol(𝐵𝑛
1

)

.

Next, using the special form of 𝜑, we see that ˜𝜑 (R𝑛) is a finite
union of sets 𝑋1, . . . , 𝑋𝑚, corresponding to the disjuncts of 𝜑, and
each such set is convex, as the intersection of half-spaces defined
by ¯𝑐 · ¯𝑧 < 0. Furthermore, the intersection of each of these sets 𝑋𝑖
with 𝐵𝑛

1 is convex.

While the problem of computing the volume of a union of con-
vex sets is intractable, in [9] it is shown that it admits an FPRAS
under the assumption that each of the sets is given by an individual
membership oracle that, for a set 𝑋 ∈ R𝑛 and a point ¯𝑎 ∈ R𝑛, tests
whether ¯𝑎 ∈ 𝑋 . Since sets are represented as conjunctions of linear
constraints and constraints ∥ ¯𝑎∥ ≤ 𝑟 . We have these polynomial-
time oracles and can apply the FPRAS of [9] to approximate both
Vol( ˜𝜑 (R𝑛) ∩𝐵𝑛
1 ). It is then an easy observation that we
have an FPRAS for their ratio, i.e., 𝜈 (𝜑), and thus for 𝜇𝑞 (𝐷, ( ¯𝑎, ¯𝑠)),
□
completing the proof.

1 ) and Vol(𝐵𝑛

8 FIRST-ORDER QUERIES AND ADDITIVE

ERROR APPROXIMATIONS

In Section 7, we proved the existence of an FPRAS for conjunctive
queries with linear constraints. This algorithm has two drawbacks:

it is limited to conjunctive queries in order to reduce them to a
formula of a specific shape, and then it uses that formula in combi-
nation with computational geometry algorithms that may not be
best suited for implementation inside a DBMS. In contrast, we now
prove that, if one settles for an additive error, it is possible to devise
an efficient algorithm for all first-order queries with polynomial
constraints. This algorithm has the advantage that it is natural to
implement, as will be shown in Section 9 that presents an initial
experimental evaluation of our approach.

First, we define what it means to have an additive fully
polynomial-time randomized approximation scheme (AFPRAS) for a
problem of computing a function 𝑓 ( ¯𝑥). An AFPRAS is an algorithm
𝐴( ¯𝑥, 𝜖) that produces a value output[𝐴( ¯𝑥, 𝜖)] in time polynomial
in ¯𝑥 and 1/𝜖 such that

𝑓 ( ¯𝑥) − 𝜖 < output[𝐴( ¯𝑥, 𝜖)] < 𝑓 ( ¯𝑥) + 𝜖

holds with probability at least 3/4.

Once again, we are interested in data complexity, and thus the
problem we analyze is that of computing the function 𝜇𝑞 (𝐷, ( ¯𝑎, ¯𝑠)),
as in the previous section: for a fixed query 𝑞( ¯𝑥, ¯𝑦), on the input
that consists of a database 𝐷 and values ¯𝑎 for base type variables ¯𝑥
and ¯𝑠 for numerical type variables ¯𝑦, compute 𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)).

Theorem 8.1. If 𝑞 ∈ FO(+, ·, <), then there is an AFPRAS for the

function problem 𝜇𝑞 (𝐷, ( ¯𝑎, ¯𝑠)).

In the rest of the section we explain how to construct this algo-
rithm. As in Section 7, we start with 𝑞( ¯𝑥, ¯𝑦), a database 𝐷 with 𝑛
numerical nulls, and tuples ¯𝑎, ¯𝑠 and use Theorem 5.4 to produce a for-
mula 𝜑 ( ¯𝑧) with 𝑛 free variables over R so that 𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) = 𝜈 (𝜑).
If 𝜑 only uses linear constraints, and is in disjunctive normal form,
the existence of an AFPRAS follows from results of [11]. Now, how-
ever, the query 𝑞 is in FO(+, ·, <) and thus 𝜑 could be a formula
over R of arbitrary shape that also uses multiplication, which com-
plicates the search for an AFPRAS considerably.

The idea of an AFPRAS is to test the asymptotic behavior of 𝜑 by
testing the truth value of 𝜑 far away enough from the origin, along
different directions. To formalize this, for a formula 𝜑 ( ¯𝑧) over R
with 𝑛 free variables, and for ¯𝑎 ∈ R𝑛, define

𝑓𝜑, ¯𝑎 (𝑘) =

(cid:26) 1,
0,

if R |= 𝜑 (𝑘 · ¯𝑎)
if R ̸|= 𝜑 (𝑘 · ¯𝑎)

where 𝑘 · ¯𝑎 is the result of multiplying each component of ¯𝑎 by
𝑘. Intuitively 𝑓𝜑, ¯𝑎 (𝑘) defines the behavior of 𝜑 along the direction
¯𝑎. Functions built this way exhibit a monotonic behavior as the
following lemma shows.

Lemma 8.2. For each formula 𝜑 ( ¯𝑧) over R with 𝑛 free variables,

and ¯𝑎 ∈ R𝑛,

𝑓𝜑, ¯𝑎 (𝑘) ∈ {0, 1} .

lim
𝑘→∞

proof sketch. To prove this, notice that the limit, if it exists,
is either 0 or 1, as the function 𝑓𝜑, ¯𝑎 (𝑘) assumes only these val-
ues. It remains to argue why lim𝑘→∞ 𝑓𝜑, ¯𝑎 (𝑘) exists for all ¯𝑎 ∈ R𝑛.
Each atomic formula of 𝜑 is given as a (multivariate) polynomial
constraint. Each of these possesses, into each particular direction
represented by ¯𝑎 ∈ R𝑛, finitely many zeros. As a consequence, there
is a largest such zero, say 𝑘+, after which all constraints in 𝜑 are

either fulfilled or unfulfilled forever. Hence, the value of 𝑓𝜑, ¯𝑎 (𝑘)
will be constant for all 𝑘 ≥ 𝑘+.
□

Using the result presented above, one can prove that the value of
𝜈 (𝜑) depends only on the asymptotic behavior of 𝑓𝜑, ¯𝑎, for ¯𝑎 taken
from the unit ball 𝐵𝑛
1 .
Lemma 8.3. For 𝜑 ( ¯𝑧) as in Lemma 8.2,

𝜈 (𝜑) =

Vol({ ¯𝑎 ∈ 𝐵𝑛

1 | lim𝑘→∞ 𝑓𝜑, ¯𝑎 (𝑘) = 1})

Vol(𝐵𝑛
1

)

.

proof sketch. First note that by the proof of Lemma 8.2, the
set in the numerator is definable in R and thus is measurable and
its volume exists. By analogy with the proof of Lemma 8.2, the pro-
portion of directions into which all constraints of 𝜑 are eventually
always true or false, will be the same regardless of the radius of the
ball, and thus to compute it we can use the unit ball and consider
the asymptotic behavior of the constraints into each direction. □

The idea of the algorithm then is to sample sufficiently many
directions ¯𝑎 ∈ 𝐵𝑛
1 , and test whether lim𝑘→∞ 𝑓𝜑, ¯𝑎 (𝑘) = 1. To prove
that this intuition gives us an efficient algorithm, we first need
to prove that testing whether lim𝑘→∞ 𝑓𝜑, ¯𝑎 (𝑘) = 1 can be done
efficiently. This is indeed the case, as the following statement shows.

Lemma 8.4. Given 𝜑 ( ¯𝑧) as in previous lemmas, and ¯𝑎 ∈ 𝐵𝑛
1

, check-
ing whether lim𝑘→∞ 𝑓𝜑, ¯𝑎 (𝑘) = 1 can be done in polynomial time
with respect to the size of ¯𝑎 and 𝜑.

proof sketch. Indeed, from 𝜑, we first compute the formula
𝜑 ¯𝑥/𝑘 · ¯𝑎 in one free variable 𝑘 by substituting 𝑘 ·𝑎𝑖 for each variable 𝑧𝑖 .
Observe that each atomic formula of 𝜑 ¯𝑥/𝑘 · ¯𝑎 is of the form 𝑝 (𝑘){<, =
}0, where 𝑝 is a univariate polynomial. For each such polynomial, to
test whether the corresponding constraint is asymptotically fulfilled,
we only need to consider the coefficients of the terms of highest
□
degree.

We finally use all these lemmas to outline the AFPRAS algorithm.
Assume an input database 𝐷 with |Nnum (𝐷)| = 𝑛, a tuple ( ¯𝑎, ¯𝑠) of
the appropriate type, and a value 𝜖 ∈ (0, 1]. First, using Theorem
5.4 we produce, in polynomial time, a formula 𝜑 ( ¯𝑧) with 𝑛 free
variables over R so that 𝜇 (𝑞, 𝐷, ( ¯𝑎, ¯𝑠)) = 𝜈 (𝜑). Then, to compute
𝜈 (𝜑) approximately, we sample, uniformly at random, 𝑚 vectors
¯𝑎1, . . . , ¯𝑎𝑚 from the unit 𝑛-dimensional ball (see [8] for a description
of such a sampling). Then, we compute the values of

𝐴𝑚 (𝐷) =

𝑚
(cid:213)

𝑖=1

lim𝑘→∞ 𝑓𝜑, ¯𝑎𝑖 (𝑘)
𝑚

.

Using the Chernoff bound, we can prove that, if 𝑚 ≥ 𝜖−2, then
𝐴𝑚 (𝐷) ∈ [𝜇𝑞 (𝐷, ( ¯𝑎, ¯𝑠)) − 𝜖, 𝜇𝑞 (𝐷, ( ¯𝑎, ¯𝑠)) + 𝜖] with probability at
least 3
4 , which shows that for such 𝑚 the algorithm is the desired
□
AFPRAS.

9 EXPERIMENTAL EVALUATION
We have implemented the additive error approximation algorithm
from Section 8. Its main goal was not to produce a fully fledged
system for generating a confidence level for queries, but rather
to make sure that the proposed theoretical scheme, in addition to
having nice theoretical properties, is also feasible in practice.

Specifically, we used this implementation to evaluate a set of join
queries with numerical conditions that are fairly typical decision
support queries. We evaluated the algorithm for various precision
levels ranging from 0.1 to 0.01, essentially corresponding to getting
one or two decimal digits correctly. The main parameter to measure
was the time overhead required to run the algorithm. The key
conclusion is that for common decision queries, and even fairly
small 𝜖 (i.e., high confidence level), getting approximate results is
feasible at least for medium size databases.

Implementation. The implementation of the approximation algo-
rithm itself is done in Python, using a standard library (Numpy) to
perform the random sampling. It works on the output of a query, un-
der naive evaluation, produced by the Postgres database, to evaluate
confidence level in tuples it generates. Our implementation follows
very closely the theoretical algorithm presented in Section 8. Given
a conjunctive query 𝑞 and a database 𝐷, we first use Postgres to
construct a compact representation of the formulae 𝜑𝑞,𝐷, ¯𝑎,¯𝑠 defined
in Section 5. With it in place, we run the Monte-Carlo phase of our
algorithm, with only one major difference.

In the theoretical algorithm, given a database 𝐷 with 𝑛 different
numerical nulls and a query 𝑞, we sample a vector ¯𝑧 uniformly at
random from the 𝑛-dimensional unit ball and check the asymptotic
behavior of 𝑞 along the direction of ¯𝑧. To sample ¯𝑧 uniformly, we use
the standard technique of sampling 𝑛 independent and normally
distributed random variables, and then scale the vector obtained
this way to fit the unit ball, see [8].

While this technique is efficient in theory, in practice sampling
normally distributed random variables requires the use of a rel-
atively slow Python routine. When there are many nulls in the
database, this inevitably leads to poor performances. In our im-
plementation, instead of sampling the whole ¯𝑧, we only sample as
many many coordinates of ¯𝑧 as needed to replace the nulls that
affect the result of the input query. As the final scaling does not
affect the direction represented by ¯𝑎, we can safely use this partial
vector for our asymptotic analysis. This optimization saves us a
considerable amount of calls to the sampling routine and speeds
up the computation substantially.

Dataset and Queries. To perform our experiments, we used syn-
thetic data generated for a schema of a sales database resembling
the one we used in the introduction. It has the following relations.
• Products(id, seg, rrp, dis) has product ids, their mar-
ket segment (seg), recommended retail price (rrp), and the
intended discount (dis).

• Orders(id, pr, q, dis) contains information about possi-
ble future orders, including the product id (pr), the quantity
ordered (q), and the extra discount applied on the order (dis).
In this case, the final discount depends on the quantity, and
is calculated as dis/q.

• Market(seg, rrp, dis) stores the recommended retail
price (rrp) and the forecast discount (dis) of the best com-
peting product on the market.

To produce the data, we used DataFiller [10], a tool for the gen-
eration of synthetic data. We generated an SQL database of about
200K tuples, with null values. To use this data in our assessment,
we replaced each SQL’s null with a different string so to obtain the

equivalent of a database with marked nulls. We then loaded the
data into Postgres to perform our evaluation.

We used three typical decision support queries in our experi-
ments. They ask for segments of the market where competitive
advantage could be achieved, for having much better offers than
the market, and for other companies offering unfair discounts. As
is common in such decision support queries, we put a limit clause
to present the analyst with an analyzable sample from the database.
Below we give SQL code and brief descriptions of queries.

• Competitive Advantage Query: What are the market seg-
ments where the company will have a competitive advan-
tage?

SELECT P.seg
FROM Products P, Market M
WHERE P.seg = M.seg AND

P.rrp * P.dis <= M.rrp * M.dis

LIMIT 25

• Never Knowingly Undersold Query: What are the products
that will sell for less than half of the best price on the market?

SELECT P.id
FROM Products P, Orders O, Market M
WHERE P.seg = M.seg AND

(P.rrp * P.dis * (O.q/O.dis)
<= 0.5 * M.id * M.dis)

LIMIT 25

• Unfair Discount Query: What are the orders that apply a
discount at least 60% higher than the intended campaign
discount?

SELECT O.id
FROM Products P, Orders O, Market M
WHERE P.id = O.pr AND

(P.rrp * P.dis O.q) <= (0.5 * M.id * M.dis)

LIMIT 25

Experimental Setup and Results. We ran our implementation for
each of the above queries, using errors from 0.01 to 0.1 with a step
of 0.005. This resulted in 19 different figures for each of the queries.
All experiments ran on a machine with an Intel(R) Core(TM) i5-
8500 CPU @ 3.00GHz processor, 16GB of RAM, 500GB hard-disk,
running Xubuntu 19.04.

The results are shown in Figure 1. Along the 𝑥 axis, we show
error levels 𝜖, and along the 𝑦 axis we show running time of the
algorithm. Smaller values of 𝜖 correspond to higher precision and
thus more sampling and longer running times. If we are interested
only in the precision up to the first decimal digit (𝜖 ∈ (0, 0.1]), then
our implementation, for all of the queries, runs in less than a second.
This is a very small overhead that produces valuable information
on the likelihood of tuples returned by the naive implementation of
a query, and in particular tells the analyst whether results that may
be based on incomplete information warrant further investigation.
It is also reasonable to expect that such a level of precision would
be acceptable. After all, it should not matter that much whether
the likelihood of a tuple is 0.8 or 0.7. As the precision increases,
and 𝜖 decreases, the performance degrades as expected. But even
in the case when the second decimal digits matters (𝜖 ∈ (0, 0.01]),
the overhead time required to perform our analysis stays below 10
seconds for every single query.

Figure 1: Experimental results

10 FUTURE WORK
The good theoretical bounds as well as promising results of the
experimental evaluation suggest pushing this approach further in
at least several directions.

The most important one is to move away from the totally ag-
nostic approach where we say that each numerical null can be in-
terpreted by an arbitrary element of the numerical domain. While
this was motivated by the usual assumption in the literature on
incomplete databases that nulls can denote arbitrary elements, and
as such it was appropriate for this initial study, in real life with
typed columns additional constraints are possible. Most commonly
we have restrictions on ranges of numerical attributes. For example,
price is expected to be positive, while discount is expected to be
a number in [0, 1]. However the model we proposed here is very
easily adaptable to such modifications. We can simply add such
constraints in both the numerator and denominator of the ratio
defining the measure of certainty. It then needs to be seen how
the AFPRAS algorithm is to be adjusted. The model is also suit-
able for adding probability distributions associated with particular
columns, which can simply replace uniform distributions over the
𝑛-dimensional ball.

So far we measured the likelihoods of answers by computing vol-
umes in R𝑛. In the case of integer type, we can provide an alternative
measure by counting the number of integer lattice points. In gen-
eral one may expect to obtain similar results as the 𝑛-dimensional

100959085807570656055504540353025201510(cid:15)·1030.0940.7771.5222.3734.2019.458Time(seconds)QueryCompetitiveAdvantage100959085807570656055504540353025201510(cid:15)·1030.0220.5602.224Time(seconds)QueryNeverKnowinglyUndersold100959085807570656055504540353025201510(cid:15)·1030.0130.5911.332Time(seconds)QueryUnfairDiscountgeneralization of the Gauss circle problem says that the number
of integer points inside 𝐵𝑛
𝑟 is a good approximation of Vol(𝐵𝑛
𝑟 ),
i.e., the difference between such number and Vol(𝐵𝑛
𝑟 ) is of the or-
der 𝑜 (Vol(𝐵𝑛
𝑟 )), cf. [23]. Extending the measure in the integer case
may also offer connections with the recent work on open world
probabilistic databases over countable domains [17]. Open world
databases with uncountable domains [18] offer another possible
direction for further exploration.

As further extensions, one could look at extensions with aggre-
gate queries, where reasoning about certainty is significantly more
complicated [2] but ideas related to approximation might perhaps
be helpful in the case of numerical answers. Yet another connection
worth exploring is with the study of the asymptotic behavior of
queries over random databases under the constraint that the ex-
pected size of the database remains constant [12], as this is indeed
close to the model we have with substituting values for nulls.

Acknowledgment Work partially supported by EPSRC grants
M025268, N023056, and S003800. Part of this work was done while
the third author was at IRIF, Université de Paris, and DI-ENS, sup-
ported by a grant from the Foundation Sciences Mathématiques de
Paris.

REFERENCES
[1] Serge Abiteboul and Oliver Duschka. 1998. Complexity of answering queries

using materialized views. In PODS. 254–263.

[2] Foto Afrati and Phokion Kolaitis. 2008. Answering aggregate queries in data

exchange. In PODS. 129–138.

[3] Foto Afrati, Chen Li, and Prasenjit Mitra. 2002. Answering Queries Using Views

with Arithmetic Comparisons. In PODS. 209–220.

[4] Foto Afrati, Chen Li, and Vassia Pavlaki. 2008. Data exchange in the presence of

arithmetic comparisons. In EDBT. 487–498.

[5] Marcelo Arenas, Pablo Barceló, Leonid Libkin, and Filip Murlak. 2014. Foundations

of Data Exchange. Cambridge University Press.

[6] Leopoldo Bertossi. 2011. Database Repairing and Consistent Query Answering.

Morgan&Claypool Publishers.

[7] Meghyn Bienvenu and Magdalena Ortiz. 2015. Ontology-Mediated Query An-
swering with Data-Tractable Description Logics. In Reasoning Web. 218–307.
[8] Avrim Blum, John Hopcroft, and Ravindran Kannan. 2020. Foundations of Data

Science. CUP.

[9] Karl Bringmann and Tobias Friedrich. 2010. Approximating the volume of unions
and intersections of high-dimensional geometric objects. Comput. Geom. 43, 6-7
(2010), 601–610.

[10] Fabien Coelho. [n.d.]. DataFiller – generate random data from database schema.

https://www.cri.ensmp.fr/people/coelho/datafiller.html.

[11] Marco Console, Matthias Hofer, and Leonid Libkin. 2019. Measuring the Likeli-

hood of Numerical Constraints. In IJCAI.

[12] Nilesh N. Dalvi, Gerome Miklau, and Dan Suciu. 2005. Asymptotic Conditional

Probabilities for Conjunctive Queries. In ICDT. 289–305.

[13] Bettina Fazzinga, Sergio Flesca, and Francesco Parisi. 2015. On the Complexity
of Probabilistic Abstract Argumentation Frameworks. ACM Trans. Comput. Log.
16, 3 (2015), 22:1–22:39.

[14] Yunjun Gao and Xiaoye Miao. 2018. Query Processing over Incomplete Databases.

Morgan & Claypool Publishers.

[15] Amélie Gheerbrant and Leonid Libkin. 2015. Certain Answers over Incomplete
XML Documents: Extending Tractability Boundary. Theory Comput. Syst. 57, 4
(2015), 892–926.

[16] Amélie Gheerbrant, Leonid Libkin, and Cristina Sirangelo. 2014. Naïve evaluation
of queries over incomplete databases. ACM Trans. Database Syst. 39, 4 (2014),
31:1–31:42.

[17] Martin Grohe and Peter Lindner. 2019. Probabilistic Databases with an Infinite

Open-World Assumption. In PODS. 17–31.

[18] Martin Grohe and Peter Lindner. 2020. Infinite Probabilistic Databases. In 23rd
International Conference on Database Theory (ICDT 2020) (Leibniz International
Proceedings in Informatics (LIPIcs)), Carsten Lutz and Jean Christoph Jung (Eds.),
Vol. 155. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, Dagstuhl, Germany,
16:1–16:20. https://doi.org/10.4230/LIPIcs.ICDT.2020.16

[19] Tomasz Imielinski and Witold Lipski. 1984. Incomplete information in relational

databases. J. ACM 31, 4 (1984), 761–791.

[20] Marek Karpinski and Angus Macintyre. 1997. Approximating the Volume of
General Pfaffian Bodies. In Structures in Logic and Computer Science, A Selection
of Essays in Honor of Andrzej Ehrenfeucht. 162–173. https://doi.org/10.1007/
3-540-63246-8_10

[21] Anthony C. Klug. 1988. On conjunctive queries containing inequalities. J. ACM

35, 1 (1988), 146–160.

[22] Pascal Koiran. 1995. Approximating the volume of definable sets. In FOCS. 134–

141. https://doi.org/10.1109/SFCS.1995.492470

[23] E. Krätzel. 1988. Lattice Points. Kluwer.
[24] Gabriel Kuper, Leonid Libkin, and Jan Paredaens. 2000. Constraint Databases.

Springer.

[25] Maurizio Lenzerini. 2002. Data integration: a theoretical perspective. In ACM

Symposium on Principles of Database Systems (PODS). 233–246.

[26] Leonid Libkin. 2016. SQL’s Three-Valued Logic and Certain Answers. ACM Trans.

Database Syst. 41, 1 (2016), 1:1–1:28.

[27] Leonid Libkin. 2018. Certain Answers Meet Zero-One Laws. In PODS. 195–207.
[28] Witold Lipski. 1984. On Relational Algebra with Marked Nulls. In PODS. 201–203.
[29] Ju. V. Matijasevic and Julia Robinson. 1975. Reduction of an arbitrary diophantine

equation to one in 13 unknowns. Acta Arith. 27 (1975), 521–553.

[30] Antonella Poggi, Domenico Lembo, Diego Calvanese, Giuseppe De Giacomo,
Maurizio Lenzerini, and Riccardo Rosati. 2008. Linking Data to Ontologies. J.
Data Semantics 10 (2008), 133–173.

[31] D. Suciu, D. Olteanu, C. Re, and C. Koch. 2011. Probabilistic Databases. Mor-

gan&Claypool Publishers.

[32] Transaction Processing Performance Council 2014. TPC Benchmark™ H Standard
Specification. Transaction Processing Performance Council. Revision 2.17.1.
[33] Leslie G. Valiant. 1979. The Complexity of Enumeration and Reliability Problems.

SIAM J. Comput. 8, 3 (1979), 410–421. https://doi.org/10.1137/0208032

[34] Lou Van den Dries. 1998. Tame Topology and o-minimal Structures. Vol. 248.

Cambridge university press.

[35] Ron van der Meyden. 1997. The Complexity of Querying Indefinite Data about

Linearly Ordered Domains. J. Comput. Syst. Sci. 54, 1 (1997), 113–135.

[36] Vijay V. Vazirani. 2001.

Approximation Algorithms.

Springer.

http://www.springer.com/computer/theoretical+computer+science/book/
978-3-540-65367-7

