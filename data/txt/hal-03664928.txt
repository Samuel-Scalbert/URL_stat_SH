Eﬀicient Provenance-Aware Querying of Graph
Databases with Datalog
Yann Ramusat, Silviu Maniu, Pierre Senellart

To cite this version:

Yann Ramusat, Silviu Maniu, Pierre Senellart. Eﬀicient Provenance-Aware Querying of Graph
Databases with Datalog. GRADES-NDA 2022 - Joint Workshop on Graph Data Management Expe-
riences & Systems (GRADES) and Network Data Analytics (NDA), Jun 2022, Philadelphia, United
States. ￿hal-03664928￿

HAL Id: hal-03664928

https://inria.hal.science/hal-03664928

Submitted on 11 May 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Efficient Provenance-Aware Querying
of Graph Databases with Datalog

Yann Ramusat
DI ENS, ENS, PSL University, CNRS,
Inria
Paris, France
yann.ramusat@ens.fr

Silviu Maniu
Université Paris-Saclay, LISN, CNRS
Gif-sur-Yvette, France
silviu.maniu@lisn.upsaclay.fr

Pierre Senellart
DI ENS, ENS, PSL University, CNRS,
Inria & IUF
Paris, France
pierre@senellart.com

ABSTRACT
We establish a translation between a formalism for dynamic pro-
gramming over hypergraphs and the computation of semiring-
based provenance for Datalog programs. The benefit of this trans-
lation is a new method for computing the provenance of Data-
log programs for specific classes of semirings, which we apply to
provenance-aware querying of graph databases. Theoretical results
and practical optimizations lead to an efficient implementation us-
ing Soufflé, a state-of-the-art Datalog interpreter. Experimental
results on real-world data suggest this approach to be efficient in
practical contexts, competing with dedicated solutions for graphs.

CCS CONCEPTS
• Information systems → Data provenance; • Theory of com-
putation → Data provenance.

KEYWORDS
Datalog, Provenance, Semirings, Graph Databases, Dynamic Pro-
gramming, Transportation Networks

1 INTRODUCTION
Data provenance [3] is meta-information that is kept along and
tracked about data throughout its life cycle, and which is prop-
agated to query results during query evaluation; applications of
such information include traceability, explainability, or uncertainty
management [21]. A notion of provenance for Datalog queries
was introduced by Green, Karvounarakis, and Tannen [9]. Based
on the algebraic structure of semirings to encode additional meta-
information about query results, it extends the notion of semiring
provenance for the positive fragment of the relational algebra, also
introduced in [9]. The full provenance of a Datalog program (i.e.,
the provenance associated to each derived tuple) is expressed as
a system of equations over an 𝜔-continuous semiring. This forms
a “computational” notion of provenance, where operations (and
queries) over provenance values are permitted.

A recent line of work has adapted this provenance model for
simple navigational queries (regular path queries [2] or RPQs) over
graph databases [18, 19]. Several provenance-aware algorithms
have been proposed, and a taxonomy of semiring classes, based
on their properties, has been established in [19]. Those works aim
at identifying, for a set of important semiring classes, the most
appropriate algorithm for provenance-aware querying, enabling
real-world applications.

The aim of the current work is to extend these approaches to
queries that go beyond the simple class of RPQs, relying on the

rich literature around Datalog provenance to provide better so-
lutions for provenance computations over graph databases. Our
objective is to obtain new effective solutions to practical scenarios
(i.e., real transportation networks over large areas). In the process,
we generalize the methods for provenance computation over graph
databases of [19] to Datalog. Our main motivation is thus is to allow
new opportunities for querying graph databases in the presence of
provenance information, as Datalog is significantly more expressive
than RPQs. Given the fact that RPQs are expressible in Datalog, we
can therefore either compose or take the union of several RPQs.
Whereas RPQs only select pair of vertices, with Datalog we can go
beyond binary output relations; this allows to retrieve, for instance,
paths that are restricted to pass through another node.

Our contributions can be organized into three parts. We first
establish a correspondence between dynamic programming over
hypergraphs (as introduced in [10] under the name of weighted hy-
pergraphs) and the proof-theoretic definition of the provenance for
Datalog programs. We provide both-way translations and charac-
terize for which class of semirings the best-weight derivation in the
hypergraph corresponds to the provenance of the initial Datalog
program.

The translation we thus introduced permits us to obtain a version
of Knuth’s generalization of Dijkstra’s algorithm to the grammar
problem [13], adapted to the case of Datalog provenance computa-
tion. In the special setting where all hyperedges are of arity 1, we
obtain the classical notion of semiring-based provenance for graph
databases [18]. In the general setting, the algorithm steadily gener-
alizes to Datalog the adapted Dijkstra’s algorithm from [18], under
the same assumptions on the properties of the underlying semiring.
Such algorithm is unlikely to be efficient as-is in practical contexts.
The main issue is closely related to the inefficiency of basic Dat-
alog evaluation: many computations of facts (provenance values)
have already been deduced, leading to redundant computations.
Nevertheless, we show that the semi-naïve evaluation strategy for
Datalog is also applicable in our setting. An added advantage is
that it facilitates extending existing Datalog solvers to provenance
annotations and their computation.

We implement our strategy by extending Soufflé [11], a state-of-
the-art Datalog interpreter. We apply our solution to the computa-
tion of the provenance of various graph queries (translated into Dat-
alog programs) on several real-world graph datasets. Experiments
witness that the performance of the implementation competes with
previous dedicated solutions specific to graph databases, while al-
lowing much more expressive queries than the works of [18, 19]:
RPQs only select pairs of vertices joinable by a path whose label
belongs to a given regular language. We focus our experiments

on graph patterns that are combinations and/or unions of RPQs,
using the expressive power of Datalog. We show that for this wider
class of navigational queries, our method performs well in practice.
Notably, the ratio between the running time of our approach com-
pared to plain Datalog evaluation (not tracking the provenance) is
experimentally bounded by a small constant factor. Moreover, in
case of large output DB size, the average number of output tuples
processed by seconds is up to a million, permitting a reasonable
running time in practice for large datasets.

The paper is organized as follows. We start by introducing in
Section 2 basic concepts on semirings and we recall the definition
of provenance for Datalog programs. We formulate and prove in
Section 3 the correspondence between weighted hypergraphs and
semiring-based provenance for Datalog programs. In Section 4, we
present the adapted version of Knuth’s algorithm for the grammar
problem and discuss theoretical aspects of its optimization. We
then dive into the practical aspects of its implementation using
Soufflé, and present in Section 5 experimental results witnessing
the efficiency of our approach for practical scenarios. We finally
discuss in Section 6 the related work. For space reasons, proofs are
deported to an appendix.

2 BACKGROUND
In the following, we recall basic concepts of semiring theory un-
derlying the optimization techniques we provide in this paper. For
more background on the theory and applications of semirings, ex-
amples of relevant semirings, as well as references to the literature
on advanced notions of semiring theory, see [19]. We mostly fol-
low the definitions from [19] and also highlight notions that occur
under different names depending on the application domain.

Definition 1 (Semiring). A semiring is an algebraic structure
(𝑆, ⊕, ⊗, ¯0, ¯1) where 𝑆 is some set, ⊕ and ⊗ are binary operators
over 𝑆, and ¯0 and ¯1 are elements of 𝑆, satisfying the following
axioms:

• (𝑆, ⊕, ¯0) is a commutative monoid: (𝑎 ⊕ 𝑏) ⊕ 𝑐 = 𝑎 ⊕ (𝑏 ⊕ 𝑐),

𝑎 ⊕ 𝑏 = 𝑏 ⊕ 𝑎, 𝑎 ⊕ ¯0 = ¯0 ⊕ 𝑎 = 𝑎;

• (𝑆, ⊗, ¯1) is a monoid: (𝑎 ⊗𝑏) ⊗𝑐 = 𝑎 ⊗ (𝑏 ⊗𝑐), ¯1⊗𝑎 = 𝑎 ⊗¯1 = 𝑎;
• ⊗ distributes over ⊕: 𝑎 ⊗ (𝑏 ⊕ 𝑐) = (𝑎 ⊗ 𝑏) ⊕ (𝑎 ⊗ 𝑐);
• ¯0 is an annihilator for ⊗: ¯0 ⊗ 𝑎 = 𝑎 ⊗ ¯0 = ¯0.

A semiring is commutative if for all 𝑎, 𝑏 ∈ 𝑆, 𝑎 ⊗ 𝑏 = 𝑏 ⊗ 𝑎. A
semiring is idempotent if for all 𝑎 ∈ 𝑆, 𝑎 ⊕ 𝑎 = 𝑎. For an idempotent
semiring we can introduce the natural order defined by 𝑎 ⩽ 𝑏
iff 𝑎 ⊕ 𝑏 = 𝑎.1 Note that this order is compatible with the two
binary operations of the semiring: for all 𝑎, 𝑏, 𝑐 ∈ 𝑆, 𝑎 ⩽ 𝑏 implies
𝑎 ⊕ 𝑐 ⩽ 𝑏 ⊕ 𝑐 and 𝑎 ⊗ 𝑐 ⩽ 𝑏 ⊗ 𝑐. This is also called the monotonicity
property.

An important property is that of k-closedness [17], i.e., a semir-
ing is 𝑘-closed if: ∀𝑎 ∈ 𝑆, (cid:201)𝑘+1
𝑎𝑖 . Here, by 𝑎𝑖 we
𝑖=0
denote the repeated application of the ⊗ operation 𝑖 times, i.e.,
𝑎𝑖 = 𝑎 ⊗ 𝑎 ⊗ · · · ⊗ 𝑎
. 0-closed semirings (i.e., those in which ∀𝑎 ∈
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:125)

𝑎𝑖 = (cid:201)𝑘

𝑖=0

(cid:124)

(cid:123)(cid:122)
𝑖

1There are unfortunately two definitions of natural order commonly found in the
literature; we use here that found in [10, 17] which matches the standard order on
the tropical semiring; other works [9, 15, 19] define it as the reverse order. Our choice
obviously has some impacts: in particular, when defining Datalog provenance, we
need greatest fixpoints in lieu of the least fixpoints used in [9, 15].

Yann Ramusat, Silviu Maniu, and Pierre Senellart

𝑆, ¯1 ⊕ 𝑎 = ¯1) have also been called absorptive, bounded, or simple
depending on the literature. Note that any 0-closed semiring is
idempotent (indeed, 𝑎 ⊕ 𝑎 = 𝑎 ⊗ (¯1 ⊕ ¯1) = 𝑎 ⊗ ¯1 = 𝑎) and therefore
admits a natural order.

Huang [10] introduces the notion of superiority of a semiring 𝑆
with respect to a partial order ⩽, defined by: ∀𝑎, 𝑏 ∈ 𝑆 𝑎 ⩽ 𝑎 ⊗𝑏, 𝑏 ⩽
𝑎 ⊗ 𝑏. The natural order satisfies this notion for 0-closed semirings:
Lemma 2. Let 𝑆 be an idempotent semiring and ⩽ the natural order
over 𝑆. Then 𝑆 is superior with respect to ⩽ if and only if 𝑆 is 0-closed.

An easier way of understanding natural order in 0-closed semir-
ings is to note that for any idempotent semiring 𝑆, ¯0 is the greatest
element (∀𝑎 ∈ 𝑆, 𝑎 ⊕0 = 𝑎 ⩽ ¯0) while, if the semiring is also 0-closed
(i.e., bounded), ¯1 is the smallest (∀𝑎 ∈ 𝑆, ¯1 ⊕ 𝑎 = ¯1 so ¯1 ⩽ 𝑎). Thus a
bounded semiring 𝑆 verifies ¯1 ⩽ 𝑎 ⩽ ¯0 for all 𝑎 ∈ 𝑆.

Definition 3 (𝜔-Continuous semiring). An idempotent semiring

(𝑆, ⊕, ⊗, ¯0, ¯1) is 𝜔-continuous if:

(1) (𝑆, ⩾) is an 𝜔-complete partial order, i.e., the infimum inf
𝑖 ∈N

𝑎𝑖

of any infinite chain 𝑎0 ⩾ 𝑎1 ⩾ . . . exists in 𝑆.

(2) both addition and multiplication are 𝜔-continuous in both
arguments, i.e., for all 𝑎 ∈ 𝑆 and infinite chain 𝑎0 ⩾ 𝑎1 ⩾
(𝑎 ⊗ 𝑎𝑖 ),
. . . , (𝑎 ⊕ inf
𝑖 ∈N
𝑎𝑖 ) ⊗ 𝑎 = inf
( inf
𝑖 ∈N
𝑖 ∈N

𝑎𝑖 ) = inf
𝑖 ∈N
(𝑎𝑖 ⊗ 𝑎).

(𝑎 ⊕ 𝑎𝑖 ), (𝑎 ⊗ inf
𝑖 ∈N

𝑎𝑖 ) = inf
𝑖 ∈N

In such semirings we can define countable sums:

(cid:202)

𝑛 ∈N

𝑎𝑛 = inf
𝑚 ∈N

𝑚
(cid:202)

𝑖=0

𝑎𝑖 .

A system of fixpoint equations over an 𝜔-continuous semiring
𝑆 is a finite set of equations: 𝑋1 = 𝑓1 (𝑋1, 𝑋2, . . . , 𝑋𝑛), . . . , 𝑋𝑛 =
𝑓𝑛 (𝑋1, 𝑋2, . . . , 𝑋𝑛), where 𝑋1, . . . , 𝑋𝑛 are variables and 𝑓1, . . . 𝑓𝑛 are
polynomials with coefficients in 𝑆. We extend the notion of natural
order from semiring elements to tuples of semiring elements by
simply considering the product order. We then have the follow-
ing on solutions of a system of equations over an 𝜔-continuous
semiring:

Theorem 4 (Theorem 3.1 of [15]). Every system of fixpoint equa-
tions X = 𝑓 (X) over a commutative 𝜔-continuous semiring has a
greatest solution gfp(𝑓 ) w.r.t. ⩽, and gfp(𝑓 ) is equal to the infimum
of the Kleene sequence: gfp(𝑓 ) = inf
𝑚 ∈N

𝑓 𝑚 (¯0).

We now recall some basics about the Datalog query language
and refer to [1] for more details. A Datalog rule is of the form
𝑅( (cid:174)𝑥) :- 𝑅1 ( (cid:174)𝑥1),
. . . , 𝑅𝑛 ( (cid:174)𝑥𝑛) with 𝑅’s representing relations of a
given arity and the (cid:174)𝑥’s tuples of variables of corresponding arities.
Variables occurring on the left-hand side, the head of the rule,
are required to occur in at least one of the atoms on the right-
hand side, the body of the rule. A Datalog program is a finite set of
Datalog rules. We call fact a rule with an empty body and variables
replaced by constants. We divide relations into extensional ones
(which can only occur as head of a fact, or in rule bodies) and
intensional ones (which may occur as heads of a non-fact rule). The
set of extensional facts is called the extensional database (EDB). We
distinguish one particular relation occurring in the head of a rule,
the output predicate of the Datalog program. We refer to [1] for the
semantics of such a program and the notion of derivation tree.

Efficient Provenance-Aware Querying of Graph Databases with Datalog

path(Paris, London) 1
𝑟2

path(Paris, London) 3

𝑟1

path(Paris, Brussels) 1

edge(Brussels, London) 0

edge(Paris, London) 3

𝑟1

edge(Paris, Brussels) 1

edge(Paris, London) :-

edge(Paris, Brussels) :-

edge(Brussels, London) :-

3
1
0

path(x, y) :- edge(x, y)

dummy

path(x, y) :- path(x, z),

edge(z, y)

𝑟1

𝑟2

Figure 1: Derivation trees along their weights for the fact
path(Paris, London) using the transitive closure Datalog pro-
gram over the tropical semiring with an EDB containing 3
facts.

There are two ways of defining the provenance of a Datalog
program 𝑞 with output predicate 𝐺 over an 𝜔-continuous semiring.
We can first base this definition on the proof-theoretic definition of
standard Datalog:

Definition 5 (Proof-theoretic definition for Datalog provenance
[9]). Let (𝑆, ⊕, ⊗, ¯0, ¯1) be a commutative 𝜔-continuous semiring
and 𝑞 a Datalog program with output predicate 𝑆 and such that all
extensional facts 𝑅(𝑡 ′) are annotated with an element of 𝑆, denoted
𝑞
𝑅 (𝑡 ′). Then the provenance of 𝐺 (𝑡) for 𝑞, where 𝐺 (𝑡) is in
as prov
the output of 𝑞, is defined as:

𝑞
𝐺 (𝑡) =
prov

(cid:202)

𝜏 yields 𝑡

(cid:204)

(cid:169)
(cid:173)
𝑡 ′ ∈ leaves(𝜏)
(cid:171)

𝑞
𝑅 (𝑡 ′)(cid:170)
prov
(cid:174)
(cid:172)

.

The first sum ranges over all the derivation trees of the fact 𝑡
(see Figure 1 for examples of derivation trees), the second sum
ranges over all leaves of the tree (extensional facts). This definition
describes how the provenance propagates across the deduction
process given an initial assignment of provenance weights to the
𝑞
extensional relations of 𝑞, prov
𝑅.

Example 6. The tropical semiring is (R+ ∪ {∞}, min, +, ∞, 0). It is
a 0-closed (and thus idempotent) 𝜔-continuous semiring. We show
in Figure 1 an example Datalog program (bottom right) with tropical
semiring annotations on extensional edge facts, as well as the (only)
two derivation trees of the fact path(Paris, London) along their
weight. This witnesses that the provenance of path(Paris, London)
is min(1 + 0, 3) = 1.

Since some tuples can have infinitely many derivations, the
Datalog semantics of Definition 5 cannot be used as an algorithm.
As pointed out in [9], it is possible instead to use a fixpoint-theoretic
definition of the provenance of a Datalog query 𝑞: introduce a fresh
variable for every possible intensional tuple (i.e., every possible
ground atom), and produce for this variable an equation that reflects
the immediate consequence operator T𝑞 – extensional facts appearing
as their semiring annotations in these equations. This yields a
system of fixpoint equation 𝑓𝑞. The provenance of 𝐺 (𝑡) for 𝑞 is now
simply the value of the variable corresponding to 𝐺 (𝑡) in gfp(𝑓𝑞).
The fixpoint-theoretic definition directly yields an algorithm,
albeit a very inefficient one because of the need of generating a
rule for every intensional tuple.

3 DATALOG PROVENANCE AND DYNAMIC
PROGRAMMING OVER HYPERGRAPHS
We now show how to convert a Datalog program into a weighted
hypergraph (as introduced in [10]) and characterize the semirings
where the best-weight derivation in the hypergraph corresponds
to the provenance for the initial Datalog program, mimicking the
proof-theoretic definition. We first recall basic definitions and no-
tation related to hypergraphs.

Definition 7 (Weighted hypergraph [10]). Given a semiring 𝑆, a
weighted hypergraph on 𝑆 is a pair 𝐻 = ⟨𝑉 , 𝐸⟩, where 𝑉 is a finite
set of vertices and 𝐸 is a finite set of hyperedges, and each element
𝑒 ∈ 𝐸 is a triple 𝑒 = ⟨ℎ(𝑒), T(𝑒), 𝑓𝑒 ⟩ with ℎ(𝑒) ∈ 𝑉 its head vertex,
T(𝑒) ∈ 𝑉 an ordered list of tail vertices and 𝑓𝑒 a weight function
from 𝑆 |T(𝑒) | to 𝑆.

We note |𝑒 | = |T(𝑒)| the arity of a hyperedge. If |𝑒 | = 0, we say 𝑒
is nullary and then 𝑓𝑒 () is a constant, an element of the semiring;
we assume there exists at most one nullary edge for a given vertex.
In that case, 𝑣 = ℎ(𝑒) is called a source vertex and we note 𝑓𝑒 () as 𝑓𝑣.
The arity of a hypergraph is the maximum arity of any hyperedge.
The backward-star BS(𝑣) of a vertex 𝑣 is the set of incoming hy-
peredges {𝑒 ∈ 𝐸 | ℎ(𝑒) = 𝑣 }. The graph projection of a hypergraph
𝐻 = ⟨𝑉 , 𝐸⟩ is a directed graph 𝐺 = (𝑉 , 𝐸 ′) where 𝐸 ′ = {(𝑢, 𝑣) |
∃𝑒 ∈ BS(𝑣), 𝑢 ∈ T(𝑒)}. A hypergraph 𝐻 is acyclic if its graph pro-
jection 𝐺 is acyclic; then a topological ordering of 𝐻 is an ordering
of 𝑉 that is a topological ordering of 𝐺.

With these definitions in place, we can encode a Datalog pro-
gram with semiring annotations as a weighted hypergraph in a
straightforward manner:

Definition 8 (Hypergraph representation of a Datalog program).
Given a Datalog program 𝑞 described with a set of rules {𝑞1, . . . , 𝑞𝑛 }
and the semiring 𝑆 used for annotations, we define the weighted
hypergraph representation of 𝑞 as 𝐻𝑞 = ⟨𝑉𝑞, 𝐸𝑞⟩ with 𝑉𝑞 being
all ground atoms and, for each instantiation of a rule 𝑡 ( (cid:174)𝑥) ←
𝑟1 ( (cid:174)𝑥1), . . . , 𝑟𝑛 ( (cid:174)𝑥𝑛), a corresponding edge ⟨𝑡 ( (cid:174)𝑥), (𝑟1 ( (cid:174)𝑥1), . . . , 𝑟𝑛 ( (cid:174)𝑥𝑛)),
⊗⟩. For a fact 𝑅( (cid:174)𝑥) ∈ EDB(𝑞) we add a nullary edge 𝑒 with ℎ(𝑒) =
𝑞
𝑅 ( (cid:174)𝑥).
𝑅( (cid:174)𝑥) and 𝑓𝑒 = prov

The notion of derivations is the hypergraph counterpart to paths
in graph. We recall the definition of derivations and we define it in
a way that is reminiscent of Datalog-related notions.

Definition 9 (Derivation in hypergraph [10]). We recursively de-
fine a derivation 𝐷 of a vertex 𝑣 in a hypergraph 𝐻 (as a pair formed
of a hyperedge and a list of derivations), its size |𝐷 | (a natural
integer) and its weight 𝑤 (𝐷) (a semiring element) as follows:

• If 𝑒 ∈ BS(𝑣) with |𝑒 | = 0, then 𝐷 = ⟨𝑒, ⟨⟩⟩ is a derivation of

𝑣, |𝐷 | = 1, and 𝑤 (𝐷) = 𝑓𝑒 ().

• If 𝑒 ∈ BS(𝑣) with |𝑒 | ⩾ 0, 𝐷𝑖 is a derivation of 𝑇𝑖 (𝑒) for
𝑖 = 1 . . . |𝑒 |, then 𝐷 = ⟨𝑒, ⟨𝐷1 · · · 𝐷 |𝑒 |⟩⟩ is a derivation of 𝑣,
|𝐷 | = 1 + (cid:205)|𝑒 |
𝑖=1

|𝐷𝑖 |, 𝑤 (𝐷) = 𝑓𝑒 (𝑤 (𝐷1), . . . , 𝑤 (𝐷 |𝑒 |)).

We note D𝐻 (𝑣) the set of derivations of 𝑣 in 𝐻 .

When modeling Datalog provenance in a semiring 𝑆 as weighted
hypergraphs on 𝑆, all non-source weight functions are bound to
the ⊗ operation of the semiring. Note that, if 𝑆 is idempotent, the

natural order on 𝑆 induces an ordering on derivations: 𝐷 ⩽ 𝐷 ′ if
𝑤 (𝐷) ⩽ 𝑤 (𝐷 ′).

We now show that in this formalism, the Datalog provenance of
an output predicate can be understood as the best-weight for the
corresponding vertex in the hypergraph.

Definition 10 (Best-weight [10]). The best-weight 𝛿𝐻 (𝑣) of a ver-
tex 𝑣 of a hypergraph 𝐻 on a semiring (𝑆, ⊕, ⊗, ¯0, ¯1) is the weight
of the best derivation of 𝑣:

𝛿𝐻 (𝑣) =

(cid:26) 𝑓𝑣
(cid:201)

𝐷 ∈D𝐻 (𝑣)

𝑤 (𝐷)

if v is a source vertex;
otherwise.

The best-weight generally requires additional properties of either
the hypergraph or the semiring to be well-defined. Acyclicity for
the hypergraph is a sufficient condition. Existence of an infinitary
summation operator in the semiring extending ⊕, guaranteed in
𝜔-continuous semirings, is also a sufficient condition. To guarantee
semantics compatible with the intuitive meaning of provenance,
a more restrictive sufficient condition is for the semiring to be a
𝑐-complete star-semiring [14], see [19] for details.

We can now show that Datalog provenance can be computed
through the formalism of weighted hypergraphs. Let us start with
a lemma exhibiting a one-to-one mapping between derivations in
the hypergraph and proofs in Datalog.

Lemma 11. For any Datalog query 𝑞 and grounding of an atom 𝑣

of 𝑞, there is a bijection between D𝐻𝑞 (𝑣) and {𝜏 | 𝜏 yields 𝑣 }.

We then show that the weight of each derivation of a tuple is

equal to the corresponding proof tree weight in Datalog.

Lemma 12. For any Datalog query 𝑞 and grounding of an atom 𝑣

of 𝑞, for any derivation 𝐷 of 𝑣 in 𝐻𝑞 we have
𝑞
𝑅 (𝑡 ′)
prov

𝑤 (𝐷) =

(cid:204)

𝑡 ′ ∈ 𝑙𝑒𝑎𝑣𝑒𝑠 (𝜏𝐷 )
where 𝜏𝐷 is the proof tree corresponding to 𝐷 in the bijection given
by Lemma 11.

Finally, we obtain:

Theorem 13. Let 𝑡 be a tuple of a Datalog program 𝑞 with output
𝑞
predicate 𝐺 and 𝐻𝑞 its hypergraph representation, then prov
𝐺 (𝑡) =
𝛿𝐻𝑞 (𝐺 (𝑡)).

4 BEST-FIRST METHOD
Knuth [13] generalized the Dijkstra algorithm to what he calls the
grammar problem (i.e., finding the best-weight derivation from a
given non-terminal, where each terminal has a specific weight and
each rule comes with an associated weight function). This has been
identified as corresponding to the search problem in a monotonic
superior hypergraph – i.e., for each 𝑒 ∈ 𝐻 , 𝑓𝑒 is monotone and
superior in each argument (see Table 3 in [10]). We showed in
Lemma 2 that superiority corresponds to 0-closedness in semirings
with natural orders. The definition of the grammar problem assumes
a total order on weights as the weights are real numbers. In the
special case where all hyperedges are of arity 1 (and all weight
functions bound to ⊗), we obtain the classical notion of semiring-
based provenance for graph databases [18]. Thus, Knuth’s algorithm
can be seen as a generalization to hypergraphs (and therefore, by the

Yann Ramusat, Silviu Maniu, and Pierre Senellart

results of the previous section, to Datalog provenance computation)
of the modified Dijkstra algorithm from [18], working on 0-closed
totally-ordered semirings, which are generalizations of the tropical
semiring.

Optimized version of Best-First method. In the original paper of
Knuth [13], the question of efficient construction of the set of candi-
date facts for the extraction of the minimal-valued fact is not dealt
with. A lot of redundant work may be carried out if the implemen-
tation is not carefully designed.

In the following, we show how to obtain a ready-to-be-implemen-
ted version incorporating ideas from the semi-naïve evaluation of
Datalog programs. Semi-naïve evaluation of Datalog, as described
in [1, Chapter 13] introduces a number of ideas aiming at improving
the efficiency of the naïve Datalog evaluation method; we show
how to leverage them in our setting.

The naïve evaluation of a Datalog program 𝑞 processes iteratively,
applying at each step the consequence operator T𝑞. Many redundant
derivations are computed, leading to practical inefficiency. The
semi-naïve evaluation addresses this problem by considering only
facts derived using at least one new fact found at the previous step.
Note, however, that while many new facts can be found at one
step of the semi-naïve evaluation, only one is to be added by the
Best-First method to respect the ⩽-minimality ordering of added
facts.

Algorithm 1 Basic semi-naïve version of Best-First method for
Datalog provenance
Require: Datalog query 𝑞, EDB 𝐷 with provenance indications over a

0-closed totally-ordered semiring 𝑆.

Ensure: full Datalog provenance for the IDB of 𝑞.
1: function Relax(𝑟0 ( (cid:174)𝑥0), 𝑆)
2:

for each instantiation of a rule

𝑟 ( (cid:174)𝑥) ← 𝑟1 ( (cid:174)𝑥1), . . . , 𝑟𝑚 ( (cid:174)𝑥𝑚), . . . , 𝑟𝑛 ( (cid:174)𝑥𝑛)

where 𝑟𝑖 ( (cid:174)𝑥𝑖 ) ∈ 𝐷 ∪ 𝑆 ∪ {𝑟0 ( (cid:174)𝑥0) }, 1 ⩽ 𝑖 < 𝑚, 𝑟𝑚 ( (cid:174)𝑥𝑚) = 𝑟0 ( (cid:174)𝑥0) and
𝑟𝑖 ( (cid:174)𝑥𝑖 ) ∈ 𝐷 ∪ 𝑆, 𝑚 < 𝑖 ⩽ 𝑛 do

𝜈 (𝑟 ( (cid:174)𝑥)) ⊕= (cid:203)
1⩽𝑖 ⩽𝑛

𝑟𝑖 ( (cid:174)𝑥𝑖 )

3:

4:
5: 𝐼 ← ∅
6: Let 𝜈 be the function that maps all facts of 𝐷 to their annotation in 𝑆

and all potential facts of the intensional schema of 𝑞 to ¯0

7: for each intensional atom 𝑟 ( (cid:174)𝑥) ∉𝐼 do
8:

for each instantiation of a rule 𝑟 ( (cid:174)𝑥) ← 𝑟1 ( (cid:174)𝑥1), . . . , 𝑟𝑛 ( (cid:174)𝑥𝑛) with

𝑟𝑖 ( (cid:174)𝑥𝑖 ) ∈ 𝐷 do

𝑟𝑖 ( (cid:174)𝑥𝑖 )

9:

𝜈 (𝑟 ( (cid:174)𝑥)) ⊕= (cid:203)
1⩽𝑖 ⩽𝑛
10: while min𝜈\𝐼 𝑟 ( (cid:174)𝑥) ≠ ¯0 do
11:
12:
13: return 𝜈

Add such minimal 𝑟 ( (cid:174)𝑥) to 𝐼
Relax(𝑟 ( (cid:174)𝑥), 𝐼 \ 𝑟 ( (cid:174)𝑥))

This algorithm starts by initializing the priority queue with IDB
facts that are derivable from EDB facts. Then, at each step, the
minimum valued-fact is added, and only derivations using this
new fact are computed to update the value of the facts in 𝐼 . This
algorithm stops whenever: 1. the maximal value is reached for a
candidate fact, or 2. the list is empty - the minimal value of the list
is by default the maximal value of the semiring.

Efficient Provenance-Aware Querying of Graph Databases with Datalog

Theorem 14. Algorithm 1 computes the full Datalog provenance

for 0-closed totally-ordered semirings.

Precedence graph. The structure of the Datalog program can be
analysed to provide clues about the predicates to focus on. Follow-
ing [1], we introduce the notion of precedence graph 𝐺𝑃 of a Datalog
program 𝑃. The nodes are the IDB predicates and the edges are
pairs of IDB predicates (𝑅, 𝑅′) where 𝑅′ occurs at the head of a rule
of 𝑃 with 𝑅 belonging to the tail. 𝑃 is a recursive program if 𝐺𝑃 has
a directed cycle. Two predicates 𝑅 and 𝑅′ are mutually recursive
if 𝑅 = 𝑅′ or 𝑅 and 𝑅′ participate in the same cycle of 𝐺𝑃 . This
defines equivalence classes. Following a topological ordering on the
equivalence classes, Algorithm 1 is sequentially applied to compute
the IDB predicates in the current equivalence class, considering
previous equivalence classes as EDB predicates. Soufflé natively
supports this optimization.

Generalization to distributive lattices. In [19], a new algorithm
was introduced for single-source provenance in graph databases
over 0-closed multiplicatively idempotent semirings (equivalent to
distributive lattices). That method is relevant for semirings that are
0-closed but for which Dijkstra’s algorithm is not directly applicable
as the semiring is not totally ordered. A similar gap also appears
when we consider provenance over Datalog queries (see Section 6).
Thus, we show how to apply the method from [19] for computing
provenance for Datalog queries over distributive lattices.

Algorithm 2 Generalized Best-first method for Datalog provenance
Require: 𝑞 a Datalog query with provenance indication over a 0-closed

multiplicatively idempotent semiring 𝑆.
Ensure: full Datalog provenance for the IDB of 𝑞.
1: for each EDB fact 𝑅 ( (cid:174)𝑥): Decompose(𝑅 ( (cid:174)𝑥))
2: for each dimension 𝑖 : 𝜈𝑖 ← Best-first(𝑞, 𝑖)
3: return Recompose(𝜈1, . . . , 𝜈𝑛)

We provide a brief review of the key ideas presented in [19].
Any element of a distributive lattice is decomposable into a prod-
uct of join-irreducible elements of the lattice, and there exists an
embedding of the distributive lattice into a chain decomposition
of its join-irreducible elements. This ensures we can 1) work on
a totally ordered environment and apply algorithms that require
total ordering over the elements, 2) independently compute par-
tial provenance annotations for each dimension to form the final
provenance annotation. Given 𝑚 the number of dimensions in the
decomposition, our solution (described in Algorithm 2) performs
𝑚 launches of the Best-First method and thus, roughly has a cost
increased by a factor 𝑚.

5 IMPLEMENTATION AND EXPERIMENTS
In numerous application domains, Datalog is used as a domain
specific language (DSL) to express logical specifications for static
program analysis. A formal specification, written as a declarative
Datalog program is usually translated into an efficient imperative
implementation by a synthesizer. This process simplifies the devel-
opment of program analysis compared to hand-crafted solutions
(highly optimized C++ applications specialized in enforcing a fixed
set of specifications). Soufflé [11, 20] has been introduced to pro-
vide efficient synthesis of Datalog specifications to executable C++

programs, competing with state-of-the-art handcrafted code for
program analysis. The inner workings of Soufflé were of interest
to our work; the algorithm implementations are similar to the eval-
uation strategy followed by the Best-First method we introduced
here. We present a brief overview of the architecture of Soufflé
and discuss how we extended it.

Architecture and implementation. Following what is described
in [11], an input datalog program 𝑞 goes through a staged specializa-
tion hierarchy. After parsing, the first stage of Soufflé specializes
the semi-naïve evaluation strategy applied to 𝑞, yielding a relational
algebra machine program (RAM). Such a program consists in ba-
sic relational algebra operations enriched with I/O operators and
fix-point computations. As a final step, the RAM program is finally
either interpreted or compiled into an executable. For this work,
we have only used the interpreter. Our code was inserted in two
different stages of Soufflé: a new translation strategy from the
parsed program to the RAM program, a priority queue, replacing
the code in charge of adding at run-time the tuples to the relations.

Algorithm 3 Input Datalog program computing the transitive
closure (Soufflé syntax)

.decl edge(s:number, t:number[, @prov:semiring value])
.decl path(s:number, t:number[, @prov:semiring value])
.input edge .output path

1:
2:
3:
4: path(x, y) :- edge(x, y).
5: path(x, y) :- path(x, z), edge(z, y).

Algorithm 4 Corresponding Soufflé RAM program for Algo-
rithm 3

1: if ¬(edge = ∅) then
for t0 in edge do
2:
3:
4:

add (t0.0, t0.1) in path
add (t0.0, t0.1) in 𝛿path

5: loop
6:
7:
8:
9:
10:

if ¬(𝛿path = ∅) ∧ ¬(edge = ∅) then

for t0 in 𝛿path do

for t1 in edge on index t1.0 = t0.1 do

if ¬(t0.0, t0.1) ∈ path then
add (t0.0, t0.1) in path’

11:
12:
13:
14:

if path’ = ∅ then exit
for t0 in path’: add (t0.0, t0.1) in path
swap 𝛿path with path’
clear path

We showcase the result of our translation strategy in Algo-
rithms 4 and 5 for a Datalog query computing the transitive closure
of a graph; this program is given in Algorithm 3 in its Soufflé
syntax. Algorithm 4 presents the corresponding Soufflé RAM pro-
gram resulting from applying the semi-naïve evaluation strategy
and Algorithm 5 our modification to the RAM program to pro-
vide provenance annotation via the Best-First strategy and use
the priority queue pq for provenance computation. The ⊥ nota-
tion corresponds to a wildcard. Importantly, modifying directly at
the RAM level of Soufflé allows us to benefit of all implemented
optimizations.

Yann Ramusat, Silviu Maniu, and Pierre Senellart

)
s
(

e
m

i
t

100 000

10 000

1 000

100

10

1

0.1

)
s
(

e
m

i
t

Rome99

USPowerGrid

Yeast

Stif

Soufflé

NodeElim-Id

NodeElim-Degree

Soufflé-prov

Rome99

USPowerGrid

Yeast

Stif

BFS

Soufflé

Dijkstra

Mohri

Soufflé-prov

1

0.1

0.01

0.001

Figure 2: Comparison between algorithms for all-pairs
shortest-distances (tropical semiring). Values greater than
100 000 s are timeouts.

Figure 3: Comparison between algorithms for single-source
shortest-distances (tropical semiring).

Table 1: Computation times (in seconds), provenance overhead ratio, size of the output DB (million tuples), and throughput
(million tuples/second), for a selection of graph patterns.

Dataset

Rome99
PowerGrid
Yeast
Stif

𝑟

14.2
.079
.577
491

Soufflé
𝑝2
𝑝1
6.45
.068
.028
.011
7.65
.131
oom
50.6

Soufflé-prov

Ratio

Output DB size

𝑝3
.556
.021
1.30
oom

𝑟

52.2
.202
1.88
2081

𝑝1
.134
.019
.264
141

𝑝2
20.1
.050
25.2
oom

𝑝3
1.82
.035
3.73
oom

𝑟

3.68
2.56
3.26
4.24

𝑝1
1.97
1.45
2.02
2.79

𝑝2
3.11
1.78
3.56
n/a

𝑝3
3.26
1.67
2.87
n/a

𝑟

1.12
.044
.487
313

𝑝1
.005
0
𝜖
.068

𝑝2
16.5
.006
19.9
n/a

𝑝3
1.31
.004
3.02
n/a

𝑟

.792
.556
.844
.151

Throughput
𝑝2
𝑝1
.820
.047
.130
n/a
.789
n/a
𝜖
n/a

𝑝3
.718
.119
.808
n/a

Algorithm 5 Modification of RAM program of Algorithm 4 to
implement Best-First strategy

1: if ¬(edge = ∅) then
2:
3:

for t0 in edge: update (t0.0, t0.1, t0.prov) in path
for t0 in path: add (t0.0, t0.1, t0.prov) in 𝛿path

4: loop
5:
6:
7:
8:
9:

if ¬(𝛿path = ∅) ∧ ¬(edge = ∅) then

for t0 in 𝛿path do

for t1 in edge on index t1.0 = t0.1 do
if ¬(t0.0, t1.1, ⊥) ∈ path then

update (t0.0, t0.1, t0.prov ⊗ t1.prov) in pq

10:
11:
12:

clear 𝛿path
if pq is empty then exit
add pq.top() in pq.top().relation and in pq.top().𝛿relation

Experiments. Our implementation was tested on an Intel Xeon
E5-2650 computer with 176 GB of RAM. The source code will be
made available once anonymity requirements are removed.

To translate querying over graphs into Datalog query evaluation,
the graph structure has been encoded into an EDB with one binary
predicate edge encoding the edges, and with edge notations depend-
ing on the provenance semiring we chose. We run the transitive
closure Datalog program outlined in Algorithm 3. We use the same
datasets as those used in [19], see [16, 19] for their description and
where to download them.

We provide in Figure 2 a comparison between the Best-First
method introduced here (Soufflé-prov), the plain Soufflé with-
out provenance computation, and a previous provenance compu-
tation algorithm from [19] computing all-pairs shortest-distances
over graph databases (the NodeElimination algorithm, with a
choice of node to eliminate based on its id or its degree), in the
tropical semiring. Similarly, in Figure 3, we compare with previous
solutions for single-source shortest-distances, in the same semir-
ing, in particular the adaptation of the Dijkstra algorithm of [19],
and, for comparison purposes, a bread-first-search (Bfs) algorithm
that simply navigates the graph from the source node but does not
compute provenance.

The main focus of this work was to provide an effective Datalog
based solution for all-pairs provenance in graph databases. For
the all-pairs problem, depending on the dataset, (see, e.g., Yeast),
Soufflé-Prov is significantly faster than the previous best known
algorithm, NodeElimination. Unsurprisingly, BFS and Dijkstra
perform respectively better than Soufflé and Soufflé-prov in the
single-source context. What favors both graph algorithms strongly
is the fact that they reduce redundant computation: the algorithms
abort whenever the target vertex has been reached. Soufflé-prov
performs between 1 and 2 orders of magnitude faster than Mohri
[17] – an algorithm designed for single-source provenance on 𝑘-
closed semirings. This fact highlights the potential of adapting the
best-first method to also handle 𝑘-closed semirings.

Previous work [19] addressing provenance computation for graph
databases was restricted to RPQs. We now turn to evaluating this
approach for more intricate graph patterns. Patterns considered are

Efficient Provenance-Aware Querying of Graph Databases with Datalog

combinations and/or unions of RPQs. The output is moreover not
restricted to pairs, but can be of any arbitrary arity. For instance, this
allows retrieval of intermediate nodes on a path when computing
graph reachability. On the same datasets, we label their edges with
two distinct labels, 𝑎 and 𝑏, in an uniform random manner. After
this process, some edges have disappeared (neither labeled with 𝑎
nor 𝑏), some appear two times (labeled with 𝑎 and 𝑏, with different
weights), or are only associated to one label. The final size of the
modified datasets did not change significantly. Table 1 provides a
summary of the experiments we conducted over three distinct pat-
terns 𝑝1, 𝑝2, and 𝑝3, described in the following. Pattern 𝑝1 (𝑥, 𝑦, 𝑧)
:- 𝑅𝑎 (𝑥, 𝑦), 𝑅𝑏+ (𝑦, 𝑧), 𝑅𝑎 (𝑧, 𝑥) selects triplets of vertices that are tri-
angles in the graph, with one side being a 𝑏 path of arbitrary
length. Pattern 𝑝2 (𝑤, 𝑥, 𝑦, 𝑧) :- 𝑅𝑎+ (𝑤, 𝑥), 𝑅𝑏+ (𝑥, 𝑦), 𝑅𝑎+ (𝑦, 𝑧) selects
quadruplets of vertices with two hops, and pattern 𝑝3 (𝑤, 𝑥, 𝑦, 𝑧) :-
𝑅𝑎+ (𝑤, 𝑥), 𝑅𝑏 (𝑥, 𝑦), 𝑅𝑎+ (𝑦, 𝑧) is a slight variation of 𝑝2. We perform
the same experiments as for the reachability queries before, and
we indicate the ratio between computation time with or without
provenance tracking. The results show that the overhead induced
by our provenance approach stays within a constant factor, roughly
between 2 and 4, depending on the dataset and pattern. Finally,
as observed in the Yeast dataset, the chosen pattern can strongly
impact the output DB size: almost negligible having around 100
tuples for pattern 𝑝1, or extremely large having 19 million tuples
for pattern 𝑝2. In order to provide a meaningful comparison, we
also measure the throughput, consisting in the average number of
output tuples processed per second. For smaller output DB sizes,
this measure is less relevant, as the fixed costs of running Soufflé-
prov dominate the overall running time. Overall, these results are
promising, as our method has the potential to process 1M tuples
per second when the query output is large.

6 RELATED WORK
With respect to Datalog provenance, it has been shown in [6] that,
for a Datalog program having 𝑛 candidate IDB tuples, a circuit
for representing Datalog provenance in the semiring Sorp(𝑋 ) (the
most general absorptive semiring) only needs 𝑛 + 1 layers. For
binary relations, e.g., representing the edge relation of a graph,
this construction is at least quadratic in the number of vertices,
thus not practically applicable for the graphs we analyzed in our
experiments. Similarly, in [7], absorptive semirings (i.e., 0-closed
semirings) have the property that derivation trees of size ⩾ 𝑛 are
“pumpable” (they do not contribute to the final result). A concrete
implementation [8] computes the provenance for commutative and
idempotent semirings using 𝑛 Newton iterations.

Fairly recently, [12] introduced POPS (Partially Ordered, Pre-
Semiring), a structure decoupling the order on which the fixed-point
is computed from the semiring structure. Complex and recursive
computations over vectors, matrices, tensors are now expressible
using this framework. The study also generalized the semi-naïve
method from plain Datalog evaluation to idempotent semirings (aka
dioids). In comparison, our method is restricted to semirings that
are totally ordered (a subclass of distributive dioids2), leveraging

2Distributive dioids are POPS structures over a distributive lattice being the natural
order of the dioid.

the invariant that once a fact is first labeled with a provenance
value, we are certain it is the correct one.

In cases where keeping the full provenance of a program (how-
provenance) is still prohibitively large, [4, 5] propose to select only
a relevant subset of such trees using selection criteria based on
tree patterns and ranking over rules and facts occurring in the
derivation. First, given a Datalog program 𝑃 and a pattern 𝑞, an
offline instrumentation is performed, leading to an instrumented
program 𝑃𝑞. Then, given any database 𝐷, an efficient algorithm can
be used to retrieve only the top-𝑘 best derivation trees for 𝑃𝑞 (𝐷).
The top-1 algorithm of the study is closely related to our solution,
but does not mention the use of a priority queue nor does it take into
account the optimization provided by the semi-naïve evaluation
strategy we describe in Section 4.

Our solution can be seen as a hybrid of the ideas introduced
in [12] and [5]. We generalize the semi-naïve evaluation to a specific
class of semirings in order to achieve a more efficient algorithm,
one that can be used in practical real-world scenarios.

7 CONCLUSION
In this work, we developed a novel method for Datalog provenance
computation based on the link between dynamic programming
over hypergraphs and the proof structure of provenance of Dat-
alog programs. We introduced Knuth’s algorithm for computing
the provenance, and optimized it for practical use. We showed its
feasibility by providing an implementation on top of Soufflé and
tested it on several graph databases and matching patterns.

We proved in this paper that optimization methods for graph
provenance naturally extend to Datalog provenance, for certain
classes of semirings playing a major role in practical applications.
The previous work targeting provenance computations for graph
databases in the framework of [18] and [19] only considered RPQs,
which are a strict subset of the expressive capabilities of Datalog.
We thus have extended the supported set of queries for provenance-
aware interrogation of graph databases, maintaining the practical
efficiency of the approach. The theoretical complexity of the intro-
duced method is not fully understood yet; we plan to address this
in future work.

The internals of Soufflé, targeting the inflationary computa-
tion of the fixed-point operator lack support for updating tuples.
We conjecture we could mitigate the overhead induced by prove-
nance computations within Soufflé-prov by adding primitives in
their data structures. What remains to be established is to what
extent these data structures [11] could be extended to handle up-
dates, without reducing the efficiency of Soufflé’s current set of
operators.

ACKNOWLEDGMENTS
This work has been funded by the French government under man-
agement of Agence Nationale de la Recherche as part of the “In-
vestissements d’avenir” program, reference ANR-19-P3IA-0001 (PR-
AIRIE 3IA Institute).

REFERENCES
[1] Serge Abiteboul, Richard Hull, and Victor Vianu. Foundations of Databases.

Addison-Wesley, 1995.

[2] Pablo Barceló. Querying graph databases. In PODS, pages 175–188, New York,

[3]

2013. ACM.
James Cheney, Laura Chiticariu, and Wang Chiew Tan. Provenance in databases:
Why, how, and where. Found. Trends Databases, 1(4):379–474, 2009.

[4] Daniel Deutch, Amir Gilad, and Yuval Moskovitch. selP: selective tracking and

presentation of data provenance. In ICDE, pages 1484–1487, 2015.

[5] Daniel Deutch, Amir Gilad, and Yuval Moskovitch. Efficient provenance tracking

for datalog using top-k queries. The VLDB Journal, 27:245–269, 2018.

abs/2105.14435, 2021.

[13] Donald E. Knuth. A generalization of Dijkstra’s algorithm. Information Processing

Letters, 6(1), 1977.

[14] Daniel Krob. Monoides et semi-anneaux complets. In Semigroup Forum, vol-

ume 36, pages 323–339. Springer, 1987.

[15] Werner Kuich. Semirings and formal power series: Their relevance to formal
languages and automata. In Handbook of Formal Languages, volume 1, chapter 9,
pages 609–677. Springer, 1997.

[6] Daniel Deutch, Tova Milo, Sudeepa Roy, and Val Tannen. Circuits for Datalog

[16] Silviu Maniu, Pierre Senellart, and Suraj Jog. An Experimental Study of the

Yann Ramusat, Silviu Maniu, and Pierre Senellart

[7]

Provenance. In ICDT, pages 201–212, 2014.
Javier Esparza and Michael Luttenberger. Solving fixed-point equations by
derivation tree analysis. In CALCO, pages 19–35, 2011.
Javier Esparza, Michael Luttenberger, and Maximilian Schlund. Fpsolve: A
generic solver for fixpoint equations over semirings. In CIAA, pages 1–15, 2014.
[9] Todd J. Green, Grigoris Karvounarakis, and Val Tannen. Provenance semirings.

[8]

In PODS, 2007.

Treewidth of Real-World Graph Data. In ICDT, pages 12:1–12:18, 2019.

[17] Mehryar Mohri. Semiring frameworks and algorithms for shortest-distance

problems. J. Autom. Lang. Comb., 7(3):321–350, 2002.

[18] Yann Ramusat, Silviu Maniu, and Pierre Senellart. Semiring provenance over

graph databases. In TaPP, 2018.

[19] Yann Ramusat, Silviu Maniu, and Pierre Senellart. Provenance-based algorithms

for rich queries over graph databases. In EDBT, pages 73–84, 2021.

[10] Liang Huang. Advanced dynamic programming in semiring and hypergraph

[20] Bernhard Scholz, Herbert Jordan, Pavle Subotić, and Till Westmann. On fast

frameworks. In COLING, pages 1–18, 2008.

large-scale program analysis in datalog. In CC, page 196–206, 2016.

[11] Herbert Jordan, Bernhard Scholz, and Pavle Subotić. Soufflé: On synthesis of

[21] Pierre Senellart. Provenance in databases: Principles and applications. In Rea-

program analyzers. In CAV, pages 422–430, 2016.

soning Web, pages 104–109, 2019.

[12] Mahmoud Abo Khamis, Hung Q. Ngo, Reinhard Pichler, Dan Suciu, and
Yisu Remy Wang. Convergence of datalog over (pre-) semirings. CoRR,

Efficient Provenance-Aware Querying of Graph Databases with Datalog

A PROOFS FOR SECTION 2 (BACKGROUND)

Lemma 2. Let 𝑆 be an idempotent semiring and ⩽ the natural order over 𝑆. Then 𝑆 is superior with respect to ⩽ if and only if 𝑆 is 0-closed.

Proof. First assume 𝑆 superior with respect to ⩽. Then for any 𝑎, ¯1 ⩽ ¯1 ⊗ 𝑎 = 𝑎, which means that ¯1 + 𝑎 = ¯1, i.e., 𝑆 is 0-closed.
Now assume 𝑆 0-closed. Since 𝑎 ⊕ 𝑎 ⊗𝑏 = 𝑎 ⊗ (¯1 ⊕ 𝑏) = 𝑎, we have: 𝑎 ⩽ 𝑎 ⊗ 𝑏, and similarly for 𝑏 ⩽ 𝑎 ⊗ 𝑏. Thus 𝑆 is superior with respect
□

to ⩽.

B PROOFS FOR SECTION 3 (DATALOG PROVENANCE AND DYNAMIC PROGRAMMING OVER

HYPERGRAPHS)

Lemma 11. For any Datalog query 𝑞 and grounding of an atom 𝑣 of 𝑞, there is a bijection between D𝐻𝑞 (𝑣) and {𝜏 | 𝜏 yields 𝑣 }.

Proof. By definition of 𝐻𝑞 each instantiation of a rule corresponds to a unique hyperedge. Then, we can inductively construct for a

given derivation 𝐷 its associated (unique) Datalog proof tree 𝜏𝐷 :

• If |𝐷 | = 1, then 𝑣 is a source vertex and thus an extensional tuple, we get the empty proof.
• If |𝐷 | ⩾ 1, then there exists 𝑒 ∈ BS(𝑣) where |𝑒 | ⩾ 0 and 𝐷𝑖 a derivation of 𝑇𝑖 (𝑒) for 1 ⩽ 𝑖 ⩽ |𝑒 |, where 𝐷 = ⟨𝑒, 𝐷1 · · · 𝐷 |𝑒 |⟩. By
definition, this hyperedge corresponds to the grounding of a rule 𝑡 ( (cid:174)𝑥) ← 𝑟1 ( (cid:174)𝑥1), . . . , 𝑟𝑛 ( (cid:174)𝑥𝑛). By induction, for 1 ⩽ 𝑖 ⩽ |𝑒 |, 𝜏𝐷𝑖 is the
corresponding proof of the derivation 𝐷𝑖 . Then by composition we obtain 𝜏𝐷 the proof for 𝐷.

□

Lemma 12. For any Datalog query 𝑞 and grounding of an atom 𝑣 of 𝑞, for any derivation 𝐷 of 𝑣 in 𝐻𝑞 we have

𝑤 (𝐷) =

(cid:204)

𝑞
𝑅 (𝑡 ′)
prov

𝑡 ′ ∈ 𝑙𝑒𝑎𝑣𝑒𝑠 (𝜏𝐷 )

where 𝜏𝐷 is the proof tree corresponding to 𝐷 in the bijection given by Lemma 11.

Proof. By induction on the size of the derivation 𝐷:

𝑞
𝑅 (𝑟 ( (cid:174)𝑥)) =
• If |𝐷 | = 1 then, there exists a nullary edge 𝑒 ∈ 𝐸𝑞 with ℎ(𝑒) = 𝑣 and 𝑤 (𝐷) = 𝑓𝑣 = prov

(cid:206)
𝑡 ′ ∈ 𝑙𝑒𝑎𝑣𝑒𝑠 (𝜏𝐷 )

𝑞
𝑅 (𝑡 ′).
prov

• If |𝐷 | ⩾ 1 then there exists 𝑒 ∈ 𝐸𝑞 and 𝐷 is of the form ⟨𝑒, 𝐷1 · · · 𝐷 |𝑒 |⟩ with 𝐷𝑖 a derivation of 𝑇𝑖 (𝑒) for 1 ⩽ 𝑖 ⩽ |𝑒 |. We have

𝑤 (𝐷) = 𝑓𝑒 (𝑤 (𝐷1), . . . , 𝑤 (𝐷 |𝑒 |)) and by definition of 𝑓𝑒 = ⊗ and by IHP 𝑤 (𝐷) = (cid:203)

𝑞
𝑅 (𝑡 ′).
prov

𝑡 ′ ∈ 𝑙𝑒𝑎𝑣𝑒𝑠 (𝜏𝐷 )

□

𝑞
𝐺 (𝑡) =
Theorem 13. Let 𝑡 be a tuple of a Datalog program 𝑞 with output predicate 𝐺 and 𝐻𝑞 its hypergraph representation, then prov

𝛿𝐻𝑞 (𝐺 (𝑡)).

Proof.

𝛿𝐻𝑞 (𝑡) =

(cid:201)
𝐷 ∈D𝐻𝑞 (𝐺 (𝑡 ))

𝑤 (𝐷)

(cid:32)

(cid:203)
𝑡 ′ ∈ 𝑙𝑒𝑎𝑣𝑒𝑠 (𝜏𝐷 )

(cid:33)

𝑞
𝑅 (𝑡 ′)
prov

and by Lemma 12,

and by Lemma 11,

=

(cid:201)
𝐷 ∈D𝐻𝑞 (𝐺 (𝑡 ))

(cid:32)

= (cid:201)

𝜏 yields 𝑡

(cid:203)
𝑡 ′ ∈ 𝑙𝑒𝑎𝑣𝑒𝑠 (𝜏)

𝑞
𝑅 (𝑡 ′)
prov

(cid:33)

𝑞
𝑇 (𝑡).
= prov

□

C PROOFS FOR SECTION 4 (BEST-FIRST METHOD)

Theorem 14. Algorithm 1 computes the full Datalog provenance for 0-closed totally-ordered semirings.

Proof. We show the algorithm verifies the following invariant: whenever a tuple is added to 𝐼 in Line 11, it has optimal value. This
implies that 𝐼 is populated in increasing order: each new derivation computed in the Relax() procedure only updates the priority queues
with values greater than the value of the tuple relaxed (by superiority of ⊗).

Assume by contradiction that some output tuples are not correctly labeled and take such a minimal tuple 𝜈 = 𝑟 ( (cid:174)𝑥). At the moment where
𝜈 is extracted with value 𝑛 let us consider an optimal derivation path of 𝜈 that leads to the optimum value 𝑜𝑝𝑡 < 𝑛. By superiority each tuple
occurring in the tail of the rule has value less than 𝑜𝑝𝑡. Thus a tuple occurring in the tail is either wrong-valued or not present in 𝐼 at the
moment where 𝜈 is found. In both cases and because tuples are added to 𝐼 in increasing order we obtain a new minimal tuple incorrectly
□
labeled by the algorithm, contradicting the hypothesis.

