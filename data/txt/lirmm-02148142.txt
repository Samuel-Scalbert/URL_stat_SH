Oblivious and Semi-Oblivious Boundedness for
Existential Rules
Pierre Bourhis, Michel Leclère, Marie-Laure Mugnier, Sophie Tison, Federico

Ulliana, Lily Gallois

To cite this version:

Pierre Bourhis, Michel Leclère, Marie-Laure Mugnier, Sophie Tison, Federico Ulliana, et al.. Oblivious
and Semi-Oblivious Boundedness for Existential Rules. IJCAI 2019 - 28th International Joint Con-
ference on Artificial Intelligence, Aug 2019, Macao, China. pp.1581-1587, ￿10.24963/ijcai.2019/219￿.
￿lirmm-02148142￿

HAL Id: lirmm-02148142

https://hal-lirmm.ccsd.cnrs.fr/lirmm-02148142

Submitted on 5 Jun 2019

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Oblivious and Semi-Oblivious Boundedness for Existential Rules

Pierre Bourhis1,3,4 , Michel Lecl`ere2,4 , Marie-Laure Mugnier2,4 ,
Sophie Tison3,4 , Federico Ulliana2,4 and Lily Galois3,4
1 CNRS, France
2 Univ. Montpellier, LIRMM, France
3 Univ. Lille, CRIStAL, France
4 Inria, France
{ﬁrstname.lastname}@inria.fr

Abstract

We study the notion of boundedness in the context
of positive existential rules, that is, whether there
exists an upper bound to the depth of the chase pro-
cedure, that is independent from the initial instance.
By focussing our attention on the oblivious and the
semi-oblivious chase variants, we give a character-
ization of boundedness in terms of FO-rewritability
and chase termination. We show that it is decidable
to recognize if a set of rules is bounded for several
classes and outline the complexity of the problem.

1 Introduction

We consider the setting of ontology-based query answering
(OBQA) in which answers to conjunctive queries are logi-
cally entailed from a knowledge base constituted of a set of
facts and an ontology. Existential rules, also known as Tu-
ple Generating Dependencies (TGDs) in database theory, are
an expressive knowledge representation language well stud-
ied in the OBQA setting [Cal`ı et al., 2009; Baget et al., 2011;
Cal`ı et al., 2013]. These rules generalize function-free Horn
rules (like those of datalog) with existentially quantiﬁed vari-
ables in the rule heads, which allow one to assert the exis-
tence of unknown individuals, and hence to reason in open
domains. Beside datalog, existential rules generalize the Se-
mantic Web language RDF Schema, as well as most Descrip-
tion Logics used in the OBQA context, namely Horn descrip-
tion logics, in particular those at the core of the tractable pro-
ﬁles of the ontological language OWL 2.

The two main approaches developed to answer conjunctive
queries on existential rules knowledge bases are materializa-
tion and query rewriting. Both can be seen as ways of reduc-
ing query answering to a classical database query evaluation
problem. Materialization relies on a forward chaining tech-
nique, called the chase, that consists in expanding the fact-
base with the facts entailed by rules until ﬁxpoint. In contrast,
query rewriting is a backward chaining mechanism that con-
sists in rewriting an input query using relevant rules, so that
its answers on the knowledge base are exactly the answers of
the rewritten query on the factbase alone. Query answering
being undecidable for existential rules, both materialization
and query rewriting may not terminate.

This led to intensive research aiming at characterizing de-
cidable and tractable classes of existential rules. Several syn-
tactic restrictions were proposed to ensure chase termination
(e.g. weak-acyclicity [Fagin et al., 2005]) or the existence
of a (ﬁnite) ﬁrst-order rewriting of a conjunctive query, a
property referred as FO-rewritability [Calvanese et al., 2007].
Nevertheless, the interactions between chase termination and
FO-rewritability have been little investigated so far, and not
much is known for existential rules on which both hold. What
are the relationships between these two properties?

Answering this question leads us to another fundamen-
tal problem, which has been extensively studied for data-
log, namely (uniform) boundedness [Hillebrand et al., 1995].
Boundedness concerns the recursivity of rules, and asks
whether there is an upper bound on the depth of the chase,
which is independent from any factbase. The property is key
for practical optimization of reasoning as it implies that the
ruleset is essentially non-recursive (although syntactic condi-
tions may fail to capture this). It is known that boundedness
and FO-rewritability are equivalent in the case of datalog [Aj-
tai and Gurevich, 1994], but this does not hold for existential
rules. In this setting, the notion of boundedness also depends
on the chase variant as they all behave differently with respect
to termination.

We focus our attention on the oblivious and semi-oblivious
(a.k.a. Skolem) chase [Marnette, 2009]. As a matter of fact,
almost all known sufﬁcient conditions for chase termination
fall within these chase variants (from the simplest ones: rich-
acyclicity [Hernich and Schweikardt, 2007], weak-acyclicity
[Fagin et al., 2005] and acyclic-GRD [Baget et al., 2011] to
the more general MFA [Grau et al., 2013]), at the exception
of the recent work of [Carral et al., 2017] which applies to the
restricted chase variant. Importantly, we consider a breadth-
ﬁrst version for both variants, which ensures the minimal
depth of the chase [Delivorias et al., 2018].

Our main contribution is a characterization of bounded-
ness in terms of chase termination and FO-rewritability. This
means that a set of rules is bounded if and only if it ensures
both chase termination for any instance and FO-rewritability
for any conjunctive query. We show this by proving two or-
thogonal results. The ﬁrst is a bound on the depth of existen-
tial variables when the chase terminates on all instances. The
second is a bound on the (breadth-ﬁrst) rank at which facts
using terms of a given depth are inferred.

This connection reveals important differences between the
two variants. For the oblivious case we show that, when chase
termination holds, FO-rewritability on full-atomic queries
(queries with a single atom and only answer variables) is
equivalent with FO-rewritability. Moreover, for the case of
fully-existential rules (rules where all head atoms have at least
one existential variable), we show that chase termination is
equivalent to boundedness and so it implies FO-rewritability.
None of these properties hold for the semi-oblivious chase.

Recognizing if a set of existential rules is bounded is unde-
cidable already for datalog [Hillebrand et al., 1995]. How-
ever, we show the decidability of the problem for major
classes of existential rules as direct corollaries of our charac-
terizations and existing results from the literature. Precisely,
the problem is PSpace-complete for linear and sticky rules
and in 2Exptime for guarded rules. Finally, we consider the
k-boundedness problem (i.e., whether the chase terminates in
k steps on all instances), which was recently proven decid-
able for several chase variants, including those investigated
here [Delivorias et al., 2018]. We show that deciding if a rule-
set is k-bounded is in 2Exptime for the breadth-ﬁrst (semi-)
oblivious chase and co-NExptime-complete for datalog.

2 Preliminary Deﬁnitions

We consider a relational vocabulary V = (P, C) constituted
of a ﬁnite set of predicates P and a ﬁnite set of constants C. A
term v is a constant of C or a variable. An atom is of the form
p(v1 . . . vk) where p is a predicate of arity k and the vi are
terms. We denote by terms() the set of its terms and extend
the notation to sets of atoms. An embedding ϕ from a set of
atoms A to a set of atoms A(cid:48) is a substitution of terms(A)
with terms(A(cid:48)) such that ϕ(A) ⊆ A(cid:48). A homomorphism is
an embedding which is the identity on constants.

An instance I is a conjunction of atoms on constants and
(globally) existentially quantiﬁed variables.
It is ﬁnite un-
less otherwise speciﬁed. Throughout this paper, we see an
instance I as the set of its atoms and call fact any atom f that
belongs to this set. Given a ﬁnite set P of predicates, the criti-
cal instance Ia is composed of all facts built on P and special
constant a. Any instance I on P can be embedded into Ia.

An existential rule σ is a closed formula ∀¯x¯y(B[¯x, ¯y] →
∃¯zH[¯x, ¯z] where B and H are sets of atoms built on vari-
ables called the body and the head of the rule, also denoted
by body(σ) and head(σ) respectively. The set of variables
¯x shared by B and H is called the frontier of the rule and
is denoted by fr(σ). The set of variables ¯z that belong to H
only are called existential variables and are denoted by ex(σ).
Universal quantiﬁers will often be omitted in the remainder of
the paper. A rule such that ex(σ) = ∅ is called datalog. A
rule where all head atoms contain at least one existential vari-
able is called fully-existential and denoted by FE-rule. We
say that a rule σ is applicable on an instance I if there is a ho-
momorphism π from body(σ) to I and call the pair (σ, π) a
trigger of I. Given a trigger (σ, π), we denote by π|fr(σ) ⊆ π
the restriction of π to fr(σ).

A knowledge base (KB) is a pair (I, Σ) where I is an in-
stance and Σ a set of existential rules. The chase is a funda-
mental tool for computing logical consequences from a KB

since, when it terminates, it computes a universal model of
the KB, i.e., a model that maps by homomorphism to any
other model of the KB (with a model being seen here as an
instance). In this work, we focus our attention on the breadth-
ﬁrst oblivious (o-chase) and semi-oblivious (so-chase) vari-
ants. As discussed in Section 3.3, the breadth-ﬁrst behavior
is particularly interesting when studying boundedness.
Deﬁnition 1. Let (I, Σ) be a knowledge base and (cid:63) ∈ {o, so}
a chase variant. Then, the breadth-ﬁrst (cid:63)-chase is deﬁned as
follows: (cid:63)-chase0(I, Σ) = I and for all saturation rank i ≥ 0

(cid:63)-chasei+1(I, Σ) = (cid:63)-chasei(I, Σ) ∪

(cid:91)

(σ,π)

π(cid:63)(head(σ))

where (σ, π) is any trigger of (cid:63)-chasei(I, Σ) and π(cid:63) ⊇ π a
substitution that replaces each existential variable z ∈ ex(σ)
with a fresh variable named as follows:

• πo(z) = z(σ,π)
• πso(z) = z(σ,π|fr(σ))

Then, we deﬁne (cid:63)-chase(I, Σ) = (cid:83)∞
(cid:63)-chase terminates on (I, Σ) if
(cid:63)-chase(I, Σ) = (cid:63)-chasek(I, Σ).

i≥0 (cid:63)-chasei(I, Σ). The
there is a rank k with

Note that for the o-chase fresh variables are named by the
trigger from which they have been generated. Instead, for the
so-chase the naming only depends on the frontier-restriction
of the homomorphism of the trigger. This means that any two
triggers having the same rule and agreeing on the image of
its frontier variables produce equal results, hence only one of
them is actually considered by the so-chase. The so-chase is
very close to the Skolem chase, which relies on a skolemisa-
tion of the rules: ﬁrst, each rule σ is transformed by replacing
each occurrence of an existential variable z with a functional
term f σ
z (fr(σ)) on the frontier of σ; then the o-chase is run
on the skolemised rules. At each saturation rank, the Skolem
chase produces a result isomorphic to that of the so-chase (up
to the renaming of each Skolem term by the corresponding
fresh variable), hence the forthcoming results on the so-chase
also hold for the Skolem chase.
Example 1. Consider the rule σ = p(x, y) → ∃z p(x, z).
Then o-chase(I, Σ) with I = {p(a, b)} and Σ = {σ} is inﬁ-
nite - as the chase does not terminate. The atom p(a, z(σ,π1))
with π1 = {x (cid:55)→ a, y (cid:55)→ b} is ﬁrst inferred, then p(a, z(σ,π2))
with π2 = {x (cid:55)→ a, y (cid:55)→ z(σ,π1)}, and so on. Here, each rule
application enables a new trigger. In contrast, so-chase(I, Σ)
is ﬁnite, in that only the ﬁrst rule application will be per-
formed, producing p(a, z(σ,{x(cid:55)→a})), since all triggers map
the frontier variable x to a. For the Skolem chase, σ is rewrit-
ten as σ(cid:48) = p(x, y) → p(x, f σ
z (x)). The ﬁrst rule application
according to trigger (σ(cid:48), π1) produces p(a, f σ
z (a)), then the
chase halts as the same atom is produced by the next trigger.
Deﬁnition 2. The rank of a fact f ∈ (cid:63)-chase(I, Σ), de-
noted by rank(f ), is 0 if f ∈ I and 1 + max{rank(f (cid:48))|f (cid:48) ∈
π(body(σ))} if f is produced by the trigger (σ, π). This def-
inition is naturally extended to terms and sets of facts. The
rank of (cid:63)-chase(I, Σ) is the smallest k such that (cid:63)-chase(I, Σ)
= (cid:63)-chasek(I, Σ) if (cid:63)-chase(I, Σ) terminates, and it is inﬁnite
otherwise.

Note that for the breadth-ﬁrst chases we consider the above
deﬁnition implies that rank(f ) is the smallest k such that f ∈
(cid:63)-chasek(I, Σ) \ (cid:63)-chasek−1(I, Σ).

An FO-query φ(x1, ..., xn) is a (function free) ﬁrst-order
formula whose free variables (called answer variables) are ex-
actly {x1, ..., xn}. A conjunctive query (CQ) is an FO-query
which is an existentially quantiﬁed conjunction of atoms. An
atomic query is a CQ with a single atom. A full-atomic query
is an atomic query where all terms are free variables. A query
is called Boolean if it does not have any free variable. As
for instances, it will be handful to see CQs as sets of atoms,
of course by distinguishing the answer variables. A union of
conjunctive queries (UCQ) Q is a disjunction of CQs with the
same free variables, also seen as a set of CQs.

A tuple of constants (a1, ..., an) ∈ Cn is an answer to a
CQ Q(x1, ..., xn) on an instance I if there is a homomor-
phism h from Q to I such that h(xi) = ai for 1 ≤ i ≤ n.
Equivalently, I |= Q[xi (cid:55)→ ai], where |= denotes the clas-
sical logical consequence and Q[xi
(cid:55)→ ai] is the Boolean
query obtained from Q substituting each xi with ai. A tu-
ple of constants (a1, ..., an) ∈ Cn is a certain answer to Q on
a KB (I, Σ) if I, Σ |= Q[xi (cid:55)→ ai]. This is equivalent to the
existence of a saturation rank k such that (cid:63)-chasek(I, Σ) |=
Q[xi (cid:55)→ ai].
In other words, the certain answers to Q on
(I, Σ) are exactly its answers on the possibly inﬁnite instance
(cid:63)-chase(I, Σ). The set of (certain) answers to a UCQ Q is the
union of the sets of (certain) answers to the CQs it contains.

2.1 Termination vs Boundedness
To begin our study, we need to present the relationships be-
tween chase termination and boundedness. Let (cid:63) ∈ {o, so}
be a chase variant, the (cid:63)-chase termination class, denoted by
CT(cid:63), contains all rulesets Σ such that (cid:63)-chase(I, Σ) termi-
nates for all instances I. The (cid:63)-boundedness class, denoted
by BN(cid:63), contains all bounded rulesets Σ, i.e., for which there
exists an integer k such that (cid:63)-chasek(I, Σ) = (cid:63)-chase(I, Σ)
for all instances I . Obviously, BN(cid:63) ⊂ CT(cid:63).
Example 2. Let σ1 = p(x, y) ∧ p(y, z) → p(x, z) and σ2 =
p(x, y) ∧ p(w, z) → p(x, z). Because both rules are datalog,
{σ1} ∈ CT(cid:63) and {σ2} ∈ CT(cid:63). However, Σ = {σ1} (cid:54)∈ BN(cid:63),
since the rank of (cid:63)-chase(I, Σ) depends on I. In contrast,
{σ2} ∈ BN(cid:63) and the bound is k = 1. Similarly, {σ1, σ2} ∈
BN(cid:63). Indeed, σ2 produces at the ﬁrst rank all atoms that can
be produced by σ1 at later ranks.

To get a better understanding of boundedness, it will be
useful to decompose each rule of a set thereby distinguishing
between its “datalog part” and its “existential part”. For in-
stance, a rule of the form p(x, y) → ∃z p(x, z) ∧ q(x) can be
decomposed into a datalog rule p(x, y) → q(x) and an FE-
rule p(x, y) → ∃z p(x, z). Let σ be any existential rule of the
form B → HF ∧ HD where B is the set of body atoms, HF
is the set of head atoms with at least one existential variable
and HD are the remaining head atoms. The datalog-fully ex-
istential decomposition of σ, denoted by DF(σ), returns a set
made of the FE-rule B → HF together with a (single head)
D, for each H i
datalog rule of the form B → H i
D ∈ HD. The
deﬁnition is then extended to sets DF(Σ) = (cid:83)
σ∈Σ DF(σ).
This decomposition preserves boundedness and termination.

Proposition 1. Σ ∈ CT(cid:63) iff DF(Σ) ∈ CT(cid:63) and Σ ∈ BN(cid:63) iff
DF(Σ) ∈ BN(cid:63), when (cid:63) ∈ {o, so}.

3 Upper Bounding the Chase Depth

Our approach consists of deﬁning a notion of existential depth
for facts, proper to each chase, which is ﬁnite on a given in-
stance if and only if the chase terminates on that instance.
Then we show that for each chase, the existential depth of all
facts produced by the chase for a given ruleset are bounded
by those of the critical instance. This means that whenever
the chase terminates on the critical instance there is an upper
bound to the existential depth of the facts, for all instances.
In the next section, with these results in hand, we use FO-
rewritability to bound the rank at which any fact of a certain
existential depth will be inferred. This will give us a char-
acterization of boundedness for the oblivious and so-chase in
terms of FO-rewritability and chase termination.

3.1 The Oblivious Case

Intuitively, the notion of existential depth of a term measures
the number of fresh variable generation steps that led to the
creation of this term.

Deﬁnition 3. The existential depth (or simply depth) of a
term v that belongs to o-chase(I, Σ) is

depth∃(v) =

(cid:26) 0

1 + max{ depth∃(vB) }

if v ∈ terms(I)
otherwise

where vB is any term in π(body(σ)) used by a trigger (σ, π)
which generates v. The existential depth of a fact f is the
maximum existential depth of its terms. The existential depth
of o-chase(I, Σ) is the maximum existential depth of its facts
if it is ﬁnite and is inﬁnite otherwise.

To illustrate the deﬁnition, consider Example 1. The exis-
tential depth of terms in o-chase(I, {σ}) is unbounded, which
is in line with the non-termination of the o-chase on (I, {σ}).
The rule σ1 in Example 2.
shows the difference between
rank and existential depth. For any I, the existential depth
of terms (hence facts) is 0 because σ1 is datalog, however
their rank depends on I. More generally, for any term v and
fact f in o-chase(I, Σ) it holds that depth∃(v) ≤ rank(v)
and depth∃(f ) ≤ rank(f ). Hence, if o-chase(I, Σ) termi-
nates, its existential depth is ﬁnite. Reciprocally, when the
existential depth of o-chase(I, Σ) is ﬁnite, so it is the number
of its terms, and o-chase(I, Σ) terminates. We point out that
when dealing with sets of FE-rules the notions of rank and
existential depth coincide, as illustrated by Example 1.

Proposition 2. If Σ is a set of FE-rules then, for all instance I
and term v in o-chase(I, Σ), holds that depth∃(v) = rank(v).
It should be clear that, for a given ruleset, the o-chase may
have unbounded rank even when it terminates on all instances
(see for instance Example 2). Nevertheless, when a ruleset is
in CTo, our goal is to show that there exists a bound on the
existential depth of its terms, which holds for all instances.
Aiming at this, we present a lemma stating that existential
depth of terms are preserved by embeddings.

Lemma 3. For any embedding ϕ from I to I (cid:48) and any
i ≥ 0, there exists an embedding ϕ(cid:48) ⊇ ϕ from o-chasei(I, Σ)
to o-chasei(I (cid:48), Σ) which preserves the existential depth of
terms, i.e., for every term v in o-chase(I, Σ) it holds that
depth∃(v) = depth∃(ϕ(cid:48)(v)).

It is well-known that the o-chase terminates on all in-
stances if and only if it terminates on the critical instance
[Marnette, 2009]. We leverage this property to compute a
bound on the existential depth under chase termination.
Theorem 4. When Σ ∈ CTo there exists a constant kd such
that for every instance I, the existential depth of a term in
o-chase(I, Σ) is bounded by kd.
Proof. Because Σ ∈ CTo, the o-chase terminates on the
critical instance Ia. Let kd be the largest rank such that
terms(o-chasekd (Ia, Σ)) \ terms(o-chasekd−1(Ia, Σ)) (cid:54)= ∅.
Every instance I can be embedded into Ia. By Lemma 3 the
existential depth of the terms in o-chase(I, Σ) is bounded by
that of o-chase(Ia, Σ), which is in turn bounded by kd.

Chase termination is a necessary condition for bounded-
ness as it bounds the existential depths of the variables gen-
erated by the chase - but not the rank (see the datalog case).
Interestingly, for FE-rules, chase termination also becomes a
sufﬁcient condition for boundedness, because the notion of
rank and existential depth coincide (Proposition 2).
Corollary 5. For Σ a set of FE-rules, Σ ∈ CTo iff Σ ∈ BNo.
For general existential rules, we will later show that when
a restricted form of FO-rewritability holds, one can also pro-
vide a bound to the rank of the o-chase (Theorem 14).

3.2 The Semi-Oblivious Case
When applied to the so-chase, the previous notion of existen-
tial depth is not preserved by embedding, which hinders the
possibility of using the critical instance to bound the existen-
tial depth of terms. As illustrated below, this is due to the
fact that the so-chase makes equal the result of two distinct
triggers agreeing on a rule frontier.
Example 3. Consider I = {p(a, b)}, I (cid:48) = I ∪ {r(a, b)} and
Σ = {σ1 : p(x, y) → ∃z r(z, y) σ2 : r(x, y) → ∃z s(y, z)}.
Then, so-chase2(I, Σ) = I ∪ { r(z(σ1,π), b) ∪ s(b, z(σ2,π)) }
with π = {y (cid:55)→ b}. Also, so-chase2(I, Σ) ⊆ so-chase1(I (cid:48), Σ)
because all triggers applied by the chase from I are al-
ready applicable on I (cid:48). The application of σ2 on r(a, b) and
r(z(σ1,π), b) gives equal results, hence so-chase1(I (cid:48), Σ) =
so-chase2(I (cid:48), Σ). In the embeddings from so-chase2(I, Σ) to
so-chase2(I (cid:48), Σ), z(σ2,π) is mapped to itself, but both occur-
rences have different existential depth (resp. 2 and 1).

It is therefore natural to turn to the following notion of

depth, which accounts for frontier terms only.
Deﬁnition 4. The frontier existential depth (or simply frontier
depth) of a term v that belongs to so-chase(I, Σ) is

depthfr

∃(v) =






0
1
1 + max{ depthfr

∃(vB) }

if v ∈ terms(I)
if fr(σ) = ∅
otherwise

where vB is any term in π(fr(σ)) used by a trigger (σ, π)
which generates v. Accordingly, the frontier depth of a fact f
is the maximum frontier depth of its terms. The frontier depth
of so-chase(I, Σ) is deﬁned as the maximum frontier depth of
its facts if it is ﬁnite and is inﬁnite otherwise.

Note that frontier depth coincides with the (usual) depth of

terms generated by the Skolem chase.

Clearly, depthfr

∃(v) ≤ depth∃(v) for all v in o-chase(I, Σ).
The following example illustrates the difference between the
two notions of (existential) depth.
Example 4. Let Σ = {σ = p(x, y, u) → ∃z p(y, x, z)}.
Starting from I = {p(a, b, c)}, the o-chase generates an in-
ﬁnite number of fresh variables v with increasing depth∃(v).
The rank of the so-chase is instead 2 and for each fresh vari-
able v, depthfr
∃(v) = 1 as all triggers map fr(σ) to terms(I).
It is worth noting that not only the oblivious notion of ex-
itential depth is not effective for studying the so-chase, but
also that the frontier depth is not well characterizing the be-
havior of the o-chase either. The crux is that the ﬁniteness of
the frontier depth cannot be related with the termination of the
o-chase, as illustrated by Example 4. Using such a notion to
study the o-chase would impede us, for instance, to establish
Corollary 5, which relies on the fact that rank and existential
depth coincide for the oblivious-chase (Property 2).

We are now ready to show that the frontier depth is pre-
served by embeddings. The next lemma and theorem are the
counter-parts of Lemma 3 and Theorem 4 for the so-chase.
Lemma 6. For any embedding ϕ from I to I (cid:48) and any i ≥ 0,
there exists an embedding ϕ(cid:48) ⊇ ϕ from so-chasei(I, Σ) to
so-chasei(I (cid:48), Σ) which preserves the frontier depth of terms.
Theorem 7. When Σ ∈ CTso there exists a constant kd
such that for every instance I, the frontier depth of a term
in so-chase(I, Σ) is bounded by kd.

3.3 On the Interest of the Breadth-First Chase
We conclude this section with some remarks on the interest
of studying boundedness for breadth-ﬁrst chases. We assume
that the reader is familiar with the notion of chase sequence.1
We deﬁne the rank of a chase sequence on (I, Σ) as the max-
imal rank of its facts if it is ﬁnite, and inﬁnite otherwise.

For the (semi-)oblivious chase, it is well-known that there
is a terminating chase sequence for (I, Σ) if and only if all
chase sequences for (I, Σ) terminate. However, not all termi-
nating chase sequences have the same rank, and the minimal
rank is obtained with breadth-ﬁrst sequences [Delivorias et
al., 2018]. This makes the notion of boundedness we consider
equivalent to studying whether there exists a bound such that,
for all instance, there exists a terminating chasing sequence
whose rank is within the bound. Hence, it characterizes the
fact that the chase can indeed terminate within that bound,
if a strategy ensuring a minimal sequence rank is followed.

1A chase sequence is any sequence of triggers satisfying the ap-
plicability criterion of the chase variant. For the oblivious chase,
the same trigger should not be applied twice. For the semi-oblivious
chase a trigger is not applied if a trigger for the same rule assigning
the same image for the frontier variables has been applied before.

It is therefore natural to consider breadth-ﬁrst chases which
achieve this property, like the (semi-)oblivious chase. Exam-
ple 2 illustrates this concept and shows that, already for dat-
alog, the rank of some chase sequences may be not bounded,
while the rank of all breadth-ﬁrst sequences is bounded. This
happens for instance if all applications of the transitivity rule
σ2 are performed before the rule σ1.

In the special case of FE-rules, it is not hard to see that
all oblivious chase sequences for (I, Σ) have the same rank.
However, this does not hold for the semi-oblivious chase. Be-
low, a variation of Example 2, where some dummy variables
are introduced, illustrates this point.
Example 5. Let Σ = {σ1, σ2}, with σ1 = p(x, y, t) ∧
p(y, z, u) → ∃v p(x, z, v) and σ2 = p(x, y, t)∧p(w, z, u) →
∃v p(x, z, v). The rank of so-chase(I, Σ) is bounded by 2 for
any I, while again performing all applications of σ2 before
σ1 gives derivations of different ranks.

4 The Impact of First Order Rewritability
We now turn our attention to FO-rewritability and show that
it yields a bound on the rank of speciﬁc (sets of) facts that
share terms with the initial instance I. For the o-chase, we
bound the rank of facts that have all their terms in I. For
the so-chase, we consider triggers that map a rule frontier to
terms of I: we do not bound the rank of facts that allow to
ﬁre such triggers, but we show that for each such trigger t =
(σ, π), there is a trigger t(cid:48) = (σ, π(cid:48)) that agrees with t on
the mapping of fr(σ) and that is ﬁred at a bounded rank. In
Section 5, we will leverage these results to show that FO-
rewritability yields a bound on the rank of all facts with a
certain existential depth. For the o-chase, a restricted version
of FO-rewritability is sufﬁcient to get these properties.

We say that a pair (Q, Σ) is FO-rewritable (resp. UCQ-
rewritable) if there is an FO-query (resp. a UCQ) Q such
that, for all I, the certain answers to Q on (I, Σ) are exactly
the answers to Q on I. It is known that FO-rewritability is
equivalent to UCQ-rewritability2 . A set of rules Σ is FO-
rewritable (or equivalently, UCQ-rewritable) if (Q, Σ) is FO-
rewritable for every CQ Q. We denote by FO-R the class of
FO-rewritable rulesets. We will also consider speciﬁc classes
of CQs. Given a class of CQs C, we say that a ruleset Σ
is FO-rewritable with respect to C if (Q, Σ) is FO-rewritable
for all Q ∈ C. We denote by FO-RC the corresponding class.
We ﬁrst point out that FO-rewritability with respect to full-
atomic queries, denoted by FO-RAF, is a strictly weaker prop-
erty than FO-rewritability.
Proposition 8. FO-RAF ⊃ FO-R

Proof. The inclusion holds by deﬁnition, and to see that it is
strict consider Σ = {σ = p(x, x1), p(x1, x2), p(x2, z) →
∃y p(x, y), p(y, z)}. Σ is not FO-rewritable as for the
Boolean query Q = {p(a, u), p(u, b)}, where a and
b are constants, (Q, Σ) is not FO-rewritable (we would
need an inﬁnite union of Boolean CQs of
the form
{p(a, u0), ...p(ui−1, ui), p(ui, b)}, none of these queries be-
ing contained in another). However, Σ ∈ FO-RAF as (Q, Σ)

2It follows from the Homomorphism preservation theorem, a

classical result in model theory.

is FO-rewritable for any Q ∈ AF . Indeed, σ cannot bring any
answer to such query (in more technical terms, an existential
variable of σ cannot be uniﬁed with an answer variable).

Note also that since full-atomic queries have only answer
variables, they cannot be rewritten by means of FE-rules.
Thus, every set of FE-rules is trivially in FO-RAF. More in-
terestingly, to check if Σ ∈ FO-RAF one can restrict the full-
atomic queries of interest to those corresponding to the heads
of the datalog rules yielded by the DF-decomposition of Σ.
Proposition 9. Let Σ be a ruleset and HDΣ be the full-atomic
queries given by heads of the datalog rules in DF(Σ). Then,
Σ ∈ FO-RAF if and only if Σ ∈ FO-RHDΣ .

The following lemma upper bounds the rank of all facts
with terms in I for sets of rules enjoying FO-rewritability on
full-atomic queries.
Lemma 10. If Σ ∈ FO-RAF there is a constant kAF such that,
for any instance I and fact f such that terms(f ) ⊆ terms(I),
when f ∈ o-chase(I, Σ) it holds that rank(f ) ≤ kAF.

Proof. The number of (non-isomorphic) full-atomic queries
to be considered is ﬁnite, as for Proposition 9. We take for
kAF the maximal number of breadth-ﬁrst rewriting steps nec-
essary to obtain a UCQ-rewriting of a full-atomic query (we
refer here to the breadth-ﬁrst rewriting based on aggregated
piece-uniﬁers, see [K¨onig et al., 2013]).

The previous lemma also holds for the so-chase, how-
ever we want to derive a bound on the rank of facts with
a certain frontier depth, and for that full-atomic rewritabil-
ity is not enough. To illustrate, consider Σ = {σ =
p(x, y, u), p(y, z, v) → ∃w p(x, z, w)}. Here Σ ∈ FO-RAF
(the only rewriting of a full-atomic query is the query itself
because of the existential variable w). For any instance I, the
frontier depth of facts in the so-chase is bounded by 1, how-
ever there is no bound on their rank (although the so-chase
terminates). Therefore, we give a different property for the
so-chase, which requires the power of FO-rewritability.
Lemma 11. If Σ ∈ FO-R there is a constant kFO such that,
for any instance I and any trigger (σ, π) from so-chase(I, Σ)
with π(fr(σ)) ⊆ terms(I), there is also a trigger (σ, π(cid:48)) from
so-chase(I, Σ) such that π(cid:48)
|fr(σ) = π|fr(σ) and rank(f ) ≤ kFO
for all f ∈ π(cid:48)(body(σ)).

Proof. Similar to the proof of Lemma 10 but considering
CQs of the form Qbody(σ) whose atoms correspond to the
atoms of body(σ), for σ ∈ Σ, and all variables are existen-
tially quantiﬁed except for those in fr(σ). The number of such
queries is bounded by the cardinal of Σ. We take for kFO the
maximal number of breadth-ﬁrst rewriting steps necessary to
obtain a UCQ-rewriting from any Qbody(σ) query. The proof
actually shows that FO-rewritability with respect to rule body
queries is sufﬁcient to derive the lemma.

5 Boundedness: Linking Depth and Rank
We can ﬁnally establish a connection between the rank and
depth of a fact when the chase is run on FO-rewritable sets of
rules. This will immediately lead us to a characterization of
boundedness for the oblivious and semi-oblivious chases.

Theorem 12. If Σ ∈ FO-RAF then for all instance I and
fact f ∈ o-chase(I, Σ) we have that rank(f ) ≤ depth∃(f ) ×
(kAF + 1) + kAF with kAF the bound provided by Lemma 10.
Theorem 13. If Σ ∈ FO-R then for all instance I and fact
f ∈ so-chase(I, Σ) we have that rank(f ) ≤ depthfr
∃(f ) ×
(kFO + 1) + kFO with kFO the bound provided by Lemma 11.
For the o-chase, boundedness is exactly termination and
FO-rewritability on full-atomic queries. Furthermore, for
rulesets in CTo, the notions of FO-R and FO-RAF coincide.
Theorem 14. FO-RAF ∩ CTo = BNo = FO-R ∩ CTo

Proof. We start by showing that BNo ⊆ FO-R ∩ CTo. By
deﬁnition BNo ⊆ CTo. Then, BNo ⊆ FO-R follows from the
equivalence between FO-R and the bounded-depth derivation
property [Gottlob et al., 2014]. Moreover, by Proposition 8
we have BNo ⊆ FO-RAF ∩ CTo. To conclude the proof, by
Theorem 4 and 12 we have that FO-RAF ∩ CTo ⊆ BNo and
again by Proposition 8 follows FO-R ∩ CTo ⊆ BNo.

For the so-chase, boundedness can be characterized again

as termination and FO-rewritability by Theorem 7 and 13.
Theorem 15. BNso = FO-R ∩ CTso

Summing up, we have the following differences between
boundedness for o-chase and so-chase. o-chase-boundedness
requires i) o-chase termination and full-atomic-rewritability
and ii) is equivalent to o-chase termination for FE-rules.
Intuitively, when a set of rules Σ is decomposed into
DF(Σ), the fully-existential part may cause non-termination
of the o-chase, while the datalog part may cause non-FO-
rewritability. Furthermore, the fully-atomic queries possi-
bly leading to inﬁnite rewritings in this case correspond to
the heads of the datalog rules. Note however that this re-
stricted form of FO-rewritability has still to be veriﬁed with
In contrast, so-chase-
respect to the whole set of rules.
boundedness i) requires a stronger form of FO-rewritability
and ii) FE-rules do not behave differently from general exis-
tential rules for this chase. Intuitively, for the so-chase, any
existential rule (even an FE-rule) has an “underlying” data-
log rule. This is illustrated by the following transformation.
To each rule σ in Σ we assign a special predicate pσ of ar-
ity |fr(σ)|. Ψ(Σ) is obtained from Σ by replacing each rule
σ = B → H with two rules: a datalog rule B → pσ(fr(σ))
and a rule pσ(fr(σ)) → H. It can be shown that Σ ∈ CTso
iff Ψ(Σ) ∈ CTo and that Σ ∈ BNso iff Ψ(Σ) ∈ BNo. This
may also provide an alternative path to study so-chase bound-
edness by reducing it to o-chase boundedness.

6 Decidability and Complexity

From the undecidability of (uniform) boundedness of datalog
[Hillebrand et al., 1995], we immediately obtain the undecid-
ability of membership to BNo and BNso. A notable class of
datalog rules with decidable boundedness (more precisely in
linear time) is chain datalog [Guessarian and Peixoto, 1994].
We obtain that membership to BNso, CTso and FO-R remains
undecidable for FE-rules, while the decidability of member-
ship to BNo, hence to CTo, is still open.

Importantly, new decidability and complexity results about
boundedness for speciﬁc existential rules studied in the litera-
ture can be obtained as direct corollaries of our results. This is
in particular the case for classes known to be FO-rewritable.
Corollary 16. For any class of existential rules C ∈ FO-R, it
holds that: C ∈ BNo iff C ∈ CTo, and C ∈ BNso iff C ∈ CTso.
This implies that membership to BNo and BNso is PSpace-
complete for the two main classes of FO-rewritable existen-
Indeed, deciding CTo
tial rules, namely linear and sticky.
and CTso is PSpace-complete for both [Calautti et al., 2015;
Calautti and Pieris, 2019]. We also get an upper bound on
the complexity of membership to BNo and BNso for a major
class of existential rules, namely guarded. This class is nei-
ther CTso nor FO-R. However, membership to CTo and CTso
for guarded rules is decidable in 2Exptime [Calautti et al.,
2015]. Then a careful reduction from [Barcel´o et al., 2018]
allows us to set the result. The paper shows that checking
FO-rewritability for a single query under guarded rules is in
2Exptime. This sufﬁces since by Lemma 10 and 11 we need
to test only a polynomial number of queries.

We conclude by considering the k-boundedness problem,
which asks wether the chase actually halts within k steps. The
problem is decidable for the breadth-ﬁrst (semi-)oblivious
chase and any set of existential rules [Delivorias et al., 2018].
Therefore, the k-boundedness question becomes interesting
for dealing with fragments of existential rules where bound-
edness is undecidable. We study here the complexity of the
following version of the problem. Given a ruleset Σ and a
(unary encoded) integer k, does it hold that (cid:63)-chasek(I, Σ) =
(cid:63)-chase(I, Σ) for all instance I?
Theorem 17. Deciding k-boundedness is in 2Exptime
for existential rules for the o-chase and so-chase; co-
NExptime-complete for datalog rules; in co-NExptime on FE-
rules for the o-chase.

Proof. (Sketch) The membership results rely on the de-
cidability arguments from [Delivorias et al., 2018]. Co-
NExptime-hardness for datalog is by reduction from the co-
NExptime-hard inclusion problem of non-recursive Boolean
datalog queries [Benedikt and Gottlob, 2010].

7 Outline and Perspectives
In this paper, we have characterized boundedness in terms of
FO-rewritability and chase termination, for the oblivious and
semi-oblivious chase variants. We conclude with a discussion
on the extent of our results to more powerful chase variants
(i.e., which terminate at least when the semi-oblivious chase
terminate). Theorem 13 suggests that whenever Σ ∈ FO-R
if any such chase generates only terms of bounded frontier
depth on all instances, then Σ is bounded. We leave open
the question to determine if for other chase variants, like the
restricted and the core chases, boundedness is again the inter-
section of chase termination and FO-rewritability.
Acknowledgements.
This work was supported by ANR
projects CQFD (ANR-18-CE23-0003), DataCert (ANR-15-
CE39-0009), DeLTA (ANR-16- CE40-0007) and the CNRS-
Momentum project Managing-Data.

References
[Ajtai and Gurevich, 1994] Miklos Ajtai and Yuri Gurevich.

Datalog vs ﬁrst-order logic. 1994.

[Baget et al., 2011] Jean-Franc¸ois Baget, Michel Lecl`ere,
Marie-Laure Mugnier, and Eric Salvat. On rules with ex-
istential variables: Walking the decidability line. Artif. In-
tell., 175(9-10):1620–1654, 2011.

[Barcel´o et al., 2018] Pablo Barcel´o, Gerald Berger, Carsten
Lutz, and Andreas Pieris.
First-order rewritability of
frontier-guarded ontology-mediated queries. In Proceed-
ings of the Twenty-Seventh International Joint Conference
on Artiﬁcial Intelligence, IJCAI 2018, July 13-19, 2018,
Stockholm, Sweden., pages 1707–1713, 2018.

[Benedikt and Gottlob, 2010] Michael Benedikt and Georg
Gottlob. The impact of virtual views on containment.
PVLDB, 3(1):297–308, 2010.

[Calautti and Pieris, 2019] Marco Calautti

and Andreas
Pieris. Oblivious chase termination: The sticky case.
In 22nd International Conference on Database Theory,
ICDT 2019 (to appear), 2019.

[Calautti et al., 2015] Marco Calautti, Georg Gottlob, and
Andreas Pieris. Chase termination for guarded existen-
tial rules. In Proceedings of the 34th ACM Symposium on
Principles of Database Systems, PODS 2015, Melbourne,
Victoria, Australia, May 31 - June 4, 2015, pages 91–103,
2015.

[Cal`ı et al., 2009] Andrea Cal`ı, Georg Gottlob, and Thomas
Lukasiewicz. Datalog extensions for tractable query an-
In Semantic Web Information
swering over ontologies.
Management - A Model-Based Perspective, pages 249–
279. 2009.

[Cal`ı et al., 2013] Andrea Cal`ı, Georg Gottlob, and Michael
Kifer. Taming the inﬁnite chase: Query answering un-
der expressive relational constraints. J. Artif. Intell. Res.,
48:115–174, 2013.

[Calvanese et al., 2007] Diego Calvanese, Giuseppe De Gi-
acomo, Domenico Lembo, Maurizio Lenzerini, and Ric-
cardo Rosati. Tractable reasoning and efﬁcient query an-
swering in description logics: The DL-Lite family. J. Au-
tom. Reasoning, 39(3):385–429, 2007.

[Gottlob et al., 2014] Georg Gottlob,

Stanislav Kikot,
Roman Kontchakov, Vladimir Podolskii, Thomas
Schwentick, and Michael Zakharyaschev. The price of
query rewriting in ontology-based data access. Artiﬁcial
Intelligence, 213:42–59, 2014.

[Grau et al., 2013] Bernardo Cuenca Grau, Ian Horrocks,
Markus Kr¨otzsch, Clemens Kupke, Despoina Magka,
Boris Motik, and Zhe Wang. Acyclicity notions for ex-
istential rules and their application to query answering in
ontologies. J. Artif. Intell. Res., 47:741–808, 2013.

[Guessarian and Peixoto, 1994] Ir`ene Guessarian and Mar-
cos Veloso Peixoto. About boundedness for some datalog
and datalogneg programs. J. Log. Comput., 4(4):375–403,
1994.

[Hernich and Schweikardt, 2007] Andr´e Hernich and Nicole
Schweikardt. Cwa-solutions for data exchange settings
with target dependencies. In Proceedings of the Twenty-
Sixth ACM SIGACT-SIGMOD-SIGART Symposium on
Principles of Database Systems, June 11-13, 2007, Bei-
jing, China, pages 113–122, 2007.

[Hillebrand et al., 1995] Gerd G Hillebrand, Paris C Kanel-
lakis, Harry G Mairson, and Moshe Y Vardi. Undecidable
boundedness problems for datalog programs. The Journal
of logic programming, 25(2):163–190, 1995.

[K¨onig et al., 2013] M´elanie K¨onig, Michel Lecl`ere, Marie-
Laure Mugnier, and Micha¨el Thomazo. On the exploration
of the query rewriting space with existential rules. In Web
Reasoning and Rule Systems - 7th International Confer-
ence, RR 2013, Mannheim, Germany, July 27-29, 2013.
Proceedings, pages 123–137, 2013.

[Marnette, 2009] Bruno Marnette. Generalized schema-
In Proceed-
mappings: from termination to tractability.
ings of the Twenty-Eigth ACM SIGMOD-SIGACT-SIGART
Symposium on Principles of Database Systems, PODS
2009, June 19 - July 1, 2009, Providence, Rhode Island,
USA, pages 13–22, 2009.

[Carral et al., 2017] David Carral,

Irina Dragoste,

and
Markus Kr¨otzsch. Detecting chase (non)termination for
existential rules with disjunctions. In Proceedings of the
Twenty-Sixth International Joint Conference on Artiﬁcial
Intelligence, IJCAI 2017, Melbourne, Australia, August
19-25, 2017, pages 922–928, 2017.

[Delivorias et al., 2018] Stathis Delivorias, Michel Lecl`ere,
Marie-Laure Mugnier, and Federico Ulliana. On the
In International
k-boundedness for existential rules.
Joint Conference on Rules and Reasoning, pages 48–64.
Springer, 2018.

[Fagin et al., 2005] Ronald Fagin, Phokion G. Kolaitis,
Ren´ee J. Miller, and Lucian Popa. Data exchange: seman-
tics and query answering. Theor. Comput. Sci., 336(1):89–
124, 2005.

