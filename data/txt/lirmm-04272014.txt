Query Rewriting with Disjunctive Existential Rules and
Mappings
Michel Leclère, Marie-Laure Mugnier, Guillaume Pérution-Kihli

To cite this version:

Michel Leclère, Marie-Laure Mugnier, Guillaume Pérution-Kihli. Query Rewriting with Disjunctive
Existential Rules and Mappings. KR 2023 - 20th International Conference on Principles of Knowledge
Representation and Reasoning, Sep 2023, Rhodes, Greece. pp.429-439, ￿10.24963/kr.2023/42￿. ￿lirmm-
04272014￿

HAL Id: lirmm-04272014

https://hal-lirmm.ccsd.cnrs.fr/lirmm-04272014

Submitted on 6 Nov 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Public Domain

Query Rewriting with Disjunctive Existential Rules and Mappings

Michel Lecl`ere , Marie-Laure Mugnier , Guillaume P´erution-Kihli
LIRMM, Inria, University of Montpellier, CNRS, France
fleclere,mugnierg@lirmm.fr, guillaume.perution-kihli@inria.fr

Abstract

We consider the issue of answering unions of conjunctive
queries (UCQs) with disjunctive existential rules and map-
pings. While this issue has already been well studied from a
chase perspective, query rewriting within UCQs has hardly
been addressed yet. We ﬁrst propose a sound and com-
plete query rewriting operator, which has the advantage of
establishing a tight relationship between a chase step and a
rewriting step. The associated breadth-ﬁrst query rewriting
algorithm outputs a minimal UCQ-rewriting when one exists.
Second, we show that for any “truly disjunctive” nonrecur-
sive rule, there exists a conjunctive query that has no UCQ-
rewriting. It follows that the notion of ﬁnite uniﬁcation sets
(fus), which denotes sets of existential rules such that any
UCQ admits a UCQ-rewriting, seems to have little relevance
in this setting. Finally, turning our attention to mappings, we
show that the problem of determining whether a UCQ admits
a UCQ-rewriting through a disjunctive mapping is undecid-
able. We conclude with a number of open problems.

1

Introduction

Existential rules (Cal`ı, Gottlob, and Kifer 2008; Baget et
al. 2009; Cal`ı, Gottlob, and Lukasiewicz 2009), aka tuple
generating dependencies (Beeri and Vardi 1984), are an ex-
tension of datalog (i.e., ﬁrst-order function-free Horn rules),
which allows for existentially quantiﬁed variables in the rule
heads, e.g., 8x(human(x) ! 9y isParent(y; x)). They have
become a popular language to model ontologies and do rea-
soning on data. Then, a key issue is ontology-mediated
query answering, which consists of computing the answers
to a query on a knowledge base (KB), composed of a set of
facts (or data) F and an ontology O. In this context, most
works focus on the prominent class of (unions of) conjunc-
tive queries ((U)CQs). There are two main dual techniques
the chase, which
to compute the answers to a query Q:
enriches the facts F by performing a ﬁxpoint computation
with the ontology O until a canonical model of F and O
is obtained (then Q is evaluated on this canonical model),
and query rewriting, where Q is rewritten using O into a
query Q0, such that for any set of facts F , the evaluation
of Q0 on F yields the answers to Q on the KB. Query an-
swering with general existential rules is undecidable, how-
ever a wide range of decidable subclasses have been deﬁned,
based on syntactic restrictions that ensure the termination of
chase-like or query rewriting techniques. Tuple generating

dependencies (TGDs) are also the main formalism to repre-
sent schema mappings, which are high-level speciﬁcations
of the relationships between two database schemas (Fagin et
al. 2005). Schema mappings are at the core of many data in-
teroperability tasks, such as data exchange, data integration
or peer data management. More speciﬁcally, a mapping is
a set of TGDs, with bodies and heads expressed on disjoint
sets of predicates, namely S and T , called the source and
the target schemas. Given a database instance I on S and
a mapping M, a query expressed on T is posed on the set
of facts produced from I by triggering M; again, query an-
swering can be solved by chasing I with M or rewriting Q
with M into a query that is evaluated on I. Since mappings
are inherently nonrecursive, both techniques always termi-
nate. Finally, in the Ontology-Based Data Access (OBDA)
framework (Poggi et al. 2008), mappings specify relation-
ships between a database schema and an ontology. Here,
existential rules can be used as a uniform language to ex-
press both the ontology and the mapping (Buron, Mugnier,
and Thomazo 2021).

In

we

this

with

rules

paper,

consider

existential

the
disjunction,

Existential rules generalize popular description logics
(DLs) used to do reasoning on data, such as DL-Lite (Cal-
vanese et al. 2007), EL (Baader, Brandt, and Lutz 2005;
Lutz, Toman, and Wolter 2009) and more expressive Horn-
DLs (Kr¨otzsch, Rudolph, and Hitzler 2006). However, they
do not capture nondeterministic features, as offered by some
key DLs such as ALC (Schmidt-Schauß and Smolka 1991)
or the Semantic Web ontology language OWL (W3C 2009).
extension
e.g.,
of
8x8y(isGrandParent(x; y) ! 9z1
(isParent(x; z1) ^
isMother(z1; y)) _ 9z2 (isParent(x; z2) ^ isFather(z2; y))).
the usefulness of such rules
From a KR perspective,
has long been acknowledged for ontology modeling, but
also for expressing nondeterministic guessing in problem
solving, see e.g., (Eiter, Gottlob, and Mannila 1997). From
a database perspective, disjunction in schema mappings
received considerable attention in the context of mapping
management, where mapping composition and inversion
emerged as fundamental operators (Bernstein and Ho 2007;
Arenas et al. 2010). Indeed, disjunction is required to ex-
press several kinds of inverse mappings, like so-called quasi-
inverses or maximum recovery mappings (Fagin et al. 2008;
Arenas, P´erez, and Riveros 2008). Beside the issue of

Proceedingsofthe20thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack429constructing such mappings, the design of associated query
answering techniques is highly relevant. For instance, in a
peer data management system, a mapping M from peer P1
to peer P2 allows to rewrite a query on P2 in terms of P1,
while an inverse of M allows to rewrite a query on P1 in
terms of P2. As another example, consider a mapping M
from schema A to schema B, and assume that A evolves
into A0, which is expressed by a mapping M0; the relation
between A0 and B can be obtained by inverting M0 and
composing it with M; then, a query on B can be translated
into a query on A0 by rewriting it ﬁrst with M, then with the
inverse of M0 (P´erez 2013). Such scenario is also relevant
in OBDA, taking for B an ontology instead of a schema.

So far, reasoning with disjunctive existential rules has
been mainly studied through the chase. It was shown that
decidable classes of (conjunctive) existential rules, based on
the behavior of the chase, can be generalized to disjunctive
rules in a quite natural way, whether in relation to acyclic-
ity notions (Carral, Dragoste, and Kr¨otzsch 2017) or based
on guardedness (Alviano et al. 2012; Gottlob et al. 2012;
Bourhis et al. 2016), although these generalizations come
with a huge increase in the complexity of query answering.
In contrast, query rewriting within UCQs has been barely
addressed yet. A notable exception is the work in (Alfonso,
Chortaras, and Stamou 2021), which provides a rewrit-
ing technique based on ﬁrst-order resolution (see Section
3). A large body of work has studied the rewritability of
ontology-mediated queries, i.e., pairs of the form (Q; O)
with Q a (U)CQ and O an ontology, into query languages
of various expressivity. However, for ontologies expressed
in fragments of disjunctive existential rules, most studies
target expressive rewriting languages, like disjunctive dat-
alog (Bienvenu et al. 2014; Ahmetaj, Ortiz, and Simkus
2018). As far as we are aware, the only result directly rel-
evant to our purpose comes from the ﬁne-grained complex-
ity study in (Gerasimova et al. 2020), which provides syn-
tactic rewritability conditions for ontology-mediated queries
where the ontology is composed of a single speciﬁc disjunc-
tive rule, called a covering axiom (see Section 4).

Our contributions are the following:

• We ﬁrst deﬁne a sound and complete query rewriting op-
erator for UCQs and disjunctive existential rules, which
has the advantage of establishing a tight relationship be-
tween a chase step and a rewriting step (Theorem 3). The
associated breadth-ﬁrst query rewriting algorithm outputs
a minimal UCQ-rewriting when one exists (Theorem 4).

• We then turn our attention to the notion of ﬁnite uniﬁca-
tion sets (fus), which denotes sets of existential rules for
which any UCQ is UCQ-rewritable, i.e., admits a ﬁnite
sound and complete rewriting under the form of a UCQ.
Noting that the known fus classes for conjunctive exis-
tential rules do not seem to be generalizable to disjunc-
tive rules, we show that, in fact, for any “truly disjunc-
tive” nonrecursive rule, there is a CQ that is not UCQ-
rewritable (Theorem 5). This leads to question the rele-
vance of fus for disjunctive rules and to consider the prob-
lem of whether a speciﬁc UCQ is UCQ-rewritable.

• Finally, considering (disjunctive) mappings, we show that
the problem of determining whether a given UCQ on
the target schema admits a UCQ-rewriting on the source
schema is undecidable (Theorem 6).

Based on these results, we conclude with a number of open
problems. Detailed proofs are available in a technical report
(Lecl`ere, Mugnier, and P´erution-Kihli 2023).

2 Preliminaries
Generalities. We consider logical vocabularies of the
form V = (P; C), where P is a ﬁnite set of predicates and C
is a (possibly inﬁnite) set of constants. A term on V is a con-
stant from C or a variable. An atom on V has the form p(t)
where p 2 P is a predicate of arity n and t is a tuple of terms
on V with jtj = n. An atom with predicate p is also called
a p-atom. Given a formula or set of formulas S, we denote
by vars(S), consts(S) and terms(S) its sets of variables,
constants and terms, respectively. We will often see a tuple
x of pairwise distinct variables as a set. We denote by j=
and (cid:17) classical logical entailment and equivalence, respec-
tively. Given two sets of atoms S1 and S2, a homomorphism
h from S1 to S2 is a substitution of vars(S1) by terms(S2)
such that h(S1) (cid:18) S2 (we say that S1 maps to S2 by h). It
is well-known that, when we see S1 and S2 as existentially
closed conjunctions of atoms, S2 j= S1 iff S1 maps to S2.

A safe copy of an atom set S is obtained from S by a bijec-
tive renaming of its variables with fresh variables (i.e., that
do not occur elsewhere in the context of the computation).

Knowledge base. A set of facts F is a possibly inﬁnite
set of atoms, logically seen as an existentially closed con-
junction. When this set is ﬁnite we call it a fact base. A
disjunctive existential rule R (or simply rule hereafter) is a
closed formula of the form

8x8y ( B[x; y] !

n
_

i=1

9ziHi[xi; zi] )

where n (cid:21) 1, B and the Hi are non-empty ﬁnite conjunc-
tions of atoms with vars(B) = x [ y and vars(Hi) =

xi [ zi, x =

xi and x; y and the zi are pairwise dis-

n
S
i=1

joint; B is the body of R, also denoted by body(R), and
fH1; : : : ; Hng is the head of R, also denoted by head(R).
We also denote by headi(R) the i-th disjunct Hi of the head
of R. The set x is the frontier of R and is denoted by fr(R).
Its elements are called frontier variables. The set zi is the set
of existential variables of Hi, also denoted by exist(Hi),
and the union of all the exist(Hi) is the set of existen-
tial variables of R, also denoted by exist(R). Note that
constants may occur anywhere. For brevity, we often de-
note by B ! H1 _ : : : _ Hn a rule with body B and head
fH1; : : : ; Hng. A rule R is conjunctive if n = 1. A (dis-
junctive) rule R is (disjunctive) datalog if exist(R) = ;.

A (disjunctive) knowledge base (KB) is a pair (F; R),
where F is a fact base and R is a ﬁnite set of (disjunctive)
existential rules. We assume w.l.o.g. that distinct rules in R
have disjoint sets of variables. In examples, we may reuse
variables for simplicity.

Proceedingsofthe20thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack430Disjunctive chase. A rule R = B ! H1 _ : : : _ Hn is
applicable on a fact base F if there is a homomorphism h
from body(R) to F . The pair (R; h) is called a trigger on F .
The application of (R; h) to F is denoted by (cid:11)_(F; R; h); it
produces a set of n fact bases, each obtained by adding to
F a set of atoms obtained from headi(R) by replacing each
frontier variable x by h(x) and each existential variable by
a fresh variable. We denote by hsafei the extension of h that
safely renames exist(headi(R)) by fresh variables. Then:

(cid:11)_(F; R; h) = fF [ hsafei (headi(R)) j 1 (cid:20) i (cid:20) ng

The disjunctive chase procedure iteratively applies triggers
towards a ﬁxpoint. This procedure is often seen as the con-
struction of a tree, see in particular (Bourhis et al. 2016;
Carral, Dragoste, and Kr¨otzsch 2017).
Deﬁnition 1 (Derivation tree). A derivation tree T of a KB
(F; R) is a (possibly inﬁnite) rooted labeled tree (V; E; (cid:21)),
where V is the set of vertices, E the set of edges, and (cid:21) a
vertex labeling function inductively deﬁned as follows:
• (cid:21)(r) = F for the root r of T ;
• For each vertex v with children fv1; :::; vng, there is a
trigger (R; h) on (cid:21)(v) with R = B ! H1 _: : :_Hn 2 R
and the restriction of (cid:21) to the domain fv1; :::; vng is a
bijection to (cid:11)_((cid:21)(v); R; h).
Note that we do not impose any criterion of trigger ap-
plicability, as we do not aim at studying a particular chase
strategy. A branch (cid:13) of a rooted tree is a maximal path from
the root; we denote by nodes((cid:13)) its set of vertices. Given
a derivation tree T , we denote by (cid:0)(T ) the set of all its
branches. A trigger (R; h) on F is satisﬁed (by F ) if there
is an extension h0 of h with h0(headi(R)) (cid:18) F for some i.
A derivation tree (V; E; (cid:21)) is fair if, for each branch (cid:13) and
each vertex v 2 nodes((cid:13)), any trigger on (cid:21)(v) is satisﬁed in
a (cid:21)(v0) with v0 2 nodes((cid:13)). Finally, a chase tree is a fair
derivation tree.
Deﬁnition 2 (Disjunctive chase result). The result of
a disjunctive chase of F by R is chase(F; R) =
f S
(cid:21)(v) j (cid:13) 2 (cid:0)(T )g where T is a chase tree and
v2nodes((cid:13))
(cid:21) its labeling function.

From a logical viewpoint, the chase result is a disjunction
of existentially closed conjunctions of atoms. Neither the
chase tree nor the chase result are unique, however all the
results entail the same queries (see next Theorem 1). Al-
though the degree of each vertex in a chase tree is bounded
by the maximal number of disjuncts in a rule head, the tree
may have inﬁnite branches, and an inﬁnite number of them.
When the chase tree is ﬁnite, the result of the chase is the
(ﬁnite) set of fact bases associated with its leaves.

It is sometimes convenient to consider a linearization of a
ﬁnite derivation tree, which we call a derivation. A deriva-
tion of (fF g; R) is a ﬁnite sequence of sets of fact bases and
tk(cid:0)! Fk where
triggers D = (F0 = fF g) t1(cid:0)! F1
ti = (R; h) is a trigger of R 2 R on an Fj 2 Fi(cid:0)1 and
Fi = (Fi(cid:0)1 n fFjg) [ (cid:11)_(Fj; R; h), for all 1 (cid:20) i (cid:20) k.
To each ﬁnite derivation tree can be assigned a derivation

t2(cid:0)! : : :

obtained from any total ordering of the trigger applications
associated with the inner vertices in the tree, in a compatible
way with the parent-child partial order. When R is a set of
conjunctive rules, a derivation tree is a path and the Fi in a
derivation are singletons; then, a derivation can be seen as a
sequence of fact bases (instead of sets of fact bases).

Query Answering. A conjunctive query (CQ) Q takes the
form 9y (cid:30)[x; y], where x and y are disjoint tuples of vari-
ables, and (cid:30) is a ﬁnite conjunction of atoms with vars((cid:30)) =
x [ y. The variables in x are called answer variables.
A Boolean CQ has no answer variables. In a full CQ, all
variables are answer variables. An atomic CQ has a single
atom. A (Boolean) union of conjunctive queries (UCQ) is a
disjunction of (Boolean) CQs with the same tuple of answer
variables x. For clarity, we denote a UCQ by Q and a CQ
by Q. A set of facts F answers positively to a Boolean CQ
Q if F j= Q. More generally, a tuple of constants c is an
answer to a CQ Q on F if there is a substitution s such that
s(x) = c and F j= s(Q). This extends to a UCQ Q and a
set of sets of facts F : a tuple of constants c is an answer to
Q on F if for every Fi 2 F , there is a CQ Qj 2 Q such that
c is an answer to Qj on Fi.

W.l.o.g. we focus in this paper on Boolean queries, to
avoid technicalities related to answer variables. Hence, in
the following, by UCQ and CQ we refer to Boolean queries,
unless otherwise speciﬁed. We will often see a CQ as a set
of atoms, and a UCQ as a set of atoms sets.

The following theorem states that the disjunctive chase
provides a sound and complete procedure to decide whether
a UCQ is entailed by a disjunctive KB.

Theorem 1 (from (Bourhis et al. 2016)). Let Q be a
(Boolean) UCQ and (F; R) be a disjunctive KB. Then
F; R j= Q iff chase(F; R) j= Q (i.e., Fi
j= Q for all
Fi 2 chase(F; R)).

Example 1 (Colorability). Let F be a fact base on pred-
icates v (vertex) and e (edge) describing a graph G. Let
R = v(x) ! g(x) _ r(x) (“Every vertex has color green
or red”). Then, chase(F; fRg) yields all ways of color-
ing each vertex. Let the UCQ Q = fQ1; Q2g with Q1 =
fg(u); e(u; w); g(w)g and Q2 = fr(u); e(u; w); r(w)g.
The KB (F; fRg) answers positively to Q iff G is not 2-
colorable.

Given UCQs Q1 and Q2, we say that Q1 is more speciﬁc
than Q2 if Q1 j= Q2. Note that Q1 j= Q2 iff for all Q1 2
Q1, there is Q2 2 Q2 such that Q1 j= Q2 (i.e., Q2 maps
to Q1 by homomorphism). A CQ Q is minimal if it has no
strict subset Q0 ( Q such that Q0 (cid:17) Q (i.e., Q0 j= Q). A
UCQ Q is minimal if it has no strict subset Q0 ( Q such
that Q (cid:17) Q0 (whether each CQ in the UCQ is itself minimal
is not relevant for our results). A cover of a UCQ Q is a
minimal subset Q0 (cid:18) Q such that Q (cid:17) Q0. It is known that,
given two equivalent UCQs Q1 and Q2, there is a bijection
from any cover of Q1 to any cover of Q2 that maps each
CQ in Q1 to an equivalent CQ in Q2 (see, e.g., (K¨onig et al.
2015)).

Proceedingsofthe20thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack431Mappings. Given two disjoint sets of predicates S and T ,
respectively called the source and the target predicates, a
source-to-target (or S-to-T ) rule R is such that body(R)
uses predicates in S and head(R) uses predicates in T . A
(disjunctive) mapping M on (S; T ) is a ﬁnite set of S-to-T
(disjunctive) rules. In this setting, a fact base (or database
instance) is expressed on S and a query on T . Note that the
chase of a fact base with a mapping is always ﬁnite.

In the following, by rewriting of a
UCQ rewritability.
UCQ Q with a set of rules R, we mean a possibly inﬁnite
set of CQs Q0, such that for all fact base F , if F j= Q0
then F; R j= Q (in other words, a rewriting is by deﬁnition
sound). A rewriting Q0 of Q with R is complete if for all
fact base F , if F; R j= Q then F j= Q0. A ﬁnite complete
rewriting is called a UCQ-rewriting. A pair (Q; R) is called
UCQ-rewritable if it admits a UCQ-rewriting. The set R
itself is called UCQ-rewritable if for any UCQ Q, the pair
(Q; R) is UCQ-rewritable. In the framework of conjunctive
existential rules, a UCQ-rewritable set is also called a ﬁnite
uniﬁcation set (fus) (Baget et al. 2011). We shall extend this
term to disjunctive rules.
Example 2 (Transitivity). Let R = p(x; y) ^ p(y; z) !
p(x; z). The (Boolean) CQ Q1 = fp(a; b)g, where a and b
are constants, has no UCQ-rewriting with fRg, while the
(Boolean) CQ Q2 = fp(u; v)g has one, which is fQ2g.
Indeed, any complete rewriting of Q1 is inﬁnite as it con-
tains all the “paths” of p-atoms from a to b, which are pair-
wise incomparable by homomorphism. In contrast, the atom
p(u; v) maps by homomorphism to any path of p-atoms.

Finally, we recall some fundamental notions on rewriting
with conjunctive existential rules. We will rely on these to
deﬁne rewriting with disjunctive rules.

Query rewriting with conjunctive existential rules
In
the setting of conjunctive existential rules, query rewriting
can be performed using piece-uniﬁers; these are a general-
ization of classical uniﬁers that take care of existential vari-
ables in rule heads by unifying sets of atoms instead of sin-
gle atoms (Salvat and Mugnier 1996; Baget et al. 2009). In
short, a piece-uniﬁer uniﬁes a subset Q0 of a CQ Q and a
subset H 0 of a rule head, such that existential variables from
H 0 are uniﬁed only with variables of Q0 that do not occur
in Q n Q0. Next, we call separating variables of Q0 (w.r.t.
Q) the variables of Q0 that also occur in Q n Q0. It is con-
venient to represent a uniﬁer as a partition of a set of terms
rather than a substitution. Hence, we say that a partition P
of a set of terms is admissible if no class of P contains two
constants; we associate a substitution u with an admissible
partition Pu by selecting one term in each class with prior-
ity given to constants: for each class C in Pu, let ti be the
selected term, then for every tj 2 C, we set u(tj) = ti.
Deﬁnition 3 (Piece-uniﬁer). 1 Let Q be a CQ and R = B !
H be a conjunctive existential rule such that vars(Q) \
vars(B [ H) = ;. A piece-uniﬁer of Q with R is a triple

1In non-Boolean queries, answer variables have to be treated as

separating variables.

(cid:22) = (Q0; H 0; Pu) with Q0 6= ;, Q0 (cid:18) Q, H 0 (cid:18) H, and Pu
is an admissible partition on terms(Q0) [ terms(H 0) such
that:
1. u(Q0) = u(H 0), with u a substitution associated with Pu;
2. If a class C 2 Pu contains an existential variable (from
H 0), then the other terms in C are non-separating vari-
ables from Q0.
Let (cid:22) = (Q0; H 0; Pu) be a piece-uniﬁer of Q with R :
B ! H and u a substitution associated with Pu. The appli-
cation of (cid:22) produces the following CQ:

(cid:12)(Q; R; (cid:22)) = u(B) [ u(Q n Q0)

Example 3 (Piece-Uniﬁer). Let R = p(x; y) !
9z p1(x; z) ^ p2(y; z) and Q1 = fp1(u; v); s(v)g. There
is no piece-uniﬁer of Q1 with R since v is a separating vari-
able of Q0
1 = fp1(u; v)g, hence cannot be uniﬁed with z.
Let Q2 = fp1(u; v); s(u)g: now, there is a piece-uniﬁer
of Q2 with R, namely (cid:22)2 = (fp1(u; v)g; fp1(x; z)g; Pu2 )
Taking the sub-
with Pu2 = ffx; ug; fyg; fz; vgg.
7! zg, we obtain
stitution u2 = fu
7! x; v
(cid:12)(Q2; R; (cid:22)2) = fp(x; y); s(x)g.
let Q3 =
Finally,
fp1(u; v); p2(u; w); p1(t; v); s(t)g, and Q0
3 = Q3 n fs(t)g.
The triple (cid:22)3 = (Q0
3; head(R); Pu3 ) with Pu3 =
ffx; y; t; ug; fz; v; wgg is a piece-uniﬁer of Q3 with R. If
we select x and z in Pu3 , (cid:12)(Q3; R; (cid:22)3) = fp(x; x); s(x)g.

A piece-rewriting of a UCQ Q with a (conjunctive) rule
set R is a UCQ Qk obtained by a ﬁnite sequence of piece-
uniﬁer applications, i.e., (Q0 = Q); : : : ; Qk (k (cid:21) 0) such
that, for all 0 < i (cid:20) k, there is a piece-uniﬁer (cid:22) of Q 2 Qi(cid:0)1
with R 2 R such that Qi = Qi(cid:0)1 [ f(cid:12)(Q; R; (cid:22))g.

As stated below, piece-uniﬁers provide a sound and com-

plete query rewriting procedure:
Theorem 2 (from (Baget et al. 2011)). For any (conjunc-
tive) KB (F; R) and UCQ Q, there is a derivation of (F; R)
leading to an Fi such that Fi
j= Q iff there is a piece-
rewriting Qj of Q with R such that F j= Qj.

It follows that, when a pair (Q; R) is UCQ-rewritable, a
UCQ-rewriting can be obtained as a piece-rewriting. Let
us point out that a conjunctive mapping is always UCQ-
rewritable (or fus). Indeed, since it is made of S-to-T rules,
the application of a piece-uniﬁer of a CQ Q produces a CQ
with strictly fewer atoms on T than Q. Also, CQs that con-
tain predicates on T are useless in a rewriting.

3 Query Rewriting with Disjunctive Rules
Our generalization of query rewriting to disjunctive rules re-
lies on a simple idea: a query Q can be rewritten with a rule
R = B ! H1 _ (cid:1) (cid:1) (cid:1) _ Hn if each Hi contributes to partially
answer Q. Therefore, a uniﬁcation step consists of unify-
ing each Hi (using a piece-uniﬁer) with a safe copy Qi of
a CQ from Q ; safe copies ensure that the CQs involved in
the uniﬁcation have pairwise disjoint sets of variables. Note
that several safe copies of the same CQ from Q can be in-
volved. This yields a new CQ made of body(R) and the
remaining parts of the uniﬁed CQs, according to some ag-
gregation of the piece-uniﬁers. We need a few auxiliary no-
tions to specify this aggregation. Let P be a set of partitions

Proceedingsofthe20thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack432(not necessarily of the same set). The join of P, denoted
by join(P), is the partition obtained from P by making the
union of the partitions in P, then merging all non-disjoint
classes until ﬁxed point. E.g., given P composed of par-
titions ffx; ug; fy; vg; fz; wgg and ffx; y; ag; fz0; tgg, we
obtain join(P) = ffx; u; y; v; ag; fz; wg; fz0; tgg. We say
that a set of partitions associated with piece-uniﬁers is ad-
missible if its join is an admissible partition (i.e., it does not
contain a class with two constants).
Deﬁnition 4 (Disjunctive Piece-Uniﬁer and One-step
Piece-Rewriting). Let a rule R = B ! H1 _ (cid:1) (cid:1) (cid:1) _ Hn
and a UCQ Q. A disjunctive piece-uniﬁer (cid:22)_ of Q with R
is a set f(cid:22)1; : : : ; (cid:22)ng such that:
• for 1 (cid:20) i (cid:20) n, (cid:22)i = (Q0

i; H 0
i; Pui ) is a (conjunctive)
piece-uniﬁer of Qi, a safe copy of a CQ from Q, with the
(conjunctive) rule B ! Hi;

• and Pu_ = fPu1 ; : : : ; Pun g is admissible.
Given a substitution u_ associated with join(Pu_ ), the ap-
plication of (cid:22)_ produces the CQ

(cid:12)_(Q; R; (cid:22)_) = u_(B) [

[

1(cid:20)i(cid:20)n

u_ (Qi n Q0
i)

The one-step piece-rewriting of Q w.r.t. (cid:22)_ is

Q [ f(cid:12)_(Q; R; (cid:22)_)g
Example 4. Let R = p(x; y) ! 9z1 r(x; z1) _ 9z2 r(y; z2)
and the UCQ Q = fQg with Q = fs(u); r(u; v)g. Let
Q1 = fs(u1); r(u1; v1)g and Q2 = fs(u2); r(u2; v2)g
be two safe copies of Q, and let (cid:22)_ = f(cid:22)1; (cid:22)2g with
(cid:22)1 = (fr(u1; v1)g; fr(x; z1)g; ffu1; xg; fv1; z1gg) and
(cid:22)2 = (fr(u2; v2)g; fr(y; z2)g; ffu2; yg; fv2; z2gg). As-
sume we give priority to variables from R, i.e., we take the
substitution u_ = fu1 7! x; v1 7! z1; u2 7! y; v2 7! z2g.
Then (cid:12)_(Q; R; (cid:22)_) = fp(x; y); s(x); s(y)g.
Deﬁnition 5 (Piece-Rewriting). Given a disjunctive rule
set R, a UCQ Q0 is a piece-rewriting (or simply rewrit-
ing when clear from the context) of a UCQ Q with R if
there is a ﬁnite sequence (called rewriting sequence) Q =
Q0; Q1; : : : ; Qk = Q0 (k (cid:21) 0), such that for all 0 < i (cid:20) k,
there is a disjunctive piece-uniﬁer (cid:22)_ of Qi(cid:0)1 with R 2 R
such that Qi is the one-step rewriting of Qi(cid:0)1 w.r.t. (cid:22)_.

The following lemmas highlight fundamental properties

of (cid:11)_ and (cid:12)_.
Lemma 1 (Preservation of entailment by (cid:11)_ and (cid:12)_). Let
R be a disjunctive rule.
1. For any fact bases F1 and F2 such that F2 j= F1: if there
is a trigger (R; h1) on F1 then there is a trigger (R; h2)
on F2 such that (cid:11)_(F2; R; h2) j= (cid:11)_(F1; R; h1).

2. For any UCQs Q1 and Q2 such that Q2 j= Q1: if there
is a (disjunctive) piece-uniﬁer (cid:22)2 of Q2 with R then ei-
ther (cid:12)_(Q2; R; (cid:22)2) j= Q1, or there is a (disjunctive)
piece-uniﬁer (cid:22)1 of Q1 with R such that (cid:12)_(Q2; R; (cid:22)2) j=
(cid:12)_(Q1; R; (cid:22)1).
The second lemma clariﬁes the tight relationship between
(cid:11)_ and (cid:12)_ (we recall that fact bases and CQs have the same
logical form; this is also true of ﬁnite sets of fact bases and
UCQs).

(cid:12)_(Q; R; (cid:22)_)

(cid:12)_

Q

(cid:12)_(Q; R; (cid:22)_)

(cid:12)_

Q

j=

j=

j=

j=

(cid:11)_

F

(cid:11)_(F; R; h)

(cid:11)_

F

(cid:11)_(F; R; h)

Figure 1: Correspondences between (cid:12)_ (in blue) and (cid:11)_ (in red)

Lemma 2 (Composition of (cid:11)_ and (cid:12)_). Let R be a disjunc-
tive rule.

1. For any fact base F : if there is a trigger (R; h) on F then
there is a (disjunctive) piece-uniﬁer (cid:22) of (cid:11)_(F; R; h) with
R such that F j= (cid:12)_((cid:11)_(F; R; h); R; (cid:22)).

2. For any UCQ Q: if there is a piece-uniﬁer (cid:22) of Q with
R then there is a trigger (R; h) on (cid:12)_(Q; R; (cid:22)) such that
(cid:11)_((cid:12)_(Q; R; (cid:22)); R; h) j= Q.
These two lemmas are keys to establish the soundness and

completeness of piece-rewriting, as stated next.
Theorem 3 (Soundness and completeness of piece-rewrit-
ing). Let R be a set of disjunctive rules and Q be a UCQ.
Then, for any fact base F , holds F; R j= Q iff there is a
piece-rewriting Q0 of Q such that F j= Q0.

Proof. (Sketch) We show that
there is a derivation of
(fF g; R) leading to an Fi such that Fi j= Q iff there is
a rewriting Qj of Q with R such that F j= Qj (with more-
over j (cid:20) i). This equivalence relies on the following two
lemmas, which are corollaries of previous Lemmas 1 and 2.
Given any Boolean UCQ Q, disjunctive rule R and fact base
F , the following holds (see Figure 1):

• (Backward-forward Lemma) For any disjunctive piece-
uniﬁer (cid:22)_ of Q with R, if F j= (cid:12)_(Q; R; (cid:22)_) then there
is a trigger (R; h) on F such that (cid:11)_(F; R; h) j= Q;

• (Forward-backward Lemma) For any trigger (R; h) on F ,
if (cid:11)_(F; R; h) j= Q then either F j= Q or there is a
disjunctive piece-uniﬁer (cid:22)_ of Q with R, such that F j=
(cid:12)_(Q; R; (cid:22)_).

The ()) direction of the theorem is proved by induction
on the length k of a derivation from fF g to Fk such that
Fk j= Q, using forward-backward Lemma (which itself
follows from Lemma 2 (Point 1) and Lemma 1 (Point 2)).
The (() direction is proved by induction on the length k
of a rewriting sequence from Q to Qk such that F j= Qk,
using backward-forward Lemma (which itself follows from
Lemma 2 (Point 2) and Lemma 1 (Point 1)).

To actually compute a UCQ-rewriting of Q when one ex-
ists, it is convenient to proceed in a breadth-ﬁrst manner, i.e.,
extend Q at each step with all the CQs that can be generated
with (new) disjunctive piece-uniﬁers. More speciﬁcally, we
inductively deﬁne the following operator W , which takes as
input a UCQ Q and a disjunctive rule set R, and returns a
possibly inﬁnite set of CQs:
• W0(Q; R) = Q

Proceedingsofthe20thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack433i

• For

= Wi(cid:0)1(Q; R)[
f(cid:12)_(Wi(cid:0)1(Q; R); R; (cid:22)_)j(cid:22)_ piece-uniﬁer with R 2 Rg

0, Wi(Q; R)

>

• Finally, W (Q; R) = S
i2N

Wi(Q; R).

Proposition 1 (Properties of W ). For any UCQ Q and dis-
junctive rule set R, the following holds:

1. W (Q; R) is a complete rewriting of (Q; R).
2. If (Q; R) admits a UCQ-rewriting Q0, then there is i (cid:21) 0

such that Q0 (cid:17) Wi(Q; R).

Proof. (1) Each Wi(Q; R) is a piece-rewriting of Q with R
and, for any piece-rewriting Q0 of Q with R, there is i such
that Q0 (cid:18) Wi(Q; R). Hence, the union of all the Wi(Q; R)
is a complete rewriting of Q. (2) If (Q; R) admits a UCQ-
rewriting Q0, then by Theorem 3 it admits a complete piece-
rewriting Q00, and both are necessarily equivalent. Then,
Q00 (cid:18) Wi(Q; R) for some i and, since Q00 is complete,
Q00 (cid:17) Wi(Q; R).

We propose a query rewriting algorithm (see Algorithm 1)
that mimics the computation of W (Q; R), while including
two optimizations at each step i > 0. First, it only considers
new disjunctive piece-uniﬁers, i.e., those that involve at least
one CQ generated at step i(cid:0)1. Second, it removes redundant
CQs in the rewriting under construction, by the computation
of a cover. More speciﬁcally, Q? denotes the rewriting under
construction and Qnew the set of CQs generated at a given
step. The function cover (Lines 1 and 6) returns a cover
of the given set. The function generate (Line 5) takes as
input the current rewriting Q?, its subset Qprev of CQs gen-
erated at the previous step, as well as R, and returns the set
of generated CQs, i.e., all the (cid:12)_(Q?; R; (cid:22)_) where (cid:22)_ is
a new disjunctive piece-uniﬁer. This yields the set Qnew.
To compute a cover of Q? [ Qnew, priority is given to Q?
in case of query equivalence, for termination reasons. The
function removeMoreSpecific takes as input two sets of
CQs and returns the ﬁrst set minus its queries more speciﬁc
than a query of the second set. The computation of a cover
of Q? [ Qnew is decomposed into three steps (Lines 6-8):
compute a cover of Qnew; remove from Qnew the queries
more speciﬁc than a query from Q?; and remove from Q?
the queries more speciﬁc than a query from Qnew. Then,
Qnew is added to Q? (Line 9). We remind that a query may
have rewritings of unbounded size but still a UCQ-rewriting
(see Example 2), hence the role of the cover computation is
not only to remove redundancies but also to ensure that the
algorithm halts when a UCQ-rewriting has been found.

The correctness of the algorithm is based on the sound-
ness and completeness of the W operator, however attention
should be paid to the potential impact of query removal on
completeness (Lines 6 to 8). Indeed, when a CQ Q2 is re-
moved because it is more speciﬁc than another CQ Q1, we
have to ensure that any CQ that could be generated using
Q2 is more speciﬁc than another CQ already present in the
curent rewriting, or than a CQ that can be generated using
Q1. Fortunately, this property is ensured by Lemma 1 (Point
2), considering Q? and Qnew at the end of Line 5, then tak-
ing Q2 = Q? [ Qnew and Q1 = Q2 n fQ2g.

Algorithm 1: BREADTH-FIRST REWRITING
Data: UBCQ Q and set of disjunctive rules R
Result: A sound and complete rewriting of Q

1 Qnew   cover(Q); // new CQs
2 Q?   Qnew; // result
3 while Qnew 6= ; do
4

5

6

7

8

Qprev   Qnew // CQs from the preceding step
Qnew   generate(Q?; Qprev; R); // new CQs
Qnew   cover(Qnew)
Qnew   removeMoreSpecific(Qnew; Q?)
Q?   removeMoreSpecific(Q?; Qnew)
Q?   Q? [ Qnew

9
10 return Q?

Theorem 4. Algorithm 1 computes a sound and complete
rewriting. Moreover, it halts and outputs a minimal rewrit-
ing when (Q; R) is UCQ-rewritable.

Proof. By induction on the number of iterations of the while
loop, we prove the following invariant of the algorithm, us-
ing Lemma 1 (Point 2): after step i, Q? is equivalent to
Wi(Q; R). Then, soundness and completeness follow from
Proposition 1. Line 7 ensures that Qnew becomes empty
when Q? is a complete rewriting. Since a cover of Q? is
computed at each step, the output set is of minimal size.

Further remarks on completeness. When it comes to
practical implementations, one may ﬁnd simpler to rely on
(conjunctive) piece-uniﬁers that unify the smallest possi-
ble subsets of a CQ. Such piece-uniﬁers are called single-
piece (K¨onig et al. 2015). In the speciﬁc case of datalog,
a single-piece uniﬁer uniﬁes a single atom of a CQ with a
rule head. Piece-rewriting restricted to single-piece uniﬁers
is complete for conjunctive rules (K¨onig et al. 2015), but it
is no longer so with disjunctive rules. This occurs already in
the case of disjunctive datalog, as illustrated next.

Example 5. Consider again the colorability example
1) with R = v(x) ! g(x) _ r(x) and Q =
(Ex.
fQ1; Q2g with Q1 = fg(u); e(u; w); g(w)g and Q2 =
fr(u); e(u; w); r(w)g. With single-piece uniﬁers we obtain
CQs that have the shape of “chains” with a g-atom or an
r-atom at each extremity. However, there are also rewrit-
ings without any occurrence of g nor r, and the only way
of obtaining them is to unify two query atoms together. For
instance, the CQ fv(u); e(u; u)g is obtained by unifying, on
the one hand both g-atoms of a safe copy of Q1 with g(x),
and on the other hand both r-atoms of a safe copy of Q2
with r(x). More generally, using such piece-uniﬁers, one
can produce all the CQs that describe the odd-length cycles
in the graph. Note that these CQs are incomparable with the
CQs generated with single-piece uniﬁers. This example also
shows that a UCQ may have no UCQ-rewriting although
each of its CQs has one (which is here the CQ itself).

Proceedingsofthe20thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack434Related work. To the best of our knowledge, (Alfonso,
Chortaras, and Stamou 2021) is the only previous work
proposing a UCQ rewriting technique for general disjunc-
tive existential rules. This technique is based on a restricted
form of ﬁrst-order resolution, where at each step a CQ is
uniﬁed with a disjunct of a rule head (using a conjunctive
piece-uniﬁer), which produces a new disjunctive rule with
fewer disjunctions; when the uniﬁed rule is conjunctive, (the
negation of) a CQ is produced. In comparison, the main ad-
vantages of our proposal are the following: (1) a rewriting
step directly produces a CQ and not a rule, (2) intermedi-
ate rules, which may not lead to a CQ, are avoided, and (3)
there is a direct correspondence between a chase step and a
rewriting step, which makes it easier to study the properties
of query rewriting, especially as the rule set is not updated.

4 What are fus Disjunctive Rules?
We now address the question of identifying classes of dis-
junctive rules that are UCQ-rewritable. By extension of the
term coined for conjunctive existential rules, we also call
them fus. To the best of our knowledge, the only fus class of
disjunctive rules mentioned in the literature (Alfonso, Chor-
taras, and Stamou 2021) is actually a slight extension of
fus conjunctive rules: this class consists of disjunctive rules
with an empty frontier and it is shown that such rules can
be safely added to a set of fus conjunctive rules. As a mat-
ter of fact, known fus classes of conjunctive rules do not
seem to be extensible to the disjunctive case. And worse,
the straightforward extension of syntactic criteria that un-
derlie fus in the conjunctive case seems to easily lead to un-
decidability of query answering, as shown for example in
(Morak 2021) for the syntactic restriction called stickiness
(Cal`ı, Gottlob, and Pieris 2010).

At ﬁrst glance, one may expect nonrecursive disjunctive
rule sets to be fus, as it happens for conjunctive rules. How-
ever, it is not the case, as shown by the next example: a
CQ (on unary predicates) may have no UCQ-rewriting even
with a single non-recursive body-atomic (disjunctive) data-
log rule.
Example 6. Let the rule R = p(x; y) ! t1(x) _ t2(y) and
the BCQ Q = ft1(u); t2(u)g. Then the pair (fQg; fRg) has
no UCQ-rewriting. Indeed, a complete rewriting contains
all the CQs of the following shape for any n 2 N:

t2(u0) ^

  n
^

i=1

!

p(ui(cid:0)1; ui)

^ t1(un)

All these queries are pairwise incomparable w.r.t. homo-
morphism. Let us detail the ﬁrst rewriting step. To unify
fQg with R, we have to make two safe copies of Q, let Q1
and Q2, which are respectively uniﬁed with t1(x) and t2(y).
This produces the CQ ft2(x); p(x; y); t1(y)g, isomorphic to
ft2(u0); p(u0; u1); t1(u1)g. If we switch the uniﬁed atoms
of head(R), we obtain an isomorphic CQ. All subsequent
rewriting steps lead to longer paths of p-atoms.

A similar observation follows from (Gerasimova et al.
2020), which focuses on a speciﬁc disjunctive rule of the
form A(x) ! T (x) _ F (x), called a covering axiom and

denoted by covA; their complexity results imply that the sin-
gleton set fcovAg is not fus,2 which can be checked for in-
stance by considering the query Q = fT (u); p(u; v); F (v)g.

Next, we show that such observations can be generalized
to almost any source-to-target disjunctive rule. Evidently,
we have to exclude disjunctive rules that are equivalent to
a conjunctive rule, as classes of fus conjunctive rules are
known. We also exclude disconnected rules, i.e., rules R
such that body(R) [ head(R) is not a connected set of
atoms (where connectivity is deﬁned in the obvious way
based on shared variables). Note that a rule with a head
Hi that has an empty frontier is disconnected, as well as a
rule whose body has a connected component with an empty
frontier. However, a rule with a disconnected body may not
be disconnected, since head atoms may connect several con-
nected components of the body (e.g., a “product” rule like
b1(x)^b2(y) ! t1(x)_t2(y)_p(x; y) is not disconnected).
Example 7 (Fus disconnected rule). Let the disconnected
rule R = b(x) ! t1(x) _ 9z t2(z). R is not equivalent
to a conjunctive rule. Let us check that it is fus. Given any
UCQ Q, let Q2 be the subset of Q that contains all the CQs
that can be uniﬁed with 9z t2(z). Any Q 2 Q2 necessarily
contains a disconnected component of the form 9u t2(u).
Moreover, it is useless to unify Q with t1(x): in such case,
let Q2 be the CQ uniﬁed with 9z t2(z), then the obtained
rewriting is more speciﬁc than Q2. Hence, we can ignore
all the produced CQs that contain a connected component
of the form 9u t2(u). Rewriting Q with fRg amounts to
rewriting Q n Q2 with the conjunctive rule set R = fb(x) ^
(Q2 n f9u t2(u)g) ! t1(x) j Q2 2 Q2g, which belongs to
the fus class called domain restricted (Baget et al. 2011).

In the next theorem, we restrict the head of the rule to a

disjunction of two atom sets, to keep the proof simple.
Theorem 5. Let R = B ! H1 _ H2 be a source-to-target
rule that is not disconnected nor equivalent to a conjunctive
rule. Then, there is a CQ Q such that (fQg; fRg) is not
UCQ-rewritable.

Proof. (Sketch) Let R = B[x1; x2; y] ! 9z1 H1[x1; z1] _
9z2 H2[x2; z2)], where:

• fr(R) = x1 [ x2; x1 and x2 may share variables;
• xi 6= ; (i = 1; 2) since R is not disconnected.

We build the following (Boolean) CQ:

Q = fH s
where each H s

1 [v1; w1]; p(v1; v2); H s
i [vi; wi] is a safe copy of Hi[xi; zi] and p is
a fresh predicate. Note that, since R is connected, both H1

2 [v2; w2]g

2That paper studies syntactic conditions on ontology-mediated
CQs of the form (Q; covA) that determine the data complexity of
query answering and the rewritability in some target query lan-
guage. In particular, it is shown that if a (connected) CQ Q has
no term x with both atoms T (x) and F (x) and contains at least
one F -atom and one T -atom then answering (Q; covA) is L-hard
for data complexity. Since answering a UCQ-rewritable ontology-
mediated query is in AC 0 for data complexity, and AC 0 (cid:26) L, it
follows that no covA is fus.

Proceedingsofthe20thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack435and H2 have a frontier variable, and frontier variables being
renamed in each H s
i , the arity of p is at least 2. In p(v1; v2)
the order on the variables is important: a ﬁxed order is cho-
sen on xi (hence, vi) and the tuple v1 comes before the tuple
v2. Hence, p(v1; v2) can be seen as “directed” from v1 to
v2. We then proceed in two steps.

1. We show that we can produce an inﬁnite set Q whose ele-
ment CQs are pairwise incomparable by homomorphism.
Let Q0 = Q. At each step i (cid:21) 1, Qi is produced from a
safe copy of Q uniﬁed with H1 and a safe copy of Qi(cid:0)1
1 (resp. H s
uniﬁed with H2. The piece-uniﬁers unify H s
2 )
in Q (resp. Qi(cid:0)1) according to the isomorphism from H s
1
(resp. H s
2 ) to H1 (resp. H2). Any CQ Qk in Q is con-
nected and follows the “pattern” H s
1 , where
occurrences of p-atoms all have the same direction; hence,
two “adjacent” p-atoms, i.e., that share variables with the
same copy Bi of a B, cannot be mapped one onto the
other (by a homomorphism that maps Bi to itself).

2 :p:(B:p)k:H s

2. We show that no CQ Q0 that can be produced by piece-
rewriting maps by homomorphism to a CQ from Q,
except by isomorphism. When there is no (conjunc-
tive) piece-uniﬁer that uniﬁes H1[v1; w1] in Q with
H2[x2; z2] (the same holds if we exchange H1 and H2),
all the produced Q0 are more speciﬁc than (including iso-
morphic to) CQs from Q. Otherwise, assume that a CQ
Q0 is produced by unifying H1[v1; w1] with H2[x2; z2].
If Q0 can be mapped by homomorphism to a Qn 2 Q, the
arguments of any p-atom in Q0 must be pairwise distinct
variables. We show that it leads to have R equivalent to
the conjunctive rule B ! Hi (with i = 1 or i = 2), which
contradicts the hypothesis on R.

It follows that Q is a subset of any sound and complete
rewriting of fQg with fRg, hence the pair (fQg; fRg) does
not admit a UCQ-rewriting.

One interest of the above proof is to provide a general
construction that applies to any rule (fulﬁlling the conditions
of the theorem). Also, the proof can be generalized to a rule
head with k disjuncts, taking Q containing a safe copy of
each Hi plus a p-atom that connects these copies through
their frontier variables.

Given this result, the notion of fus disjunctive rules does
not seem to be particularly relevant. Studying the problem
of deciding whether a pair (Q; R) is UCQ-rewritable seems
more interesting, although it is known to be undecidable al-
ready for (conjunctive) datalog rules.3 Again, little is known
about classes of disjunctive rules and UCQs for which this
problem would be decidable. Let us point out a few imme-
diate cases of UCQ-rewritable pairs (Q; R):

• Q is composed of atomic CQs and R is a set of disjunctive
linear existential rules (i.e., rules with an atomic body).

3This follows from the undecidability of determining whether
a datalog program is uniformly bounded (Gaifman et al. 1993).
Indeed, a datalog program R is uniformly bounded iff the pair
(Q; R) is UCQ-rewritable for any full atomic query Q. In turn,
UCQ-rewritability of (Q; R) can be reduced to UCQ-rewritability
of (Q0; R) with Q0 a Boolean CQ.

Indeed, only atomic CQs can be produced, and there is a
ﬁnite number of them on a given set of predicates. This
case was already noticed in (Bourhis et al. 2016).

• Q is composed of atomic queries and R is a set of S-to-T
rules. The produced CQs are obtained from the rule bod-
ies by specializing their frontier (i.e., merging variables
and replacing them by constants occurring in Q and rule
heads). Hence, there is a ﬁnite number of them.

• Q is composed of variable-free CQs4 and R is a set of
lossless existential rules (i.e., such that all the variables
in a rule body are frontier). Then, no variable is intro-
duced by rewriting, hence the number of terms in a CQ is
bounded by jconsts(Q) [ consts(R)j.

5 Disjunctive Mappings
We now consider UCQ-rewritability with (disjunctive) map-
pings. Let S and T be the sets of source and target pred-
icates, respectively, and let M be a mapping on (S; T ).
Given a query on T , the aim is to obtain a complete rewrit-
ing w.r.t. fact bases on S. Because S and T are disjoint, CQs
that contain atoms on T are useless in a rewriting. Hence,
we deﬁne a mapping rewriting as a rewriting on S and use
the notation S-rewriting to distinguish it from a rewriting on
S [ T . An S-rewriting Q0 of a UCQ Q with M is complete
if, for all fact base F on S, if F; M j= Q then F j= Q0. A
ﬁnite complete S-rewriting is called a UCQ-S-rewriting.
Example 8 (Colorability). We adapt Example 5 to transform
the rule into a mapping. Let S = fv; eg, T = f^e; g; rg and
M = fm1; m2g, with:

m1 = e(x; y) ! ^e(x; y)
m2 = v(x) ! g(x) _ r(x).
Let Q = fQ1; Q2g with Q1 = fg(u); ^e(u; w); g(w)g and
Q2 = fr(u); ^e(u; w); r(w)g. Any complete S-rewriting of
Q contains CQs that describe all the cycles of odd length (in
other words, it deﬁnes non-2-colorability). All the other CQs
that can be produced by piece-rewriting contain predicates
g and r, hence are discarded.

Note that a query may have a UCQ-S-rewriting, while it
does not have any UCQ-rewriting (on S [ T ), as illustrated
by the next example.
Example 9. Let S = fpg and T = ft1; t2g. Con-
sider the (Boolean) CQ Q = ft1(u); t2(u)g and the rule
R = p(x; y) ! t1(x) _ t2(y) from Example 6. While the
pair (fQg; fRg) has no UCQ-rewriting, it has a UCQ-S-
rewriting, which is empty. Indeed, all the CQs that can be
obtained by piece-rewriting contain an atom on T .

Let disjunctive mapping rewritability be the following
problem: Given a disjunctive mapping M on (S; T ) and
a UCQ Q on T , does (Q; M) have a UCQ-S-rewriting ?
Theorem 6. Disjunctive mapping rewritability is undecid-
able.

Proof. (Sketch) We build a reduction from the following un-
decidable problem: Given a (Boolean) CQ Q and a set of

4If non-Boolean CQs are considered, Q can be extended to a

set of full CQs.

Proceedingsofthe20thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack436(conjunctive) datalog rules R, is the pair (fQg; R) UCQ-
rewritable? W.l.o.g. we assume that rules in R have no
constants (and an atomic head). The reduction translates
each instance (Q; R) deﬁned on a set of predicates P,
into an instance (QQ;R; MQ;R) of the disjunctive mapping
rewritability problem, deﬁned on a pair of predicats sets
(S; T ) such that:

• S = P [ fT g, where T is a fresh unary predicate,
• T is the union of: (1) a set of predicates in bijection with
S, where ^p denotes the predicate obtained from p 2 S,
and (2) a set of fresh predicates in bijection with R, where
pRi denotes the predicate associated with the rule Ri; the
arity of each pRi is jfr(Ri)j.
Given a conjunction Q (on P), we denote by QT the con-
junction (on S) obtained from Q by adding a T -atom on
each term; given a conjunction Q (on S), we denote by ^Q
the conjunction (on T ) obtained from Q by renaming all the
predicates p into ^p. Hence, cQT is obtained by performing
the ﬁrst operation, then the second. Given x = x1; : : : ; xn,
T [x] denotes the conjunction T (x1)^(cid:1) (cid:1) (cid:1)^T (xn). Similarly,
^T [x] = ^T (x1) ^ (cid:1) (cid:1) (cid:1) ^ ^T (xn).

Let Q and R = fR1; : : : ; Rng, where Ri = Bi[xi; yi] !
Hi[xi]. The instance (QQ;R; MQ;R) is deﬁned as follows:
• QQ;R = fQQg [ QR with:

QQ = cQT ,

QR = fQRi = 9xi; yi

\
(Bi)T [xi; yi] ^ pRi (xi)jRi 2 Rg

• MQ;R = MR [ Mtrans with:

MR = fmRi = T [xi] ! pRi (xi) _ ^Hi(xi) j Ri 2 Rg
Mtrans = fp(x) ! ^p(x) j p 2 Sg

Based on the natural bijection between the CQs QP de-
ﬁned on P and the CQs (QP )T deﬁned on S, we prove that
QP belongs to a rewriting of fQg with R iff (QP )T belongs
to a rewriting of QQ;R with MQ;R. Note that set mem-
bership is up to isomorphism throughout the proof. More
speciﬁcally, we ﬁrst prove the following lemmas:

1. For any CQ Qw in a piece-rewriting of fQg with R,
(Qw)T belongs to a piece-rewriting of QQ;R with MQ;R.
Indeed, to each Ri are associated a CQ QRi and a rule
mRi that allow to simulate any rewriting step performed
with Ri, using fresh predicate pRi .

2. Any CQ QS in an S-rewriting of QQ;R with MQ;R is of
the form QS = (QP )T , with QP the subset of QS on P.
3. For any CQ of the form (QP )T , with QP on P, that be-
longs a piece-rewriting of QQ;R with MQ;R, QP belongs
to a piece-rewriting of fQg with R?, where R? is the re-
ﬂexive and transitive closure of R by unfolding (i.e., rule
composition). Note that R? is logically equivalent to R.

We rely on these lemmas to prove the following: if there
is a UCQ-rewriting of (fQg; R) then there is a UCQ-S-
rewriting of (QQ;R; MQ;R). The proof of the opposite di-
rection is similar. Let Q be a UCQ-rewriting of (fQg; R).
Then there is a piece-rewriting Qi of fQg with R such
that Qi (cid:17) Q. By Lemma 1, there is a piece-rewriting

Qj of QQ;R with MQ;R that contains all the CQs of the
form (Qw)T in bijection with the Qw in Qi. By deﬁni-
tion, Qj is a ﬁnite rewriting of (QQ;R; MQ;R) and the
subset QS
j of Qj that contains only the CQs on S is a ﬁ-
nite S-rewriting of (QQ;R; MQ;R). Now, assume QS
j is
not complete, i.e., there is a CQ that belongs to an S-
rewriting of (QQ;R; MQ;R) but that is not more speciﬁc
than a CQ in QS
j ; by Lemma 2, such CQ is of the form
(QP )T . Then there is a piece-rewriting Q0
j of QQ;R with
MQ;R that contains a CQ entailed by (QP )T ; hence such
P )T .
CQ is also on S, and by Lemma 2 it is of the form (Q0
By Lemma 3, Q0
P belongs to a piece-rewriting of fQg with
R?. Since R? (cid:17) R, there is a CQ equivalent to Q0
P in
some rewriting of (fQg; R). Since Qi is complete, there is
Qc 2 Qi such that Q0
P )T j= (Qc)T ,
so (QP )T j= (Qc)T ; by Lemma 1, (Qc)T 2 Qj, hence
j , which contradicts the fact that (QP )T is not
(Qc)T 2 QS
more speciﬁc than a CQ in QS
j .

P j= Qc. Hence, (Q0

6 Perspectives

In conclusion, UCQ rewriting with disjunctive existential
rules appears to be extremely challenging. The main classes
that ensure termination for conjunctive rules fail to be gen-
eralized. As suggested by previous work in (Gerasimova et
al. 2020) and our Theorem 5, the fus notion applied to dis-
junctive rules does not seem to add much w.r.t. fus conjunc-
tive rules. However, it might be more relevant in the context
of mappings (when it becomes UCQ-S-rewritability), which
still has to be studied. Beside, a number of interesting issues
remain open, in relationship with the ﬁnite rewritability of a
pair (Q; R). We list here some of them:
1. Clarify the boundary between decidability and undecid-
ability for the problem of determining whether a pair
(Q; R) is UCQ-rewritable, according to speciﬁc classes
of rules (and queries). In particular, UCQ-rewritability is
decidable for guarded conjunctive rules and some of their
generalizations (Barcel´o et al. 2018), does this extend to
the disjunctive case?

2. We have shown that the UCQ-S-rewritability of a pair
(Q; M) is undecidable (Theorem 6). Is it still the case
for a pair (fQg; M) where Q is a CQ?

3. Our undecidability proof for UCQ-S-rewritability (The-
orem 6) exploits the fact that rewritings are restricted to
predicates in S. If we consider instead UCQ-rewritings
with source-to-target rules, we know that the problem can
only be simpler, as there is an easy reduction from UCQ-
rewritability with S-to-T -rules to UCQ-S-rewritability
with mappings (one simply has to add a mapping rule per
target predicate to give it an existence at the source level).
Is the UCQ-rewritability of a pair (Q; R) decidable when
R is a set of S-to-T rules?

4. Design an algorithm that, given a pair (Q; M), outputs a

UCQ-S-rewriting for this pair when one exists.

Proceedingsofthe20thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack437Acknowledgements
This work is partly supported by the ANR project CQFD
(ANR-18-CE23-0003).

References
Ahmetaj, S.; Ortiz, M.; and Simkus, M. 2018. Rewriting
In
guarded existential rules into small datalog programs.
21st International Conference on Database Theory, ICDT
2018, volume 98 of LIPIcs, 4:1–4:24.
Alfonso, E. M.; Chortaras, A.; and Stamou, G.
2021.
Ucq-rewritings for disjunctive knowledge and queries with
negated atoms. Semantic Web 12(4):685–709.
Alviano, M.; Faber, W.; Leone, N.; and Manna, M. 2012.
Disjunctive datalog with existential quantiﬁers: Semantics,
decidability, and complexity issues. Theory Pract. Log. Pro-
gram. 12(4-5):701–718.
Arenas, M.; P´erez, J.; Reutter, J. L.; and Riveros, C. 2010.
In 29th
Foundations of schema mapping management.
ACM SIGMOD-SIGACT-SIGART Symposium on Principles
of Database Systems, PODS 2010, 227–238. ACM.
Arenas, M.; P´erez, J.; and Riveros, C. 2008. The recovery of
a schema mapping: bringing exchanged data back. In 27th
ACM SIGMOD-SIGACT-SIGART Symposium on Principles
of Database Systems, PODS 2008, 13–22. ACM.
Baader, F.; Brandt, S.; and Lutz, C. 2005. Pushing the EL
envelope. In 19th International Joint Conference on Artiﬁ-
cial Intelligence, IJCAI 2005, 364–369.
Baget, J.-F.; Lecl`ere, M.; Mugnier, M.-L.; and Salvat, E.
2009. Extending Decidable Cases for Rules with Existential
Variables. In 21st International Joint Conference on Artiﬁ-
cial Intelligence, IJCAI 2009, 677–682.
Baget, J.; Lecl`ere, M.; Mugnier, M.; and Salvat, E. 2011.
On rules with existential variables: Walking the decidability
line. Artif. Intell. 175(9-10):1620–1654.
Barcel´o, P.; Berger, G.; Lutz, C.; and Pieris, A. 2018. First-
order rewritability of frontier-guarded ontology-mediated
queries. In 27th International Joint Conference on Artiﬁcial
Intelligence, IJCAI 2018, 1707–1713. ijcai.org.
Beeri, C., and Vardi, M. Y. 1984. A proof procedure for data
dependencies. J. ACM 31(4):718–741.
Bernstein, P. A., and Ho, H. 2007. Model management and
In 33rd Interna-
schema mappings: Theory and practice.
tional Conference on Very Large Data Bases, VLDB, 2007,
1439–1440. ACM.
Bienvenu, M.; ten Cate, B.; Lutz, C.; and Wolter, F. 2014.
Ontology-based data access: A study through disjunctive
datalog, csp, and MMSNP. ACM Trans. Database Syst.
39(4):33:1–33:44.
Bourhis, P.; Manna, M.; Morak, M.; and Pieris, A. 2016.
Guarded-Based Disjunctive Tuple-Generating Dependen-
cies. ACM Trans. Database Syst. 41(4):27:1–27:45.
Buron, M.; Mugnier, M.; and Thomazo, M. 2021. Parallelis-
able existential rules: a story of pieces. In 18th International
Conference on Principles of Knowledge Representation and
Reasoning, KR 2021, 162–173.

Cal`ı, A.; Gottlob, G.; and Kifer, M. 2008. Taming the in-
ﬁnite chase: Query answering under expressive relational
constraints. In 11th International Conference on Principles
of Knowledge Representation and Reasoning, KR 2008, 70–
80. AAAI Press.
Cal`ı, A.; Gottlob, G.; and Lukasiewicz, T. 2009. A General
Datalog-Based Framework for Tractable Query Answering
over Ontologies. In 28th ACM SIGMOD-SIGACT-SIGART
Symposium on Principles of Database Systems, PODS 2009,
77–86. ACM.
Cal`ı, A.; Gottlob, G.; and Pieris, A. 2010. Advanced pro-
cessing for ontological queries. VLDB Endow. 3(1):554–
565.
Calvanese, D.; De Giacomo, G.; Lembo, D.; Lenzerini, M.;
and Rosati, R. 2007. Tractable Reasoning and Efﬁcient
Query Answering in Description Logics: The DL-Lite Fam-
ily. Journal of Automated Reasoning 39(3):385–429.
Carral, D.; Dragoste, I.; and Kr¨otzsch, M. 2017. Restricted
Chase (Non)Termination for Existential Rules with Disjunc-
In 26th International Joint Conference on Artiﬁcial
tions.
Intelligence, IJCAI 2017, 922–928. ijcai.org.
Eiter, T.; Gottlob, G.; and Mannila, H. 1997. Disjunctive
datalog. ACM Trans. Database Syst. 22(3):364–418.
Fagin, R.; Kolaitis, P. G.; Miller, R. J.; and Popa, L. 2005.
Data exchange: semantics and query answering. Theor.
Comput. Sci. 336(1):89–124.
Fagin, R.; Kolaitis, P. G.; Popa, L.; and Tan, W. C. 2008.
Quasi-inverses of schema mappings. ACM Trans. Database
Syst. 33(2):11:1–11:52.
Gaifman, H.; Mairson, H. G.; Sagiv, Y.; and Vardi, M. Y.
1993. Undecidable optimization problems for database logic
programs. J. ACM 40(3):683–713.
Gerasimova, O.; Kikot, S.; Kurucz, A.; Podolskii, V. V.; and
Zakharyaschev, M. 2020. A data complexity and rewritabil-
ity tetrachotomy of ontology-mediated queries with a cov-
In 17th International Conference on Princi-
ering axiom.
ples of Knowledge Representation and Reasoning, KR 2020,
403–413.
Gottlob, G.; Manna, M.; Morak, M.; and Pieris, A. 2012. On
the complexity of ontological reasoning under disjunctive
existential rules. In Mathematical Foundations of Computer
Science 2012 - 37th International Symposium, MFCS 2012,
volume 7464 of LNCS, 1–18. Springer.
K¨onig, M.; Lecl`ere, M.; Mugnier, M.; and Thomazo, M.
2015. Sound, complete and minimal ucq-rewriting for exis-
tential rules. Semantic Web 6(5):451–475.
Kr¨otzsch, M.; Rudolph, S.; and Hitzler, P. 2006. On the
complexity of Horn description logics. In 2nd Workshop on
OWL: Experiences and Directions, volume 216 of CEUR
WS Proceedings. CEUR-WS.org.
Lecl`ere, M.; Mugnier, M.; and P´erution-Kihli, G. 2023.
Query rewriting with disjunctive existential rules and map-
pings. CoRR abs/2306.05973.
Lutz, C.; Toman, D.; and Wolter, F. 2009. Conjunctive
Query Answering in the Description Logic EL Using a Re-

Proceedingsofthe20thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack438lational Database System. In 21st International Joint Con-
ference on Artiﬁcial Intelligence, IJCAI 2009, 2070–2075.
Morak, M. 2021. Sticky Existential Rules and Disjunc-
tion are Incompatible. In 18th International Conference on
Principles of Knowledge Representation and Reasoning, KR
2021, 691–695.
P´erez, J. 2013. The inverse of a schema mapping. In Data
Exchange, Integration, and Streams, volume 5 of Dagstuhl
Follow-Ups. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Infor-
matik. 69–95.
Poggi, A.; Lembo, D.; Calvanese, D.; Giacomo, G. D.;
Lenzerini, M.; and Rosati, R. 2008. Linking Data to On-
tologies. J. Data Semant. 10:133–173.
Salvat, E., and Mugnier, M. 1996. Sound and Complete
Forward and Backward Chainings of Graph Rules. In 4th
International Conference on Conceptual Structures, ICCS
1996, volume 1115 of Lecture Notes in Computer Science,
248–262. Springer.
Schmidt-Schauß, M., and Smolka, G. 1991. Attributive con-
cept descriptions with complements. Artif. Intell. 48(1):1–
26.
W3C. 2009. OWL 2 Web Ontology Language: Document
Overview. http://www.w3.org/TR/owl2-overview/.

Proceedingsofthe20thInternationalConferenceonPrinciplesofKnowledgeRepresentationandReasoningMainTrack439