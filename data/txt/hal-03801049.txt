Capturing Homomorphism-Closed Decidable Queries
with Existential Rules (Extended Abstract)
Camille Bourgaux, David Carral, Markus Krötzsch, Sebastian Rudolph,

Michaël Thomazo

To cite this version:

Camille Bourgaux, David Carral, Markus Krötzsch, Sebastian Rudolph, Michaël Thomazo. Capturing
Homomorphism-Closed Decidable Queries with Existential Rules (Extended Abstract). IJCAI-ECAI
2022 - 31st International Joint Conference on Artificial Intelligence - 25th European Conference on Ar-
tificial Intelligence, Jul 2022, Vienna, Austria. pp.5269-5273, ￿10.24963/ijcai.2022/733￿. ￿hal-03801049￿

HAL Id: hal-03801049

https://hal.science/hal-03801049

Submitted on 6 Oct 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Capturing Homomorphism-Closed Decidable Queries with Existential Rules
(Extended Abstract)∗
Camille Bourgaux1 , David Carral2 , Markus Kr¨otzsch3 ,
Sebastian Rudolph3 and Micha¨el Thomazo1
1 DI ENS, ENS, CNRS, PSL University & Inria, Paris, France
2 LIRMM, Inria, University of Montpellier, CNRS, Montpellier, France
3 Technische Universit¨at Dresden, Dresden, Germany
{camille.bourgaux, david.carral, michael.thomazo}@inria.fr,
{markus.kroetzsch, sebastian.rudolph}@tu-dresden.de

Abstract

Existential rules are a very popular ontology-
mediated query language for which the chase rep-
resents a generic computational approach for query
answering.
It is straightforward that existential
rule queries exhibiting chase termination are de-
cidable and can only recognize properties that are
preserved under homomorphisms. This paper is an
extended abstract of our eponymous publication at
KR 2021 where we show the converse: every decid-
able query that is closed under homomorphism can
be expressed by an existential rule set for which the
standard chase universally terminates. Membership
in this fragment is not decidable, but we show via a
diagonalisation argument that this is unavoidable.

1 Introduction

At the core of contemporary logic-based knowledge repre-
sentation is the concept of querying data sources, often using
elaborate query formalisms that allow for taking background
knowledge into account. The classical decision problem re-
lated to such knowledge-aware querying is Boolean query en-
tailment. From an abstract point of view, a Boolean query
identiﬁes a class of databases D – those that satisfy the query,
i.e., to which the query “matches”. This view allows us to de-
ﬁne and investigate properties of (abstract) queries indepen-
dently from the syntax used to specify them. Such properties
can be structural (morphisms, closure properties) or compu-
tational (decidability, complexity).

A very popular querying formalism are existential rules,
also referred to as tuple-generating dependencies.
It is
straightforward that the class of databases satisfying some
existential rule query is closed under homomorphisms and re-
cursively enumerable. Conversely, it was established that ev-
ery homomorphism-closed query that is recursively enumer-
able can be expressed using existential rules [Rudolph and

∗This is an extended abstract of the paper that won the 2021 Ray
Reiter Best Paper Prize at the Int. Conf. on Principles of Knowledge
Representation and Reasoning [Bourgaux et al., 2021]

Thomazo, 2015]. That is, plain existential rules already re-
alize their full potential; further syntactic extensions within
these boundaries do not enhance expressivity.

For questions related to automated deduction, however, de-
cidability rather than recursive enumerability is of central in-
terest. The crucial question we tackle in this paper is thus:
Can we characterize an existential rules fragment capable of
expressing every decidable homomorphism-closed query?
The generic computational paradigm for existential rules, the
chase [Beeri and Vardi, 1984], is based on repetitive, forward-
chaining rule application, starting from the database. As this
may cause the iterated introduction of new domain elements,
this procedure is not guaranteed to terminate – yet, termina-
tion is a crucial criterion for decidability. The chase comes
in several variants, mainly differing in their (increasingly
thorough) mechanisms to prevent unnecessary rule applica-
tions: While the Skolem chase [Marnette, 2009] essentially
just avoids duplicate rule applications, the standard [Fagin et
al., 2005] and the core chase [Deutsch et al., 2008] check for
redundancy on a local and global level, respectively.

The class of existential rule sets with terminating1 Skolem
it
chase has already been weighed and found wanting:
only comprises those queries that are already expressible
in plain Datalog – and hence can be evaluated in polyno-
mial time [Marnette, 2009; Kr¨otzsch and Rudolph, 2011;
Zhang et al., 2015]. For the standard-chase-terminating and
the core-chase-terminating existential rules classes, on the
other hand, we only know that the former is contained in
the latter [Grahne and Onet, 2018], but little more than that
[Kr¨otzsch et al., 2019]. In this paper, we clarify the situation
signiﬁcantly by showing the following:
Standard-chase-terminating existential rules capture the
class of all decidable homomorphism-closed queries.

Notably, this implies that standard-chase-terminating and
core-chase-terminating existential rule queries are equally ex-
pressive and no decidable enhancement of this formalism that
preserves homomorphism-closedness (e.g. by allowing dis-
junction in rule heads) can be strictly more expressive.

As a downside, the existential rules fragment thus iden-
tiﬁed is not even semi-decidable, that is, one cannot semi-

1We always mean universal termination, i.e., for every database.

decide whether a set of rules is universally terminating for the
standard chase. We show that this downside is unavoidable:
There are no semi-decidable query languages that (i) ex-
press all decidable, homomorphism-closed queries and (ii)
for which query answering is decidable.

2 Preliminaries
We ﬁrst brieﬂy introduce the notions we need in this paper.

Rules We consider ﬁrst-order formulas over countably in-
ﬁnite sets Vars of variables and Preds of predicates, where
each p ∈ Preds has an arity Ar (p) ≥ 0. An atom is an
expression p((cid:126)x) with p ∈ Preds and (cid:126)x a list of variables of
length Ar (p). The fragment of disjunctive existential rules
consists of formulas of the form:
(cid:16)

(cid:17)

∀(cid:126)x.

β[(cid:126)x] →

∃(cid:126)yi.ηi[(cid:126)xi, (cid:126)yi]

,

(1)

(cid:95)k

i=1

where β[(cid:126)x] and ηi[(cid:126)xi, (cid:126)yi] (i = 1, . . . , k) are conjunctions of
atoms with variables (cid:126)x and (cid:126)xi ∪ (cid:126)yi, respectively. We call β
body and (cid:87)k
i=1 ∃(cid:126)yi.ηi head. Bodies can be empty, but heads
must be non-empty. We require that (cid:126)x and (cid:126)yi are mutually
disjoint and that (cid:126)xi ⊆ (cid:126)x for all i = 1, . . . , k. We single out the
fragment of existential rules by disallowing disjunction, i.e.
requiring k = 1, and Datalog rules by disallowing existential
quantiﬁers. We omit the universal quantiﬁers from rules.

Databases, Interpretations, and Entailment The seman-
tics of formulas is based on interpretations, deﬁned as rela-
tional structures over a countably inﬁnite set Nulls of nulls.
A schema S is a ﬁnite set of predicates. An interpretation I
over S is a set of expressions p((cid:126)n) with p ∈ S and (cid:126)n a list of
nulls of length Ar (p). A database is a ﬁnite interpretation.

A homomorphism h : I1 → I2 between interpretations I1
and I2 is a mapping h from the nulls in I1 to the nulls in I2,
such that p((cid:126)n) ∈ I1 implies p(h((cid:126)n)) ∈ I2.

A substitution σ is a mapping from variables to nulls. A
rule ρ as in (1) is satisﬁed by interpretation I if every sub-
stitution σ : (cid:126)x → Nulls with σ(β) ⊆ I can be extended
to σ(cid:48) : (cid:126)x ∪ (cid:126)yi → Nulls for some i ∈ {1, . . . , k} such that
σ(cid:48)(ηi) ⊆ I. Otherwise, if σ(β) ⊆ I but no extension σ(cid:48) of σ
veriﬁes σ(cid:48)(ηi) ⊆ I for some i, then (cid:104)ρ, σ(cid:105) is applicable to I.
An interpretation I satisﬁes a set Σ of rules if it satisﬁes
every rule in Σ. An interpretation J is satisﬁed by an in-
terpretation I if there is a homomorphism h : J → I. I
is a model of a rule/rule set/interpretation/database X if X
is satisﬁed by I, written I |= X . As usual, we also write
X |= Y if every model of X is a model of Y, where X and
Y might be rules, rule sets, databases, or lists of several such
elements. Note that the semantics of a database D in this con-
text corresponds to the semantics of a Boolean conjunctive
query ∃(cid:126)x. (cid:86){p(xn1, . . . , xn(cid:96)) | p(n1, . . . , n(cid:96)) ∈ D} – we
will therefore not introduce such queries as a separate notion.
Also note that entailment and satisfaction between interpreta-
tions/databases coincide.
Abstract Queries, Expressivity, and Decidability An (ab-
stract) query Q over a schema S is a set of databases over
S that is closed under isomorphism, i.e., such that whenever
D ∈ Q and D(cid:48) is obtained from D by bijective renaming of

nulls, then D(cid:48) ∈ Q. The query Q is further closed under
homomorphisms if, for all D ∈ Q and all homomorphisms
h : D → D(cid:48), we have D(cid:48) ∈ Q.
Deﬁnition 1. Let Goal be a nullary predicate. A query Q
over S is expressed by a set Σ of rules if, for every database
D over S, we have D ∈ Q if and only if Σ, D |= Goal.

To discuss decidability of queries, we need to see databases
as Turing machine (TM) inputs over a ﬁxed alphabet. A seri-
alisation for a schema S is a word s ∈ ({0, 1, (cid:107)} ∪ S)∗ of the
form e1 · · · en where n ≥ 0 and ei = pi(cid:107)wi1(cid:107) · · · (cid:107)wiAr (pi)(cid:107)
for wij ∈ {0, 1}+ and pi ∈ S. Given s of this form and an
injection η : {0, 1}+ → Nulls, let η(s) denote the database
{pi(η(wi1), . . . , η(wiAr (pi))) | 1 ≤ i ≤ n}. Then s corre-
sponds to a database D if η(s) is isomorphic to D; note that
this does not depend on the choice of η.

A query Q with schema S is decidable if the set of all seri-
alisations for S that correspond to some D ∈ Q is decidable.
Universal Models and the Chase Entailment of databases
(corresponding to Boolean conjunctive queries) can be de-
cided by considering only a subset of all models. Given sets I
and K of interpretations, I is universal for K if, for all K ∈ K,
there is I ∈ I and a homomorphism I → K. Consider a rule
set Σ and database D, and let M be the set of all models of
Σ, D. Then I is a universal model set for Σ and D if I ⊆ M
and I is universal for M.
Fact 1. If I is a universal model set for Σ and D then, for
every database C, we have Σ, D |= C iff I |= C for all I ∈ I.
Universal model sets can be computed with the chase algo-
rithm. We consider a variation of the standard (or restricted)
chase for rules with disjunctions [Carral et al., 2017].
Deﬁnition 2. A chase tree for Σ and D is a (ﬁnite or inﬁnite)
tree where each node is labelled by a database, such that:

1. The root is labelled with D.
2. For every node with label E that has (cid:96) children labelled
C1, . . . , C(cid:96), there is a rule ρ ∈ Σ and a substitution σ :
(cid:126)x → Nulls such that (i) (cid:104)ρ, σ(cid:105) is applicable to E, (ii) ρ
has (cid:96) head disjuncts, and (iii) Ci = E ∪ σi(ηi) where σi
extends σ by mapping each y ∈ (cid:126)yi to a fresh null.

3. For each ρ ∈ Σ and σ, there is i ≥ 1 such that (cid:104)ρ, σ(cid:105) is
not applicable to the label of any node of depth ≥ i.
The result that corresponds to a chase tree is the set of all
interpretations that can be obtained as the union of all inter-
pretations along a path in the tree.

Point (3) ensures fair rule application, but different orders
of application can lead to different chase trees, and different
results. Nevertheless, every result is semantically correct:
Fact 2. Every result of a chase on a rule set Σ and database
D is a universal model set for Σ and D.

The pair (cid:104)Σ, D(cid:105) is chase-terminating if all its chase trees
are ﬁnite; this corresponds to all-strategy termination. Σ is
chase-terminating if (cid:104)Σ, D(cid:105) is chase-terminating for every
database D; this corresponds to universal termination.

3 Main Results
We are now ready to state the main results of the paper.

Capturing Decidable Homomorphism-Closed Queries
Given a homomorphism-closed query Q over signature S,
and a Turing machine MQ that decides Q, we describe in
the next section how to construct a set of standard-chase-
terminating existential rules Σ that expresses Q.
Theorem 3. Chase-terminating existential rules capture the
class of all decidable homomorphism-closed queries.
Limitations of Semi-Decidable Languages A query lan-
guage F over a schema S is a function from a set L to 2DS ,
where DS is the set of all databases over schema S. We
say that F is semi-decidable if membership to L is semi-
decidable, and that its query answering problem is decidable
if there exists a TM MF that takes as input some (l, D) ∈
(L × DS ) and decides whether D ∈ F(l).

The set of chase-terminating existential rule sets is a query
language that is not semi-decidable [Grahne and Onet, 2018]
and for which the query answering problem is decidable (by
running the chase). In fact, we show that one cannot ﬁnd a
semi-decidable query language with similar properties.
Theorem 4. There are no semi-decidable query languages
that (i) express all decidable, homomorphism-closed queries
and (ii) for which query answering is decidable.

To show this result, we deﬁne a set M of TMs (intuitively,
M is the set of all deciders that solve homomorphism-closed
queries over databases in D{ed}), show that M can be enu-
merated up to equivalence if there is a semi-decidable lan-
guage that satisﬁes (i) and (ii) above, and ﬁnally prove that
M is not enumerable up to equivalence.

4 Construction for Theorem 3
In this section we explain how we construct the standard-
chase-terminating existential rules Σ that expresses the
homomorphism-closed query Q to prove Theorem 3.

4.1 Overview
The construction works in three steps:

1. We express Q with a set of disjunctive existential rules
simulating a TM MQ deciding Q. Disjunction is actu-
ally used in a very light way: It is only used to guess an
ordering on the database elements, and to guess which
atoms are not present in D.

2. We ensure termination of the standard chase by modi-
fying our rule set. Known syntactic criteria to ensure
termination come with an upper bound on the length of
the chase (possibly exponential) and are thus not appli-
cable in our setting, as MQ may take arbitrarily long to
halt. We thus adapt the “emergency brake” technique
[Kr¨otzsch et al., 2019] by casting it as a general rule set
transformation, and apply it by detecting the situations
in which the previous rule set leads to non-termination.
This essentially happens when the “linear order” relation
that is guessed contains cycles.

3. Finally, we remove disjunction by noticing that the rule
set has a speciﬁc shape, in which all disjunctive rules are
Datalog rules that can be applied before any existential
rules. For such a rule set, we adapt another technique by

→ ∃y.First(y) ∧ DbDom(y)
→ ∃z.Last(z) ∧ DbDom(z)

p((cid:126)x) → Inp((cid:126)x) ∧ (cid:86)

x∈(cid:126)x DbDom(x)

DbDom(x) → Eq(x, x)
Eq(x, y) → Eq(y, x)
NEq(x, y) → NEq(y, x)
R((cid:126)x) ∧ Eq(xi, y) → R((cid:126)xxi(cid:55)→y)

DbDom(x) ∧ DbDom(y) → Eq(x, y) ∨ NEq(x, y)

LT(x, y) ∧ LT(y, z) → LT(x, z)
First(x) ∧ NEq(x, y) → LT(x, y)
NEq(x, y) ∧ Last(y) → LT(x, y)

NEq(x, y) → LT(x, y) ∨ LT(y, x)
x∈(cid:126)x DbDom(x) → Inp((cid:126)x) ∨ NInp((cid:126)x)

(cid:86)

(2)
(3)
(4)

(5)
(6)
(7)
(8)
(9)
(10)
(11)
(12)
(13)
(14)

Figure 1: The rule set R1, where rules (4) and (14) are instan-
tiated for each p ∈ S, and rules (8) are instantiated for each
R ∈ {First, Last, Eq, NEq, LT} ∪ {Inp, NInp
| p ∈ S} and
1 ≤ i ≤ Ar (R), and (cid:126)xxi(cid:55)→y denotes (cid:126)x with xi replaced by y.

First(x) → ∃u.Root(u) ∧ Rep(x, u)

Rep(x, v) ∧ LT(x, z) → ∃w.Chi(v, w) ∧ Rep(z, w)
Last(x) ∧ Rep(x, u) → Leaf(u)
Rep(x, u) ∧ Eq(x, y) → Rep(y, u)

Inp((cid:126)x) ∧ (cid:86)|(cid:126)x|
NInp((cid:126)x) ∧ (cid:86)|(cid:126)x|

i=1Rep(xi, ui) → In(cid:48)
i=1Rep(xi, ui) → NIn(cid:48)

p((cid:126)u)

p((cid:126)u)

(15)
(16)
(17)
(18)

(19)

(20)

Figure 2: The rule set R2 contains R1 (see Figure 1) and all above
rules, where (19) and (20) are instantiated for each p ∈ S.

Kr¨otzsch et al. [2019] to create an equivalent set of non-
disjunctive existential rules: It builds all possible worlds
corresponding to choices made by disjunctive Datalog
rules, simulates the application of non-disjunctive exis-
tential rules in each world independently, and aggregates
the results from all worlds.

In the remaining of this section, we focus on the ﬁrst step.

4.2 Expressing Q with Disjunctive Rules

We build ﬁve rule sets R1 ⊆ R2 ⊆ R3 ⊆ R4 ⊆ R5 such
that for any database D over S, there is a universal model set
M of R5 and D s.t. D ∈ Q iff Goal ∈ I for every I ∈ M.

Intuitively, R1 constructs all possible linear orders over the
nulls in D, as well as all possible completions of D with facts
built using these nulls; R2 \ R1 extracts successor relations
from the linear orders; R3 \ R2 associates to nulls repre-
sentations of their positions in successor relations; R4 \ R3
encodes all initial TM conﬁgurations corresponding to some
linear order and completion; and R5 \ R4 simulates the run
of the TM on these conﬁgurations. The two last steps being
more standard (e.g. [Abiteboul et al., 1995] and [Baget et al.,
2011a]), we focus on R1 to R3 (see Figures 1-3).

Root(u) → ∃y1, y2.Enc(u, y1, y2) ∧ S0(y1) ∧ Nxt(y1, y2) ∧ S1(y2)

Enc(u, y1, y ) ∧ Chi(u, v) → ∃z1, z .Enc(v, z1, z ) ∧ Cpy+1(y1, y , z1, z )

(21)
(22)

Cpy+1(y1, y2, z1, z ) ∧ S0(y1) ∧ Nxt(y1, y2) → S1(z1) ∧ Nxt(z1, z ) ∧ S1(z )
(23)
Cpy+1(y1, y2, z1, z ) ∧ S1(y1) ∧ Nxt(y1, y2) → ∃z2.S0(z1) ∧ Nxt(z1, z2) ∧ S0(z2) ∧ Nxt(z2, z ) ∧ S1(z ) (24)
(25)

Cpy+1(y1, y , z1, z ) ∧ S0(y1) ∧ Nxt(y1, y2) ∧ Nxt(y2, y3) → ∃z2.Cpy(y2, y , z2, z ) ∧ S1(z1) ∧ Nxt(z1, z2)
Cpy+1(y1, y , z1, z ) ∧ S1(y1) ∧ Nxt(y1, y2) ∧ Nxt(y2, y3) → ∃z2.Cpy+1(y2, y , z2, z ) ∧ S0(z1) ∧ Nxt(z1, z2)
Cpy(y1, y2, z1, z2) ∧ S∗(y1) ∧ Nxt(y1, y2) → S∗(z1) ∧ Nxt(z1, z2) ∧ S1(z2)
Cpy(y1, y , z1, z ) ∧ S∗(y1) ∧ Nxt(y1, y2) ∧ Nxt(y2, y3) → ∃z2.Cpy(y2, y , z2, z ) ∧ S∗(z1) ∧ Nxt(z1, z2)

(26)

(27)
(28)

Figure 3: The rule set R3 contains R2 (Figure 2) and all of the above rules, where (27) and (28) are instantiated for each ∗ ∈ {0, 1}.

Guessing an Order and Completing the Database R1
serves two distinct purposes: (1) predicates First, Last, Eq
(“=”), NEq (“(cid:54)=”), and LT (“<”) encode representations of
possible linear orders over nulls in D (collected in predicate
DbDom); and (2) predicates Inp and NInp for each p ∈ S ex-
plicitly encode positive and negative (absent) facts in D. Both
purposes require disjunctive reasoning. Possible models in-
clude representations of strict, total linear orders (1) and the
exact database completion (2), but also models for collapsed
orders and inconsistent completions. The latter is not prob-
lematic since we consider homomorphism-closed queries.

Building a Tree Structure According to the Order The
purpose of R2 is to extract successor relations from the tran-
sitive linear order LT. It builds a tree structure – deﬁned using
predicates Root, Chi (“child”), and Leaf – where each path
is a sequence of nulls representing a sequence of elements
that respects the linear order LT. Unavoidably, some elements
may be skipped in some sequences, but one path is complete,
and it is the successor relation with respect to LT. Note that it
may lead to non-termination of the restricted chase when the
guessed LT contains a cycle. This problem is dealt with in the
second part of the construction. Moreover, nulls are related
via predicates In(cid:48)
p that reﬂect the relations for Inp
and NInp that hold between the represented elements (in the
database completion of the considered model I of R1).

p and NIn(cid:48)

Creating a Binary Encoding of the Distance from the Root
The purpose of R3 is to associate each node in the tree of
R2 with a binary encoding of its distance from the root (the
root starts with “distance” 2 for technical reasons). Encodings
start at the least signiﬁcant bit and always end in 1 (i.e., have
no leading 0s). To simplify upcoming steps, encodings take
the form of little TM tapes, represented by a Nxt-connected
chain of nulls with unary predicates S0 and S1 encoding the
symbol at each position. Nodes u relate to the ﬁrst and last
null ts and te of their “tape” through facts Enc(u, ts, te).
Facts Cpy(as, ae, bs, be) are used to create a tape between bs
and be that contains a copy of the information on the tape be-
tween as and ae. Predicate Cpy+1 is analogous, but creates a
representation of the successor of the number that is copied.

5 Discussion and Conclusion

We
characterized all decidable homomorphism-closed
Boolean queries: These are exactly the chase-terminating

existential rule queries, that is, queries that can be expressed
by a set of (non-disjunctive) existential rules for which the
standard chase universally terminates irrespective of the
order of rule applications (as long as it is fair).

By its nature, our result immediately shows that various
extensions of our framework do not increase its expressivity:
Theorem 5. Chase-terminating existential rule queries have
the same expressivity as

1. existential rule queries with guaranteed existence of

some ﬁnite chase tree (for every database)

2. existential rule queries for which the chase terminates
according to some fair strategy (such as datalog-ﬁrst),
3. core-chase-terminating [Deutsch et al., 2008] existential

rule queries,

4. disjunctive chase-terminating existential rule queries.
Moreover, our result also applies to query languages and
querying formalisms of different types. An interesting ex-
ample is the existential rules fragment of bounded treewidth
sets (bts) of rules [Baget et al., 2011a] that is not chase-
terminating and encompasses many well-known existential
rule fragments with decidable query entailment, including
guarded [Cal`ı et al., 2008], frontier-guarded [Baget et al.,
2011a], and glut-guarded existential rules [Kr¨otzsch and
Rudolph, 2011], as well as greedy bts [Baget et al., 2011b]:
Theorem 6. Let Σ be a bounded-treewidth set of rules and
Q a conjunctive query. There is a chase-terminating set ΣQ
of existential rules such that D, Σ |= Q iff D, ΣQ |= Goal.

While possibly surprising, this is a consequence of de-
cidability of conjunctive query entailment from bts and of
homomorphism-closedness of existential rule queries. Note,
however, that every Q would give rise to a different ΣQ. Ask-
ing for a “uniform” chase-terminating existential rules set Σ(cid:48)
satisfying D, Σ(cid:48) |= Q iff D, Σ |= Q would change the game
[Zhang et al., 2015]. Such a set will not exist in all cases.

As we learned recently, Cabibbo [1998] shows a result akin
to Theorem 3 for monotonic queries and Horn logic with in-
equality. This is important prior work that nonetheless also
has important differences, explaining why our proof required
several new techniques. A detailed discussion is planned for
future work. Another direction of future research is to look at
complexity instead of expressivity. Indeed, even though sev-
eral chase variants can express the same query, we believe
that not all of them lead to worst-case optimal computations.

[Fagin et al., 2005] Ronald Fagin, Phokion G. Kolaitis,
Ren´ee J. Miller, and Lucian Popa. Data exchange: seman-
tics and query answering. Theoretical Computer Science,
336(1):89–124, 2005.

[Grahne and Onet, 2018] G¨osta Grahne and Adrian Onet.
Informaticae,

Fundam.

chase.

Anatomy of
157(3):221–270, 2018.

the

[Kr¨otzsch and Rudolph, 2011] Markus Kr¨otzsch and Sebas-
tian Rudolph. Extending decidable existential rules by
In Walsh [2011],
joining acyclicity and guardedness.
pages 963–968.

[Kr¨otzsch et al., 2019] Markus Kr¨otzsch, Maximilian Marx,
and Sebastian Rudolph. The power of the terminating
In Pablo Barcel´o and Marco Calautti, editors,
chase.
Proc. 22nd Int. Conf. on Database Theory, ICDT’19, vol-
ume 127 of LIPIcs, pages 3:1–3:17. Schloss Dagstuhl -
Leibniz-Zentrum f¨ur Informatik, 2019.

[Marnette, 2009] Bruno Marnette. Generalized schema-
mappings:
In Jan
from termination to tractability.
Paredaens and Jianwen Su, editors, Proc. 28th Symposium
on Principles of Database Systems (PODS’09), pages 13–
22. ACM, 2009.

[Rudolph and Thomazo, 2015] Sebastian

and
Micha¨el Thomazo. Characterization of the expressivity
of existential rule queries.
In Qiang Yang and Michael
Wooldridge, editors, Proc. 24th Int. Joint Conf. on Arti-
ﬁcial Intelligence (IJCAI’15), pages 3193–3199. AAAI
Press, 2015.

Rudolph

[Walsh, 2011] Toby Walsh,

Proc. 22nd Int.
Joint Conf. on Artiﬁcial Intelligence (IJCAI’11). AAAI
Press/IJCAI, 2011.

editor.

[Zhang et al., 2015] Heng Zhang, Yan Zhang, and Jia-Huai
You. Existential rule languages with ﬁnite chase: Com-
plexity and expressiveness.
In Blai Bonet and Sven
Koenig, editors, Proc. 29th AAAI Conf. on Artiﬁcial In-
telligence (AAAI’15). AAAI Press, 2015.

Acknowledgements

The authors thank Jan van den Bussche for pointing them to
the related work of Cabibbo [1998] during a discussion at
ICDT conference 2022.

This work is partly supported by DFG in project number
389792660 (TRR 248, Center for Perspicuous Systems), by
BMBF in the Center for Scalable Data Analytics and Arti-
ﬁcial Intelligence (ScaDS.AI), by the Center for Advancing
Electronics Dresden (cfaed), by the ERC Consolidator Grant
DeciGUT (project number 771779), and by the ANR project
CQFD (ANR-18-CE23-0003).

References
[Abiteboul et al., 1995] Serge Abiteboul, Richard Hull, and
Victor Vianu. Foundations of Databases. Addison-Wesley,
1995.

[Baget et al., 2011a] Jean-Franc¸ois Baget, Michel Lecl`ere,
Marie-Laure Mugnier, and Eric Salvat. On rules with ex-
istential variables: Walking the decidability line. Artif. In-
tell., 175(9-10):1620–1654, 2011.

[Baget et al., 2011b] Jean-Franc¸ois Baget, Marie-Laure
Mugnier, Sebastian Rudolph, and Micha¨el Thomazo.
Walking the complexity lines for generalized guarded
existential rules. In Walsh [2011], pages 712–717.

[Beeri and Vardi, 1984] Catriel Beeri and Moshe Y. Vardi.
J. ACM,

A proof procedure for data dependencies.
31(4):718–741, 1984.

[Bourgaux et al., 2021] Camille Bourgaux, David Carral,
Markus Kr¨otzsch, Sebastian Rudolph,
and Micha¨el
Thomazo. Capturing homomorphism-closed decidable
queries with existential rules. In Meghyn Bienvenu, Ger-
hard Lakemeyer, and Esra Erdem, editors, Proceedings of
the 18th International Conference on Principles of Knowl-
edge Representation and Reasoning (KR 2021), pages
141–150, 2021.

[Cabibbo, 1998] Luca Cabibbo. The expressive power of
stratiﬁed logic programs with value invention. Inf. Com-
put., 147(1):22–56, 1998.

[Cal`ı et al., 2008] Andrea Cal`ı, Georg Gottlob, and Michael
Kifer. Taming the inﬁnite chase: Query answering un-
der expressive relational constraints. In Gerhard Brewka
and J´erˆome Lang, editors, Proc. 11th Int. Conf. on Knowl-
edge Representation and Reasoning (KR’08), pages 70–
80. AAAI Press, 2008.

[Carral et al., 2017] David Carral,

and
Markus Kr¨otzsch. Restricted chase (non)termination for
existential rules with disjunctions. In Carles Sierra, edi-
tor, Proc. 26th Int. Joint Conf. on Artiﬁcial Intelligence,
IJCAI’17, pages 922–928. ijcai.org, 2017.

Irina Dragoste,

[Deutsch et al., 2008] Alin Deutsch, Alan Nash, and Jef-
frey B. Remmel. The chase revisited. In Maurizio Lenz-
erini and Domenico Lembo, editors, Proc. 27th Sympo-
sium on Principles of Database Systems (PODS’08), pages
149–158. ACM, 2008.

