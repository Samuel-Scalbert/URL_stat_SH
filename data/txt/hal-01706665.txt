First-order queries on classes of structures with bounded
expansion
Wojciech Kazana, Luc Segoufin

To cite this version:

Wojciech Kazana, Luc Segoufin. First-order queries on classes of structures with bounded expansion.
Logical Methods in Computer Science, 2020, 16 (1), ￿10.23638/LMCS-16(1:25)2020￿. ￿hal-01706665v2￿

HAL Id: hal-01706665

https://inria.hal.science/hal-01706665v2

Submitted on 8 Jan 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH
BOUNDED EXPANSION

WOJCIECH KAZANA AND LUC SEGOUFIN

INRIA and ENS Cachan

INRIA and ENS Cachan

Abstract. We consider the evaluation of ﬁrst-order queries over classes of databases
with bounded expansion. The notion of bounded expansion is fairly broad and generalizes
bounded degree, bounded treewidth and exclusion of at least one minor. It was known that
over a class of databases with bounded expansion, ﬁrst-order sentences could be evaluated
in time linear in the size of the database. We give a diﬀerent proof of this result. Moreover,
we show that answers to ﬁrst-order queries can be enumerated with constant delay after a
linear time preprocessing. We also show that counting the number of answers to a query
can be done in time linear in the size of the database.

1. Introduction

Query evaluation is certainly the most important problem in databases. Given a query q
and a database D it computes the set q(D) of all tuples in the output of q on D. However,
the set q(D) may be larger than the database itself as it can have a size of the form nl where
n is the size of the database and l the arity of the query. Therefore, computing entirely q(D)
may require too many of the available resources.

There are many solutions to overcome this problem. For instance one could imagine that
a small subset of q(D) can be quickly computed and that this subset will be enough for the
user needs. Typically one could imagine computing the top-(cid:96) most relevant answers relative
to some ranking function or to provide a sampling of q(D) relative to some distribution. One
could also imagine computing only the number of solutions |q(D)| or providing an eﬃcient
test for whether a given tuple belongs to q(D) or not.

In this paper we consider a scenario consisting in enumerating q(D) with constant
delay. Intuitively, this means that there is a two-phase algorithm working as follows: a
preprocessing phase that works in time linear in the size of the database, followed by an
enumeration phase outputting one by one all the elements of q(D) with a constant delay
between any two consecutive outputs. In particular, the ﬁrst answer is output after a time
linear in the size of the database and once the enumeration starts a new answer is being
output regularly at a speed independent from the size of the database. Altogether, the set
q(D) is entirely computed in time f (q)(n + |q(D)|) for some function f depending only on q
and not on D.

Key words and phrases: enumeration, ﬁrst-order, constant delay, bounded expansion.

Preprint submitted to
Logical Methods in Computer Science

c(cid:13) W. Kazana and L. Segouﬁn
CC(cid:13) Creative Commons

2

W. KAZANA AND L. SEGOUFIN

One could also view a constant delay enumeration algorithm as follows. The preprocessing
phase computes in linear time an index structure representing the set q(D) in a compact
way (of size linear in n). The enumeration algorithm is then a streaming decompression
algorithm.

One could also require that the enumeration phase outputs the answers in some given
order. Here we will consider the lexicographical order based on a linear order on the domain
of the database.

There are many problems related to enumeration. The main one is the model checking
problem. This is the case when the query is boolean, i.e. outputs only true or false. In this
case a constant delay enumeration algorithm is a Fixed Parameter Linear (FPL) algorithm
for the model checking problem of q, i.e. it works in time f (q)n. This is a rather strong
constraint as even the model checking problem for conjunctive queries is not FPL (assuming
some hypothesis in parametrized complexity) [PY99]. Hence, in order to obtain constant
delay enumeration algorithms, we need to make restrictions on the queries and/or on the
databases. Here we consider ﬁrst-order (FO) queries over classes of structures having
“bounded expansion”.

The notion of class of graphs with bounded expansion was introduced by Neˇsetˇril and
Ossona de Mendez in [NdM08a]. Its precise deﬁnition can be found in Section 2.2. At this
point it is only useful to know that it contains the class of graphs of bounded degree, the
class of graphs of bounded treewidth, the class of planar graphs, and any class of graphs
excluding at least one minor. This notion is generalized to classes of structures via their
Gaifman graphs or adjacency graphs.

For the class of structures with bounded degree and FO queries the model checking
problem is in FPL [See96] and there also are constant delay enumeration algorithms [DG07,
KS11]. In the case of structures of bounded treewidth and FO queries (actually even MSO
queries with ﬁrst-order free variables) the model checking problem is also in FPL [Cou90] and
there are constant delay enumeration algorithms [Bag06, KS13b]. For classes of structures
with bounded expansion the model checking problem for FO queries was recently shown to
be in FPL [DKT13, GK11].

Our results can be summarized as follows. For FO queries and any class of

structures with bounded expansion:

• we provide a new proof that the model checking problem can be solved in FPL,
• we show that the set of solutions to a query can be enumerated with constant delay,
• we show that computing the number of solutions can be done in FPL,
• we show that, after a preprocessing in time linear in the size of the database, one can

test on input ¯a whether ¯a ∈ q(D) in constant time.

Concerning model checking, our method uses a diﬀerent technique than the previous
ones. There are several characterizations of classes having bounded expansion [NdM08a].
Among them we ﬁnd characterizations via “low tree depth coloring” and “transitive fra-
ternal augmentations”. The previous methods were based on the low tree depth coloring
characterization while ours is based on transitive fraternal augmentations. We show that it
is enough to consider quantiﬁer-free queries in a given normal form. The normal form is at
the core of our algorithms for constant delay enumeration and for counting the number of
solutions. As for the previous proofs, we exhibit a quantiﬁer elimination method, also based
on our normal form. Our quantiﬁer elimination method results in a quantiﬁer-free query but

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION

3

over a recoloring of a functional representation of a “fraternal and transitive augmentation”
of the initial structure.

Our other algorithms (constant delay enumeration, counting the number of solution or
testing whether a tuple is a solution or not) start by eliminating the quantiﬁers as for the
model checking algorithm. The quantiﬁer-free case is already non trivial and require the
design and the computation of new index structures. For instance consider the simple query
R(x, y). Given a pair (a, b) we would like to test whether (a, b) is a tuple of the database in
constant time. In general, index structures can do this with log n time. We will see that we
can do constant time, assuming bounded expansion.

In the presence of a linear order on the domain of the database, our constant delay

algorithm can output the answers in the corresponding lexicographical order.

Related work. We make use of a functional representation of the initial structures. Without
this functional representations we would not be able to eliminate all quantiﬁers. Indeed,
with this functional representation we can talk of a node at distance 2 from x using the
quantiﬁer-free term f (f (x)), avoiding the existential quantiﬁcation of the middle point. This
idea was already taken in [DG07] for eliminating ﬁrst-order quantiﬁers over structures of
bounded degree. Our approach diﬀers from theirs in the fact that in the bounded degree
case the functions can be assumed to be permutations (in particular they are invertible)
while this is no longer true in our setting, complicating signiﬁcantly the combinatorics.

Once we have a quantiﬁer-free query, constant delay enumeration could also be obtained
using the characterization of bounded expansion based on low tree depth colorings. Indeed,
using this characterization one can easily show that enumerating a quantiﬁer-free query over
structures of bounded expansion amounts in enumerating an MSO query over structures of
bounded tree-width and for those known algorithms exist [Bag06, KS13b]. However, the
known enumeration algorithms of MSO over structures of bounded treewidth are rather
complicated while our direct approach is fairly simple. Actually, our proof shows that
constant delay enumeration of FO queries over structures of bounded treewidth can be
done using simpler algorithms than for MSO queries. Moreover, it gives a constant delay
algorithm outputting the solutions in lexicographical order. No such algorithms were known
for FO queries over structures of bounded treewidth. In the bounded degree case, both
enumeration algorithms of [DG07, KS11] output their solutions in lexicographical order.

Similarly, counting the number of solutions of a quantiﬁer-free query over structures
of bounded expansion reduces to counting the number of solutions of a MSO query over
structures of bounded treewidth. This latter problem is known to be in FPL [ALS91]. We
give here a direct and simple proof of this fact for FO queries over structures of bounded
expansion.

Our main result is about enumeration of ﬁrst-order queries. We make use of a quantiﬁer
elimination method reducing the general case to the quantiﬁer-free case. As a special
we obtain a new proof of the linear time model checking algorithm, already obtained
in [DKT13, GK11]. Both these results were also obtained using (implicitly or explicitly)
a quantiﬁer elimination method. As our enumeration of quantiﬁer-free query also needs a
speciﬁc normal form, we could not reuse the results of [DKT13, GK11]. Hence we came up
with our own method which diﬀer in the technical details if not in the main ideas.

In [DKT13] it is also claimed that the index structure used for quantiﬁer elimination
can be updated in constant time. It then tempting to think that enumeration could be
achieved by adding each newly derived output tuple to the index structure and obtain the

4

W. KAZANA AND L. SEGOUFIN

next output in constant time using the updated index. This idea does not work because
constant update time can only be achieved if the inserted tuple does not modify too much
the structure of the underlying graph. In particular the new structure must stay within
the class under investigation. This is typically not the case with ﬁrst-order query that may
produce very dense results.

This paper is the journal version of [KS13a]. All proofs are now detailed and the whole
story has been simpliﬁed a bit, without changing the key ideas. Since the publication
of the conference version, constant delay enumeration has been obtained for ﬁrst-order
queries over any class of structures having local bounded expansion [SV17] or being nowhere
dense [SSV18] These two classes of structures generalize bounded expansion. However the
preprocessing time that has been achieved for these two classes is not linear but pseudo-linear
(i.e for any (cid:15) there is an algorithm working in time O(n1+(cid:15))) and the enumeration algorithms
are signiﬁcantly more complicated.

2. Preliminaries

In this paper a database is a ﬁnite relational structure. A relational signature is a tuple
σ = (R1, . . . , Rl), each Ri being a relation symbol of arity ri. A relational structure over σ
is a tuple D = (cid:0)D, RD
is a subset of Dri.
We will often write Ri instead of RD

(cid:1), where D is the domain of D and RD
i
i when D is clear from the context.

1 , . . . , RD
l

We use a standard notion of size. The size of RD
i || is the number of tuples
i multiplied by the arity ri. The size of the domain of D, denoted |D|, is the number

in RD
of elements in D. Finally the size of D, denoted by ||D||, is

i , denoted ||RD

||D|| = |D| + ΣRi∈σ||RD

i ||.

By query we mean a formula of ﬁrst-order logic, FO, built from atomic formulas of
the form x = y or Ri(x1, . . . , xri) for some relation Ri, and closed under the usual Boolean
connectives (¬, ∨, ∧) and existential and universal quantiﬁcations (∃, ∀). We write φ(¯x) to
denote a query whose free variables are ¯x, and the number of free variables is called the
arity of the query. A sentence is a query of arity 0. We use the usual semantics, denoted
|=, for ﬁrst-order. Given a structure D and a query q, an answer to q in D is a tuple ¯a
of elements of D such that D |= q(¯a). We write q(D) for the set of answers to q in D, i.e.
q(D) = {¯a | D |= q(¯a)}. As usual, |q| denotes the size of q.

Let C be a class of structures. The model checking problem for FO over C is the
computational problem of given ﬁrst-order sentence q and a database D ∈ C to test whether
D |= q or not.

We now introduce our running examples.

Example A-1 . The ﬁrst query has arity 2 and returns pairs of nodes at distance 2 in a
graph. The query is of the form ∃zE(x, z) ∧ E(z, y).

Testing the existence of a solution to this query can be easily done in time linear in the
size of the database. For instance one can go trough all nodes of the database and check
whether it has non-nill in-degree and out-degree. The degree of each node can be computed
in linear time by going through all edges of the database and incrementing the counters
associated to its endpoints.

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION

5

Example B-1 . The second query has arity 3 and returns triples (x, y, z) such that y is
connected to x and z via an edge but x is not connected to z. The query is of the form
E(x, y) ∧ E(y, z) ∧ ¬E(x, z).

It is not clear at all how to test the existence of a solution to this query in time linear
in the size of the database. The problem is similar to the one of ﬁnding a triangle in a
graph, for which the best know algorithm has complexity even slightly worse than matrix
multiplication [AYZ95]. If the degree of the input structure is bounded by a constant d, we
can test the existence of a solution in linear time by the following algorithm. We ﬁrst go
through all edges (x, y) of the database and add y to a list associated to x and x to a list
associated to y. It remains now to go through all nodes y of the database, consider all pairs
(x, z) of nodes in the associated list (the number of such pairs is bounded by d2) and then test
whether there is an edge between x and z (by testing whether x is in the list associated to z).
We aim at generalizing this kind of reasoning to structures with bounded expansion.

Given a query q, we care about “enumerating” q(D) eﬃciently. Let C be a class of
structures. For a query q(¯x), the enumeration problem of q over C is, given a database
D ∈ C, to output the elements of q(D) one by one with no repetition. The maximum time
between any two consecutive outputs of elements of q(D) is called the delay. The deﬁnition
below requires a constant time delay. We formalize these notions in the forthcoming section.

2.1. Model of computation and enumeration. We use Random Access Machines
(RAM) with addition and uniform cost measure as a model of computation. For fur-
ther details on this model and its use in logic see [DG07]. In the sequel we assume that the
input relational structure comes with a linear order on the domain. If not, we use the one
induced by the encoding of the database as a word. Whenever we iterate through all nodes
of the domain, the iteration is with respect to the initial linear order.

We say that the enumeration problem of q over a class C of structures is in the class
CD◦Lin, or equivalently that we can enumerate q over C with constant delay, if it can be
solved by a RAM algorithm which, on input D ∈ C, can be decomposed into two phases:
• a precomputation phase that is performed in time O(||D||),
• an enumeration phase that outputs q(D) with no repetition and a constant delay between
two consecutive outputs. The enumeration phase has full access to the output of the
precomputation phase but can use only a constant total amount of extra memory.

Notice that if we can enumerate q with constant delay, then all answers can be output
in time O(||D|| + |q(D)|) and the ﬁrst output is computed in time linear in ||D||. In the
particular case of boolean queries, the associated model checking problem must be solvable
in time linear in ||D||. Notice also that the total amount of memory used after computing all
answers is linear in ||D||, while a less restrictive deﬁnition requiring only a constant time delay
between any two outputs may yield in a total amount of memory linear in ||D|| + ||q(D)||.

Note that we measure the running time complexity as a function of ||D||. The multiplica-
tive factor will depend on the class C of database under consideration and, more importantly,
on the query q. In our case we will see that the multiplicative factor is non elementary in |q|
and that cannot be avoided, see the discussion in the conclusion section.

We may in addition require that the enumeration phase outputs the answers to q using
the lexicographical order. We then say that we can enumerate q over C with constant delay
in lexicographical order.

6

W. KAZANA AND L. SEGOUFIN

Example A-2 . Over the class of all graphs, we cannot enumerate pairs of nodes at distance
2 with constant delay unless the Boolean Matrix Multiplication problem can be solved in
quadratic time [BDG07]. However, over the class of graphs of degree d, there is a simple
constant delay enumeration algorithm. During the preprocessing phase, we associate to each
node the list of all its neighbors at distance 2. This can be done in time linear in the size of
the database as in Example B- 1. We then color in blue all nodes having a non empty list
and make sure each blue node points to the next blue node (according to the linear order on
the domain). This also can be done in time linear in the size of the database and concludes
the preprocessing phase. The enumeration phase now goes through all blue nodes x using
the pointer structure and, for each of them, outputs all pairs (x, y) where y is in the list
associated to x.

Example B-2 . Over the class of all graphs, the query of this example cannot be enumerated
with constant delay because, as mentioned in Example B- 1, testing whether there is one
solution is already non linear. Over the class of graphs of bounded degree, there is a simple
constant delay enumeration algorithm, similar to the one from Example A- 2.

Note that in general constant delay enumeration algorithms are not closed under any
boolean operations. For instance if q and q(cid:48) can be enumerated with constant delay, we
cannot necessarily enumerate q ∨ q(cid:48) with constant delay as enumerating one query after the
other would break the “no repetition” requirement. However, if we can enumerate with
constant delay in the lexicographical order, then a simple argument that resembles the
problem of merging two sorted lists shows closure under union:

Lemma 2.1. If both queries q(¯x) and q(cid:48)(¯x) can be enumerated in lexicographical order with
constant delay then the same is true for q(¯x) ∨ q(cid:48)(¯x).

Proof. The preprocessing phase consists in the preprocessing phases of the enumeration
algorithms for q and q(cid:48).

The enumeration phase keeps two values, the smallest element from q(D) that was
not yet output and similarly the smallest element from q(cid:48)(D) that was not yet output. It
then outputs the smaller of the two values and replaces it in constant time with the next
element from the appropriate set using the associated enumeration procedure. In case the
elements are equal, the value is output once and both stored values are replaced with their
appropriate successors.

It will follow from our results that the enumeration problem of FO over the class of
structures with “bounded expansion” is in CD◦Lin. The notion of bounded expansion was
deﬁned in [NdM08a] for graphs and then it was generalized to structures via their Gaifman
or Adjacency graphs. We start with deﬁning it for graphs.

2.2. Graphs with bounded expansion and augmentation. By default a graph has no
orientation on its edges and has colors on its vertices. In an oriented graph every edge is an
arrow going from the source vertex to its target. We can view a (oriented or not) graph as a
l ), where V G is the set of nodes, EG ⊆ V 2 is
relational structure G = (V G, EG, P G
the set of edges and, for each 1 ≤ i ≤ l, P G
is a predicate of arity 1, i.e. a color. We omit
the subscripts when G is clear from the context. In the nonoriented case, E is symmetric
and irreﬂexive and we denote by {u, v} the edge between u and v. In the oriented case
we denote by (u, v) the edge from u to v. We will use the notation (cid:126)G when the graph is

1 , . . . , P G
i

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION

7

oriented and G in the nonoriented case. An orientation of a graph G is any graph (cid:126)H such
that {u, v} ∈ EG implies (u, v) ∈ E (cid:126)H or (v, u) ∈ E (cid:126)H. The in-degree of a node v of (cid:126)G is the
number of nodes u such that (u, v) ∈ E. We denote by ∆−( (cid:126)G) the maximum in-degree of
a node of (cid:126)G. Among all orientations of a graph G, we choose the following one, which is
computable in time linear in ||G||. It is based on the degeneracy order of the graph. We ﬁnd
the ﬁrst node of minimal degree, orient its edges towards it and repeat this inductively in
the induced subgraph obtained by removing this node. The resulting graph, denoted (cid:126)G0,
has maximum in-degree which is at most twice the optimal value and that is enough for our
needs.

In [NdM08a] several equivalent deﬁnitions of bounded expansion were shown. We present

here only the one we will use, exploiting the notion of “augmentations”.

Let (cid:126)G be an oriented graph. A 1-transitive fraternal augmentation of (cid:126)G is any graph (cid:126)H
with the same vertex set as (cid:126)G and the same colors of vertices, including all edges of (cid:126)G (with
their orientation) and such that for any three vertices x, y, z of (cid:126)G we have the following:
(transitivity): if (x, y) and (y, z) are edges in (cid:126)G, then (x, z) is an edge in (cid:126)H,
(fraternity): if (x, z) and (y, z) are edges in (cid:126)G, then at least one of the edges: (x, y), (y, x)

is in (cid:126)H,

(strictness): moreover, if (cid:126)H contains an edge that was not present in (cid:126)G, then it must have

been added by one of the previous two rules.
Note that the notion of 1-transitive fraternal augmentation is not a deterministic
operation. Although transitivity induces precise edges, fraternity implies nondeterminism
and thus there can possibly be many diﬀerent 1-transitive fraternal augmentations. We care
here about choosing the orientations of the edges resulting from the fraternity rule in order
to minimize the maximum in-degree.

Following [NdM08b] we ﬁx a deterministic algorithm computing a “good” choice of
orientations of the edges induced by the fraternity property. The precise deﬁnition of the
algorithm is not important for us, it only matters here that the algorithm runs in time linear
in the size of the input graph (see Lemma 2.3 below). With this algorithm ﬁxed, we can
now speak of the 1-transitive fraternal augmentation of (cid:126)G.

Let (cid:126)G0 be an oriented graph. The transitive fraternal augmentation of (cid:126)G0 is the
sequence (cid:126)G0 ⊆ (cid:126)G1 ⊆ (cid:126)G2 ⊆ . . . such that for each i ≥ 1 the graph (cid:126)Gi+1 is the 1-transitive
fraternal augmentation of (cid:126)Gi. We will say that (cid:126)Gi is the i-th augmentation of (cid:126)G0. Similarly
we denote the transitive fraternal augmentation of a nonoriented graph G by considering
the orientation (cid:126)G0 based on the degeneracy order as explained above.

Deﬁnition 2.2. [NdM08a] Let C be a class of graphs. C has bounded expansion if there exists
a function ΓC : N → R such that for each graph G ∈ C its transitive fraternal augmentation
(cid:126)G0 ⊆ (cid:126)G1 ⊆ (cid:126)G2 ⊆ . . . of G is such that for each i ≥ 0 we have ∆−( (cid:126)Gi) ≤ ΓC(i).

Consider for instance a graph of degree d. Notice that the 1-transitive fraternal
augmentation introduces an edge between nodes that were at distance at most 2 in the initial
graph. Hence, when starting with a graph of degree d, we end up with a graph of degree at
most d2. This observation shows that the class of graphs of degree d has bounded expansion
as witnessed by the function Γ(i) = d2i. Exhibiting the function Γ for the other examples of
classes with bounded expansion mentioned in the introduction: bounded treewidth, planar
graphs, graphs excluding at least one minor, requires more work [NdM08a].

8

W. KAZANA AND L. SEGOUFIN

The following lemma shows that within a class C of bounded expansion the i-th aug-
mentation of G ∈ C can be computed in linear time, the linear factor depending on i and on
C.

Lemma 2.3. [NdM08b] Let C be a class of bounded expansion. For each G ∈ C and each
i ≥ 0, (cid:126)Gi is computable from G in time O(||G||).

A transitive fraternal augmentation introduces new edges in the graphs in a controlled
way. We will see that we can use these extra edges in order to eliminate quantiﬁers in a ﬁrst-
order query. Lemma 2.3 shows that this quantiﬁer elimination is harmless for enumeration
as it can be done in time linear in the size of the database and can therefore be done during
the preprocessing phase.

2.3. Graphs of bounded in-degree as functional structures. Given the deﬁnition of
bounded expansion it is convenient to work with oriented graphs. These graphs will always
be such that the maximum in-degree is bounded by some constant depending on the class
of graphs under investigation. It is therefore convenient for us to represent our graphs as
functional structures where the functions links the current node with its predecessors. This
functional representation turns out to be also useful for eliminating some quantiﬁers.

A functional signature is a tuple σ = (f1, . . . , fl, P1, . . . , Pm), each fi being a functional
symbol of arity 1 and each Pi being an unary predicate. A functional structure over σ
is then deﬁned as for relational structures. FO is deﬁned as usual over the functional
signature.
In particular, it can use atoms of the form f (f (f (x))), which is crucial for
the quantiﬁer elimination step of Section 4 as the relational representation would require
existential quantiﬁcation for denoting the same element. A graph (cid:126)G of in-degree l and
colored with m colors can be represented as a functional structure f (cid:126)G, where the unary
predicates encode the various colors and v = fi(u) if v is the ith element (according to some
arbitrary order that will not be relevant in the sequel) such that (v, u) is an edge of (cid:126)G. We
call such node v the ith predecessor of u (where “ith predecessor” should really be viewed as
an abbreviation for “the node v such that fi(u) = v” and not as a reference to the chosen
order). If we do not care about the i and we only want to say that v is the image of u under
some function, we call it a predecessor of u. If a node u has j predecessors with j < l, then
we set fk(u) = u for all k > j. This will allow us to detect how many predecessors a given
node has without quantiﬁers by checking whether fj(u) = u or not. Given a nonoriented
graph G we deﬁne f (cid:126)G to be the functional representation of (cid:126)G0 as described above. Note
that f (cid:126)G is computable in time linear in ||G|| and that for each ﬁrst order query φ(¯x), over
the relational signature of graphs, one can easily compute a ﬁrst order query ψ(¯x), over the
functional signature, such that φ(G) = ψ(f (cid:126)G).

Example A-3 . Consider again the query computing nodes at distance 2 in a nonoriented
graph. There are four possible ways to orient a path of length 2. With the functional point
of view we further need to consider all possible predecessors. Altogether the distance 2 query
is now equivalent to:
(cid:95)

f (g(x)) = y ∨ g(f (y)) = x ∨ f (x) = g(y) ∨ ∃z f (z) = x ∧ g(z) = y

f,g

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION

9

where the small disjuncts correspond to the four possible orientations and the big one to all
possible predecessors, each of them corresponding to a function name, whose number depends
on the function ΓC.

Example B-3 . Similarly, the reader can verify that the query of Example B- 1 is equivalent
to:

(cid:95)

(cid:94)

f,g

h

(h(x) (cid:54)= z ∧ h(z) (cid:54)= x)∧ (cid:2)(f (x) = y ∧ g(y) = z)

∨ (x = f (y) ∧ g(y) = z)

∨ (f (x) = y ∧ y = g(z))
∨ (x = f (y) ∧ y = g(z))(cid:3).

Augmentation for graphs as functional structures. The notion of 1-transitive
fraternal augmentation can be adapted directly to the functional setting. However it will be
useful for us to enhance it with extra information. In particular it will be useful to remember
at which stage the extra edges are inserted. We do this as follows.
(cid:48)
Given a graph f (cid:126)G, its 1-transitive fraternal augmentation f (cid:126)G

(cid:48)
The signature of f (cid:126)G
(cid:48)
care of the new edges created during the expansion and f (cid:126)G
(cid:48)
logical sense, of f (cid:126)G over this new signature: f (cid:126)G and f (cid:126)G
signature.

is constructed as follows.
extends the signature of f (cid:126)G with new function symbols for taking
is then an expansion, in the
agree on the relations in the old

For any pair of functions f and g in the signature of f (cid:126)G there is a new function h in
representing the transitive part of the augmentation. It is deﬁned as

(cid:48)
the signature of f (cid:126)G
the composition of f and g, i.e. hf (cid:126)G

(cid:48)

= f f (cid:126)G ◦ gf (cid:126)G

(cid:48)

(cid:48)

(x).

(x)) = f f (cid:126)G

I.e h is such that hf (cid:126)G

Similarly, for any pair of functions f and g in the signature of f (cid:126)G, and any node x in
the domain of both f f (cid:126)G and gf (cid:126)G there will be a function h in the new signature representing
(x)) = gf (cid:126)G(x) or
the fraternity part of the augmentation.
(cid:48)
hf (cid:126)G

(gf (cid:126)G
Given a class C of bounded expansion, the guarantees that the number of new function
symbols needed for the i-th augmentation is bounded by ΓC(i) and does not depend on
the graph. Hence a class C of bounded expansion generates ﬁnite functional signatures
σC(0) ⊆ σC(1) ⊆ σC(2) ⊆ . . . such that for any graph G ∈ C and for all i:
(1) f (cid:126)Gi is a functional structure over σC(i) computable in linear time from G,
(2) f (cid:126)Gi+1 is an expansion of f (cid:126)Gi,
(3) for every FO query φ(¯x) over σC(i) and every j ≥ i we have that φ(f (cid:126)Gi) = φ(f (cid:126)Gj).

(f f (cid:126)G

(cid:48)

(cid:48)

We denote by αC(i) the number of function symbols of σC(i). Notice that we have

αC(i) ≤ Σj≤iΓC(j).

We say that a functional signature σ(cid:48) is a recoloring of σ if it extends σ with some extra
unary predicates, also denoted as colors, while the functional part remains intact. Similarly,
(cid:48)
a functional structure f (cid:126)G
over σ(cid:48) is a recoloring of f (cid:126)G over σ if σ(cid:48) is a recoloring of σ and
(cid:48)
diﬀers from f (cid:126)G only in the colors in σ(cid:48). We write φ is over a recoloring of σ if φ is
f (cid:126)G
over σ(cid:48) and σ(cid:48) is a recoloring of σ. Notice that the deﬁnition of bounded expansion is not
sensitive to the colors as it depends only on the binary predicates, hence adding any ﬁxed
ﬁnite number of colors is harmless.

10

W. KAZANA AND L. SEGOUFIN

Given a class C of graphs, for each p ≥ 0, we deﬁne Cp to be the class of all recolorings
(cid:48)
f (cid:126)G
p of f (cid:126)Gp for some G ∈ C. In other words Cp is the class of functional representations of
all recolorings of all p-th augmentations of graphs from C. Note that all graphs from Cp are
recolorings of a structure in σC(p), hence they use at most αC(p) function symbols.

From now on we assume that all graphs from C and all queries are in their functional
representation. It follows from the discussion above that this is without loss of generality.

2.4. From structures to graphs. A class of structures is said to have bounded expansion
if the set of adjacency graphs of the structures of the class has bounded expansion.

The adjacency graph of a relational structure D, denoted by Adjacency(D), is a func-
tional structure deﬁned as follows. The set of vertices of Adjacency(D) is D ∪ T where D is
the domain of D and T is the set of tuples occurring in some relation of D. For each relation
Ri in the schema of D, there is a unary symbol PRi coloring the elements of T belonging to
Ri. For each tuple t = (a1, · · · , ari) such that D |= Ri(t) for some relation Ri of arity ri, we
have an edge fj(t) = aj for all j ≤ ri.

Observation 2.4. It is immediate to see that for every relational structure D we can
compute Adjacency(D) in time O(||D||).

Let C be a class of relational structures. We say that C has bounded expansion if the
class C’ of adjacency graphs (seen as graphs) of structures from C has bounded expansion.

Remark 2.5. In the literature, for instance [DKT13, GK11], a class C of relational structures
is said to have bounded expansion if the class of their Gaifman graphs has bounded expansion.
It is easy to show that if the class of Gaifman graphs of structures from C has bounded
expansion then the class of adjacency graphs of structures from C also has bounded expansion.
The converse is not true in general. However the converse holds if the schema is ﬁxed, i.e.
C is a class of structures all having the same schema. We refer to [Kaz13] for the simple
proofs of these facts.

Let ΓC(cid:48) be the function given by Deﬁnition 2.2 for C’. The following lemma is immediate.

For instance R(¯x) is rewritten as ∃yPR(y) ∧ (cid:86)
Lemma 2.6. Let C be a class of relational structures with bounded expansion and let C’ be
the underlying class of adjacency graphs. Let φ(¯x) ∈ FO. In time linear in the size of φ we
can ﬁnd a query ψ(¯x) over σC(cid:48)(0) such that for all D ∈ C we have φ(D) = ψ(Adjacency(D)).

1≤i≤r fi(y) = xi.

As a consequence of Lemma 2.6 it follows that model checking, enumeration and counting
of ﬁrst-order queries over relational structures reduce to the graph case. Therefore in the rest
of the paper we will only concentrate on the graph case (viewed as a functional structure),
but the reader should keep in mind that all the results stated over graphs extend to relational
structures via this lemma.

3. Normal form for quantifier-free first-order queries

We prove in this section a normal form on quantiﬁer-free ﬁrst-order formulas. This normal
form will be the ground for all our algorithms later on. It says that, modulo performing
some extra augmentation steps, a quantiﬁer-free formula has a very simple form.

Fix class C of graphs with bounded expansion. Recall that we are now implicitly

assuming that graphs are represented as functional structures.

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION

11

A formula is simple if it does not contain atoms of the form f (g(x)), i.e. it does not
contain any compositions of functions. We ﬁrst observe that, modulo augmentations, any
formula can be transformed into a simple one.

Lemma 3.1. Let ψ(¯x) be a formula over a recoloring of σC(p). Then, for q = p + |ψ|, there
is a simple formula ψ(cid:48)(¯x) over a recoloring of σC(q) such that:

(cid:48)

∈ Cq computable in time linear in ||f (cid:126)G||

for all graphs f (cid:126)G ∈ Cp there is a graph f (cid:126)G
(cid:48)
).

such that ψ(f (cid:126)G) = ψ(cid:48)(f (cid:126)G

Proof. This is a simple consequence of transitivity. Any composition of two functions in f (cid:126)G
represents a transitive pair of edges and becomes an single edge in the 1-augmentation f (cid:126)H
of f (cid:126)G. Then y = f (g(x)) over f (cid:126)G is equivalent to (cid:87)
h y = h(x) ∧ Pf,g,h(x) over f (cid:126)H, where h
is one of the new function introduced by the augmentation and the newly introduced color
Pf,g,h holds for those nodes v, for which the f (g(v)) = h(v). As the nesting of compositions
of functions is at most |ψ|, the result follows. The linear time computability is immediate
from Lemma 2.3.

We make one more observation before proving the normal form:

Lemma 3.2. Let f (cid:126)G ∈ Cp. Let u be a node of f (cid:126)G. Let S be all the predecessors of u in
∈ Cq be the (q − p)-th augmentation of f (cid:126)G. There
f (cid:126)G and set q = p + ΓC(p). Let f (cid:126)G
exists a linear order < on S computable from f (cid:126)G
, such that for all v, v(cid:48) ∈ S, v < v(cid:48) implies
v(cid:48) = f (v) is an edge of f (cid:126)G

for some function f from σC(q).

(cid:48)

(cid:48)

(cid:48)

Proof. This is because all nodes of S are fraternal and the size of S is at most ΓC(p). Hence,
after one step of augmentation, all nodes of S are pairwise connected and, after at most
ΓC(p) − 1 further augmentation steps, if there is a directed path from one node u of S to
another node v of S, then there is also a directed edge from u to v. By induction on |S| we
show that there exists a node u ∈ S such that for all v ∈ S there is an edge from v to u. If
|S| = 1 there is nothing to prove. Otherwise ﬁx v ∈ S and let S(cid:48) = S \ {v}. By induction
we get a u in S(cid:48) satisfying the properties. If there is an edge from v to u, u also works for S
and we are done. Otherwise there must be an edge from u to v. But then there is a path of
length 2 from any node of S(cid:48) to v. By transitivity this means that there is an edge from any
node of S(cid:48) to v and v is the node we are looking for.

We then set u as the minimal element of our order on S and we repeat this argument

with S \ {u}.

Lemma 3.2 justiﬁes the following deﬁnition. Let p be a number and let q = p + ΓC(p).
A p-type τ (x) is a quantiﬁer-free formula over the signature σC(q) with one free variable x
consisting of the conjunction of a maximal consistent set of clauses of the form f (g(x)) = h(x)
or f (x) (cid:54)= x. Given a node u of some graph f (cid:126)G of Cp, its p-type is the set of clauses satisﬁed
(cid:48)
of f (cid:126)G. From Lemma 3.2 it follows that the p-type
by u in the (q − p)-th augmentation f (cid:126)G
of u induces a linear order on its predecessors in f (cid:126)G. Indeed the predecessors of u in f (cid:126)G
can be deduced from the p-type by looking at the clauses f (x) (cid:54)= x where f is a function
symbol from σC(p) and the linear order can be deduced from the clauses h(f (x)) = g(x).
Lemma 3.2 guarantees that these latter clauses induce a linear order. In the sequel we
denote this property as “the p-type τ induces the order f1(x) < f2(x) < · · · ” and for i < j
we refer to the h linking fi(x) to fj(x) as hi,j.

12

W. KAZANA AND L. SEGOUFIN

Note that for a given p there are only ﬁnitely many possible p-types and that each of

them can be speciﬁed with a conjunctive formula over σC(q).

We now state the normal form result.

Proposition 3.3. Let φ(¯xy) be a simple quantiﬁer-free query over a recoloring of σC(p).
There exists q that depends only on p and φ and a quantiﬁer-free query ψ over a recoloring
of σC(q) that is a disjunction of formulas:

ψ1(¯x) ∧ τ (y) ∧ ∆=(¯xy) ∧ ∆(cid:54)=(¯xy),
(3.1)
where τ (y) implies a p-type of y; ∆=(¯xy) is either empty or contains one clause of the form
y = f (xi) or one clause of the form f (y) = g(xi) for some i, f and g; and ∆(cid:54)=(¯xy) contains
arbitrarily many clauses of the form y (cid:54)= f (xi) or f (y) (cid:54)= g(xj). Moreover, ψ is such that:
∈ Cq computable in time linear in ||f (cid:126)G|| with φ(f (cid:126)G) =

for all f (cid:126)G ∈ Cp there is a f (cid:126)G

(cid:48)

).

ψ(f (cid:126)G
Proof. Set q as given by Lemma 3.2. We ﬁrst put φ into a disjunctive normal form (DNF)
and in front of each such disjunct we add a big disjunction over all possible p-types of y
(recall that a type can be speciﬁed as a conjunctive formula). We deal with each disjunct
separately.

(cid:48)

Note that each disjunct is a query over σC(q) of the form:
ψ1(¯x) ∧ τ (y) ∧ ∆=(¯xy) ∧ ∆(cid:54)=(¯xy),
where all sub-formulas except for ∆= are as desired. Moreover, ψ1(¯x), ∆=(¯xy) and ∆(cid:54)=(¯xy)
are in fact queries over σC(p). At this point ∆= contains arbitrarily many clauses of the
form y = f (xi) or f (y) = g(xi). If it contains at least one clause of the form y = f (xi), we
can replace each other occurrence of y by f (xi) and we are done.

Assume now that ∆= contains several conjuncts of the form fi(y) = g(xk). Assume
wlog that τ is such that f1(y) < f2(y) < · · · , where f1(y), f2(y), · · · are all the predecessors
of y from σC(p). Let i0 be the smallest index i such that a clause of the form fi(y) = g(xk)
belongs to ∆=. We have fi0(y) = g(xk) in ∆= and recall that τ speciﬁes for i < j a function
hi,j in σC(q) such that hi,j(fi(y)) = fj(y). Then, as y is of type τ , a clause of the form
fj(y) = h(xk(cid:48)) with i0 < j is equivalent to hi0,j(g(xk)) = h(xk(cid:48)).
Example A-4 . Let us see what Lemma 3.1 and the normalization algorithm do for p = 0
and some of the disjuncts of the query of Example A- 3:

In the case of f (g(x)) = y note that by transitivity, in the augmented graph, this clause
is equivalent to one of the form y = h(x) ∧ Pf,g,h(x) (this case is handled by Lemma 3.1).
Consider now ∃z f (z) = x ∧ g(z) = y. It will be convenient to view this query when z
plays the role of y in Proposition 3.3. Notice that in this case it is not in normal form as
∆= contains two elements. However, the two edges f (z) = x and g(z) = y are fraternal.
Hence, after one augmentation step, a new edge is added between x and y and we either
have y = h(x) or x = h(y) for some h in the new signature.

Let τh,f,g(z) be 0-type stating that h(f (z)) = g(z) and τh,g,f (z) be 0-type stating that
h(g(z)) = f (z). It is now easy to see that the query ∃z f (z) = x ∧ g(z) = y is equivalent to

(cid:95)

y = h(x) ∧ τh,f,g(z) ∧ f (z) = x ∨

∃z

h

x = h(y) ∧ τh,g,f (z) ∧ g(z) = y.

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION

13

4. Model checking

In this section we show that the model checking problem of FO over a class of structures
with bounded expansion can be done in time linear in the size of the structure. This gives
a new proof of the result of [DKT13]. Recall that by Lemma 2.6 it is enough to consider
oriented graphs viewed as functional structures.

Theorem 4.1. [DKT13] Let C be a class of graphs with bounded expansion and let ψ be
a sentence of FO. Then, for all f (cid:126)G ∈ C, testing whether f (cid:126)G |= ψ can be done in time
O(||f (cid:126)G||).

The proof of Theorem 4.1 is done using a quantiﬁer elimination procedure: given a
query ψ(¯x) with at least one free variable we can compute a quantiﬁer-free query φ(¯x) that is
“equivalent” to ψ. Again, the equivalence should be understood modulo some augmentation
steps for a number of augmentation steps depending only on C and |ψ|. When starting with
a sentence ψ we end-up with φ being a boolean combination of formulas with one variable.
Those can be easily tested in linear time in the size of the augmented structure, which in
turn can be computed in time linear from the initial structure by Lemma 2.3. The result
follows. We now state precisely the quantiﬁer elimination step:

Proposition 4.2. Let C be a class of graphs with bounded expansion witnessed by the
function ΓC. Let ψ(¯xy) be a quantiﬁer-free formula over a recoloring of σC(p). Then one
can compute a q and a quantiﬁer-free formula φ(¯x) over a recoloring of σC(q) such that:
∈ Cq such that:
φ(f (cid:126)G

for all f (cid:126)G ∈ Cp there is an f (cid:126)G

) = (∃yψ)(f (cid:126)G)

(cid:48)

(cid:48)

Moreover, f (cid:126)G

(cid:48)

is computable in time O(||f (cid:126)G||).

Proof. In view of Lemma 3.1 we can assume that ψ is simple. We then apply Proposition 3.3
to ψ and p and obtain a q and an equivalent formula in DNF, where each disjunct has the
special form given by (3.1). As disjunction and existential quantiﬁcation commute, it is
enough to treat each part of the disjunction separately.

We thus assume that ψ(¯xy) is a quantiﬁer-free conjunctive formula over a recoloring of

σC(q) of the form (3.1):

ψ1(¯x) ∧ τ (y) ∧ ∆=(¯xy) ∧ ∆(cid:54)=(¯xy).

Let’s assume that the p-type τ satisﬁed by y enforces f1(y) < f2(y) < · · · , where
f1(y), f2(y), · · · are all the images of y by a function from σC(p) such that fi(y) (cid:54)= y.
Moreover, for each i < j, τ contains an atom of the form hi,j(fi(y)) = fj(y) for some
function hi,j ∈ σC(q).

We do a case analysis depending on the value of ∆=.
• If ∆= is y = g(xk) for some function g and some k, then we replace y with g(xk)

everywhere in ψ(¯xy) resulting in a formula φ(¯x) having obviously the desired properties.

• Assume now that ∆= is of the form f (y) = g(xk). Without loss of generality we
In other words ∆= contains only the constraint

can assume that f is fi0 and k = 1.
fi0(y) = g(x1).

The general idea is to limit the quantiﬁcation on y to a ﬁnite set (whose size depends
only on C and ψ), depending only on x1. We then encode these sets using suitable extra
colors. To do this, for each node w we ﬁrst compute a set Witness(w) such that for each
tuple ¯v we have f (cid:126)Gq |= ∃y ψ(¯vy) iﬀ f (cid:126)Gq |= ∃y ∈ Witness(g(v1)) ψ(¯vy). Moreover, for all

14

W. KAZANA AND L. SEGOUFIN

w, |Witness(w)| ≤ N where N is a number depending only on p. We then encode these
witness sets using suitable extra colors.

The intuition behind the Witness set is as follows. Assume ﬁrst that ∆(cid:54)= is empty.
Then we only need to test the existence of y such that fi0(y) = g(x1). To do so, we scan
through all nodes u, test if τ (u) holds and if so we add u to Witness(fi0(u)) if this set is
empty and do nothing otherwise. Clearly each witness set has size at most one and the
desired properties are veriﬁed. Moreover if v is in Witness(g(x1)) then fi0(v) = g(x1).
Therefore it is then enough to color with a new color red all nodes having a non-empty
witness set and ∃y τ (y) ∧ fi0(y) = g(x1) is then equivalent to red(g(x1)).

The situation is slightly more complicated if ∆(cid:54)= is not empty. Assume for instance
that ∆(cid:54)= contains only constraints of the form y (cid:54)= h(xk). Then the previous procedure
does not work because Witness(g(x1)) may be such that it is equal to h(xk). However
there are only c nodes that we need to avoid, where c depends only on the formula, hence
if Witness(g(x1)) contains at least c + 1 nodes we are sure that at least one of them will
satisfy all the inequality constraints. We implement this by scanning through all nodes u,
test if τ (u) holds and if so we add u to Witness(fi0(u)) if this set has a size smaller or
equal to c do nothing otherwise. The diﬃculty is to encode this set into the formula. If the
witness set is of size c + 1 one of its element must make all inequalities true hence a new
color as before does the job. When the set has a smaller size we need to test each of its
elements against the inequalities. For this we introduce a predicates Qi, and add a node u
to Qi if u has been added as the ith element in Witness(fi0(u)). As before any element
y in Witness(g(x1)) is such that fi0(y) = g(x1). It remains to test whether the ith such
element satisﬁes y (cid:54)= h(x). In other words whether h(x) is the ith witness of g(x1) or not. It
is easy to check that the ith witness of g(x1) is h(x) iﬀ Qi(h(xk)) ∧ fi0(h(xk)) = g(x1).

The general case, when ∆(cid:54)= contains also clauses of the form h1(y) (cid:54)= h2(xk) is more

complex and require an even bigger witness set but this is essentially what we do.

Computation of the Witness function. We start by initializing Witness(v) = ∅ for all v.

We then successively investigate all nodes u of f (cid:126)Gq and do the following. If f (cid:126)Gq |= ¬τ (u)
then we move on to the next u. If f (cid:126)Gq |= τ (u) then let u1, · · · , ul be the current value of
Witness(fi0(u)) - if Witness(fi0(u)) is empty then we add u to this set and move on to
the next node of f (cid:126)Gq.

Let βp be αC(p)(αC(p) + 1)|¯x| + 1.
Let i be minimal such that there exists j with fi(uj) = fi(u) (notice that i ≤ i0). Note
that because fj(w) = hi,j(fi(w)) for all w verifying τ and all j > i, this implies that u and
uj agree on each fj with j ≥ i and disagree on each fj with j < i.

Let Si = {fi−1(uj) | fi(uj) = fi(u)}, where f0(uj) is uj in the case where i = 1. If

|Si| < βp then we add u to Witness(fi0(u)).

Analysis of the Witness function. Clearly the algorithm computing the witness function runs
in linear time.

Moreover, for each node v, Witness(v) can be represented as the leaves of a tree of
depth at most αC(p) and of width βp. To see this, notice that all nodes u of Witness(v) are
such that fi0(u) = v. Note also that if two nodes u and u(cid:48) satisfying τ share a predecessor,
fi(u) = fi(u(cid:48)), then for all j > i, u and u(cid:48) agree on fj as fj = hi,j ◦ fi for all nodes satisfying
τ . The depth of the least common ancestor of two nodes u and u(cid:48) of Witness(v) is deﬁned
as the least i such that u and u(cid:48) agree on fi. One can then verify that by construction of

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION

15

Witness(v) the tree has the claimed sizes. Hence the size of Witness(v) is bounded by
βαC(p)+1
p

.

We now show that for each tuple ¯v and each node u such that f (cid:126)Gq |= ψ(¯vu) there is a

node u(cid:48) in Witness(g(v1)) such that f (cid:126)Gq |= ψ(¯vu(cid:48)).

To see this assume f (cid:126)Gq |= ψ(¯vu). If u ∈ Witness(g(v1)) we are done. Otherwise note
that fi0(u) = g(v1) and that f (cid:126)Gq |= τ (u). Let i and Si be as described in the algorithm
when investigating u. As u was not added to Witness(fi0(u)), we must have |Si| > βp. Let
u1, · · · , uβp be the elements of Witness(g(v1)) providing βp pairwise diﬀerent values for
fi−1. Among these, at most αC(p)|¯v| of them may be of the form fj(vl) for some j and l as
each vl has at most αC(p) predecessors. Notice that for all j > i and all (cid:96), u agrees with u(cid:96)
on fi and therefore they also agree on fj for j > i as fj = hi,j ◦ fi for all nodes satisfying τ .
When j < i the values of fj(u(cid:96)) and fj(u(cid:96)(cid:48)) must be diﬀerent if (cid:96) (cid:54)= (cid:96)(cid:48) as otherwise u(cid:96) and
u(cid:96)(cid:48) would also agree on fi−1 as fi−1 = hj,i−1 ◦ hi−1 for all nodes satisfying τ . Therefore, for
each (cid:96) and each j < i there are at most αC(p) of the u(cid:96) such that fj(u(cid:96)) is a predecessor of
vl.

Altogether, at most αC(p)2|¯v| + αC(p)|¯v| nodes u(cid:96) may falsify an inequality constraint.

As βp is strictly bigger than that, one of the u(cid:96) is the desired witness.

Recoloring of f (cid:126)Gq. Based on Witness we recolor f (cid:126)Gq as follows. Let γp = (βp + 1)αC(p)+1.
For each v ∈ f (cid:126)Gq, the ith witness of v is the ith element inserted in Witness(v) by the
algorithm.

For each i ≤ γp we introduce a new unary predicate Pi and for each u ∈ f (cid:126)Gq we set

Pi(u) if Witness(u) contains at least i elements.

For each i ≤ γp, we introduce a new unary predicate Qi and for each v ∈ f (cid:126)Gq we set

Qi(v) if the ith witness of fi0(v) is v.

For each i ≤ γp and each h, h(cid:48) ∈ αC(q) we introduce a new unary predicate Pi,h,h(cid:48) and
for each v ∈ f (cid:126)Gq we set Pi,h,h(cid:48)(v) if the ith witness of h(v) is an element u with h(cid:48)(u) = v.
the resulting graph and notice that it can be computed in linear time

(cid:48)
We denote by f (cid:126)G

from f (cid:126)G.

Computation of φ. We now replace ψ(¯x, y) by the following formula:

(cid:95)

ψ1(¯x) ∧ ψi(¯x)

i≤γp
where ψi(¯x) checks that the ith witness of g(x1) makes the initial formula true.

Notice that if y is the ith witness of g(x1) then fi0(y) = g(x1). Hence the equality
(cid:48)
fj(y) = h(xk) with j < i0 is equivalent over f (cid:126)G
to hj,i0(h(xk)) = g(x1) ∧ Pi,hj,i0 ,fj (h(xk))
(cid:48)
and the equality y = h(xk) is equivalent over f (cid:126)G
to fi0(h(xk)) = g(x1) ∧ Qi(h(xk)).
From the deﬁnition of p-type, the equality fj(y) = h(xk) with j > i0 is equivalent to
hi0,j(g(x1)) = h(xk).

16

W. KAZANA AND L. SEGOUFIN

This implies that ψi(¯x) can be deﬁned as

Pi(g(x1)) ∧

(cid:94)

¬(cid:0)hj,i0(h(xk)) = g(x1) ∧ Pi,hj,i0 ,fj (h(xk))(cid:1)

fj (y)(cid:54)=h(xk)∈∆(cid:54)=
j<i0

∧

∧

(cid:94)

hi0,j(g(x1)) (cid:54)= h(xk)

fj (y)(cid:54)=h(xk)∈∆(cid:54)=
j≥i0
(cid:94)

¬(cid:0)fi0(h(xk)) = g(x1) ∧ Qi(h(xk))(cid:1).

y(cid:54)=h(xk)∈∆(cid:54)=

It is constructed as in the previous case and veriﬁes:

• It remains to consider the case when ∆= is empty. This is a simpler version of the
previous case, only this time it is enough to construct a set Witness which does not depend
for all tuples ¯v of f (cid:126)Gq, if
on v.
f (cid:126)Gq |= ψ(¯vu) for some node u, then there is a node u(cid:48) ∈ Witness such that f (cid:126)Gq |= ψ(¯vu(cid:48)).
Moreover, |Witness| ≤ γp. We then argue as in the previous case.
Example A-5 . Consider one of the quantiﬁed formulas as derived by Example A- 4:

∃z y = h(x) ∧ τh,f,g(z) ∧ f (z) = x.

The resulting quantiﬁer-free query has the form:

P (x) ∧ h(x) = y

where P (x) is a newly introduced color saying “∃z τh,f,g(z) ∧ f (z) = x”. The key point
is that this new predicate can be computed in linear time by iterating through all nodes z,
testing whether τh,f,g(z) is true and, if this is the case, coloring f (z) with color P .

Applying the quantiﬁer elimination process from inside out using Proposition 4.2 for

each step and then applying Lemma 3.1 to the result yields:

Theorem 4.3. Let C be a class of graphs with bounded expansion. Let ψ(¯x) be a query of
FO over a recoloring of σC(0) with at least one free variable. Then one can compute a p and
a simple quantiﬁer-free formula φ(¯x) over a recoloring of σC(p) such that:

(cid:48)
∀f (cid:126)G ∈ C, we can construct in time O(||f (cid:126)G||) a graph f (cid:126)G

∈ Cp such that

(cid:48)
φ(f (cid:126)G

) = ψ(f (cid:126)G).

We will make use of the following useful consequence of Theorem 4.3:

Corollary 4.4. Let C be a class of graphs with bounded expansion and let ψ(¯x) be a formula
of FO over σC(0) with at least one free variable. Then, for all f (cid:126)G ∈ C, after a preprocessing
in time O(||f (cid:126)G||), we can test, given ¯u as input, whether f (cid:126)G |= ψ(¯u) in constant time.

Proof. By Theorem 4.3 it is enough to consider quantiﬁer-free simple queries. Hence it is
enough to consider a query consisting in a single atom of either P (x) or P (f (x)) or x = f (y)
or f (x) = g(y).

During the preprocessing phase we associate to each node v of the input graph a list
L(v) containing all the predicates satisﬁed by v and all the images of v by a function symbol
from the signature. This can be computed in linear time by enumerating all relations of

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION

17

the database and updating the appropriate lists with the corresponding predicate or the
corresponding image.

Now, because we use the RAM model, given u we can in constant time recover the
list L(u). Using those lists it is immediate to check all atoms of the formula in constant
time.

Theorem 4.1 is a direct consequence of Theorem 4.3 and Corollary 4.4: Starting with a
sentence, and applying Theorem 4.3 for eliminating quantiﬁers from inside out we end up
with a Boolean combination of formulas with one variable. Each such formula can be tested
in O(||f (cid:126)G||) by iterating through all nodes v of f (cid:126)G and in constant time (using Corollary 4.4)
checking if v can be substituted for the sole existentially quantiﬁed variable.

On top of Theorem 4.1 the following corollary is immediate from Theorem 4.3 and

Corollary 4.4:

Corollary 4.5. Let C be a class of graphs with bounded expansion and let ψ(x) be a formula
of FO over σC(0) with one free variable. Then, for all f (cid:126)G ∈ C, computing the set ψ(f (cid:126)G)
can be done in time O(||f (cid:126)G||).

5. Enumeration

In this section we consider ﬁrst-order formulas with free variables and show that we can enu-
merate their answers with constant delay over any class with bounded expansion. Moreover,
assuming a linear order on the domain of the input structure, we will see that the answers
can be output in the lexicographical order. As before we only state the result for graphs,
but it immediately extends to arbitrary structures by Lemma 2.6.

Theorem 5.1. Let C be a class of graphs with bounded expansion and let φ(¯x) be a ﬁrst-order
query. Then the enumeration problem of φ over C is in CD◦Lin.
Moreover, in the presence of a linear order on the vertices of the input graph, the answers to
φ can be output in lexicographical order.

The proof of Theorem 5.1 is by induction on the number of free variables of φ. The
unary case is done by Corollary 4.5. The inductive case is a simple consequence of the
following:

Proposition 5.2. Let C be a class of graphs with bounded expansion and let φ(¯xy) be a
ﬁrst-order query or arity 2 or more. Let G be a graph of C. Let < be any linear order on
the nodes of G. After a preprocessing working in time linear in the size of G we can, on
input a tuple ¯a of nodes of G, enumerate with constant delay and in the order given by <
all b such that G |= φ(¯ab) or answer nill if no such b exists.

Proof. Fix a class C of graphs with bounded expansion and a query φ(¯xy) with k ≥ 2 free
variables. Let f (cid:126)G be the functional representation of the input graph and V be its set of
vertices. Let < be any order on V .

(cid:48)
query ϕ(¯xy) and a structure f (cid:126)G
(cid:48)
(cid:48)
) = φ(f (cid:126)G) and f (cid:126)G
ϕ(f (cid:126)G

During the preprocessing phase, we apply Theorem 4.3 to get a simple quantiﬁer-free
∈ Cp, for some p that does not depend on f (cid:126)G, such that

can be computed in linear time from f (cid:126)G.
Furthermore we normalize the resulting simple quantiﬁer-free query using Proposition 3.3,
∈ Cq, where q depends

(cid:48)(cid:48)
and obtain an equivalent quantiﬁer-free formula ψ and a structure f (cid:126)G

18

W. KAZANA AND L. SEGOUFIN

(cid:48)(cid:48)
only on p and ϕ, f (cid:126)G
a disjunction of formulas of the form (3.1):

(cid:48)
can be computed in linear time from f (cid:126)G

(cid:48)
, ϕ(f (cid:126)G

(cid:48)(cid:48)
) = ψ(f (cid:126)G

) and ψ is

ψ1(¯x) ∧ τ (y) ∧ ∆=(¯xy) ∧ ∆(cid:54)=(¯xy),
where ∆=(¯xy) is either empty or contains one clause of the form y = f (xi) or one clause of
the form f (y) = g(xi) for some i, f and g; and ∆(cid:54)=(¯xy) contains arbitrarily many clauses of
the form y (cid:54)= f (xi) or f (y) (cid:54)= g(xj).

In view of Lemma 2.1 it is enough to treat each disjunct separately. In the sequel we
then assume that ψ has the form described in (3.1). We let ψ(cid:48)(y) be the formula ∃¯xψ(¯xy)
and ψ(cid:48)(cid:48)(¯x) the formula ∃yψ(¯xy).

If ∆= contains an equality of the form y = f (xi) we then use Corollary 4.4 and test

(cid:48)(cid:48)
whether f (cid:126)G

|= ψ(¯af (ai)) and we are done as f (ai) is the only possible solution for ¯a.

Assume now that ∆= is either empty or of the form f (y) = g(xi).
We ﬁrst precompute the set of possible candidates for y (i.e. those y satisfying ψ(cid:48)) and
distribute this set within their images by f . In other words we deﬁne a function L : V → 2V
such that

(cid:48)(cid:48)
L(w) = {u | w = f (u) ∧ u ∈ ψ(cid:48)(f (cid:126)G

)}.

(cid:48)(cid:48)
In the speciﬁc case where ∆= is empty we pick an arbitrary node w0 in f (cid:126)G
(cid:48)(cid:48)
L(w0) = ψ(cid:48)(f (cid:126)G
(cid:48)(cid:48)
procedure. We ﬁrst use Corollary 4.5 and compute in linear time the set ψ(cid:48)(f (cid:126)G
(cid:48)(cid:48)
next initialize L(w) to ∅ for each w ∈ V . Then, for each u ∈ ψ(cid:48)(f (cid:126)G
L(f (u)).

and set
) and L(w) = ∅ for w (cid:54)= w0. This can be done in linear time by the following
). We
), we add u to the set

Let W be the function from V k−1 to V such that W (¯v) = g(vi). In the speciﬁc case

where ∆= is empty we set W (¯v) = w0, where w0 is the node chosen above.

(cid:48)(cid:48)
Notice that for each ¯vu, f (cid:126)G

|= ψ(¯vu) implies u ∈ L(W (¯v)) and if u ∈ L(W (¯v)) then
∆=(¯vu) is true. Hence, given ¯a it remains to enumerate within L(W (¯a)) the nodes b satisfying
∆(cid:54)=(¯ab).

To do this with constant delay, it will be important to jump from an element u of L(w)
to the smallest (according to <) element u(cid:48) ≥ u of L(w) satisfying the inequality constraints.
For this we deﬁne for S1, . . . , SαC(q) ⊆ V the element nextf1,S1,...,fαC (q),SαC (q)(u) to be the
ﬁrst element w ≥ u of L(f (u))1 such that f1(w) /∈ S1, . . . , and fαC(q)(w) /∈ SαC(q). If such w
does not exist, the value of nextf1,S1,...,fαC (q),SαC (q)(u) is NULL. When all Si are empty, we
write next∅(u) and by the above deﬁnitions we always have next∅(u) = u. We denote such
functions as shortcut pointers of u. The size of a shortcut pointer nextf1,S1,...,fαC (q),SαC (q)(u)
is the sum of sizes of the sets Si.

In order to avoid writing too long expressions containing shortcut pointers, we introduce

the following abbreviations:
• nextf1,S1,...,fαC (q),SαC (q)(u) is denoted with next(cid:126)S(u),
• nextf1,S1,...,fi,Si∪{ui},...,fαC (q),SαC (q)
Set γq = (k − 1) · αC(q)2.

(u) is denoted with next(cid:126)S[Si+={ui}](u).

1In order to simplify the notations we consider explicitly the case where ∆= is not empty. If empty then

L(f (u)) should be replaced by L(w0).

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION

19

Computing all shortcut pointers of size γq would take more than linear time. We
therefore only compute a subset of those, denoted SCL, that will be suﬃcient for our needs.
SCL is deﬁned in an inductive manner. For all u such that u ∈ L(f (u)), next∅(u) ∈ SCL.
Moreover, if the shortcut pointer next(cid:126)S(u) ∈ SCL is not NULL and has a size smaller than
γq, then, for each i, next(cid:126)S[Si+={ui}](u) ∈ SCL, where ui = fi(next(cid:126)S(u)). We then say
that next(cid:126)S(u) is the origin of next(cid:126)S[Si+={ui}](u). Note that SCL contains all the shortcut
pointers of the form nextfi,{fi(u)}(u) for u ∈ L(f (u)) and these are exactly the shortcut
pointers of u of size 1. By SCL(u) ⊆ SCL we denote the shortcut pointers of u that are in
SCL.

The set SCL contains only a constant number of shortcut pointers for each node u.
Claim 5.3. There exists a constant ζ(q, k) such that for every node u we have |SCL(u)| ≤
ζ(q, k).
Proof. The proof is a direct consequence of the recursive deﬁnition of SCL(u). Fix u.
Note that there is exactly 1 shortcut pointer of u of size 0 (namely next∅(u)) and αC(q)
shortcut pointers of u of size 1. By the deﬁnition of SCL, any shortcut pointer next(cid:126)S(u)
can be an origin of up to αC(q) shortcut pointers of the form next(cid:126)S[Si+={ui}](u), where
ui = fi(next(cid:126)S(u)) and the size of next(cid:126)S[Si+={ui}](u) is the size of next(cid:126)S(u) plus 1. This
way we see that SCL(u) contains up to αC(q)2 shortcut pointers of size 2 and, in general, up
to αC(q)s shortcut pointers of size s. As the maximal size of a computed shortcut pointer is
bounded by γq, we have |SCL(u)| ≤ (cid:80)
αC(q)i. Both αC(q) and γq depend only on q
and k, which concludes the proof.

0≤i≤γq

Moreover SCL contains all what we need to know.

αC (q)

1,...,fαC (q),S(cid:48)

Claim 5.4. Let next(cid:126)S(u) be a shortcut pointer of size not greater than γq. Then there
exists next (cid:126)S(cid:48)(u) ∈ SCL such that next(cid:126)S(u) = next (cid:126)S(cid:48)(u). Moreover, such next (cid:126)S(cid:48)(u) can
be found in constant time.
Proof. If next(cid:126)S(u) ∈ SCL, then we have nothing to prove. Assume then that next(cid:126)S(u) /∈
SCL. We write nextf1,S(cid:48)
(u) (cid:22) nextf1,S1,...,fαC (q),SαC (q)(u) if for each 1 ≤ i ≤
αC(q) we have S(cid:48)
i ⊆ Si. Note that for a given u the (cid:22) relation is a partial order on the
set of shortcut pointers of u. A trivial observation is that if nextf1,S(cid:48)
(u) (cid:22)
nextf1,S1,...,fαC (q),SαC (q)(u), then nextf1,S(cid:48)

1,...,fαC (q),S(cid:48)
Let next (cid:126)S(cid:48)(u) ∈ SCL be a maximal in terms of size shortcut pointer of u such that
next (cid:126)S(cid:48)(u) (cid:22) next(cid:126)S(u). Such a shortcut pointer always exists as next∅(u) (cid:22) next(cid:126)S(u)
and next∅(u) ∈ SCL. Note that the size of next (cid:126)S(cid:48)(u) is strictly smaller than the size of
next(cid:126)S(u), so it is strictly smaller than γq. One can ﬁnd next (cid:126)S(cid:48)(u) by exploring all the
shortcut pointers of u in SCL(u). This can be done in constant time using Claim 5.3.

(u) ≤ nextf1,S1,...,fαC (q),SαC (q)(u).

1,...,fαC (q),S(cid:48)

We now claim that next(cid:126)S(u) = next (cid:126)S(cid:48)(u).
Let v = next (cid:126)S(cid:48)(u). We know that v ≤ next(cid:126)S(u). Assume now that there would exists
1 ≤ i ≤ αC(q) such that fi(v) ∈ Si. Then we have that next (cid:126)S(cid:48)[S(cid:48)
i+={ui}](u) ∈ SCL, where
ui = fi(v), and this contradicts the maximality of next (cid:126)S(cid:48)(u). This means that such an i
does not exist and concludes the fact that next(cid:126)S(u) = next (cid:126)S(cid:48)(u).

αC (q)

αC (q)

The following claim guarantees that SCL can be computed in linear time and has

therefore a linear size.

20

W. KAZANA AND L. SEGOUFIN

(cid:48)(cid:48)
Claim 5.5. SCL can be computed in time linear in ||f (cid:126)G
Proof. For every u we compute SCL(u) in time linear in the size of SCL(u). By Claim 5.3
the total time is linear in the size of V as claimed.

||.

The computation of SCL(u) is done in reverse order on u: Assuming SCL(v) has been

computed for all v > u we compute SCL(u) time linear in the size of L(u).

Note that we only care to compute next(cid:126)S(u) when u ∈ L(u).
Consider a node u. If u is the maximaum vertex then all next(cid:126)S(u) are NULL.
Assume now that u is not the maximum vertex and that for all v > u SCL(v) has been
computed. If u does not belong to L(u) we do nothing. If u ∈ L(u) we set next∅(u) = u
and we construct SCL(u) by induction on the size.

Assume next(cid:126)S(u) ∈ SCL has already been computed. Let v = next(cid:126)S(u) and assume

it is not NULL. Let (cid:126)S(cid:48) = (cid:126)S[Si+= {fi(v)}] and assume next (cid:126)S(cid:48)(u) ∈ SCL(u).

It is easy to see that next (cid:126)S(cid:48)(u) = next (cid:126)S(cid:48)(v). By Claim 5.4 we can obtain in constant
time next (cid:126)S(cid:48)(cid:48)(v) ∈ SCL(v) such that next (cid:126)S(cid:48)(v) = next (cid:126)S(cid:48)(cid:48)(v). As v > u the value of
next (cid:126)S(cid:48)(cid:48)(v) has already been computed.

The computation of SCL concludes the preprocessing phase and it follows from Claim 5.5

that it can be done in linear time. We now turn to the enumeration phase.

Assume we are given ¯a. In view of Corollary 4.4 we can without loss of generality assume

that ¯a is such that G |= ψ(cid:48)(cid:48)(¯a). If not we simply return nill and stop here.

(cid:48)(cid:48)
By construction we know that all nodes b such that f (cid:126)G

|= ψ(¯ab) are in L = L(W (¯a)).
Recall also that all elements b ∈ L make τ (b) ∧ ∆=(¯ab) true. For 1 ≤ i ≤ αC(q) we set
Si = {g(vj) : g(xj) (cid:54)= fi(y) is a conjunct of ∆(cid:54)=}. Starting with b the ﬁrst node of the sorted
list L, we apply the following procedure:
(1) If b is not NULL, let next (cid:126)S(cid:48)(b) be the shortcut pointer from the application of Claim 5.4

to next(cid:126)S(b). Set b(cid:48) = next (cid:126)S(cid:48)(b). If b(cid:48) = NULL, stop here.

(cid:48)(cid:48)
(2) If f (cid:126)G
(3) Reinitialize b to the successor of b(cid:48) in L and continue with Step 1.

|= ψ(¯ab(cid:48)), output b(cid:48).

We now show that the algorithm is correct.
(cid:48)(cid:48)
The algorithm clearly outputs only solutions as it tests whether f (cid:126)G

|= ψ(¯ab(cid:48)) before

outputting b(cid:48).

By the deﬁnition of sets Si and next(cid:126)S(b), for each b ≤ v < b(cid:48) there is a i and j such
that g(aj) = fi(v) and g(xj) (cid:54)= fi(y) is a conjunct of ∆(cid:54)=. This way the algorithm does not
skip any solutions at Step 1 and so it outputs exactly all solutions.

It remains to show that there is a constant time between any two outputs. Step 1 takes
constant time due to Claim 5.4. From there the algorithm either immediately outputs a
(cid:48)(cid:48)
solution at Step 2 or jumps to Step 3. In the second case, this means that f (cid:126)G
(cid:54)|= ψ(¯ab(cid:48)), but
from the deﬁnitions of list L, sets Si and shortcut pointers next(cid:126)S(b) this can only happen
if ∆(cid:54)= is falsiﬁed and this is because of an inequality of the form y (cid:54)= g(xj) for some suitable
g and j (where g may possibly be identity). Hence b(cid:48) = g(aj). As all the elements on L are
distinct, the algorithm can skip over Step 2 up to (k − 1) · (αC(q) + 1) times for each tuple ¯a
(there are up to that many diﬀerent images of nodes from ¯a under αC(q) diﬀerent functions).
The delay is therefore bounded by k · (αC(q) + 1) consecutive applications of Claim 5.4.

As the list L was sorted with respect to the linear order on the domain, it is clear that

the enumeration procedure outputs the set of solutions in lexicographical order.

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION

21

This concludes the proof of the theorem.

6. Counting

In this section we investigate the problem of counting the number of solutions to a query,
i.e. computing |q(D)|. As usual we only state and prove our results over graphs but they
generalize to arbitrary relational structures via Lemma 2.6.

Theorem 6.1. Let C be class of graphs with bounded expansion and let φ(¯x) be a ﬁrst-order
formula. Then, for all f (cid:126)G ∈ C, we can compute |φ(f (cid:126)G)| in time O(||f (cid:126)G||).

Proof. The key idea is to prove a weighted version of the desired result. Assume φ(¯x) has
exactly k free variables and for 1 ≤ i ≤ k we have functions #i : V → N. We will compute
in time linear in ||f (cid:126)G|| the following number:

|φ(f (cid:126)G)|# :=

(cid:88)

(cid:89)

#i(ui).

¯u∈φ(f (cid:126)G)

1≤i≤k

By setting all #i to be constant functions with value 1 we get the regular counting

problem. Hence Theorem 6.1 is an immediate consequence of the next lemma.

Lemma 6.2. Let C be class of graphs with bounded expansion and let φ(¯x) be a ﬁrst-order
formula with exactly k free variables.
For 1 ≤ i ≤ k let #i : V → N be functions such that for each v the value of #i(v) can be
computed in constant time.
Then, for all f (cid:126)G ∈ C, we can compute |φ(f (cid:126)G)|# in time O(||f (cid:126)G||).
Proof. The proof is by induction on the number of free variables.

The case k = 1 is trivial: in time linear in ||f (cid:126)G|| we compute φ(f (cid:126)G) using Corollary 4.5.
By hypothesis, for each v ∈ φ(f (cid:126)G), we can compute the value of #1(v) in constant time.
Therefore the value

|φ(f (cid:126)G)|# =

(cid:88)

#1(v)

v∈φ(f (cid:126)G)

can be computed in linear time as desired.

Assume now that k > 1 and that ¯x and y are the free variables of φ, where |¯x| = k − 1.
We apply Theorem 4.3 to get a simple quantiﬁer-free query ϕ(¯xy) and a structure
(cid:48)
(cid:48)
(cid:48)
f (cid:126)G
∈ Cp, for some p that does not depend on f (cid:126)G, such that ϕ(f (cid:126)G
) = φ(f (cid:126)G) and f (cid:126)G
can
(cid:48)
be computed in linear time from f (cid:126)G. Note that |φ(f (cid:126)G)|# = |ϕ(f (cid:126)G
)|#, so it is enough to
compute the latter value.

We normalize the resulting simple quantiﬁer-free query using Proposition 3.3, and obtain
∈ Cq, where q depends only
) and ψ is a

(cid:48)(cid:48)
an equivalent quantiﬁer-free formula ψ and a structure f (cid:126)G
(cid:48)
(cid:48)(cid:48)
on p and ϕ, f (cid:126)G
can be computed in linear time from f (cid:126)G
disjunction of formulas of the form (3.1):

(cid:48)(cid:48)
) = ψ(f (cid:126)G

(cid:48)
, ϕ(f (cid:126)G

ψ1(¯x) ∧ τ (y) ∧ ∆=(¯xy) ∧ ∆(cid:54)=(¯xy),
where ∆=(¯xy) is either empty or contains one clause of the form y = f (xi) or one clause of
the form f (y) = g(xi) for some suitable i, f and g; and ∆(cid:54)=(¯xy) contains arbitrarily many

22

W. KAZANA AND L. SEGOUFIN

(cid:48)
clauses of the form y (cid:54)= f (xi) or f (y) (cid:54)= g(xj). Note that |ϕ(f (cid:126)G
enough to compute the latter value.

(cid:48)(cid:48)
)|# = |ψ(f (cid:126)G

)|#, so it is

Observe that it is enough to solve the weighted counting problem for each disjunct
separately, as we can then combine the results using a simple inclusion-exclusion reasoning
(the weighted sum for q ∨ q(cid:48) is obtained by adding the weighted sum for q to the weighted
sum for q(cid:48) and then subtracting the weighted sum for q ∧ q(cid:48)). In the sequel we then assume
that ψ has the form described in (3.1).

The proof now goes by induction on the number of inequalities in ∆(cid:54)=. While the
inductive step turns out to be fairly easy, the diﬃcult part is the base step of the induction.
We start with proving the inductive step. Let g(y) (cid:54)= f (xi) be an arbitrary inequality
from ∆(cid:54)= (where g might possibly be the identity). Let ψ− be ψ with this inequality removed
and ψ+ = ψ− ∧ g(y) = f (xi). Of course ψ and ψ+ have disjoint sets of solutions and we
have:

(cid:48)(cid:48)
|ψ(f (cid:126)G

(cid:48)(cid:48)
)|# = |ψ−(f (cid:126)G

(cid:48)(cid:48)
)|# − |ψ+(f (cid:126)G

)|#.

Note that ψ− and ψ+ have one less conjunct in ∆(cid:54)=. The problem is that ψ+ is not of
the form (3.1) as it may now contain two elements in ∆=. However it can be seen that the
removal of the extra equality in ∆= as described in the proof of Proposition 3.3 does not
introduce any new elements in ∆(cid:54)=.
Claim 6.3. . There exists a query ψ+
NF such that: its size depends only on the size of ψ+, ψ+
NF
is in the normal form given by (3.1), it contains an inequality conjunct h(y) (cid:54)= g1(xi) (where
(cid:48)(cid:48)
) = ψ+(f (cid:126)G
h might possibly be identity) iﬀ ψ+ also contains such conjunct and ψ+
).
Moreover, ψ+

NF can be constructed in time linear in the size of ψ+.

NF(f (cid:126)G

(cid:48)(cid:48)

Proof. The proof is a simple case analysis of the content of ∆= of ψ.

If its empty, then ψ+
If it contains an atom of the form y = h2(xj), then equality g(y) = f (xi) is equivalent

NF is already in the desired form.

to g(h2(xj)) = f (xi) and we are done.

If it contains an atom of the form h3(y) = h2(xj) and g is identity, then h3(y) = h2(xj)
is equivalent to h3(f (xi)) = h2(xj). If g is not identity, then τ (y) ensures us that either
g(y) determines h3(y) or vice versa. If we have h4(g(y)) = h3(y), then h3(y) = h2(xj) is
equivalent to h4(f (xi)) = h2(xj). The other case is symmetric.

The fact that ψ+

in time linear in the size of ψ+ and that ψ+
construction.

NF(f (cid:126)G

NF does not contain any additional inequalities, that it can be computed
) follows from the above

(cid:48)(cid:48)
) = ψ+(f (cid:126)G

(cid:48)(cid:48)

We can therefore remove the extra element in ∆+ and assume that ψ+ has the desired
form. We can now use the inductive hypothesis on the size of ∆(cid:54)= to both ψ− and ψ+ in
(cid:48)(cid:48)
order to compute both |ψ−(f (cid:126)G

(cid:48)(cid:48)
)|# and derive |ψ(f (cid:126)G

(cid:48)(cid:48)
)|# and |ψ+(f (cid:126)G

)|#.

It remains to show the base of the inner induction. In the following we assume that ∆(cid:54)=

is empty. The rest of the proof is a case analysis on the content of ∆=.
Assume ﬁrst that ∆= consists of an atom of the form y = f (x1).

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION

23

Note that the solutions to ψ are of the form (¯vf (v1)). We have:

(cid:48)(cid:48)
|ψ(f (cid:126)G

)|# =

(cid:88)



#k(u)

(cid:89)



#i(vi)



(¯vu)∈ψ(f (cid:126)G

(cid:48)(cid:48)

)

1≤i≤k−1

(cid:88)

=

(¯vf (v1))∈ψ(f (cid:126)G

(cid:48)(cid:48)

)

(cid:88)

=

(¯vf (v1))∈ψ(f (cid:126)G

(cid:48)(cid:48)

)



#k(f (v1))



#i(vi)



(cid:89)

1≤i≤k−1



#1(v1)#k(f (v1))



(cid:89)

#i(vi)



2≤i≤k−1

(cid:48)(cid:48)
In linear time we now iterate through all nodes w in f (cid:126)G
1(w) := #1(w) · #k(f (w))
i(w) := #i(w)

#(cid:48)
#(cid:48)

and set

for 2 ≤ i ≤ k − 1.

Let ϑ(¯x) be ψ with all occurrences of y replaced with f (x1). We then have:



#(cid:48)

i(vi)




#(cid:48)

1(v1)

(cid:89)

2≤i≤k−1

#(cid:48)

i(vi)

(cid:48)(cid:48)
|ψ(f (cid:126)G

)|# =

(cid:88)

(¯vf (v1))∈ψ(f (cid:126)G

(cid:48)(cid:48)

)
(cid:89)

(cid:88)

=

¯v∈ϑ(f (cid:126)G
(cid:48)(cid:48)
= |ϑ(f (cid:126)G

)|#(cid:48)

(cid:48)(cid:48)

1≤i≤k−1

)

By induction on the number of free variables, as #(cid:48)

(cid:48)(cid:48)
time for each i and w, we can compute |ϑ(f (cid:126)G

i(w) can be computed in constant
(cid:48)(cid:48)
)|#(cid:48) in time linear in ||f (cid:126)G
|| and we are done.
Assume now that ∆= consists of an atom g(y) = f (x1). Let ψ(cid:48)(y) be the formula
) in linear time using

(cid:48)(cid:48)
∃¯xψ(¯xy) and ψ(cid:48)(cid:48)(¯x) the formula ∃yψ(¯xy). We ﬁrst compute set ψ(cid:48)(f (cid:126)G
Corollary 4.5. We now deﬁne a function #(cid:48)(cid:48)

k : V → N as:

#(cid:48)(cid:48)

k(w) :=

(cid:88)

#k(u).

(cid:48)(cid:48)

{u∈ψ(cid:48)(f (cid:126)G
g(u)=w}

)

k(g(w)).

Note that this function can be easily computed in linear time by going through all nodes w
and adding #k(w) to #(cid:48)(cid:48)
Finally we set:
#(cid:48)
#(cid:48)

1(w) := #1(w)#(cid:48)(cid:48)
i(w) := #i(w)
(cid:48)(cid:48)
Let u1, u2 ∈ ψ(cid:48)(f (cid:126)G
) be such that g(u1) = g(u2). Because ∆(cid:54)= is empty, observe that
(cid:48)(cid:48)
f (cid:126)G
|= ∀¯x(ψ(¯xu1) ↔ ψ(¯xu2)). Based on this observation we now group the solutions to ψ
according to their last k − 1 values and get:

for 2 ≤ i ≤ k − 1.

k(f (w))

24

W. KAZANA AND L. SEGOUFIN

(cid:48)(cid:48)
|ψ(f (cid:126)G

)|# =

(cid:88)

(¯vu)∈ψ(f (cid:126)G

(cid:48)(cid:48)

)



#k(u)

(cid:89)



#i(vi)



1≤i≤k−1


#k(u)



#i(vi)



(cid:89)

1≤i≤k−1

(cid:88)

=

¯v∈ψ(cid:48)(cid:48)(f (cid:126)G

(cid:48)(cid:48)

)

(cid:88)

(cid:48)(cid:48)

{u∈ψ(cid:48)(f (cid:126)G
)
g(u)=f (v1)}


(cid:88)

¯v∈ψ(cid:48)(cid:48)(f (cid:126)G

(cid:48)(cid:48)

)






(cid:88)

#k(u)








(cid:89)

#i(vi)

1≤i≤k−1

(cid:48)(cid:48)

{u∈ψ(cid:48)(f (cid:126)G
)
g(u)=f (v1)}


#(cid:48)(cid:48)

k(f (v1))

)

#1(v1)#(cid:48)(cid:48)



#i(vi)



(cid:89)

1≤i≤k−1



k(f (v1))

(cid:89)

2≤i≤k−1

#(cid:48)

i(vi)



=

=

(cid:88)

¯v∈ψ(cid:48)(cid:48)(f (cid:126)G

(cid:48)(cid:48)

(cid:88)

=
¯v∈ψ(cid:48)(cid:48)(f (cid:126)G
(cid:88)

=

(cid:48)(cid:48)

)

(cid:48)(cid:48)

¯v∈ψ(cid:48)(cid:48)(f (cid:126)G
(cid:48)(cid:48)
= |ψ(cid:48)(cid:48)(f (cid:126)G

)|#(cid:48)

(cid:89)

#(cid:48)

i(vi)

1≤i≤k−1

)

By induction on the number of free variables, as #(cid:48)

i(w) can be computed in constant

(cid:48)(cid:48)
time for each i and w, we can compute |ψ(cid:48)(cid:48)(f (cid:126)G

)|#(cid:48) and we are done with this case.

The remaining case when ∆= is empty is handled similarly to the previous one. We

then have

ψ(¯xy) = ψ1(¯x) ∧ τ (y).

After setting
#(cid:48)

1(w) := #2(w) ·

(cid:88)

#1(u)

(cid:48)(cid:48)
u∈τ (f (cid:126)G

)

#(cid:48)

i(w) := #i+1(w)

for 2 ≤ i ≤ k − 1

we see that

(cid:48)(cid:48)
|ψ(f (cid:126)G
and we conclude again by induction on the number of free variables.

(cid:48)(cid:48)
)|# = |ψ1(f (cid:126)G

)|#(cid:48)

As we said earlier, Theorem 6.1 is an immediate consequence of Lemma 6.2.

7. Conclusions

Queries written in ﬁrst-order logic can be eﬃciently processed over the class of structures
having bounded expansion. We have seen that over this class the problems investigated in
this paper can be computed in time linear in the size of the input structure. The constant
factor however is high. The approach taken here, as well as the ones of [DKT13, GK11],

FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION

25

yields a constant factor that is a tower of exponentials whose height depends on the size
of the query. This nonelementary constant factor is unavoidable already on the class of
unranked trees, assuming FPT(cid:54)=AW[∗] [FG04]. In comparison, this factor can be triply
exponential in the size of the query in the bounded degree case [See96, KS11].

Since the submission of this work, the result has been extended to a larger class of
structures. In [NdM11] the class of nowhere dense graphs was introduced and it generalizes
the notion of bounded expansion. It has been shown that the model checking problem
of ﬁrst-order logic can be done in nearly linear time (i.e.
for any (cid:15) > 0 it can be done
in O(n1+(cid:15))) over any nowhere dense class of graph [GKS17]. Recently an enumeration
procedure has been proposed for ﬁrst-order queries over nowhere dense graph classes, with a
nearly linear preprocessing time and constant delay [SSV18].

For graph classes closed under substructures, the nowhere dense property seems to be
the limit for having good algorithmic properties for ﬁrst-order logic. Indeed, it is known
that the model checking problem of ﬁrst-order logic over a class of structures that is not
nowhere dense cannot be FPT [KD09] (modulo some complexity assumptions).

For structures of bounded expansion, an interesting open question is whether a sampling
of the solutions can be performed in linear time. For instance: can we compute the j-th
solution in constant time after a linear preprocessing? This can be done in the bounded
degree case [BDGO08] and in the bounded treewidth case [Bag09]. We leave the bounded
expansion case for future research.

Finally it would be interesting to know whether the index structure computed in linear
time for the enumeration process could be updated eﬃciently. In the boolean case, queries
of arity 0, updates can be done in constant time [DKT13], assuming the underlying graph is
not changed too much. In particular a relabeling of a node require only constant update
time. It would be interesting to know whether this constant update time could also be
achieved for an index structure allowing for constant delay enumeration.

References

[ALS91]

[AYZ95]
[Bag06]

[Bag09]

Stefan Arnborg, Jens Lagergren, and Detlef Seese. Easy Problems for Tree-Decomposable Graphs.
J. of Algorithms, 12(2):308–340, 1991.
Noga Alon, Raphael Yuster, and Uri Zwick. Color-Coding. J. ACM, 42(4):844–856, 1995.
Guillaume Bagan. MSO Queries on Tree Decomposable Structures Are Computable with Linear
Delay. In Conf. on Computer Science Logic (CSL), pages 167–181, 2006.
Guillaume Bagan. Algorithmes et complexit´e des probl`emes d’´enum´eration pour l’´evaluation de
requˆetes logiques. PhD thesis, Universit´e de Caen, 2009.

[Cou90]

[BDG07] Guillaume Bagan, Arnaud Durand, and Etienne Grandjean. On Acyclic Conjunctive Queries and
Constant Delay Enumeration. In Conf. on Computer Science Logic (CSL), pages 208–222, 2007.
[BDGO08] Guillaume Bagan, Arnaud Durand, Etienne Grandjean, and Fr´ed´eric Olive. Computing the jth
solution of a ﬁrst-order query. RAIRO Theoretical Informatics and Applications, 42(1):147–164,
2008.
Bruno Courcelle. Graph Rewriting: An Algebraic and Logic Approach. In Handbook of Theoretical
Computer Science, Volume B: Formal Models and Sematics (B), pages 193–242. 1990.
Arnaud Durand and Etienne Grandjean. First-order queries on structures of bounded degree are
computable with constant delay. ACM Trans. on Computational Logic (ToCL), 8(4), 2007.
Zdenek Dvorak, Daniel Kr´al, and Robin Thomas. Testing ﬁrst-order properties for subclasses of
sparse graphs. J. ACM, 60(5):36:1–36:24, 2013.
Markus Frick and Martin Grohe. The complexity of ﬁrst-order and monadic second-order logic
revisited. Ann. Pure Appl. Logic, 130(1-3):3–31, 2004.

[DKT13]

[DG07]

[FG04]

26

W. KAZANA AND L. SEGOUFIN

[GK11]

Martin Grohe and Stephan Kreutzer. Model Theoretic Methods in Finite Combinatorics, chapter
Methods for Algorithmic Meta Theorems. American Mathematical Society, 2011.

[GKS17] Martin Grohe, Stephan Kreutzer, and Sebastian Siebertz. Deciding ﬁrst-order properties of

nowhere dense graphs. J. of the ACM, 64(3):17:1–17:32, 2017.

[Kaz13] Wojciech Kazana. Query evaluation with constant delay. (L’´evaluation de requˆetes avec un d´elai

[KD09]

[KS11]

constant). PhD thesis, ´Ecole normale sup´erieure de Cachan, Paris, France, 2013.
Stephan Kreutzer and Anuj Dawar. Parameterized complexity of ﬁrst-order logic. Electronic
Colloquium on Computational Complexity (ECCC), 16:131, 2009.
Wojciech Kazana and Luc Segouﬁn. First-order query evaluation on structures of bounded degree.
Logical Methods in Computer Science (LMCS), 7(2), 2011.

[KS13a] Wojciech Kazana and Luc Segouﬁn. Enumeration of ﬁrst-order queries on classes of structures
with bounded expansion. In Symp. on Principles of Database Systems (PODS), pages 297–308,
2013.

[KS13b] Wojciech Kazana and Luc Segouﬁn. Enumeration of monadic second-order queries on trees. ACM

Trans. on Computational Logic (ToCL), 14(4), 2013.

[NdM08a] Jaroslav Neˇsetˇril and Patrice Ossona de Mendez. Grad and classes with bounded expansion I.

Decompositions. Eur. J. Comb., 29(3):760–776, 2008.

[NdM08b] Jaroslav Neˇsetˇril and Patrice Ossona de Mendez. Grad and classes with bounded expansion II.

[NdM11]

[PY99]

[See96]

[SSV18]

[SV17]

Algorithmic aspects. Eur. J. Comb., 29(3):777–791, 2008.
Jaroslav Neˇsetˇril and Patrice Ossona de Mendez. On nowhere dense graphs. European J. of
Combinatorics, 32(4):600–617, 2011.
Christos H. Papadimitriou and Mihalis Yannakakis. On the Complexity of Database Queries. J.
on Computer and System Sciences (JCSS), 58(3):407–427, 1999.
Detlef Seese. Linear Time Computable Problems and First-Order Descriptions. Mathematical
Structures in Computer Science, 6(6):505–526, 1996.
Nicole Schweikardt, Luc Segouﬁn, and Alexandre Vigny. Enumeration for FO queries over nowhere
dense graphs. In Symp. on Principles of Database Systems (PODS), pages 151–163, 2018.
Luc Segouﬁn and Alexandre Vigny. Constant delay enumeration for FO queries over databases
with local bounded expansion. In Intl. Conf. on Database Theory, pages 20:1–20:16, 2017.

This work is licensed under the Creative Commons Attribution License. To view a copy of this
license, visit https://creativecommons.org/licenses/by/4.0/ or send a letter to Creative
Commons, 171 Second St, Suite 300, San Francisco, CA 94105, USA, or Eisenacher Strasse
2, 10777 Berlin, Germany

