A trichotomy for regular simple path queries on graphs
Guillaume Bagan, Angela Bonifati, Benoit Groz

To cite this version:

Guillaume Bagan, Angela Bonifati, Benoit Groz. A trichotomy for regular simple path queries on
graphs. Journal of Computer and System Sciences, 2020, 108, pp.29-48. ￿10.1016/j.jcss.2019.08.006￿.
￿hal-02435355￿

HAL Id: hal-02435355

https://inria.hal.science/hal-02435355

Submitted on 25 Sep 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution 4.0 International License

Journal of Computer and System Sciences 108 (2020) 29–48

Contents lists available at ScienceDirect

Journal  of  Computer  and  System  Sciences

www.elsevier.com/locate/jcss

A  trichotomy  for  regular  simple  path  queries  on  graphs ✩
Guillaume Bagan a,∗
a Université Lyon 1, LIRIS UMR CNRS 5205, F-69622, Lyon, France
b Université Paris Sud, LRI UMR CNRS 8623, F-91405, Orsay, France

,  Angela Bonifati a,  Benoit Groz b

a  r  t  i  c  l  e 

i  n  f  o

a  b  s  t  r  a  c  t

Article history:
Received 3 June 2018
Received in revised form 23 June 2019
Accepted 19 August 2019
Available online 20 September 2019

Keywords:
Graphs
Paths
Regular simple paths
Complexity
Regular languages
Automata

1.  Introduction

We  focus  on  the  computational  complexity  of  regular  simple  path  queries  (RSPQs).  We 
consider the following problem RSPQ(L) for a regular language  L: given an edge-labeled 
digraph G and two nodes x and  y, is there a simple path from x to  y that forms a word 
belonging  to  L? We  fully  characterize  the  frontier  between  tractability  and  intractability 
for RSPQ(L). More precisely, we prove RSPQ(L) is either AC0, NL-complete or NP-complete 
depending on the language  L. We also provide a simple characterization of the tractable 
fragment  in  terms  of  regular  expressions.  Finally,  we  also  discuss  the  complexity  of 
deciding  whether  a  language  L belongs  to  the  fragment  above.  We  consider  several 
alternative  representations  of  L:  DFAs,  NFAs  or  regular  expressions,  and  prove  that  this 
problem is NL-complete for the ﬁrst representation and PSpace-complete for the other two.
© 2019 Elsevier Inc. All rights reserved.

Graph  databases  have  been  investigated  starting  from  the  late  80s  and  are  now  again  in  vogue  due  to  their  wide  ap-
plication scenarios, ranging from social networks to biological and scientiﬁc databases (see [2] for a survey). Regular path 
queries  (RPQs)  are  one  of  the  most  notable  classes  of  queries  on  graph  databases.  They  allow  to  retrieve  pairs  of  nodes 
connected by a path, where the path is described through a regular expression. Such regular path queries are computable in 
time polynomial in both query and data complexity (combined complexity). In this paper, we investigate the computational 
complexity of regular simple path queries (RSPQs), a variant of RPQ in which the path connecting the pair has to be simple, 
i.e.,  does  not  have  repeated  vertices.  Given  an  edge-labeled  graph  G and  a  regular  language  L,  an  RSPQ  selects  pairs  of 
vertices connected by a simple path whose edge labels form a word in L.

The evaluation of RSPQs is NP-complete even for ﬁxed basic languages such as (aa)∗

[20], in sharp contrast with 
RPQs.  RSPQs  are  desirable  in  many  application  scenarios [17,23,6,15,13,30],  such  as  transportation  problems,  VLSI  design, 
metabolic networks, DNA matching and routing in wireless networks. Additionally, regular simple paths have been recently 
considered  in  SPARQL  1.1  queries  exhibiting  property  paths.  In  particular,  recent  studies  on  the  complexity  of  property 
paths  in  SPARQL [3,18] have  highlighted  the  hardness  of  the  semantics  proposed  by  W3C  to  evaluate  such  paths  in  RDF 
graphs.  Roughly  speaking,  according  to  the  semantics  considered  in [18],  the  evaluation  of  expressions  under  Kleene-star 
closure  should  return  a  simple  path,  whereas  the  evaluation  of  the  remaining  expressions  allows  to  traverse  the  same 
vertex multiple times. As such, the semantics studied in [18] is an hybrid between regular paths and regular simple paths 
semantics. RPQs have been recently found in practice within real-world SPARQL query logs, such as DBPedia and Wikidata 

or a

ba

∗

∗

✩

This article is an extended version of [5].

* Corresponding author.

E-mail addresses: guillaume.bagan@liris.cnrs.fr (G. Bagan), angela.bonifati@univ-lyon1.fr (A. Bonifati), benoit.groz@lri.fr (B. Groz).

https://doi.org/10.1016/j.jcss.2019.08.006
0022-0000/© 2019 Elsevier Inc. All rights reserved.

30

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

query logs [8,7,9], showing thus the increasing interest of users manipulating real-world graph datasets with these queries. 
In  particular,  the  majority  of  RPQs  analyzed in  large  corpuses [8,9] belong  to  the  tractable  fragment  Ctract studied  in  this 
paper, further conﬁrming the applicability and impact of our theoretical investigation.
Contributions. In this paper, we address the long standing open question [20,6] of exactly characterizing the maximal class 
of regular languages for which RSPQs are tractable. By “tractable” we mean computable in time polynomial in the size of 
the graph. Precisely, we establish a comprehensive classiﬁcation of the complexity of RSPQs for a ﬁxed regular language  L. 
A ﬁrst step towards this important issue has been made in [20]. They exhibit a tractable fragment: the class of languages 
closed under taking subword. However, their fragment is not maximal.

Our contributions can be detailed as follows. We introduce a class of languages, named Ctract , for which RSPQs can be 
evaluated  in  polynomial  time  (data  complexity),  and  even  in  NL. We  then  show  that  RSPQ  evaluation  is  NP-complete  for 
every regular language that does not belong to Ctract. Consequently, the maximal tractable fragment Ctract characterizes the 
frontier between tractability and intractability for this problem, under the hypothesis NL (cid:3)= NP. We further reﬁne our results 
to show the following trichotomy: the evaluation of RSPQ problem is either AC0, NL-complete or NP-complete. We note that 
we consider the language L as a ﬁxed parameter, thus our results characterize the data complexity of RSPQ evaluation.

We  also  discuss  the  complexity  of  deciding,  given  a  language  L,  whether  the  RSPQ  problem  for  L is  tractable.  We 
consider several alternative representations of L: DFAs, NFAs or regular expressions. We prove that this problem of deciding 
tractability is NL-complete for the ﬁrst representation and PSpace-complete for the two others.

Next, we give a characterization of the tractable fragment Ctract for edge-labeled graphs in terms of regular expressions. 
We  also  show  that  Ctract is  closed  by  union  and  intersection  and  show  that  languages  in  Ctract are  aperiodic,  i.e.,  can  be 
expressed by ﬁrst-order formulas [29].

We conclude with some minor results that identify further cases where RSPQs admit eﬃcient solutions. We thus prove 
that RSPQs are FPT for the class of ﬁnite languages. Furthermore, we prove that the problem is also FPT for the class of all 
regular languages when the parameter is the size of the path. Finally, we prove that the problem RSPQ is polynomial w.r.t. 
combined complexity on graphs of bounded directed treewidth. This is actually a straightforward generalization of a result 
of [14].

A  preliminary  version  of  the  present  article  has  appeared  in  [5] without  proofs  of  the  main  results.  Here  we  provide 

detailed proofs.
Related work. A few papers deal with RSPQs or are related to them. Lapaugh et al. [16] prove that ﬁnding simple paths of 
even length is polynomial for non directed graphs and NP-complete for directed graphs. This study has been extended in [4]
by considering paths of length i mod k. Similarly, ﬁnding k disjoint paths with extremities given as input is polynomial for 
non directed graphs [26] and  NP-complete for directed graphs [10]. Using these results, Mendelzon and Wood prove that 
evaluating an RSPQ on an edge-labeled directed graph is NP-hard even for ﬁxed languages [20]. However, they show that 
the problem can be decided in polynomial time for subword-closed languages. They also show that the problem becomes 
polynomial under some restrictions on the size of cycles of both graph and automaton. A subsequent paper [22] proves the 
polynomiality for the class of outerplanar graphs. Barrett et al. [6] extend this result, proving that the regular simple path 
problem  is  polynomial  w.r.t.  combined  complexity  for  graphs  of  bounded  treewidth.  Barrett  et  al. [6] also  show  that  the 
problem is NP-complete for the class of grid graphs even when the language is ﬁxed.

We already mentioned that the complexity of evaluating SPARQL property paths has been investigated in previous stud-
ies [18,3].  As  highlighted  above,  the  semantics  of  SPARQL  property  paths  blends  the  arbitrary  paths  and  simple  paths 
semantics.  Losemann  and  Martens [18] and  Arenas  et  al. [3] focus  on  the  complexity  of  evaluating  such  property  paths. 
They show that the evaluation is NP-complete in several cases, and exhibit cases in which it is polynomial. More precisely, 
Losemann and Martens [18] classify several fragments of property paths with respect to their complexity. Both the seman-
tics and the query fragments are different from the ones in our paper. Counting the number of paths that match a regular 
expression (which is permitted for instance in SPARQL 1.1) is hard in many cases [18,3]. Recently, Martens and Trautner [19]
studied the decision- and enumeration problems concerning the evaluation of RPQs by considering several semantics: ar-
bitrary paths, shortest paths, and simple paths. While we prove here a trichotomy for the data complexity of the decision 
problem, they focus on the data complexity of the polynomial delay enumeration problem.

Section 2 introduces  and  illustrates  the  problem.  We  then  establish  our  trichotomy.  We  ﬁrst  show  in  section 3 why 
languages  outside  our  tractable  fragment  have  NP-hard  complexity.  Section 4 discusses  some  properties  of  the  tractable 
fragment,  and  shows  how  those  properties  (about  strongly  connected  components)  lead  to  a  polynomial  evaluation  algo-
rithm. And ﬁnally, Section 5 details our algorithm to deal with the tractable languages.

2.  Preliminaries

Let [n] denote the set of integers {1, . . . , n} and [n, m] denote the set of integers {n, . . . , m}.

2.1.  Complexity

A  TM  refers  to  a  Turing  Machine  and  a  NDTM  refers  to  a  non  deterministic  Turing  Machine.  AC0, L, NL, P, NP, PSpace
refer  to  the  classical  classes  of  complexity  [24].  The  relations  AC0 ⊆ L ⊂ NL ⊆ P ⊆ NP ⊆ PSpace between  these  classes  are 
well known.

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

31

FL is  the  class  of  functions  computable  by  a  deterministic  log-space  transducer.  The  class  LNL
is  the  set  of  decision 
problems  computable  by  a  deterministic  log-space  algorithm  with  an  oracle  in  NL.  The  class  FLNL
is  the  set  of  functions 
computable by a deterministic log-space transducer with an oracle in NL. The class FLNL(NL) is the set of problems reducible 
to a problem in NL by a function in FLNL

.

Lemma 1. [24,11] NL = LNL = FLNL(NL).

NLNL

is the class of decision problems computable by a non deterministic log-space algorithm with an oracle in NL. The 
next lemma is true only if we make some restrictions on the oracle machine model (see [27]): the TM must write on the 
oracle tape deterministically i.e. it works deterministically as soon as it starts to write on the tape until it calls the oracle. 
The oracle tape is erased at the end of each call.

Lemma 2. [11] NL = NLNL

.

2.2.  Graphs

In our paper, we essentially consider db-graphs. A db-graph is a tuple G = (V , (cid:2), E) where  V is a set of vertices, (cid:2) is a 
set of labels and  E ⊆ V × (cid:2) × V is a set of edges labeled by symbols of (cid:2). Given a set  S ⊆ V , G[S] the induced subgraph 
of G by  S is (S, (cid:2), E ∩ S × (cid:2) × S). A path  p of a db-graph G from x to  y is a sequence (v 1 = x, a1, . . . , vm, am, vm+1 = y)
such that for each i ∈ [m + 1], v i is a vertex in G and for each i ∈ [m], (v i, ai, v i+1) is an edge in G. A path p is simple if all 
vertices v i in  p are distinct. Given a language L ⊆ (cid:2)∗
,  p is L-labeled if a1 . . . am ∈ L. Given a subset  S ⊆ V ,  p is  S-restricted 
if every intermediate vertex of  p belongs to  S. Given a simple path  p and two vertices  x and  y in  p,  p[x, y] denotes the 
subpath of  p from x to  y.

2.3.  Languages and automata

Let  L be  a  regular  language.  Given  a  word  w and  a  language  L,  w

(cid:8) ∈ L}.  We  denote  by  A L =
(Q L, i L, F L, (cid:3)L) the  minimal  DFA  for  L,  and  by  M L the  number  of  states  M L = |Q L| in  A L .  Whenever  the  language  is 
obvious from context, we drop the subscript and write  M instead of  M L . We assume that  A L is complete i.e. (cid:3)L is a total 
function, so that in general  A L may have a sink state. For any state q ∈ Q and word  w ∈ (cid:2)∗
, (cid:3)L(q, w) denotes the state 
obtained when reading  w from q. For any state q ∈ Q and set of words  S ⊆ (cid:2)∗
such 
(cid:8) = (cid:3)L(q, w). Finally, Lq denotes the set of all words accepted from q. For every state q we 
that there exists  w ∈ S with q
denote by Loop(q) the set of all non empty words that allow to loop on q: Loop(q) = {w ∈ (cid:2)+ | (cid:3)L(q, w) = q}. We say that 
(cid:8) ∈ (cid:3)L(q, (cid:2)∗). A (strongly connected) component of  A L is a maximal set of states 
a state q
that are pairwise reachable.

, (cid:3)L(q, S) denotes the set of states q

is reachable from a state q if q

−1 L = {w

(cid:8) : w w

The run of L (or  A L ) over a path p = (v 1, a1, . . . , am, vm+1) is the mapping ρ : {v 1, . . . , vm+1} → Q L such that: ρ(v 1) = i L
and ρ(v i+1) = (cid:3)L(i L, a1 . . . ai) for every i ∈ [m]. There are many characterizations of aperiodic languages [29]. A language L
is aperiodic if and only if it satisﬁes (cid:3)L(q, w M+1) = (cid:3)L(q, w M ) for every state q and word  w. Intuitively, that means that 
for any state q0 and a word  w, in the inﬁnite sequence (q0, q1, q2, . . .) with qi+1 = (cid:3)L(q, w) for any integer i, there is an 
integer M such that qM+1 = qM .

(cid:8)

(cid:8)

2.4.  Regular simple paths

Given a regular language L, we deﬁne the following problem:

RSPQ(L)
Input: A db-graph G = (V , (cid:2), E), and two vertices x, y ∈ V
Question: Is there a simple L-labeled path from x to  y?

For this problem,  L is ﬁxed, so we focus on data complexity. Notice that the representation of  L does not matter here. 
Although we consider the Boolean version of the problem, namely deciding the existence of a path, our algorithms actually 
also return a simple L-labeled path.

The  main  problem  that  we  address  in  this  paper  is  to  distinguish  cases  when  RSPQ(L) is  tractable  (i.e.  decidable  in 

polynomial time) and when it is not (i.e. NP-hard).

2.5.  The class of tractable languages

We recall that  M refers to the size of  Q L , here and henceforth. We next introduce the class Ctract of languages. We will 

prove that it is exactly the class of regular languages for which RSPQ(L) is tractable.

32

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

Deﬁnition 1. A  regular  language  L belongs  to  the  class  Ctract if  the  following  property  is  satisﬁed:  for  all  pairs  of  states 
q1, q2 ∈ Q L and all words w with Loop(q1) (cid:3)= ∅, Loop(q2) (cid:3)= ∅, q2 ∈ (cid:3)L(q1, (cid:2)∗) and w ∈ Loop(q2), it holds that w M Lq2
⊆ Lq1 .

This deﬁnition is merely a technical deﬁnition for Ctract , but we will provide in Theorem 6 a more intuitive characteriza-

tions of the class.

Example 1. As an introductory example, consider the language  L = a
. We observe that this language belongs 
to our class Ctract. We wish to decide RSPQ(L), i.e., whether there exists a simple path from x to  y labeled by  L, given two 
vertices x, y of a db-graph G. It is not absolutely trivial that RSPQ(L) can be solved eﬃciently: RSPQ(a
) has indeed been 
proved NP-complete. Yet we outline below a polynomial algorithm for L.

bc

∗

∗

∗(bb

+ + (cid:5))c

∗

We distinguish two cases: there is a simple L-labeled path from x to  y if and only if one of the following cases holds:

1: there exists a simple a
2: case 1 does not hold and there exists a simple a

-labeled path from x to  y for some k ∈ {0, 2, 3}
b4b

-labeled path from x to  y.

bkc

c

∗

∗

∗

∗

∗

∗

∗

∗

∗

c

c
c

The  ﬁrst  case  is  the  easiest  to  check.  We  ﬁrst  check  whether  y can  be  reached  from  x by  a  (non-necessarily  simple) 
∗
-labeled path by eliminating its loops. Assume now there is no 
-labeled path. If we ﬁnd one, we obtain a simple a
a
∗
-labeled path from x to  y for some 
-labeled path from x to  y. We then check as follows if there exists a simple a
a
k ∈ {2, 3}: we try every possible assignment for the k middle b-edges. For each combination of k b-edges, we check if the 
-labeled path (avoiding the vertices of the other b edges), and check if the 
initial b-edge can be reached from x through an a
ﬁnal b-edge can lead to  y through some c
-
∗
labeled path the a
path). Consequently 
-labeled path by eliminating its loops. As the number of possible assignments for k edges (k ≤ 3) 
we obtain a simple a
is polynomial, we have proved that we can ﬁnd out in polynomial time whether case 1 holds.

-labeled path (avoiding the vertices of the other b edges). In the resulting a

-labeled suﬃx cannot intersect (we assumed there is no a

-labeled preﬁx and c

Let us now assume w.l.o.g. that there is no a

-labeled path from  x to  y for k ∈ {0, 2, 3}. We can show that in this 
second case there exists a simple L-labeled path from x to  y if and only if there exist six vertices v 1, v 2, v 3, v 4, v 5, v 6, two 
integers la, lb and two sets  Sa,  Sb satisfying all following conditions:

bkc

bkc

bkc

bkc

c

∗

∗

∗

∗

∗

∗

∗

∗

∗

∗

∗

∗

∗

• the vertices v 1, . . . , v 6 are all distinct except that v 3 may equal v 4.
• there is a b-labeled edge from v 1 to v 2, from v 2 to v 3, from v 4 to v 5, and from v 5 to v 6.
• there is an a
• Sa is the set of all vertices reachable from x through an a
• there is a b

-labeled path of length at most la that avoids all v i s (i > 1).
-labeled path from v 3 to v 4 of which all vertices (but the ﬁrst and last) avoid  Sa and the v i s. The shortest 

-labeled path from x to v 1 avoiding all other v i s (i > 1). The shortest possible such path has length la .

∗

∗

∗

• Sb is the set of all vertices reachable from  v 3 through any b

∗

-labeled path of length at most lb that avoids  Sa and all 

possible such path has length lb .

other v i s (i (cid:3)= 4).

• there is a c

∗

-labeled path from v 6 to  y of which all vertices (but the ﬁrst) avoid  Sa and  Sb and all other v i s (i < 6).

The ﬁgure below summarizes all these conditions.

These conditions can clearly be veriﬁed in time polynomial in G. It is relatively clear also that the path constructed above 
is an  L-labeled simple path from x to  y, so the conditions are suﬃcient to obtain an  L-labeled simple path. To prove that 
our procedure is correct, we only have to prove that reciprocally, if there exists a simple  L-labeled path we can ﬁnd one 
satisfying our restrictions (the conditions above involving the v i ,  Sa,  Sb).

For every shortest  L-labeled simple path  p from x to  y, let  v 1, . . . , v 6 denote the vertices that delimit the ﬁrst and last 
two b-edges of  p. We next show that those vertices satisfy the conditions above. The last vertex of  p that belongs to  Sa
cannot occur after v 3 in  p. Otherwise, we could obtain a simple path  p
by replacing the preﬁx of  p up to v with a shorter 
would still be  L-labeled by deﬁnition of the  v i , which contradicts the minimality 
path through  Sa. This resulting path  p
of  p. A similar argument shows that the last occurrence of a vertex from  Sb cannot occur after  v 6. We conclude that the 
paths connecting  v 3 to  v 4 in  p (resp. v 6 to  y) exclude respectively all vertices from  Sa (resp. Sa ∪ Sb). As a consequence, 
the path from  x to  v 1 will only feature vertices from  Sa by minimality of  p, which proves that vertices  v 1, . . . , v 6 satisfy 
the conditions above.

(cid:8)

(cid:8)

The  crux  of  our  approach  is  to  construct  the  a

subpaths  independently,  lest  we  enumerate  exponentially 
many paths. This is why we require that the b
subpath avoids  Sa: this condition is stronger than necessary to guarantee 
the ﬁrst two subpaths do not intersect, but the stronger requirement allows us to build the two subpaths independently, as 
Sa is a superset of the vertices on the subpath from x to v 1. Our algorithm for tractable instances will generalize this idea.

and  c

,  b

∗

∗

∗

∗

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

33

3.  Hard languages for RSPQ

This section is devoted to the proof of a hardness result: RSPQ(L) is NP-hard for every regular language L that does not 

belong to Ctract. The ﬁrst step toward that proof lies in the following characterization of Ctract .

Deﬁnition 2 (Witness of hardness). Let  L be  a  regular  language.  A  witness for hardness of  L is  a  tuple  (wl, wm, wr, w 1, w 2)
where  wl, wr ∈ (cid:2)∗

and  wm, w 1, w 2 ∈ (cid:2)+

satisfying

∗
• wl w
1 wm w
• wl(w 1 + w 2)∗

∗
2 wr ⊆ L

wr ∩ L = ∅.

Lemma 3. Let L be a regular language that does not belong to Ctract. Then, L admits a witness for hardness.

Proof. Let  L be  a  regular  language  that  does  not  belong  to  Ctract.  For  commodity,  we  distinguish  two  cases,  depending 
⊆ Lq1 for  every  q1, q2 ∈ Q L such  that  q2 ∈ (cid:3)L(q1, (cid:2)∗) and 
on  whether  L satisﬁes  or  not  the  following  property:  Lq2
Loop(q1) ∩ Loop(q2) (cid:3)= ∅ (Property P ).

Let L be a language that does not satisfy Property P , there exist q, q2, wm, w, wr such that (cid:3)L(q, wm) = q2, w ∈ Loop(q) ∩

Loop(q2), and  wr ∈ Lq2

\ Lq. Let  wl such that (cid:3)(i L, wl) = q. Then  wl, wm, wr, w 1 = w 2 = w is a witness for hardness.

(cid:8)

(cid:8)

(cid:8)

(cid:8)(cid:8)

(cid:8)(cid:8)

and q

We next plan to exhibit a witness for hardness for the case where  L satisﬁes Property P , but we ﬁrst prove that every 
language  satisfying  property P (whether  in  Ctract or  not)  is  aperiodic.  Let  L be  a  language  satisfying  Property P ,  q ∈ Q L
and  w a word in (cid:2)+
(cid:8), w). We want to prove 
(cid:8) = (cid:3)L(q, w M ). We denote by q
(cid:8) = q
(cid:8)(cid:8)
. By the pigeonhole principle there exists some k0 < k1 ≤ M such that (cid:3)L(q, wk0 ) = (cid:3)L(q, wk1 ). We then have 
that q
(cid:8), wk) = q
for k = k1 − k0. Then q
by 
(cid:3)L(q
minimality. Consequently, L is aperiodic.

both loop on  wk, so that Lq(cid:8) = Lq(cid:8)(cid:8) by deﬁnition of P , hence q

denote the state q

the state (cid:3)L(q

. Let also q

1) = q

Let  L be  a  language  that  satisﬁes  Property P (and  so  in  particular  is  aperiodic),  but  that  does  not  belong  to  Ctract . 
(cid:8)
r such  that  (cid:3)(i L, wl) = q,  w 1 ∈ Loop(q),  w 2 ∈
(cid:8)
(cid:8)
1)M for  some  word  w
1.  We 
w 1),  there  exists  some k > 0 such 
(cid:8)) and  therefore 

By  deﬁnition  of  Ctract there  exist  states  q, q2 and  words  wl, w 1, w 2, wm, w
∈ Lq2 and  w M
Loop(q2),  (cid:3)L(q, wm) = q2,  w
(cid:8)
then  claim  that  Lq(cid:8) ⊆ Lq for  every q
(cid:8)
that  (cid:3)L(q
,  hence  q
Lq(cid:8) ⊆ Lq due to Property P .

loops  over  w 1 by  aperiodicity  of  L.  We  thus  have  w 1 ∈ Loop(q) ∩ Loop(q

(cid:8)
r /∈ Lq.  W.l.o.g.  we  can  suppose  that  w 1 = (w

w 1).  Indeed,  for  every q

2 w
in  (cid:3)L(q, (cid:2)∗

(cid:8)
r . By deﬁnition,  wm w

wr ∩ Lq = ∅, because 
any  word  in  (w 1 + w 2)∗
wr .  We  recall  that 
(cid:8) = (cid:3)L(q, u) satisﬁes Lq(cid:8) ⊆ Lq. 
(cid:8)
r /∈ Lq and L is aperiodic, so that v /∈ Lq. Furthermore, we have just proved that q
wr = w M
Consequently,  v /∈ Lq(cid:8) and  uv /∈ Lq. Thus,  wl,  wm,  wr ,  w 1, and  w 2 provide a witness for hardness, which concludes the 
proof of Lemma 3. (cid:2)

2 wr ⊆ Lq because  wr ∈ Lq2 . We now prove that (w 1 + w 2)∗

wr can  be  decomposed  into  uv with  u ∈ (cid:5) + (w 1 + w 2)∗

w 1 and  v ∈ (w 2)∗

(cid:8) ∈ (cid:3)L(q, (cid:2)∗

Let  wr = w M

(cid:8) = q

(cid:8), wk

2 w

2 w

(cid:8)
r

(cid:8)(cid:8)

∗

(cid:8)

We  can  now  prove  our  hardness  result,  by  reduction  from  Vertex-Disjoint-Path,  a  problem  also  used  in [20] to  prove 

hardness in the particular case of a

∗

∗

.

ba

Vertex-Disjoint-Path
Input: A directed graph G = (V , E), four vertices x1, y1, x2, y2 ∈ V
Question: Are there two disjoint paths, one from x1 to  y1 and the other from x2 to  y2?

Lemma 4. Let L be a regular language that does not belong to Ctract. Then, RSPQ(L) is NP-hard.

(cid:8)

Proof. Let  L /∈ Ctract. We exhibit a reduction from the Vertex-Disjoint-Path problem to  RSPQ(L). According to Lemma 3,  L
∗
admits a witness for hardness  wl, wm, wr, w 1, w 2. By deﬁnition we get  wl(w 1 + w 2)∗
2 wr ⊆ L.
whose edges are labeled by non empty words. This is actually a generalization of db-
graphs.  Nevertheless,  by  adding  intermediate  vertices,  an  edge  labeled  by  a  word  w can  be  replaced  with  a  path  whose 
edges form the word  w.

We build from  G a db-graph  G

wr ∩ L = ∅ and  wl w

∗
1 wm w

(cid:8)

G

is constructed as follows. The vertices of G

Assume  there  is  a  simple  L-labeled  path  p from  x to  y in  G

are the same as the vertices of G. For each edge (v 1, v 2) in G, we add two 
edges (v 1, w 1, v 2) and (v 1, w 2, v 2). Moreover, we add two new vertices  x, y and three edges (x, wl, x1), ( y1, wm, x2) and 
(cid:8), x, y) iff Vertex-Disjoint-Path returns True for (G, x1, y1, x2, y2).
( y2, wr, y). We next prove that RSPQ(L) returns True for (G
,  this  path  necessarily  goes  through 
the  edge  ( y1, wm, x2) since  wl(w 1 + w 2)∗
wr ∩ L = ∅.  Since  p is  simple,  the  subpaths  from  x1 to  y1 and  x2 to  y2 are 
disjoint, hence Vertex-Disjoint-Path returns True for (G, x1, y1, x2, y2). Reciprocally, if Vertex-Disjoint-Path returns True for 
(G, x1, y1, x2, y2), there exist disjoint paths from x1 to  y1 and from x2 to  y2. By deﬁnition these two paths match a word 
∗
in  (w 1 + w 2)∗
1 and  one  from 
.  We  can  then  obtain  two  disjoint  simple  paths,  one  from  x1 to  y1 matching  a  word  in  w
∗
2. To obtain those paths we keep the vertices as the original paths, eliminate the loops if 
x2 to  y2 matching a word in  w

.  By  deﬁnition  of  G

(cid:8)

(cid:8)

(cid:8)

34

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

Fig. 1. Reduction for L = a

∗

b(cc)∗

d.

there are any, and switch  w 1 and  w 2 edges where needed: we can always replace a  w 1 edge with a  w 2 by construction 
of  G since every pair of vertices is connected by both types of edges or none. Concatenating the edge (x, wl, x1) with the 
ﬁrst path, the edge ( y1, wm, x2), the second path and the edge ( y2, wr, y) provides a simple L-labeled path  p from x to  y, 
which concludes our proof. We illustrate in Fig. 1 the reduction for L = a
d, on an instance (G, x1, y1, x2, y2), choosing 
wl = w 1 = a,  wm = b,  w 2 = cc, and  wr = d. (cid:2)

b(cc)∗

∗

This  concludes  our  proof  that  languages  outside  Ctract are  intractable.  After  this  negative  result,  we  now  focus  on  the 

positive result, namely that languages in Ctract admit eﬃcient algorithms.

4.  Properties of languages in Ctract

The  main  result  of  this  paper  is  that  for  every  L ∈ Ctract,  RSPQ(L) ∈ NL.  The  algorithm  to  evaluate  eﬃciently  RSPQ(L)
exploits a particular kind of pumping argument between strongly connected components of the automaton. This pumping 
argument  proves  that  if  we  build  carefully  a  path  using  the  usual  reachability  algorithm  inside  the  strongly  connected 
components, then we need not care about possible intersections between subpaths corresponding to different components. 
In this section, we introduce and prove this pumping argument in Lemma 11 through a serie of technical lemmas about the 
structure of automata that recognize Ctract languages.

4.1.  Alternative characterization of Ctract

To begin with, we prove that every language from Ctract is aperiodic and deduce an alternative characterization of Ctract .

Lemma 5. Let L be a regular language in Ctract. Then L is aperiodic.

Proof. In the proof of Lemma 3 we deﬁned a property P and showed that languages satisfying property P are aperiodic. We 
show that every  L ∈ Ctract satisﬁes property P . Let  L ∈ Ctract, q1, q2 ∈ Q L and  w satisfy q2 ∈ (cid:3)L(q1, (cid:2)∗) and  w ∈ Loop(q1) ∩
Loop(q2). By deﬁnition of Ctract,  w M Lq2

⊆ Lq1 because  w ∈ Loop(q1). (cid:2)

⊆ Lq1 , hence Lq2

We  then  exploit  this  aperiodicity  property  to  establish  the  following  characterization  of  Ctract,  which  strengthens  the 

requirements from Deﬁnition 1 on the loops of  A L .

Lemma 6. Let  L be a regular language. Then,  L belongs to Ctract iff for every pair of states q1, q2 ∈ Q L such that Loop(q1) (cid:3)= ∅, 
Loop(q2) (cid:3)= ∅ and q2 ∈ (cid:3)L(q1, (cid:2)∗), the following statement holds: (Loop(q2))M Lq2

⊆ Lq1 .

(cid:8)
2

∈ Q L satisfy  Loop(q

Proof. The  (if)  implication  is  immediate  by  Deﬁnition 1.  Let  us  now  prove  the  (only  if)  implication.  Assume  L ∈ Ctract. 
(cid:8)
(cid:8)
(cid:8)
(cid:8)
(cid:8)
2) (cid:3)= ∅,  q
1) (cid:3)= ∅,  Loop(q
Let  q
2).  Let  also  q3 denote  the  state 
1, q
(cid:8)
(cid:8)
⊆ Lq3 . The crux of the proof is to choose carefully q
⊆ L
1, w M ). Then Deﬁnition 1 implies  w M L
(cid:3)L(q
q
2
and  w to exploit the constraints on Lq3 .

1, (cid:2)∗),  and  let  w ∈ Loop(q

Let  q1, q2 be  two  states  such  that  Loop(q1) (cid:3)= ∅,  Loop(q2) (cid:3)= ∅ and  q2 ∈ (cid:3)L(q1, (cid:2)∗).  Let  (v 1, . . . , v M ) be  a  sequence  of 

(cid:8)
∈ (cid:3)L(q
2
. Thus, L
q

(cid:8)
1, q

(cid:8)
2

(cid:8)
2

(cid:8)
1

q

words in (Loop(q2))M and q3 = (cid:3)L(q1, v 1 . . . v M ). We wish to prove Lq2

⊆ Lq3 .

For some  i, j,  0 ≤ i < j ≤ M, we get (cid:3)L(q1, v 1 . . . v i) = (cid:3)L(q1, v 1 . . . v j), using the convention (cid:3)L(q1, v 1 . . . v i) = q1 for 
⊆ Lq4 . The result then 
Lq4
2 and  q5 = (cid:3)L(q1, w M ).  As  (cid:3)L(q1, w M ) =
⊆ Lq5 through  Deﬁnition 1 with  q1, q2 and  w.  Furthermore,  u2 belongs  to  Loop(q5)
⊆ Lq4 , by Deﬁnition 1 with q5, q4 and u2, and because 

i = 0. Let u1 = v 1 . . . v i , u2 = v i+1 . . . v j and u3 = v j+1 . . . v M . Let q4 = (cid:3)L(q1, u1). We claim that Lq2
−1
follows  from  Lq2
3
q5 and  w ∈ Loop(q2),  we  get  Lq2
because L is aperiodic. To conclude the proof, we observe that Lq5
(cid:3)L(q4, u M

= Lq3 .  To  prove  the  claim,  let  w = u1u M

2 ) = q4 and u2 ∈ Loop(q5).1 (cid:2)

Lq2

⊆ u

= u

−1
3

1 This last application of Deﬁnition 1 corresponds actually to observing that every language in Ctract satisﬁes property P from Lemma 3.

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

35

4.2.  Technical lemmas on the components of A L

In  this  section,  we  show  properties  about  the  components  of  Ctract languages.  Notice  that  states  in  a  component  are 
mutually  reachable,  but  not  reachable  from  states  in  other  components  that  they  can  reach  themselves.  From  now  on, 
and  until  the  end  of  the  section,  we  ﬁx  a  language  L ∈ Ctract.  We  introduce  in  Lemmas 9 and  11 the  pumping  argument 
that we exploit in the algorithm to compute a simple path. In the other lemmas we prove auxiliary results, based on the 
decomposition of the automaton in strongly connected components. We prove that components of languages in Ctract are 
very particular, in the sense that every word staying long enough in the component is synchronizing. A preliminary lemma 
shows that two distinct states q1 and q2 in the same component cannot loop on the same word.

Lemma 7. Let q1 and q2 be two states belonging to the same component of A L. If Loop(q1) ∩ Loop(q2) (cid:3)= ∅, then q1 = q2.

Proof. Let q1, q2 as above, and let  w a word in Loop(q1) ∩ Loop(q2). According to Deﬁnition 1,  w M Lq2
Lq1 since  w ∈ Loop(q1). By symmetry, Lq2

= Lq1 , which implies q2 = q1. (cid:2)

⊆ Lq1 , hence Lq2

⊆

The next two lemmas characterize the internal language of a component.

Lemma 8. Let C be a component of A L , q1, q2 ∈ C and a ∈ (cid:2). Then (cid:3)L(q1, a) ∈ C iff (cid:3)L(q2, a) ∈ C .

Proof. Let  q1 (cid:3)= q2 two  states  in  the  same  component  C .  Let  a satisfy  (cid:3)L(q1, a) ∈ C .  Let  also  w ∈ Loop(q1) ∩ a(cid:2)∗
and 
q3 = (cid:3)L(q2, w M ): a and  w necessarily exist because  C is the strongly connected component of q1 and q2. We next prove 
that q3 belongs to C : by our deﬁnition of C , this implies (cid:3)L (q2, a) ∈ C . As  L is aperiodic,  w ∈ Loop(q3), and consequently, 
w M Lq3
=
Lq3 . Thus, Lq1

= Lq3 and, by minimality of  A L , q1 = q3, so that q3 ∈ C . (cid:2)

⊆ Lq1 by Deﬁnition 1. Furthermore, w M Lq1

⊆ Lq2 also by Deﬁnition 1. Hence Lq3

⊆ (w M )−1Lq2

⊆ Lq1 and Lq1

Notation 1. We denote the internal alphabet of a component C of  A L by (cid:2)C = {a ∈ (cid:2) : ∃q1, q2 ∈ C.(cid:3)L(q1, a) = q2}.

As a direct consequence of Lemma 8 we get:

Lemma 9. Let C be a component of A L , q ∈ C and w ∈ (cid:2)∗

. Then (cid:3)L(q, w) ∈ C iff w ∈ ((cid:2)C )∗

.

Finally, we prove that inside a component, every word with length at least  M2 is synchronizing. This result is the core 

of our pumping argument between strongly connected components as exposed in Lemma 11.

Lemma 10. Let  C be a component of  A L , (cid:2)C be the internal alphabet of  C , q1, q2 be two states of  C and  w ∈ ((cid:2)C )M2
(cid:3)L(q1, w) = (cid:3)L(q2, w).

. Then, 

Proof. Assume  that  w = a1 . . . aM2 .  For  each  i from  0 to  M2 and  α = 1, 2,  let  qα,i =  (cid:3)L(qα, a1 . . . ai).  Since  there  are  at 
most  M2 distinct pairs (q1,i, q2,i), there exist i, j, with i < j such that q1,i = q1, j and q2,i = q2, j . By Lemma 9, q1,i, q2,i ∈ C . 
(cid:8) ∈ Loop(q1,i) ∩ Loop(q2,i),  hence  q1,i = q2,i by  Lemma 7.  As  a  consequence,  (cid:3)L(q1, w) =
Let  w
(cid:3)L(q2, w). (cid:2)

(cid:8) = ai+1 . . . a j .  We  have  w

Notice that the above lemma still holds for  w ∈ ((cid:2)C )M2

(cid:2)∗

C . Here and thereafter, we ﬁx the constant N = 2M2.

Lemma 11. Let q1, q2 be two states such that Loop(q1) (cid:3)= ∅, Loop(q2) (cid:3)= ∅, and q2 ∈ (cid:3)L(q1, (cid:2)∗). Let C be the component that contains 
q2 and (cid:2)C be the internal alphabet of C . Then, Lq2

∩ ((cid:2)C )N (cid:2)∗ ⊆ Lq1 .

∩ ((cid:2)C )N (cid:2)∗

Proof. Let  w ∈ Lq2
.  By  Lemma 9 and 
the  Pigeonhole  Principle,  there  exist  a  state  q3 ∈ C and  M + 1 non-empty  words  v 1, . . . , v M+1 such  that  v = v 1 . . . v M+1
and  (cid:3)L(q2, uv 1 . . . v i) = q3 for  every  i ∈ [M].  Therefore,  w ∈ uv 1(Loop(q3))M−1 v M+1 w
.  By  Lemma 10,  (cid:3)L(q3, uv 1) =
(cid:3)L(q2, uv 1) = q3. Thus,  w belongs to both (Loop(q3))M v M+1 w

.  There  are  some  words  u, v ∈ ((cid:2)C )M2

and Lq3 . By Lemma 6,  w ∈ Lq1 . (cid:2)

such  that  w = uv w

(cid:8) ∈ (cid:2)∗

,  w

(cid:8)

(cid:8)

(cid:8)

Or main result focuses on data complexity and therefore assumes the language (hence N) is constant. Yet the complexity 

will be exponential in N therefore we next prove, for the sake of eﬃciency, that we can take N = M in Lemma 11.

Lemma 12. Let q1, q2 be two states such that Loop(q1) (cid:3)= ∅, Loop(q2) (cid:3)= ∅, and q2 ∈ (cid:3)L(q1, (cid:2)∗). Let C be the component that contains 
q2 and (cid:2)C be the internal alphabet of C . Then, Lq2

∩ ((cid:2)C )M (cid:2)∗ ⊆ Lq1 .

36

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

(cid:8)

Proof. Lemma 10 shows  that  all  words  of  length  at  least  M2 are  synchronizing  inside  a  component.  A  straightforward 
partition-reﬁnement argument [25] shows that for every k, k
are synchronizing, 
then words of length k are already synchronizing. This shows that words of length |C| are synchronizing inside a component 
of  A L , hence it is enough to assume  w ∈ ((cid:2)C )|C|

and every k-states DFA, if words of length k

With  the  assumptions  of  Lemma 11,  let  w = uv ∈ Lq2 such  that  u ∈ ((cid:2)C )M .  As  u synchronizes  C ,  (cid:3)(q2, u M+1 v) =
(cid:3)(q2, uv) ∈ F . If (cid:3)(q1, u) ∈ C then (cid:3)(q1, u M+1 v) ∈ F since L ∈ Ctract. Furthermore, (cid:3)(q1, uv) = (cid:3)(q1, u M+1 v) as u synchro-
nizes C . As a consequence, (cid:3)(q1, uv) ∈ F .

in Lemma 10.

Otherwise  the  automaton  avoids  C while  reading  u from  q1 and  as  a  consequence  there  exist  C

isfying  the  following  4 conditions:  u = u1u2u3,  (cid:3)(q, u1) ∈ C
(cid:3)(q2, uv) ∈ F because  u3 synchronizes  C .  By  Lemma 11,  this  implies  (cid:3)(q1, u1u N
(cid:3)(q1, uv) = (cid:3)(q1, u1u N

2 u3 v) and therefore belongs to  F . In both cases,  w ∈ Lq1 , which concludes our proof. (cid:2)

,  u2 ∈ ((cid:2)C (cid:8) )|C

and  |u3| ≥ |C|.  Then  (cid:3)(q2, u1u N

(cid:8), u1, u2, u3 sat-
2 u3 v) =
(cid:8)
2 u3 v) ∈ F .  As  u2 synchronizes  C
, 

(cid:8)|

(cid:8)

(cid:8)

5.  Computing RSPQ(L) for L in Ctract

In this section, we describe a polynomial algorithm that computes RSPQ(L) when L belongs to Ctract. A (non-necessarily 
simple)  L-labeled path between two points could be computed incrementally using dynamic programming: we only need 
to record the last vertex in the (partial) path together with the corresponding state. But this approach is not adequate to 
build a simple path, as we need to memorize all the vertices in the path to check the absence of loops. The approach may 
thus lead to consider an exponential number of paths.

Nevertheless, we will show that in the case where L belongs to Ctract, we can identify a constant number of vertices that 
suﬃce to check if the path is (or can be transformed into) a simple path labeled with L. Section 5.1 deﬁnes path summaries 
that record these “critical” vertices, while Section 5.2 explains how we can restore any shortest simple L-labeled path from 
its summary. Finally, Section 5 presents our algorithm for RSPQ, which enumerates all candidate summaries in logarithmic 
space, until it ﬁnds a candidate summary from which it can restore a simple L-labeled path.

5.1.  Deﬁning summaries

Roughly speaking, the idea of a summary is to keep only a bounded number of vertices of  p, that depends only on  L. 
Notice that in a run of  A L over  p, states of the same component appear consecutively. Indeed, if one leaves a component 
of  A L , one cannot re-enter it later. Inspired by Lemma 12, we will only record the ﬁrst and the M last vertices having their 
state  in  C ,  for  each  component  C of  A L .  When  the  number  of  such  vertices  is  greater  than  M + 1,  we  replace  the  path 
between the ﬁrst vertex and the  M last ones by a cut symbol  cutC . This symbol intuitively represents a (cid:2)∗
C -labeled path 
that has been cut from the path. More formally, a summary is deﬁned as follows.

Deﬁnition 3 (Long run components). Let  p = (v 1, a1, . . . , am, vm+1) be a path and let ρ be the run of  L over  p. A long run 
component of  p is a component C of  A L such that there are at least  M + 2 vertices  v in  p such that ρ(v) ∈ C . We denote 
by  C1, . . . , Cl the long run components of  p (the sequence is sorted by order of appearance in  p). For each integer i ∈ [l], 
(cid:2)Ci is the internal alphabet of Ci , lefti is the ﬁrst vertex  v j of  p such that ρ(v j) ∈ Ci and righti is the last vertex  v j of  p
such that ρ(v j), . . . , ρ(v j+M ) ∈ Ci .

Deﬁnition 4 (Cut symbols and summary). We introduce a new “cut” symbol cutC for each component C of  A L . The set of all 
cut symbols is denoted by Cuts. Let  p = (v 1, a1, . . . , am, vm+1), ρ a run over  p, and (Ci, (cid:2)Ci , lefti, righti)i∈[l] be as stated in 
Deﬁnition 3.  The  summary  S of  the  path  p (w.r.t.  A L )  is  the  sequence  obtained  from  p by  replacing,  for  each  i ∈ [l] the 
subpath  p[lefti, righti

] by the sequence (lefti, cutCi , righti).

Example 2 depicts a path together with its summary.

Example 2. Fig. 2a represents the minimal DFA for L = a(c
(we did not represent the sink state). This 
automaton can loop in three strongly connected components:  C1 = {q4},  C2 = {q5, q6}, and  C3 = {q7}. The accepting states 
are  q2,  q4,  q5,  q6,  and  q7.  For  this  automaton,  we  observe  that  Lemma 12 still  holds  after  replacing  exponent  M with  2. 
Consequently,  we  shall  pretend  that  M = 2 when  deﬁning  the  long  run  components  and  summary  in  our  example.  This 
means  we  only  store  the  ﬁrst  and  last  3 (instead  of  8)  vertices  of  each  component,  which  will  simplify  our  illustrative 
example.

≥2 + (cid:5))(a + b)∗(ac)?a

∗

Let us consider the path  p1 illustrated in Fig. 2b with thick edges. Fig. 2c details the run over this path.
We observe that  p1 is a simple L-labeled path. The summary  S of  p1 is obtained by removing the second (resp. second 
and third) vertex with state in  C1 (resp.  C2). The vertices on a white background in Fig. 2c are thus eliminated from the 
summary and replaced with their respective cut symbol cutC1 and cutC2 :

S =(v 1, a, v 2, c, v 3, c, v 4, cutC1 , v 7, c, v 8, c, v 9,

a, v 10, cutC2 , v 13, a, v 14, a, v 15 ).

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

37

Fig. 2. Components, summaries and safe completions.

We also observe that in a summary, all cut symbols are clearly distinct by deﬁnition of strongly connected components. 
A summary therefore contains at most M(M + 2) = O (M2) elements (vertices, labels and cut symbols), which is constant if 
L is ﬁxed. As a consequence, each summary can be represented with a logarithmic number of bits.

We  next  deﬁne  a  candidate  summary  as  an  alternative  sequence  of  vertices  and  symbols  or  cut  symbols  of  the  form 

above.

Deﬁnition 5 (Candidate summary). We  deﬁne  as  a  candidate  summary  S any  sequence  of  vertices  and  labels  of  the  form 
above;  S = (v 1, α1, . . . , αm, vm+1) where αi ∈ (cid:2) ∪ Cuts for every i ∈ [m], all cut symbols are distinct, and m ≤ M. Similarly 
to Deﬁnition 3, we denote by cutC1 , . . . , cutCl the sequence of cut symbols appearing in  S. Furthermore we deﬁne, for each 
i ∈ [l], lefti (resp. righti ) as the vertex at left (resp. right) of cutCi in  p.

Every summary is clearly a candidate summary but a candidate summary needs not be the summary of any  L-labeled 

path, let alone a simple one.

Deﬁnition 6. A path  p obtained by replacing each subsequence (lefti, cutCi , righti) with a simple (cid:2)∗
Ci
to righti is called a completion of the candidate summary  S.

-labeled path from lefti

By deﬁnition, completion and summary are inverse operations in the following sense:

Lemma 13. Let S be the summary of an L-labeled path p and let p

(cid:8)

be a completion of S. Then, p

(cid:8)

is an L-labeled path with summary S.

38

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

For each candidate summary  S that happens to be a summary, we could compute in NL a completion of  S. For instance, 
this  can  be  done  by  repeatedly  using  a  reachability  oracle.  By  deﬁnition,  this  completion  p is  an  L-labeled  path  from  a 
summary  S. However, the path  p is not necessarily simple, even if  S is the summary of a simple path. The reason is that 
the paths (pi)i∈[l] we have built between each lefti and righti are not necessarily disjoint.

5.2.  Safe completions

The  completion  of  a  summary  needs  not  be  a  simple  path.  We  therefore  deﬁne  in  this  section  safe completions  such 
that  safe  completions  are  always  simple  L-labeled  paths,  and  reciprocally  every  shortest  simple  L-labeled  paths  is  a  safe 
completion of its summary.

For that purpose, we will deﬁne local domains Set1, . . . , Setl which are disjoint sets of vertices from  G. For each  i ∈ [l], 
the  safe  completions  require  the  path  pi between  lefti and  righti to  be  Seti -restricted.  Consequently,  these  paths  will  be 
disjoint. To guarantee that reciprocally we can ﬁnd a safe completion for the summary of a shortest simple L-labeled path, 
we deﬁne Seti to the set of vertices that might occur on a shortest (cid:2)∗
-labeled path from lefti to righti that avoids all Set j
Ci
( j < i):

Deﬁnition 7 (Local domains). Let  S be a candidate summary. We denote by (Ci, lefti, righti)i∈[l] its components as stated in 
Deﬁnition 5, and denote by  V (S) the set of vertices appearing in  S. We deﬁne the local domains Seti recursively for each 
i from  1 to  l.  The  set  Seti
j<i Set j),  as  follows.  If  there  is  no  V i -restricted 
(cid:2)∗
-labeled  simple  path  p from  lefti to  righti ,  then  Seti = ∅.  Otherwise,  we  denote  by ki the  length  of  the  shortest  such 
Ci
path and deﬁne Seti as the set of vertices  y in  V i that can be reached from lefti by a  V i -restricted (cid:2)∗
-labeled path  p of 
Ci
length at most ki − 1.

is  deﬁned  as  a  subset  of  V i = V \ (V (S) ∪

(cid:2)

The following lemma is a direct consequence of Deﬁnition 7.

Lemma 14. Let S be a candidate summary. Then all sets V (S), (Seti)i∈[l] from Deﬁnition 7 are disjoint.

Deﬁnition 8 (Safe completion). Let  p be a path with label in L and summary  S. We qualify  p as safe completion of summary 
S if the following two conditions are satisﬁed: (a) all vertices appearing in  S are distinct and (b) for every i ∈ [l], the path 
p[lefti, righti

] is simple and Seti -restricted.

By the deﬁnition and Lemma 14, a safe completion is necessarily simple.

Lemma 15. Let S be a candidate summary. Every safe completion of S is a simple L-labeled path.

Example 3. The path  p1 deﬁned in Example 2 is a safe completion, since Set1 = {v 5, v 6} and Set2 = {v 11, v 12}, as illustrated 
in  Fig.  2b.  The  deﬁnition  of  safe  completions  guarantees  the  paths  replacing  cutC1 and  cutC2 are  disjoint.  Indeed  we  can 
check that {v 5} ∩ {v 11, v 12} = ∅.

Being a safe completion is clearly more restrictive than being a simple path. However, it turns out that shortest simple 
paths are safe completions, as shown below. That means that the existence of a simple path is equivalent to the existence 
of a safe completion.

Lemma 16. Let (G, x, y) be a RSPQ(L) instance. Every shortest simple L-labeled path from x to y is a safe completion of its summary.

Proof. Let  p = (v 1, a1, . . . , am, vm+1) be a shortest simple L-labeled path from x to  y. Assume that  p is not a safe comple-
such that  v /∈ Seti0 . Equivalently, if  p is not a safe 
tion. That means there is some i0 and vertex  v between lefti0
completion, then there exists some i and some vertex  v on the path that satisfy one of the following two properties P1(i)
or  P2(i): (1)  v satisﬁes  P1(i) if  there  is  j > i such  that  v is  visited  between  left j and  right j ,  and  v ∈ Seti (2)  v satisﬁes 
P2(i) if no vertex  v
satisﬁes  P 1(i),  v is visited between lefti and  righti , and  v /∈ Seti . Intuitively, case (2) covers the case 
where the path between lefti and righti stays within V i but fails to stay within Seti .

and righti0

(cid:8)

We choose a minimal such i. For each of the two cases, we will construct a path p

shorter than p from x to  y. We then 

(cid:8)

(cid:8)

prove that  p

is an L-labeled simple path, which contradicts our assumption that  p is the shortest such path.

Case  (1): let  v be  a  vertex  satisfying  property  P1(i).  Then,  by  deﬁnition  of  Seti ,  there  is  a  Seti -restricted  (cid:2)∗
Ci

simple path sp from lefti to  v that is shorter than the subpath  p[lefti, righti
(cid:8)
p
proof we assume that v is the last visited vertex in  p satisfying property P1(i) and we deﬁne  p

be  the  path  obtained  from  p by  replacing  p[lefti, v] with  sp.  This  path  p

(cid:8)

(cid:8)

accordingly.

-labeled 
] and, consequently, shorter than  p[lefti, v]. Let 
is  shorter  than  p.  For  the  remainder  of  the 

(cid:8)

Case  (2):  let  v

and righti that is shorter than  p[lefti, righti
Furthermore, for homogeneity of the proof, we deﬁne  j = i and v = righti (v is not the vertex satisfying property P2(i)).

be  a  vertex  satisfying  property  P2(i).  There  is  a  Seti -restricted  L-labeled  simple  path  sp between  lefti
] with sp. 

as the path obtained from  p by replacing  p[lefti, righti

]. We choose  p

(cid:8)

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

39

(cid:8)

(cid:8)

(cid:8)

be the run of  L over  p

is an  L-labeled path. Let ρ(cid:8)

The remainder of the proof is common to the two cases. We need to prove that  p

is a simple  L-labeled path. We ﬁrst 
prove that  p
. Let  w be the word formed by the labels of the subpath 
p[v, y]. We know that w ∈ Lρ(v) since p is an L-labeled path. We will show using Lemma 11 that w ∈ Lρ(cid:8)(v). By deﬁnition, 
(cid:8)[lefti, v] is (cid:2)∗
-labeled, hence ρ(cid:8)(v) ∈ Ci by Lemma 9. Furthermore 
ρ(cid:8)(lefti) belongs to the component Ci and the path s = p
Ci
ρ(v) ∈ C j and  C j is reachable from  Ci . In addition, by deﬁnition of a summary, there are at least  M + 1 vertices  v
of  p
(cid:8)(cid:8)) ∈ C j , and therefore the  M labels following vertex  v in  p belong to (cid:2)C j by Lemma 9
after  v (including  v) such that ρ(v
again.  The  deﬁnition  of  components  Ci, C j guarantees  that  q1, q2 admit  loops.  We  have  thus  proved  that  q1 = ρ(cid:8)(v) and 
q2 = ρ(v) meet all requirements for Lemma 12, which implies  w ∈ Lρ(cid:8)(v). Consequently,  p

is an L-labeled path.

We now prove that  p

is simple. Since  p is simple, it suﬃces to prove that the vertices in sp (between lefti and  v) are 
(cid:8) < i, 
disjoint with other vertices in  p
. Notice that all intermediate vertices of sp belong to Seti . By minimality of i, for all i
the vertices between lefti(cid:8) and righti(cid:8) belong to Seti(cid:8) and, since Seti(cid:8) and Seti are disjoint (Lemma 14), do not belong to Seti . 
Consequently, there is no vertex  v
belong to  Seti . By construction, in the two cases (1) and (2), 
there is no vertex v

belongs to Seti . This concludes the proof. (cid:2)

before  lefti such that  v

after v such that v

(cid:8)(cid:8)

(cid:8)

(cid:8)

(cid:8)

(cid:8)

(cid:8)

(cid:8)

(cid:8)

We observe that many of our summary and completion deﬁnitions were actually tailored for this Lemma 16: our proof 
by  contradiction  explains  for  instance  why  our  deﬁnition  of  Seti guarantees  the  existence  of  a  safe  completion.  And  our 
application of Lemma 12 in that proof explains why our summaries feature M + 2 vertices of each component.

We next show how a summary admitting a safe completion can be completed in logarithmic space into a simple path.

5.3.  An algorithm for RSPQ via safe completions

We next introduce Algorithm 1, show that it computes simple L-labeled path from x to  y, and analyze its complexity.

Algorithm 1 Algorithm for RSPQ(L).
(* Fixed parameter: A L . 
1: for all candidate summary S do
2:
3:

if Safe-completion(S)(cid:3)= ∅ then
return Safe-completion(S)

Input: graph G, vertices x, y. *)

4: procedure Safe-completion(S)

(* Denoting by (Ci , (cid:2)Ci , lefti , righti )i∈[l] the components of S *)

if the vertices of S are not distinct then

5:
6:
7:
8:
9:
10:
11:
12:
13:
14:

return ∅
for all i ∈ [l] do

else return ∅

return p
else return ∅

Compute a shortest Seti -restricted (cid:2)∗
Ci
if there is such a path then

-labeled path from lefti to righti

replace in S the sequence (lefti , cutCi , righti ) by that path

if the resulting path p is L-labeled and has summary S then

Theorem 1. Algorithm 1 returns a simple L-labeled path from x to y if there is one. The algorithm can be implemented in NL.

We ﬁrst prove that local domains Seti can be computed in logarithmic space.

Lemma 17. Let L be a ﬁxed language in Ctract. The following problem P Set is in NL. Given an instance (G, x, y) of RSPQ(L), a candidate 
summary S, a vertex z and an integer i, decide whether z ∈ Seti .

Proof. For  each  k ≥ 0,  let  P k
(G, x, y, S, z, i) ∈ P Set and i ≤ k.

Set be  the  decision  problem  P Set with  the  restriction  i ≤ k:  (G, x, y, S, z, i) ∈ P k

Set

iff 

∈ NL for  each  k ∈ [0, K ].  The  proof  is  by  induction  on  k.  If  k = 0,  P 0

Clearly,  the  number l of  cuts  in  a  summary  S as  in  Deﬁnition 4,  is  bounded  by  the  number  K of  strongly  connected 
components of L. Consequently,  P Set = P K
Set . Notice that  K is a constant that does not depend on the instance. Let us prove, 
that  P k
Set always  returns  False  because  Seti is  not 
Set
∈ NL.  It  suﬃces  to  show  that  there  is  an  NL-
deﬁned  for  i = 0.  So  P 0
Set
algorithm for  P k+1
∈ NL. Let (G, x, y, S, z, i) be an 
instance  of  P k+1
Set .  If  i = k + 1,  using  the  deﬁnition  and  notations 
of Setk+1, the problem essentially boils down to computing the distances between the vertices leftk+1 and  z on one hand, 
} and  E
leftk+1 and  rightk+1 on  the  other  hand  in  the  graph  G
is  the  set 
of  (cid:2)Ck+1 -labeled  edges  of  G[V
is  not  stored  in  memory  but 
Set . (cid:2)
simulated. The distance computation can thus clearly be performed in non deterministic log-space using the oracle  P k

is  trivially  in  NL.  Assume,  by  induction,  that  P k
Set
Set as oracle. Since NLNL = NL (Lemma 2), this implies that  P k+1

Set using  P k
.  If  i ≤ k,  we  return  the  same  answer  as  the  oracle  P k

(cid:8)].  In  order  to  remain  within  logarithmic  space,  the  graph  G

(cid:8) = V k+1 ∪ {leftk+1, rightk+1

(cid:8)) where  V

(cid:8) = (V

(cid:8), E

Set

Set

(cid:8)

(cid:8)

40

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

Lemma 18. Let L be a ﬁxed language in Ctract, (G, x, y) an instance of RSPQ(L) and S a summary. Procedure Safe-completion(S) 
from Algorithm 1 returns in NL a safe completion p from x to y if there is any, and returns ∅ otherwise.

Proof. The  correctness  of  the  procedure  is  immediate  as  it  matches  the  deﬁnition  of  safe  completions.  We  still  have  to 
check the complexity. To achieve logarithmic space, we do not store the Seti in memory: we only need to check on-the-ﬂy 
if a given vertex belongs those sets, using Lemma 17. This proves the algorithm can easily be implemented in NL. (cid:2)

We can now prove Theorem 1. By Lemmas 15 and 16, there exists a safe completion from x to  y if and only if there is 
a simple path from x to  y. Lemma 16 implies that Algorithm 1 identiﬁes a safe completion if there is one, so the algorithm 
is  correct.  The  complexity  is  in  NL as  candidate  summaries  have  constant  size  and  therefore  can  be  enumerated  in  NL, 
whereas completions are computed in NL according to Lemma 16. This concludes the proof of Theorem 1.

Notice that we can easily adapt Algorithm 1 so that it outputs a shortest path for positive instances. The main theorem 

summarizes our results, combining Lemma 4 with Theorem 1.

Theorem 2. Let L be a regular language. Then, RSPQ(L) is in NL if L ∈ Ctract and is NP-complete otherwise.

5.4.  Towards a complete classiﬁcation

We have partitioned RSPQ(L) problems into NL and NP-complete problems. We next reﬁne the classiﬁcation within the 

class of NL problems.

Lemma 19. For every regular language L, RSPQ(L) ∈ AC0 if L is ﬁnite, otherwise RSPQ(L) is NL-hard.

The proof is based on a reduction from the following NL-complete problem [24].

Reachability
Input: A directed graph G and two vertices x, y in G
Question: Is there a path from x to  y?

Proof. (Membership)  For  a  ﬁnite  language  L,  RSPQ(L) can  easily  be  deﬁned  by  a  ﬁrst-order  formula,  more  precisely  a 
disjunction of conjunctive formulas. Consequently, RSPQ(L) ∈ AC0 [12].

(Hardness) We exhibit a reduction from Reachability. Let L be an inﬁnite regular language. By the Pumping Lemma, there 
(cid:8)
from G by ﬁrst labeling every edge of G with 
(cid:8)). There is a (not necessarily simple) path from 

exist non empty words u, v, w such that uv
(cid:8)
with edges (x
v, and then adding two vertices x
(cid:8)
x to  y in G iff there is an L-labeled simple path from x

w ⊆ L. We build a db-graph G
(cid:8), u, x) and ( y, w, y
(cid:8)
in G
to  y

. Consequently, RSPQ(L) is NL-hard. (cid:2)

and  y

∗

(cid:8)

(cid:8)

Our results so far can be summarized in the following trichotomy which reﬁnes Theorem 2.

Theorem 3. Let L be a regular language. The complexity of RSPQ(L) can be determined as follows.

1. L is ﬁnite: RSPQ(L) ∈ AC0;
2. L ∈ Ctract and L is inﬁnite: RSPQ(L) is NL-complete;
3. L /∈ Ctract: RSPQ(L) is NP-complete.

6.  Variations

In this Section, we analyze the computational complexity of variations of the main problem: allowing (cid:5)-edges, ﬁnding 

shortest paths in weighted graphs and ﬁnding paths that minimize repetitions of vertices.

6.1.  Db-graphs with (cid:5)-edges

We observed in Lemma 4 that RSPQ(L) does not become harder if we allow edges labeled by non empty words. However, 
we have not discussed yet the complexity of RSPQ(L) when we allow edges labeled by (cid:5). We name RSPQ(cid:5) (L) this variation 
of RSPQ(L). We show that the class of tractable languages RSPQ(cid:5) (L) corresponds to the languages closed under subwords, 
and consequently is a strict subset of Ctract .

Theorem 4. Let L be a regular language. The complexity of RSPQ(cid:5) (L) can be determined as follows.

1. L is empty: RSPQ(cid:5) (L) is trivial i.e. does not contain positive instances;

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

41

2. L is non empty and closed under subwords: RSPQ(cid:5) (L) is NL-complete;
3. L is not closed under subwords: RSPQ(cid:5) (L) is NP-complete.

Proof. 1) is straightforward.

2)  The  membership  in  NL is  straightforward:  for  any  subword  closed  language  L,  there  exists  a  simple  L-labeled  path 
from x to  y in G if and only if there exists an L-labeled path (simple or not) from x to  y in G. This can obviously be checked 
in NL. We next prove that RSPQ(cid:5) (L) is NL-hard. Since  L is not empty, let  w be a word in  L. The reduction is identical to 
the reduction of Lemma 19. We choose u = v = (cid:5) and  w as deﬁned above.

3)  Since  L is  not  closed  under  subwords,  there  exist  words  u, v, w such  that  uv w ∈ L and  u w /∈ L.  The  reduction  is 

identical to the reduction of Lemma 4. We choose  w 1 = w 2 = (cid:5),  wl = u,  wm = v and  wr = w. (cid:2)

6.2.  Shortest path in weighted graphs

In this section, we consider the following problem:

weighted-RPQ(L, C)
Input: A db-graph G, two vertices x and  y and a positive weight function W over the edges of G
Objective: Find a simple path L-labeled path  p from x to  y with minimal weight W (p) if such a path exists

The problem can be solved with a straightforward generalization of Algorithm 1. Edges of weight  0 are the only ones 
shorter 
that require special care. Indeed, in the proof of Lemma 16, we start from a shortest path  p and build a path  p
can have weight 0, there may be no contradiction. 
than  p with the goal of showing a contradiction. When both  p and  p
To  overcome  this  problem,  one  can  for  instance  deﬁne  weights  over  a  product  order  to  count  the  number  of  edges  with 
weight 0: if the weights are originally deﬁned over some ordered set  W , we assign to each edge e the weight (w, 0) if e
has weight w > 0, and (w, 1) otherwise. The weights of the edges along a path are summed componentwise, and paths are 
compared based on a lexicographic order. This means that the number of edges with weight 0 along a path is solely used 
to break ties.

(cid:8)

(cid:8)

6.3.  Paths that minimize repetitions of vertices

We next show that our technique and results extend to generalizations of the simple path problem that do not forbid 

but only limit repetitions of vertices along the path.

Deﬁnition 9. Let  p be a path and  v 1, . . . , vm be the sequence of vertices appearing in  p. We deﬁne rep(p) as the multiset 
keeping only vertices v i for which there is v j ,  j < i such that v i = v j . We denote by nbrep(p) the cardinality of rep(p).

Clearly  p is a simple path if and only if nbrep(p) = 0. We consider the following problem:

rep-RPQ(L)
Input: A db-graph G, two vertices x and  y and an integer k ≥ 0
Question: Is there an L-labeled path  p from x to  y such that nbrep(p) ≤ k?

Lemma 20. Let L ∈ Ctract. Then there is a constant K L such that for every db-graph G and L-labeled path p from x to y in G, there 
exists an L-labeled path p

from x to y with nbrep(p

(cid:8)) ≤ K L .

(cid:8)

Proof. Let p be an L-labeled path from x to  y that minimizes nbrep(p). We will prove that all occurrences of a given vertex 
v appear in the summary  S except at most one. This is suﬃcient for the proof since the size of the summary  S is bounded 
by a constant. Assume, for the sake of contradiction, that  p is of the form (v 1, a1, . . . al, vl+1) and contains two occurrences 
(cid:8) = (v 1, . . . v i, a j, v j+1, . . . , vl+1).  Then, 
v i, v j of  the  same  vertex  such  that  v i and  v j are  not  in  the  summary  of  p.  Let  p
nbrep(p

is an L-labeled path by Lemma 11. (cid:2)

(cid:8)) < nbrep(p), and  p

(cid:8)

Theorem 5. Let L ∈ Ctract. Then, rep-RPQ(L) ∈ NL.

Proof. Given a db-graph G and a multiset  A of vertices in G, we deﬁne the graph c(G, A) as follows. We start from G and 
for each vertex x in  A we add a new vertex in G which is a copy of x i.e. has the same incoming and outgoing edges as x
has.

By construction, we have the following property: there exists an  L-labeled simple path from x to  y in c(G, A) iff there 
exists an  L-labeled path  p from x to  y in G such that rep(p) ⊆ A. Consequently, it suﬃces to enumerate all multisets  A of 

42

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

Table 1
A family of regular expressions for Ctract .

(cid:7)seq

::= w + (cid:5) | A

(cid:7)tr

::= w(cid:7)seq w

≥k + (cid:5) | (cid:7)seq(cid:7)seq
(cid:8) | (cid:7)tr + (cid:7)tr
(cid:8) ∈ (cid:2)

, A ⊆ (cid:2)

∗

where w, w

at most k vertices and check if, for one of them, c(G, A), x, y is a positive instance of RSPQ(L). Thanks to Lemma 20, we do 
not have to consider multisets of more than  K L vertices.

Moreover, it is easily seen that c is a function in FL. Thus, we obtain the following algorithm for rep-RPQ(L).

Algorithm 2 Algorithm for rep-RPQ(L).
1: for each multiset A of min(k, K L ) vertices do
2:
3:
4: return false

return true

if c(G, A), x, y is a positive instance of RSPQ(L) then

Other constraints on repetitions may be worth mentioning. It is obvious that Lemma 20 and therefore also Theorem 5
still  hold  if  we  deﬁne  nbrep(p) as  the  maximal  number  of  occurrences  of  a  vertex  in  p.  Or  if  we  deﬁne  nbrep(p) as  the 
number of distinct vertices that are repeated (one or several times) in  p.

7.  Characterization by regular expressions

In  this  section,  we  propose  two  characterizations  of  Ctract languages.  The  ﬁrst  in  terms  of  regular  expressions  and  the 
second in terms of a pumping property. Unlike the other properties discussed before on the minimal DFA of L, the pumping 
property is expressed directly on the language L. The languages in Ctract are exactly those that can be expressed with an ex-
pression in the fragment (cid:7)tr deﬁned in Table 1. This fragment enforces restrictions on the concatenation of subexpressions: 
roughly speaking, only expressions of the form e + (cid:5) can be concatenated.

(cid:2)

Example 4. For instance, the expression a
∗ = c
c
following theorem, however, implies that a

≥0).  Expression a

∗ + (a + b)∗

ba

∗

∗

∗

ba

∗(b

≥2 + (cid:5))c

∗

investigated in Example 1 belongs to the fragment (cid:7)tr (using notation 
,  on  the  opposite,  does  not,  but  is  clearly  equivalent  to  (a + b)≥0,  which  does.  The 

is not equivalent to any expression from (cid:7)tr .

Theorem 6. Let L be a regular language. The three following statements are equivalent:

1. A language L belongs to Ctract.
2. L is recognized by a regular expression in (cid:7)tr .
3. There is an integer i ≥ 0 such that for all words wl, wm, wr ∈ (cid:2)∗

and all non empty words w 1, w 2 ∈ (cid:2)+

implies wl w i

1 w i

2 wr ∈ L.

, wl w i

1 wm w i

2 wr ∈ L

Proof. 1 ⇒ 2)  We  next  outline  an  algorithm  to  build  the  regular  expression  e from  A L .  Let  C1, . . . , Cl be  the  strongly 
connected components of  L in some topological order. For every k ∈ {0, . . . , l} and every sequence 1 ≤ j1 < · · · < jk ≤ l, we 
denote by L[ j1, . . . , jk] the set of all words from L that stay for at least 2M steps in each component C j1 , . . . , C jk , and stay 
for at most 2M − 1 steps after entering in each other component.

Clearly,  L is  the  union  of  all  L[ j1, . . . , jk] over  all  sequences  j1, . . . , jk.  We  next  show  how  to  build  an  expression  for 
L[ j1, . . . , jk]. We denote by S1, . . . , Sk the components C j1 , . . . , C jk and by (cid:2)1, . . . , (cid:2)k their alphabet. For any component S i
and state q in  S i , we can easily build an expression  Hq with language:  L(Hq) = {w ∈ ((cid:2)i)M | ∃q0 ∈ S i, (cid:3)L(q0, w) = q}. The 
rationale for this deﬁnition is that words of ((cid:2)i)M are synchronizing within S i according to Lemma 12: for all q, q1 ∈ S i and 
w ∈ L(Hq), we have (cid:3)L(q1, w) = q.

Let i < k and q ∈ S i . We build an expression W q for the set of all words  w that lead from q to some state of  S i+1 while 
respecting the sequence of components. In other words, a word  w = a1 . . . am belongs to  L(W q) iff when we denote by q j
the state (cid:3)L(q, a1 . . . a j), the sequence q1 . . . qm satisﬁes the following properties2:

• q1 /∈ S i
• qm is the ﬁrst state of the sequence that belongs to  S i+1

2 We require somewhat arbitrarily that the ﬁrst letter of w lets quit S i , while the last letter of w lets enter S i+1 (i.e., is not in (cid:2)i+1).

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

43

• there are at most 2M states q j in the same component of  A L .

Similarly,  for  i = k,  we  build  for  any  state  q ∈ Sk an  expression  W q for  the  set  of  all  words  w that  lead  from  q to  some 
ﬁnal state while respecting the sequence of components, i.e., satisfying conditions similar to the above ones except that qm
belongs to  F L instead of  S i+1. L(W q) is a ﬁnite set of words having length at most 2M2.

If i L belongs to  S1, we deﬁne the expression einit as (cid:5), otherwise einit is the set of all words that lead from i L to some 
state in  S1 while respecting the sequence of components. Rephrased differently, a word  w = a1 . . . am belongs to L(einit) iff, 
when we denote by q j the state (cid:3)L(i L, a1 . . . a j), the sequence q1 . . . qm satisﬁes the following properties:

• qm is the ﬁrst state of the sequence that belongs to  S1,
• there are at most 2M states q j in the same component of  A L .

einit is a ﬁnite set of words having length at most 2M2.
Claim 1: The expression e

(cid:8)
0 deﬁned by the following equations represents the language L[ j1, . . . , jk]
(cid:3)

(cid:8)
k

e

= ((cid:2)k)

≥M · (

Hq · W q)

(cid:8)
i

e

= ((cid:2)i)

≥M · (

q∈Sk
(cid:3)

Hq · W q) · e

(cid:8)
i+1 for all 1 ≤ i < k

q∈S i
≥M · (

= einit · ((cid:2)1)

(cid:8)
0

e

(cid:3)

Hq · W q) · e

(cid:8)
1

q∈S1

(cid:8)
0 clearly contains L[ j1, . . . , jk]. The converse inclusion follows from Lemma 12, which concludes the proof 
The language of e
of Claim 1. We now deﬁne the expressions e0, . . . , ek recursively as follows (with i ranging from 1 to k − 1 included, in the 
second equation):

ek = (((cid:2)k)

≥M + (cid:5)) · (

(cid:3)

Hq · W q)

ei = (((cid:2)i)

≥M + (cid:5)) · (

q∈Sk
(cid:3)

Hq · W q + (cid:5)) · ei+1

e0 = einit · (((cid:2)1)

q∈S i
≥M + (cid:5)) · (

(cid:3)

Hq · W q + (cid:5)) · e1

q∈S1

Claim 2: The language of e0 contains L[ j1, . . . , jk] and is contained in L.
The  language  of  e0 clearly  contains  the  language  of  e
u0, v 0, u1, v 1 . . . , un, and vn such that

(cid:8)
0,  hence  L[ j1, . . . , jk] by  Claim 1.  Let  w ∈ L(e0).  There  exist 

(cid:2)

• w = u0 v 0u1 v 1 . . . un vn
• u0 ∈ L(einit · (((cid:2)1)≥M + (cid:5)))
• vn ∈ L(
q∈Sk
• for each 0 ≤ i ≤ n − 1, v i ∈ L(
• for each 1 ≤ i ≤ n, ui ∈ L(((cid:2)i)≥M + (cid:5)).

Hq · W q)

q∈S i

(cid:2)

Hq · W q + (cid:5))

(cid:8)

be the word obtained from  w by replacing every  v i equal to (cid:5) with an arbitrary word from  L(
(cid:8)
i equal to (cid:5) with an arbitrary word from L(((cid:2)i)≥M ). Then  w

Hq · W q), and 
Let  w
(cid:8)
every e
0) and in particular to L. Consequently, 
w also belongs to  L by repeated applications of Lemma 12. As  L(W q) and  L(Hq) are ﬁnite sets of words for every state q, 
e0 belongs to the fragment, which concludes the proof of Claim 2.

belongs to L(e

q∈S i

(cid:8)

(cid:2)

2 ⇒ 3) It is easily seen that languages that satisfy Statement (3) are closed by union. Consequently, we consider a regular 
expression  ϕ ∈ (cid:7)tr of  the  form  ϕ1 · . . . · ϕl where  ϕ1 and  ϕl are  words  and  ϕi is  a  (cid:7)seq-term  for  every  i ∈ {2, . . . , l − 1}. 
For each  i ∈ [l], we denote by  Li the language recognized by ϕi . Let  M be the size of ϕ, deﬁned as the number of states 
≥k are expanded). Let 
in its Glushkov automaton (i.e., the number of symbols in the expressions when terms of the form  A
2 w ∈ L. 
1 w M
u, v, w, w 1, w 2 be words with  w 1 and  w 2 non empty such that  u w M
Using the usual pumping argument for automata, applied to the Glushkov automaton of the expression, one shows easily 
≥n · Li+1 . . . Ll). Notice that 
that there is some term ϕi of the form  A
ϕi cannot  be  of  the  form  w + (cid:5) because  w M
1 necessarily  “ends”  inside  a  Kleene-star  subexpression  by  deﬁnition  of  M. 
2 w ∈ L j . . . Ll.  Thus, 
Similarly,  there  is  some  term  ϕ j ,  j ≥ i of  the  form  B
2

2 w ∈ L. We want to prove that  u w M

≥n + (cid:5) such that  u w M
1

≥m + (cid:5) such  that  u w M

∈ L1 . . . Li (and  w M

∈ L1 . . . L j and  w M

2 w ∈ A

1 v w M

1 v w M

1 v w M

44

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

1 w M

2 w ∈ L1 . . . Li · L j . . . Ll. Furthermore, L1 . . . Li · L j . . . Ll ⊆ L: if i = j, then Li L j ⊆ L j due to the form of Li , and if i < j, 

u w M
then (cid:5) ∈ Li+1 L j−1 because every intermediate term can be skipped. As a consequence, u w M

1 w M

2 w ∈ L.

3 ⇒ 1) Assume that L satisﬁes Statement (3). Let i be as stated in (3). Let q1, q2 ∈ Q L such that Loop(q1) (cid:3)= ∅, Loop(q2) (cid:3)= ∅
such that w 1 ∈ Loop(q1), w 2 ∈ Loop(q2), (cid:3)L(i L, wl) = q1, (cid:3)L(q1, wm) = q2
2 wr ∈ L. We consider two cases: i ≤ M and i > M.
2 wr ∈ L. Con-
2 wr = wl w M

2 wr . By hypothesis, we then have  wl w M−i

2 wr ∈ Lq1 . Let w = wl w M

1 wm w M

2 w M−i

1 w i

1 w i

1 w M

1 w i

1 wm w i

and q2 ∈ (cid:3)L(q1, (cid:2)∗). Let w 1, w 2, wl, wm, wr ∈ (cid:2)∗
and wr ∈ Lq2 . We need to prove that w M
Case i ≤ M:  w = wl w M−i
2 w M−i
2 wr ∈ Lq1 .
sequently,  w M
Case  i > M:  By  the  classical  pumping  lemma,  there  exist  integers  k, k
M+kj
wl w
1
wl w i+i1
1 w
w i+i2

1 w i+i2
2 wr ∈ Lq1 for every i2 ≥ 0. By the usual pumping argument,  w M

wm w
w i+i2
2 wr ∈ L,  which  by  hypothesis  implies  wl w i+i1
(cid:8)

M+k
2

j

(cid:8)

(cid:8)

(cid:8) > 0 such  that  for  every  j, j
∗
1 wm w

(cid:8) ∈ w

2 wr ∈ L.  Observe  that  (cid:3)(i L, wl w i+i1
2 wr ∈ Lq1 . (cid:2)

1

(cid:8) ≥ 0,  the  word 
∗
2 such  that 
) = q1,  so  that 

wr belongs  to  L.  Consequently,  for  every  i1, i2 ≥ 0,  we  can  ﬁnd  a  word  w

The two characterizations of Ctract in Theorem 6 imply the following results.

Corollary 1. Ctract is closed under intersection, union and word reversal.

The closure under intersection and union of Ctract is a consequence of the second statement of Theorem 6 and the closure 

under word reversal is a consequence of the third statement of the same theorem.

An  NFA  A is  pseudo-acyclic  if  every  loop  in  A is  a  self-loop  (i.e.  a  transition  from  a  state  to  itself).  Since  in  the  third 
in  Theorem 6 expressions  under  a  Kleene  star  are  unions  of  symbols,  we  obtain  the  following 

characterization  of  Ctract
result.

Corollary 2. Let L ∈ Ctract. Then, A is recognizable by a pseudo-acyclic NFA.

The converse is not true since a

∗

∗

ba

is not in Ctract but recognizable by a pseudo-acyclic NFA.

8.  Recognition of tractable languages

The  following  theorem  establishes  the  complexity  of  deciding  if  RSPQ(L) is  tractable  (i.e.  deciding  if  RSPQ(L) can  be 

computed in polynomial time). We consider different representations of L (DFAs, NFAs and regular expressions).

Theorem 7. Testing whether a regular language L belongs to Ctract is:

1. NL-complete if L is given by a DFA;
2. PSpace-complete if L is given by an NFA (resp. a regular expression).

Before proving this theorem, we need some useful lemmas.

Lemma 21 (Folklore). There is an L transducer that, given two DFAs A1 and A2 that respectively recognize the languages L1 and L2, 
returns a DFA that recognizes the language L1 ∩ L2 (resp. L1 ∪ L2, L1 \ L2).

Proof. The classical construction by product of the two DFAs can be done by an L transducer. (cid:2)

The next lemma permits to consider only minimal DFAs.

Lemma 22. Let L be a class of regular languages, such that we can test in NL whether a minimal DFA recognizes a language in L.

1. testing whether a DFA recognizes a language in L is in NL;
2. testing whether an NFA recognizes a language in L is in PSpace.

(cid:8)
Proof. 1) We will exhibit an NL transducer t that given a DFA  A L returns a minimal DFA  A
L equivalent to  A L . We construct 
t as the composition of two transducers t1 and t2, where t1 removes from  A L all states non reachable from the initial state 
and t2 merges all Nerode-equivalent states. This composition of two NL transducers is an NL transducer [24].

The log-space algorithm for t1 uses an oracle for the problem Reachability and the log-space algorithm for t2 uses an 
= Lq2 , is actually in NL since it can be 

oracle for state equivalence. This problem of deciding given q1 and q2, whether Lq1
reduced to Emptiness using L transducers of Lemma 21.

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

45

2)  We  determinize  the  automaton  and  then  apply  an  NL algorithm  A to  recognize  L on  the  deterministic  automaton 
thus  obtained.  To  achieve  the  polynomial  bound  on  space,  the  deterministic  automaton  is  actually  simulated  on  the  ﬂy 
instead of stored in memory. (cid:2)

Lemma 23. There is an L transducer that given a minimal DFA A L and a state q of A L computes a DFA that recognizes the language 
Loop(q)M Lq.

Proof. Let  L
puted by an L transducer.

(cid:8) = Loop(q)M Lq. We construct a DFA  A L(cid:8) = (Q L(cid:8) , i L(cid:8) , F L(cid:8) , (cid:3)L(cid:8) ) as follows. This construction can clearly be com-

• Q L(cid:8) = Q L × [0, M];
• i L(cid:8) = (q, 0);
• F L(cid:8) = F L × {M};
• Let  (q1, i) ∈ Q L(cid:8) and  a ∈ (cid:2).  Then  (cid:3)L(cid:8) ((q1, i), a) = ((cid:3)L(q1, a), i + 1) if  q1 = q and  i < M.  Otherwise,  (cid:3)L(cid:8) ((q1, i), a) =

((cid:3)L(q1, a), i).

Let  us  prove  that  A L(cid:8) recognizes  the  language  L

(cid:8) = Loop(q)M Lq.  We  decompose  w as  w = w 1 w 2 where 
w 1 ∈ Loop(q)M and  w 2 is accepted by  A L starting from q. By construction (cid:3)L(cid:8) ((q, 0), w 1) = (q, M) and  w 2 is accepted by 
A L(cid:8) starting from (q, M). Thus,  w is accepted by  A L(cid:8) .

.  Let  w ∈ L

Let  w be a word accepted by  A L(cid:8) . By construction, we easily see that  w is accepted by  A L starting from q. Additionally, 
the run of  w over  A L contains at least  M + 1 occurrences of the state q. Consequently,  w = w 1 w 2 where  w 1 ∈ Loop(q)M
and  w 2 is accepted by  A L starting from q. Thus  w ∈ L

. (cid:2)

(cid:8)

(cid:8)

Lemma 24. We can decide in NL whether Loop(q2)M Lq2

⊆ Lq1 given a minimal DFA together with two states q1 and q2.

Proof. Combining Lemmas 21 and 23, we obtain an L transducer that, given a minimal DFA A L and two states q1, q2, returns 
a DFA that recognizes the language Loop(q2)M Lq2
\ Lq1 . We thus reduce our problem to the Emptiness problem that is in 
NL. (cid:2)

With the help of those lemmas we ﬁnally prove Theorem 7.

Proof. 1) Membership: let  A L be a minimal DFA. The proof is based on the characterization of Lemma 6: for each pair of 
states q1, q2, we check in NL if they admit a loop and if q2 is accessible from q1. Then we check Loop(q2)M Lq2
⊆ Lq1 , still 
in NL according to Lemma 24. We thus check in NL whether  L ∈ Ctract when  L is given by a minimal DFA which, together 
with Lemma 22, concludes our proof.

Hardness: we exhibit a reduction from Emptiness. Let  L ⊆ (cid:2)∗

where 1 /∈ (cid:2). Moreover, we assume that 
(cid:5) /∈ L. Emptiness clearly remains NL-complete with this restriction. Our reduction maps a DFA  A L that recognizes L to a DFA 
(cid:8) ∈ Ctract, 
A L(cid:8) that recognizes L
and let  w ∈ (cid:2)+
for every  i ≥ 0. As a consequence, Theorem 6 (using  wl = wr = (cid:5)) yields some 
i ≥ 0 such that 1i w1i /∈ L

(cid:8)
. Thus,  w /∈ L, hence L is empty.

(cid:8) = ∅ ∈ Ctract. Conversely, assume that L

. First, we prove that L = ∅ iff L

(cid:8) ∈ Ctract. If L = ∅ then L

. By construction, 1i1i /∈ L

+
(cid:8) = 1

and  L

L1

+

(cid:8)

(cid:8)

It  remains  to  prove  that  the  reduction  can  be  computed  with  an  L transducer.  We  construct  A L(cid:8) from  A L as  follows.
We add a state i L(cid:8) that will be the initial state of  A L(cid:8) and a state  f L(cid:8) that will be the unique ﬁnal state of  A L(cid:8) . (cid:3)L(cid:8) is the 
extension of (cid:3)L deﬁned as follows:

• (cid:3)L(cid:8) (i L(cid:8) , 1) = i L(cid:8) and (cid:3)L(cid:8) (i L(cid:8) , a) = i L for every symbol a ∈ (cid:2).
• For every ﬁnal state q ∈ F L , (cid:3)L(cid:8) (q, 1) = f L(cid:8) , and (cid:3)L(cid:8) ( f L(cid:8) , 1) = f L(cid:8) .

2) The membership is a direct consequence of (1) and Lemma 22. To prove the hardness result we will exhibit a reduction 
∗ + La
∗
∗
. Let us 
ba
∗(b + (cid:5))a
∗ ∈ Ctract
belongs to L. By deﬁnition 

from Universality. Consider the alphabet (cid:2) = {0, 1, a, b} and two languages  L ⊆ {0, 1}∗
prove that L = {0, 1}∗
(cid:8) ∈ Ctract. Assume that L = {0, 1}∗
iff L
according to Theorem 6. Conversely, assume L
of L

(cid:8) = (0 + 1)∗
(cid:8) ∈ Ctract. Let us prove that every word  w ∈ {0, 1}∗

(cid:8) = (0 + 1)∗
and  L
a
∗ = (0 + 1)∗
∗ + (0 + 1)∗
a
a

for every M ≥ 0. Consequently,  waMaM ∈ L

for some M ≥ 0 since L

(cid:8) ∈ Ctract. Thus  w ∈ L. (cid:2)

,  waM baM ∈ L

. Then L

ba

a

∗

(cid:8)

(cid:8)

(cid:8)

9.  Other minor results

9.1.  Parametrized complexity

The next section focuses on the parametrized complexity of the RSPQ problem.

46

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

para-RSPQ
Input: a db-graph graph G = (V , (cid:2), E),
a regular language L given by an NFA  A L with q states
two vertices x and  y
Parameter: q
Question: Is there a simple L-path from x to  y in G?

Our initial goal was to determine the parametrized complexity para-RSPQ(Ctract) when  L is restricted to Ctract. Unfortu-
nately, we could only partially reach this goal. We ﬁrst address the parametrized complexity of RSPQs when the parameter 
is the size of the path.

k-RSPQ
Input: a db-graph graph G = (V , (cid:2), E),
a regular language L given by an NFA  A L with q states,
two vertices x and  y
an integer k ≥ 0
Parameter: k
Question: Is there a simple L-labeled path of size at most k from x to  y in G?

Theorem 8. k-RSPQ is FPT. More precisely, the problem is solvable in time 2O (k)q · |G| · log |G|.

The proof is based on the Color Coding method [1]. Let  V be a ﬁnite set. A k-coloring of  V is a function c : V → [k]. A 
set  S ⊆ V is colorful for c if c(x) = c( y) ⇒ x = y for every x, y ∈ S. The crux of our proof is the following result by Alon et 
al.:

Theorem 9 ([1]). Given k, n ≥ 0 and a set V of n elements, one can compute in time 2O (k)|V | log |V | a set of l ∈ 2O (k) log |V | k-coloring 
functions c1, . . . cl such that every set S of V of size k is colorful for at least one ci (i ∈ [l]).

To exploit this result when building incrementally a simple path from x to  y we shall record for each coloring the subset 
of colors used so far, instead of recording the set of nodes visited. This reduces the number of combinations considered to 
2O (k) log |V |.

Proof of Theorem 8. Let  G, A L, k be an instance of k-RSPQ. We compute l k-coloring functions c1, . . . cl as stated in Theo-
rem 9. Let c be one of these functions. We will show how to decide if there is a colorful  L-labeled path from x to  y in  G
for c. To this purpose, we deﬁne a function  f : V × Q L × P([k]) → {0, 1} such that  f (v, q, S) = 1 if and only if there exists 
a colorful path  p starting from  x that uses only colors of  S and such that (cid:3)L(i Q , w) = q where  w is the label of  p. The 
function can be computed by dynamic programming using the following equation.

• f (x, i Q , {c(x)}) = 1
• f (v, q, S) = 1 if there is a subset  S
• f (v, q, S) = 1 if c(v) ∈ S and there is a vertex  v

(cid:8) (cid:2) S such that  f (v, q, S
, a state q

(cid:8)

and q ∈ (cid:3)L(q

(cid:8), a);

• f (v, q, S) = 0 otherwise.

(cid:8)) = 1;
(cid:8)
and a label a such that  f (v

(cid:8), q

(cid:8), S \ c(v)) = 1, (v

(cid:8), a, v) ∈ E

This function can be computed in time O (2k · | A L| · |G|). We compute  f for every function ci , i ∈ [l] where l ∈ 2O (k) log |V |. 
Clearly there is a simple path of length at most k from x to  y if and only if there are i ∈ [l],  S ⊆ [k] and q ∈ F L such that 
f ( y, q, S) = 1 for coloring function ci . Consequently, k-RSPQ can be solved in time 2O (k)| A L| · |G| · log |G|. (cid:2)

As a consequence of this theorem we get:

Corollary 3. para-RSPQ restricted to ﬁnite languages is FPT.

9.2.  Directed treewidth

Directed  treewidth  is  a  notion  introduced  in [14].  It  measures  in  some  sense  how  close  a  digraph  is  to  a  directed 
acyclic graph and is based on the notion of arboreal decomposition. Johnson et al. [14] present a general method to design 
polynomial  algorithms  on  graphs  of  bounded  directed  treewidth.  Like  most  algorithms  exploiting  treewidth,  this  method 
leverages a dynamic programming approach on the decomposition tree. They apply this method to show that testing the 

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

47

existence of a Hamiltonian path is polynomial on such classes of graphs. Here, we extend this result to show that the regular 
simple path problem is also computable in polynomial time for the same classes.

It  has  been  observed  in  the  literature  that  RSPQ has  polynomial  combined  complexity  on  two  interesting  classes  of 
graphs: graphs of bounded treewidth [6], and DAGs [20]. The result for DAGs is immediate indeed, as every path in a DAG 
is simple. The next theorem generalizes both these two results.

Theorem 10. Let L be a regular language, k ≥ 0 and G be a class of db-graphs with directed treewidth at most k. Then, RSPQ(L)
restricted to the class G is polynomial if an arboreal decomposition of the graph is given as input. Furthermore, it is also polynomial if 
L is a part of the problem.

Proof. The proof is a straightforward adaptation of the proof proposed in [14] for the Hamiltonian Path problem. Since they 
(cid:8)
use a dynamic approach, they consider a more general problem: given a digraph G and a sequence of k tuples (v i, ni, v
i)i∈[k], 
are there k disjoint simple paths  p1, . . . pk such that  pi is a path of size ni from v i to v

We extend the problem as follows: given a db-graph  G, a regular language  L and a sequence of k tuples (v i, ni, v

(cid:8)
i, qi,
(cid:8)
i)i∈[k], are there k words  w 1, . . . wk and k disjoint simple paths  p1, . . . pk such that  pi is a  w i -labeled path of size ni from 
q
v i to v

(cid:8)
i for every i ∈ [k]? Therefore, their proof can easily be adapted to this new problem. (cid:2)

(cid:8)
i and (cid:3)L(qi, w i) = q

(cid:8)
i for every i ∈ [k]?

10.  Future work

We now pinpoint some directions for future work.

• As an extension of our work, we can consider context-free languages. It seems to be diﬃcult to obtain useful results, 

since we can easily prove that distinguishing polynomial and NP-hard instances is undecidable if P (cid:3)= NP.

• What becomes tractable under restrictions to the graph such as planar digraphs or undirected graphs? Notice that both 

disjoint paths and even path problems are polynomial in these cases [16,21,26,28].

• Study  the  parametrized  complexity  of  RSPQ  for  languages  L represented  by  NFAs,  the  parameter  is  the  number  of 
states of the NFA (or  L is represented by a regular expression and the parameter is the size of the regular expression). 
Corollary 3 proves that the complexity is FPT when L is restricted to be ﬁnite.

Declaration of competing interest

The  authors  declare  that  they  have  no  known  compe5ng  ﬁnancial  interests  or  personal  rela5onships  that  could  have 

appeared to inﬂuence the work reported in this paper.

Acknowledgments

The  authors  would  like  to  thank  the  anonymous  reviewers  and  Tina  Trautner  for  their  insightful  comments  on  the 

manuscript.

References

[1] N. Alon, R. Yuster, U. Zwick, Color-coding, J. ACM 42 (4) (1995) 844–856.
[2] R. Angles, M. Arenas, P. Barceló, A. Hogan, J.L. Reutter, D. Vrgoc, Foundations of modern query languages for graph databases, ACM Comput. Surv. 50 (5) 

[3] M. Arenas, S. Conca, J. Pérez, Counting beyond a Yottabyte, or how SPARQL 1.1 property paths will prevent adoption of the standard, in: WWW, 2012, 

(2017) 68:1–68:40.

pp. 629–638.

[4] E.M. Arkin, C.H. Papadimitriou, M. Yannakakis, Modularity of cycles and paths in graphs, J. ACM 38 (2) (1991) 255–274.
[5] G. Bagan, A. Bonifati, B. Groz, A trichotomy for regular simple path queries on graphs, in: Proceedings of the 32nd ACM SIGMOD-SIGACT-SIGAI Sym-

posium on Principles of Database Systems, ACM, 2013, pp. 261–272.

[6] C.L. Barrett, R. Jacob, M.V. Marathe, Formal-language-constrained path problems, SIAM J. Comput. 30 (3) (2000) 809–837.
[7] A. Bielefeldt, J. Gonsior, M. Krötzsch, Practical linked data access via SPARQL: the case of Wikidata, in: Proceedings of LDOW Workshop, 2018.
[8] A. Bonifati, W. Martens, T. Timm, An analytical study of large SPARQL query logs, VLDB J. 11 (2) (2017) 149–161.
[9] A. Bonifati, W. Martens, T. Timm, Navigating the maze of Wikidata query logs, in: The World Wide Web Conference, WWW 2019, San Francisco, CA, 

USA, May 13–17, 2019, 2019, pp. 127–138.

[10] M.R. Garey, D.S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, W. H. Freeman, 1979.
[11] N. Immerman, Nondeterministic space is closed under complementation, SIAM J. Comput. 17 (5) (1988) 935–938.
[12] N. Immerman, Descriptive Complexity, Springer, 1999.
[13] R. Jin, H. Hong, H. Wang, N. Ruan, Y. Xiang, Computing label-constraint reachability in graph databases, in: SIGMOD Conference, 2010, pp. 123–134.
[14] T. Johnson, N. Robertson, P.D. Seymour, R. Thomas, Directed tree-width, J. Comb. Theory, Ser. B 82 (1) (2001) 138–154.
[15] A. Koschmieder, U. Leser, Regular path queries on large graphs, in: SSDBM, 2012, pp. 177–194.
[16] A.S. Lapaugh, C.H. Papadimitriou, The even-path problem for graphs and digraphs, Networks 14 (4) (1984) 507–513.
[17] U. Leser, A query language for biological networks, in: ECCB/JBI, 2005, p. 39.
[18] K. Losemann, W. Martens, The complexity of regular expressions and property paths in SPARQL, ACM Trans. Database Syst. (TODS) 38 (4) (2013) 24.
[19] W. Martens, T. Trautner, Evaluation and enumeration problems for regular path queries, in: ICDT, in: LIPIcs, vol. 98, Schloss Dagstuhl – Leibniz-Zentrum 

fuer Informatik, 2018, pp. 19:1–19:21.

48

G. Bagan et al. / Journal of Computer and System Sciences 108 (2020) 29–48

[20] A.O. Mendelzon, P.T. Wood, Finding regular simple paths in graph databases, SIAM J. Comput. 24 (6) (1995) 1235–1258.
[21] Z.P. Nedev, Finding an even simple path in a directed planar graph, SIAM J. Comput. 29 (1999) 685–695.
[22] Z.P. Nedev, P.T. Wood, A polynomial-time algorithm for ﬁnding regular simple paths in outerplanar graphs, J. Algorithms 35 (2) (2000) 235–259.
[23] F. Olken, Graph data management for molecular biology, Omics. J. Integr. Biol. 7 (1) (2003) 75–78.
[24] C.H. Papadimitriou, Computational Complexity, Addison-Wesley, 1994.
[25] M. Perles, M. Rabin, E. Shamir, The theory of deﬁnite automata, IEEE Trans. Electron. Comput. EC-12 (3) (June 1963) 233–243.
[26] N. Robertson, P.D. Seymour, Graph minors XIII. The disjoint paths problem, J. Comb. Theory, Ser. B 63 (1) (1995) 65–110.
[27] W.L. Ruzzo, J. Simon, M. Tompa, Space-bounded hierarchies and probabilistic computations, J. Comput. Syst. Sci. 28 (2) (1984) 216–230.
[28] A. Schrijver, Finding k disjoint paths in a directed planar graph, SIAM J. Comput. 23 (4) (1994) 780–788.
[29] M.P. Schützenberger, On ﬁnite monoids having only trivial subgroups, Inf. Control 8 (2) (1965) 190–194.
[30] C.B. Ward, N.M. Wiegand, Complexity results on labeled shortest path problems from wireless routing metrics, Comput. Netw. 54 (2) (2010) 208–217.

