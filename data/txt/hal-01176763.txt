Logics for Unordered Trees with Data Constraints
Adrien Boiret, Vincent Hugot, Joachim Niehren, Ralf Treinen

To cite this version:

Adrien Boiret, Vincent Hugot, Joachim Niehren, Ralf Treinen. Logics for Unordered Trees with Data
￿10.1016/j.jcss.2018.11.004￿.
Constraints. Journal of Computer and System Sciences, 2019, pp.40.
￿hal-01176763v2￿

HAL Id: hal-01176763

https://inria.hal.science/hal-01176763v2

Submitted on 19 Dec 2018

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Logics for Unordered Trees
with Data Constraints(cid:73)

Adrien Boireta, Vincent Hugotb,∗, Joachim Niehrenc, Ralf Treinend

aManySynth project, Université de Mons

bSDS team, LIFO (EA 4022) & INSA Centre-Val de Loire

cLinks team, Cristal lab (Cnrs Umr 9189) of Inria Lille & Université de Lille

dUniv Paris Diderot, Sorbonne Paris Cité, IRIF, UMR 8243, CNRS, F-75205 Paris, France

Abstract

We study monadic second-order logics with counting constraints (CMso) for
unordered data trees. Our objective is to enhance this logic with data constraints
for comparing string data values. Comparisons between data values at arbitrary
positions of a data tree quickly lead to undecidability. Therefore, we restrict
ourselves to comparing sibling data values of unordered trees. But even in this
case CMso remains undecidable when allowing for data comparisons that can
check the equality of string factors. However, for more restricted data constraints
that can only check the equality of string preﬁxes, it becomes decidable. This
decidability result is obtained by reduction to WSkS. Furthermore, we exhibit a
restricted class of constraints which can be used in transitions of tree automata,
resulting in a model with tractable complexity, which can be extended with
structural equality tests between siblings. This eﬃcient restriction is relevant
to applications such as checking well-formedness properties of ﬁle system trees.

Keywords: Counting Mso; data trees; string comparisons

1. Introduction

Monadic second-order order logic (Mso) is one of the yardstick logics for ex-
pressiveness in computer science [2]. It is well-known that Mso for tree-like
structures is decidable, basically by reduction to tree automata, while Mso for

(cid:73)Extended version of [1]. This work has been partially supported by the the project ANR

CoLiS (contract ANR-15-CE25-0001).

∗Corresponding author
Email addresses: Adrien.BOIRET@umons.ac.be (Adrien Boiret), vincent.hugot@insa-cvl.fr
(Vincent Hugot), joachim.niehren@inria.fr (Joachim Niehren), treinen@irif.fr (Ralf Treinen)

Draft version

Wednesday 19th December, 2018

more general graphs or structures is undecidable. In this paper, we will consider
Mso over unordered data trees. This means that we annotate the elements of the
data tree with strings or other data values from an inﬁnite alphabet. Depending
on which relations on data values are supported, unordered data trees subsume
graphs, so that Mso becomes undecidable again.

Unordered data trees are a versatile data structure that is of interest in various
domains of computer science. More recently, they were used as data models of
semi-structured databases, such as for NoSql databases [3] or for Xml databases
[4, 5, 6]. Here, Mso can be used both as a query language and as a schema
language. Unordered data trees also have a long history for modeling syntactic
structures in computational linguistics [7] and records in programming languages
[8, 9, 10]. The unordered data trees in this context were called feature trees and
the corresponding logics feature logics [11, 12]. Our own motivation is to model
ﬁle systems, i.e. trees representing directories, ﬁles names, their contents etc.

Yet, so far, Mso for unordered trees has been studied without data, that is
over ﬁnite alphabets. The two main variants of Mso for unordered trees that
were proposed are Presburger Mso and Counting Mso [4, 5, 6]. Both logics
were proven decidable by reduction to corresponding notions of automata for
unranked trees. The weaker logic, Counting Mso or CMso for short, is consid-
ered a canonical language for characterising recognizable sets, and is actually
equivalent to Mso in the case of ordered trees or words [13]. In this present
paper, we generalize CMso to unordered data trees with arbitrary ranks, and
study the expressiveness of the resulting logics.

The most general extension of CMso would enable comparisons of data values
between arbitrary locations, but this immediately leads to undecidability. In-
deed even Mso on data words with equality tests between the data values of
arbitrary positions is undecidable [14] since it can be reduced to Mso on grids,
for which undecidability is folklore [15]. The situation is even worse, in that
even the ﬁrst-order logic of data words with equality tests is undecidable [16].
One therefore needs to ﬁnd suitable restrictions, avoiding the case of data words.
The most important restrictions for decidability are:

(1) Limiting comparisons of data values to sibling positions only. With this,
each level of the tree can be seen as a multiset of data values, so that the nub
of the problem becomes handling CMso for such multisets.

(2) Disallowing for string comparisons that deal with factors of strings, or
equivalently, suﬃxes and preﬁxes at the same time.

We shall see that CMso for multisets of strings remains decidable even when
allowing for equality tests of data values up to constant suﬃxes.

Contributions. Our contributions are as follows:

(cid:5) We introduce the logic CMso(Θ) for unordered data trees by extending
Counting Mso on unordered trees with comparisons of sibling data values.

2

Which speciﬁc comparisons are allowed for is deﬁned by a set Θ of relations
between data values, which is a parameter of the logic. In particular, we
can choose Θ such that it provides only equality tests on data values.
(cid:5) We show that satisﬁability of CMso(Θsuﬃx) is decidable, where Θsuﬃx only
deals with relations between suﬃxes. This includes the special case of data
equality tests. (The same applies symmetrically to CMso(Θpreﬁx), dealing
only with preﬁxes.) In fact, we show more generally that CMso(ΘWSkS) is
decidable, where ΘWSkS is the set of all relations deﬁnable in weak monadic
second-order logic of k successors.

(cid:5) To ﬁnd out whether it is possible to loosen the limitation to data compar-
isons between siblings, we extend CMso(Θid) – testing only data equality
between siblings – with equality of data values between uncles and nephews.
However, we show that satisﬁability for this logic becomes undecidable.
The same applies with equality of data between cousin positions.

(cid:5) We next show that satisﬁability of CMso(Θpreﬁx+suﬃx) is undecidable,
where Θpreﬁx+suﬃx provides functions that add or remove letters at the
beginning or the end of data words. More generally, comparison of both
preﬁxes and suﬃxes, and similarly, comparisons of factors of data values,
lead to undecidability.

(cid:5) We show that, if the relations Θ only transform one suﬃx into another
(e.g. ".tex" to ".pdf"), for a ﬁxed ﬁnite set of suﬃxes none of which is
another’s suﬃx, then we can use counting constraints with data tests
between siblings in the transitions of an appropriate model of bottom-up
automata, and get an implementation with tractable complexities for empti-
ness: PSpace in the case of deterministic automata – and NExpTime
in general. Furthermore, the method is extended to support structural
equality and disequality constraints between siblings, still in NExpTime.

Those results are a net positive for our targeted applications. For example, an
important property which we need to model is whether source ﬁles have been com-
piled, e.g. "mybook.tex" to "mybook.pdf". Of course any other PDF ﬁle is irrelevant
wrt. "mybook.tex", so this is an instance of checking equality of data values, up to
suﬃxes. Such properties are expressible in CMso(Θsuﬃx) – and thus decidable –
so long as compilation is done in the same directory as the source, and all but a few
artiﬁcial counterexamples fall in the special case that can be handled eﬃciently.
We now clarify the ways in which counting constraints serve our applications.

Counting in Data Trees: Intuitions. Using unordered trees means expressing and
evaluating properties on sets – or multisets – of elements, e.g. the data values of
the children at the current position. Naturally, this amounts to counting: for in-
stance in a ﬁle tree “there are at least 2 values that match *.txt” (where * matches
any string), or in a bibliographical database “there are fewer values of type in-
proceedings than there are books”. Where the existing approaches diﬀer is in the
expressive power available for that counting; for instance, it may be possible to

3

compare two variable quantities – as in the second example – or just one variable
quantity and a constant – as in the ﬁrst. This is the main diﬀerence of expressiv-
ity between Presburger constraints and the simpler counting constraints. In all
cases, however, each element is considered alone, in isolation from its brothers.

We previously studied the complexity of decision problems for automata using
various such formalisms as guards for their bottom-up transitions in [17]. The
focus was on devising good notions of deterministic machines capable of execut-
ing such counting operations, suﬃciently expressive while allowing for eﬃcient
algorithms. Our present focus, in contrast, is to extend the expressive power of
the counting formalisms, while preserving decidability. Since the yardsticks of
expressive power for counting tests are logics, this paper mostly deals directly
with second-order logics rather than automata.

Our main goal in this paper is to extend existing formalisms with the ability
to express data constraints on unordered data trees, so that each data value
may be considered not only in isolation, but also along with sibling values to
which it is related. Such constraints arise naturally in various circumstances,
and we shall see that considering only sibling values is a practical restriction,
in the sense that it makes it easier to obtain decidable logics.

By way of example, consider a directory containing LATEX resources, which may
be represented by an edge-labelled tree in the style of Figure 1, given in Json
(JavaScript Object Notation) syntax, where each data value corresponds to a
ﬁle name or, in the case of leaves, ﬁle contents.

{ "file.tex" : {"\documentclass...":{}},

◦

"dir" : {

"x.png" : {"<bin>":{}},

"y.png" : {"<bin>":{}},

...} ... }

ﬁle.tex

◦

\doc...

◦

dir
◦

x.png
◦

y.png
◦

<bin>

◦

◦

<bin>

Figure 1: Unordered trees in Json format, describing a typical ﬁle tree.

Suppose that we want to specify that the contents of a LATEX repository has been
properly compiled, which is to say that for every main LATEX ﬁle – i.e. a ﬁle whose
name has suﬃx ".tex", and whose contents begin with "\documentclass" – there
exists a corresponding pdf ﬁle whose contents starts with a header declaring
adherence to version 1.5 of the PDF standard. To express this property, sibling
data values – here representing ﬁles in the same directory – are put in relation
by θtex2pdf = { (w".tex", w".pdf") | w is a word }. In other words, the constraint
which is expressed is of the form “any value d whose subtree satisﬁes some prop-
erty P has a brother d0 = θtex2pdf(d) whose subtree satisﬁes another property P 0”.

We need to integrate this kind of data constraints in existing formalisms for
unordered trees; the two yardsticks of expressive power that have emerged in the

4

◦

d1
◦

d1
◦

◦

d1
◦

d1
◦

◦

d1
◦

d1
◦

◦

d1
◦

d1
◦

d3

d1

d2

d3

d2

d1

d1

d2

d3

d2

d1

d3

◦

◦◦

◦

◦◦

◦◦

◦

◦◦

◦

Figure 2: Drawings of {| d1 : {| d3 : {| |} |}, d1 : {| d1 : {| |}, d2 : {| |} |} |} with all edge orders.

literature are the extensions of monadic second-order logic (Mso) by horizontal
Presburger constraints [4], and by the weaker, but more tractable, counting
constraints [18]. The latter is capable of expressing that the cardinality of a
set variable is less than m or equal to m modulo n, but not of comparing the
cardinalities of two set variables directly, unlike Presburger logic.

We choose Mso with counting constraints as our starting point, and add the
capability to express data relations.

Related work. This paper combines work on unordered trees and the associated
automata and logics, as in [4, 5, 6], with questions about data values that are
closely related to problems studied in the databases community for register
automata, ﬁrst-order logic, and XPath, [16, 19], among others. The upshot of
the existing work is that, in the ordered case, even the mere ability to express
equality between data values renders very simple logics intractable or undecid-
able. For instance, on data words, Mso with equality tests is undecidable, and
even the very simple logic F O2(∼, +1, <), i.e. ﬁrst-order logic with two variables
and successor and linear order relations, with data equality tests, while still
decidable, is not known to be primitive recursive, and is at least as hard as
reachability for Petri nets [16]. As it turns out in this paper, the unorderedness
of our data trees actually simpliﬁes the handling of the data values.

2. Data trees and CMso(Θ)

2.1. Data Trees

A data alphabet is a ﬁnite set A. A data value over A is a string in A∗. The trees
under consideration are ﬁnite, unordered, unranked trees whose edges are labelled
by data values in A∗. Formally, a tree t is a multiset {| (d1, t1), . . . , (dn, tn) |}
where d1, . . . , dn ∈ A∗ and t1, . . . , tn are trees. The data value di is the label of
the edge leading into the subtree ti. We generally take a Json-like record nota-
tion {| d1 : t1, . . . , dn : tn |}. Those trees can be represented by the usual graphs,
discounting order: see Figure 2. The tree representing the Json document
of Fig 1 is therefore {| ("ﬁle.tex", {| ("\doc...", {| |}) |}), ("dir", . . . ) |}. To simplify the

5

formalisation, we shall not consider edges as distinct objects, but instead see an
edge label as a property of the node into which the edge leads. Furthermore,
though the tree itself is deﬁned as a multiset, its nodes form a set (through any
arbitrary ordering). Thus we represent t by a structure hVt, ‘t, ↓ti, where Vt is
the set of nodes of t, ‘t(v) is the data value labeling the edge leading into the
node v – undeﬁned for the root node, – and v ↓t v0 holds if v0 is a child of v.
For our convenience, we also deﬁne the “sibling-or-self” relation:

t v0 ⇔ v = v0 ∨ ∃v00 . v00 ↓t v ∧ v00 ↓t v0 .

(1)

v

(cid:36)(cid:37)

By extension of the language of terms and ranked trees, we use the word arity to
refer to the set of children of a node v in a tree t, which we denote by ar(t, v).

2.2. CMso(Θ)

Mso(Ψ). Let A be a data alphabet and X a countable set of variables of two
types, node variables and set variables. A variable assignment I into some tree
t will map any node variable x ∈ X to a node I(x) ∈ Vt and any set variable
X ∈ X to a set of nodes I(X) ⊆ Vt.

As a parameter of our logic we assume a set Ψ of formulæ called node selectors,
which may contain letters from A and variables from X . The only assumption
we make is that any node selector ψ ∈ Ψ deﬁnes for any tree t and variable
assignment I into t a set of nodes
t,I ⊆ Vt. For instance, we could choose
(cid:75)
formulæ ψ ::= π | _ ↓ x, for regular expressions π and node variable x, such that
t,I = {v | ‘t(v) matches π} is set of all nodes whose incoming edge is labeled
π
(cid:74)
by a word in A∗ that matches regular expression π, and
t,I = {v | v ↓t
I(x)} is the set of nodes of which I(x) is a child. The formulæ of MSO over Ψ are:

_ ↓ x
(cid:74)

ψ

(cid:75)

(cid:74)

(cid:75)

ξ ∈ Mso(Ψ)

::= x ∈ ψ | x ∈ X | ∃x . ξ | ∃X . ξ | ξ ∧ξ | ¬ξ ,

(2)

where ψ ∈ Ψ. Whether a formula is true for a given tree t and variables as-
signment I into t is deﬁned in Figure 3. As syntactic sugar, we shall freely use

t, I |= x ∈ ψ

t, I |= x ∈ X

t, I |= ∃x . ξ

t, I |= ∃X . ξ
t, I |= ξ ∧ ξ0

t, I |= ¬ξ

⇔

⇔

⇔

⇔

⇔

⇔

ψ

I(x) ∈

t,I ,
(cid:75)
(cid:74)
I(x) ∈ I(X) ,
t, I[x 7→ v] |= ξ for some v ∈ Vt ,
t, I[X 7→ V ] |= ξ for some V ⊆ Vt ,
t, I |= ξ ∧ t, I |= ξ0 ,
t, I (cid:19)(cid:19)|= ξ .

Figure 3: Semantics of Mso(Ψ).

the usual additional logical connectives and set comparisons that can be easily

6

encoded, i.e. formulæ ∀x.ξ, ∀X.ξ, ξ ⇔ ξ0, ξ ⇒ ξ0, as well as X ⊆ X 0, X = ψ,
and ψ = ∅.

Children Counting Constraints: CC(Φ). Here we deﬁne node selectors
given other node selectors Φ. A children counting constraint selects a node of
a tree by testing the number of its children satisfying some property. Which
properties can be tested is deﬁned by the parameter Φ. As before, we use as
parameter a set of node selectors Φ such that
t,I ⊆ Vt is deﬁned for all φ ∈ Φ.
A counting constraint over Φ is a formula with the following syntax, where φ ∈ Φ
and n, m ∈ N:

φ

(cid:74)

(cid:75)

γ ∈ CC(Φ)

::= #φ (cid:54) n | #φ ≡m n | γ ∧ γ | ¬γ .

(3)

The ﬁrst two kinds of formulæ can test whether the number of children satisfying
φ is less or equal to n or equal to n modulo m. Note that we cannot write
#φ (cid:54) #φ0, though this is possible in the richer class of Presburger formulæ.

Any counting constraint γ deﬁnes a set of nodes
I to t, so counting constraints themselves can be used as node selectors:

t,I for any variable assignment

γ

(cid:75)

(cid:74)

#φ (cid:54) n
(cid:74)
#φ ≡m n
(cid:74)
γ ∧ γ0
¬γ

(cid:74)

(cid:74)

(cid:75)
(cid:75)
(cid:75)
(cid:75)

t,I = { v ∈ Vt | Card({ v0 | v ↓t v0 ∧ v0 ∈
t,I = { v ∈ Vt | Card({ v0 | v ↓t v0 ∧ v0 ∈
t,l,
t,I =
(cid:75)
t,I = Vt \

t,l ∩
γ

γ

(cid:75)

(cid:74)

γ0
(cid:74)
t,l.
(cid:75)

(cid:74)

t,I }) (cid:54) n },
t,I }) ≡m n },

φ
φ

(cid:74)
(cid:74)

(cid:75)
(cid:75)

(4)

Note that we can deﬁne #φ (cid:62) n as syntactic sugar for ¬(#φ (cid:54) n − 1), and
#φ = n as syntactic sugar for #φ (cid:62) n ∧ #φ (cid:54) n.

Counting MSO with comparisons of sibling data values: CMso(Θ).
We can now deﬁne the logic we are interested in. As before we assume a set
of variables X and a data alphabet A. In addition, we ﬁx a set Θ of binary
relations on A∗ that are called string comparisons. We then deﬁne a set of node
selectors with regular expressions for matching data values and comparisons of
sibling data values from Θ. Such a node selector has the following syntax where
θ ∈ Θ, π is a regular expression over A, and x, X ∈ X :

φ ∈ Φrel(Θ)

::= π

incoming edge label matches π,

| x | X

| θ.φ

equal to x or member of X,

∃ sibling satisfying φ with labels related by θ,

| φ ∧ φ | ¬φ conjunction and negation.

The sets of selected nodes are deﬁned as follows for formula φ ∈ Φrel, any tree

7

t and variable assignment I into t:

π

(cid:74)

(cid:75)
x
(cid:75)
(cid:74)
θ.φ
(cid:74)
(cid:75)
φ ∧ φ0

(cid:75)

(cid:75)

¬φ

(cid:74)

(cid:74)

t,I = {v | ‘t(v) matches π}
t,I = {I(x)}
t,I = {v | ∃v0 . v
φ0
t,I =
φ
(cid:75)
t,I = Vt \

t,I ∩
φ

(cid:36)(cid:37)
t,I
(cid:75)

(cid:74)

(cid:74)

(cid:74)
t,I
(cid:75)

(cid:74)

t,I = I(X)

X
(cid:75)
t v0 ∧ (‘t(v), ‘t(v0)) ∈ θ ∧ v0 ∈

t,I }

φ

(cid:74)

(cid:75)

Deﬁnition 1. We deﬁne the children counting contraints for data trees with
comparisons of data values CC(Θ) by CC(Φrel(Θ)) and the counting MSO for
data trees with comparison of sibling data values CMso(Θ) by Mso(CC(Θ)).

Note that the childhood relation x ↓ x0 can be deﬁned in CMso(Θ) by x ∈ (#x0 =
x0 can
1) independently of the choice of Θ. Hence, sibling-or-self contraints x
also be deﬁned by x = x0 ∨ ∃x00. (x00 ↓ x ∧ x00 ↓ x0) for any Θ. The elements of
Θ intervene only if one wants to compare the data values of sibling nodes.

(cid:36)(cid:37)

It is relevant to note that this is not the only way a CMso logic can be de-
ﬁned: as explored in previous literature [5], Mso can be enriched with counting
constraints on individual arities or, equivalently, on the whole tree. This equiva-
lence does not hold true for all Mso enrichment: for example, PMso is deﬁned
with Presburger constraints on arities. We choose to parametrize the counting
constraints as test in the arities. One of the advantage of this choice is that it
ties into one of our previous publications [17] where we create automata classes
parametrized by their arity constraints.

Example 1. Recall now the earlier motivating example, given the representa-
tion of ﬁle trees illustrated by Figure 1[p4]: specify that the contents of a LATEX
repository has been properly compiled, which is to say that for every main LATEX
ﬁle – i.e. a ﬁle whose name has suﬃx ".tex", and whose contents begins with
"\documentclass" – there exists a corresponding pdf ﬁle whose contents begins
with a pdf 1.5 header.

As mentioned before, the requirements regarding the contents of the ﬁles are
properties of subtrees or, equivalently, of nodes. Let us brieﬂy assume that those
nodes are captured by the set variables Xdoc and Xpdf15, containing the nodes
satisfying the “main TEX ﬁle” and “valid pdf” properties, respectively.
A TEX main document (resp. a valid pdf version 1.5) is represented by a
node with a single outgoing edge, whose label is preﬁxed by "\documentclass"
(resp. "%PDF-1.5"), leading to a leaf. For instance, we would expect the following

8

annotations:

◦

. (5)

"chapter.tex"

"Book.tex"

"Book.pdf"

◦

◦ ∈ Xdoc

◦ ∈ Xpdf15

"Blah blah"

"\documentclass..."

"%PDF-1.5..."

◦ ∈ Xleaf

◦ ∈ Xleaf

◦ ∈ Xleaf

Then we can write

∀x . x ∈ (#[∗".tex" ∧ Xdoc ∧ ¬θtex2pdf.Xpdf15] = 0) .

(6)

There now remains to complete the formula by deﬁning Xdoc and Xpdf15 formally:
this yields the following CMso({ θtex2pdf }) sentence, capturing the desired spec-
iﬁcation:

∃Xleaf . ∃Xdoc . ∃Xpdf15 .
Xleaf = (cid:0)#[∗] = 0(cid:1)

∧ Xdoc = (cid:0)#[∗] = 1 ∧ #["\documentclass" ∗ ∧ Xleaf] = 1(cid:1)
∧ Xpdf15 = (cid:0)#[∗] = 1 ∧ #["%PDF-1.5" ∗ ∧ Xleaf] = 1(cid:1)

∧ ∀x . x ∈ (#[∗".tex" ∧ Xdoc ∧ ¬θtex2pdf.Xpdf15] = 0) .

3. Satisﬁability of CMso(ΘWSkS) is Decidable

We shall now see that Θ can be made rather large and useful without endangering
decidability (so long as the pitfalls studied in the next sections are avoided).
Indeed, the most frequent operation in applications, illustrated in particular by
the running TEX compilation example, is suﬃx replacement. The property that
we really need is thus decidability of satisﬁability for CMso(Θsuﬃx), where the
relations of Θsuﬃx are of the form θu,u0 = { (wu, wu0) | w ∈ A∗ }, for u, u0 ∈ A∗.
We show decidability for a class which is actually more general: WSkS-deﬁnable
relations.

3.1. Preliminaries: WSkS

The well-known logic Weak Monadic Second-Order Logic with k Successors
(WSkS) [20], for any k (cid:62) 1, is the weak Mso on the signature containing the
constant symbol ε and the unary function symbols 1, 2, . . . , k, written in postﬁx
notation. That is to say, the terms are given by

τ

::= (cid:15) | z | τ i

where 1 (cid:54) i (cid:54) k .

(7)

9

For instance ε41234 is a term of WSkS, for k (cid:62) 4. The domain of interpretation
is the set of words of { 1, . . . , k }∗, in the straightforward way: the constant (cid:15)
denotes the empty word, and each of the functions i, written in postﬁx notation,
denotes appending the symbol i at the end of a word. The term ε41234 is thus
interpreted as the word 41234. The logic is called “weak” because it is restricted
to quantiﬁcation over ﬁnite sets.

Since we shall handle both WSkS and CMso(Θ) at the same time – in fact
encoding one into the other – we shall suppose that they use diﬀerent variables,
and take the convention that WSkS ﬁrst-order variables are written z or some
variant thereof, and second-order variables Z – the set of all variables is likewise
written Z.

Validity and satisﬁability of formulæ in WSkS are decidable [21], albeit with a
non-elementary complexity [22]. WSkS has previously been shown equivalent
in expressive power to Mso and ordering constraints over feature trees [23].
Some useful relations expressible in WSkS are z (cid:54)pref z0 (preﬁx partial order
on words), z (cid:54)lex z0 (lexicographic total order on words), z ∈ π for any regular
expression π, Z ⊆ Z 0, Z = Z 0 ∪ Z 00, Z = Z 0 ∩ Z 00, Z = Z 0 (complement), Z = ∅,
|Z| ≡n m for any constants n, m. Most of those are shown in [24, p88].

The unary predicates on words deﬁnable in WSkS are precisely the regular sets
[25, 26]. A binary relation R ⊆ { 1, . . . , k }∗ × { 1, . . . , k }∗ is called special if it is
of the form { (ab, ac) | a ∈ L, b ∈ M, c ∈ N } for some regular sets L, M , and
N . A binary relation on words is deﬁnable in WSkS iﬀ it is a ﬁnite union of
special relations [26].

Some relations which are known not to be expressible in WSkS are z = z0z00,
z = iz0, z is a suﬃx of z0, z and z0 have the same length, Z and Z 0 have the
same cardinality. Let us note that what is deﬁnable largely includes the kinds
of speciﬁcations about suﬃxes which we need for applications and, conversely,
that the dangerous properties highlighted in the next section are not expressible:
one cannot handle suﬃxes and preﬁxes at the same time.

3.2. Showing Decidability of CMso(ΘWSkS)

Let ΘWSkS be the set of WSkS-deﬁnable relations on strings on the alphabet
A, with the letters of A taken as successor functions, along with fresh letters $
and /, not in A; we show the decidability of CMso(ΘWSkS) by encoding this
logic into WSkS itself. This is an indirect way to encode it into automata, as
WSkS’s own decidability is obtained by such an encoding.

We adopt a convention to encode nodes and edge labels as strings handled by
WSkS. For that purpose, / acts as a separator and $ as an additional symbol
to distinguish multiple instances of the same label within an arity; recall that
we have multisets of labels, yet need to deal with them in a logic – WSkS –
acting on sets. Following this convention, a tree is encoded by a set of strings,

10

t =

◦

f

◦

f

a

◦

◦

g

b

◦

t = { ε, f /, f $/, f $/a/, g/, g/b/, g/b$/, g/c/ } (8)

◦

◦

b

c

◦

Figure 4: Encoding a tree as a set of WSkS strings.

as illustrated on an example by Figure 4. Formally, the encoding t of a tree
t = {| d1 : t1, . . . , dn : tn |} is deﬁned as follows:

t = {ε} ∪

n

di$mult(t,i,di)/e

(cid:12)
(cid:12)
(cid:12) i ∈

1, n
(cid:75)

(cid:74)

, e ∈ ti

o

,

(9)

where the mult function counts how many identical data values have previously
been encountered: mult(t, i, d) = |{ k ∈
| dk = d }|. The encoding of
the tree t also establishes, in the obvious way, the encoding v of the nodes v ∈ Vt,
and the encoding of a set of nodes – it is the set of the encodings.

1, i − 1
(cid:75)

(cid:74)

At this point, let us note that a given tree t might have several equivalent
alternative encodings, depending on the order in which the children sharing a
label are distinguished by additional $s. All of those describe the same structure
and would be equally valid. Those variations in encoding are of no consequence
for the satisﬁability of the formulæ which we develop, as every predicate that
follows will ignore the number of $. To avoid any confusion as to the nature of
the object t, we ﬁx an arbitrary total order on trees (and pairs of data values
and trees) so that the decomposition t = {| d1 : t1, . . . , dn : tn |} is unique, and
use speciﬁcally the encoding (9) deﬁned above to assign $s. Thus t refers to that
one encoding among the other possibles.

We now encode the father/child relation, getting the arity of a node, and
checking that a given set of strings describes a valid tree structure. The
child relation is expressible in WSkS: take the special relation ↓ ≡ { (a, ab)
| a ∈ ((A∗$∗)/)∗, b ∈ A∗$∗/ }. Note that ((A∗$∗)/)∗ matches the possible path
preﬁxes, and A∗$∗/ the last data value, if available, along with the distinguishing
$s and separator / which we can expect to ﬁnd along with it if the strings are
well-formed node encodings. Then we have the encoding for the child relation:
v ↓t v0 ⇔ v ↓ v0, and from there, we can test whether a given set variable Z
describes a correct tree structure, by making sure that every node coded into
that set has a father there, except for the root node, which does not:

istree(Z) ≡ ∀z . z ∈ Z =⇒ ( z = ε ∨ ∃z0 . z0 ∈ Z ∧ z0 ↓ z ) .

Of course, we are now able to extract the arity of a node – here deﬁned as the set
of its children nodes – for the purposes of evaluating counting constraints. The

11

predicate ar(t, z, Z) tests that Z is the arity of node z in the tree encoding
t: ar(t, z, Z) ≡ ∀z0
. z0 ∈ Z ⇔ (z ↓ z0 ∧ z0 ∈ t). Note that it relates
to the arity function on trees in the following way, given a tree t, a node
v ∈ Vt and a variable assignment I: ar(t, v, Z) ⇐⇒ ar(t, v) = I(Z). Variable
assignments are encoded in the obvious way, given that to each variable x or X
we associate a WSkS variable x or X: { . . . , x 7→ v, X 7→ V, . . . } ≡ (cid:8) . . . , x 7→
v, X 7→ V , . . . (cid:9). We can now begin by encoding any child-selector φ as a
WSkS formula φ with free variables z, Z (standing for the current node and
its arity), such that for any tree t, interpretation I, and nodes v0 ↓t v: t, I, v |=
φ ⇐⇒ I[z 7→ v, Z 7→ ar(t, v0)] |= φ. Recall that π ⊆ A∗, and that all regular
expressions are expressible in WSkS; we have π ≡ ((A∗$∗)/)∗π$∗/. Likewise
for relations θ; since they are WSkS-deﬁnable, they are ﬁnite unions of special
relations, which are of the form S = { (ab, ac) | a ∈ L, b ∈ M, c ∈ N }, where
L, M, N ⊆ A∗ are regular languages. The encoding of such a special relation is
S ≡ { (ab, ac) | a ∈ ((A∗$∗)/)∗L, b ∈ M $∗/, c ∈ N $∗/ }. The encoding θ of θ is
the union of the encodings of the special relations composing θ. Using this, the
encoding of ﬁlters becomes trivial.

We move on to handling counting constraints ψ, which is simply a matter of
showing that WSkS can encode the primitives |Z| (cid:54) m – which is easy – and
|Z| ≡n m – which rests on a total order such as the lexicographic one, and on the
idea of aﬀecting each element in turn to a second-order variable corresponding
to the value of the modulo. Those methods are folklore.
There remains to encode the Mso layer, with Zt being the free variable stand-
ing for a tree encoding; the only non-trivial case is x ∈ ψ ≡ ∀z, Z .
z =
x ∧ ar(Zt, z, Z) ⇒ ψ. Through this encoding, ξ is satisﬁable if and only if
istree(Zt) ∧ ξ is.
Theorem 1. Satisﬁability of CMso(ΘWSkS) is decidable.

4. The Frontiers of Decidability

As mentioned before, our decidability results for CMso(ΘWSkS) are dependent on
two kinds of limitations: restrictions of the scope of data comparisons to siblings,
and of the expressive power of the string comparisons themselves, disallowing for
joint manipulations of suﬃxes and preﬁxes. In this section, we shall see that at-
tempts to relax those constraints, even slightly, quickly yield undecidable logics.

4.1. Data tests beyond siblings: uncles/nephews & cousins

We will show that data equality tests between uncles and nephews lead to a
Mso logic where satisﬁability is undecidable.
Equality tests between uncles and nephews. We deﬁne the logic Msouncle
(CC(Θid)) – abbreviated into CMsouncle(Θid), where Θid = {θid}, θid being the

12

equality relation over A∗, and add a new atom at the level of Mso statements,
which is to say that statements ξ are as given before, with the following addition
to the syntax:

ξ ∈ Msouncle(Ψ)

::= . . .

| x ∼uncle y .

Intuitively, x ∼uncle y tests two things: (1) the node x is an uncle of y, and (2)
the data values of x and y are equal. Formally, the semantics is deﬁned as:

t, I |= x ∼uncle y ⇔ ‘t(I(x)) = ‘t(I(y)) ∧ ∃z . (x

t z)∧(z 6= x)∧(z ↓t y) .

(cid:36)(cid:37)

Note that this is less general than having a general data equality test x ∼ y,
since the positional uncle/nephew relation can be expressed inside the logic itself.
However, this is still a comparison of data values in diﬀerent arities. Even that
restricted power leads CMsouncle(Θid) to have undecidable satisﬁability.

xqini

xq ∈ Xq

ain

ai1

#

bj1

bjm

bjm+1

∅

x

...

xq0 ∈ Xq0

∼uncle

∼uncle

∼uncle

ain+1

ain

ai1

#

bj1

z

y

...

Xq00

xqﬁn

∼uncle

bjm

...

...

∼uncle

∼uncle

∅

Figure 5: Using uncle/nephew data equality tests to encode accessibility in a Minsky machine.
The dotted lines indicate constraints between data values. The dashed lines indicate omitted
steps.

Theorem 2. Satisﬁability is undecidable for CMsouncle(Θid).
Proof. We proceed by reduction of the accessibility problem for a Minsky
machine M with a set of states Q and two non-negative counters c1, c2. Rules of
a Minsky machine go from one state to another, and can increment/decrement
c1 or c2, test if the current value of c1 or c2 is 0, or any combination of these
q0 is a rule that executes if c1 = 0, going
actions. For example, q

c1++,c2−−
−−−−−−−→
c1=0

13

from a state q to another state q0, incrementing c1, and decrementing c2. To
simplify our proof, we make some basic assumptions about M . The starting
conﬁguration is qini(c1 = 0, c2 = 0), and qini cannot be visited again. We want
to know if a state qﬁn is accessible.
We give an intuition on how to build the formula of CMsouncle(Θid) satisﬁed by
trees describing runs of the Minsky machines, terminating in qﬁn. The tree which
we describe follows the schema of Figure 5. The set variables Xq store the “spine”
nodes of the tree. Each spine node belongs to exactly one set Xq, corresponding
to a state q of our Minsky machine. It has three types of children: ones labeled
by diﬀerent words of a+, ones labeled by diﬀerent words of b+, and the following
spine node, labeled #. The value of the ﬁrst counter c1 is encoded by the number
of distinct a+-children a node has. Similarily, the value of c2 is encoded by the
number of b+-children a node has. To ensure that all words of a+ and b+ are dis-
tinct, we can say that all nodes of any Xq should satisfy (#[x ∧ θid.¬x] (cid:62) 1) = ∅.

The root node is xqini, the only element of Xqini, and has only the next spine
node as a child since c1 and c2 start at 0. We stop the run as soon as xqﬁn , the
only node of Xqﬁn, is reached. Going one level down in the tree is the same
as using a rule in M . To ensure that we keep track of the counter’s values, we
use ∼uncle. For example, imagine two consecutive nodes of the spine: xq ∈ Xq,
c1++,c2−−
−−−−−−−→ q0, a rule of M . We must ensure that
its child xq0 ∈ Xq0, and q
xq has exactly one fewer a+-child than xq0, and exactly one more b+-child. To
this end, we ensure that if x is an a+-child of xq, which can be expressed as
xq ∈ (cid:0)#[a+ ∧ x] = 1(cid:1), then it has a nephew y of same label. Conversely, every
a+-child of xq0 has an uncle of same label except for a unique z.

∀ x . xq ∈ (cid:0)#[a+ ∧ x] = 1(cid:1) ⇒ (∃ y . x ∼uncle y) ∧
∃ z . xq0 ∈ (cid:0)#[a+ ∧ z] = 1(cid:1) ∧ ¬∃ z0 . z0 ∼uncle z ∧

∀ y0 . z 6= y0 ∧ xq0 ∈ (cid:0)#[a+ ∧ y0] = 1(cid:1) ⇒ ∃ x0 . x0 ∼uncle y0

Symmetrically, we can ensure that xq0 has one more b+-child than xq. Should
a transition of M have a guard c1 = 0, one can easily check that a node has no
a+-child.

To model a run, we say that each node of the spine leads to the next one using
a rule of M , until qﬁn is reached, which is to say that Xqﬁn is not empty. Such
a tree exists if and only if there exists a run from qini(c1 = 0, c2 = 0) that
reaches qﬁn in M . Note that there may appear, in the solution trees, nodes not
represented in Figure 5; they simply have no role to play in the construction
and do not aﬀect the formula’s satisﬁability.
As has been noted before, this also entails the undecidability of a logic CMso∼(Θid)
equipped with a data equality test x ∼ y between arbitrary positions, as this is a
strictly more powerful logic. The construction above can also straightforwardly be
adapted to show undecidability of extensions with variants of x ∼uncle y, such as
data equality with great-uncles etc. The factors which make the argument work

14

are, in general terms, the ability to regroup the Xu and Xv into arities to modify
them simultaneously, and to move the resulting information from arity to arity.

root

#

#

#

#

xqini

. . . . . . .

xq ∈ Xq

xq0 ∈ Xq0

. . . . . . .

xqﬁn

ckini

ck

ain bjm+1
. . . . .

ck0
z

ck0
z0

∼cous

∼cous

∼cous

c1 + +, c2 − −

ain+1

bjm

. . . . .

ck00

ckﬁn

∼cous

∼cous

Figure 6: Using cousin data equality tests to encode a Minsky machine run. The dashed
curve “c1 + +, c2 − −” indicates that the relation between a+ and b+ children in the two linked
arities is the same as in Figure 5, encoding the same incrementation/decrementation rule.

Equality tests between cousins. To illustrate this fact, another variant that
is also undecidable is CMsocousins(Θid), deﬁned as CMsouncle(Θid) but this
time, with a data equality test ∼cous between cousins instead of uncles and
nephews. The proof – again, an encoding of a Minsky machine – is extremely
similar to the previous one, and we shall present it more brieﬂy.

As illustrated in Figure 6, the idea is again to use accessibility in a Minsky ma-
chine M with two counters c1, c2, under the same assumption as previously, plus
c1++,c2−−
−−−−−−−→ q0
a new constraint: there are no two reverse rules. For example, if q
is a rule of M , then q0 c1−−,c2++

−−−−−−−→ q is not a rule of M .

The tree we consider is of height two. The set variables Xq cover the children
of the root, labelled by #. Each of these nodes represent a step of the Minsky
machine. Just like previously, each node of Xq has a number of a+-children rep-
resenting c1, and a number of b+-children representing c2. The trick to this proof
is to ensure that these conﬁgurations can be sequenced into a run. While ∼uncle
made this possible thanks to the spine being read from the root to the leaves, it
is not as easy in the case of unordered cousins. To this end, we place identiﬁers
in the form of nodes labeled by words of c+. If two nodes xq ∈ Xq and xq0 ∈ Xq0
represent consecutive steps in a run of M , then they share cousins of same label
ck, that never appears elsewhere. Each step is linked to both its previous and
next neighbour, meaning each node of any Xq has two c+-children, except for
the ﬁrst element (of Xqini ) and the last element (of Xqﬁn), that only have one.
The following formula ensures that any c+-child z can only be matched to one

15

other cousin of same label.

∀ z . ∃x ∈ (cid:0)#[c+ ∧ z] = 1(cid:1) ⇒ ∃ z0 . z ∼cous z0 ∧ ¬∃ z00 6= z0 . z ∼cous z00

From there it is easy to see if xq and xq0 are consecutive:

∃ z, z0 . xq ∈ (cid:0)#[c+ ∧ z] = 1(cid:1) ∧ xq0 ↓ z0 ∧ z ∼cous z0

The encoding of two successive conﬁgurations is the same as above. Note
that forbidding reverse rules implies that no confusion is possible as to which
conﬁguration comes before which.

Note that, perhaps counter-intuitively, these proofs would not work by the
combination of our usual data tests between siblings and a new data equality
test between father and son, which we could deﬁne as follows:

t, I |= x ∼father y ⇔ ‘t(I(x)) = ‘t(I(y)) ∧ x ↓t y .

(10)

The reason this could not work is that we need several equality tests between
one level of Figure 5 and the next. The father can use its label to propagate an
equality test for one of these elements, but not for all at the same time. For that
reason, the constructions above do not in themselves preclude the decidability
of an extension like CMsofather(Θid). Determining whether it is decidable, and
if so, if it would remain decidable with larger Θ, is an open problem.

4.2. Expressive power of data tests

In this section, we exhibit conditions on the expressive power of the class of
data constraints Θ suﬃcient to render satisﬁability for CC(Θ), and therefore
for CMso(Θ), undecidable. As we shall see, not much is needed. Even merely
allowing Θ to express the addition or removal of a single letter at the beginning
or end of a word is enough; the argument developed in the next theorem is that
even this is suﬃcient to encode the solution of the Post Correspondence Problem.

Theorem 3. Let Θpreﬁx+suﬃx be the set of string relations of the forms w 7→ wa,
w 7→ aw, wa 7→ w, or aw 7→ w, with a ∈ A, w ∈ A∗. Then CMso(Θpreﬁx+suﬃx)
is undecidable.

Proof. We reduce the Post Correspondence Problem, with input dominoes
[ u1
v1 ], . . . , [ un
vn ]. Let us write the relations in Θpreﬁx+suﬃxas θ+a, θa+, θ−a, and
θa−, respectively. Given a word w = a1 . . . am, by abuse of notation we ab-
breviate θ+a1. . . . θ+am.φ into θ+w.φ. Although Θpreﬁx+suﬃxis not closed by
composition, this construction enables us to pretend that it is – the diﬀerence is
that it requires the existence of siblings for each intermediate step, which does
not aﬀect us. θw−.φ is deﬁned likewise. θam+. . . . θa1+.φ is written θw+.φ, and
likewise again for θ−w.φ.
Let $1, $2 ∈ A be fresh symbols not appearing in any domino, serving as markers
for the ﬁrst and the second phase of the construction. Informally, in the ﬁrst

16

phase, we place dominoes so that each u mirrors the corresponding v; in the
second phase, we consume the result letter by letter, from both ends simulta-
neously, until everything is read (in which case we have read a solution), or it
becomes impossible to read the same letter at beginning and end (in which case
what we are reading is not a solution).

The mirror of a string u is written u. The operation for “placing domino i around
previous dominoes” is deﬁned as θi.φ ≡ θ$1−.θui+.θ+vi.θ$1+.φ, “accepting domi-
noes” is θacc.φ ≡ θ$1−.(∗1 ∧ θ$2+.φ), where ∗1 matches any string of length (cid:62) 1,
to avoid the empty sequence as a trivial solution; “reading a on both ends” is
θa.φ ≡ θ$2−.θa−.θ−a.θ$2+.φ. Abbreviating θ.∗ or θ.> into simply θ, consider now
the formula γ ∈ CC(Θpreﬁx+suﬃx) =

#[$1] = 1 ∧ #[$2] = 1 ∧

#[$1 ∗ ∧¬(θ1 ∨ · · · ∨ θn ∨ θacc)] = 0 ∧ #[$2 ∗ ∧¬(W

a6=$1,$2

θa)] = 1 .

It is satisﬁable iﬀ there is a tree whose arity contains $1, $2, and such that
every label beginning with $1 (i.e. phase one) has a sibling (along with the
intermediate siblings) obtained either by placing some domino so that ui mirrors
vi, staying in phase one, or by moving to phase two. At this point, a label is
of the form $2uik . . . ui1 vi1 . . . vik . Furthermore, all but one label beginning with
$2 (i.e. all but $2) have a sibling obtained by removing the same letter at the
beginning and the end; all letters must be read until only $2 remains. Thus, γ
is satisﬁable iﬀ there are i1, . . . , ik such that ui1 . . . uik = vi1 . . . vik . This shows
that CC(Θpreﬁx+suﬃx) is undecidable. This carries over to CMso(Θpreﬁx+suﬃx):
consider the formula ∃x . x ∈ γ.

s
yx

. . .

z . . .

This conﬁguration is represented by the word
· · · xsyz · · ·. Moving left and right, the factor xsyz
becomes s0xy0z and xy0s0z, respectively. Thus
transitions are coded by (at most) three-letter
substitutions on factors like xsy.

Figure 7: Turing machine conﬁgurations and three-letter substitutions.

Note that we could similarly argue that merely being able to replace factors inside
words yields undecidability. This can be done either by reduction to the previous
case, or directly by reduction to termination of a Turing machine. Indeed, as
illustrated in Figure 7, the transitions of Turing machines are straightforwardly
seen as factor replacements – the factors being in fact of size at most 3.

The message from this section is therefore: as soon as Θ is capable of dealing
with factors, or with preﬁxes and suﬃxes, decidability is in jeopardy.

5. A More Eﬃcient Restriction

In Section 3, we showed that CMso(ΘWSkS) has decidable satisﬁability, by
reduction to a WSkS formula. However in the absence of a bound on quantiﬁer

17

alternations in the WSkS encoding, a direct implementation may not, a priori,
do better than a non-elementary complexity. To have well-deﬁned complexity
bounds, it is usually more advisable to work with tree automata rather than
in tree logics.
In a previous publication [17], we explored the comparative
complexities of Mso logic and automata on unordered trees, both enriched with
various types of arity constraints. Notably, in Proposition 43, it is shown how
the complexity of the emptiness problem for such automata is linked to the
satisﬁability problem for an arity constraint.

Unfortunately, the classes considered in [17] do not permit data comparisons
between siblings. At the other end of the spectrum, CC(ΘWSkS) has no known
complexity results that an class of automata could beneﬁt from. Fortunately,
in many cases we do not need the full power of ΘWSkS, and it is possible to ﬁnd
restrictions with known complexity and expressive enough for our applications.
The present section deals with such a restriction.

Recall that our primary motivation is to handle the string relations Θsuﬃx, of
the form θu,u0 = { (wu, wu0) | w ∈ A∗ }. In practice, one does not need to deal
with transformations from and to all possible suﬃxes; instead, there are a few
small groups of related suﬃxes in play at a time, such as ".tex", ".dvi", and ".pdf",
or maybe ".cpp" and ".exe", so that at any point we only need to deal with a few
speciﬁc suﬃx transformations. Oftentimes, the suﬃxes in question are disjoint
in the sense that none of them is a suﬃx of another suﬃx in the same group:
".tex" is not a suﬃx of ".pdf", and vice-versa. Thus no word can admit both ".tex"
and ".pdf" as a suﬃx. For short, we say that the suﬃxes are mutually exclusive.
For our applications, the traditional dot in ﬁle extensions makes this an almost
universal case. We will see that these restrictions yield an easier satisﬁability
test than in the general case.

Let L = { w1, . . . , wn } be a set of mutually exclusive suﬃxes: there are no
i 6= j such that wi is a suﬃx of wj. Let ΘL be the set of string relations θwi,wj
linking uwi to uwj. The corresponding class of counting constraints is, as usual,
CC(ΘL). However we shall need an additional restriction: recall that CC(ΘL) is
shorthand for CC(Φregexp + siblings(ΘL)), and that ﬁlters of Φregexp + siblings(ΘL)
can use any regular expression to test edge labels. So far, this has made no
diﬀerence, but in this section, regular expressions testing labels may only be
of the form A∗w, for some w ∈ L. That is to say, they must be coherent with
the choice of suﬃxes we are dealing with. We denote by CCsufL the class of
counting formulæ of CC(ΘL) restricted this way.
To eﬃciently decide satisﬁability of a formula of CCsufL, we use a small-model
argument, then we nondeterministically guess a solution. We shall later use this
logic in a class of bottom-up automata named aut(ΘL) (see [17]). Intuitively,
they are bottom-up automata on data trees, with rules of the form γ → q; to
evaluate a tree in q, they test a counting constraint γ, in this case of CCsufL,
on the children of the tree’s root. That constraint has access to the states in
which the children trees have been evaluated in the same way as the counting
constraints used within Mso had access to the Mso variables. Before we deﬁne

18

those automata, we need a few further observations on annotations by variables.

Assume that our arities are already annotated by ﬁnite sets eX ⊆ X of second-
order variables. An arity is therefore of the form

M = {| d1 : eX 1, . . . , dn : eX n |} .

(11)

Note that this is not exactly a tree; however, to deﬁne what it means that M
is a solution of ψ, we see it as a ﬂat tree, i.e. a tree of height 1, tM :

tM =

d1

d2
v2

v1

root

di

dn

vi

vn

,

(12)

(cid:74)

(cid:75)

ψ

tM ,IM

. For ﬁlters, we write M, di : eX i |= φ iﬀ vi ∈

with a corresponding variable assignment IM . It is such that vi ∈ IM (X) iﬀ
X ∈ eX i. We say directly that an arity M satisﬁes the constraint ψ, written
M |= ψ, if root ∈
.
tM ,IM
These set variables X correspond to state labellings of an automaton of aut(ΘL),
which is standard procedure when using Mso in automata. Indeed, a state q
during the run of an automaton can be seen as the set of nodes which are
evaluated in q, and thus corresponds naturally to a set variable. If we consider
vertically deterministic automata of aut(ΘL) [17], where each tree is evaluated
in at most one state, the variables X are mutually exclusive, which is to say
each eX i has at most a single element.

φ

(cid:75)

(cid:74)

We now deﬁne the class of automata aut(ΘL). As is often done in the literature
(see [27, 17]), we create a bottom-up automata class where the rules are the
formulæ of interest, in this case constraints of CCsufL.
Deﬁnition 2 (aut(ΘL)). An alternating bottom-up automaton (aut(ΘL)) for
unordered unranked trees on data values A∗is a tuple A = hA, Q, Qﬁn, Ri where

(cid:5) Q is the ﬁnite set of (vertical) states,
(cid:5) Qﬁn ⊆ Q the subset of ﬁnal states,
(cid:5) and R ⊆ CCsufL × Q is the ﬁnite set of (vertical) transition rules; the

variables in the formula of CCsufL are the states of Q.

We shall write ψ → q for a rule (ψ, q) ∈ R. Any automaton A evaluates any tree
with data values A∗ to a set of states. This set is deﬁned by induction on the
structure of trees such that for all n ≥ 0, data values d1, . . . , dn ∈ A∗ and trees
t1, . . . , tn:

{| d1 : t1, . . . , dn : tn |}

A =
(cid:75)
{ q | {| d1 :

(cid:74)

t1

A, . . . , dn :
(cid:75)

(cid:74)

(cid:74)

tn

(cid:75)

A |} |= ψ, ψ → q ∈ R } .

Note that this formalism is alternating: it considers all states assigned to subtrees
when applying a transition rule, and not only one of them nondeterministically.

19

An automaton is said to be deterministic if for every tree t,
one element. The language accepted by A is deﬁned as

t
(cid:75)

(cid:74)

A has at most

L(A) = { t |

A ∩ Qﬁn 6= ∅ } .

t
(cid:74)

(cid:75)

(13)

Following [27, 17], classical problems such as emptiness or membership on au-
tomata of this form are generally only as hard as the same problem for the logic
used in the rules. We shall see in Thm. 4[p22] that this applies in our case as
well. This means that to decide emptiness for automata of aut(ΘL), we shall
study the satisﬁability problem for CCsufL. We propose to solve this problem
by nondeterministically guessing a solution.

As we shall see in the ﬁrst lemma, having restricted ourselves to mutually ex-
clusive suﬃxes, we can "cut" an arity in independent parts. For instance, if
L = { ".tex", ".pdf" }, then given a child, say, "foo.tex", only itself and an hypo-
thetical "foo.pdf" are relevant to any given ﬁlter. The remainder of the arity can
be ignored. In this way, by restricting ourselves to a ﬁxed set of suﬃxes, we
have also bounded the reach of ﬁlters within arities.

More generally, to see if an element labelled uwi satisﬁes a ﬁlter φ, we do not
need to consider the whole arity M , but only the part of it where the edges are
labelled in uL. We call that the orbit of uwi under the action of all θwi,wj , and
write it Mu. We have

Mu = {| d : eX |

(d : eX) ∈ M, d ∈ uL |} .

(14)

Lemma 1. Let M = {| d1 : eX 1, . . . , dn : eX n |}. Let d : eX ∈ M such that
d = uwi. For any ﬁlter φ, we have M, d : eX |= φ if and only if Mu, d : eX |= φ.
Proof. Examining the semantics of φ, it is immediate that the only operator to
consider another part of the arity is θ.φ0. That is to say that whether d : eX is se-
lected by φ or not only depends on sibling elements dk : eX k accessible from d with
operators θ.φ0. Since our θ can only express links of the form uwi to uwj, these
accessible elements of M are exactly those of data in uL, i.e. the orbit Mu. (cid:3)

Thus we do not need to consider an arity as a whole, but orbit by orbit. This
means that to solve satisﬁability, we can guess a solution orbit by orbit. The
next lemma will show that the size and number of orbits required to guess a
valid arity is limited by this small-model theorem:

Lemma 2. If ψ is satisﬁable, then we can ﬁnd a solution using an exponential
number of orbits of exponential size.

Proof. If #φ (cid:54) n appears in a formula ψ, we need to keep track of how many el-
.
ements are selected by φ in a counter; it is suﬃcient for it to range over
0, n + 1
(cid:75)
(cid:74)
Likewise, if #φ ≡m n appears in ψ, it is suﬃcient for the corresponding counter
to range over
. The total number of conﬁguration for these counters is
the product of the conﬁgurations of each counter. This leads to an exponential
number of conﬁgurations N (cid:54) O(2|ψ|).

0, m − 1
(cid:75)

(cid:74)

20

Consider M , a solution of ψ. In one of its orbits Mu, whether an element is
selected by φ depends only on the existence of the other elements, not their
multiplicity. Hence, we can remove an element d : eX without disturbing the
ﬁlter as long as we do not erase “the last element” (multiplicity (cid:62) 1).

This enables us to use a classic small-model or pumping argument for constraints
ψ, if we see their evaluation as an automation reading the arity element by
element – and element being of the form d : eX here. For each orbit Mu, if the
multiplicity of an element d : eX is at least N + 1, then necessarily a conﬁguration
must be encountered twice. By removing extraneous elements – which can be
done without aﬀecting ﬁlters, as we have said – we can thus obtain M 0, another
solution of ψ whose multiplicity for each element d : eX is smaller than N + 1.

Any orbit Mu has at most an exponential number of diﬀerent elements, as |uL|
is bounded, and if we consider only the variables of X that appears in ψ, there
are fewer than 2|ψ| possible eX. Therefore, all orbits within M 0 are of exponential
size at most. Furthermore, since orbits are independent (see Lemma 1), we
can remove one from M 0 without disturbing the others. Again, by a classic
small-model argument, if there are more than N orbits in M 0, then there exists
M 00, another solution of ψ with at most N orbits. In the end, M 00 has at most
(cid:3)
an exponential number of orbits, each of size at most exponential.

We now combine these lemmas to obtain a way to guess a solution for a formula of
CCsufL orbit by orbit. We know a bound on the size and number of orbits needed.
Lemma 3. The satisﬁability problem for an arity formula of CCsufL is decid-
able in NExpTime. Furthermore, if the variables X are mutually exclusive, the
satisﬁability problem for an arity formula of CCsufL is decidable in PSpace.
Proof. Lemma 1 tells us we can guess a solution orbit by orbit. Lemma 2 tells
us we can use only orbits whose cardinality is smaller than 2|ψ|. First, we need
counters to remember the orbits we already read. As argued before, we need
a counter capped at n for #φ (cid:54) n, and a counter modulo m for #φ ≡m n. All
these counters start at 0, and take a space smaller than |ψ|. Then, we guess an
orbit. To guess an orbit of preﬁx u, we need to know how many uwi annotated
by eX i are in the orbit, for each wi in our suﬃx and eX i set of variables. Guessing
an orbit is picking a number between 0 and 2|ψ| (size ≤ |ψ|) for each pair wi, eX i.
Each orbit is guessed and stored in exponential time. We then evaluate each pair
wi, eX i of the orbit for each ﬁlter φ that appears in ψ. This is done in polynomial
time for the size of the orbit and formula ψ. Each counter is updated accordingly.
If the new counter conﬁguration satisﬁes ψ, we found a solution.

In all cases, the time needed is exponential: this algorithm is in NExpTime.
However, if variables X are mutually exclusive, then an orbit can only have
a polynomial number of diﬀerent elements (data in uL, eX with one or zero
elements). Therefore, the orbits can be stored in a polynomial amount of memory.
Since a given conﬁguration of the counters can also be stored in a polynomial
(cid:3)
amount of memory, this algorithm is in PSpace.

21

We can then use techniques similar to those of [27, 17] to extend our results
to the class aut(ΘL) of bottom-up automata with rules ψ → q, where ψ are
formulæ of CCsufL.
Theorem 4. The emptiness problem for automata in aut(ΘL) is decidable in
NExpTime. Furthermore, for deterministic automata of aut(ΘL), the empti-
ness problem is decidable in PSpace.
Proof. To decide the emptiness of the language of an automaton A = hA, Q, Qﬁn, Ri,
we use a variant of classical reachability algorithms to ﬁnd all possible annotations
for a subtree.
For each state q ∈ Q, we note ψq = W
ψ→q∈R ψ. We note that an arity is annotated
by q if and only if it satisﬁes ψq. We can also build, for any part eQ ∈ ℘(Q), a
eQ:
constraint ψ
(15)

eQ such that an arity is annotated by eQ if and only if it satisﬁes ψ

^

^

ψ

¬ψq .

ψq ∧

eQ =

q∈ eQ

q6∈ eQ

Note that |ψ

eQ| is polynomial in the size of A.

We try to build all possible annotations. This computation will be recursive:

(cid:5) If the empty arity satisﬁes ψ

eQ, then eQ is a possible annotation.

(cid:5) If M = {| d1 : eQ1, . . . , dn : eQn |} is an arity where each eQi is known to be

a possible annotation, then eQ is a possible annotation.

This translates as an algorithm as follows: We have a variable S ⊆ ℘(Q) to store
all possible annotations. It starts as { eQ0}, where is eQ0 is the set of states such
that {| |} |= ψq – thus it is the annotation for leaves.

We then have the following loop: while there exists eQ 6∈ S such that there
exists M = {| d1 : eQ1, ...dn : eQn |} where each eQi ∈ S, and M satisﬁes ψ
eQ, or in
other words, whenever eQ becomes reachable from S, we add eQ to S for the next
iteration: S := S ∪ { eQ}.

In the end, S is the set of all possible annotations. L(A) is empty if and only
if there is no eQ ∈ S such that eQ ∩ Qﬁn 6= ∅.
Concerning the complexity of the algorithm: for an alternating automaton, each
passage in the loop proves the accessibility of an annotation eQ. In the worst
case scenario, every annotation is needed to prove the non-emptiness of A. This
loop stops as soon as it cannot add a new element to S, so it occurs at most
an exponential number of times: this algorithm is in NExpTime.

In a deterministic automaton, however, the possible annotations are either sin-
gletons {q}, or empty. Thus there are only |Q| + 1 diﬀerent annotations to
consider. Each passage in the loop can test the satisﬁability with mutually
exclusive variables (in PSpace) of a linear number of ψ{q} to ﬁnd a new element
for S. This loop stops as soon as it cannot add a new element to S, ans thus
(cid:3)
occurs at most a linear number of times: this algorithm is in PSpace.

22

Note that these results are only as good as CC(ΘL) is a good approximation
of the expressivity needed on arity constraints. Should a tighter restriction
have a satisﬁability decidable in better complexities, it would generate a better
automaton class. As discussed in [17], Propositions 42 and 43, should one ﬁnd
a class of arity constraints where satisﬁability is in PTime, then the resulting
deterministic automaton class would have membership and emptiness problem
decidable in PTime as well.

6. A Decidable Extension to Subtree Equality Tests Between Broth-

ers

We can extend the methods of Section 5 to a wider logic: we consider automata
of aut(ΘL) with additional tests for structural equality of subtrees between
brothers (as seen in [28]). We prove that our small model theorem still applies,
and continues to yield a NExpTime result for the emptiness problem. It is
important to note that the method presented here does not preserve the PSpace
results for deterministic automata.
We start by deﬁning our class, as an extention of aut(ΘL) where ΘL can also
test equality or inequality of subtrees. To this end, in our logic CCsufL, each
θ is replaced by two versions: θ= and θ6=. We get the new deﬁnition of ﬁlters:

φ ::= π

incoming edge label matches π,

| x | X
| θ=.φ

| θ6=.φ

node is x / a member of X,

∃ sibling satisfying φ with labels related by θ

with identical subtrees,

∃ sibling satisfying φ with labels related by θ

with diﬀerent subtrees,

| φ ∧ φ | ¬φ

conjunction and negation.

The semantics of θ= and θ6= uses subtrees under the node we examine. We note
t|v the subtree under node v in a tree t. We give the following deﬁnition, which
is identical to that of θ.φ, with the addition of the subtree (dis)equality tests:

(cid:74)

θ=.φ
(cid:75)
n
v

t,I =
(cid:12)
(cid:12) ∃v0 . v
(cid:12)

(cid:113)θ6=.φ(cid:121)t,I =
(cid:12)
(cid:12) ∃v0 . v
(cid:12)
v

n

(cid:36)(cid:37)

(cid:36)(cid:37)

t v0 ∧ (‘t(v), ‘t(v0)) ∈ θ ∧ v0 ∈

φ
(cid:74)

t,I ∧ t|v = t|v0
(cid:75)

t v0 ∧ (‘t(v), ‘t(v0)) ∈ θ ∧ v0 ∈

t,I ∧ t|v 6= t|v0

φ
(cid:74)

(cid:75)

o

o

23

sufL in order to solve the emptiness problem in aut(Θ=,6=

We call CC=,6=
sufL the counting constraints on this logic, with the same restriction
on regular expressions as CCsufL in the previous section. Since this logic needs
information on the annotations and subtrees of an arity, it will be evaluated on an
arity of the form M = {| d1 : (t1, eX 1), . . . , dn : (tn, eX n) |}. Just like we did in Sec-
L ) as automata where each rule is a formula of CC=,6=
tion 5, we deﬁne aut(Θ=,6=
sufL.
An important note to make is that since we want to test satisﬁability of a formula
of CC=,6=
L ), we have to con-
sider a slightly modiﬁed satisﬁability problem. Indeed, we now must check that
when an orbit is presented, it represents a feasible conﬁguration. This can be a
problem for two diﬀerent reasons. The ﬁrst one is that when a certain annotation
is used for several diﬀerent subtrees, we must check that enough trees with this
annotation exist. To solve this, we are reminded that the only tests we have are of
the form A∗w. This means that if a word satisﬁes a test, then an inﬁnite number of
words satisfy this test, which means that if an annotation can be reached by a non-
empty tree, then it is reached by an inﬁnite number of trees. The second problem
is that in an alternating automaton, two nodes with identical subtrees are anno-
tated by the same set of states. To reﬂect that, we study the satisﬁability problem
with consistent annotations, which is to say that for M = {| d1 : (t1, eX 1), . . . , dn :
(tn, eX n) |} to be a proper solution, we want that if ti = tj, then eX i = eX j.

As an example, consider the following arity, with 3 elements:

M = {| uwi : ({| d1 : ∅, d2 : ∅ |}, {X, X 0}) ,
uwj : ({| d3 : ∅ |}, {X 00}) ,
uwk : ({| d1 : ∅, d2 : ∅ |}, {X, X 0}) |}

The ﬁrst and third element have the same annotations, since they have the
same subtree. The ﬁlter θ6=
.X selects the second element, since uwi : ({| d1 :
∅, d2 : ∅ |}, {X, X 0}) has a diﬀerent subtree, is annotated by X, and their data
values are related via θwj ,wi. The ﬁlter θ=
.∗ select the ﬁrst element, since
uwk : ({| d1 : ∅, d2 : ∅ |}, {X, X 0}) has the same subtree, and their data are
related via θwi,wk . However, θ6=

.∗ does not select the ﬁrst element.

wi,wk

wj ,wi

wi,wk

To prove that the emptiness problem in aut(Θ=,6=
L ) is decidable in NExpTime,
we follow the same pattern as in Section 5. First, we prove a small model
theorem on CC=,6=
sufL. Then, we prove that satisﬁability problem with consistent
annotations in CC=,6=
sufL is decidable in NExpTime. Finally, we use the same
method as in Theorem 4 to prove that the emptiness problem in aut(Θ=,6=
L ) is
decidable in NExpTime.

wi,wj

wi,wj

and θ6=

Our ﬁrst remark is that a variant of Lemma 1 still holds: for an element labelled
uwi, θ=
only consider elements of Mu. Our second remark is that
part of Lemma 2 still holds: the number of conﬁgurations for the counters is
still exponential. This means that if a formula ψ of CC=,6=
sufL is satisﬁable, then
it has a solution with fewer than N (cid:54) O(2|ψ|) orbits. However, to ensure that
each orbit can be of exponential size, we must see what part of a very large orbit
can be removed without changing which elements satisfy ﬁlters φ.

24

To this end, we will further cut an orbit into its equivalence classes with the same
subtree. Given an arity M = {| d1 : (t1, eX 1), . . . , dn : (tn, eX n) |}, we deﬁne its
sub-orbit Mu,t as the multiset of all elements d : (t, eX) in M such that d ∈ uL.
We will show that if a formula ψ is satisﬁable, it has a solution where each orbit
has an exponential number of sub-orbits.

In order to keep a small model theorem, we try and eliminate sub-orbits from
a solution of ψ without changing which elements are selected by a ﬁlter φ. As
before, a ﬁlter only concerns itself with existence or non-existence, therefore
multiplicity has no impact on whether an element is selected by φ or not. We
capture that using a notion of similarity:

Deﬁnition 3. Two sub-orbits Mu,t1 and Mu,t2 are similar if t1 and t2 are anno-
tated by the same eX ∈ ℘(X ), and for every d ∈ uL, we have d : (t1, eX) ∈ Mu,t1
if and only if d : (t2, eX) ∈ Mu,t2.

The equivalence class for similarity of a sub-orbit Mu,t is entirely characterized
by the labelling of t and by set of d ∈ uL occurring in the sub-orbit. Hence
for a ﬁxed preﬁx u, there are at most 2|L|+|ψ| diﬀerent equivalence classes for
similarity (as in Part 5, there are fewer than 2|ψ| possible eX to consider).

We will see in the next lemma the expected property that two similar sub-orbits
are indistinguishable from the point of view of a ﬁlter.

Lemma 4. Let Mu be an orbit and Mu,t1 , Mu,t2 two similar sub-orbits. Let
d : (t1, eX) ∈ Mu,t1 . Then d : (t2, eX) ∈ Mu,t2 , and for any ﬁlter φ ∈ CC=,6=
sufL,
Mu, d : (t1, eX) |= φ if and only if Mu, d : (t2, eX) |= φ.
Proof. The existence of d : (t2, eX) ∈ Mu,t2 for every element d : (t1, eX) ∈ Mu,t1
is a direct consequence of the deﬁnition of similarity. One can prove that it
satisﬁes all the same φ as d : (t1, eX) by induction on φ. This is trivially true for
π or X (as both have same data and annotations). The induction is immediate
for the ∧ or ¬ operators.

wi,wj

, we know that d : (t1, eX) satisﬁes θ=

For θ=
.φ if d = uwi and there is
in Mu,t1 an element uwj : (t1, eX) that satisﬁes φ. This means that there is in
Mu,t2 an element uwj : (t2, eX) that, by induction, satisﬁes φ. We then have that
d : (t2, eX) satisﬁes θ=

wi,wj

.φ.

wi,wj

wi,wj

, we know that d : (t1, eX) satisﬁes θ6=

For θ6=
.φ if d = uwi and there is in
another sub-orbit an element uwj : (t3, eX) that satisﬁes φ. If uwj : (t3, eX) is not
in Mu,t2, then d : (t2, eX) satisﬁes θ6=
.φ as well. If uwj : (t3, eX) is in Mu,t2 ,
then there exists uwj : (t1, eX) in Mu,t1 that satisﬁes φ by induction. Therefore,
(cid:3)
either way, d : (t2, eX) satisﬁes θ6=

wi,wj

wi,wj

.φ.

wi,wj

The last argument we need to get a small model theorem for CC=,6=
sufL is that if
an orbit contains three or more similar sub-orbits, we can delete one without
changing which ﬁlters select which element.

Lemma 5. Let Mu = {| d1 : eX 1, . . . , dn : eX n |} be an orbit. Let Mu,t1, Mu,t2, Mu,t3

25

be three similar sub-orbits. Let d : (t, eX) ∈ Mu\Mu,t3. We have Mu, d : (t, eX) |=
φ if and only if Mu\Mu,t3, d : (t, eX) |= φ.
Proof. Looking at the semantics of φ, the only operator to consider an element
outside of the sub-orbit is θ6=. We recall that Mu, d : (t, eX) |= θ6=
.φ if there
is an element d0 : (t0, eX 0) ∈ Mu such that d = uwi, d0 = uwj, Mu, d0 : eX 0 |= φ
and t 6= t0.

wi,wj

We now consider several cases: if d0 : (t0, eX 0) is not in Mu,t3 , then removing
Mu,t3 does not change the fact that d : (t, eX) is selected by θ6=
.φ. Con-
versely, if d0 : (t0, eX 0) is in Mu,t3, since Mu,t1 , Mu,t2 , Mu,t3 are three similar
sub-orbits annotated by the same eX 0, there Lemma 4 gives us d0 : (t1, eX 0) ∈ Mu,t1
and d0
: (t0, eX 0) |= φ if and only if
: (t2, eX 0) ∈ Mu,t2 such that Mu, d0
Mu, d0 : (t1, eX 0) |= φ if and only if Mu, d0 : (t2, eX 0) |= φ.
Hence, even if we remove d0 : (t0, eX 0) from Mu, there will be an element to
"replace" it to ensure that Mu, d : (t, eX) |= θ6=
.φ. If d : (t, eX) is in Mu,t1, we
choose d0 : (t2, eX 0) to "replace" d0 : (t0, eX 0). Otherwise, we chose d0 : (t1, eX 0) to
(cid:3)
"replace" d0 : (t0, eX 0).

wi,wj

wi,wj

We now have all the elements for our small model theorem: from a solution of ψ
with consistent annotations, we can remove orbits until there is an exponential
number of orbits, in each orbit we can remove similar sub-orbits until there is an
exponential number of sub-orbits, and in each sub-orbit we can remove elements
until their multiplicity is exponential. We then get the small model result we
wanted:

Lemma 6. If ψ is satisﬁable with consistent annotations, then we can ﬁnd a
solution using an exponential number of orbits of exponential size.

From there, the reasoning is identical to what we can ﬁnd in Section 5 for the
NExpTime results: we can decide satisﬁability of CC=,6=
sufL by guessing a solution
orbit by orbit, and each orbit has an exponential size.

Lemma 7. The satisﬁability problem with consistent annotations for an arity
formula of CC=,6=

sufL is decidable in NExpTime.

We can use this result to obtain the complexity of the emptiness problem for
aut(Θ=,6=

L ), as in the previous section.

Theorem 5. The emptiness problem for automata in aut(Θ=,6=
in NExpTime.

L ) is decidable

7. Conclusions and Future Work

We have introduced the logic CMso(ΘWSkS) on unordered data trees. It is
an extension of CMso to data trees, where tests on a given node may include
enforcing the existence of a sibling whose label is in relation with that node’s
own label, the relation being WSkS-deﬁnable. That logic’s expressive power is

26

largely suﬃcient for our targeted concrete applications, such as the veriﬁcation
of common constraints on ﬁle trees, which usually involve suﬃx manipulations,
largely captured by WSkS. We have shown that satisﬁability for CMso(ΘWSkS)
is decidable. However, we have also shown that any attempt to allow additional
data relations for both preﬁx and suﬃx manipulations, even of the simplest kind,
would render the logic undecidable, as would any extension allowing two or more
independent data tests to be performed between data values present at diﬀerent
levels of a tree (such as uncle/nephew tests). We have also studied the complexity
of the emptiness tests for automata where horizontal counting constraints are
restricted to relations that only involve disjoint suﬃxes, and shown that the test
is then NExpTime for alternating automata, and only PSpace for deterministic
automata. Furthermore, under the disjoint suﬃx restriction, tests of structural
equality or disequality of sibling subtrees can be added while preserving the
NExpTime complexity result.

There are two main dimensions in which this work can be extended. One is to
ﬁnd more expressive string relations for which the logic remains decidable; our
undecidability results indicate that such an extension may not be very natural.
Another is to extend the reach of the string relation from merely the set of
siblings to something larger. The result on (dis)equality constraints between
brother subtrees is a ﬁrst step towards such extensions.

A promising direction is the use of Monadic Datalog on data trees [29], which
is capable of expressing relations not only with siblings but also with parents,
cousins etc., and for which eﬃcient algorithms are known. However, regardless
of the chosen method, the search space for potential decidable extensions is much
reduced by our undecidability result concerning the uncle/nephew extension and
variants. Possibilities which remain open include father/child data relations, and
new restrictions on the applicability of data tests.

8. References

[1] A. Boiret, V. Hugot, J. Niehren, R. Treinen, Logics for unordered trees with
data constraints on siblings, in: A. H. Dediu, E. Formenti, C. Martín-Vide,
B. Truthe (Eds.), Language and Automata Theory and Applications -
9th International Conference, LATA 2015, Nice, France, March 2-6, 2015,
Proceedings, Vol. 8977 of Lecture Notes in Computer Science, Springer,
2015, pp. 175–187. doi:10.1007/978-3-319-15579-1_13.
URL http://dx.doi.org/10.1007/978-3-319-15579-1_13

[2] B. Courcelle, J. Engelfriet, Graph Structure and Monadic Second-Order
Logic - A Language-Theoretic Approach, Vol. 138 of Encyclopedia of
mathematics and its applications, Cambridge University Press, 2012.
URL
locale=fr_FR

http://www.cambridge.org/fr/knowledge/isbn/item5758776/?site_

27

[3] V. Benzaken, G. Castagna, K. Nguyen, J. Siméon, Static and dynamic
in: POPL, ACM, 2013, pp. 101–114.

semantics of NoSQL languages,
doi:10.1145/2429069.2429083.

[4] H. Seidl, T. Schwentick, A. Muscholl, Numerical document queries, in:
Proceedings of the Symposium on Principles Of Database Systems, 2003,
pp. 155–166. doi:10.1145/773153.773169.

[5] I. Boneva, J.-M. Talbot, Automata and logics for unranked and unordered
trees, in: RTA, Vol. 3467 of LNCS, Springer Verlag, 2005, pp. 500–515.
doi:10.1007/978-3-540-32033-3\_36.

[6] S. D. Zilio, D. Lugiez, XML schema, tree logic and sheaves automata, in:
Proc. of RTA, Vol. 2706 of LNCS, Springer Verlag, 2003, pp. 246–263.
doi:10.1007/3-540-44881-0\_18.

[7] G. Smolka, Feature constraint logics for uniﬁcation grammars, Journal of
Logic Programming 12 (1992) 51–87. doi:10.1016/0743-1066(92)90039-6.

[8] G. Smolka, R. Treinen, Records for logic programming, J. Log. Program.

18 (3) (1994) 229–258. doi:10.1016/0743-1066(94)90044-2.

[9] M. Müller, J. Niehren, R. Treinen, The First-Order theory of ordering
constraints over feature trees, in: LICS, IEEE Comp. Soc. Press, 1998, pp.
432–443. doi:10.1109/LICS.1998.705677.

[10] J. Niehren, A. Podelski, Feature automata and recognizable sets of feature
trees, in: TAPSOFT, Vol. 668 of LNCS, Springer, 1993, pp. 356–375.

[11] R. Backofen, G. Smolka, A complete and recursive feature theory, Theor.
Comput. Sci. 146 (1-2) (1995) 243–268. doi:10.1016/0304-3975(94)00188-O.
URL http://dx.doi.org/10.1016/0304-3975(94)00188-O

[12] P. Blackburn, Structures,

the structural
approach to feature logic, in: Constraints, Language and Computation,
Academic Press, 1994, pp. 1–27.

languages and translations:

[13] P. Weil, Algebraic recognizability of

languages,

in: Mathematical

Foundations of Computer Science 2004, Springer, 2004, pp. 149–175.

[14] B. Bollig, A. Cyriac, P. Gastin, K. N. Kumar, Model checking languages
of data words, in: Foundations of Software Science and Computational
Structures, Springer, 2012, pp. 391–405.

[15] H. Lauchli, C. Savioz, Monadic second order deﬁnable relations on the
binary tree, J. Symb. Log. 52 (1) (1987) 219–226. doi:10.2307/2273878.
URL http://dx.doi.org/10.2307/2273878

[16] M. Bojanczyk, C. David, A. Muscholl, T. Schwentick, L. Segouﬁn, Two-
variable logic on data words, ACM Trans. Comput. Log. 12 (4) (2011) 27.

28

[17] A. Boiret, V. Hugot, J. Niehren, R. Treinen, Automata for unordered trees,

Inf. Comput. 253 (2017) 304–335. doi:10.1016/j.ic.2016.07.012.
URL http://dx.doi.org/10.1016/j.ic.2016.07.012

[18] B. Courcelle, The monadic second-order logic of graphs. i. recognizable
sets of ﬁnite graphs, Information and computation 85 (1) (1990) 12–75.
doi:10.1016/0890-5401(90)90043-H.

[19] D. Figueira, On XPath with transitive axes and data tests, in: R. Hull,

W. Fan (Eds.), PODS, ACM, 2013, pp. 249–260.

[20] J. R. Büchi, Weak second-order arithmetic and ﬁnite automata, Mathe-

matical Logic Quarterly 6 (1-6) (1960) 66–92.

[21] J. W. Thatcher, J. B. Wright, Generalized ﬁnite automata theory with an ap-
plication to a decision problem of second-order logic, MST 2 (1) (1968) 57–81.

[22] L. Stockmeyer, A. Meyer, Word problems requiring exponential time, in:

Symposium on the Theory of Computing, ACM, 1973, pp. 1–9.

[23] M. Müller, J. Niehren, Ordering constraints over feature trees expressed
in second-order monadic logic, Inf. Comput. 159 (1-2) (2000) 22–58.
doi:10.1006/inco.2000.2878.
URL http://dx.doi.org/10.1006/inco.2000.2878

[24] H. Comon, M. Dauchet, R. Gilleron, C. Löding, F. Jacquemard, D. Lugiez,
S. Tison, M. Tommasi, Tree automata techniques and applications,
Available on: http://www.grappa.univ-lille3.fr/tata, release October,
12th 2007 (2007).

[25] M. Rabin, Automata on Inﬁnite Objects and Church’s Problem, no. 13 in
CBMS Regional Conference Series in Mathematics, American Mathematical
Society, 1972.

[26] H. Läuchli, C. Savioz, Monadic second order deﬁnable relations on the

binary tree, Journal of Symbol Logic 52 (1) (1987) 219–226.

[27] H. Seidl, T. Schwentick, A. Muscholl, Counting in trees, in: Logic and
Automata, Vol. 2 of Texts in Logic and Games, Amsterdam University
Press, 2008, pp. 575–612.

[28] B. Bogaert, S. Tison, Equality and disequality constraints on direct
subterms in tree automata, in: Proceedings of the 9th Annual Symposium
on Theoretical Aspects of Computer Science, STACS ’92, Springer-Verlag,
London, UK, UK, 1992, pp. 161–171.
URL http://dl.acm.org/citation.cfm?id=646508.694491

[29] S. Abiteboul, P. Bourhis, A. Muscholl, Z. Wu, Recursive queries on trees

and data trees, in: ICDT, ACM, 2013, pp. 93–104.

29

