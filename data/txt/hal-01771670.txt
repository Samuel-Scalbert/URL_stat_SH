On is an n-MCFL
Kilian Gebhardt, Frédéric Meunier, Sylvain Salvati

To cite this version:

Kilian Gebhardt, Frédéric Meunier, Sylvain Salvati. On is an n-MCFL. Journal of Computer and
System Sciences, 2022, 127, pp.41-52. ￿10.1016/j.jcss.2022.02.003￿. ￿hal-01771670v2￿

HAL Id: hal-01771670

https://hal.science/hal-01771670v2

Submitted on 22 Dec 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

On IS AN n-MCFL

KILIAN GEBHARDT1, FRÉDÉRIC MEUNIER2, AND SYLVAIN SALVATI3

Abstract. Commutative properties in formal languages pose problems at the frontier of
computer science, computational linguistics and computational group theory. A prominent
problem of this kind is the position of the language On, the language that contains the same
number of letters ai and ¯ai with 1 (cid:54) i (cid:54) n, in the known classes of formal languages. It has
recently been shown that On is a Multiple Context-Free Language (MCFL). However the
more precise conjecture of Nederhof that On is an MCFL of dimension n was left open. We
present two proofs of this conjecture, both relying on tools from algebraic topology. On our
way, we prove a variant of the necklace splitting theorem.

1. Introduction

The language On is the language built on the alphabet Σn = {ai, ¯ai | i ∈ [n]} and that
contains exactly all words w which, for every i in [n], have the same number of occurrences of
ai and ¯ai. Writing |w|c the number of occurrences of the letter c in w, this condition becomes
|w|ai = |w|¯ai for all i in [n]. The problem of situating the languages On within known classes
of languages has been raised at least in two different communities.

The first one is that of computational linguistics. This problem has attracted attention with
a language called M IX (also called the Bach language as it was introduced by Bach [Bac81,
Bac88, Pul83]) that is rationally equivalent to O2. It was related to the research program
of Joshi [Jos85] which consists in formally describing the class of languages corresponding
to Natural Languages. According to Joshi’s terminology, this is the class of Mildly Context
Sensitive Languages. This program tries to give abstract properties of this class while
describing possible candidates [Wei88, JSW91]. Among such candidates, a powerful one
is formed by Multiple Context Free Languages (MCFL) [SMFK91]. According to Joshi et
al. [JSW91] the language “M IX can be regarded as the extreme case of free word order” and
Mildly Context Sensitive Languages should “perhaps” not contain M IX (and thus O2). This
paper also mentions that the position of M IX in classes of languages, such as Tree Adjoining
Languages, is not known and difficult to establish. In particular, it stresses that it is not
known whether M IX is an Indexed Language.

The second community that has also shown interest for the problem is that of computational
group theory which tries to identify properties of groups by means of properties of their word
problem. The word problem for a group consists in describing the language of words that are
equal to zero for a given presentation (all presentations giving rise to rationally equivalent
languages). For example, Muller and Schuppe have characterized virtually free groups as
exactly those groups whose word problems are solved by context free grammars [MS83]. A
question that has been raised by that community is whether O2—which coincides with the

1Technische Universität Dresden, Germany, kilian@gebhardt.xyz.
2CERMICS, École des Ponts ParisTech, France, frederic.meunier@enpc.fr.
3Université de Lille, INRIA, CRIStAL, France, sylvain.salvati@univ-lille.fr.

1

language corresponding to the word problem for the additive group (Z2, +)—is an Indexed
Language [Gil05]. This question remains open. MCFL form a natural generalization of
“copyless” Macro-Languages (see [SK08] for a discussion) and Macro-Languages are equivalent
to Indexed Languages. This makes the question of whether O2 belongs to MCFL relevant.
A first important result in that line of research is that O2 is not a well-nested MCFL
of dimension 2 [KS12], which solves a long-standing open problem raised by Joshi [Jos85].
Subsequently it has been shown that it is actually an MCFL [Sal15] and more precisely an
MCFL of dimension 2 (a 2-MCFL). Nederhof [Ned16] has given a similar proof of the same
result. Later he conjectured that On is an n-MCFL [Ned17]. As pointed in this work, a
simple pumping argument shows that On cannot be an MCFL of dimension strictly smaller
than n. More recently, a breakthrough has been achieved by Ho [Ho18] who proved that
On is an MCFL for every n. However the MCFL constructed in the proof is of dimension
larger than n, namely 8 (cid:4) n+1
(cid:5) − 2. All proofs related to these results are based on algebraic
topology. While the proofs of [Sal15] and [Ned16] strongly rely on topological properties of
the plane (existence of winding numbers of curves around points), the aforementioned proof
by Ho is based on the well-known Borsuk–Ulam theorem, a powerful theorem from algebraic
topology which holds in any dimension. More specifically, it uses a combinatorial application
of this theorem, due to Alon and West [AW86]: the necklace splitting theorem. In this paper,
we also rely on related tools to prove Nederhof’s conjecture, namely that On is an n-MCFL.
Nederhof actually conjectures that a particular Multiple Context-Free Grammar (MCFG) of
dimension n defines On. We prove a slightly stronger result by showing that a grammar that
uses a more restricted kind of rules is sufficient to define On.

2

The article is structured as follows: In Section 2, we introduce notation regarding formal
languages and MCFG as well as the grammar Gn, which is an MCFG of dimension n. Section 3
establishes the main result namely that the language of Gn is On using a decomposition
lemma. The decomposition lemma can on the one hand be derived from a variant of the
necklace splitting theorem that we prove in Section 4. Alternatively, it can be obtained via
purely combinatorial proofs presented in Section 5.

2. Background on Multiple Context Free Grammars

We write [n] for the set {1, . . . , n}. For a given finite set Σ, also called alphabet, we write
Σ∗ for the monoid freely generated by Σ, and Σ+ for the free semigroup generated by Σ. The
elements of Σ are called letters while the elements of Σ∗ and Σ+ are called strings or words
and we write ε for the empty word. Given a word w, we write |w| for its length, and |w|c for
the number of occurrences of the letter c in w. A language is a subset of Σ∗.

We define the language On as {w ∈ Σ∗

n | |w|ai = |w|¯ai for i ∈ [n]} where Σn is the alphabet
{ai, ¯ai | i ∈ [n]}. For α in Σn, writing ¯α exchanges ai and ¯ai: if α is ai, then ¯α is ¯ai; if α is
¯ai, then ¯α is ai. Two letters α and β of Σn are compatible when α = ¯β. We extend the (¯·)
operation to words in Σ∗
n as follows: the word ¯w is obtained from w by applying (¯·) to each
of its letters.

A ranked alphabet Ω is a pair (A, ρ) where A is a finite set and ρ is a function from A to N.
For a in A, the integer ρ(a) is the rank of a. We shall write Ω(n) for the set {a ∈ A | ρ(a) = n}.
The dimension of a ranked alphabet is the maximal rank of its elements.

A Multiple Context Free Grammar (MCFG) G is a tuple (Ω, Σ, R, S) where Ω is a ranked
alphabet of non-terminals, Σ is a finite set of letters, R is a set of rules and S is an element
2

of Ω(1) called initial non-terminal. The rules in R are of the form
A(w1, . . . , wn) ⇒ B1(x1,1, . . . , x1,l1), . . . , Bp(xp,1, . . . , xp,lp)
(1)
where A is in Ω(n), Bk is in Ω(lk), the xk,j are pairwise distinct variables and the wj are
elements of (Σ ∪ X)∗ with X = {xk,j | k ∈ [p] ∧ j ∈ [lk]} and with the restriction that each
xk,j may have at most one occurrence in the string w1 · · · wn. Note that p may be equal to
0, in which case the right part of the rule (the one on the right of the ⇒ symbol) is empty.
Then we may write the rule by omitting the symbol ⇒. The dimension of an MCFG is that
of its ranked alphabet of non-terminals. An MCFG of dimension at most n is an n-MCFG.
An MCFG such as G defines judgments of the form (cid:96)G A(s1, . . . , sn) where A is in Ω(n)
and the sj belong to Σ∗. The notion of derivable judgments is defined inductively: suppose
we are given p derivable judgments (cid:96)G Bk(sk,1, . . . , sk,lk) where Bk ∈ Ω(lk) for k in [p]. For
each rule of the form (1), the judgment (cid:96)G A(s1, . . . , sn) is derivable when each sj is obtained
from wj by replacing each occurrence of the variable xk,j by sk,j. The language defined by G,
denoted by L(G), is the set {w ∈ Σ∗ |(cid:96)G S(w) is derivable}. The class of languages that are
definable by MCFGs is the class of Multiple Context-Free Languages (MCFL). Likewise, the
class of languages definable by n-MCFGs is the class of n-Multiple Context-Free Languages
(n-MCFL).

We define now Gn, the central n-MCFG for which we prove that it generates On. It uses
two non-terminals S and I that are respectively of rank 1 and n. The non-terminal S is the
initial one. The alphabet of Gn is Σn. The rules of the grammar Gn are the following:

(1) S(x1 · · · xn) ⇒ I(x1, . . . , xn).
(2) I(w1, . . . , wn) ⇒ I(x1, . . . , xn), I(y1, . . . , yn)

for all w1, . . . , wn ∈ {x1, . . . , xn, y1, . . . , yn}∗ such that w1 · · · wn = x1y1 · · · xnyn.
(3) I(w1, . . . , wn) ⇒ I(x1, . . . , xn) for all w1, . . . , wn and all α ∈ Σn, k, (cid:96) ∈ [n] such that

wj = xj for j (cid:54)= k, (cid:96) and

• k (cid:54)= (cid:96) implies wk ∈ {αxk, xkα} and w(cid:96) ∈ {¯αx(cid:96), x(cid:96) ¯α}.
• k = (cid:96) implies wk = αxk ¯α.

(4) I(ε, . . . , ε).
Items numbered (2) and (3) describe finite sets of rules. The rules (2) are parametrized
by a particular factorization (w1, . . . , wn) of x1y1 · · · xnyn. For example, when n = 3 letting
w1 = x1y1x2, w2 = y2x3 and w3 = y3 is such a factorization; we have w1w2w3 = x1y1x2y2x3y3.
A rule of the form (3) adds a compatible pair of letters at distinct endpoints of the words.
For example, I(a1x1, x2, ¯a1x3, x4) ⇒ I(x1, x2, x3, x4) is such a rule for n = 4.

Example 1. The grammar G2 contains the following rules:

S(x1x2) ⇒ I(x1, x2)

I(x1y1x2y2, ε) ⇒ I(x1, x2), I(y1, y2)
I(x1y1x2, y2) ⇒ I(x1, x2), I(y1, y2)
I(x1y1, x2y2) ⇒ I(x1, x2), I(y1, y2)
I(x1, y1x2y2) ⇒ I(x1, x2), I(y1, y2)
I(ε, x1y1x2y2) ⇒ I(x1, x2), I(y1, y2)
I(αx1 ¯α, x2) ⇒ I(x1, x2) α ∈ Σ2
I(αx1, ¯αx2) ⇒ I(x1, x2) α ∈ Σ2
3

I(αx1, x2 ¯α) ⇒ I(x1, x2) α ∈ Σ2
I(x1α, ¯αx2) ⇒ I(x1, x2) α ∈ Σ2
I(x1α, x2 ¯α) ⇒ I(x1, x2) α ∈ Σ2
I(x1, αx2 ¯α) ⇒ I(x1, x2) α ∈ Σ2

I(ε, ε)

It is usual to present derivations as trees where nodes have the following form:

(cid:96)G B1(s1,1, . . . , s1,l1) · · · (cid:96)G Bp(sp,1, . . . , sp,lp)

(cid:96)G A(s1, . . . , sn)
when from the derivations of the (cid:96)G Bi(si,1, . . . , si,li) we can derive (cid:96)G A(s1, . . . , sn) using a
rule of G. When p equals 0, there is no derivation above the bar. This means that rules with
no right-hand part form the leaves of these trees.

Using this notation we can show as follows that a1a1¯a2¯a1¯a1a2 is in the language of G2. We

use colors to identify each letter and allow one to infer the rules used in the derivation:

(cid:96)G2 I(ε, ε)

(cid:96)G2 I(ε, ε)

(cid:96)G2 I(¯a2, a2)

(cid:96)G2 I(a1, ¯a1)

(cid:96)G2 I(a1¯a2, ¯a1a2)

(cid:96)G2 I(a1, a1¯a2¯a1¯a1a2)

(cid:96)G2 S(a1a1¯a2¯a1¯a1a2)

3. Main result

Our main theorem is that the language of Gn is On. The inclusion of L(Gn) into On is
obvious and the challenge consists in proving the converse inclusion. We prove actually
a stronger statement: (cid:96)Gn I(s1, . . . , sn) is derivable for every s1 · · · sn in On. With this
statement, the desired inclusion is immediate: for w ∈ On, set s1 = w and sj = ε for all j (cid:62) 2
and apply rule (1).

A tuple (s1, . . . , sn) is reducible if there are at least two compatible letters among the
endpoints of the sj’s; otherwise the tuple is irreducible. Repeated applications of rules of
the form (3) allow to derive reducible tuples from irreducible ones. Irreducible tuples are
dealt with the following “decomposition lemma,” which shows how a rule of the form (2) is
applied to derive an irreducible tuple from smaller elements in On. While rule (4) provides
the base case for the induction, this lemma is the main technical result towards the proof of
Theorem 1. It relies on Theorem 2, a result stated and proved in Section 4, and formulated
with the terminology of the necklace splitting theorem.
n )n,
Lemma 1 (Decomposition lemma). Consider an irreducible tuple (s1, . . . , sn) in (Σ+
where each sj is of length at least 2. If s1 · · · sn belongs to On, then there exist two tuples
n)n and integers 0 = k0 (cid:54) k1 (cid:54) · · · (cid:54) kn = 2n
(u1, u3, . . . , u2n−1) and (u2, u4, . . . , u2n) in (Σ∗
such that

(I) u1u3 · · · u2n−1 and u2u4 · · · u2n are both nonempty elements of On, and
(II) sj = ukj−1+1 ukj−1+2 · · · ukj for each j ∈ [n].

4

In particular, s1 · · · sn = u1u2 · · · u2n.
Proof. We distinguish the cases n = 1 and n (cid:62) 2.

We deal first with the case n = 1. In that case, Σn = {a1, ¯a1}. As s1 is irreducible, without
loss of generality, we may assume that s1 = a1wa1. We consider prefixes u(cid:48) of w of increasing
length, from |u(cid:48)| = 0 to |u(cid:48)| = |w|. Since s1 belongs to O1, the quantity |a1u(cid:48)|a1 − |a1u(cid:48)|¯a1
starts with the value 1 and finishes with the value −1, and changes by steps of one unit.
There is therefore a prefix u(cid:48) of w such that a1u(cid:48) belongs to O1. Setting u1 = a1u(cid:48) and
u2 ∈ Σ+

1 such that s1 = u1u2 makes the job.

We deal now with the case n (cid:62) 2. The proof of Theorem 2 builds explicitly u(cid:96)’s satisfying
the desired properties: property (I) is a consequence of the fact that each of A and B are
balanced; property (II) is a consequence of the fact that the endpoints of the sj’s form
(cid:3)
cuts.

From this the inclusion follows easily.

Proposition 1. The judgment (cid:96)Gn I(s1, . . . , sn) is derivable for every s1 · · · sn in On. In
particular, we have On ⊆ L(Gn).

Proof. As mentioned above, the second part of the statement is a direct consequence of the
first part. We proceed by induction on the pairs (|s1 · · · sn|, e) ordered lexicographically,
where e is the number of sj equal to ε.

Suppose first that (s1, . . . , sn) is reducible. A rule of the form (3) shows that we can derive
n| < |s1 · · · sn|. The

n), with |s(cid:48)

1, . . . , s(cid:48)

the judgment from another judgment (cid:96)Gn I(s(cid:48)
induction hypothesis provides the conclusion.

1 · · · s(cid:48)

Suppose now that (s1, . . . , sn) is irreducible. Four cases are in order, distinguished according

to the possible lengths of the sj’s.

The first case is when at least one sj is of length 1. Without loss of generality we may
assume that sj = a1. As s1 · · · sn is in On, there is a k such that sk = v1¯a1v2 for some v1 and
v2 in Σ∗
n. The other case being similar, we suppose that j < k. Define tj = a1, tk = ¯a1, and
t(cid:96) = ε for (cid:96) (cid:54)= j, k; define also (u1, . . . , un) = (s1, . . . , sj−1, sj+1, . . . , sk−1, v1, v2, sk+1, . . . , sn).
Using rule (4) and a rule of the form (3), we get that (cid:96)Gn I(t1, . . . , tn) is derivable. The
judgment (cid:96)Gn I(u1, . . . , un) is derivable by induction. Then using a rule of the form (2) shows
that (cid:96)Gn I(s1, . . . , sn) is derivable. More precisely, we instantiate each variable x(cid:96) with t(cid:96)
and each variable y(cid:96) with u(cid:96) in the following rule

I(x1y1, . . . , xj−1yj−1, xj, yj, . . . , xk−2yk−2xk−1, yk−1xkyk, . . . , xnyn) ⇒

I(x1, . . . , xn), I(y1, . . . , yn) .

The second case is when all sj are equal to ε. The conclusion follows from an application

of rule (4).

The third case is when some sj but not all are equal to ε and no sj is of length 1. There
is then an j ∈ [n − 1] such that either sj = ε and |sj+1| > 1, or |sj| > 1 and sj+1 = ε. By
symmetry, we suppose that sj = ε and |sj+1| > 1. As |sj+1| > 1, we have that sj+1 = v1v2
with v1 and v2 in Σ+. Define (s(cid:48)
n) = (s1, . . . , sj−1, v1, v2, sj+2, . . . , sn). The judgment
(cid:96)Gn I(s(cid:48)
n) is derivable by induction (we have a smaller e). The judgment (cid:96)Gn I(ε, . . . , ε)
is derivable from an application of rule (4). Then using a rule of the form (2) shows that
(cid:96)Gn I(s1, . . . , sn) is derivable. More precisely, we instantiate each variable x(cid:96) with s(cid:48)
(cid:96) and

1, . . . , s(cid:48)

1, . . . , s(cid:48)

5

each variable y(cid:96) with ε in the following rule:

I(x1y1, . . . , xj−1yj−1, ε, xiyjxj+1yj+1, . . . , xnyn) ⇒ I(x1, . . . , xn), I(y1, . . . , yn) .

The fourth case satisfies the conditions of Lemma 1 (“decomposition lemma”), which
shows that (cid:96)Gn I(s1, . . . , sn) is derivable by an application of a rule of the form (2) and by
(cid:3)
induction.

From this we can derive our main theorem.

Theorem 1. The language On is an n-MCFL.

Remark. Theorem 2 actually implies a version of Lemma 1 that also holds for reducible
tuples albeit only if n is at least 2 and if we permit to decompose (s1, . . . , sn) in more versatile
tuples. This corresponds to a slightly more liberal definition of the rules (2). More precisely,
we may add to the rules (2) for each j ∈ [n] the rule:

(∗)

I(x1y1, . . . , xj−1yj−1, yjxj, xj+1yj+1, . . . , xnyn) ⇒ I(x1, . . . , xn), I(y1, . . . , yn) .

We have chosen to exclude rules (∗) to emphasize the surprising simplicity of the rules (2)
which allow to decompose every irreducible tuple. Moreover, we want to contrast the grammar
we obtain with the one that Nederhof [Ned17] conjectures to capture On. Nederhof proposes
binary rules of the following form:

A(w1, . . . , wn) ⇒ A(x1, . . . , xn), A(y1, . . . , yn)
where w1 · · · wn is obtained by shuffling the words x1 · · · xn and y1 · · · yn, i.e., |w1 · · · wn| = 2n,
removing all occurrences of yj’s from w1 · · · wn yields x1 · · · xn and, analogously, removing
all occurrences of xj’s from w1 · · · wn yields y1 · · · yn. Furthermore, a wk may not contain
an occurrence of xjxj+1 or of yjyj+1 for some j ∈ [n − 1]. The rules (2) may be obtained
from Nederhof’s by forbidding the occurrence of xjxj+1 and of yjyj+1 not only in the wk’s
but rather in the combined word w1 · · · wn. Note however that this additional restriction
implies that rules (3) need to allow the removal of compatible letters at arbitrary endpoints
of the words of a tuple. The corresponding rules of Nederhof’s grammar are less liberal.
Were we to remove rules (3) and treat the elimination of compatible letters as in [Ned17],
then we would need to add the rules (∗). Clearly, these rules form a strict subset of those
proposed by Nederhof as wk’s are of length 2 and at most one occurrence of xjxj+1 is allowed
in w1 · · · wn. In this sense, our grammar is simpler than Nederhof’s. Notably, also Nederhof
[Ned17, Sec. 5.3] conjectures for O3 that some of the rules of his grammar are redundant.

4. Necklace splitting and proof of the decomposition lemma

In this section, we prove a combinatorial theorem in the tradition of the necklace splitting
problem. The theorem almost implies Lemma 1, but while it does not require irreducibility,
it misses the property (II). Its proof however gives the construction for the case n > 1 of
Lemma 1.

This combinatorial theorem is formulated without the terminology of languages and
grammars so as to make it understandable easily without background in this area. For
readers who are more familiar to manipulating words, the vocabulary of the necklace problem
translates easily to that of words: necklaces become words and beads become letters.

In the traditional version of the necklace splitting theorem, there is an open necklace with
beads of n different types, and an even number of beads of each type. The necklace splitting
6

theorem ensures that such a necklace can always be split between two thieves with no more
than n cuts so that each thief gets the same amount of each type. The cuts have to leave the
beads untouched. Here, we keep the same setting, except that a bead can be either “positive”
or “negative.” The amount of a type in a necklace or in a collection of necklaces is the number
of positive beads of this type minus the number of negative beads of this type. A necklace or
a collection of necklaces is balanced if the amount of each type is zero.

Theorem 2. Consider a collection of n open necklaces with positive and negative beads.
Suppose that there are n (cid:62) 2 types of beads and that each of the necklaces has at least two
beads. If the collection is balanced, then there is a way to cut the necklaces using at most n
cuts in total and partition the subnecklaces into two parts so that each part is balanced, gets
at least one bead (and thus at least two), and is formed by at most n subnecklaces.

The connection to Lemma 1 is as follows:

• The n types of beads are the numbers 1, . . . , n, the letter ai representing a positive

bead of type i and the letter ¯ai representing a negative bead of type i.

• The n open necklaces correspond to the words s1, . . . , sn.
• The two parts of the at most n subnecklaces are the tuples (u1, . . . , u2n−1) and
(u2, . . . , u2n) in the lemma, which, as in the theorem, are required to be balanced and
to contain at least one letter each.

The proof of Theorem 2 relies on the following proposition, which is actually the traditional
necklace splitting theorem extended to negative beads (the relaxation of the parity condition
of the number of beads is standard; see, e.g., [AMS06, Section 5.1]).

Proposition 2. Consider a necklace with positive and negative beads. Suppose that there are
n (cid:62) 1 types of beads. Then the necklace can be split between two thieves with no more than n
cuts so that the amount of beads received by the thieves differ by at most one unit for each
type. It is moreover possible to choose which thief receives an extra bead for each type which
requires so.

The types requiring that one of the thieves receives an extra bead are precisely those whose

total amount of beads is an odd number.

Proof of Proposition 2. We proceed in two steps.
In a first step, we prove a continuous
version, in which we are allowed momentarily to locate cuts on beads themselves. In a second
step, we show how to move the cuts so as to get a splitting with cuts leaving the beads
untouched.1

We identify the necklace with [0, 1] and the beads with intervals included in [0, 1], all of
same length (this length is the inverse of the total number of beads in the necklace), and
with disjoint interiors. Assume that these small intervals are all open. (This assumption
is made to ease the proof, but actually whether these small intervals contain or not their
boundaries does not matter.) Define

gi(x) (cid:55)−→






+1 if x is in a interval corresponding to a positive bead of type i.
−1 if x is in a interval corresponding to a negative bead of type i.
0

otherwise.

1An alternative purely combinatorial proof is presented in Section 5.2.

7

According to the Hobby–Rice theorem [HR65], there are points 0 = x0 < x1 < · · · < xr <
xr+1 = 1 with r (cid:54) n such that for all i ∈ [n]
(cid:90) xj

r+1
(cid:88)

(−1)j

gi(u) d u = 0 .

j=1

xj−1

(Here, we take the formulation given by Pinkus [Pin76].) The r points x1, . . . , xr can be
interpreted as cuts. The intervals (xj−1, xj) with j odd are given to one thief, and the intervals
(xj−1, xj) with j even are given to the other thief. Each thief gets the same amount of each
type. The only problem is that some cuts may be located on beads.

The second step of the proof consists in explaining how to move these cuts so that none of
them touch the beads anymore, without creating a difference of more than one unit between
the amounts received by the thieves for each type. We can make that each bead is cut at most
twice since moving two cuts inside a bead in the same direction and by the same distance
does not change the amounts received by the thieves. If a bead is cut twice, we can similarly
move the two cuts until one of them is located between two beads. (Doing this, we can have
several cuts located at the same position between two beads, but this is not an issue.) So,
we can assume that each bead is cut at most once and that the two parts of a cut bead go
to distinct thieves. If a type has two beads or more touched by a cut, then we can move
two cuts so that one at least reaches a position between two beads, without changing the
amounts received by each thief. Thus, we can assume that each type is cut at most once.
We finish the proof by noting that if a type has a bead that is cut, it means that each thief
received a non-integral amount of the corresponding type, i.e., a half-integer, and moving the
(cid:3)
cut arbitrarily leads to the desired splitting.

Proof of Theorem 2. Denote by s1, . . . , sn the n necklaces. We assume that there are no
two beads located at the endpoints of some necklaces and that are of the same type but of
opposite signs, for otherwise there would be an easy solution: cut these two beads from the
necklaces, form a balanced part with them, and leave the rest of the remaining beads for the
second balanced part. The number of cuts would then be 2 (cid:54) n (or, if these two beads formed
a necklace of their own, the solution would need no cut), and the number of subnecklaces
in the parts would be 2 and n (or 1 and n − 1). Making this assumption corresponds to
considering only the irreducible case in the terminology of Theorem 1.

A natural idea would be to apply a result like Proposition 2 to the “big” necklace s = s1 · · · sn
obtained by appending the necklaces in their index order. The first issue with this idea is
that one thief might get nothing. This can easily be dealt with as done below. The second
issue is that, even though there are 2n subnecklaces in total, one thief might get more than
n subnecklaces.2 Instead we consider another big necklace, which we will denote by s(cid:48) and
which we define now.

We start by defining s(cid:48)
1 to be s1 from which the left-most bead has been removed, and
s(cid:48)
n to be sn from which the right-most bead has been removed. Note that without loss of
generality, we can assume that the left-most bead of s1 is a positive bead of type 1 and that
the right-most bead of sn is a positive bead of type 1 or n. We thus consider two cases:

(i) The left-most bead of s1 and the right-most bead of sn are both positive beads of

type 1.

2In essence, this is the reason why Ho [Ho18] could only show that On is an (cid:0)8 (cid:4) n+1

2

(cid:5) − 2(cid:1)-MCFL.

8

(ii) The left-most bead of s1 is a positive bead of type 1 and the right-most bead of sn is

a positive bead of type n.

The condition of the theorem ensures that neither s(cid:48)

1¯s2s3¯s4 · · · . If n is even, the big necklace s(cid:48) ends with ¯s(cid:48)

n are empty. Consider the “big”
necklace s(cid:48) = s(cid:48)
n, and if n is odd, it
n. (Given a sequence t of beads, the notation ¯t means t where all positive beads
ends with s(cid:48)
become negative and conversely, without changing their types.) According to Proposition 2,
there is a splitting of s(cid:48) into n + 1 subnecklaces t1, . . . , tn+1 (completing with zero-length
subnecklaces if necessary) such that we have for i ∈ [n] in Case (i) and for i ∈ {2, . . . , n − 1}
in Case (ii)

1 nor s(cid:48)

(2)

and such that in Case (ii)

(3)

(4)

(cid:88)

k odd

µi(tk) =

(cid:88)

k even

µi(tk) ,

(cid:88)

k odd
(cid:88)

µ1(tk) =

µn(tk) =

(cid:88)

k even
(cid:88)

µ1(tk) − 1 ,

µn(tk) + 1 .

k even
Here, we denote by µi(t) the amount of beads of type i in the subnecklace t. We remind
the reader that the amount of beads is the number of positive beads minus the number of
negative beads of this type.

k odd

We interpret now the endpoints of the subnecklaces tk as cuts of the “big” necklace s (the
one formed by the original necklaces sj). Together with the endpoints of the sj, we get a
splitting of s into 2n subnecklaces u1, . . . , u2n (in this order). Some u(cid:96) can be zero-length
subnecklaces. We make two parts: a part A formed by the u(cid:96) with an odd (cid:96), and a part B
formed by the u(cid:96) with an even (cid:96). Remark two things:

• Since the left-most bead of s1 belongs to u1 and the right-most bead of sn belongs to

u2n, each part contains at least one bead.

• The number of subnecklaces u(cid:96) is the same in each part, and thus equal to n.
We finish the proof by checking that both A and B are balanced. We denote by qA
i and
qB
i the amount of beads of type i in A and B, respectively. Since the original collection is
balanced, we have qA
i = 0. The end of the proof consists simply in checking that we
have also qA

i = 0, which implies then immediately that qA

i = 0, as desired.

i = qB

i + qB

i − qB

Each bead x belongs to exactly one sj. Moreover, apart from the two beads at the endpoints
of s, any bead x (resp. ¯x) belongs also to exactly one tk when j is odd (resp. even). It is
immediate to check that j + k − 1 and the index (cid:96) of the u(cid:96) to which x belongs have the
same parity. Thus if j + k − 1 is odd, then x belongs to A, and if it is even, then x belongs
to B. We have
qA
1 = 1+

µ1(¯sj ∩tk) and qB

µ1(sj ∩tk)−

µ1(sj ∩tk)−

µ1(¯sj ∩tk) ,

1 = δ(i) +

(cid:88)

(cid:88)

(cid:88)

(cid:88)

j,k odd

j,k even

and for i (cid:54)= 1, we have

qA
i =

(cid:88)

j,k odd

µi(sj ∩tk)−

(cid:88)

j,k even

µi(¯sj ∩tk)

j odd
k even

j even
k odd

and qB

i = δi=n

(ii) +

(cid:88)

j odd
k even

µi(sj ∩tk)−

(cid:88)

j even
k odd

µi(¯sj ∩tk) ,

9

where δ(i) ∈ {0, 1} and takes the value 1 only if we are in Case (i), and where δi=n
and takes the value 1 only if we are in Case (ii) and i = n.

(ii) ∈ {0, 1}

For the beads of type 1, we have

1 − qB
qA

1 = 1 − δ(i) +

n+1
(cid:88)

(cid:88)

(−1)k+1µ1(sj ∩ tk) +

n+1
(cid:88)

(cid:88)

(−1)k+1µ1(¯sj ∩ tk)

k=1
n+1
(cid:88)

k=1

= 1 − δ(i) +

= 0 ,

j odd

k=1

j even

(−1)k+1µ1(tk)

where the last equality is a consequence of Equation (2) in Case (i) and of Equation (3) in
Case (ii). For the beads of type i (cid:54)= 1, we have

i − qB
qA

i = −δi=n

(ii) +

n+1
(cid:88)

(cid:88)

(−1)k+1µi(sj ∩ tk) +

n+1
(cid:88)

(cid:88)

(−1)k+1µi(¯sj ∩ tk)

j odd

k=1

j even

k=1
n+1
(cid:88)

k=1

= −δi=n

(ii) +

= 0 ,

(−1)k+1µi(tk)

where the last equality is a consequence of Equation (2), except when i = n and we are in
(cid:3)
Case (ii), where we use of Equation (4) instead.

5. Alternate combinatorial proofs of Proposition 2 and Lemma 1

All statements deal with discrete objects and properties. It is thus desirable from a logical
point of view that all proofs stay in the “discrete world” if possible. Similarly to the traditional
proof of the necklace splitting theorem, the proof of Proposition 2 we gave in Section 4 is
relying on some “continuous” notions. Pálvőlgyi [Pál09] showed how such proofs are amenable
to the discrete world by using a combinatorial counterpart of the Borsuk–Ulam theorem.

We adapt here the approach proposed by Pálvőlgyi to provide a purely combinatorial proof
of Proposition 2, also relying on Tucker’s lemma. Moreover, we show how the more general
Ky Fan lemma can actually provide a direct combinatorial proof of Lemma 1 itself.
5.1. Combinatorial tools. We start by introducing some notation. Let B = {−1, 1}. For
brevity, we may write + instead of +1 and − instead of −1. Let O = {−1, 0, 1}. We define
the partial order ≺ on O where 0 ≺ 1 and 0 ≺ −1, or, equivalently, b (cid:52) b(cid:48) if b = 0 or b = b(cid:48).
For every m ∈ N, we lift ≺ to Om where for x, y ∈ Om we have x (cid:52) y if for all i ∈ [m],
x(i) (cid:52) y(cid:48)(i). Given a string x, we denote by x(i) the i-th letter of x. We also denote by −x
the string obtained from x by replacing 1’s by −1’s and −1’s by 1’s (and the 0’s are left
unchanged).

Now the Ky Fan lemma can be stated as follows:

Lemma 2 (Octahedral Ky Fan lemma, [Che11, Lemma 2]). Let λ : Om \ 0m → {±1, . . . , ±q}
such that

(i) λ(−x) = −λ(x) for every x.
(ii) λ(x) + λ(y) (cid:54)= 0 for every x (cid:52) y.

10

Then there is at least one positively alternating m-chain, i.e., there are x1, . . . , xm ∈ Om \ 0m
and j1, . . . , jm ∈ [q] such that x1 (cid:52) · · · (cid:52) xm, 1 (cid:54) j1 < j2 < · · · < jm, and λ({x1, . . . , xm}) =
{j1, −j2, j3, . . . , (−1)m−1jm}. In particular, q (cid:62) m.

(The statement we provide here is actually a special case of the original Ky Fan lem-
ma [Fan52] when the simplicial complex is the first barycentric subdivision of the octahedron.)
The octahedral Tucker lemma [Tuc46] is actually the same statement without the existence
of the chain, but still with the inequality q (cid:62) m.

We explain now how strings in Om relate to decompositions of strings in Σm

n . We consider
here all decompositions of a string w ∈ Σm
n into two tuples (u1, u3, . . . ), (u2, u4, . . . ) of strings
n such that w = u1u2 · · · . Such a decomposition is described as a string x ∈ Bm where
in Σ+
each maximal segment of consecutive −1’s, as well as each maximal segment of consecutive
+1’s, corresponds to one uj. Each sign change in x corresponds thus to a cut in w and to a
transition from a uj to uj+1. A string x ∈ Om, containing some 0’s, can be interpreted as
an underspecified decomposition, which can be completed into different decompositions by
replacing the 0’s with −1’s or +1’s.

5.2. Combinatorial proof of Proposition 2. We prove Proposition 2 in a way that is
similar to [Pál09].

For x in B∗ we let alt(x) be the number of sign alternations in x. We extend the function

alt to O∗ \ 0∗ as follows: alt(x) = max{alt(y) | y ∈ B∗, x (cid:52) y}. Notice that:

• alt(−x) = alt(x) for every x.
• alt(x) (cid:62) alt(y) for every x (cid:52) y.

For x in O∗ \ 0∗, we define sign(x) ∈ {−1, 1} as the first letter of some y in B∗ so that x (cid:52) y
and alt(x) = alt(y). The function sign(x) is well defined as when x is of the form 0kκx(cid:48), with
κ ∈ B, the only way to replace the first k zeroes so as to maximize alt consists in changing
the sign at each position.

From now on we fix the necklace w and assume it is of length m (i.e., w is in Σm
We let Eκ,i(x) for x in Om \ 0m and κ ∈ {−1, 1} be the amount of beads of type i in w
that are aligned with the symbol κ in x. We say that x is κi-unbalanced if Eκ,i(y) > E−κ,i(y)
for every y such that x (cid:52) y. We define unb(x) to be κi where i is the smallest i so that x is
κi-unbalanced. When no such i exists, we let unb(x) = 0. We have

n ).

• unb(−x) = − unb(x) for every x.
• |unb(x)| (cid:62) |unb(y)| > 0 for every x (cid:52) y if unb(x) (cid:54)= 0.

Notice that |unb(x)| = |unb(y)| implies unb(x) = unb(y) for every x (cid:52) y. Finally we define
λ as the function from Om to {−m + 1, . . . , 0, . . . , m − 1}:

λ(x) =

ß sign(x) alt(x) when alt(x) > n .
when alt(x) (cid:54) n .

unb(x)

Because of the properties of alt, sign and unb, had it no zero, the function λ would satisfy the
properties (i) and (ii) of the octahedral Tucker lemma. However, then the conclusion is not
satisfied, thus λ must have a zero. Take x so that λ(x) = 0. We must have that alt(x) (cid:54) n.
As unb(x) = 0, it is possible, for each type i, to replace 0’s in x with 1’s or −1’s so that
we eventually obtain y verifying E1,i(y) = E−1,i(y) for every i, and such that the remaining
0’s in y are aligned with at most one unassigned bead of type i. We can then choose to
replace these 0’s with either 1 or −1 depending on how we wish to treat the extra bead of a
11

given type. As alt(x) is smaller than n, then no matter how we have conducted the previous
changes, we have obtained a way to split the necklace with at most n cuts so that each part
contains the same amount of each type, with the extra beads (when the amount is odd) being
distributed in any possible way.

Remark. The definition of unb is where the proof departs from the one of [Pál09]. Indeed
Pálvőlgyi’s proof only considers positive beads and it is then enough to consider that x is
unbalanced when one of the thief receives more than half of the beads of some type. In that
case the split remains unbalanced for every y so that x (cid:52) y. This property is no longer true
with negative beads. Our definition of unb is taking this into account by imposing that being
unbalanced is closed under (cid:52).

5.3. Combinatorial proof of Lemma 1. Lastly, we present a direct combinatorial proof
of Lemma 1 that avoids Theorem 2. The method is again inspired by Pálvőlgyi [Pál09], but
instead of constructing a function λ that contradicts the Tucker lemma, if it has no zero,
we construct a pair of functions λ+ and λ−, for which the chains guaranteed by the Ky Fan
lemma cannot exist for irreducible tuples.

2 · · · κ(cid:96)k

In contrast to Section 5.2, we do not consider x ∈ Bm to represent the decomposition of a
single string but instead x shall represent the decomposition of an irreducible tuple (s1, . . . , sn)
in (Σ+
n )n where the word s1 · · · sn is in On and each sj is of length at least 2. To account for the
arity of the tuple, we need to generalize the notion of alt. Denote the word s1 · · · sn by s and
k with κ1, . . . , κk ∈ B, κp = −κp+1
the length of s by m. Factorize x such that x = κ(cid:96)1
and (cid:96)p ∈ N be such that for each j ∈ [n], there is qj ∈ {0, . . . , k} with (cid:80)
p∈[qj ] (cid:96)p,
and k is minimal. Now, if k = 2n, then x describes a decomposition of (s1, . . . , sn) in two
tuples each of size n. Precisely, these tuples are (u1, u3, . . . , u2n−1) and (u2, u4, . . . , u2n) where
the length of uj is (cid:96)j for each j ∈ [2n] and sj = uqi−1+1uqi−1+2 · · · uqj for each j ∈ [n]. If
k < 2n, we may add κq’s with (cid:96)q = 0 to increase k to 2n and proceed similarly. We call
the value k − 1 the number of sign alternations of x and write alt(x) = k − 1. Hence, in
the following we will search for x with alt(x) (cid:54) 2n − 1. Crucially, we assume mandatory
sign alternations between the neighboring endpoints of sj and sj+1: if the last position of
sj and the first position of sj+1 are signed equally in x, then some κp with (cid:96)p = 0 occurs
in our factorization of x. In this case 2 sign alternations are accounted for the transition
between neighboring endpoints. In order to maximize alt, we may choose x to be strictly

p∈[j] |sp| = (cid:80)

1 κ(cid:96)2

s1

s2

s3

a1 a2 ¯a2 a3 ¯a2 ¯a3 a1 ¯a1 ¯a1 ¯a2

x =

+ − − − − − − + − −

alt(x) =

+1

+2

+1 +1

(

u1

u2

u3,

u4

,

u5 u6

= 5

)

Figure 1. A word s1s2s3, a decomposition x with the corresponding alignment
of sj’s to up’s (in particular, u3 = ε), and the calculation of alt(x).

12

alternating except for the n − 1 transitions between neighboring endpoints. In consequence
alt(x) (cid:54) m − (n − 1) + 2(n − 1) − 1 = m + n − 2.

Figure 1 gives an example: Note that alt(x) < 2 · 3 and that the subwords in +-
labeled and −-labeled positions are both in O3. Thus, x describes the decomposition of
(a1a2¯a2a3, ¯a2¯a3a1, ¯a1 ¯a1¯a2) to two strictly smaller 3-tuples (a1, ε, ¯a1) and (a2¯a2a3, ¯a2¯a3a1, ¯a1¯a2),
for each of which the word obtained by concatenating the tuple’s components is in O3.

Again, we consider words in Om \ 0m which may have unsigned positions, i.e., positions
labeled with 0.
In this case the decomposition is only partially determined. We define
the function h : Om \ 0m → [m + n − 2] by h(x) = maxy∈Bm : x(cid:52)y alt(y). Observe that
alt(x) = alt(−x), hence, for each x ∈ Om \ 0m: h(x) = h(−x). Also, for each x, y ∈ Om \ 0m
with x (cid:52) y, we have h(x) (cid:62) h(y).

Denote by H(x) the set arg maxy∈Bm : x(cid:52)y alt(y). All elements of H(x) may be obtained

with the following algorithm:

(i) Choose a signed position p in x with an unsigned neighbor p(cid:48) ∈ {p − 1, p + 1}.
(ii) If p and p(cid:48) are neighboring endpoints (in this case we call p and p(cid:48) internal endpoints),
set x(cid:48)(p(cid:48)) = x(p); otherwise set x(cid:48)(p(cid:48)) = −x(p). For each q (cid:54)= p(cid:48), set x(cid:48)(q) = x(q).

(iii) If x(cid:48) ∈ Bm we are done, otherwise, recursively apply the algorithm to x(cid:48).

This algorithm may yield words y, y(cid:48) where y(p) (cid:54)= y(cid:48)(p) if p is an unsigned position between
two signed positions of x. However, for all position p(cid:48) smaller than the smallest signed position
of x, the signs y(p(cid:48)) and y(cid:48)(p(cid:48)) are equal for all words y, y(cid:48) in H(x). Hence, we may define a
function sign : Om \ 0m → B to assign to x the first symbol of some y ∈ H(x). Moreover, for
each x ∈ Om \ 0m: sign(x) = − sign(−x).

To prove Lemma 1, we need to show that there is x ∈ Bm with alt(x) < 2n and that both
words u1u3 · · · and u2u4 · · · described by x are in On and non-empty. To assure non-emptiness,
we just need that both signs occur in x. To ensure that the words are in On, we rephrase
the notions Eκ,i and unb from Section 5.2 in terms of tuples of words instead of necklaces.
Now Eκ,i(x) is formulated as the difference of the amount of ai’s and ¯ai’s aligned with κ in x.
Formally:





Eκ,i(x) = |{p | s(p) = ai ∧ x(p) = κ}| − |{p | s(p) = ¯ai ∧ x(p) = κ}| .
Observe that E+,i(x) + E−,i(x) = 0 for s ∈ On and x ∈ Bm. We define two functions λ+ and
λ−, where for each b ∈ B, λb : Om \ 0m → {±1, . . . , ±m} ∪ {0} is such that

λb(x) =

sign(x) · (h(x) − n + 2)
b · (−1) · b(cid:48) · (n + 1)
unb(x)

if h(x) (cid:62) 2n .
if h(x) < 2n ∧ ∃b(cid:48) ∈ B : |x|b(cid:48) = 0 .
if h(x) < 2n ∧ |x|+ > 0 ∧ |x|− > 0 .

(C1)

(C2)

(C3)
If there are x ∈ Om \ 0m and b ∈ B such that λb(x) = 0, then Lemma 1 holds: Note that case
C3 of λb applies. Thus, for each i ∈ [n] there is y ∈ Bm such that E+,i(y) = E−,i(y) = 0. The
positions relevant to balance ai and aj where i (cid:54)= j are distinct. Hence, we choose ˆy ∈ Bm
with x (cid:52) ˆy such that all symbols are balanced. Since ˆy (cid:60) x we have that alt(ˆy) (cid:54) h(x) < 2n,
|ˆy|+ > 0, and |ˆy|− > 0. Thus, ˆy encodes a decomposition with the desired properties.

Otherwise, if λ+ and λ− have no zero, we want to apply the Ky Fan lemma. Clearly, λb
satisfies property (i) of the octahedral Ky Fan lemma if cases C1 and C3 apply. For case C2,
note that |x|+ = 0 = |−x|− implies

−λb(x) = −(b · (−1) · (+1) · (n + 1)) = (b · (−1) · (−1) · (n + 1)) = λb(−x) .
13

It remains to show property (ii), i.e., that the sum λb(x) + λb(y) is not zero if x (cid:52) y and
λb(x) (cid:54)= 0 (cid:54)= λb(y). Assume λb(x) + λb(y) = 0. By the definition of λb, there are three cases:
C1: h(x) = h(y) (cid:62) 2n and sign(x) = − sign(y). But then H(x) ⊇ H(y) and, thus,

sign(x) = sign(y), a contradiction.

C2: h(x), h(y) < 2n and either |x|+ = 0 = |y|− or |x|− = 0 = |y|+. W.l.o.g. assume that
|x|− = 0 = |y|+. Then there is k ∈ [m] such that x(k) = +. But x (cid:52) y implies
y(k) = +, a contradiction to |y|+ = 0.

C3: h(x), h(y) < 2n, |x|+, |y|+ > 0, |x|−, |y|− > 0 and unb(x) = − unb(y). This contra-
dicts properties of unb shown in Section 5.2: for every x (cid:52) y with unb(x) (cid:54)= 0 we
have |unb(x)| (cid:62) |unb(y)|, where |unb(x)| = |unb(y)| implies unb(x) = unb(y).

Proposition 3. If λ+ and λ− have no zero, then every pair of compatible symbols ai, ¯ai ∈ Σn
can be reduced from (s1, . . . , sn).

Lemma 1 follows directly, as whenever (s1, . . . , sn) is irreducible, λ+ and λ− have a zero.

To show Proposition 3 assume that for either b ∈ B there is no x ∈ Om \ 0m such that
λb(x) = 0. By Lemma 2, for each b ∈ B, there is a positively alternating m-chain, i.e., there
(cid:52) xb
are xb
2 < · · · < jb
m}) =
2
1
m
{(−1)k−1jb
k | k ∈ [m]}. We derive the following properties of the chains and (s1, . . . , sn):

(cid:54) m such that λb({xb

m and 1 (cid:54) jb

(cid:52) · · · (cid:52) xb

1, . . . , xb

1 < jb

1, . . . , jb

m are pairwise distinct and in [m]. Thus, jb
(a) The values jb
k = k for each k ∈ [m].
(b) By the definition of ≺, every strictly increasing chain in Om \ 0m has at most length
2|+ + |xb
m|− = m. Also,
k(p) = 0 and

2|− = 2, . . ., and |xb
k+1 differ in exactly one position p, i.e., xb

m. Specifically, |xb
for each k ∈ [m − 1], xb
k+1(p) ∈ B and for each p(cid:48) (cid:54)= p: xb
xb

1|− = 1, |xb

k(p(cid:48)) = xb

m|+ + |xb

k and xb

1|+ + |xb

k+1(p(cid:48)).

(c) By (a), all cases (C1, C2, C3) of λb apply. Because h is antitone, C1 applies to
k+1) for each k ∈ [m − n − 1]. On the other hand,

xb
1, . . . , xb
for k ∈ {0, 1, . . . , n}, we have that h(xb

m−n−1 where h(xb

m−n+k) < 2n.
Case C2 applies to exactly one of the words xb

k) > h(xb

m−n, . . . , xb

m while to the remaining
words case C3 applies. For C2 to apply, only one sign (cid:62)b ∈ B may occur in the word,
while C3 requires that both signs occur. Hence C2 applies to xb
m−n as the words, to
which C3 apply, need to be larger with respect to (cid:52). Moreover, as xb
m−n is larger
1, . . . , xb
than xb
m−n−1, the latter are in {(cid:62)b, 0}m, too. (cid:62)b is determined by the sign
of λb(xb
m−n) = (−1)n · (n + 1), i.e., it depends on b and the parity of n. Precisely:
(cid:62)b = b · (−1)n.
(d) C3 applies to xb

m−n+k for each k ∈ [n] and yields values {1, −2, 3, . . . , (−1)n−1n}. As
m−n+k)| > |unb(xb
m−n+k+1)| for all k ∈ [n − 1].
m−n+k) = (−1)n−k · (n − k + 1). Denote n − k + 1 by i. Observe that
m−n trivially balances every symbol. Hence,
m−n+k with −(cid:62)b where
i depends on (cid:62)b and the parity of i: If

unb(xb
Thus, λ(xb
unb(xb
m−n) = 0 because the word (cid:62)b
to ultimately unbalance ai, a position pb
s(pb
(−1)i−1 = −(cid:62)b, then pb
Let U = {p ∈ [m] | ∃b ∈ B : xb

i ) is either ai or ¯ai. The exact choice of pb

m−n+k) (cid:54)= 0, we have that |unb(xb

i is newly signed in xb

i ) = ai, otherwise, pb

i is such that s(pb

i is such that s(pb

i | b ∈ B, i ∈ [n]}. From
(cid:62)+ = (+1) · (−1)n = (−1) · (−1) · (−1)n = (−1) · (cid:62)−

m−n(p) = 0} = {pb

i ) = ¯ai.

m (cid:60) xb

and (d) it follows that p+
i
and Σn ⊆ {s(p) | p ∈ U }. To complete our proof, we further characterize the set U .

i and ai, ¯ai ∈ {s(p) | p ∈ U } for each i ∈ [n]. Hence, |U | = 2n

(cid:54)= p−

14

Property 1. Let p and p + 1 be neighboring endpoints. At most one of p and p + 1 is signed
in xb

m−n.

Proof. Assume the contrary. Let k ∈ [m − n] be minimal such that xb
k−1(p + 1) = 0. W.l.o.g. assume that xb
i.e., either xb
using our algorithm to construct an element of H(xb
obtain xb

k(p) = (cid:62)b = xb
k(p + 1),
k−1(p + 1) = 0. Hence,
k−1), we may set p + 1 to (cid:62)b, i.e., we
(cid:3)

k−1(p) = 0 or xb

k−1), contradicting (c).

k. But then h(xb

k) = h(xb

Let p and p + 1 be neighboring endpoints. We denote C(p) = C(p + 1) = {p, p + 1}. For

each position p(cid:48) ∈ [m] that is not an internal endpoint, we denote C(p(cid:48)) = {p(cid:48)}.
Property 2. Let 1 < p < m be an unsigned position in xb
Then C(p − 1) or C(p + 1) contain only unsigned positions in xb

m−n.

m−n that is not an internal endpoint.

k−1. Using the algorithm to construct an element of H(xb

Proof. Assume the contrary. Let k ∈ [m − n] be minimal such that both C(p − 1) and C(p + 1)
contain a signed position in xb
k. W.l.o.g. assume that C(p − 1) contains a signed position
already in xb
k−1), we may first set
the other position in C(p − 1) to (cid:62)b (if it exists), then set p to −(cid:62)b, then set each position
of C(p + 1) to (cid:62)b and call the intermediate result y. We may also obtain y from xb
k by first
setting each unsigned position of C(p + 1) to (cid:62)b, then p to −(cid:62)b, and then the remaining
(cid:3)
position of C(p − 1) to (cid:62)b, if it exists. Thus, h(xb

k−1), contradicting (c).

k) = h(xb

There are n − 1 pairs of neighboring endpoints, i.e., in total 2n − 2 internal endpoints.
x+
m−n and x−
m−n each have n unsigned positions, of which, by Property 1, at least n − 1 are
internal endpoints. Property 2 implies that the only unsigned position that is not an internal
endpoint, if one exists, is 1 or m. Thus, U consists solely of endpoints of the sj’s. However,
all symbols of Σn are distributed at the positions in U . Hence, (s1, . . . , sn) is such that every
pair of compatible letters of Σn can be reduced. This concludes the proof of Proposition 3.

References

[AMS06] Noga Alon, Dana Moshkovitz, and Shmuel Safra. Algorithmic construction of sets for k-restrictions.

[AW86]

[Bac81]

[Bac88]

[Che11]

[Fan52]

[Gil05]

[Ho18]

[HR65]

ACM Transactions on Algorithms (TALG), 2(2):153–177, 2006.
Noga Alon and Douglas B. West. The Borsuk–Ulam theorem and bisection of necklaces. Proceedings
of the American Mathematical Society, 98(4):623–628, 1986.
Emmon Bach. Discontinuous constituents in generalized categorial grammars. In Victoria Burke
and James Pustejovsky, editors, Proceedings of the 11th Annual Meeting of the Northeastern
Linguistics Society, pages 1–12, 1981.
Emmon Bach. Categorial grammars as theories of language. In Richard T. Oehrle, Emmon Bach,
and Deirdre Wheeler, editors, Categorial Grammars and Natural Language Structures, pages
17–34. D. Reidel, 1988.
Peng-An Chen. A new coloring theorem of Kneser graphs. Journal of Combinatorial Theory,
Series A, 118(3):1062–1071, 2011.
Ky Fan. A generalization of Tucker’s combinatorial lemma with topological applications. Annals
of Mathematics, 56(3):431–437, 1952.
Robert Gilman. Formal languages and their application to combinatorial group theory. In Groups,
Languages, Algorithms, number 378 in Contemporary Mathematics, pages 1–36. Amer. Math.
Soc., 2005.
Meng-Che Ho. The word problem of Zn is a multiple context-free language. Groups Complexity
Cryptology, 10(1):9–15, 01 May. 2018.
Charles R. Hobby and John R. Rice. A moment problem in l1 approximation. Proceedings of the
American Mathematical Society, 16(4):665–670, 1965.

15

[Jos85]

Aravind K. Joshi. Tree-adjoining grammars: How much context sensitivity is required to provide
reasonable structural descriptions? In David Dowty, Lauri Karttunen, and Arnold M. Zwicky,
editors, Natural Language Parsing, pages 206–250. Cambridge University Press, 1985.
[JSW91] Aravind K. Joshi, Vijay K. Shanker, and David J. Weir. The converence of mildly context-sensitive
grammar formalisms. In Peter Sells, Stuart M. Shieber, and Thomas Wasow, editors, Foundational
Issues in Natural Language Processing, pages 31–81. The MIT Press, 1991.
Makoto Kanazawa and Sylvain Salvati. MIX is not a tree-adjoining language. In Proceedings of
the 50th Annual Meeting of the Association for Computational Linguistics, pages 666–674, 2012.
David E. Muller and Paul E. Schupp. Groups, the theory of ends, and context-free languages.
Journal of Computer and System Sciences, 26(3):295–310, 1983.

[MS83]

[KS12]

[Ned16] Mark-Jan Nederhof. A short proof that O2 is an MCFL. In Proceedings of the 54th Annual Meeting

of the Association for Computational Linguistics, 2016.

[Pál09]

[Pin76]

[Ned17] Mark-Jan Nederhof. Free word order and MCFLs. In M. Wieling, M. Kroon, G. van Noord, and
G. Bouma, editors, From Semantics to Dialectometry: Festschrift for John Nerbonne, chapter 28,
pages 273–282. College Publications, 2017.
Dömötör Pálvölgyi. Combinatorial necklace splitting. The Electronic Journal of Combinatorics,
pages R79–R79, 2009.
Allan Pinkus. A simple proof of the Hobby–Rice theorem. Proceedings of the American Mathe-
matical Society, 60(1):82–84, 1976.
Geoffrey K. Pullum. Context-freeness and the computer processing of human languages. In
Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics, pages
1–6, 1983.
Sylvain Salvati. MIX is a 2-MCFL and the word problem in is captured by the IO and the OI
hierarchies. Journal of Computer and System Sciences, 81(7):1252–1277, 2015.
Hiroyuki Seki and Yuki Kato. On the generative power of multiple context-free grammars and
macro grammars. IEICE Transactions, 91-D(2):209–221, 2008.

[Pul83]

[Sal15]

[SK08]

[SMFK91] Hiroyuki Seki, Takashi Matsumura, Mamoru Fujii, and Tadao Kasami. On multiple context free

[Tuc46]

[Wei88]

grammars. Theoretical Computer Science, 88(2):191–229, 1991.
Albert W. Tucker. Some topological properties of disk and sphere. In Proc. First Canadian Math.
Congress 1945, pages 285–309, Montreal, 1946. University of Toronto Press.
David J. Weir. Characterizing mildly context-sensitive grammar formalisms. PhD thesis, University
of Pennsylvania, Philadephia, PA, 1988.

16

