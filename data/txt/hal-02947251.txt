Querying and Repairing Inconsistent Prioritized
Knowledge Bases: Complexity Analysis and Links with
Abstract Argumentation
Meghyn Bienvenu, Camille Bourgaux

To cite this version:

Meghyn Bienvenu, Camille Bourgaux. Querying and Repairing Inconsistent Prioritized Knowledge
Bases: Complexity Analysis and Links with Abstract Argumentation. KR 2020 - 17th International
Conference on Principles of Knowledge Representation and Reasoning, Sep 2020, Rhodes, Greece.
pp.141-151. ￿hal-02947251￿

HAL Id: hal-02947251

https://inria.hal.science/hal-02947251

Submitted on 24 Sep 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Querying and Repairing Inconsistent Prioritized Knowledge Bases:
Complexity Analysis and Links with Abstract Argumentation

Meghyn Bienvenu1 , Camille Bourgaux2
1 CNRS & University of Bordeaux, France
2 DI ENS, ENS, CNRS, PSL University & Inria, Paris, France
meghyn.bienvenu@u-bordeaux.fr, camille.bourgaux@ens.fr

Abstract

In this paper, we explore the issue of inconsistency handling
over prioritized knowledge bases (KBs), which consist of an
ontology, a set of facts, and a priority relation between con-
ﬂicting facts. In the database setting, a closely related sce-
nario has been studied and led to the deﬁnition of three dif-
ferent notions of optimal repairs (global, Pareto, and com-
pletion) of a prioritized inconsistent database. After transfer-
ring the notions of globally-, Pareto- and completion-optimal
repairs to our setting, we study the data complexity of the
core reasoning tasks: query entailment under inconsistency-
tolerant semantics based upon optimal repairs, existence of
a unique optimal repair, and enumeration of all optimal re-
pairs. Our results provide a nearly complete picture of the
data complexity of these tasks for ontologies formulated in
common DL-Lite dialects. The second contribution of our
work is to clarify the relationship between optimal repairs and
different notions of extensions for (set-based) argumentation
frameworks. Among our results, we show that Pareto-optimal
repairs correspond precisely to stable extensions (and often
also to preferred extensions), and we propose a novel seman-
tics for prioritized KBs which is inspired by grounded exten-
sions and enjoys favourable computational properties. Our
study also yields some results of independent interest con-
cerning preference-based argumentation frameworks.

1

Introduction

Ontology-mediated query answering (OMQA) improves
data access through the use of an ontology, which pro-
vides a convenient vocabulary for query formulation and
captures domain knowledge that is exploited during query
evaluation (Poggi et al. 2008; Bienvenu and Ortiz 2015;
Xiao et al. 2018). There is now a large literature on OMQA,
with much of the work adopting description logics (DLs)
(Baader et al. 2017), or the closely related OWL (2) standard
(OWL Working Group 2009), as the ontology speciﬁcation
language. In particular, the DL-Lite family of lightweight
DLs (Calvanese et al. 2007; Artale et al. 2009) (which un-
derpin the OWL 2 QL proﬁle (Motik et al. 2012)) has been
a main focus of both theoretical and practical research due
to its favourable computational properties.

While it is often reasonable to assume that the ontol-
ogy has been debugged and contains only trusted knowl-
edge, real-world datasets are plagued by data quality issues,

which may render the KB inconsistent. This has led to a
large body of work on how to handle data inconsistencies in
OMQA, with the proposal of several inconsistency-tolerant
semantics to provide meaningful answers to queries posed
over inconsistent KBs (see e.g. the surveys (Bienvenu and
Bourgaux 2016) and (Bienvenu 2019)). Many of these se-
mantics are based upon some notion of repair, deﬁned as
an inclusion-maximal subset of the data that is consistent
with the ontology. This is in particular the case for the AR,
brave, and IAR semantics, which correspond respectively to
a query answer holding w.r.t. all repairs, at least one re-
pair, or the intersection of all repairs (Lembo et al. 2010;
Bienvenu and Rosati 2013). The computational properties
of these and other semantics are now quite well understood,
and some practical algorithms and implementations have be-
gun to be developed, see e.g. (Lembo et al. 2015; Bien-
venu, Bourgaux, and Goasdou´e 2019; Tsalapati et al. 2016;
Trivela, Stoilos, and Vassalos 2018).

In many scenarios, there is some information about the
dataset that can be used to select the most relevant repairs
(e.g. we might know which relations or sources are most
reliable, or the likelihood of certain kinds of facts being cor-
rect). To exploit such information, variants of the preced-
ing semantics have been considered in which we restrict at-
tention to the most preferred repairs based upon cardinal-
ity, weight, or a stratiﬁcation of the dataset into priority
levels (Bienvenu, Bourgaux, and Goasdou´e 2014). While
the latter forms of preferences are quite natural, there are
other relevant ways of deﬁning preferred repairs that are
worth exploring.
In particular, in the database area, the
seminal work of Staworko, Chomicki, and Marcinkowski
(2012) supposes that preferences are given in terms of a pri-
ority relation (i.e. acyclic binary relation) between conﬂict-
ing facts. Such ‘fact-level’ preferences have been shown
to naturally arise in applications like information extrac-
tion and can e.g. be declaratively speciﬁed using rules (Fa-
gin et al. 2016). To lift a priority relation between facts to
the level of repairs, three different methods were proposed
by Staworko et al. Pareto-optimal and globally-optimal re-
pairs are deﬁned as those for which there is no possible
substitution of facts that leads to a (Pareto / global) im-
provement, while completion-optimal repairs correspond to

greedily constructing a repair based upon some compatible
total order (see Section 3 for formal deﬁnitions). The com-
plexity of reasoning with these three kinds of optimal re-
pair has been investigated, primarily focusing on constraints
given as functionality dependencies (Fagin, Kimelfeld, and
Kolaitis 2015; Kimelfeld, Livshits, and Peterfreund 2017;
Livshits and Kimelfeld 2017).

In this paper, we explore the use of fact-level preferences
and optimal repairs for inconsistency handling in OMQA.
Our ﬁrst contribution is a data complexity analysis of the
central reasoning problems related to optimal repairs: con-
junctive query entailment under inconsistency-tolerant se-
mantics based upon optimal repairs, uniqueness of optimal
repairs, and enumeration of all optimal repairs. Our re-
sults provide a nearly complete picture of the data complex-
ity for the three types of optimal repair and for ontologies
formulated in DL-Litecore and DL-LiteH
horn; however, as we
make precise later, many of our results transfer to other data-
tractable ontology languages. Not surprisingly, we ﬁnd that
reasoning with optimal repairs is generally more challeng-
ing than for standard repairs. In particular, query entailment
under variants of the AR, IAR, and brave semantics based
upon any of the three notions of optimal repair is intractable
in data complexity, whereas with standard repairs, the IAR
and brave semantics allow for tractable query answering.

Our second contribution is to establish connections with
abstract argumentation frameworks (AFs). More precisely,
we show that every prioritized KB with only binary con-
ﬂicts naturally corresponds to a preference-based AF (Kaci,
van der Torre, and Villata 2018). To handle general pri-
oritized KBs, we need preference-based set-based AFs
(SETAFs), which we introduce as a natural extension of
SETAFs (Flouris and Bikakis 2019). This correspondence
enables us to compare repairs and extensions. We determine
that Pareto-optimal repairs are precisely the stable exten-
sions of the corresponding preference-based (SET)AF, and
under reasonable assumptions, also coincide with the pre-
ferred extensions. To establish the latter result, we prove a
technically challenging result about symmetric preference-
based SETAFs that we believe is of independent inter-
est. Globally-optimal and completion-optimal repairs cor-
respond to proper subsets of the stable extensions, but do
not at present have any analog in the argumentation setting.
The argumentation connection situates optimal repairs
within a broader context and lays the foundations for im-
porting ideas and results from the argumentation literature.
Indeed, our third contribution is to propose a new notion of
grounded repair, directly inspired by grounded extensions
from argumentation. We show that the (unique) grounded
repair is contained in the intersection of Pareto-optimal re-
pairs. As the grounded repair can be computed in polyno-
mial time from the dataset and conﬂicts, it yields a tractable
approximation of the Pareto variant of the IAR semantics
for the considered DLs. Moreover, we show that it is more
productive than the recently proposed Elect semantics (Be-
labbes, Benferhat, and Chomicki 2019; Belabbes and Ben-
ferhat 2019). These advantages motivate us to take a closer
look at the computational properties of the grounded se-
mantics. We prove in particular a matching P lower bound

and show how the semantics can be computed via the well-
founded semantics of logic programs.

Proofs are omitted due to lack of space but can be found

in the long version (Bienvenu and Bourgaux 2020).

2 Preliminaries

Even if many of our results apply to more general settings,
our focus is on description logic (DL) knowledge bases,
and we will in particular consider the DL-Litecore and DL-
LiteH

horn dialects of the DL-Lite family.

Syntax. A DL knowledge base (KB) K = (cid:104)T , A(cid:105) consists of
an ABox A and a TBox T , both constructed from a set NC of
concept names (unary predicates), a set of NR of role names
(binary predicates), and a set NI of individuals (constants).
The ABox (dataset) consists of a ﬁnite number of concept
assertions of the form A(a) and role assertions of the form
R(a, b), where A ∈ NC, R ∈ NR, a, b ∈ NI. The TBox
(ontology) consists of a set of axioms whose form depends
In DL-Litecore, TBox axioms are
on the DL in question.
concept inclusions B (cid:118) C built according to the following
grammar, where A ∈ NC and R ∈ NR:

B := A | ∃S, C := B | ¬B, S := R | R−.

DL-LiteH

horn extends DL-Litecore with role inclusions of
the form S (cid:118) Q where Q := S | ¬S and concept inclusions
of the form B1 (cid:117) · · · (cid:117) Bn (cid:118) C.

Semantics. An interpretation has the form I = (∆I, ·I),
where ∆I is a non-empty set and ·I maps each A ∈ NC to
AI ⊆ ∆I, each R ∈ NR to RI ⊆ ∆I ×∆I, and each a ∈ NI
to aI ∈ ∆I. The function ·I is straightforwardly extended
to general concepts and roles, e.g. (¬B1)I = ∆I \ BI
1 ,
(B1 (cid:117) B2)I = BI
2 , (R−)I = {(c, d) | (d, c) ∈ RI}
and (∃Q)I = {c | ∃d : (c, d) ∈ QI}. An interpretation
I satisﬁes G (cid:118) H if GI ⊆ H I; it satisﬁes A(a) (resp.
R(a, b)) if aI ∈ AI (resp. (aI, bI) ∈ RI). We call I
a model of K = (cid:104)T , A(cid:105) if I satisﬁes all axioms in T and
assertions in A. A KB K is consistent if it has a model;
otherwise it is inconsistent. We say that an ABox A is T -
consistent if the KB K = (cid:104)T , A(cid:105) is consistent.

1 ∩ BI

Queries. A ﬁrst-order (FO) query is a ﬁrst-order logic for-
mula whose atoms are built using the predicate symbols
in NC ∪ NR and constants in NI. We will focus on the
subclass of conjunctive queries (CQs) which take the form
q((cid:126)x) = ∃(cid:126)y ψ((cid:126)x, (cid:126)y), where ψ is a conjunction of atoms of the
forms A(t) or R(t, t(cid:48)) whose terms are either variables from
(cid:126)x ∪ (cid:126)y or individuals. When a CQ consists of a single atom,
we called it an instance query (IQ). A query without free
variables is called Boolean, and we refer to Boolean CQs as
BCQs. A Boolean query q is satisﬁed by an interpretation I,
written I |= q, iff q is satisﬁed in I according to standard
ﬁrst-order logic semantics; q is entailed by a KB K, written
K |= q, iff I |= q for every model I of K. Henceforth, when
we speak of a (Boolean) query, without specifying the type
of query, we mean a (Boolean) CQ.

3 Querying Inconsistent Prioritized KBs
An inconsistent KB entails every Boolean query under the
standard semantics. Several inconsistency-tolerant seman-
tics have been deﬁned to obtain meaningful answers in this
context (see (Bienvenu and Bourgaux 2016) for a survey).
Most of these semantics are based on the notion of repairs,
which correspond to the different ways of restoring consis-
tency by minimally removing some assertions.
Deﬁnition 1 (Repair). An ABox repair of a KB K = (cid:104)T , A(cid:105),
or repair for short, is an inclusion-maximal T -consistent
subset of A. The set of repairs of K is denoted by SRep(K).
Another central notion is that of conﬂicts, which are the

minimal subsets of assertions that contradict the TBox.
Deﬁnition 2 (Conﬂict). A conﬂict of a KB K = (cid:104)T , A(cid:105), is a
minimal T -inconsistent subset of A. The set of all conﬂicts
of K is denoted by Conf (K) and can be represented as a
conﬂict hypergraph whose vertices are assertions and whose
hyperedges are the conﬂicts.

To simplify the presentation, we assume throughout the
paper that the ABox does not contain any assertion that is
inconsistent with the TBox, i.e., every conﬂict contains at
least two assertions. Note that self-contradictory assertions
do not occur in any repair, and such assertions can be readily
identiﬁed and removed using existing reasoning algorithms.
In the database setting, Staworko, Chomicki, and
Marcinkowski (2012) deﬁned three notions of optimal re-
pairs based on a priority relation over facts, which expresses
preferences between conﬂicting facts. Such a relation could
e.g. represent expert knowledge of how to resolve certain
kinds of conﬂicts or be learned from manual conﬂict resolu-
tion (Martinez et al. 2014; Tanon, Bourgaux, and Suchanek
2019). We recast these notions in the KB setting.
Deﬁnition 3 (Priority relation, completion). Given a KB
K = (cid:104)T , A(cid:105), a priority relation (cid:31) for K is an acyclic bi-
nary relation over the assertions of A such that if α (cid:31) β,
then there exists C ∈ Conf (K) such that {α, β} ⊆ C. A
priority relation (cid:31) is total iff for all α (cid:54)= β, if there exists
C ∈ Conf (K) such that {α, β} ⊆ C, then α (cid:31) β or β (cid:31) α.
A completion of (cid:31) is a total priority relation (cid:31)(cid:48) ⊇ (cid:31).
Deﬁnition 4 (Prioritized KB). A prioritized KB is a pair
(K, (cid:31)) consisting of a KB K and priority relation (cid:31) for K.
The notation K(cid:31) will be used as shorthand for (K, (cid:31)).
Deﬁnition 5 (Optimal repairs). Consider a prioritized KB
K(cid:31) with K = (cid:104)T , A(cid:105), and let A(cid:48) ∈ SRep(K).
• A Pareto improvement of A(cid:48) (w.r.t. (cid:31)) is a T -consistent
A(cid:48)(cid:48) ⊆ A such that there exists β ∈ A(cid:48)(cid:48) \ A(cid:48) such that
β (cid:31) α for every α ∈ A(cid:48) \ A(cid:48)(cid:48).

• A global improvement of A(cid:48) (w.r.t. (cid:31)) is a T -consistent
A(cid:48)(cid:48) ⊆ A such that A(cid:48)(cid:48) (cid:54)= A(cid:48) and for every α ∈ A(cid:48) \ A(cid:48)(cid:48),
there exists β ∈ A(cid:48)(cid:48) \ A(cid:48) such that β (cid:31) α.

The repair A(cid:48) is a:
• Pareto-optimal repair of K(cid:31) if there is no Pareto improve-

ment of A(cid:48) w.r.t. (cid:31).

• Globally-optimal repair of K(cid:31) if there is no global im-

provement of A(cid:48) w.r.t. (cid:31).

• Completion-optimal repair of K(cid:31) if A(cid:48) is a globally-
optimal repair of K(cid:31)(cid:48), for some completion (cid:31)(cid:48) of (cid:31).
We denote by GRep(K(cid:31)), PRep(K(cid:31)) and CRep(K(cid:31)) the
sets of globally-, Pareto-, and completion-optimal repairs.

Staworko, Chomicki, and Marcinkowski (2012) showed

the following relation between optimal repairs:

CRep(K(cid:31)) ⊆ GRep(K(cid:31)) ⊆ PRep(K(cid:31)) ⊆ SRep(K).
They also show that A(cid:48) is a completion-optimal repair iff it
can be obtained by the following greedy procedure: while
some assertion has not been considered, pick an assertion
that is maximal w.r.t. (cid:31) among those not yet considered, and
add it to the current set if it does not lead to a contradiction.
Example 6. Consider the prioritized KB K(cid:31) given on Fig-
ure 1. The sets of optimal repairs of K(cid:31) are as follows.

CRep(K(cid:31)) ={{Rattler(a), Carnivorous(a), EatMeat(a, b)},

{Boa(a), Carnivorous(a), EatMeat(a, b)}}
GRep(K(cid:31)) =CRep(K(cid:31)) ∪ {{Mammal(a), Oviparous(a),
Carnivorous(a), EatMeat(a, b)}}

PRep(K(cid:31)) =GRep(K(cid:31)) ∪ {

{Rattler(a), Herbivorous(a), EatPlant(a, b)},
{Boa(a), Herbivorous(a), EatPlant(a, b)},
{Mammal(a), Oviparous(a),

Herbivorous(a), EatPlant(a, b)}}

SRep(K) additionally contains repairs with Stone(b) in-
stead of the EatPlant(a, b) or EatMeat(a, b) assertions.

We next introduce the three natural inconsistency-tolerant
semantics based upon repairs. The AR semantics is arguably
the most natural and well-known semantics and requires that
a query be entailed from every repair of the KB. The IAR se-
mantics is a more cautious semantics that evaluates queries
over the intersection of all repairs. Finally, the brave se-
mantics is the most adventurous semantics, returning yes to
queries that are entailed by some repair.
Deﬁnition 7 (AR, IAR and brave semantics). For X ∈
{C, G, P, S}, a prioritized KB K(cid:31) entails a query q under
• X-AR semantics, written K(cid:31) |=X

AR q,
iff (cid:104)T , A(cid:48)(cid:105) |= q for every A(cid:48) ∈ XRep(K(cid:31));
IAR q,

• X-IAR semantics, written K(cid:31) |=X

iff (cid:104)T , A∩(cid:105) |= q where A∩ = (cid:84)

A(cid:48)∈XRep(K(cid:31)) A(cid:48);

• X-brave semantics, written K(cid:31) |=X

brave q,

iff (cid:104)T , A(cid:48)(cid:105) |= q for some A(cid:48) ∈ XRep(K(cid:31)).

We remark that these semantics are related as follows:

K(cid:31) |=X

IAR q ⇒ K(cid:31) |=X

AR q ⇒ K(cid:31) |=X

brave q.

Example 8 (Ex. 6 cont’d). Considering the different seman-
tics based upon completion-optimal repairs, we observe that
• K(cid:31) |=C
• K(cid:31) |=C
• K(cid:31) |=C

IAR Carnivorous(a),
AR Snake(a) but K(cid:31) (cid:54)|=C
brave Boa(a) but K(cid:31) (cid:54)|=C

IAR Snake(a),
AR Boa(a).

T = {Boa (cid:118) Snake, Boa (cid:118) Ovoviviparous,

A =

Rattler(a)

Boa(a)

Rattler (cid:118) Snake, Rattler (cid:118) Ovoviviparous,
EatPlant (cid:118) Eat, EatMeat (cid:118) Eat,
Mammal (cid:118) ¬Snake, Oviparous (cid:118) ¬Ovoviviparous,
Boa (cid:118) ¬Rattler, Carnivorous (cid:118) ¬Herbivorous,
Carnivorous (cid:118) ¬∃EatPlant, Herbivorous (cid:118) ¬∃EatMeat,
∃EatPlant− (cid:118) ¬∃EatMeat−, ∃Eat− (cid:118) ¬Stone}

Mammal(a)

Oviparous(a)

Carnivorous(a)

EatMeat(a, b)

Herbivorous(a)

EatPlant(a, b)

Stone(b)

Figure 1: Prioritized KB example. T formalizes knowledge about animal groups and A gives information about individuals a and b. An
arrow from α to β indicates that α (cid:31) β while a dotted line indicates a conﬂict without priority between assertions.

If we consider now AR semantics for the different kinds of
optimal repairs, we ﬁnd that
• K(cid:31) |=C
• K(cid:31) |=G
• K(cid:31) |=P

AR Snake(a) but K(cid:31) (cid:54)|=G
AR Carnivorous(a) but K(cid:31) (cid:54)|=P
AR Eat(a, b) but K(cid:31) (cid:54)|=S

AR Carnivorous(a),

AR Snake(a),

AR Eat(a, b).

4 Complexity Analysis
In this section, we analyze the data complexity of the central
reasoning tasks related to optimal repairs.

4.1 Overview
We deﬁne the problems and complexity classes we consider
as well as some relevant properties of DL languages.

Problems. Given a prioritized KB K(cid:31) and a type of re-
pairs X ∈ {C, G, P, S}, repair checking (ISREP) is decid-
ing whether a set of assertions belongs to XRep(K(cid:31)); AR
(resp. IAR, brave) entailment (AR, IAR, BRAVE) is decid-
ing whether K(cid:31) entails a given BCQ under X-AR (resp. X-
IAR, X-brave) semantics; uniqueness (UNIQUE) is deciding
whether |XRep(K(cid:31))| = 1; and enumeration (ENUM) is enu-
merating all elements of XRep(K(cid:31)).

Complexity classes. All of the complexity results stated
in this paper are for the data complexity measure, i.e., the
complexity is with respect to the size of A, with T and q
treated as ﬁxed (hence of constant size).

For decision problems, we will refer to the following com-
plexity classes: AC0 is the class of problems that can be
solved by a uniform family of cicuits of constant depth and
polynomial-size, with unbounded-fanin AND and OR gates;
P is the class of problems solvable in polynomial time; NP
is the class of problems solvable in non-deterministic poly-
nomial time; Σp
2 is the class of problems solvable in non-
deterministic polynomial time with access to an NP oracle;
coNP (resp. Πp
2) is the class of problems whose complement
is in NP (resp. Σp
2). These classes are related as follow:
2 and AC0 ⊂ P ⊆ coNP ⊆ Πp
AC0 ⊂ P ⊆ NP ⊆ Σp
2. It is
widely believed that all of the inclusions are proper.

For enumeration problems, we will use the following
classes: TOTALP is the class of enumeration problems that
can be solved in polynomial time in n + m where n is the
input size and m the output size; DELAYP is the class of
enumeration problems that can be solved by an algorithm

SRep(K) PRep(K(cid:31)) GRep(K(cid:31)) CRep(K(cid:31))

ISREP
AR
IAR
BRAVE
UNIQUE
ENUM DELAYP∗ not TOTALP† not TOTALP† DELAYP∗

coNP-c
Πp
2-c
Πp
2-c
Σp
2-c
Πp
2-c‡

in P
coNP-c
coNP-c
NP-c
coNP-c

in P
coNP-c
coNP-c
NP-c
in P

in P
coNP-c
in AC0
in AC0
in P

Table 1: Data complexity overview. Lower bounds hold for DL-
Litecore. Upper bounds hold for DL-LiteH
horn except those noted
with ∗ which hold only for DL-Litecore. Results for the SRep(K)
case are stated (or are straightforward consequences of results)
in (Bienvenu and Bourgaux 2016; Bienvenu and Rosati 2013;
Livshits and Kimelfeld 2017). ‡ in P if (cid:31) is transitive † INCP if
(cid:31) is score-structured ∗ INCP for DL-LiteH
horn KBs with a score-
structured priority relation (cid:31) (see Section 4.4 for the deﬁnition)

such that the delay between the kth and the k + 1th so-
lution is bounded by a polynomial in the input size; INCP
is the class of enumeration problems that can be solved by
an algorithm such that the delay between the kth and the
k + 1th solution is bounded by a polynomial in the size
of the input and k. These classes are related as follow:
DELAYP ⊆ INCP ⊆ TOTALP.
If the decision problem
associated to an enumeration problem is NP-hard, then the
enumeration problem is not in TOTALP.

Results. Table 1 presents an overview of the complexity
results for DL-Lite. However, since most of the results hold
for some DLs outside the DL-Lite family, we will state them
for DLs that satisfy some of the following properties:

• BOUNDCONF: the size of conﬂicts is bounded;

• BINCONF: conﬂicts have size at most two;

• POLYBCQ: polynomial time BCQ entailment;

• POLYCONS: polynomial time consistency checking.

The most commonly considered DL-Lite dialects, such as
DL-Litecore and DL-LiteR (the basis for OWL 2 QL), satisfy
all of these properties, while DL-LiteH
horn satisﬁes all except
BINCONF (the size of conﬂicts is bounded by the number of
concept and role names occurring in the TBox).

4.2 Query Entailment
We start by establishing the complexity of repair checking
and BCQ entailment under the various semantics.

The upper bounds are stated in the following theorem and
can be proven by adapting existing results from databases
and inconsistency-tolerant OMQA (recall that proofs of all
results are provided in (Bienvenu and Bourgaux 2020)). Ob-
serve that this result applies to all DLs satisfying POLY-
CONS and POLYBCQ, which includes prominent Horn DLs
like EL and Horn-SHIQ.
Theorem 9. For DLs satisfying POLYCONS, repair check-
ing is in coNP for globally-optimal repairs, in P for Pareto-
or completion-optimal repairs.

For DLs satisfying POLYCONS and POLYBCQ, G-AR
and G-IAR entailment are in Πp
2, G-brave entailment in Σp
2,
P-AR, P-IAR, C-AR and C-IAR entailment are in coNP, and
P-brave and C-brave entailment in NP.

For Pareto-optimal and completion-optimal

repairs,
coNP-hardness (resp. NP-hardness) of AR and IAR (resp.
brave) IQ entailment in DL-Litecore follow from the special
case where the priority relation is given by priority levels,
for which it is known the three families of optimal repairs
we consider coincide (Bourgaux 2016). The following the-
orem establishes the remaining lower bounds.
Theorem 10. In DL-Litecore, repair checking is coNP-hard
for globally-optimal repairs, G-AR and G-IAR entailment
are Πp
2-hard, even for IQs.

2-hard, and G-brave entailment Σp

4.3 Uniqueness and Enumeration
We now turn our attention to the problems of deciding
uniqueness and enumerating repairs. Note that in the case of
classical repairs, deciding whether |SRep(K)| = 1 amounts
to checking whether K is consistent (recall our assumption
that all self-contradictory assertions have been removed).

As observed by Livshits and Kimelfeld (2017) in the
database setting, classical repairs correspond to the maxi-
mal independent sets (MISs) of the conﬂict hypergraph. It
is known that MIS enumeration for graphs is in DELAYP
(Johnson, Papadimitriou, and Yannakakis 1988), while for
hypergraphs with bounded-size hyperedges, the problem is
in INCP (Eiter and Gottlob 1995; Boros et al. 2000). Since
the conﬂict hypergraph can be tractably computed for DLs
with bounded-size conﬂicts, enumeration of SRep(K) is in
INCP for DLs with bounded conﬂicts, and in DELAYP for
DLs with binary conﬂicts.

Kimelfeld, Livshits, and Peterfreund (2017) and Livshits
and Kimelfeld (2017) provide intractability results for
UNIQUE and ENUM in the case of globally- and Pareto-
optimal repairs of databases with functional dependencies.
Their proofs do not transfer to DL-Lite KBs, but via differ-
ent proofs, we can establish analogous results in our context.
Theorem 11. Uniqueness is coNP-complete for Pareto-
optimal repairs, Πp
2-complete for globally-optimal repairs.
Upper bounds hold for DLs satisfying POLYCONS. Lower
bounds hold for DL-Litecore.
Corollary 12. Enumeration of Pareto-optimal or globally-
optimal repairs is not in TOTALP for DL-Litecore.

Kimelfeld, Livshits, and Peterfreund (2017) provide an
algorithm which, given an arbitrary conﬂict hypergraph
and a priority relation, decides uniqueness for completion-
optimal repairs in polynomial time. Hence deciding whether
|CRep(K(cid:31))| = 1 is in P for DLs with bounded conﬂicts,
since in this case the conﬂict hypergraph can be computed in
polynomial time. Livshits and Kimelfeld (2017) describe an
algorithm that enumerates completion-optimal repairs with
polynomial delay for conﬂict graphs. It follows that for DLs
with binary conﬂicts, enumeration of completion-optimal
repairs is in DELAYP. The case of completion-optimal re-
pairs with non-binary conﬂicts remains open.

4.4 Case of Transitive Priority Relations
A natural case to consider is when the priority relation is
transitive. This occurs in particular when the priority rela-
tion captures the relative reliability of the facts.
Deﬁnition 13. A priority relation is transitive if α1 (cid:31) · · · (cid:31)
αn and {α1, αn} ⊆ C ∈ Conf (K) implies α1 (cid:31) αn.

Kimelfeld, Livshits, and Peterfreund (2017) proved that
when the priority relation is transitive, deciding uniqueness
for globally-optimal repairs can be done in polynomial time
when the conﬂict hypergraph is given. This result is appli-
cable to all DLs for which the conﬂict hypergraph is com-
putable in polynomial time. A natural question is whether
any of our other problems become easier if we assume (cid:31)
is transitive. We found that this is not the case, although
the transitivity requirement makes the lower bounds proofs
more involved. In particular, we can no longer use the coNP-
hardness proof for uniqueness to derive that the enumera-
tion of globally-optimal repairs is not in TOTALP, but in-
stead show this via the coNP-hardness of deciding whether
a given set of ABoxes is exactly GRep(K(cid:31)).
Theorem 14. When (cid:31) is transitive, uniqueness is in P for
globally-optimal repairs and DLs satisfying BOUNDCONF.
All other lower bounds in Table 1 still hold for DL-Litecore.

Score-structured priority relations. An interesting spe-
cial case of transitive priority relation arises when every
assertion α is assigned a natural number called its score
(or priority level) s(α), which induces a priority relation
as follows: for every pair of assertions α and β that be-
longs to a conﬂict, α (cid:31) β if and only if s(α) > s(β).
Livshits and Kimelfeld (2017) call such a priority relation
score-structured and show that deciding whether a priority
is score-structured is in P and that if (cid:31) is score-structured,
CRep(K(cid:31)) = GRep(K(cid:31)) = PRep(K(cid:31)). This relation
was also given in (Bienvenu, Bourgaux, and Goasdou´e 2014;
Bourgaux 2016) where it is shown that they further coin-
cide with another notion of preferred repairs directly deﬁned
from ABoxes partitioned into priority levels.

For score-structured priorities, the complexity of all de-
cision problems is the same as in the case of completion-
optimal repairs, with the lower bounds shown in (Bourgaux
2016). By contrast, for enumeration, it follows from the al-
gorithm for enumerating score-structured priority repairs of
Livshits and Kimelfeld that enumeration is in INCP for DLs
with bounded conﬂicts and consistency checking in P.

5 Preference-Based Argumentation
In preparation for the following section, we recall the basics
of argumentation frameworks and previously studied exten-
sions with preferences and collective attacks. We also prove
some new results (Theorems 22, 23, 28, and 32).

5.1 Argumentation Frameworks
We consider ﬁnite argumentation frameworks. Argumenta-
tion frameworks over an inﬁnite set of arguments have also
been studied in the literature but ﬁniteness is an ordinary as-
sumption and is made for all results we recall or extend here.

Deﬁnition 15. An argumentation framework (AF) is a pair
(Args, (cid:32)) where Args is a ﬁnite set of arguments and (cid:32) ⊆
Args × Args is the attack relation. When (α, β) ∈(cid:32), we say
that α attacks β, alternatively denoted by α (cid:32) β.

We recall some commonly used notation and terminology,
letting (Args, (cid:32)) be the considered AF and A ⊆ Args. We
use A+ = {β | α (cid:32) β for some α ∈ A} to denote the
set of arguments attacked by arguments from A. We say
that A defends γ ∈ Args (or, γ is defended by A) iff {β |
β (cid:32) γ} ⊆ A+. A set A ⊆ Args is conﬂict-free if A ∩
A+ = ∅. The characteristic function ΓF : 2Args (cid:55)→ 2Args
of F = (Args, (cid:32)) is deﬁned as follows: ΓF (A) = {α |
α is defended by A}. A set A ⊆ Args is admissible if it is
conﬂict-free and A ⊆ ΓF (A).

Argumentation semantics are usually based upon exten-
sions, intended to capture coherent sets of arguments. We
recall some prominent notions of extension:
Deﬁnition 16. Let F = (Args, (cid:32)). Then E ⊆ Args is a:
• complete extension iff E is conﬂict-free and E = ΓF (E);
• grounded extension iff E is the ⊆-minimal complete ex-

tension, or equivalently, the least ﬁxpoint of ΓF ;

• preferred extension iff E is a ⊆-maximal admissible set;
• stable extension iff E+ = Args \ E.

While every stable extension is a preferred extension, the
converse does not hold in general (Dung 1995). The term
coherent designates AFs for which these two notions coin-
cide (i.e. every preferred extension is stable). Coherence is
viewed as a desirable property, and several sufﬁcient condi-
tions for coherence have been identiﬁed. In particular:
Deﬁnition 17. An AF (Args, (cid:32)) is symmetric iff (cid:32) is sym-
metric and irreﬂexive.

Theorem 18. (Coste-Marquis, Devred, and Marquis 2005)
Every symmetric AF is coherent.

5.2 Enriching AFs with Preferences
There has been signiﬁcant interest in extending AFs to al-
low for preferences between arguments (Amgoud and Cay-
rol 2002; Kaci, van der Torre, and Villata 2018).

Deﬁnition 19. A preference-based argumentation frame-
work (PAF) is a triple (Args, (cid:32), (cid:31)), where Args and (cid:32)
are as before, and (cid:31) is an acyclic binary relation over Args
(called the preference relation). Symmetric PAFs are ob-
tained by requiring (Args, (cid:32)) to be symmetric.

It is typical to assume that the preference relation (cid:31) is
transitive. This is a reasonable assumption, but for the sake
of generality, the preceding deﬁnition does not impose this.
The standard way of deﬁning the semantics of PAFs is via

reduction to (plain) AFs:
Deﬁnition 20. Given a PAF (Args, (cid:32), (cid:31)), the correspond-
ing AF is (Args, (cid:32)(cid:31)), where α (cid:32)(cid:31) β iff α (cid:32) β and
β (cid:54)(cid:31) α. A subset E ⊆ Args is a stable (resp. preferred,
grounded, complete) extension of a PAF (Args, (cid:32), (cid:31)) iff it
is a stable (resp. preferred, grounded, complete) extension
of the corresponding AF.

While alternative reductions have been proposed in (Am-
goud and Vesic 2014) and (Kaci, van der Torre, and Villata
2018), all of these reductions coincide for symmetric PAFs,
which is the case that will interest us here.
Theorem 21. (Amgoud and Vesic 2014) Every symmetric
PAF with a transitive preference relation is coherent.

We generalize the preceding result by showing that tran-

sitivity is not required:
Theorem 22. Every symmetric PAF is coherent.

Theorem 23 gives a characterization of AFs that corre-
spond to symmetric PAFs. It generalizes the strict acyclicity
condition characterizing the so-called conﬂict+preference
AFs (Kaci, van der Torre, and Weydert 2006) that requires
for any cycle α1 (cid:32) α2 (cid:32) . . . (cid:32) αn (cid:32) α1 that α1 (cid:32)
αn (cid:32) . . . (cid:32) α2 (cid:32) α1.
Theorem 23. For every AF F = (Args, (cid:32)), the following
statements are equivalent.

1. F is the corresponding AF of some symmetric PAF.
2. For any cycle α1 (cid:32) α2 (cid:32) . . . (cid:32) αn (cid:32) α1, there exists
(j, i) ∈ {(1, 2), . . . , (n − 1, n), (n, 1)} with αi (cid:32) αj.

5.3 Set-Based Argumentation Frameworks
Another well-studied extension of AFs is to allow collective
attacks, in which a set of arguments together form an attack
(Nielsen and Parsons 2006; Flouris and Bikakis 2019).
Deﬁnition 24. A set-based argumentation framework
(SETAF) is a pair (Args, (cid:32)) where Args is a ﬁnite set of
arguments, and (cid:32) ⊆ (2Args \ {∅}) × Args is the attack re-
lation. We’ll write S (cid:32) α to mean (S, α) ∈(cid:32).

When working with SETAFs, we deﬁne A+ as {β | S (cid:32)
β for some S ⊆ A} and say A defends β iff A+ ∩ S (cid:54)= ∅
whenever S (cid:32) β. The deﬁnitions of characteristic function,
conﬂict-free, admissibility, different types of extensions, and
coherence for SETAFs are the same as for AFs but using
these modiﬁed notions of defeated and defended arguments.
Symmetric SETAFs were recently deﬁned as follows:
Deﬁnition 25. (Diller et al. 2020) A SETAF (Args, (cid:32)) is
symmetric if the following two conditions hold: (Symm-1)
if S (cid:32) β and α ∈ S, then S(cid:48) ∪ {β} (cid:32) α for some S(cid:48), and
(Irr) there is no S (cid:32) α with α ∈ S.

Unfortunately, Diller et al. show their deﬁnition does not
preserve the nice properties of symmetric AFs. In particular:
Theorem 26. Some symmetric SETAFs are not coherent.

We propose an alternative, and we believe quite natural,
notion of symmetric SETAF, which we term ‘strongly sym-
metric’ to distinguish it from the preceding notion:
Deﬁnition 27. A SETAF (Args, (cid:32)) is strongly symmetric if
it satisﬁes (Irr) and (Symm-2): for every attack S (cid:32) β and
every α ∈ S, we have S \ {α} ∪ {β} (cid:32) α.

With our deﬁnition, symmetry implies coherence:
Theorem 28. Strongly symmetric SETAFs are coherent.

5.4 Adding Preferences to SETAFs
It is natural to combine the preceding two extensions, but to
the best of our knowledge, this combination has not yet been
considered. We propose the following deﬁnition:
Deﬁnition 29. A preference-based set-based argumenta-
tion framework (PSETAF) is a triple (Args, (cid:32), (cid:31)), where
(Args, (cid:32)) is a SETAF, and (cid:31) is an acyclic binary relation
over Args, called the preference relation.

To deﬁne the semantics of PSETAFs, we give a reduction

to SETAFs, which generalizes the one for PAFs:
Deﬁnition 30. Given a PSETAF (Args, (cid:32), (cid:31)), its corre-
sponding SETAF is (Args, (cid:32)(cid:31)), where the relation (cid:32)(cid:31)⊆
(2Args \ {∅}) × Args is deﬁned as follows: S (cid:32)(cid:31) α iff
S (cid:32) α and α (cid:54)(cid:31) β for every β ∈ S. A subset E ⊆ Args
is a stable (resp. preferred, grounded, complete) extension
of a PSETAF (Args, (cid:32), (cid:31)) iff it is a stable (resp. preferred,
grounded, complete) extension of the corresponding SETAF.

We will focus on strongly symmetric PSETAFs:

Deﬁnition 31. A PSETAF (Args, (cid:32), (cid:31)) is strongly sym-
metric if the SETAF (Args, (cid:32)) is strongly symmetric.

The following result lifts Theorem 21 to PSETAFs. The
proof is quite intricate, and we leave open whether the same
result holds without the transitivity assumption:
Theorem 32. Every strongly symmetric PSETAF with a
transitive preference relation is coherent.

6 Linking Prioritized KBs and PSETAFs
This section places optimal repairs into a broader context by
exhibiting a tight relationship between optimal repairs and
extensions of argumentation frameworks. The argumenta-
tion connection is then exploited to deﬁne a new kind of
prioritized repair with favourable computational properties.
Each prioritized KB naturally gives rise to a PSETAF in
which the ABox assertions play the role of arguments, and
the attack relation captures the conﬂicts.
Deﬁnition 33. Given a prioritized KB K(cid:31) with K = (cid:104)T , A(cid:105),
the associated PSETAF is FK,(cid:31) = (A, (cid:32)K, (cid:31)), where
(cid:32)K= {(C \ {α}, α) | C ∈ Conf (K), α ∈ C}.
Remark 34. Recall that we assume the ABoxes do not con-
If
tain self-conﬂicting assertions, hence C \ {α} (cid:54)= ∅.
we choose not to make this assumption, we should omit
such assertions when constructing the PSETAF, i.e., using
A \ {α | (cid:104)T , {α}(cid:105) |= ⊥} for the set of arguments and only
considering C ∈ Conf (K) with |C| ≥ 2 to construct (cid:32)K.
In this section, results are formulated for arbitrary KBs,

except where otherwise noted.

6.1 Optimal Repairs vs. PSETAF Extensions

Now that we have translated prioritized KBs into argumenta-
tion frameworks, it is possible to compare preferred repairs
and extensions. The following theorem shows that Pareto-
optimal repairs correspond precisely to stable extensions.
Theorem 35. A(cid:48) ⊆ A is a Pareto-optimal repair of K(cid:31) =
((cid:104)T , A(cid:105), (cid:31)) iff A(cid:48) is a stable extension of FK,(cid:31).

Observe that our translation always produces strongly
symmetric PSETAFs, which makes it possible to transfer
Theorem 32 when the priority relation is transitive.

Theorem 36. If (cid:31) is a transitive priority relation, then the
PSETAF FK,(cid:31) is coherent.

Theorems 35 and 36 together show that for transitive (cid:31),

Pareto-repairs coincide also with preferred extensions.

For KBs which contain only binary conﬂicts (e.g. core
DL-Lite dialects), the resulting PSETAF is actually a PAF,
so we can drop the transitivity requirement:

Theorem 37. For every prioritized KB K(cid:31) such that C ∈
Conf (K) implies |C| = 2, FK,(cid:31) is coherent. Thus, A(cid:48) ∈
PRep(K(cid:31)) iff A(cid:48) is a preferred extension of FK,(cid:31).

Note that it follows from Theorem 35 that globally-
repairs correspond to
optimal and completion-optimal
proper subsets of the stable extensions of FK,(cid:31), but they
do not at present have any analog in the argumentation set-
ting. For a (SET)AF F that corresponds to a (strongly) sym-
metric P(SET)AF P , it is possible to deﬁne new types of
extensions that will correspond to globally- and completion-
optimal repairs of a KB having P for associated P(SET)AF
and to import results from the prioritized KB setting.
In
particular, when F is an AF that respects the conditions of
Theorem 23, we can adapt the algorithms for completion-
optimal repairs to tractably enumerate a non-empty subset
of the stable/preferred extensions of F , while enumerating
its stable/preferred extensions is not in TOTALP in general.

6.2 Grounded Semantics for Prioritized KBs

We next turn to the relationship between grounded exten-
sions and optimal repair semantics. We start by clarifying
the situation for the simplest case, in which there are no pref-
erences (cf. (Croitoru and Vesic 2013) for a similar result in
a different but related setting).

Theorem 38. Let K = (cid:104)T , A(cid:105) be a KB, and let FK be the
SETAF corresponding to FK,(cid:31)∅ (with (cid:31)∅ the empty rela-
tion). Then the grounded extension of FK coincides with the
intersection of the repairs of K.

For prioritized KBs, we can use Theorem 35 and the fact
that every stable extension is a complete extension to relate
grounded extensions with Pareto-optimal repairs:

Theorem 39. If G is the grounded extension of FK,(cid:31), then
G ⊆ B for every B ∈ PRep(K(cid:31)).

Thus, the grounded extension contains only assertions
common to all Pareto-optimal repairs. It may not contain
all such assertions, as the following example illustrates:

Example 40. Consider a prioritized KB K(cid:31) in which
Conf (K) = {{α, β}, {α, γ}, {β, γ}, {γ, δ}} and where (cid:31)
contains α (cid:31) γ, β (cid:31) γ, and γ (cid:31) δ. Then δ appears in
the two Pareto-optimal repairs of K(cid:31), which are {α, δ} and
{β, δ}, while the grounded extension of FK,(cid:31) is ∅.

We propose to use the grounded extension to deﬁne a new

inconsistency-tolerant semantics for prioritized KBs:

Deﬁnition 41. A query q is entailed from K(cid:31) under
grounded semantics, denoted K(cid:31) |=GR q, iff (cid:104)T , G(cid:105) |= q,
where G is the grounded extension of FK,(cid:31).

As follows from Theorem 39, our new semantics provides

an under-approximation of the P-IAR semantics:

Theorem 42. For every prioritized KB K(cid:31) and query q:
K(cid:31) |=GR q implies K(cid:31) |=P
IAR q.

Importantly, since the grounded extension of a (SET)AF
can be computed in polynomial time, this semantics allows
for tractable query answering in some relevant settings.

Theorem 43. Let L be a DL satisfying POLYBCQ and
POLYCONS. Then the problem of BCQ entailment over L-
KBs under grounded semantics is in P w.r.t. data complexity.
Corollary 44. For DL-LiteH
grounded semantics is in P w.r.t. data complexity.

horn KBs, BCQ entailment under

The grounded semantics can be compared to another re-
cently proposed semantics for prioritized KBs, the Elect se-
mantics, deﬁned for KBs with binary conﬂicts by Belabbes,
Benferhat, and Chomicki (2019) then generalized for non-
binary conﬂicts (Belabbes and Benferhat 2019). Elect eval-
uates queries over a set of elected assertions and is tractable
for DLs for which computing the conﬂicts and BCQ entail-
ment can be done in polynomial time w.r.t. data complexity.

Deﬁnition 45. (Belabbes and Benferhat 2019) An assertion
α ∈ A is elected iff for every C ∈ Conf (K), if α ∈ C,
then there exists β ∈ C such that α (cid:31) β. The set of elected
assertions is denoted by Elect(K(cid:31)).

The grounded semantics is more productive than Elect,

i.e., is a more precise under-approximation of P-IAR.

Theorem 46. Elect(K(cid:31)) ⊆ G where G is the grounded ex-
tension of FK,(cid:31).

Example 47. Consider a prioritized KB K(cid:31) in which
Conf (K) = {{α, β}, {β, γ}} and where (cid:31) contains α (cid:31) β
and β (cid:31) γ. Then Elect(K(cid:31)) = {α} while G = {α, γ}.
Indeed, α ∈ G and γ is defended by {α} in the AF corre-
sponding to FK,(cid:31), so γ ∈ G.

Our next result establishes that reasoning under grounded

semantics is P-complete in the settings of Theorem 43.

Theorem 48. IQ entailment under grounded semantics is
P-hard w.r.t. data complexity for DL-Litecore.

Dung (1995) observed that the grounded extension can be
computed via the well-founded semantics of a simple logic
program. The following lemma generalizes this result to k-
SETAFs, i.e., SETAFs for which S (cid:32) β implies |S| ≤ k.

Theorem 49. Let F = (Args, (cid:32)) be a k-SETAF. Then α
is in the grounded extension of F iff acc(α) belongs to the
well-founded model of the following normal logic program:

{def(x) ← atti(y1, .., yi, x),acc(y1),...,acc(yi) | 1 ≤ i ≤ k}
∪ {acc(x) ← arg(x), ¬def(x)} ∪ {arg(α) | α ∈ Args}
∪ {atti(α1, . . . , αi, β) ← | {α1, . . . , αi} (cid:32) β}

Intuitively, the preceding logic program computes the sets
of defeated (def) and accepted (acc) arguments starting
from the original sets of arguments (arg) and attacks (atti
encodes i-ary attacks). By adding rules to compute conﬂicts
and populate the attack relations atti, we can show that the
grounded extension of FK,(cid:31) can be computed via logic pro-
gramming. While stated for DL-LiteH
horn, the next theorem
holds for any ontology (or constraint) language for which
inconsistency can be characterized by a ﬁnite set of BCQs.
Theorem 50. For every DL-LiteH
horn TBox T , there exists
a normal logic program ΠT such that for every ABox A,
priority relation (cid:31) for K = (cid:104)T , A(cid:105), and assertion α, the
following are equivalent:
• α belongs to the grounded extension of the PSETAF FK,(cid:31)
• acc(id(α)) belongs to the well-founded model of ΠT ∪
{γ ← | γ ∈ Aid} ∪ {pref(id(α), id(β)) ← | α (cid:31) β},
where Aid is obtained from A by adding an extra argument
to every assertion β containing a unique id, denoted id(β).

As the well-founded semantics is implemented in logic
programming systems like XSB (Rao et al. 1997),
the
preceding theorem presents a method for implementing
grounded semantics. Alternatively, the grounded extension
can be naturally under-approximated by ﬁxing d > 0 and
considering Γd
F (∅) rather than the least ﬁxpoint of ΓF . The
logic program from Theorem 50 can be modiﬁed to yield
a non-recursive stratiﬁed program that computes Γd
(∅),
which in turn can be expressed as a ﬁrst-order (∼ SQL)
query and evaluated using a relational database system.

FK,(cid:31)

7 Related Work
Our complexity results are similar to those obtained for pri-
oritized databases with functional dependencies (Staworko,
Chomicki, and Marcinkowski 2012; Kimelfeld, Livshits,
and Peterfreund 2017; Livshits and Kimelfeld 2017). Com-
pared to this work, we additionally consider IAR and brave
semantics, study the impact of transitivity on all reasoning
tasks, and establish connections with argumentation.

Inconsistency-tolerant semantics based on other kinds of
preferred repairs have been investigated both in the database
and DL or Datalog± contexts, often with a focus on re-
pairs that have maximal cardinality or weight (Lopatenko
and Bertossi 2007; Du, Qi, and Shen 2013; Baget et al. 2016;
Lukasiewicz, Malizia, and Vaicenavicius 2019). How-
ever, such global optimality criteria lead to a higher com-
putational complexity (typically ∆P
2 [O(log n)]-hard). By
contrast, Bienvenu, Bourgaux, and Goasdou´e (2014) show
that for preferred repairs based on priority levels and set-
inclusion (corresponding to optimal repairs in the score-
structured case), BCQ entailment remains in the ﬁrst level of

the polynomial hierarchy for DL-Lite. Our results show that
even if the priority relation over facts is not score-structured,
and not even transitive, these computational properties are
retained for Pareto- and completion-optimal repairs.

When (cid:31) is score-structured, we can compare the
grounded extension and the intersection of optimal repairs to
the proposals of Benferhat, Bouraoui, and Tabia (2015) for
selecting a single preferred T -consistent subset of the ABox.
In particular, the non-defeated repair is the union of the in-
tersections of the repairs of S1, S1 ∪ S2, . . . , S1 ∪ · · · ∪ Sn,
where S1, . . . , Sn is a partition of A into priority levels.
Since Elect coincides with non-defeated semantics for score-
structured priorities (Belabbes and Benferhat 2019),
the
non-defeated repair is included in the grounded extension by
Theorem 46; as the priority relation in Example 47 is score-
structured, the inclusion may be strict. Another proposal is
the prioritized inclusion-based non-defeated repair, which
coincides with the intersection of the optimal repairs. The
grounded extension thus lies between the non-defeated and
prioritized inclusion-based non-defeated repairs. Other pro-
posals are either included in non-defeated, or are not sound
approximations of the intersection of the optimal repairs.
For partially preordered ABoxes, Belabbes and Benferhat
(2019) propose to go beyond Elect by intersecting the opti-
mal repairs w.r.t. the score-structured priorities obtained by
extending the original partial preorder into a total preorder.
Interestingly, the obtained set of assertions corresponds ex-
actly to the intersection of the completion-optimal repairs of
the prioritized KB underpinned by the partially preordered
KB (cf. appendix of (Bienvenu and Bourgaux 2020)).

Argumentation frameworks derived from inconsistent
KBs have been considered before. Arguments are gen-
erally deﬁned as pairs of a support (subset of the KB)
and a conclusion (consequence of the support), with vari-
ous attack relations (see e.g., (Amgoud and Cayrol 2002;
Gorogiannis and Hunter 2011)). A series of papers start-
ing with (Croitoru and Vesic 2013) links argumentation and
inconsistency-tolerant querying of KBs, where the support
of the argument is a subset of the ABox, the conclusion
is a conjunction of facts entailed from the support and T ,
and α attacks β iff the conclusion of α is T -inconsistent
with the support of β (in some papers, the argument con-
sists of a whole derivation sequence, not just the support
and conclusion). Stable and preferred extensions of such
AFs correspond to repairs in the following sense: every
such extension contains all those arguments whose sup-
ports are included in some particular repair. The work by
Croitoru, Thomopoulos, and Vesic (2015) shows that it is
possible to use a preference relation over facts to deﬁne
notions of optimal extensions for AFs induced by incon-
sistent KBs in this fashion, and observe that such exten-
sions correspond to optimal repairs. While touching on
similar topics, an essential difference between this line of
work and our own lies in the deﬁnition of the AF. Indeed,
in the AFs of Croitoru et al., even if we group together ar-
guments with the same supports, we would still have an ex-
ponential number of arguments. By contrast, our translation
can be carried out in polynomial time under reasonable as-
sumptions, enabling us to import tractability results from ar-

gumentation to OMQA. Moreover, since we use assertions
as arguments, each priority relation yields a preference re-
lation over arguments, enabling a transparent reduction to
preference-based (SET)AFs. Croitoru, Thomopoulos, and
Vesic do not discuss any connections to preference-based,
nor set-based AFs, and our results on the equivalence be-
tween Pareto-optimal repairs and stable and preferred ex-
tensions of P(SET)AFs do not follow from their results.

8 Conclusion and Future Work
We have explored the problem of how to repair and query in-
consistent KBs while taking into account a priority relation
over facts. By leveraging connections to database repairs
and abstract argumentation, we obtained a number of novel
results for our setting, while at the same time contributing
new results and research questions to these two areas.

After importing the notions of Pareto-, globally-, and
completion-optimal repairs into the OMQA setting, our ﬁrst
contribution was a data complexity study that showed, un-
surprisingly, that reasoning with optimal repairs is typically
intractable and more challenging than for classical repairs.
Nevertheless, there are several cases which are ‘only’ NP/
coNP, which suggests that it may be interesting to devise
practical SAT-based procedures, as has been successfully
done for some other forms of repair (Bienvenu, Bourgaux,
and Goasdou´e 2014). It would also be relevant to implement
and experiment our proposed grounded semantics as well as
the ﬁrst-order approximations we suggested. Our complex-
ity study could be expanded to include further ontology lan-
guages as well as the combined complexity measure.

In order to provide an elegant translation of prioritized
KBs to argumentation frameworks, we were naturally led to
consider preference-based (SET)AFs. We believe that the
new results we established in Section 5, in particular, Theo-
rem 32, should be of interest to the argumentation commu-
nity. Moreover, the connections we established between ex-
tensions of PSETAFs and repairs of prioritized KBs motivate
a more detailed study of PSETAFs (a concrete open ques-
tion is whether Theorem 32 holds in the absence of transi-
tivity). Furthermore, this correspondence could be leveraged
to explore new notions of extension for (strongly) symmetric
P(SET)AFs inspired by completion- or globally-optimal re-
pairs, or to design benchmarks for (P)(SET)AFs via a trans-
lation from inconsistent KBs.

An important question that has not yet been satisfacto-
rily answered in the database literature is which of the three
forms of optimal repair is most natural, independently of
their computational costs. While we do not claim to pro-
vide a deﬁnitive answer to this question, we believe that our
result showing that Pareto-optimal repairs coincide with sta-
ble extensions (and often also preferred extensions) speaks
to the interest of adopting Pareto-optimal repairs. We should
emphasize that while phrased for KBs, the connection be-
tween Pareto-optimal repairs and stable / preferred exten-
sions holds equally well for databases with denial con-
straints (such as functional dependencies). Moreover, the
tractable grounded semantics we proposed can be applied
not just to KBs but also to prioritized databases.

Acknowledgements
This work was supported by Camille Bourgaux’s CNRS
PEPS grant and the ANR AI Chair INTENDED.

2014.

References
Amgoud, L., and Cayrol, C. 2002. Inferring from incon-
sistency in preference-based argumentation frameworks. J.
Autom. Reasoning 29(2):125–169.
Amgoud, L., and Vesic, S.
Rich preference-
based argumentation frameworks. Int. J. Approx. Reasoning
55(2):585–606.
Artale, A.; Calvanese, D.; Kontchakov, R.; and Za-
kharyaschev, M. 2009. The DL-Lite family and relations. J.
Artif. Intell. Res. 36:1–69.
Baader, F.; Horrocks, I.; Lutz, C.; and Sattler, U. 2017. An
Introduction to Description Logic. Cambridge University
Press.
Baget, J.; Benferhat, S.; Bouraoui, Z.; Croitoru, M.; Mug-
nier, M.; Papini, O.; Rocher, S.; and Tabia, K.
2016.
Inconsistency-tolerant query answering: Rationality proper-
ties and computational complexity analysis. In JELIA.
Belabbes, S., and Benferhat, S. 2019. Inconsistency han-
dling for partially preordered ontologies: Going beyond
Elect. In KSEM.
Belabbes, S.; Benferhat, S.; and Chomicki, J. 2019. Elect:
An inconsistency handling approach for partially preordered
lightweight ontologies. In LPNMR.
Benferhat, S.; Bouraoui, Z.; and Tabia, K. 2015. How to se-
lect one preferred assertional-based repair from inconsistent
and prioritized DL-Lite knowledge bases? In IJCAI.
Bienvenu, M., and Bourgaux, C. 2016.
Inconsistency-
tolerant querying of description logic knowledge bases. In
Reasoning Web.
Bienvenu, M., and Bourgaux, C.
2020. Querying and
repairing inconsistent prioritized knowledge bases: Com-
plexity analysis and links with abstract argumentation.
arXiv:2003.05746 [cs.LO].
Bienvenu, M., and Ortiz, M. 2015. Ontology-mediated
query answering with data-tractable description logics.
In
Reasoning Web.
Bienvenu, M., and Rosati, R. 2013. Tractable approxi-
mations of consistent query answering for robust ontology-
based data access. In IJCAI.
Bienvenu, M.; Bourgaux, C.; and Goasdou´e, F.
2014.
Querying inconsistent description logic knowledge bases
under preferred repair semantics. In AAAI.
Bienvenu, M.; Bourgaux, C.; and Goasdou´e, F. 2019. Com-
puting and explaining query answers over inconsistent DL-
Lite knowledge bases. J. Artif. Intell. Res. 64:563–644.
Bienvenu, M. 2019.
mediated query answering: A progress report. In DL.
Boros, E.; Elbassioni, K. M.; Gurvich, V.; and Khachiyan,
L. 2000. An efﬁcient incremental algorithm for generat-
ing all maximal independent sets in hypergraphs of bounded
dimension. Parallel Processing Letters 10(4):253–266.

Inconsistency handling in ontology-

Bourgaux, C. 2016. Inconsistency Handling in Ontology-
Mediated Query Answering. Ph.D. Dissertation, University
of Paris-Saclay, France.
Calvanese, D.; De Giacomo, G.; Lembo, D.; Lenzerini, M.;
and Rosati, R. 2007. Tractable reasoning and efﬁcient query
answering in description logics: The DL-Lite family. J. Au-
tom. Reasoning 39(3):385–429.
Coste-Marquis, S.; Devred, C.; and Marquis, P. 2005. Sym-
metric argumentation frameworks. In ECSQARU.
Croitoru, M., and Vesic, S. 2013. What can argumentation
do for inconsistent ontology query answering? In SUM.
Croitoru, M.; Thomopoulos, R.; and Vesic, S. 2015. Intro-
ducing preference-based argumentation to inconsistent on-
tological knowledge bases. In PRIMA.
Diller, M.; Keshavarzi Zafarghandi, A.; Linsbichler, T.; and
Woltran, S. 2020. Investigating subclasses of abstract dialec-
tical frameworks. Argument & Computation 11(1-2):191–
219.
Du, J.; Qi, G.; and Shen, Y. 2013. Weight-based consistent
query answering over inconsistent SHIQ knowledge bases.
Knowl. Inf. Syst. 34(2):335–371.
Dung, P. M. 1995. On the acceptability of arguments and
its fundamental role in nonmonotonic reasoning, logic pro-
gramming and n-person games. Artif. Intell. 77(2):321–358.
Eiter, T., and Gottlob, G. 1995.
Identifying the minimal
transversals of a hypergraph and related problems. SIAM J.
Comput. 24(6):1278–1304.
Fagin, R.; Kimelfeld, B.; Reiss, F.; and Vansummeren, S.
2016. Declarative cleaning of inconsistencies in information
extraction. ACM Trans. Database Syst. 41(1):6:1–6:44.
Fagin, R.; Kimelfeld, B.; and Kolaitis, P. G. 2015. Di-
chotomies in the complexity of preferred repairs. In PODS.
Flouris, G., and Bikakis, A. 2019. A comprehensive study of
argumentation frameworks with sets of attacking arguments.
Int. J. Approx. Reasoning 109:55–86.
Instantiating ab-
Gorogiannis, N., and Hunter, A. 2011.
stract argumentation with classical logic arguments: Postu-
lates and properties. Artif. Intell. 175(9-10):1479–1497.
Johnson, D. S.; Papadimitriou, C. H.; and Yannakakis, M.
1988. On generating all maximal independent sets. Inf. Pro-
cess. Lett. 27(3):119–123.
Kaci, S.; van der Torre, L. W. N.; and Villata, S. 2018.
Preference in abstract argumentation. In COMMA.
Kaci, S.; van der Torre, L. W. N.; and Weydert, E. 2006.
Acyclic argumentation: Attack = conﬂict + preference. In
ECAI.
Kimelfeld, B.; Livshits, E.; and Peterfreund, L. 2017. De-
tecting ambiguity in prioritized database repairing. In ICDT.
Lembo, D.; Lenzerini, M.; Rosati, R.; Ruzzi, M.; and Savo,
D. F. 2010. Inconsistency-tolerant semantics for description
logics. In RR.
Lembo, D.; Lenzerini, M.; Rosati, R.; Ruzzi, M.; and Savo,
D. F.
Inconsistency-tolerant query answering in
ontology-based data access. Journal Web Sem. 33:3–29.

2015.

Livshits, E., and Kimelfeld, B. 2017. Counting and enumer-
ating (preferred) database repairs. In PODS.
Lopatenko, A., and Bertossi, L. E. 2007. Complexity of
consistent query answering in databases under cardinality-
based and incremental repair semantics. In ICDT.
Lukasiewicz, T.; Malizia, E.; and Vaicenavicius, A. 2019.
Complexity of inconsistency-tolerant query answering in
Datalog+/- under cardinality-based repairs. In AAAI.
Martinez, M. V.; Parisi, F.; Pugliese, A.; Simari, G. I.; and
Subrahmanian, V. S. 2014. Policy-based inconsistency man-
Int. J. Approx. Reason.
agement in relational databases.
55(2):501–528.
Motik, B.; Cuenca Grau, B.; Horrocks, I.; Wu, Z.; Fokoue,
A.; and Lutz, C. 2012. OWL 2 Web Ontology Language
proﬁles. W3C Recommendation. Available at http://www.
w3.org/TR/owl2-proﬁles/.
Nielsen, S. H., and Parsons, S. 2006. A generalization of
Dung’s abstract framework for argumentation: Arguing with
sets of attacking arguments. In ArgMAS.
2009. OWL 2 Web Ontol-
OWL Working Group, W.
ogy Language: Document overview. W3C Recommenda-
tion. Available at https://www.w3.org/TR/owl2-overview/,
accessed on July 3rd, 2020.
Poggi, A.; Lembo, D.; Calvanese, D.; De Giacomo, G.;
Lenzerini, M.; and Rosati, R. 2008. Linking data to on-
tologies. Journal of Data Semantics 10:133–173.
Rao, P.; Sagonas, K.; Swift, T.; Warren, D. S.; and Freire,
J. 1997. XSB: A system for effciently computing WFS. In
LPNMR.
Staworko, S.; Chomicki, J.; and Marcinkowski, J. 2012.
Prioritized repairing and consistent query answering in rela-
tional databases. Ann. Math. Artif. Intell. 64(2-3):209–246.
Tanon, T. P.; Bourgaux, C.; and Suchanek, F. M. 2019.
Learning how to correct a knowledge base from the edit his-
tory. In WWW.
Trivela, D.; Stoilos, G.; and Vassalos, V. 2018. A framework
and positive results for IAR-answering. In AAAI.
Tsalapati, E.; Stoilos, G.; Stamou, G. B.; and Koletsos, G.
2016. Efﬁcient query answering over expressive inconsistent
description logics. In IJCAI.
Xiao, G.; Calvanese, D.; Kontchakov, R.; Lembo, D.; Poggi,
A.; Rosati, R.; and Zakharyaschev, M. 2018. Ontology-
based data access: A survey. In IJCAI.

