Weight Annotation in Information Extraction
Johannes Doleschal, Benny Kimelfeld, Wim Martens, Liat Peterfreund

To cite this version:

Johannes Doleschal, Benny Kimelfeld, Wim Martens, Liat Peterfreund. Weight Annotation in In-
formation Extraction. ICDT 2020 - 23rd International Conference on Database Theory, Mar 2020,
Copenhague / Virtual, Denmark. ￿10.4230/LIPIcs.ICDT.2020.8￿. ￿hal-03104155￿

HAL Id: hal-03104155

https://inria.hal.science/hal-03104155

Submitted on 8 Jan 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Weight Annotation in Information Extraction

Johannes Doleschal
University of Bayreuth, Germany
Hasselt University, Belgium

Benny Kimelfeld
Technion – Israel Institute of Technology, Haifa, Israel

Wim Martens
University of Bayreuth, Germany

Liat Peterfreund
CNRS, IRIF – Université de Paris, France
University of Edinburgh, United Kingdom

Abstract

The framework of document spanners abstracts the task of information extraction from text as a
function that maps every document (a string) into a relation over the document’s spans (intervals
identiﬁed by their start and end indices). For instance, the regular spanners are the closure under
the Relational Algebra (RA) of the regular expressions with capture variables, and the expressive
power of the regular spanners is precisely captured by the class of vset-automata – a restricted class
of transducers that mark the endpoints of selected spans.

In this work, we embark on the investigation of document spanners that can annotate extractions
with auxiliary information such as conﬁdence, support, and conﬁdentiality measures. To this end,
we adopt the abstraction of provenance semirings by Green et al., where tuples of a relation are
annotated with the elements of a commutative semiring, and where the annotation propagates
through the (positive) RA operators via the semiring operators. Hence, the proposed spanner
extension, referred to as an annotator, maps every string into an annotated relation over the
spans. As a speciﬁc instantiation, we explore weighted vset-automata that, similarly to weighted
automata and transducers, attach semiring elements to transitions. We investigate key aspects
of expressiveness, such as the closure under the positive RA, and key aspects of computational
complexity, such as the enumeration of annotated answers and their ranked enumeration in the case
of numeric semirings. For a number of these problems, fundamental properties of the underlying
semiring, such as positivity, are crucial for establishing tractability.

2012 ACM Subject Classiﬁcation Information systems → Information extraction; Theory of com-
putation → Transducers; Theory of computation → Problems, reductions and completeness; Theory
of computation → Data provenance

Keywords and phrases Information extraction, regular document spanners, weighted automata,
provenance semirings, K-relations

Digital Object Identiﬁer 10.4230/LIPIcs.ICDT.2020.8

Related Version A full version of the paper is available at https://arxiv.org/abs/1908.11642.

Funding This work was supported by the German-Israeli Foundation for Scientiﬁc Research and
Development (GIF), grant I-1502-407.6/2019. The work of Johannes Doleschal and Wim Martens
was also supported by the Deutsche Forschungsgemeinschaft (DFG), grant MA 4938/4-1. The work
of Benny Kimelfeld and Liat Peterfreund was also supported by the Israel Science Foundation (ISF),
grants 1295/15 and 768/19, and the DFG project 412400621 (DIP program).
Liat Peterfreund: A part of the work was donewhile the author was aﬃliated with the Technion.

Acknowledgements We are grateful to Matthias Niewerth for many useful discussions and his help
regarding Theorem 7.1 and Shaull Almagor for many helpful comments regarding weighted automata.
Furthermore, we thank the anonymous reviewers for ICDT 2020 for many helpful remarks.

© Johannes Doleschal, Benny Kimelfeld, Wim Martens, and Liat Peterfreund;
licensed under Creative Commons License CC-BY

23rd International Conference on Database Theory (ICDT 2020).
Editors: Carsten Lutz and Jean Christoph Jung; Article No. 8; pp. 8:1–8:18

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

8:2

Weight Annotation in Information Extraction

1

Introduction

A plethora of paradigms have been developed over the past decades towards the challenge of
extracting structured information from text – a task generally referred to as Information
Extraction (IE). Common textual sources include natural language from a variety of sources
such as scientiﬁc publications, customer input and social media, as well as machine-generated
activity logs. Instantiations of IE are central components in text analytics and include
tasks such as segmentation, named-entity recognition, relation extraction, and coreference
resolution [38]. Rules and rule systems have consistently been key components in such
paradigms, yet their roles have varied and evolved over time. Systems such as Xlog [42] and
SystemT [4] use IE rules for materializing relations inside relational query languages. Machine-
learning classiﬁers and probabilistic graphical models (e.g., Conditional Random Fields)
use rules for feature generation [24, 44]. Rules serve as weak constraints (later translated
into probabilistic graphical models) in Markov Logic Networks [32] and in the DeepDive
system [43]. Rules are also used for generating noisy training data (“labeling functions”) in
the Snorkel system [34].

The framework of document spanners (spanners for short) provides a theoretical basis
for investigating the principles of relational rule systems for IE [13]. Speciﬁcally, a spanner
extracts from a document a relation over text intervals, called spans, using either atomic
extractors or a relational query on top of the atomic extractors. More formally, by a document
we refer to a string d over a ﬁnite alphabet, a span of d represents a substring of d by its start
and end positions, and a spanner is a function that maps every document d into a relation
over the spans of d. The most studied spanner language is that of the regular spanners:
atomic extraction is via regex formulas, which are regular expressions with capture variables,
and relational manipulation is via the relational algebra: projection, natural join, union,
and diﬀerence. Equivalently, the regular spanners are the ones expressible as variable-set
automata (vset-automata for short), which are nondeterministic ﬁnite-state automata that
can open and close variables (playing the role of the attributes of the extracted relation).
Interestingly, there has been an independent recent eﬀort to express artiﬁcial neural networks
for natural language processing by means of ﬁnite-state automata [26, 27, 47].

To date, the research on spanners has focused on their expressive power [13, 17, 31], their
computational complexity [2, 3, 15, 18], incompleteness [25, 30], and other system aspects such
as cleaning [14] and distributed query planning [8]. That research has exclusively adopted a
Boolean approach: a tuple is either extracted or not. Nevertheless, when applied to noisy or
fuzzy domains such as natural language, modern approaches in artiﬁcial intelligence adopt
a quantitative approach where each extracted tuple is associated with a level of conﬁdence
that the tuple coincides with the intent. When used within an end-to-end IE system, such
conﬁdence can be used as a principled way of tuning the balance between precision and
recall. For instance, in probabilistic IE models (e.g., CRF), each extraction has an associated
probability. In systems of weak constraints (e.g., MLN), every rule has a numerical weight,
and the conﬁdence in an extraction is an aggregation of the weights of the invoked rules that
lead to the extraction. IE via artiﬁcial neural networks typically involves thresholding over a
produced score or conﬁdence value [5, 29]. Numerical scores in extraction are also used for
quantifying the similarity between associated substrings, as done with sequence alignment
and edit distance in the analysis of biological sequences such as DNA and RNA [45, 46].

In this work, we embark on the investigation of spanners that quantify the extracted tuples.
We do so by adopting the concept of annotated relations from the framework of provenance
semirings by Green et al. [20]. In essence, every tuple of the database is annotated with an

J. Doleschal, B. Kimelfeld, W. Martens, and L. Peterfreund

8:3

element of a commutative semiring, and the positive relational algebra manipulates both
the tuples and their annotations by translating relational operators into semiring operators
(e.g., product for natural join and sum for union). An annotated relation is referred to as a
K-relation, where K is the domain of the semiring. The conceptual extension of the spanner
model is straightforward: instead of a function (i.e., spanner) that maps every document d
into a relation over the spans of d, we consider a function that maps every d into a K-relation
over the spans of d. We refer to such a function as a K-annotator. Interestingly, as in the
relational case, we can vary the meaning of the annotation by varying the semiring:

Conﬁdence via the probability (a.k.a. inside) semiring and the Viterbi (best derivation)
semiring [19];
Support (i.e., number of derivations) via the counting semiring [19];
Access control via the semiring of the conﬁdentiality policies [16] (e.g., does the extracted
tuple require reading top-secret sections? which level suﬃces for the tuple?);
The traditional spanners via the Boolean semiring.

As a speciﬁc instantiation of K-annotators, we study the class of K-weighted vset-automata.
Such automata generalize vset-automata in the same manner as weighted automata and
weighted transducers (cf., e.g., the Handbook of Weighted Automata [10]): transitions are
weighted by semiring elements, the cost of a run is the product of the weights along the run,
and the weight (annotation) of a tuple is the sum of costs of all the runs that produce the
tuple. Again, there has been recent research that studies the connection between models of
artiﬁcial neural networks in natural language processing and weighted automata [39]. Our
investigation answers several fundamental questions about K-weighted vset-automata:
1. Is this class closed under the positive relational algebra (according to the semantics of

provenance semirings [20])?

2. What is the computational complexity of computing the annotation of a tuple?
3. Can we enumerate the annotated tuples as eﬃciently as we can do so for ordinary

vset-automata (i.e., regular document spanners)?

4. In cases of numerical semirings (i.e., when K is a set of numbers), what is the complexity

of enumerating the answers in ranked order by decreasing weight?

Our answers are mostly positive, put the last question aside, and show that K-weighted
vset-automata possess appropriate expressivity and tractability properties. As for the last
question, we show that ranked enumeration is intractable and inapproximable for some of
the aforementioned semirings (e.g., the probability and counting semirings), but tractable
for positively ordered and bipotent semirings, such as the Viterbi semiring. Due to space
constraints, we sometimes omit proofs or only provide a proof sketch.

2

Preliminaries

Our annotators will read documents and produce annotated relations [20], which are relations
in which each tuple is annotated with an element from a semiring. In this section we revisit
the basic deﬁnitions and properties of annotated relations.

Semirings

A semiring (K, ⊕, ⊗, 0, 1) is an algebraic structure consisting of a set K, containing two
distinguished elements: the zero element 0 and the unit element 1, and equipped with two
binary operations, namely addition ⊕ and multiplication ⊗ such that:

(K, ⊕) is a commutative monoid with identity element 0;

I C D T 2 0 2 0

8:4

Weight Annotation in Information Extraction

(K, ⊗) is a monoid with identity element 1;
multiplication distributes over addition, i.e., (a ⊕ b) ⊗ c = (a ⊗ c) ⊕ (b ⊗ c) and c ⊗ (a ⊕ b) =
(c ⊗ a) ⊕ (c ⊗ b);
0 is absorbing for ⊗, i.e., 0 ⊗ a = a ⊗ 0 = 0.

A semiring is called commutative if (K, ⊗) is commutative. We follow Green et al. [20]
and assume that a semiring is commutative if not stated otherwise. Furthermore, following
Eilenberg [11], a semiring is positive if the following conditions hold:

0 6= 1,
If a ⊕ b = 0, then a = 0 = b.
If a ⊗ b = 0, then a = 0 or b = 0.

An element a ∈ K is a zero divisor if a 6= 0 and there is an element b ∈ K with b 6= 0 and
a ⊗ b = 0. Furthermore, an element a ∈ K has an additive inverse, if there is an element
b ∈ K such that a ⊕ b = 0. In the following, we will also identify a semiring by its domain K
if the rest is clear from the context. When we do this for numeric semirings such as R and N,
we always assume the usual addition and multiplication.

(cid:73) Example 2.1. The following are examples for commutative semirings. It is easy to verify
that all but the numeric semirings and the Łukasiewcz semiring are positive.
1. The numeric semirings (R, +, ·, 0, 1) and (Z, +, ·, 0, 1);
2. The counting semiring (N, +, ·, 0, 1);
3. The Boolean semiring (B, ∨, ∧, false, true) where B = {true, false};
4. The probability semiring (R+, +, ·, 0, 1).1 Rabin [33] and Segala [40] deﬁne probabilistic
automata over this semiring, where all edge weights must be between 0 and 1 and the
sum of all edge weights starting some state, labeled by the same label must be 1;
5. The Viterbi semiring ([0, 1], max, ·, 0, 1) which is used in probabilistic parsing [9];
6. The access control semiring A = ({P < C < S < T < 0}, min, max, 0, P ), where P is
“public”, C is “conﬁdential”, S is “secret”, T is “top secret”, and 0 is “so secret that
nobody can access it” [16];

7. The tropical semiring (N ∪ {∞}, min, +, ∞, 0) where min stands for the binary minimum

function. This semiring is used in optimization problems of networks [9].

8. The Łukasiewcz semiring, whose domain is [0, 1], with addition given by x⊕y = max(x, y),
with multiplication x ⊗ y = max(0, x + y − 1), zero element 0, and unit 1. This semiring
is used in multivalued logics [9].

Complexity-wise, we assume that single semiring elements can be stored in a single
register and that addition and multiplication can be carried out in constant time – in similar
spirit as the standard assumption for Random Access Machines. We use this assumption to
simplify the analysis of algorithms.

2.1 Annotated Relations

We assume inﬁnite and disjoint sets D and Vars, containing data values (or simply values)
and variables, respectively. Let V ⊆ Vars be a ﬁnite set of variables. A V -tuple is a function
t : V → D that assigns values to variables in V . The arity of t is the cardinality |V | of V . For
a subset X ⊆ Vars, we denote the restriction of t to the variables in X by t(cid:22)X. We denote
the set of all the V -tuples by V -Tup. We sometimes leave V implicit when the precise set is

1 One may expect the domain to be [0, 1], but this is diﬃcult to obtain while maintaining the semiring

properties. For instance, deﬁning a ⊕ b as min{a + b, 1} would violate distributivity.

J. Doleschal, B. Kimelfeld, W. Martens, and L. Peterfreund

8:5

not important. Let K be a set containing a distinguished element 0. A (K, D)-relation R over
V is a function R : V -Tup → K such that its support deﬁned by supp(R) def= {t | R(t) 6= 0} is
ﬁnite. The arity of a (K, D)-relation over V is |V |. When D is clear from the context or
irrelevant, we also use K-relations to refer to (K, D)-relations.

(cid:73) Example 2.2. The bottom left table in Figure 1 shows an example (K, D)-relation, where
K is the Viterbi semiring. The variables are xpers and xloc, so the V -tuples are described in
the ﬁrst two columns. The third column contains the element in K associated to each tuple.

Relational Algebra for Annotated Relations

Green et al. [20] deﬁned a set of operators on (K, D)-relations that naturally correspond
to relational algebra operators and map K-relations to K-relations. Let (K, ⊕, ⊗, 0, 1) be
a commutative semiring. The algebraic operators2 union, projection, and natural join are
deﬁned in the usual way, for all ﬁnite sets V1, V2 ⊆ Vars and for all K-relations R1 over V1
and R2 over V2, as follows.

Union: If V1 = V2 then the union R def= R1 ∪ R2 is a function R : V1-Tup → K deﬁned
by R(t) def= R1(t) ⊕ R2(t). (Otherwise, the union is not deﬁned.)
Projection: For X ⊆ V1, the projection R def= πX R1 is a function R : X-Tup → K
deﬁned by

R(t) def=

M

R1(t0).

t=t0(cid:22)X and R1(t0)6=0

Natural Join: The natural join R def= R1 ./ R2 is a function R : (V1 ∪ V2)-Tup → K
deﬁned by

R(t) def= R1(t1) ⊗ R2(t2)

where t1 and t2 are the restrictions t(cid:22)V1 and t(cid:22)V2, respectively.
Selection: If P is a selection predicate that maps each tuple in V1-Tup to either 0 or 1
then R def= σP(R1) is a function R : V1-Tup → K deﬁned by

R(t) def= R1(t) ⊗ P(t).

(cid:73) Proposition 2.3. [20] The above operators preserve the ﬁniteness of the supports and
therefore they map K-relations into K-relations.

Hence, we obtain an algebra on K-relations.

3 K-Annotators

We start by setting the basic terminology. We ﬁx a ﬁnite alphabet Σ that is disjoint from
Vars. A document is a ﬁnite sequence d = σ1 · · · σn where σi ∈ Σ for each i = 1, . . . , n. By
Docs we denote the set of all documents. A (k-ary) string relation is a subset of Docsk for
some k ∈ N.

2 As in much of the work on semirings in provenance, e.g. Green et al. [20], we do not yet consider the

diﬀerence operator (which would require additive inverses).

I C D T 2 0 2 0

8:6

Weight Annotation in Information Extraction

C a r t e r t f r o m t P l a i n s , t G e o r g i a , t W a s h i n g t o n t f r o m t W e s t m o r e l a n d , t V i r g i n i a

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67

xpers

Carter

xloc

annotation

xpers

xloc

annotation

Plains,tGeorgia

Washington Westmoreland,tVirginia

Carter
Carter

Georgia,tWashington
Westmoreland,tVirginia

0.9
0.9
0.81
0.59049

[1, 7i
[30, 40i
[1, 7i
[1, 7i

[13, 28i
[46, 68i
[21, 40i
[46, 68i

0.9
0.9
0.81
0.59049

Figure 1 A document (top), a (K, D)-relation (bottom left), and an extracted annotated span

relation (bottom right).

A span identiﬁes a substring of a document d by specifying its bounding indices, that
is, a span of d is an expression of the form [i, ji where 1 ≤ i ≤ j ≤ n + 1. By d[i,ji we
denote the substring σi · · · σj−1. In case i = j it holds that d[i,ji is the empty string, which
we denote by ε. We denote by Spans(d) the set of all possible spans of a document d and
by Spans the set of all possible spans of all possible documents. Since we will be working
with relations over spans, we assume that D is such that Spans ⊆ D. A (K, d)-relation over
V ⊆ Vars is deﬁned analogously to a (K, D)-relation over V but only uses V -tuples with
values from Spans(d).

(cid:73) Deﬁnition 3.1. Let (K, ⊕, ⊗, 0, 1) be a semiring. A K-annotator (or annotator for short),
is a function S that is associated with a ﬁnite set V ⊆ Vars of variables and maps documents
d into (K, d)-relations over V . We denote V by Vars(S). We sometimes also refer to an
annotator as an annotator over (K, ⊕, ⊗, 0, 1) when we want to emphasize the semiring.

Notice that B-annotators, i.e., annotators over (B, ∨, ∧, false, true) are simply the document

spanners as deﬁned by Fagin et al. [13].

(cid:73) Example 3.2. We provide an example document d in Figure 1 (top). The table at the
bottom right depicts a possible (K, d)-relation obtained by a spanner that extracts (person,
hometown) pairs from d. Notice that for each span [i, ji occurring in this table, the string
d[i,ji can be found in the table to the left.

In this naïve example, which is just to illustrate the deﬁnitions, we used the Viterbi
semiring and annotated each tuple with (0.9)k, where k is the number of words between the
spans associated to xpers and xloc. The annotations can therefore be interpreted as conﬁdence
scores.

Relational Algebra for K-Annotators

We now lift the relational algebra operators on K-relations to the level of K-annotators. For
all documents d and for all annotators S1 and S2 associated with V1 and V2, respectively,
we deﬁne the following:

Union: If V1 = V2 then the union S def= S1 ∪ S2 is deﬁned by S(d) def= S1(d) ∪ S2(d).3
Projection: For X ⊆ V1, the projection S def= πX S1 is deﬁned by S(d) def= πX S1(d).
Natural Join: The natural join S def= S1 ./ S2 is deﬁned by S(d) def= S1(d) ./ S2(d).

3 Here, ∪ stands for the union of two K-relations as was deﬁned previously. The same is valid also for

the other operators.

J. Doleschal, B. Kimelfeld, W. Martens, and L. Peterfreund

8:7

String selection: Let R be a k-ary string relation. The string-selection operator σR
is parametrized by k variables x1, . . . , xk in V1 and may be written as σR
. Then
S1 is deﬁned as S(d) def= σP(S1(d)) where P is a selection
the annotator S def= σR
predicate with P(t) = 1 if (dt(x1), . . . , dt(xk)) ∈ R; and P(t) = 0 otherwise.

x1,...,xk

x1,...,xk

Due to Proposition 2.3 it follows that the above operators form an algebra on K-annotators.

4 Weighted Variable-Set Automata

In this section, we deﬁne the concept of a weighted vset-automaton as a formalism to represent
K-annotators. This formalism is the natural generalization of vset-automata [13] and weighted
automata [10]. Later in this section, we also present a formalism that is based on parametric
factors, and a speciﬁcation can be translated into a weighted vset-automaton (Section 4.1).
Let V ∈ Vars be a ﬁnite set of variables. Furthermore, let ΓV = {v‘, av | v ∈ V } be
the set of variable operations.4 Let (K, ⊕, ⊗, 0, 1) be a semiring. A weighted variable-set
automaton over semiring K (alternatively, a weighted vset automaton or a K-weighted vset-
automaton) is a tuple A def= (V, Q, I, F, δ) where V ⊆ Vars is a ﬁnite set of variables; Q is a
ﬁnite set of states; I : Q → K is the initial weight function; F : Q → K is the ﬁnal weight
function; and δ : Q × (Σ ∪ {ε} ∪ ΓV ) × Q → K is a (K-weighted) transition function.

We deﬁne the transitions of A as the set of triples (p, o, q) with δ(p, o, q) 6= 0. Likewise,
the initial (resp., accepting) states are those states q with I(q) 6= 0 (resp., F (q) 6= 0). A run
ρ of A over a document d def= d1 · · · dn is a sequence

(q0, i0) o1→ · · · (qm−1, im−1)

om−1→ (qm, im)

where

i0 = 1, im = n + 1, and ij ∈ {1, . . . , n} for each j ∈ {1, . . . , m − 1};
each oj is in Σ ∪ {ε} ∪ ΓV ;
ij+1 = ij whenever oj ∈ {ε} ∪ ΓV and ij+1 = ij + 1, otherwise;
δ(qj, oj, qj+1) 6= 0 for all j ≥ 0.

The weight of a run is obtained by ⊗-multiplying the weights of its constituent transitions.

Formally, the weight wρ of ρ is an element in K given by the expression

I(q0) ⊗ δ(q0, o1, q1) ⊗ · · · ⊗ δ(qm−1, om−1, qm) ⊗ F (qm) .

We call ρ nonzero if wρ 6= 0. Notice that ρ is nonzero only if q0 and qm are initial and ﬁnal,
respectively. A run is called valid if for every variable v ∈ V the following hold: there is
exactly one index i for which oi = v‘ and exactly one index j ≥ i for which oj = av.

For a nonzero and valid run ρ, we deﬁne tρ as the V -tuple that maps each variable
v ∈ V to the span [ij, ij0i where oij = v‘ and oij0 = av. We denote the set of all valid and
nonzero runs of A on d by P (A, d). We naturally extend the notion of functionality to apply
also to general (not necessarily Boolean) weighted vset-automata. A weighted functional
vset-automaton is a weighted vset-automaton whose runs are all valid.5

Notice that there may be inﬁnitely many nonzero and valid runs of a weighted vset-
automaton on a given document, due to ε-cycles, which are sets of states {q1, . . . , qk} such
that (qi, ε, qi+1) is a transition for every i ∈ {1, . . . , k − 1}. Similar to much of the standard

4 The operation v‘ represents opening variable v and av represents closing v.
5 Notice that, while our notion of functionality indeed generalizes the notion on B-weighted vset-automata
[13], one needs positivity of K to ensure that a functional automaton has an output tuple for every valid
run.

I C D T 2 0 2 0

8:8

Weight Annotation in Information Extraction

q1

q0

Σ0; 1

t; 1

xpers‘; 1

Σ0; 1

1

Pers; 1

q3

q2

axpers; 1

q6

q5

Σ0; 1

t; 0.9

xloc‘; 1

Σ0; 1

q4

t; 1

Loc; 1

q8

q7

Σ; 1

1

q10

t; 1

axloc; 1

q9

1

Figure 2 An example weighted vset-automaton over the Viterbi semiring with initial state q0
and two ﬁnal states q9, q10. Σ0 = Σ \ {t}, Pers and Loc are sub-automata matching person and
location names respectively. All edges, including the edges of the sub-automata, have the weight 1
besides the transition from q6 to q5 with weight 0.9.

literature on weighted automata (see, e.g., [12]) we will assume that weighted vset-automata
do not have ε-cycles, unless mentioned otherwise. The reason for this restriction is that
automata with such cycles need K to be closed under inﬁnite sums for their semantics to be
well-deﬁned.6

As such, if A does not have ε-cycles, then the result of applying A on a document d,

denoted

A

(cid:74)
R(t) def=

K(d), is the (K, d)-relation R for which

(cid:75)

M

wρ.

ρ∈P (A,d) and t=tρ

Note that we only use runs ρ that are valid and nonzero here. Observe that if t is a V 0-tuple
K is well deﬁned since every V -tuple in the
with V 0 6= V then R(t) = 0. In addition,
A
K(d) is a V -tuple over Spans(d). The size |A| of a weighted vset-automaton
support of
A is its number of states plus its number of transitions.

A
(cid:74)

(cid:75)

(cid:74)

(cid:75)

We say that a K-annotator S is regular if there exists a weighted vset-automaton A
K. Similar to our terminology on annotators, we use the term B-weighted
such that S =
vset-automata to refer to the “classical” vset-automata of Fagin et al. [13], which are indeed
weighted vset-automata over the Boolean semiring.

A

(cid:75)

(cid:74)

(cid:73) Example 4.1. Figure 2 shows an example weighted vset-automaton over the Viterbi
semiring, which is intended to extract (person, hometown)-tuples from a document. Here,
“Pers” and “Loc” should be interpreted as sub-automata that test if a string could be a
person name or a location. (Such automata can be compiled from publicly available regular
expressions7 and from deterministic rules and dictionaries as illustrated in SystemT [4].)

The relation extracted by this automaton from the document in Figure 1 is exactly the
annotated span relation of the same ﬁgure. The weight of a tuple t depends on the number
of spaces occurring between the span captured by xpers and the span captured by xloc. More
speciﬁcally the automaton assigns the weight (0.9)k to each tuple, where k is the number of
words between the two variables.

4.1 Annotators via Parametric Factors

We now describe another way of introducing weights (or softness) in document spanners.
This section can also be seen as an additional motivation for K-annotators. Indeed, we
will show that, if softness is introduced in document spanners [13] (i.e., B-annotators) in

6 The semirings need to fulﬁll additional properties as well such as distributivity, commutativity and

associativity must also hold for inﬁnite sums. Such semirings are called complete [28].

7 For example, http://regexlib.com/.

J. Doleschal, B. Kimelfeld, W. Martens, and L. Peterfreund

8:9

the standard manner that we recall here, the resulting annotators can be captured in our
framework.

Softness can be introduced in document spanners via the concept of parametric factors,
which is a very common concept that is used in a wide range of contexts. Examples are
the soft keys of Jha et al. [21], the PrDB model of Sen et al. [41], the probabilistic unclean
databases of De Sa et al. [36] which can be viewed as a special case of the Markov Logic
Network (MLN) [35]. Intuitively, a parametric factor is a succinct expression of numerical
factors of a probability via weighted rules: whenever the rule ﬁres, a corresponding factor
(determined by the weight) is added to the product that constitutes the probability. What
we want to show in this section is that, if one has rules that involve B-annotators, and one
adds uncertainty or softness to these rules in this standard way – using parametric factors –
then the obtained formalism naturally leads to K-annotators.

Next, we give the precise deﬁnition of a soft spanner and show that, when the factors are

regular, a soft spanner can be translated into a weighted vset-automaton.

Formally, a soft spanner is a triple Q = (P, S, w), where:
P is a document spanner, i.e., a B-annotator,
S is a ﬁnite set of document spanners referred to as the factor spanners, and
w : S → R assigns a (positive or negative) numerical value to each factor spanner.
Given a document d, the soft spanner Q assigns to each t ∈ P (d) a probability as follows:

ˆQ(d, t) def= exp





X

X

S∈S

u∈{t}(cid:111)(cid:110)S(d)



w(S)

 =

Y

S∈S

ew(S)·|{t}(cid:111)(cid:110)S(d)| ,

Q(d, t) def= ˆQ(d, t)/Z(d),

where Z(d) is a normalization factor (or the partition function) deﬁned in the usual way:

Z(d) =

X

ˆQ(d, t)

t∈P (d)

Note that {t} (cid:111)(cid:110) S(d) is the join of the relation S(d) with the relation that consists of the
single tuple t. Hence, |{t} (cid:111)(cid:110) S(d)| is the number of tuples t0 ∈ S(d) that are compatible
(joinable) with t, that is, t(x) = t0(x) whenever x is in the domain of both t and t0.

(cid:73) Example 4.2. The same relation as discussed in Example 4.1 can also be extracted
using a soft spanner Q = (P, {S}, w). To this end, P is a boolean spanner extracting
(person, hometown)-tuples; S is the spanner, extracting (xpers, y, xloc)-triples of words, where
y matches a word between xpers and xloc; and the weight function w is the function assigning
w(S) = log(0.9). Note that S simply extracts words and does not test whether the words
matched by xpers or xloc correspond to a person or location.

We therefore see that K-annotators can also be deﬁned by applying the standard technique
of parametric factors to document spanners. In fact, as we will see next, soft spanners can be
compiled into weighted vset-automata, which serves as an additional motivation for weighted
vset-automata. To prove the result, we use closure properties of weighted vset-automata that
we will obtain further in the paper (so the proof can be seen as a motivation for the closure-
and computational properties of weighted vset-automata as well).

For the following result, we say that a K-weighted vset-automaton A is unambiguous
K(d), there exists exactly one valid and

A

if, for every document d and every tuple t ∈
nonzero run ρ of A on d such that t = tρ.

(cid:74)

(cid:75)

I C D T 2 0 2 0

8:10 Weight Annotation in Information Extraction

(cid:73) Theorem 4.3. Let Q = (P, S, w) be a soft spanner such that P and every S ∈ S is regular.
R(d)(t) = log( ˆQ(d, t)) for all
There exists an R-weighted vset-automaton A such that
documents d and tuples t; Moreover, if the spanners of Q are represented as unambiguous
functional vset-automata, then A can be constructed in polynomial time in the size of Q.

A

(cid:74)

(cid:75)

Proof sketch. Let Pu be an unambiguous version of P , interpreted as an R-weighted vset-
automaton where true is associated with 1 and false with 0 and let VP be the variables of P .
Let Su be an unambiguous version of S. From Su we compute a weighted vset-automaton
u by interpreting it as an R-weighted vset-automaton and assigning to each accepting state
Sw
q of Su the weight F (q) = w(S). Then the automaton we need for computing log( ˆQ(d, t)) is

A =

[

S∈S

πVP (Pu ./ Sw

u ) .

We show correctness, i.e., log( ˆQ(d, t)) =
u being unambiguous,
it follows directly that Pu ./ Sw
u has exactly one accepting run with weight w(S) for
R(d). Per deﬁnition of union and projection, it follows that
every tuple t ∈
R(d)(t) = P
u∈{t}(cid:111)(cid:110)S(d) w(S) = log( ˆQ(d, t)). As we will obtain in Theorem 5.5,
A
(cid:74)
automaton A can be represented as an R-weighted vset-automaton and can be constructed
(cid:74)
in PTIME, which concludes the proof.

R(d)(t). Due to Pu and Sw

Pu ./ Sw
u
P
(cid:74)
S∈S

A
(cid:74)

(cid:75)

(cid:75)

(cid:75)

5

Fundamental Properties

We now study fundamental properties of annotators. Speciﬁcally, we will show that regular
annotators are closed under union, projection, and join. Furthermore, annotators over positive
semirings are closed under exactly the same string relations as document spanners. We begin
the section by showing that every regular K-annotator can be transformed into an equivalent
functional regular K-annotator without ε-transitions. We say that two vset-automata A and
A0 are equivalent if

A0

K.

A

K =
(cid:75)

(cid:74)

(cid:74)

(cid:75)

(cid:73) Proposition 5.1. For every weighted vset-automaton A there is an equivalent weighted
vset-automaton A0 that has no ε-transitions. This automaton A0 can be constructed from A
in PTIME. Furthermore, A is functional if and only if A0 is functional.

Notice that non-functional vset-automata can be inconvenient to work with, since some
of their nonzero runs are not valid and therefore do not contribute to the weight of a tuple.
It is therefore desirable to be able to automatically convert weighted vset-automata into
functional weighted vset-automata.

(cid:73) Proposition 5.2. Let A be a weighted vset-automaton. Then there is a functional weighted
vset-automaton Afun that is equivalent to A. If A has n states and uses k variables, then
Afun can be constructed in time polynomial in n and exponential in k.

The exponential blow-up in Proposition 5.2 cannot be avoided, since Freydenberger [17,
Proposition 3.9] showed that there is a vset-automaton A (over B) with one state and
k variables, such that every equivalent functional vset-automaton has at least 3k states.
Functionality of vset-automata can be checked eﬃciently, as we have the following result.

(cid:73) Proposition 5.3. Given a weighted vset-automaton A with m transitions and k variables,
it can be decided whether A is functional in time O(km).

J. Doleschal, B. Kimelfeld, W. Martens, and L. Peterfreund

8:11

(cid:73) Observation 5.4 ((Similar to Freydenberger et al. [18])). Let A def= (V, Q, I, F, δ) be a
K-weighted functional vset-automaton. Then there exists a function C : Q × V 7→ {w, o, c}
that maps every state to its variable conﬁguration, i.e., C(q, x) ∈ {w, o, c} depending on
whether x is waiting, open, or closed in state q. More formally, the function

w there is a nonzero run where v‘ does not occur before reaching q,

C(q, v) =

there is a nonzero run where v‘ but not av occur before reaching q,

there is a nonzero run where v‘ and av occur before reaching q.



o

c

is well-deﬁned. Indeed, if C would not be well-deﬁned, then two conﬂicting runs would
contradict the functionality of A.

5.1 Closure Under Join, Union, and Projection

Here we obtain the following result.

(cid:73) Theorem 5.5. Regular annotators are closed under union, projection, and natural join.

Whereas union and projection are fairly standard, the case of join needs some care in
the case that the two automata A1 and A2 process variable operations in diﬀerent orders.
(I.e., if A1 processes x‘ y‘ a ay ax and A2 processes y‘ x‘ a ax ay, then these two diﬀerent
sequences produce the same result. The automata construction has to deal with this.) One
can also show that, if the annotators are given as functional weighted vset-automata, then
the construction for a single union, projection, and join can be done in polynomial time.
Furthermore, the constructions preserve functionality.

5.2 Closure under String Selection

A k-ary string relation is recognizable if it is a ﬁnite union of Cartesian products of regular
string languages [37]. Let REGK be the set of regular K-annotators. We say that a k-ary
string relation R is selectable by regular K-annotators if the following equivalence holds:

REGK = {σR

x1,...,xk

(S) | S ∈ REGK and xi ∈ Vars(S) for all 1 ≤ i ≤ k} ,

that is, the class of K-annotators is closed under selection using R. If K = B, we say that R is
selectable by document spanners. Fagin et al. [13] proved that a string relation is recognizable
if and only if it is selectable by document spanners. Here, we generalize this result in the
context of weights and annotation. Indeed, it turns out that the equivalence is maintained
for all positive semirings.

(cid:73) Theorem 5.6. Let (K, ⊕, ⊗, 0, 1) be a positive semiring and R be a string relation. The
following are equivalent:
(1) R is recognizable.
(2) R is selectable by document spanners.
(3) R is selectable by K-annotators.

Proof sketch. The equivalence between (1) and (2) is known [13, Theorem 4.16]. The proof
(2) ⇒ (3) is heavily based on the closure properties from Theorem 5.5 and does not use
positivity of the semiring. For (3) ⇒ (2) we use semiring morphisms to turn K-weighted
(cid:74)
vset-automata into B-weighted vset-automata and need positivity of the semiring.

Since the implication from (2) to (3) does not assume positivity of the semiring, it raises
the question if the equivalence can be generalized even further. One can show that this is
indeed the case, such as for the Łukasiewicz semiring, which is not positive.

I C D T 2 0 2 0

8:12 Weight Annotation in Information Extraction

6

Evaluation Problems

We consider two types of evaluation problems in this section: answer testing and best weight
evaluation. The former is given an annotator, document d, and tuple t; and computes the
annotation of t in d according to the annotator. The latter does not receive the tuple as
input, but recieves a weight threshold and is asked whether there exists a tuple that is
returned with a weight that is at least the threshold.

6.1 Answer Testing

It follows from Freydenberger [17, Lemma 3.1] that answer testing is NP-complete for
B-weighted vset-automata in general. Indeed, he showed that, given a B-weighted vset-
automaton A, it is NP-complete to check if A returns any output on the empty document ε,
so it is even NP-complete to check if the tuple of empty spans is returned or not. However,
the proof makes extensive use of non-functionality of the automaton. Indeed, we can prove
that answer testing is tractable for functional weighted vset-automata.

(cid:73) Theorem 6.1. Given a functional weighted vset-automaton A, a document d, and a tuple
t, the weight

K(d)(t) assigned to t by A on d can be computed in PTIME.
(cid:75)

A

(cid:74)

Proof sketch. Let A, d, and t be as stated. Per deﬁnition, the weight assigned to t by A is

K(d)(t) def=

A
(cid:74)

(cid:75)

M

wρ.

ρ∈P (A,d) and t=tρ

K(d)(t), we need to consider the weights of all
Therefore, in order to compute the weight
(cid:75)
runs ρ for which t = tρ. Furthermore, multiple runs can select the same tuple t but assign
variables in a diﬀerent order.8

A

(cid:74)

We ﬁrst deﬁne an automaton At, such that

K(d)(t0) = 0
(cid:75)
(cid:74)
otherwise. Such an automaton At can be deﬁned using a chain of |d| + 2|V | + 1 states, which
checks that the input document is d and which has exactly one nonzero run ρ, with wρ = 1
and tρ = t.

K(d)(t0) = 1 if t = t0 and

At

At

(cid:75)

(cid:74)

By Theorem 5.5 there is a weighted vset-automaton A0 such that

K. It
(cid:74)
(cid:75)
K(d)(t). Furthermore, all
follows directly from the deﬁnition of A0 that
K(d)(t) can be
accepting runs ρ ∈ P (A0, d) have length |d| + 2|V |. Therefore, the weight
obtained by taking the sum of the weights of all accepting runs of A0. If we assume w.l.o.g.
that the states of A0 are {1, . . . , n} for some n ∈ N, then this sum can be computed as

K(d)(t) =

A ./ At

A0
(cid:74)

K =

A0

A0

A

(cid:75)

(cid:75)

(cid:74)

(cid:75)

(cid:74)

(cid:75)

(cid:74)

K(d)(t) = vI × (Mδ)|d|+2|V | × (vF )T ,

A0

(cid:74)

(cid:75)

where

vI is the vector (I(1), . . . , I(n)),
Mδ is the n × n matrix with Mδ(i, j) = L
(vF )T is the transpose of vector vF = (F (1), . . . , F (n)).

a∈Σ δ(i, a, j), and

Since n is polynomial in the input, this product can be computed in polynomial time. (cid:74)

8 This may happen when variable operations occur consecutively, i.e., without reading a symbol in

between.

J. Doleschal, B. Kimelfeld, W. Martens, and L. Peterfreund

8:13

6.2 Best Weight Evaluation

In many semirings, the domain is naturally ordered by some relation. For instance, the
domain of the probability semiring is R+, which is ordered by the ≤-relation. This motivates
evaluation problems where we are interested in some kind of optimization of the weight,
which we will look into in this section.

(cid:73) Deﬁnition 6.2 ((Dorste and Kuich [9])). A commutative monoid (K, ⊕, 0) is ordered if
it is equipped with a partial order (cid:54) preserved by the ⊕ operation. An ordered monoid is
positively ordered if 0 (cid:54) a for all a ∈ K. A semiring (K, ⊕, ⊗, 0, 1) is (positively) ordered if
the additive monoid is (positively) ordered and multiplication with elements 0 (cid:54) a preserves
the order.

We consider the following two problems.

Threshold

Given:

Question:

Regular annotator A over an ordered semiring, document d ∈ Docs,
and a weight w ∈ K.
Is there a tuple t with w (cid:54)

K(d)(t)?
A
(cid:75)
(cid:74)

MaxTuple

Given: Regular annotator A over an ordered semiring and a document d ∈ Docs.

Task:

Compute a tuple with maximal weight, if it exists.

Notice that, if MaxTuple is eﬃciently solvable, then so is Threshold. We therefore
prove upper bounds for MaxTuple and lower bounds for Threshold. The Threshold
problem is sometimes also called the emptiness problem in the weighted automata literature.
It turns out that, for positively ordered semirings that are bipotent (that is, a ⊕ b ∈ {a, b}),
both problems are tractable.

(cid:73) Theorem 6.3. Let (K, ⊕, ⊗, 0, 1) be a positively ordered, bipotent semiring. Furthermore,
let A be a functional K-weighted vset-automaton and let d ∈ Docs be a document. Then
MaxTuple for A and d can be solved in PTIME.

K(d) is
Proof sketch. Since a ⊕ b ∈ {a, b} for every a, b ∈ K, the weight of a tuple t ∈
always equal to the weight of one of the accepting runs ρ with t = tρ. Thus in order to ﬁnd
the tuple with maximal weight, we need to ﬁnd the run of A on d with maximal weight.
This boils down to ﬁnding a maximal weight path in a DAG, which is obtained by taking a
(cid:74)
“product” between A and d.

A

(cid:75)

(cid:74)

If the semiring is not bipotent, however, the Threshold and MaxTuple problems

become intractable quickly.

(cid:73) Theorem 6.4. Let (K, ⊕, ⊗, 0, 1) be a semiring such that Lm
i=1 1 is strictly monotonously
increasing for increasing values of m. Futhermore let A be a functional K-weighted vset-
automaton, let d ∈ Docs be a document, and k ∈ K be a weight threshold. Then Threshold
for such inputs is NP-complete.

Proof sketch. It is obvious that Threshold is in NP, as one can guess a tuple t and and
K(d)(t) using Theorem 6.1.
test in PTIME whether w (cid:54)
For the NP-hardness, we will reduce from MAX-3SAT. To this end, let ψ = C1 ∧ · · · ∧ Cm
be a boolean formula in 3CNF over variables x1, . . . , xn such that each clause Ci = (‘i,1 ∨‘i,2 ∨
‘i,3) is a disjunction of exactly three literals ‘i,j ∈ {xc, ¬xc | 1 ≤ c ≤ n}, 1 ≤ i ≤ k, 1 ≤ j ≤ 3.

A

(cid:75)

(cid:74)

I C D T 2 0 2 0

8:14 Weight Annotation in Information Extraction

x1

ax1

q1,3
1,1

a

q1,4
1,1

ax1

q1,1
1,1

x1‘

q1,2
1,1

x3 ∨ ¬x3

q1,5
1,1

x2‘

q1,2
1,2

ax2

q1,3
1,2

a

q1,4
1,2

ax2

x2

q1,5
1,2

x3‘

q1,2
1,3

ax3

q1,3
1,3

a

a

q1,4
1,3

ax3

q1,5
1,3

x4‘

q1,2
1,4

ax4

q1,3
1,4

a

q1,4
1,4

ax4

q1,5
1,4

¬x4

Figure 3 The sub-branch of Aψ corresponding to C1 and x1 = x2 = 1, x4 = 0.

ax

a

x‘

ax

a

x‘

a

ax

ax

x‘

ax

a

ax

Figure 4 Example gadgets for variable x.

W.l.o.g., we can assume that no clause has two literals corresponding to the same variable.
Observe that for each clause Ci there are 23 = 8 assignments of the variables corresponding to
the literals of Ci of which exactly 7 satisfy the clause Ci. Formally, let fCi be the function that
maps a variable assignment τ to a number between 1 and 8, depending on the assignments
of the literals of the clause Ci. W.l.o.g., we can assume that fCi(τ ) = 8 iﬀ Ci is not satisﬁed
by τ .

(cid:74)

(cid:75)

We will deﬁne a functional weighted automaton automaton Aψ over the unary alphabet
K(an)(t) = Lm
i=1 1 if and only if the assignment corresponding to t
(cid:75)
Aψ

Σ = {a} such that
satisﬁes exactly m clauses in ψ and

K(d) = ∅ if d 6= an.

Aψ
(cid:74)

To this end, each variable xi of ψ is associated with a corresponding capture variable xi

of Aψ. We associate a tuple tτ with every assignment τ such that

tτ (xi) =

(

[i, ii

[i, i + 1i

if τ (xi) = 0, and
if τ (xi) = 1.

def= (V, Q, I, F, δ) consists of m disjoint branches, where each branch
The automaton Aψ
corresponds to a clause of ψ; we call these clause branches. Each clause branch is divided into
7 sub-branches, such that a path in the sub-branch j corresponds to a variable assignment τ
if fCi(τ ) = j. Thus, each clause branch has exactly one run ρ with weight 1 for each tuple
tτ associated to a satisfying assignment τ of Ci.
More formally, the set of states Q = {qa,b

i,j | 1 ≤ i ≤ m, 1 ≤ j ≤ n, 1 ≤ a ≤ 7, 1 ≤ b ≤ 5}
contains 5n states for every of the 7 sub-branches of each clause branch. Intuitively, Aψ has
a gadget, consisting of 5 states, for each variable and each of the 7 satisfying assignments of
each clause. Figure 4 depicts the three types of gadgets we use here. Note that the weights
of the drawn edges are all 1. We use the left gadget if x does not occur in the relevant clause
and the middle (resp., right) gadget if the literal ¬x (resp., x) occurs. Furthermore, within
the same sub-branch of Aψ, the last state of each gadget is the same state as the start state
of the next variable, i.e., qa,5

i,j+1 for all 1 ≤ i ≤ k, 1 ≤ j < n, 1 ≤ a ≤ 7.

i,j = qa,1

We illustrate the crucial part of the construction on an example. Let ψ = (x1 ∨ ¬x2 ∨
x4) ∧ (x2 ∨ x3 ∨ x4). The corresponding weighted vset-automaton Aψ therefore has 14 = 2 × 7
disjoint branches. Figure 3 depicts the sub-branch for clause C1 that corresponds to all
(cid:74)
assignments with x1 = x2 = 1 and x4 = 0.

J. Doleschal, B. Kimelfeld, W. Martens, and L. Peterfreund

8:15

We note that Theorem 6.3 and Theorem 6.4 give us tight bounds for all semirings we

deﬁned in Example 2.1.

Since MAX-3SAT is hard to approximate, we can turn Theorem 6.4 into an even stronger
inapproximability result for semirings where approximation makes sense. To this end, we
focus on semirings that contain (N, +, ·, 0, 1) (as a sub-semiring) in the following result.

(cid:73) Theorem 6.5. Let K be a semiring that contains (N, +, ·, 0, 1) and let A be a weighted
vset-automaton over K. Unless PTIME = NP, there is no algorithm that approximates the
tuple with the best weight within a sub-exponential factor in PTIME.

7

Enumeration Problems

In this section we consider computing the output of annotators from the perspective of
enumeration problems, where we try to enumerate all tuples with nonzero weight, possibly
from large to small. Such problems are highly relevant for (variants of) vset-automata, as
witnessed by the recent literature on the topic [2,15]. We assume familiarity with terminology
in enumeration algorithms such as preprocessing time and delay. If the order of the answers
does not matter and the semiring is positive, we can guarantee a constant delay enumeration
algorithm with linear preprocessing time.

(cid:73) Theorem 7.1. Given a weighted functional vset-automaton A over a positive semiring K,
K(d) can be enumerated with preprocessing linear in
and a document d, the K-Relation
A
(cid:74)
|d| and polynomial in |A| and delay constant in |d| and polynomial in |A|.

(cid:75)

Note that the proof of the theorem essentially requires to go through the entire proof of the
main result of Amarilli et al. [2, Theorem 1.1].

We now consider cases in which answers are required to arrive in a certain ordering.

Ranked Annotator Enumeration (RA-Enum)

Given: Regular functional annotator A over an ordered semiring

(K, ⊕, ⊗, 0, 1) and a document d.
Enumerate all tuples t ∈

Task:

K(d) in descending order on K.
A
(cid:75)
(cid:74)
(cid:73) Theorem 7.2. Let (K, ⊕, ⊗, 0, 1) be an positively ordered, bipotent semiring, let A be a
functional K-weighted vset-automaton, and let d ∈ Docs be a document. Then RA-Enum
can be solved with polynomial delay and preprocessing.

Proof sketch. Our algorithm is a slight adaptation of Yen’s algorithm [48]. To this end, we
will use the DAG we deﬁned in the proof of Theorem 6.3, but invest a bit more preprocessing.
In particular, we change the DAG so that it has a one-to-one correspondence between
output tuples and some of its paths. Using this correspondence, we can then revert to Yen’s
(cid:74)
algorithm for enumerating simple paths in graphs.

8

Concluding Remarks

We embarked on a study that incorporates annotations or weights in information extraction
and propose K-annotators as a candidate formalism to study this problem. The K-annotators
can be instantiated with weighted vset-automata, thereby obtaining regular K-annotators,
which are powerful enough to capture the extension of the traditional spanner framework with
parametric factors. Furthermore, the regular K-annotators have favorable closure properties,
such as closure under union, projection, natural join, and string selection using regular

I C D T 2 0 2 0

8:16 Weight Annotation in Information Extraction

relations. The ﬁrst complexity results on evaluation problems are encouraging: answer
testing is tractable and, depending on the semiring, problems such as the threshold problem,
the max tuple problem, and enumeration of answers are tractable too.

We note that the addition of weights to vset-automata also introduces new challenges.
For instance, some typical questions that we study in database theory are not yet fully
understood for weighted automata, which are the basis of weighted vset-automata. Examples
are equivalence and emptiness. Concerning equivalence, one can show that equivalence is
undecidable for weighted vset-automata over the tropical semiring, using techniques from
Krob [23] or Almagor et al. [1]. In general, however, it is not completely clear for which
semirings equivalence is decidable or not.

The emptiness problem that is usually studied in the weighted automata literature does
not ask if there exists a document d such that the automaton returns at least one tuple
with nonzero weight on d, but is additionally given a threshold (as in our Threshold
problem) and asks if the automaton returns a tuple with at least the threshold weight (which
requires an order on the semiring). It is not yet clear how much this threshold inﬂuences the
complexity of the problem.

An additional challenge is that determinization of weighted automata is a complex matter
and not always possible. It is well-known to be possible for the Boolean semiring but, for
the tropical semiring, i.e., (R ∪ {−∞}, max, +, −∞, 0), deterministic weighted automata
are strictly less expressive than unambiguous weighted automata, which are strictly less
expressive than general weighted automata, cf. Klimann et al. [22].

A possible direction for further exploration could be the study of annotators which use
regular cost functions (cf. Colcombet [6]) instead of weighted automata. Since regular cost
functions are restructed to the domain of the natural numbers, this would probably be most
interesting in the case where the semiring domain is (a subset of) the natural numbers.
Indeed, in this case, it is known that regular cost functions are strictly more expressive than
weighted automata over the tropical semiring (cf. Colcombet et al. [7]) and therefore could
provide a useful tool to annotate document spanners. On the other hand, it is not yet clear
to us how to associate regular cost functions in a natural way to annotated relations, which
require semirings.

References

1

Shaull Almagor, Udi Boker, and Orna Kupferman. What’s Decidable about Weighted Auto-
mata? In Automated Technology for Veriﬁcation and Analysis, pages 482–491, 2011.

2 Antoine Amarilli, Pierre Bourhis, Stefan Mengel, and Matthias Niewerth. Constant-Delay
Enumeration for Nondeterministic Document Spanners. In ICDT, pages 22:1–22:19, 2019.
3 Marcelo Arenas, Luis Alberto Croquevielle, Rajesh Jayaram, and Cristian Riveros. Eﬃcient
Logspace Classes for Enumeration, Counting, and Uniform Generation. In PODS, pages 59–73,
2019.
Laura Chiticariu, Rajasekar Krishnamurthy, Yunyao Li, Sriram Raghavan, Frederick Reiss, and
Shivakumar Vaithyanathan. SystemT: An Algebraic Approach to Declarative Information Ex-
traction. In ACL, pages 128–137, 2010. URL: http://www.aclweb.org/anthology/P10-1014.
Jason P. C. Chiu and Eric Nichols. Named Entity Recognition with Bidirectional LSTM-CNNs.
TACL, 4:357–370, 2016.

4

5

6 T. Colcombet. Logic and regular cost functions. In LICS, pages 1–4, 2017. doi:10.1109/

LICS.2017.8005061.

7 Thomas Colcombet, Denis Kuperberg, Amaldev Manuel, and Szymon Torunczyk. Cost
Functions Deﬁnable by Min/Max Automata. In STACS), volume 47, pages 29:1–29:13, 2016.
doi:10.4230/LIPIcs.STACS.2016.29.

J. Doleschal, B. Kimelfeld, W. Martens, and L. Peterfreund

8:17

8

Johannes Doleschal, Benny Kimelfeld, Wim Martens, Yoav Nahshon, and Frank Neven. Split-
Correctness in Information Extraction. In PODS, pages 149–163, 2019. doi:10.1145/3294052.
3319684.

9 Manfred Droste and Werner Kuich. Semirings and Formal Power Series, pages 3–28. Springer

Berlin Heidelberg, 2009. doi:10.1007/978-3-642-01492-5_1.

10 Manfred Droste, Werner Kuich, and Heiko Vogler. Handbook of Weighted Automata. Springer

11

12

Publishing Company, Incorporated, 1st edition, 2009.
Samuel Eilenberg. Automata, Languages, and Machines. Academic Press, Inc., Orlando, FL,
USA, 1974.
Zoltán Ésik and Werner Kuich. Finite Automata, pages 69–104. Springer Berlin Heidelberg,
2009. doi:10.1007/978-3-642-01492-5_3.

13 Ronald Fagin, Benny Kimelfeld, Frederick Reiss, and Stijn Vansummeren. Document Spanners:
A Formal Approach to Information Extraction. J. ACM, 62(2):12, 2015. doi:10.1145/2699442.
14 Ronald Fagin, Benny Kimelfeld, Frederick Reiss, and Stijn Vansummeren. Declarative Cleaning
of Inconsistencies in Information Extraction. ACM Trans. Database Syst., 41(1):6:1–6:44, 2016.
doi:10.1145/2877202.
Fernando Florenzano, Cristian Riveros, Martín Ugarte, Stijn Vansummeren, and Domagoj
Vrgoc. Constant Delay Algorithms for Regular Document Spanners. In PODS, pages 165–177,
2018.
J. Nathan Foster, Todd J. Green, and Val Tannen. Annotated XML: queries and provenance.
In PODS, pages 271–280, 2008.

15

16

17 Dominik D. Freydenberger. A Logic for Document Spanners. Theory Comput. Syst., 63(7):1679–

1754, 2019.

18 Dominik D. Freydenberger, Benny Kimelfeld, and Liat Peterfreund. Joining Extractions of

Regular Expressions. In PODS, pages 137–149, 2018.
Joshua Goodman. Semiring Parsing. Computational Linguistics, 25(4):573–605, 1999.

19
20 Todd J. Green, Gregory Karvounarakis, and Val Tannen. Provenance semirings.

In
Proceedings of the Twenty-Sixth ACM SIGACT-SIGMOD-SIGART Symposium on Prin-
ciples of Database Systems, June 11-13, 2007, Beijing, China, pages 31–40, 2007. doi:
10.1145/1265530.1265535.

21 Abhay Kumar Jha, Vibhor Rastogi, and Dan Suciu. Query evaluation with soft-key constraints.

22

In PODS, pages 119–128, 2008.
Ines Klimann, Sylvain Lombardy, Jean Mairesse, and Christophe Prieur. Deciding unambiguity
and sequentiality from a ﬁnitely ambiguous max-plus automaton. Theoretical Computer Science,
327(3):349–373, 2004. doi:10.1016/j.tcs.2004.02.049.

25

23 Daniel Krob. The Equality Problem for Rational Series with Multiplicities in the tropical
Semiring is Undecidable. IJAC, 4(3):405–426, 1994. doi:10.1142/S0218196794000063.
24 Yaoyong Li, Kalina Bontcheva, and Hamish Cunningham. SVM based learning system for
information extraction. In Deterministic and Statistical Methods in Machine Learning, volume
3635 of Lecture Notes in Computer Science, pages 319–339, 2004.
Francisco Maturana, Cristian Riveros, and Domagoj Vrgoc. Document Spanners for Extracting
Incomplete Information: Expressiveness and Complexity. In PODS, pages 125–136, 2018.
Franz Mayr and Sergio Yovine. Regular Inference on Artiﬁcial Neural Networks. In CD-MAKE,
volume 11015 of Lecture Notes in Computer Science, pages 350–369, 2018.
Joshua J. Michalenko, Ameesh Shah, Abhinav Verma, Richard G. Baraniuk, Swarat Chaudhuri,
and Ankit B. Patel. Representing Formal Languages: A Comparison Between Finite Automata
and Recurrent Neural Networks. In ICLR (Poster), 2019.

27

26

28 Mehryar Mohri. Weighted Automata Algorithms, pages 213–254. Springer Berlin Heidelberg,

2009. doi:10.1007/978-3-642-01492-5_6.

29 Nanyun Peng, Hoifung Poon, Chris Quirk, Kristina Toutanova, and Wen-tau Yih. Cross-

Sentence N-ary Relation Extraction with Graph LSTMs. TACL, 5:101–115, 2017.

I C D T 2 0 2 0

8:18 Weight Annotation in Information Extraction

30

31

Liat Peterfreund, Dominik D. Freydenberger, Benny Kimelfeld, and Markus Kröll. Complexity
Bounds for Relational Algebra over Document Spanners. In PODS, pages 320–334. ACM,
2019.
Liat Peterfreund, Balder ten Cate, Ronald Fagin, and Benny Kimelfeld. Recursive Programs
for Document Spanners. In ICDT, volume 127, pages 13:1–13:18, 2019.

32 Hoifung Poon and Pedro M. Domingos. Joint Inference in Information Extraction. In AAAI,

pages 913–918, 2007.

33 Michael O. Rabin. Probabilistic automata. Information and Control, 6(3):230–245, 1963.

doi:10.1016/S0019-9958(63)90290-0.

34 Alexander Ratner, Stephen H. Bach, Henry R. Ehrenberg, Jason Alan Fries, Sen Wu, and
Christopher Ré. Snorkel: Rapid Training Data Creation with Weak Supervision. PVLDB,
11(3):269–282, 2017.

35 Matthew Richardson and Pedro Domingos. Markov Logic Networks. Mach. Learn., 62(1-

36

37

38

2):107–136, 2006. doi:10.1007/s10994-006-5833-1.
Christopher De Sa, Ihab F. Ilyas, Benny Kimelfeld, Christopher Ré, and Theodoros Rekatsinas.
In ICDT, volume 127, pages
A Formal Framework for Probabilistic Unclean Databases.
6:1–6:18, 2019.
Jacques Sakarovitch. Elements of Automata Theory. Cambridge University Press, 2009.
doi:10.1017/CBO9781139195218.
Sunita Sarawagi. Information Extraction. Foundations and Trends in Databases, 1(3):261–377,
2008. doi:10.1561/1900000003.

39 Roy Schwartz, Sam Thomson, and Noah A. Smith. Bridging CNNs, RNNs, and Weighted

Finite-State Machines. In ACL, pages 295–305, 2018.

40 Roberto Segala. Probability and Nondeterminism in Operational Models of Concurrency. In

41

CONCUR, pages 64–78, 2006.
Prithviraj Sen, Amol Deshpande, and Lise Getoor. PrDB: managing and exploiting rich
correlations in probabilistic databases. VLDB J., 18(5):1065–1090, 2009.

42 Warren Shen, AnHai Doan, Jeﬀrey F. Naughton, and Raghu Ramakrishnan. Declarative Inform-
ation Extraction Using Datalog with Embedded Extraction Predicates. In VLDB, pages 1033–
1044, 2007. URL: http://www.vldb.org/conf/2007/papers/research/p1033-shen.pdf.
Jaeho Shin, Sen Wu, Feiran Wang, Christopher De Sa, Ce Zhang, and Christopher Ré.
Incremental Knowledge Base Construction Using DeepDive. PVLDB, 8(11):1310–1321, 2015.
URL: http://www.vldb.org/pvldb/vol8/p1310-shin.pdf.

43

44 Charles A. Sutton and Andrew McCallum. An Introduction to Conditional Random Fields.

Foundations and Trends in Machine Learning, 4(4):267–373, 2012.

45 David Torrents, Mikita Suyama, Evgeny Zdobnov, and Peer Bork. A genome-wide survey of

46

human pseudogenes. Genome research, 13(12):2559–2567, 2003.
Lusheng Wang and Tao Jiang. On the Complexity of Multiple Sequence Alignment. Journal
of Computational Biology, 1(4):337–348, 1994.

47 Gail Weiss, Yoav Goldberg, and Eran Yahav. Extracting Automata from Recurrent Neural
Networks Using Queries and Counterexamples. In ICML, volume 80, pages 5244–5253, 2018.
Jin Y. Yen. Finding the k Shortest Loopless Paths in a Network. Management Science,
17(11):712–716, 1971. URL: http://www.jstor.org/stable/2629312.

48

