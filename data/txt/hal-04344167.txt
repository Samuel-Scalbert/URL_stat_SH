Energy Büchi Problems
Sven Dziadek, Uli Fahrenberg, Philipp Schlehuber-Caissier

To cite this version:

Sven Dziadek, Uli Fahrenberg, Philipp Schlehuber-Caissier. Energy Büchi Problems. FM 2023 - 25th
International Symposium on Formal Methods, Mar 2023, Lübeck, Germany. pp.222-239, ￿10.1007/978-
3-031-27481-7_14￿. ￿hal-04344167￿

HAL Id: hal-04344167

https://inria.hal.science/hal-04344167

Submitted on 14 Dec 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution 4.0 International License

2
2
0
2

c
e
D
2
2

]

O
L
.
s
c
[

2
v
2
9
3
4
0
.
5
0
2
2
:
v
i
X
r
a

Energy B¨uchi Problems (cid:63)

Sven Dziadek[0000−0001−6767−7751], Uli Fahrenberg[0000−0001−9094−7625], and
Philipp Schlehuber-Caissier[0000−0002−6611−9659]

EPITA Research Laboratory (LRE), Paris, France

Abstract. We show how to eﬃciently solve energy B¨uchi problems in
ﬁnite weighted automata and in one-clock weighted timed automata.
Solving the former problem is our main contribution and is handled by a
modiﬁed version of Bellman-Ford interleaved with Couvreur’s algorithm.
The latter problem is handled via a reduction to the former relying on
the corner-point abstraction. All our algorithms are freely available and
implemented in a tool based on the open-source platforms TChecker
and Spot.

Keywords: weighted timed automaton; weighted automaton; energy
problem; generalized B¨uchi acceptance; energy constraints

1

Introduction

Energy problems in weighted (timed) automata pose the question whether there
exist inﬁnite runs in which the accumulated weights always stay positive. Since
their introduction in [7], much research has gone into diﬀerent variants of these
problems, for example energy games [12, 16, 27], energy parity games [11], robust
energy problems [2], etc., and into their application in embedded systems [17, 19],
satellite control [5,25], and other areas. Nevertheless, many basic questions remain
open and implementations are somewhat lacking.

The above results discuss looping automata [28], i.e., ω-automata in which
all states are accepting. In practice, looping automata do not suﬃce because
they cannot express all liveness properties. For model checking, formal properties
(e.g., in LTL) are commonly translated into (generalized) B¨uchi automata [9]
that provide a simple model for the larger class of ω-regular languages.

In this work, we extend energy problems with transition-based generalized
B¨uchi conditions and treat them for weighted automata as well as weighted timed
automata with precisely one clock. On weighted automata we show that they are
eﬀectively decidable using a combination of a modiﬁed Bellman-Ford algorithm
with Couvreur’s algorithm. For weighted timed automata we show that one can
use the corner-point abstraction to translate the problem to weighted (untimed)
automata.

For looping automata, the above problems have been solved in [7]. (This
paper also treats energy games and so-called universal energy problems, both of

(cid:63) Partially funded by ANR project Ticktac (ANR-18-CE40-0015)

AvailableFMEvaluationArtifactFMEvaluationArtifactReproducible 
 
 
 
 
 
2

S. Dziadek, U. Fahrenberg, P. Schlehuber-Caissier

x ≤ 35

−10

x = 35 x ← 0

x = 55 x ← 0

(a)

x ≤ 55

+40

−350

1

2

2200

(b)

Fig. 1: Satellite example: two representations of the base circuit. (a) as weighted
timed automaton A; (b) as a (ﬁnite) weighted automaton.

which are of no concern to us here.) While we can re-use some of the methods of
[7] for our B¨uchi-enriched case, our extension is by no means trivial. First, in the
setting of [7] it suﬃces to ﬁnd any reachable and energy positive loop; now, our
algorithm must consider that such loops might not be accepting in themselves
but give access to new parts of the automaton which are. Secondly, [7] mostly
treat the energy problem with unlimited upper bound, whereas we consider that
energy has a (“weak”) upper bound beyond which it cannot increase. [7] claim
that the weak-upper-bound problem can be solved by slight modiﬁcations to
their solution of the unbounded problem; but this is not the case. For example,
the typical Bellman-Ford detection of positive cycles might not work when the
energy levels attained in the previous step are already equal to the upper bound.
As a second contribution, we have implemented all of our algorithms in a tool
based on the open-source platforms TChecker1 [22] and Spot2 [13] to solve gener-
alized energy B¨uchi problems for one-clock weighted timed automata. We ﬁrst
employ TChecker to compute the zone graph and then use this to construct the
corner-point abstraction. This in turn is a weighted (untimed) generalized B¨uchi
automaton, in which we also may apply a variant of Alur and Dill’s Zeno-exclusion
technique [1]. Finally, our main algorithm to solve generalized energy B¨uchi prob-
lems on weighted ﬁnite automata is implemented using a fork of Spot. Our software
is available at https://github.com/PhilippSchlehuberCaissier/wspot.

In our approach to solve the latter problem, we do not fully separate the energy
and B¨uchi conditions (contrary to, for example, [11] who reduce energy parity
games to energy games). We ﬁrst determine the strongly connected components
(SCCs) of the unweighted automaton. Then we degeneralize each B¨uchi accepting
SCC one by one, using the standard counting construction [20]. Finally, we apply
a modiﬁed Bellman-Ford algorithm to search for energy feasible lassos that start
on the main graph and loop in the SCC traversing the remaining B¨uchi condition.

Running example 1. To clarify notation and put the concepts into context, we
introduce a small running example. A satellite in low-earth orbit has a rotation
time of about 90 minutes, 40% of which are spent in earth shadow. Measuring
time in minutes and (electrical) energy in unspeciﬁed “energy units”, we may
thus model its simpliﬁed base electrical system as shown in Fig. 1a.

1 See https://github.com/ticktac-project/tchecker
2 See https://spot.lrde.epita.fr/

Energy B¨uchi Problems

3

x ≤ 5

−20

x = 5
•

x ← 0

x ≤ 35

−10

x = 35 x ← 0

x = 55 x ← 0

x ≤ 55

+40

Fig. 2: Weighted timed automaton A1 for satellite with work module.

This is a weighted timed automaton (the formalism will be introduced in
Sect. 3) with one clock, x, and two locations. The clock is used to model time,
which progresses with a constant rate but can be reset on transitions. The initial
location on the left (modeling earth shadow) is only active as long as x ≤ 35,
and given that x is initially zero, this means that the model may stay here for at
most 35 minutes. Staying in this location consumes 10 energy units per minute,
corresponding to the satellite’s base consumption.

After 35 minutes the model transitions to the “sun” location on the right,
where it can stay for at most 55 minutes and the solar panels produce 50 energy
units per minute, from which the base consumption has to be subtracted. Note
that the transitions can only be taken if the clock shows exactly 35 (resp. 55)
minutes; the clock is reset to zero after the transition, as denoted by x ← 0. This
ensures that the satellite stays exactly 35 minutes in the shadow and 55 minutes
in the sun, roughly consistent with the “physical” model.

Figure 1b shows a translation of the automaton of Fig. 1a to a weighted
untimed automaton. State 1 corresponds to the “shadow” location, transitions are
annotated with the corresponding weights, the rate of the location multiplied by
the time spent in it. In Sect. 3 we will show how to obtain a weighted automaton
from a weighted timed automaton with precisely one clock.

One may now pose the following question: for a given battery capacity b and
an initial charge c, is it possible for the satellite to function indeﬁnitely without
ever running out of energy? It is clear that for c < 350 or b < 350, the answer is
no: the satellite will run out of battery before ever leaving Earth’s shadow; for
b ≥ 350 and c ≥ 350, it will indeed never run out of energy.

Now assume that the satellite also has some work to do: once in a while it
must, for example, send some collected data to earth. Given that we can only
handle weighted automata with precisely one clock (see Sect. 3), we model the
combined system as in Fig. 2. That is, work (modeled by the leftmost location)
takes 5 minutes and costs an extra 10 energy units per minute. The dot on the
outgoing transition of the work state marks a (transition-based) B¨uchi condition
which forces us to see the transition inﬁnitely often in order for the run to
be accepted. As a consequence, all accepting runs also visit the “work” state
indeﬁnitely often, consistent with the demand to send data once in a while. In
order to model the system within the constraints of our modeling formalism, we
must make two simplifying assumptions, both unrealistic but conservative:

– work occurs during earth shadow;
– work prolongs earth shadow time.

4

S. Dziadek, U. Fahrenberg, P. Schlehuber-Caissier

The reason for the second property is that the clock x is reset to 0 when entering
the work state; otherwise we would not be able to model that it lasts 5 minutes
without introducing a second clock. It is clear how further work modules may be
added in a similar way, each with their own accepting color.

We will come back to this example later and, in particular, argue that the
above assumptions are indeed conservative in the sense that any behavior admitted
in our model is also present in a more realistic model which we will introduce.

2 Energy B¨uchi Problems in Finite Weighted Automata

We now deﬁne energy B¨uchi problems in ﬁnite weighted automata and show how
they may be solved. The similar setting for weighted timed automata will be
introduced in Sect. 3.

Deﬁnition 1 (WBA). A weighted (transition-based, generalized) B¨uchi au-
tomaton (WBA) is a structure A = (M, S, s0, T ) consisting of a ﬁnite set of
colors M, a set of states S with initial state s0 ∈ S, and a set of transitions
T ⊆ S × 2M × R × S.

A transition t = (s, M, w, s(cid:48)) ∈ T in a WBA is thus annotated by a set of
colors M and a real weight w, denoted by s w−→M s(cid:48); to save ink, we may omit any
or all of w and M from transitions and M from WBAs. The automaton A is ﬁnite
if S and T ⊆ S × 2M × Z × S are ﬁnite (thus ﬁnite implies integer-weighted).

A run in a WBA is a ﬁnite or inﬁnite sequence ρ = s1 → s2 → · · · . We
write ﬁrst(ρ) = s1 for its starting state and, if ρ is ﬁnite, last(ρ) for its ﬁnal state.
Concatenation ρ1ρ2 of runs is the usual partial operation deﬁned if ρ1 is ﬁnite
and last(ρ1) = ﬁrst(ρ2). Also iteration ρn of ﬁnite runs is deﬁned as usual, for
ﬁrst(ρ) = last(ρ), and ρω = inj limn→∞ ρn denotes inﬁnite iteration.

For c, b ∈ N 3 and a run ρ = s1

w2−−→ · · · , the (c, b)-accumulated weights
of ρ are the elements of the ﬁnite or inﬁnite sequence weightsc↓b(ρ) = (e1, e2, . . . )
deﬁned by e1 = min(b, c) and ei+1 = min(b, ei + wi). Hence the transition weights
are accumulated, starting with c, but only up to the maximum bound b; increases
above b are discarded. We call c the initial credit and b the weak upper bound.

w1−−→ s2

Running example 2. In Fig. 1b, and choosing c = 360 and b = 750, we have
a single inﬁnite run ρ = 1 −350−−−→ 2 2200−−−→ 1 −350−−−→ 2 2200−−−→ 1 −350−−−→ · · · , with
weightsc↓b(ρ) = (360, 10, 750, 400, 750, . . . ).

A run ρ as above is said to be (c, b)-feasible if weightsc↓b(ρ)i ≥ 0 for all indices
i, that is, the accumulated weights of all preﬁxes are non-negative. (This is the
case for the example run above.)

An inﬁnite run ρ = s1 →M1 s2 →M2 · · · is B¨uchi accepted if all colors in M
are seen inﬁnitely often along ρ, that is, for all m ∈ M and any index i ∈ N,
there exists j > i such that m ∈ Mj.

We ﬁx a weak upper bound b ∈ N for the rest of the paper and write c-feasible

instead of (c, b)-feasible.

3 Natural numbers include 0.

Energy B¨uchi Problems

5

Deﬁnition 2. The energy B¨uchi problem for a ﬁnite WBA A and initial credit
c ∈ N is to ask whether there exists a B¨uchi accepted c-feasible run in A.

Energy problems for ﬁnite weighted automata without B¨uchi conditions, asking
for the existence of any c-feasible run, have been introduced in [7] and extended
to multiple weight dimensions in [16] where they are related to vector addition
systems and Petri nets. We extend them to (transition-based generalized) B¨uchi
conditions here but do not consider an extension to multiple weight dimensions.

Degeneralization As a ﬁrst step to solving energy problems for ﬁnite WBAs,
we show that the standard counting construction which transforms generalized
B¨uchi automata into simple B¨uchi automata with only one color, see for example
[20], also applies in our weighted setting. To see that, let A = (M, S, s0, T )
be a (generalized) WBA, write M = {m1, . . . , mk}, and deﬁne another WBA
¯A = ( ¯M, ¯S, ¯s0, ¯T ) as follows:

¯M = {ma}
¯T = (cid:8)((s, i), ∅, w, (s(cid:48), i)) (cid:12)

¯S = S × {1, . . . , k}
(cid:12) (s, M, w, s(cid:48)) ∈ T, mi /∈ M (cid:9)

¯s0 = (s0, 1)

∪ (cid:8)((s, i), ∅, w, (s(cid:48), i + 1)) (cid:12)
∪ (cid:8)((s, k), {ma}, w, (s(cid:48), 1)) (cid:12)

(cid:12) i (cid:54)= k, (s, M, w, s(cid:48)) ∈ T, mi ∈ M (cid:9)
(cid:12) (s, M, w, s(cid:48)) ∈ T, mk ∈ M (cid:9)

That is, we split the states of A into levels {1, . . . , k}. At level i, the same
transitions exist as in A, except those colored with mi; seeing such a transition
puts us into level i + 1, or 1 if i = k. In the latter case, the transition in ¯A is
colored by its only color ma. Intuitively, this preserves the language as we are
sure that all colors of the original automaton A have been seen:

Lemma 3. For any c ∈ N, A admits a B¨uchi accepted c-feasible run iﬀ ¯A does.

Reduction to lassos An inﬁnite run ρ in A is a lasso if ρ = γ1γω
2 for ﬁnite
runs γ1 and γ2. The following lemma shows that it suﬃces to search for lassos in
order to solve energy B¨uchi problems.

Lemma 4. For any c ∈ N, A admits a B¨uchi accepted c-feasible inﬁnite run iﬀ
it admits a B¨uchi accepted c-feasible lasso.

Hence our energy B¨uchi problem may be solved by searching for B¨uchi
accepted c-feasible lassos. We detail how to do this in Sect. 4, here we just sum
up the complexity result which we prove at the end of Sect. 4.

Theorem 5. Energy B¨uchi problems for ﬁnite WBA are decidable in polynomial
time.

6

S. Dziadek, U. Fahrenberg, P. Schlehuber-Caissier

3 Energy B¨uchi Problems for Weighted Timed Automata

We now extend our setting to weighted timed automata. Let X be a ﬁnite set of
clocks. We denote by Φ(X) the set of clock constraints ϕ on X, deﬁned by the
grammar ϕ ::= x (cid:46)(cid:47) k | ϕ1 ∧ ϕ2 with x ∈ X, k ∈ N, and (cid:46)(cid:47) ∈ {≤, <, ≥, >, =}.
A clock valuation on X is a function v : X → R≥0. The clock valuation v0
is given by v0(x) = 0 for all x ∈ X, and for v : X → R≥0, d ∈ R≥0, and
R : X → (N ∪ {⊥}), we deﬁne the delay v + d and reset v[R] by

(v + d)(x) = v(x) + d,

v[R](x) =

(cid:40)

v(x)
R(x)

if R(x) = ⊥,
otherwise.

Note that in v[R] we allow clocks to be reset to arbitrary non-negative integers
instead of only 0 which is assumed in most of the literature. It is known [24] that
this does not change expressivity, but it adds notational convenience. A clock
valuation v satisﬁes clock constraint ϕ, denoted v |= ϕ, if ϕ evaluates to true
with x replaced by v(x) for all x ∈ X.

Deﬁnition 6 (WTBA). A weighted timed (transition-based, generalized) B¨uchi
automaton (WTBA) is a structure A = (M, Q, q0, X, I, E, r) consisting of a
ﬁnite set of colors M, a ﬁnite set of locations Q with initial location q0 ∈ Q, a
ﬁnite set of clocks X, location invariants I : Q → Φ(X), a ﬁnite set of edges
E ⊆ Q × 2M × Φ(X) × (N ∪ {⊥})X × Q, and location weight-rates r : Q → Z.

As before, we may omit M from the signature and colors from edges if they
are not necessary in the context. Note that the edges carry no weights here,
which would correspond to discrete weight updates. In a WTBA, only locations
are weighted by a rate. Even without B¨uchi conditions, the approach laid out
here would not work for weighted edges. This was already noted in [7]; instead it
requires diﬀerent methods which are developed in [6] (see also [14, 15]). There,
one-clock weighted timed automata (with edge weights) are translated to ﬁnite
automata weighted with so-called energy functions instead of integers. We believe
that our extension to B¨uchi conditions should also work in this extended setting,
but leave the details to future work.

The semantics of a WTBA A as above is the (inﬁnite) WBA
(cid:12)
(cid:12) v |= I(q)} and s0 = (q0, v0). Transitions in T

= (M, S, s0, T )

A

(cid:75)

(cid:74)

given by S = {(q, v) ∈ Q × RX
≥0
are of the following two types:

– delays (q, v) w−→d

∅(q, v +d) for all (q, v) ∈ S and d ∈ R≥0 for which v +d(cid:48) |= I(q)

for all d(cid:48) ∈ [0, d], with w = r(q)d; 4

– switches (q, v) 0−→0

v(cid:48) = v[R] and v(cid:48) |= I(q(cid:48)).

M (q(cid:48), v(cid:48)) for all e = (q, M, g, R, q(cid:48)) ∈ E for which v |= g,

4 Here we annotate transitions with the time d which passes; we only need this to

exclude Zeno runs below and will otherwise omit the annotation.

0

x ≤ 35

−10

y ← 0

•

y = 5

y ← 0

•

y = 5

y ≤ 5

−10

(a)

x ≤ 35 ∧ y ≤ 5

−20

Energy B¨uchi Problems

7

x = 35 x ← 0

x = 55 x ← 0

x = 35 x ← 0

x = 55 x ← 0

(b)

x ≤ 55

+40

y ← 0

•

y = 5

x ≤ 55 ∧ y ≤ 5

+30

Fig. 3: Satellite example. (a) work module W ; (b) product B1 = A (cid:107) W

A

Each state in

corresponds to a tuple containing a location in A and a
clock valuation X → R≥0. This allows to keep track of the discrete state as well
as the evolution of the clocks. By abuse of notation, we will sometimes write
(q, v) ∈

instead of (q, v) ∈ S, for S as deﬁned above.

A

(cid:75)

(cid:74)

(cid:74)

(cid:75)

We may now pose energy B¨uchi problems also for WTBAs, but we wish to
exclude inﬁnite runs in which time is bounded, so-called Zeno runs. Formally
an inﬁnite run (q0, v0) →d1 (q1, v1) →d2 · · · is Zeno if (cid:80) di is ﬁnite: Zeno runs
admit inﬁnitely many steps in ﬁnite time and are hence considered unrealistic
from a modeling point of view [1, 21].

Deﬁnition 7. The energy B¨uchi problem for a WTBA A and initial credit
c ∈ N is to ask if there exists a B¨uchi accepted c-feasible non-Zeno run in
.

A
(cid:74)

(cid:75)

We continue our running example; but to do so properly, we need to introduce
0, Xi, Ii, Ei, ri), for i ∈ {1, 2}, be

products of WTBAs. Let Ai = (Mi, Qi, qi
WTBAs. Their product is the WTBA A1 (cid:107) A2 = (M, Q, q0, X, I, E, r) with

M = M1 ∪ M2,

Q = Q1 × Q2,

X = X1 ∪ X2,

I((q1, q2)) = I(q1) ∧ I(q2),
E = (cid:8)((q1, q2), M, g, R, (q(cid:48)

∪ (cid:8)((q1, q2), M, g, R, (q1, q(cid:48)

0, q2

q0 = (q1

0),
r((q1, q2)) = r(q1) + r(q2),
(cid:12) (q1, M, g, R, q(cid:48)
(cid:12) (q2, M, g, R, q(cid:48)

1) ∈ E1
2) ∈ E2

(cid:9)
(cid:9).

1, q2)) (cid:12)
2)) (cid:12)

Running example 3. Let A be the basic WTBA of Fig. 1a and A1 the combination
of A with the work module of Fig. 2. Now, instead of building A1 as we have
done, a principled way of constructing a model for the satellite-with-work-module
would be to ﬁrst model the work module W and then form the product A (cid:107) W .
We show such a work module and the resulting product B1 in Fig. 3.

As expected, W expresses that work takes 5 minutes and costs 10 energy units
per minute, and the B¨uchi condition enforces that work is executed inﬁnitely
often. The product B1 models the shadow-sun cycle together with the fact that
work may be executed at any time, and contrary to our “unrealistic” model A1
of Fig. 2, work does not prolong earth shadow time.

8

S. Dziadek, U. Fahrenberg, P. Schlehuber-Caissier

Now B1 has two clocks, and we will see below that our constructions can
handle only one. This is the reason for our “unrealistic” model A1, and we can
now state precisely in which sense it is conservative: if
admits a B¨uchi
(cid:74)
accepted c-feasible non-Zeno run, then so does
. For a proof of this fact, one
may be translated to an inﬁnite run ¯ρ in
notes that any inﬁnite run ρ in
by adjusting the clock valuation by 5 whenever the work module is visited.
B1
(cid:74)

B1

A1

A1

(cid:74)

(cid:75)

(cid:75)

(cid:74)

(cid:75)

(cid:75)

Bounding Clocks As a ﬁrst step to solve energy B¨uchi problems for WTBAs,
we show that we may assume that the clocks in any WTBA A are bounded above
by some N ∈ N, i.e., such that v(x) ≤ N for all (q, v) ∈
and x ∈ X. This is
shown for reachability in [3]; the following lemma extends it to B¨uchi acceptance.

A

(cid:75)

(cid:74)

Lemma 8. Let A = (M, Q, q0, X, I, E, r) be a WTBA and c ∈ N. Let N the
maximum constant appearing in any invariant I(q), for q ∈ Q, or in any guard g,
for (q, M, g, R, q(cid:48)) ∈ E. There is a WTBA ¯A = (M, Q, q0, X, ¯I, ¯E, r) such that

1. v(x) ≤ N + 2 for all x ∈ X and (q, v) ∈
2. there exists a c-feasible B¨uchi accepted run in

, and
A

(cid:74)

¯A
(cid:75)

iﬀ such exists in

.

¯A
(cid:75)
(cid:74)

(cid:74)

(cid:75)

Corner-point abstraction We now restrict to WTBAs with only one clock
and show how to translate these into ﬁnite untimed WBAs using the corner-point
abstraction. This abstraction may be deﬁned for any number of clocks, but it is
shown in [8] that the energy problem is undecidable for weighted timed automata
with four clocks or more; for two or three clocks the problem is open.

Let A = (M, Q, q0, X, I, E, r) be a WTBA with X = {x} a singleton. Using
Lemma 8 we may assume that x is bounded by some N ∈ N, i.e., such that
v(x) ≤ N for all (q, v) ∈

A

.

(cid:74)

(cid:75)

Let C be the set of all constants which occur in invariants I(q) or guards g
or resets R of edges (q, M, g, R, q(cid:48)) in A, and write C ∪ {N } = {a1, . . . , an+1}
with ordering 0 ≤ a1 < · · · < an+1. The corner-point regions [3, 23] of A are the
subsets {ai}, for i = 1, . . . , n + 1, [ai, ai+1[, and ]ai, ai+1], for i = 1, . . . , n, of
R≥0; that is, points, left-open, and right-open intervals on {a1, . . . , an+1}.

These are equivalent to clock constraints x = ai, ai ≤ x < ai+1, and ai <
x ≤ ai+1, respectively, deﬁning a notion of implication r ⇒ ϕ for r a corner-point
region and ϕ ∈ Φ({x}).

The corner-point abstraction of A is the ﬁnite WBA cpa(A) = (M ∪
{mz}, S, s0, T ), where mz /∈ M is a new color, S = {(q, r) | q ∈ Q, r corner-point
region of A, r ⇒ I(q)}, s0 = (q0, {0}), and transitions in T are of the following
types:

– delays (q, {ai}) 0−→∅ (q, [ai, ai+1[), (q, [ai, ai+1[) w−→{mz} (q, ]ai, ai+1]) with

w = r(q)(ai+1 − ai), and (q, ]ai, ai+1]) 0−→∅ (q, ai+1);

– switches (q, r) 0−→M (q(cid:48), r) for e = (q, M, g, (x (cid:55)→ ⊥), q(cid:48)) ∈ E with r ⇒ g and

(q, r) 0−→M (q(cid:48), {k}) for e = (q, M, g, (x (cid:55)→ k), q(cid:48)) ∈ E with r ⇒ g.

Energy B¨uchi Problems

9

{0}

[0, 35[

•
−350

]0, 35]

{35}

{0}

[0, 35[

1400
•

]0, 35]

{35}

[35, 55[

800
•

]35, 55]

{55}

Fig. 4: Corner-point abstraction of base module of Fig. 1a.

The new color mz is used to rule out Zeno runs, see [1] for a similar con-
struction: any B¨uchi accepted inﬁnite run in cpa(A) must have inﬁnitely many
time-increasing delay transitions (q, [ai, ai+1[) w−→{mz} (q, ]ai, ai+1]).
Theorem 9. Let A be a one-clock WTBA and c ∈ N.

1. If there is a non-Zeno B¨uchi accepted c-feasible run in

B¨uchi accepted c-feasible run in cpa(A).

, then there is a

A

(cid:75)

(cid:74)

2. If there is a B¨uchi accepted c-feasible run in cpa(A), then there is a non-Zeno

for any ε > 0.

B¨uchi accepted (c + ε)-feasible run in

A
(cid:74)
The so-called inﬁmum energy condition [7] in the second part above, replacing
c with c + ε, is necessary in the presence of strict constraints x < c or x > c in
A. The proof maps runs in A to runs in cpa(A) by pushing delays to endpoints
of corner-point regions, ignoring strictness of constraints, and this has to be
repaired by introducing the inﬁmum condition.

(cid:75)

Running example 4. We construct the corner-point abstraction of the base mod-
ule A of Fig. 1a. Its constants are {0, 35, 55}, yielding the following corner point
regions:

{0},

[0, 35[,

]0, 35],

{35},

[35, 55[,

]35, 55],

{55}

The corner-point abstraction of A now looks as in Fig. 4, with the states cor-
responding to the “shadow” location in the top row; the colored transitions
correspond to the ones in which time elapses. Note that this WBA is equivalent
to the one in Fig. 1b.

Using the corner-point abstraction, we may now solve energy B¨uchi problems
for one-clock WTBAs by translating them into ﬁnite WBAs and applying the
algorithms of Sect. 2 and the forthcoming Sect. 4.

4

Implementation

We now describe our algorithm to solve energy B¨uchi problems for ﬁnite WBA;
all of this has been implemented and is available at https://github.com/
PhilippSchlehuberCaissier/wspot.

We have seen in Sect. 2 that this problem is equivalent to the search for B¨uchi
2 consists of two parts,

accepted c-feasible lassos. By deﬁnition, a lasso ρ = γ1γω

10

S. Dziadek, U. Fahrenberg, P. Schlehuber-Caissier

E ← FindMaxE(G, G.initial state, c) // E : S → N, mapping states to energy
SCCs ← Couvreur(G)
// Find all SCCs
for all scc ∈ SCCs do

Algorithm 1 Algorithm to ﬁnd B¨uchi accepted lassos in WBA
Input: weak upper bound b
1: function B¨uchiEnergy(graph G, initial credit c)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:

GS , backedges ← degeneralize(scc)
for all t = src w−→ dst ∈ backedges do
E(cid:48) ← FindMaxE(GS , dst, E[dst])
e(cid:48) ← min(b, E(cid:48)[src] + w)
if E[dst] ≤ e(cid:48) then

E(cid:48)(cid:48) ← FindMaxE(GS , dst, e(cid:48))
if e(cid:48) ≤ min(b, E(cid:48)(cid:48)[src] + w) then

return ReportNoLoop()

return ReportLoop()

return ReportLoop()

else

// t.dst is in G and GS...
// ...(see Fig. 5b)

// Second iteration (see Fig. 5a)

the lasso preﬁx γ1 (possibly empty, only traversed once) and the lasso cycle γ2
(repeated indeﬁnitely). In order for ρ to be B¨uchi accepted and c-feasible, both
the preﬁx γ1 and the cycle γ2 must be c-feasible, however only the cycle needs to
be B¨uchi accepted.

Finding lassos The overall procedure to ﬁnd lassos is described in Alg. 1. It is
based on two steps. In step one we compute all energy-optimal paths starting at
the initial state of the automaton with initial credit c. This step is done on the
original WBA, and we do not take into account the colors. Optimal paths found
in this step will serve as lasso preﬁxes.

The second step is done individually for each B¨uchi accepting SCC. The
Couvreur algorithm ignores the weights, and we can use the version distributed
by Spot. We then degeneralize the accepting SCCs one by one, as described
in Sect. 2; recall that this creates one copy of the SCC, which we call a level,
per color. The ﬁrst level roots the degeneralization in the original automaton;
transitions leading back from the last to the ﬁrst level are called back-edges.
These back-edges play a crucial role as they are the only colored transitions in
the degeneralized SCC and represent the accepting transitions.

Hence any B¨uchi accepting cycle in the degeneralization needs to contain at
least one such back-edge, and we can therefore focus our attention on these. We
proceed to check for each back-edge whether we can embed it in a c-feasible cycle
within the degeneralized SCC. To this end, we compute the energy-optimal paths
starting at the destination of the current back-edge (by construction a state in
the ﬁrst level) with an initial credit corresponding to its maximal preﬁx energy
(as found in the ﬁrst step). By comparing the energy of the source state of the
back-edge e while taking into account its weight, one can determine whether
there exists a c-feasible cycle containing e. If this is the case, then we have found

Energy B¨uchi Problems

11

30

0

1,1

0

−10

•

−10

2,1

+1

−1

1,2

2,2

+1

0

−1

30

0

1

0

•
−10

+1

2

•
−1

(a) Original WBA

(b) Degeneralizing SCC {1, 2} with level 1 rooted
in the original WBA. Back-edges colored red.

Fig. 5: Left: WBA (also used in Example 10); right: degeneralization of one SCC
(states named originalstate, level).

a c-feasible lasso cycle, and by concatenating it with the preﬁx found in the
ﬁrst step, we can construct a lasso. Note that we might have to check the loop
a second time (using the energy level calculated in the ﬁrst iteration as initial
credit), see Example 10. If the answer is negative, we continue with the next
back-edge in the SCC or with the next SCC once all back-edges exhausted.

Example 10. Figure 5a shows an automaton where we have to compute maximal
energy levels twice (lines 11-14 in Alg. 1): with b = 30 and c = 0, the preﬁx
energy of state 1 is 30, while its optimal energy on the cycle is 20, despite it
being part of a energy-positive loop. Hence we cannot conclude that we have
found an accepting lasso after the ﬁrst iteration, but need to run the algorithm
once more with an initial credit of 20.

Finding energy optimal paths We now discuss how to ﬁnd energy optimal
paths. The problem is equivalent (but inverse) to ﬁnding shortest paths in
weighted graphs. This may be done using the well-known Bellman-Ford algorithm
[4, 18], which breaks with an error if it ﬁnds negative loops. In our inverted
problem, we are seeking to maximize energy, so positive loops are accepted and
even desired. To take into account this particularity, we modify the Bellman-Ford
algorithm to invert the weight handling and to be able to handle positive loops.
The modiﬁed Bellman-Ford algorithm is given in Alg. 2.

The standard algorithm computes shortest paths by relaxing the distance
approximation until the solution is found. One round relaxes all edges and the
algorithm makes as many rounds as there are nodes. Inverting the algorithm
is easy: the relaxation is done if the new weight is higher than the old weight;
additionally the new weight has to be higher than 0 and is bounded from above
by the weak upper bound.

The second modiﬁcation to Bellman-Ford is the handling of positive loops.
This part is a bit more involved, especially if one strives for an eﬃcient algorithm.
We could run Bellman-Ford until it reaches a ﬁxed point, however this can
signiﬁcantly impact performance as shown in the following example.

12

S. Dziadek, U. Fahrenberg, P. Schlehuber-Caissier

+1

0

−b

+1

1

−b

+1

2

−b

+1

3

−b

. . .

−b

+1
•

N

Fig. 6: WBA for Example 11

Example 11. Consider the automaton shown in Fig. 6. Here one round of Bellman-
Ford only increases the energy level by 1 at the rightmost state already reached
and possibly reaches the state to its right once the weak upper bound attained.
This means that we need to run (N + 1) · b rounds of Bellman-Ford to reach a
ﬁxed point. Ideally we would like the upper bound to have no inﬂuence on the
runtime. To this end we introduce the function PumpAll, which sets the energy
level of all states on positive loops detected by the last round of Bellman-Ford to
the achievable maximum. This way, instead of needing b rounds of Bellman-Ford
to attain the maximal energy, we only need one plus a call to PumpAll.

Before continuing, we make the following observation. This stage will be called
from Algorithm 1 that recognizes loops necessary to fulﬁll the B¨uchi condition.
Here, we only need to check reachability. Therefore, the only reason to form a loop
is to gain energy, implying that we are only interested in simple energy positive
loops, i.e., loops where every state appears at most once. If we set the optimal
reachable weight in simple loops, then nested loops are updated by Bellman-Ford
in the usual way afterwards.

To improve the runtime of our algorithm, we exploit that Bellman-Ford can
detect positive cycles and handle these cycles speciﬁcally. Note however that
contrary to a statement in [7], we cannot simply set all energy levels on a positive
loop to b: in the example of Fig. 5a, starting in state 2 with an initial credit of 10,
the energy level in state 1 will increase with every round of Bellman-Ford but
never above 20 = b − 10.

In order to have an algorithm whose complexity is independent of b, we instead

compute the ﬁxed point from above. We ﬁrst make the following observation.

Lemma 12. In energy positive loops, there exists at least one state on the loop
that can attain the maximal energy b.

Proof. Since the loop is energy positive we can increase the energy level at any
speciﬁc node by cycling through the loop. This can be repeated until a ﬁxed
point is reached. This ﬁxed point is only reached when at one of the states
the accumulated weight reaches b (or surpasses b but is restricted to b). As the
increase of energy with every cycle is a strictly monotone operation, the ﬁxed
(cid:117)(cid:116)
point will be reached and no alternation is possible.

If we knew the precise state that attains maximal energy, we could set its
energy to b and loop through the cycle once while propagating the energy, causing
every state on the loop to obtain its maximal energy. However, not knowing
which state will eﬀectively attain b, we start with any state on the loop, set

Energy B¨uchi Problems

13

Algorithm 2 Modiﬁed Bellman-Ford

Shared Variables: E, P

for n ∈ {1, . . . , |S|} do

Modiﬁed Bellman-Ford algorithm
1: function modBF(weighted graph G)
2:
3:
4:
5:
6:
7:

for all t = s w−→ s(cid:48) ∈ T do
e(cid:48) ← min(E(s) + w, b)
if E[s(cid:48)] < e(cid:48) and e(cid:48) ≥ 0 then

E[s(cid:48)] ← e(cid:48)
P [s(cid:48)] ← t // P : S → T , mapping states to best incoming transition

Helper function assigning the optimal energy to all states on the energy positive
loop containing state s

// Loop returns the states on the loop of s ...
// Special value to detect ﬁxed point

for all s(cid:48) ∈ Loop(s) do

E[s(cid:48)] ← −1
E[P [s].src] ← b
while (cid:62) do

8: function PumpLoop(weighted graph G, state s)
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:

Mark loop (and postﬁx) as done
return
E[t.dst] ← e(cid:48)

t ← P [s(cid:48)]
e(cid:48) ← min(b, E[t.src] + t.w)
if e(cid:48) = E[t.dst] then

for all s(cid:48) ∈ Loop(s) do

for all states s that changed their weight do

t = P [s]
if min(b, E[t.src] + t.w) > E[s] then

20: function PumpAll(weighted graph G)
21:
22:
23:
24:
25:
26:
27:
28:
29:

until s(cid:48) already marked
PumpLoop(G, s(cid:48))

s(cid:48).mark ← (cid:62)
s(cid:48) ← t.src

s(cid:48) ← s
repeat

Helper function, pumping all energy positive loops induced by P

// Loops at most twice
// ... in forward order

// ﬁxed point reached

// s can be either on the cycle or in a postﬁx of one
// Go through it backwards to ﬁnd a state on the cycle

// Pump it

Function computing the optimal energy for each state

Init(s0, c)
// initialize values in E to −∞ and E(s0) = c
while not f ixedpoint(E) do // Iteratively search for loops, then pump them

30: function FindMaxE(graph G, start state s0, initial credit c)
31:
32:
33:
34:
35:

modBF(G)
PumpAll(G)
return copyOf(E)

14

S. Dziadek, U. Fahrenberg, P. Schlehuber-Caissier

its energy to b and propagate the energy along the loop until a ﬁxed point is
reached. This is the case after traversing the loop at most twice. This is done by
the function PumpLoop.

Lemma 13. PumpLoop calculates the desired ﬁxed point after at most two
cycles through the loop.

Proof. In Alg. 2, lines 9 and 10 ensure that the ﬁxed point check in line 16
does not detect false positives. After setting an arbitrary state’s energy to b, the
algorithm cycles through the states in the loop in forward order.

w1−−→ s2

w2−−→ · · ·

Consider w.l.o.g. the positive cycle γ = s1

wN −1−−−−→ sN with
s1 = sN . By Lemma 12 we know that there exists at least one state sj with
0 ≤ j < N whose maximal energy equals b. Before the ﬁrst energy propagating
traversal of the cycle we set the energy of s1 to b. Two cases present themselves.
If j = 0, then energy is correctly propagated and we reach a ﬁxed point after one
traversal. In the second case, the energy attainable by s1 is strictly smaller than b.
Propagating from this energy level will over-approximate the energies reached by
the states s0 through sj−1 on the cycle, but only until state sj is reached which
actually attains b. As energy is bounded, the energy levels of state sj and its
successors sj+1, . . . , sN are correctly calculated. This means that after traversing
wj−1−−−→ sj, all energy levels on the
the cycle sj
cycle are correctly calculated and this is guaranteed to happen before traversing
the original cycle twice.

wN −1−−−−→ sN

wj−−→ · · ·

w2−−→ · · ·

w1−−→ s2

The corresponding ﬁxed point condition is detected by line 16 which will stop
the iteration. Note that we actually need to check for changes in the energy level
on line 16, and not whether some state attained energy b, as we at this point
(cid:117)(cid:116)
cannot know whether this energy was reached due to over-approximation.

Note that the pseudocode shown here is a simpliﬁcation, as our implementation
contains some further optimizations. Namely, we implement an early exit in
modBF if we detect that a ﬁxed point is reached, and we keep track of states
which have seen an update to their energy, as this allows to perform certain
operations selectively.

Algorithm Complexity We are now able to conclude our discussion from
Sect. 2 and show that energy B¨uchi problems for ﬁnite WBA are decidable in
polynomial time.

Proof (of Theorem 5). For our decision procedure, the search for strongly con-
nected components can be done in polynomial time. Our modiﬁed Bellman-Ford
algorithm also has polynomial complexity. It is called once at the beginning and
once for every back-edge of every strongly connected component. Given that the
number of such back-edges is bounded by the number of edges, we conclude that
(cid:117)(cid:116)
our overall algorithm has polynomial complexity.

Energy B¨uchi Problems

15

sol [s]
#mod #states to cpa [s]
0.00
0.01
0.02
0.03
0.24
0.06
3.24
0.19
59.52
0.89
1.87 261.38
4.37 1194.81

25
90
293
1012
3759
7377
14582

1
3
5
7
9
10
11

Table 1: Benchmark results. From left to
right: Number of work modules, Number of
states in cpa, time needed to compute cpa,
time needed to solve energy B¨uchi problem.
Benchmarks done on an ASUS G14, Ryzen
4800H CPU with 16Gb RAM.

s!

x ≤ 35

−10

x = 35
x ← 0, s!

x = 55
x ← 0, s!

x ≤ 55

+40

Fig. 7: Base circuit

x ← 0, s?

0

x = i

x ≤ i

−10

Fig. 8: Work module #i

5 Benchmarks

We employ our running example to build a scalable benchmark case. For modeling
convenience we use products of WTBAs as introduced above extended with
standard sender/receiver synchronization via channels. The additional labels s!
and s? are used for synchronization. Edges with s! can always be taken and emit
the signal s; edges with s? can only be taken if a signal s is currently emitted.
This modeling allows multiple work modules to start working at the same time.
As before, we use a base circuit with two states, see Fig. 7. Work module
#i, see Fig. 8, uses 10 energy units while working and spends exactly i time
units in the work state. We then combine these models with the speciﬁcation
that time must pass and that every work module is activated inﬁnitely often.
All the presented instances are schedulable. Table 1 presents the results of our
benchmark, showing that the presented approach scales fairly well. We note
that most of the time for solving the energy B¨uchi problem (last column) is
spent in our Python implementation of our modiﬁed Bellman-Ford algorithm.
In fact the total runtime is (at least for #mod ≥ 5) directly proportional to the
number of times lines 4 to 7 of ModBF in Alg. 2 are executed. Therefore, the
implementation could greatly beneﬁt from a direct integration into Spot and
using its C++ engine.

6 Conclusion

We have shown how to eﬃciently solve energy B¨uchi problems, both in ﬁnite
weighted (transition-based generalized) B¨uchi automata and in one-clock weighted
timed B¨uchi automata. We have implemented all our algorithms in a tool based on
TChecker and Spot. Solving the latter problem is done by using the corner-point
abstraction to translate the weighted timed B¨uchi automaton to a ﬁnite weighted

16

S. Dziadek, U. Fahrenberg, P. Schlehuber-Caissier

B¨uchi automaton; the former problem is handled by interleaving a modiﬁed
version of the Bellman-Ford algorithm with Couvreur’s algorithm.

Our tool is able to handle some interesting examples, but the restriction
to one-clock weighted timed B¨uchi automata without weights on edges does
impose some constraints on modeling. We believe that trying to lift the one-clock
restriction is unrealistic; but weighted edges (without B¨uchi conditions) have
been treated in [6], and we suspect that their approach should also be viable
here. (See [10] for a related approach.) In passing we should like to argue that, as
shown by our running example, the modeling constraints imposed by only having
one clock may be somewhat circumvented by careful modeling.

Also adopting our approach to the unlimited energy problem, without weak
upper bound, should not pose any problems. In fact, setting b = ∞ will facilitate
the algorithm, as maximal energy levels of nodes on positive loops can directly be
set to ∞ (making PumpLoop obsolete), and also the second iteration in Alg. 1
can be dropped.

Further, we strongly believe that our idea of investigating whether a back-edge
can be embedded in an energy positive cycle is not restricted to (generalized)
B¨uchi acceptance. In fact, the same methods should be applicable to, for example,
parity acceptance conditions without losing the polynomial runtime.

As a last remark, it is known that multiple clocks, multiple weight dimensions,
and even turning the weak upper bound into a strict one which may not be
exceeded, rapidly leads to undecidability results, see [7, 8, 16, 26], and we are
wondering whether some of these may be sharpened when using B¨uchi conditions.

Acknowledgments We are grateful to Alexandre Duret-Lutz, Nicolas Markey
and Ocan Sankur for fruitful discussions on the subjects of this paper.

References

1. Rajeev Alur and David L. Dill. A theory of timed automata. Theor. Comput. Sci.,

126(2):183–235, 1994.

2. Giovanni Bacci, Patricia Bouyer, Uli Fahrenberg, Kim G. Larsen, Nicolas Markey,
and Pierre-Alain Reynier. Optimal and robust controller synthesis using energy
timed automata with uncertainty. Formal Aspects Comput., 33(1):3–25, 2021.
3. Gerd Behrmann, Ansgar Fehnker, Thomas Hune, Kim G. Larsen, Paul Pettersson,
Judi Romijn, and Frits W. Vaandrager. Minimum-cost reachability for priced timed
automata. In Maria Domenica Di Benedetto and Alberto L. Sangiovanni-Vincentelli,
editors, HSCC, volume 2034 of Lect. Notes Comput. Sci., pages 147–161. Springer,
2001.

4. Richard Bellman. On a routing problem. Quart. Appl. Math., 16(1):87–90, 1958.
5. Morten Bisgaard, David Gerhardt, Holger Hermanns, Jan Krˇc´al, Gilles Nies, and
Marvin Stenger. Battery-aware scheduling in low orbit: The GomX-3 case. In
John S. Fitzgerald, Constance L. Heitmeyer, Stefania Gnesi, and Anna Philippou,
editors, FM, volume 9995 of Lect. Notes Comput. Sci., pages 559–576. Springer,
2016.

Energy B¨uchi Problems

17

6. Patricia Bouyer, Uli Fahrenberg, Kim G. Larsen, and Nicolas Markey. Timed
automata with observers under energy constraints. In Karl Henrik Johansson and
Wang Yi, editors, HSCC, pages 61–70. ACM, 2010.

7. Patricia Bouyer, Uli Fahrenberg, Kim G. Larsen, Nicolas Markey, and Jiˇr´ı Srba.
Inﬁnite runs in weighted timed automata with energy constraints. In Franck Cassez
and Claude Jard, editors, FORMATS, volume 5215 of Lect. Notes Comput. Sci.,
pages 33–47. Springer, 2008.

8. Patricia Bouyer, Kim G. Larsen, and Nicolas Markey. Lower-bound-constrained

runs in weighted timed automata. Perform. Eval., 73:91–109, 2014.

9. J. Richard B¨uchi. Symposium on decision problems: On a decision method in
restricted second order arithmetic. In Logic, Methodology and Philosophy of Science,
volume 44 of Studies in Logic and the Foundations of Mathematics, pages 1–11.
Elsevier, 1966.

10. David Cachera, Uli Fahrenberg, and Axel Legay. An ω-algebra for real-time energy

problems. Logical Meth. Comput. Sci., 15(2), 2019.

11. Krishnendu Chatterjee and Laurent Doyen. Energy parity games. Theor. Comput.

Sci., 458:49–60, 2012.

12. Krishnendu Chatterjee, Laurent Doyen, Thomas A. Henzinger, and Jean-Fran¸cois
Raskin. Generalized mean-payoﬀ and energy games. In Kamal Lodaya and Meena
Mahajan, editors, FSTTCS, volume 8 of LIPIcs, pages 505–516, 2010.

13. Alexandre Duret-Lutz, Alexandre Lewkowicz, Amaury Fauchille, Thibaud Michaud,
Etienne Renault, and Laurent Xu. Spot 2.0 - A framework for LTL and omega-
automata manipulation. In Cyrille Artho, Axel Legay, and Doron Peled, editors,
ATVA, volume 9938 of Lect. Notes Comput. Sci., pages 122–129. Springer, 2016.
14. Zolt´an ´Esik, Uli Fahrenberg, Axel Legay, and Karin Quaas. An algebraic approach
to energy problems I: ∗-Continuous Kleene ω-algebras. Acta Cyb., 23(1):203–228,
2017.

15. Zolt´an ´Esik, Uli Fahrenberg, Axel Legay, and Karin Quaas. An algebraic approach
to energy problems II: The algebra of energy functions. Acta Cyb., 23(1):229–268,
2017.

16. Uli Fahrenberg, Line Juhl, Kim G. Larsen, and Jiˇr´ı Srba. Energy games in
In Antonio Cerone and Pekka Pihlajasaari, editors,

multiweighted automata.
ICTAC, volume 6916 of Lect. Notes Comput. Sci., pages 95–115. Springer, 2011.

17. Heiko Falk, Kevin Hammond, Kim G. Larsen, Bj¨orn Lisper, and Stefan M. Petters.
Code-level timing analysis of embedded software.
In Ahmed Jerraya, Luca P.
Carloni, Florence Maraninchi, and John Regehr, editors, EMSOFT, pages 163–164.
ACM, 2012.

18. Lester R. Ford. Network Flow Theory. RAND Corporation, Santa Monica, CA,

1956.

19. Goran Frehse, Kim G. Larsen, Marius Mikuˇcionis, and Brian Nielsen. Monitoring
dynamical signals while testing timed aspects of a system. In Burkhart Wolﬀ
and Fatiha Za¨ıdi, editors, ICTSS, volume 7019 of Lect. Notes Comput. Sci., pages
115–130. Springer, 2011.

20. Paul Gastin and Denis Oddoux. Fast LTL to B¨uchi automata translation. In
G´erard Berry, Hubert Comon, and Alain Finkel, editors, CAV, volume 2102 of Lect.
Notes Comput. Sci., pages 53–65. Springer, 2001.

21. Fr´ed´eric Herbreteau and B. Srivathsan. Coarse abstractions make Zeno behaviours

diﬃcult to detect. Log. Methods Comput. Sci., 9(1), 2011.

22. Fr´ed´eric Herbreteau, B. Srivathsan, and Igor Walukiewicz. Better abstractions for

timed automata. Inf. Comput., 251:67–90, 2016.

18

S. Dziadek, U. Fahrenberg, P. Schlehuber-Caissier

23. Fran¸cois Laroussinie, Nicolas Markey, and Philippe Schnoebelen. Model check-
ing timed automata with one or two clocks. In Philippa Gardner and Nobuko
Yoshida, editors, CONCUR, volume 3170 of Lect. Notes Comput. Sci., pages 387–401.
Springer, 2004.

24. Kim G. Larsen, Paul Pettersson, and Wang Yi. Uppaal in a nutshell. Softw. Tools

Techn. Trans., 1(1-2):134–152, 1997.

25. Marius Mikuˇcionis, Kim G. Larsen, Jacob Illum Rasmussen, Brian Nielsen, Arne
Skou, Steen Ulrik Palm, Jan Storbank Pedersen, and Poul Hougaard. Schedulability
analysis using Uppaal: Herschel-Planck case study.
In Tiziana Margaria and
Bernhard Steﬀen, editors, ISoLA (2), volume 6416 of Lect. Notes Comput. Sci.,
pages 175–190. Springer, 2010.

26. Karin Quaas. On the interval-bound problem for weighted timed automata. In
Adrian Horia Dediu, Shunsuke Inenaga, and Carlos Mart´ın-Vide, editors, LATA,
volume 6638 of Lect. Notes Comput. Sci., pages 452–464. Springer, 2011.

27. Yaron Velner, Krishnendu Chatterjee, Laurent Doyen, Thomas A. Henzinger,
Alexander Moshe Rabinovich, and Jean-Fran¸cois Raskin. The complexity of multi-
mean-payoﬀ and multi-energy games. Inf. Comput., 241:177–196, 2015.

28. Pierre Wolper, Moshe Y. Vardi, and A. Prasad Sistla. Reasoning about inﬁnite
computation paths. In FOCS, pages 185–194. IEEE Computer Society, 1983.

