Fixed-point semantics for barebone relational concept
analysis
Jérôme Euzenat

To cite this version:

Jérôme Euzenat. Fixed-point semantics for barebone relational concept analysis. ICFCA - 16th inter-
national conference on formal concept analysis, Jul 2021, Strasbourg, France. pp.20-37, ￿10.1007/978-
3-030-77867-5_2￿. ￿hal-03426547￿

HAL Id: hal-03426547

https://hal.science/hal-03426547

Submitted on 12 Nov 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Fixed-point semantics for
barebone relational concept analysis(cid:63)

Jérôme Euzenat

Univ. Grenoble Alpes, Inria, CNRS, Grenoble INP, LIG, F-38000 Grenoble France
Jerome.Euzenat@inria.fr

Abstract. Relational concept analysis (RCA) extends formal concept analysis
(FCA) by taking into account binary relations between formal contexts. It has
been designed for inducing description logic TBoxes from ABoxes, but can be
used more generally. It is especially useful when there exist circular dependen-
cies between objects. In this case, it extracts a unique stable concept lattice family
grounded on the initial formal contexts. However, other stable families may exist
whose structure depends on the same relational context. These may be useful in
applications that need to extract a richer structure than the minimal grounded one.
This issue is ﬁrst illustrated in a reduced version of RCA, which only retains the
relational structure. We then redeﬁne the semantics of RCA on this reduced ver-
sion in terms of concept lattice families closed by a ﬁxed-point operation induced
by this relational structure. We show that these families admit a least and great-
est ﬁxed point and that the well-grounded RCA semantics is characterised by the
least ﬁxed point. We then study the structure of other ﬁxed points and characterise
the interesting lattices as the self-supported ﬁxed points.

1 Motivation

Formal concept analysis (FCA [7]) is a useful tool for inducing a classiﬁcation structure
from data. Relational concept analysis (RCA [13]) is one of its extensions allowing to
take advantage of relationships between objects to extract dependent concept lattices.
One of its strong point is its ability to deal with circular dependencies between objects.
Although the result returned by RCA is solid and useful, it may not be the only
possible result. The relational structure, when containing circuits, has the capability to
induce richer lattice structures. Indeed, in the absence of information or of reason to
separate objects, RCA classiﬁes them within the same concept. On the contrary, in the
absence of information or of reason to aggregate objects, it is possible to keep them
in different concepts. A good compromise may sometimes reside in between these two
extremes. As a data mining procedure, RCA can be useful in returning all possible
structures and not necessarily the safest ones.

This is not really a problem in the target RCA application: extracting the core classes
of a description logic ontology. However, this may be a problem for other applications.

(cid:63) in: Agnès Braud, Aleksey Buzmakov, Tom Hanika, Florence Le Ber (eds), Proc. 16th inter-
national conference on formal concept analysis (ICFCA), Strasbourg (FR), Lecture notes in
computer science 12733:20-37, 2021 doi:10.1007/978-3-030-77867-5_2

This work was initially motivated by one such application of RCA: We developed a
link key candidate extraction algorithm on top of relational concept analysis [2]. Link
keys are rules for identifying the same individuals from different data sources. In this
context, the concepts of extracted lattices are link key candidates which will be selected
on the basis of two independent measures [1]. As a data mining task, RCA is more
useful if it generates all the possible link key candidates.

Hereafter, we illustrate the considered problem on RCA0, a minimal version of
RCA. Although RCA0 is simply a convenient way to illustrate the problem it requires
solutions that will apply to RCA as a whole.

Understanding the nature of the problem and its relation with RCA lead to consider
its semantics. The current semantics of RCA [14] focusses on the grounding of the
process. We redeﬁne this semantics on properties directly characterising the solutions.
We ﬁrst consider the core function involved in the classical RCA algorithm and
identify acceptable results as the ﬁxed points of this function. We show, in the case of
RCA0, that the classical RCA semantics corresponds to extracting its least ﬁxed point.
We also provide a direct way to generate the greatest ﬁxed point. However, although
RCA extracts the minimal ﬁxed point in its simplest form, this is not the case of the
greatest ﬁxed point: it would make reference to non-existent concepts. Hence we discuss
the notion of self-supported concept lattice, so that the acceptable RCA results would
be self-supported ﬁxed points.

FCA is a domain of ﬁxed points, hence it is easy to get lost among the various
ﬁxed points involved: (a) In description logics, on which RCA relies, the semantics of
concepts is given by ﬁxed points when circularities occur [11]; (b) FCA’s goal is to
compute ﬁxed points: concepts are the result of a closure operator which is also a ﬁxed
point [4]; (c) ﬁnally, when confronted to cycles, the RCA concept lattice is the ﬁxed
point of the function that grows a lattice family from the previous one. The present
work is concerned with the latter kind of ﬁxed points.

In the remainder, we present the context as well as related work (§2). We illus-
trate the considered problem on a minimal example (§3). We then provide a ﬁxed-point
semantics for RCA based on a context-expansion function (§4) which allows to charac-
terise the classical RCA semantics. However, this semantics being not fully satisfactory,
we introduce the complementary notion of self-supported concept lattices (§5). We ﬁ-
nally discuss concrete processing issues (§6).

2 Preliminaries and related work

We mix preliminaries with related works for reasons of space, but also because the
paper directly builds on this related work.

2.1 Formal concept analysis

Formal Concept Analysis (FCA) [7] starts with a binary context (cid:104)G, M, I(cid:105) where G
denotes a set of objects, M a set of attributes, and I ⊆ G × M a binary relation between
G and M, called the incidence relation. The statement gIm is interpreted as “object g has

attribute m”. Two operators ·↑ and ·↓ deﬁne a Galois connection between the powersets
(cid:104)2G, ⊆(cid:105) and (cid:104)2M, ⊆(cid:105), with A ⊆ G and B ⊆ M:

A↑ = {m ∈ M | gIm for all g ∈ A}
B↓ = {g ∈ G | gIm for all m ∈ B}

The operators ·↑ and ·↓ are decreasing, i.e. if A1 ⊆ A2 then A↑

1 and if B1 ⊆ B2
then B↓
1. Intuitively, the less objects there are, the more attributes they share, and
dually, the less attributes there are, the more objects have these attributes. It can be
checked that A ⊆ A↑↓ and that B ⊆ B↓↑, that A↑ = A↑↓↑ and that B↓ = B↓↑↓.

2 ⊆ B↓

2 ⊆ A↑

For A ⊆ G, B ⊆ M, a pair (cid:104)A, B(cid:105), such that A↑ = B and B↓ = A, is called a formal
concept, where A is the extent and B the intent of (cid:104)A, B(cid:105). Moreover, for a formal concept
(cid:104)A, B(cid:105), A and B are closed sets for the closure operators ·↑↓ and ·↓↑, respectively, i.e.
A↑↓ = A and B↓↑ = B.

Concepts are partially ordered by (cid:104)A1, B1(cid:105) ≤ (cid:104)A2, B2(cid:105) ⇔ A1 ⊆ A2 or equivalently
B2 ⊆ B1. With respect to this partial order, the set of all formal concepts forms a com-
plete lattice called the concept lattice of (cid:104)G, M, I(cid:105).

Formal concept analysis can be considered as a function that associates to a formal
context (cid:104)G, M, I(cid:105) its concept lattice (cid:104)C, ≤(cid:105) = FCA((cid:104)G, M, I(cid:105)) (or B(G, M, I) [7]). By
abuse of language, when a variable L denotes a concept lattice (cid:104)C, ≤(cid:105), L will also be
used to denote C.

2.2 Extending FCA

Formal concept analysis is deﬁned on relatively simple structures hence many exten-
sions have been designed. They allow FCA to (a) deal with more complex input struc-
ture, and/or (b) generate more expressive and interpretable knowledge structures.

Scaling Scaling is one type of extension of type (a). A scaling operation ς : X (cid:55)→ 2D
generates boolean attributes named after a language D from a structure Σ ∈ X . In
FCA, D = M and I is provided by its matrix. In scaled contexts, this language can be
interpreted so that the incidence relation I is immediately derived from the attribute m
following:

gIm iff Σ |= m(g)

Hence, adding attributes to a context under such a structure may be performed as:

M(cid:48)((cid:104)G, M, I(cid:105)) = (cid:104)G, M ∪ M(cid:48), I ∪ {(cid:104)g, m(cid:105) ∈ G × M(cid:48) | Σ |= m(g)}(cid:105)
KΣ

Applying a scaling operation ς to a formal context K following a structure Σ can be
thus decomposed into (i) determining the set of attributes ς (Σ ) to add, and (ii) extending
the context with such attributes:

σς (K, Σ ) = KΣ

ς (Σ )(K)

Many conceptual scaling operations have been discussed in [7] for dealing with non
boolean variables in formal contexts. In general, Σ is void, D is expressed as predicates,

e.g. · = v for nominal scaling or · ≤ n for ordinal scaling, and |= is the evaluation of the
predicate for the value.

Logical scaling [12] has been introduced for more versatile languages such as de-
scription logics and SQL. It introduces query results within formal contexts. In this case,
Σ is a logical theory or database tables, D the set of formulas of the logic or instantiated
queries and |= is entailment or query evaluation.

Relational scaling operations considered in [13] are based on a struture Σ = (cid:104)R,C(cid:105)
made of a family of relations R = {ry}y∈Y , i.e. relations ry ⊆ Gx × Gz between two sets
of objects, and a family C = {Cx}x∈X of sets of concepts whose extent is a subset of Gx.
Its language Dς ,R,C is the set of attribute descriptions involving ς , R and C. For example,
qualiﬁed existential scaling (∃) adds attributes ∃r.c for r ∈ R, r ⊆ Gx × Gz, c ∈ Cz and
|= checks that

(cid:104)R, L(cid:105) |= gI∃r.c iff ∃g(cid:48); (cid:104)g, g(cid:48)(cid:105) ∈ r ∧ g(cid:48) ∈ extent(c)

Various relational scaling operations are used in RCA such as existential, strict and
wide universal, min and max cardinality, which all follow the classical role restriction
semantics of description logics [3].

Other extensions Pattern structures [6,9] provide a more structured attribute language
without scaling. However, its use is not directly related to the problem of context de-
pendencies considered here as the attributes do not refer to concepts.

On the contrary, other approaches [10,5] aim at extracting conceptual structures
from n-ary relations without resorting to scaling. Their concepts have intents that can
be thought of as conjunctive queries and extents as tuples of objects, i.e. answers to these
queries. Hence, instead of being classes, i.e. monadic predicates, concepts correspond
to general polyadic predicates. For that purpose, they rely on more expressive input, e.g.
in Graph-FCA [5] the incidence relation is a hypergraph between objects, and produce
a more expressive representation. A comparison of RCA and Graph-FCA is provided in
[8]. Graph-FCA adopts a different approach than RCA but should, in principle, suffer
from the same problem as the one illustrated here. However, intents would need to refer
to concepts so created, i.e. named subqueries. This remains to be studied.

2.3 Relational concept analysis

Relational Concept Analysis (RCA) [13] extends FCA to the processing of relational
datasets and allows inter-object relations to be materialised and incorporated into formal
concept intents. RCA is a way to induce a description logic TBox from a simple ABox
[3], using speciﬁc scaling operations. It may also be though of as a general way to deal
with circular references using different scaling operations.

RCA applies to a relational context (cid:104)K0, R(cid:105), composed of a set of formal con-
texts K0 = {(cid:104)Gx, M0
x (cid:105)}x∈X and a set of binary relations R = {ry}y∈Y . A relation
ry ⊆ Gx × Gz connects two object sets, a domain Gx (dom(ry) = Gx, x ∈ X) and a range
Gz (ran(ry) = Gz, z ∈ X).

x , I0

RCA applies relational scaling operations from a set Ω to each Ki
relations ry ⊆ Gx × Gz from the set of concepts in corresponding Lz = FCA(Ki

x ∈ Ki and all
z).

For performing its operations, RCA thus relies on FCA and σς . More precisely it

uses FCA∗ and σ ∗

Ω deﬁned as:

FCA∗({(cid:104)Gx, Mx, Ix(cid:105)}x∈X ) = {FCA((cid:104)Gx, Mx, Ix(cid:105))}x∈X

σ ∗
Ω ({(cid:104)Gx, Mx, Ix(cid:105)}x∈X , R, {Lx}x∈X ) =




ς ∈Ω
(cid:77)



ry∈R | r⊆Gx×Gz

σς ((cid:104)Gx, Mx, Ix(cid:105), ry, Lz)






x∈X

such that ⊕ς ∈Ω
ry∈R | r⊆Gx×Gz
relations starting from x (to any z).

scales, with all operations in Ω , the given context with all the

RCA starts from the initial formal context family K0 and thus iterates the application

of the two operations:

Ki+1 = σ ∗

Ω (Ki, R, FCA∗(Ki))

until reaching closure, i.e. reaching n such that Kn+1 = Kn. Then, RCAΩ (K0, R) =
FCA∗(Kn).

By abuse of notation, we note (cid:104)G, M, I(cid:105) ⊆ (cid:104)G, M(cid:48), I(cid:48)(cid:105) whenever M ⊆ M(cid:48) and I =
I(cid:48) ∩ (G × M). In this case, because I is the incidence relation between the same G and
M ⊆ M(cid:48), the relation only depends on M and M(cid:48). This is generalised to formal context
families {(cid:104)Gx, Mx, Ix(cid:105)}x∈X ⊆ {(cid:104)Gx, M(cid:48)

x(cid:105)}x∈X whenever ∀x ∈ X, Mx ⊆ M(cid:48)
x.

x, I(cid:48)

The RCA process always reaches a closed formal context family for reason of ﬁnite-
ness [13] and the sequence (Ki)n
i=0 is non-contracting, i.e. ∀i ≥ 0, Ki ⊆ Ki+1 [14].
The well-grounded semantics of RCA [14] further establishes that RCA indeed ﬁnds
the Kn satisfying these constraints through correctness (the concepts of FCA∗(Kn) are
grounded in K0 through R) and completess (all such concepts are in Kn).

2.4 RCA0

To keep the paper short and simple, we restrict it to RCA0, a special case of RCA. It is
restricted in two ways:

– It contains only one formal context (|X| = 1),
– which has no attributes (M0

x = ∅).

Additionally, we will consider below only qualiﬁed existential scaling (Ω = {∃}).

Because RCA0 is a restriction of RCA, we will use the same notation as deﬁned

above, thought it operates on simpler structures.

Although RCA0 seems very simple, FCA can be encoded into RCA0. Introducing

RCA0 is sufﬁcient to hint at the problem that we want to illustrate1.

3 RCA may accept different concept lattice families: illustration

As an RCA0 example, consider the following ABox:

1 An anonymous reviewer complements the remarks of §2.2 noting that RCA0 is also very re-

lated to Graph-FCA as they both have only one context and using existential scaling.

A = {(cid:62)(a), (cid:62)(b), (cid:62)(c), (cid:62)(d), p(a, b), p(b, a), p(c, d), p(d, c), p(a, a), p(b, b)}
This can be encoded as an empty formal context and the relation of Figure 1 (left).
The empty context will generate the single lattice of Figure 1 (right) (names are assigned
to concepts according to their extent).

p a b c d
a × ×
b × ×
c
d

×

×

L0:

ABCD

a, b, c, d

Fig. 1. Relation (left) and initial concept lattice (right).

Scaling with ∃ and p provides the attribute ∃p.ABCD which generates the new con-
text of Figure 2 (left), leading to the lattice of Figure 2 (right) which is the one returned
by RCA.

∃p.ABCD
×
×
×
×

a
c
b
d

L1:

∃p.ABCD

a, b, c, d

ABCD

Fig. 2. Scaled context (left) and ﬁnal concept lattice L1 (right).

However, the concept lattices of Figure 3 are other valid lattices worth considering.

∃p.ABCD

ABCD

AB

∃p.AB

a, b

CD

∃p.CD

c, d

⊥

L2:

∃p.ABCD

ABCD

ABC

∃p.ABD

ABD

∃p.ABC

∃p.CD

CD

∃p.D

c

D

∃p.C

d

AB

∃p.AB

a, b

L3:

C

⊥

Fig. 3. Alternative concept lattices (L2 and L3).

They correspond to different knowledge bases:

T1 = {ABCD (cid:118) ∃p.ABCD}
A1 = {ABCD(a), ABCD(b), ABCD(c), ABCD(d),

p(a, b), p(b, a), p(c, d), p(d, c), p(a, a), p(b, b)}

and

T2 = {AB (cid:118) (cid:62) (cid:117) ∃p.AB,CD (cid:118) (cid:62) (cid:117) ∃p.CD, ABCD (cid:118) ∃p.ABCD}
A2 = {AB(a), AB(b),CD(c),CD(d), p(a, b), p(b, a), p(c, d), p(d, c), p(a, a), p(b, b)}

and

T3 = {AB (cid:118) ABC (cid:117) ABD (cid:117) ∃p.AB,C (cid:118) ABC (cid:117)CD (cid:117) ∃p.D, D (cid:118) ABD (cid:117)CD (cid:117) ∃p.C,
ABC (cid:118) ABCD (cid:117) ∃p.ABD, ABD (cid:118) ABCD (cid:117) ∃p.ABC,CD (cid:118) ABCD (cid:117) ∃p.CD,
ABCD (cid:118) ∃p.ABCD}

A3 = {AB(a), AB(b),C(c), D(d), p(a, b), p(b, a), p(c, d), p(d, c), p(a, a), p(b, b)}

In addition to extracting the TBox, these extend the ABox. However, in RCA and FCA,
objects are also assigned to the created concepts. In this case, this assignment has con-
sequences on the scaled attributes taken into account and hence the resulting lattice.

As in classical RCA, each concept of these lattices is closed with respect to the
speciﬁc formal context scaled by ∃ and p from the concepts of the lattice. Moreover, the
lattices are self-supported in the sense that their attributes refer only to their concepts.
The problem applies to RCA as a whole as RCA0 is included in RCA. Hence the
question: Why does RCA returns only one lattice, and which one? Answering it requires
to reconsider the RCA semantics.

4 Semantics and properties: a context approach

The alternative lattices presented in Section 3 are legitimate because, independently
of the attributes, they rely exclusively on the structure of the relations between formal
contexts. This structure is already used in the well-grounded RCA semantics, but they
have not been fully exploited.

The answer will require to further deﬁne ‘legitimate’, in terms of ﬁxed points of a
speciﬁc function, and characterise the semantics of RCA as indeed grounded, in terms
of these ﬁxed points.

4.1 The lattice K of RCA0 contexts

We ﬁrst deﬁne the space of formal context families considered by RCA. They are deter-
mined by three elements given once and for all: K0 = {(cid:104)G, M0, I0(cid:105)}x∈X , R = {ry}y∈Y ,
and Ω . This is even more speciﬁc for RCA0 with K0 = (cid:104)G, ∅, ∅(cid:105) and Ω = {ς∃}, but
for most of this section we will ignore it.

The contexts considered by RCA are formal context families obtained by the scaled
initial context using the scaling operations. Given a ﬁnite set of objects G, the set of
concepts that can be created from such contexts is ﬁnite and moreover each concept can
be identiﬁed by its extent. Hence, we will consider that this induces a set of concept
names N(G) = 2G valid for any such concept lattice; the extent of a so named concept
will be the set of objects in its name. Given a ﬁnite set of relations R and scaling op-
erations Ω , this determines the ﬁnite set DΩ ,R,N(G) = (cid:83)ς ∈Ω
r∈R Dς ,r,N(G) of possible scaled
attributes in RCA0.

Hence, the formal contexts considered by RCA are those obtained by adding subsets

of DΩ ,R,N(G):

K

(cid:104)G,M0,I0(cid:105),R,Ω = {K(cid:104)R,N(G)(cid:105)

M

((cid:104)G, M0, I0(cid:105)) | M ⊆ DΩ ,R,N(G)}

with K(cid:104)R,N(G)(cid:105)
M

(.) the operation deﬁned in §2.2.

Given K, K(cid:48) ∈ K

(cid:104)G,M0,I0(cid:105),R,Ω such that K = (cid:104)G, M0 ∪ M, I0 ∪ I(cid:105) and K(cid:48) = (cid:104)G, M0 ∪

M(cid:48), I0 ∪ I(cid:48)(cid:105), K ∨ K(cid:48) and K ∧ K(cid:48) are deﬁned as:

K ∨ K(cid:48) = (cid:104)G, M0 ∪ (M ∪ M(cid:48)), I0 ∪ (I ∪ I(cid:48))
K ∧ K(cid:48) = (cid:104)G, M0 ∪ (M ∩ M(cid:48)), I0 ∪ (I ∩ I(cid:48))

(join)

(meet)

It is clear that K
Property 1. (cid:104)K

K0,R,Ω is closed by meet and join.
K0,R,Ω , ∨, ∧(cid:105) is a complete lattice

Proof. ∨ and ∧ satisfy commutativity, associativity and the absorption laws directly
from the union and intersection on sets, so this is a lattice. It is complete because ﬁnite.

Property 2. ∀K, K(cid:48) ∈ K

K0,R,Ω , K ⊆ K(cid:48) iff K = K ∧ K(cid:48)

Proof. This property also comes directly from its set theoretic counterpart application
to M and M(cid:48): K ⊆ K(cid:48) ⇔ M ⊆ M(cid:48) ⇔ M = M ∩ M(cid:48) ⇔ K = K ∧ K(cid:48)

4.2 The context expansion function F

We reformulate RCA as based on a main single function, FK0,R,Ω , the context expansion
function attached to a relational context (cid:104)K0, R(cid:105) and a set Ω of scaling operations.

Deﬁnition 1 (Context expansion function). Given a relational context (cid:104)K0, R(cid:105) and a
set of relational scaling operations Ω , the function FK0,R,Ω : K
K0,R,Ω is
deﬁned by:

K0,R,Ω (cid:55)→ K

FK0,R,Ω (K) = σ ∗

Ω (K, R, FCA∗(K)))

The function expression is independent from K0, K0 is used to restrict the domain
of the function so that its elements cover K0. From now on, we will abbreviate K
K0,R,Ω
as K and FK0,R,Ω as F. This is legitimate because, for a given relational context, K0, R
and Ω do not change. F is an extensive and monotone internal operation for K :
Property 3. ∀K ∈ K , F(K) ∈ K

Proof. Scaling only adds attributes from DΩ ,R,N(G).

Property 4 (F is extensive and monotone). The function F attached to a relational con-
text and a set of scaling operator satisﬁes:

K ⊆ F(K)

K ⊆ K(cid:48) ⇒ F(K) ⊆ F(K(cid:48))

(extensivity)

(monotony)

Proof. extensivity holds because F eventually adds to each formal context in K new
attributes scaled from FCA(K). The set of attributes can thus not be smaller. monotony
holds because K ⊆ K(cid:48) means that M ⊆ M(cid:48). This entails that the set of concepts of
FCA(K) is included in that of FCA(K(cid:48)), hence the set of attributes A scaled from
K is included in the set A(cid:48) scaled from K(cid:48). Since, they are added to M and M(cid:48), then
M ∪ A ⊆ M(cid:48) ∪ A(cid:48), hence F(K) ⊆ F(K(cid:48)).

Extensivity corresponds to the non-contracting property of the well-grounded se-

mantics [14] and monotony is also called order-preservation.

4.3 Fixed points of F

Given F, it is possible to deﬁne its sets of ﬁxed points, i.e. the sets of formal contexts
closed for F, as:

Deﬁnition 2 (ﬁxed point). A formal context K ∈ K is a ﬁxed point for a context ex-
pansion function F, if F(K) = K. We call fp(F) the set of ﬁxed points for F.

Since K is a complete lattice and F is order-preserving (or monotone) on K , then

the Knaster-Tarski theorem applies:

Theorem 1 (Knaster-Tarski theorem [15]). Let K be a complete lattice and let F :
K (cid:55)→ K be an order-preserving function. Then the set of ﬁxed points of F in L is also
a complete lattice.

In particular, this warrants that there exists least and greatest ﬁxed points of F in K

(called lfp(F) and gfp(F)).

In FCA, and subsequently in RCA without circular dependencies, the images by
FCA∗ of all ﬁxed points of F are isomorphic. They will have the same concept lattice as
seen from their intent. Even with RCA and circular dependencies (between the objects
or between the contexts), this is often the case. These are these concept lattices that
the RCA algorithm computes. But the example of Section 3 shows that, even in RCA0,
there may be several ﬁxed points for F with non isomorphic lattices. Hence the question:
which ﬁxed point is returned by RCA’s well-grounded semantics [14]?

4.4 The well-grounded semantics of RCA is the least ﬁxed-point semantics

RCA may be redeﬁned as

RCAΩ (K0, R) = FCA∗(F ∞(K0))

RCA iterates F from K0 until closure, and ultimately applies FCA∗. Since K0 belongs
to K , then it computes a ﬁxed point of F. This is the least ﬁxed point.

Proposition 1 (The RCA algorithm computes the least ﬁxed point). Given F the
context expansion function associated to K0, R and Ω ,

RCAΩ (K0, R) = FCA∗(lfp(FK0,R,Ω ))

Proof. RCAΩ (K0, R) = FCA∗(F n(K0)) for some n at which F(F n(K0)) = F n(K0) [13].
Let K∞ = F n(K0), K∞ ∈ fp(F) (Deﬁnition 2). ∀K ∈ fp(F), K ∈ K , thus K0 ⊆ K because
all the contexts in K contain M0. By monotony (Property 4), K∞ = F n(K0) ⊆ F n(K) =
K, because K is a ﬁxed point. Thus, K∞ is a ﬁxed point more speciﬁc than all ﬁxed
points: it is the least ﬁxed point.

4.5 Computing the greatest ﬁxed point

A natural question is how to obtain the greatest ﬁxed point. In fact, under this approach
this is (theoretically) surprisingly easy.

Proposition 2. gfp(F(cid:104)G,M0,I0(cid:105),R,Ω ) = K(cid:104)R,N(G)(cid:105)
DΩ ,R,N(G)

((cid:104)G, M0, I0(cid:105))

Proof. This context is the greatest element of K as it contains all attributes of DΩ ,R,N(G).
It is also a ﬁxed point because F is extensive and internal.

The lattice corresponding to the greatest ﬁxed point will be L = FCA∗(gfp(FK0,R,Ω )).
This result is easy but very uncomfortable. The obtained lattice may contain many
useless attributes. Indeed, ∃r.c is well deﬁned by the incidence relation, but it is of no
use to RCA if c does not belong to L.

In the example of Section 3, the attribute ∃p.A belongs to DΩ ,R,N(G) though A does
not belong to the maximal lattice L3, because it is not closed. The fact that both a and b
satisfy this attribute makes that it will ﬁnd its place in the intent of AB. If one considers
the lattice in isolation, this is perfectly valid because the scaled context is well-deﬁned:
∃p.A is just an attribute among others satisﬁed by a and b. However, if the lattice is
transformed in a description logic TBox, this is not correct to refer to an undeﬁned
class. This is not the result that we expected: we need the results to be self-supported.

This problem is even more embarrassing if one wants to enumerate all ﬁxed points,
which are as many solutions to the RCA problem: many of these will feature such non-
supported attributes.

5 Self-supported ﬁxed points

We ﬁrst quickly approach this problem from the concept lattice standpoint, it is better
understood with both contexts and lattices together2. We then deﬁne self-supported
concept lattices and consider their interaction with ﬁxed points.

5.1 The lattice L of RCA0 lattices and the lattice expansion function E

K0,R,Ω , one can deﬁne L

From K
K0,R,Ω by FCA.
These are concept lattices obtained by applying FCA on K0 extended with a subset of
DΩ ,R,N(G):

K0,R,Ω as the ﬁnite set of images of K

L

(cid:104)G,M0,I0(cid:105),R,Ω = {FCA((cid:104)G, M0 ∪ M, I0 ∪ I(cid:105)) | M ⊆ DΩ ,R,N(G)}

We deﬁne a speciﬁc type of homomorphisms between two concept lattices when con-
cepts are simply mapped into concepts with the same extent and possibly increased
intent.

2 Instead of developing both K and L independently and maintaining an equivalence between
them, it would have been possible to use a more FCA-like structure associating the correspond-
ing contexts and lattices.

K

K(cid:48)
F

K

FCA∗

σ ∗

FCA∗

κ

L(cid:48)= FCA(K(cid:48))
L

E

L= FCA(K)

Fig. 4. Relations between F and E through the alternation of FCA∗ and σ ∗
Ω .

Deﬁnition 3 (Lattice homomorphism). A concept lattice homomorphism h : (cid:104)C, ≤(cid:105) (cid:55)→
(cid:104)C(cid:48), ≤(cid:48)(cid:105) is a function which maps each concept c ∈ C into a corresponding concept
h(c) ∈ C(cid:48) such that:

– ∀c ∈ C, intent(c) ⊆ intent(h(c)), and
– ∀c ∈ C, extent(c) = extent(h(c)), and
– ∀c, d ∈ C, c ≤ d ⇒ h(c) ≤(cid:48) h(d).

We note L (cid:22) L(cid:48) if there exists a homomorphism from L to L(cid:48). In principle, L (cid:39) L(cid:48) if
L (cid:22) L(cid:48) and L(cid:48) (cid:22) L, but here, (cid:39) is =. The order between concept lattices is straigthfor-
wardly extended to families of concept lattices such that: {Lx}x∈X (cid:22) {L(cid:48)
x}x∈X iff ∀x ∈ X,
Lx (cid:22) L(cid:48)
x.

There exists an implicit function κ : L

K0,R,Ω ,
L = FCA(κ(L)). Since (cid:39) is the same as = which identiﬁes lattices containing concept
having exactly the same intent and extent. κ(L) can be induced by collecting the at-
tributes present in L intents to build the unique M, from which the corresponding I is
obtained [7].

K0,R,Ω such that ∀L ∈ L

K0,R,Ω (cid:55)→ K

We deﬁne EK0,R,Ω , the lattice expansion function attached to a relational context

(cid:104)K0, R(cid:105) and a set Ω of scaling operators.

Deﬁnition 4 (Lattice expansion function). Given a relational context (cid:104)K0, R(cid:105) and a
set of relational scaling operations Ω the function EK0,R,Ω : L
K0,R,Ω is
deﬁned by:

K0,R,Ω (cid:55)→ L

EK0,R,Ω (L) = FCA∗(σ ∗

Ω (κ(L), R, L))

Here again, K0 is only used to constrain the domain of the function, not its expres-

sion. From now on, we will abbreviate L

K0,R,Ω as L and EK0,R,Ω as E.

Instead of considering that RCA(K0) = FCA∗(F ∞(K0)), it is possible to consider

that RCA(K0) = E∞(FCA∗(K0)). Hence, RCA may be redeﬁned as

RCAΩ (K0, R) = E∞(FCA∗(K0))

RCA iterates E from FCA∗(K0) until closure. The deﬁnition of E amounts to ﬁrst scal-
ing and then applying FCA, though F does the opposite (see Figure 4).

In consequence, E is the function corresponding to F in the sense that E = FCA ◦
F ◦ κ and FCA∗ ◦ E = F ◦ FCA∗ (see Figure 4). Actually, the results obtained for K
and F, hold exactly for L and E:

– (cid:104)L , (cid:22)(cid:105) is a complete lattice;
– E is an internal, monotone and extensive operation of L ;
– RCAΩ (K0, R) = lfp(EK0,R,Ω ).

E inherits exactly all properties of F: the desirable ones and the problematic ones.

So, apparently no progress has been made.

5.2 Self-supported lattices

The problem is that both F and E are extensive functions. Hence, it is possible, starting
from anywhere in K or L , to consider attributes that do not refer to concepts and
these attributes will be preserved. As a consequence, there are ﬁxed points with these
unwanted attributes and they are also found in the greatest ﬁxed point.

One may consider identifying such attributes from the greatest ﬁxed point and for-
bidding them. However, these meaningless attributes are contextual: one supported at-
tribute in the greatest ﬁxed point, may be non supported in a smaller lattice. This is a
base difﬁculty for enumerating these ﬁxed points.

Instead, we consider only self-supported lattices, i.e. lattices whose intents only

refer to their own concepts.

Deﬁnition 5 (Self-supported lattices). Let L a set of concept lattices, its set of self-
supported lattices is

S(L ) = {L ∈ L

K0,R,Ω | ∀c ∈ L, intent(c) ⊆ DΩ ,R,L}

The set of interesting lattices that may be returned by RCA0 can be circumbscribed
as fp(E) ∩ S(L ) as these are stable and self-supported. Moreover, by construction of
K and L , they cover K0.

E has the advantage of preserving self-supportivity.

Proposition 3 (E is internal to S(L )). ∀L ∈ S(L ), E(L) ∈ S(L ).

Proof. If L ∈ S(L ), all attributes in intents of L are supported by concepts in L. E =
FCA∗ ◦ σ ∗
Ω ﬁrst adds to κ(L) attributes which are supported by L. L (cid:22) E(L), so
these concepts are still in E(L). Hence, the attributes in κ(L) and those scaled by σ ∗
Ω
are still supported by E(L).

Ω . σ ∗

But the deﬁnition of S does not provide a direct way to transform a non self-
supported lattice into a self-supported one: the suppression of non self-supported at-
tributes from intents could result in non-concepts (with non closed-extent). One possi-
ble way to solve this problem consists of extracting only the attributes currently in the
lattice and to apply FCA∗ to the resulting context.

For that purpose, we introduce a ﬁltering function π : L (cid:55)→ K which suppresses

from the induced context (κ(L)) those attributes non supported by the lattice:

π(L) = (cid:104)G, M \ DΩ ,R,N(G)\L, I \ {(cid:104)g, m(cid:105) | m ∈ DΩ ,R,N(G)\L}(cid:105)

such that κ(L) = (cid:104)G, M, I(cid:105).

K

K(cid:48)
P

K

κ
FCA∗

π

FCA∗

L(cid:48)= FCA(K(cid:48))
L

Q

L= FCA(K)

Fig. 5. Relations between P and Q through the alternation of FCA∗ and π.

One can deﬁne Q : L (cid:55)→ L , such that

Q(L) = FCA∗(π(L))

or P : K (cid:55)→ K , such that P(K) = π(FCA∗(K)), see Figure 5.

Contrary to E, Q is anti-extensive and monotone:

Proposition 4 (Q is anti-extensive and monotone). The function Q satisﬁes:

Q(L) (cid:22) L
L (cid:22) L(cid:48) ⇒ Q(L) (cid:22) Q(L(cid:48))

(anti-extensivity)
(monotony)

Proof. anti-extensivity π(L) ⊆ κ(L) because π simply suppresses attributes from κ(L).
Hence, FCA∗(π(L)) (cid:22) FCA∗(κ(L)) because the latter contain all concepts of the
former (identiﬁed by extent) eventually featuring the removed attributes. Moreover,
FCA∗(κ(L)) = L by deﬁnition, thus Q(L) = FCA∗(π(L)) (cid:22) FCA∗(κ(L)) = L.
monotony If L (cid:22) L(cid:48), then κ(L) ⊆ κ(L(cid:48)), otherwise FCA∗ would not generate a smaller
lattice. In addition, L (cid:22) L(cid:48) entails N(G) \ L ⊇ N(G) \ L(cid:48) which entails DΩ ,R,N(G)\L ⊇
DΩ ,R,N(G)\L(cid:48), which ﬁnally together leads to M \ DΩ ,R,N(G)\L ⊆ M(cid:48) \ DΩ ,R,N(G)\L(cid:48).
Then, π(L) ⊆ π(L(cid:48)) because a smaller context supported by a smaller lattice cannot
result in a larger context. Hence, Q(L) = FCA∗(π(L)) (cid:22) FCA∗(π(L(cid:48))) = Q(L(cid:48)).

It would be possible to redeﬁne S(L ) as fp(Q). Like with E, it is possible to apply

the Knaster-Tarski theorem to show that (cid:104)fp(Q), (cid:22)(cid:105) is a complete lattice.

But like E, Q is not a closure operator as it is not idempotent. However, with the
same arguments as [13], it can be argued that the repeated application of Q converges
to a self-supported concept lattice.

Proposition 5. ∀L ∈ L , ∃n; Qn(L) = Qn+1(L) and Qn(L) ∈ S(L ).

Proof. First, L is a ﬁnite concept lattice. Moreover, Q(L) (cid:22) L, hence it not possible to
build an inﬁnite chain of non converging application of Q since at each iteration, either
π suppresses no attribute (and then closure has been reached), or it suppresses at least
one attribute and then a strictly smaller context is reached. Ultimately, the least ﬁxed
point lfp(Q) = FCA∗(K0) is reached. It is a ﬁxed point because κ(FCA∗(K0)) = K0
contains no scaled attribute and thus is self-supported. When closure is reached, this is
because π does not ﬁnd any non-supported attribute in the lattice intents. This means
that all of them are supported by the lattice.

gfp(F)

P∞

fp(F)

lfp(F)

S(K )

K

F ∞

K0

FCA∗

σ ∗
Ω
FCA∗

σ ∗
Ω /π
FCA∗

σ ∗
Ω /π
FCA∗

π

gfp(E)

Q∞

fp(E)

lfp(E)

S(L )

E∞

L

FCA∗(K0)

Fig. 6. The L (resp. K ) lattice and effects of E and Q (resp. F and P) for characterising fp(E)
and S(L ) (resp. fp(F) and S(K )).

By convention, we note Q∞ the closure function associated with Q.
We end up with two operations, E and Q, the former extensive and the latter anti-
extensive, that may be transformed into closure operators. These functions are instru-
mental to provide the inﬁmum and supremum of our desired lattices (see also Figure 6):

Proposition 6. lfp(E) and Q∞(gfp(E)) are respectively the inﬁmum and suppremum of
fp(E) ∩ S(L ) for (cid:22).

Proof. lfp(E) is the lower bound for fp(E) ∩ S(L ) because it is the lower bound for
fp(E). It is the inﬁmum of fp(E) ∩ S(L ) for (cid:22) because FCA∗(K0) ∈ S(L ) and by
Proposition 3 this property is preserved by E and since lfp(E) = E∞(FCA∗(K0)), it
belongs to S(L ).

Q∞(gfp(E)) is the upper bound for fp(E) ∩ S(L ) because gfp(E) contains all pos-
sible closed concepts that can be built from DΩ ,R,N(G). Hence, those attributes not be-
longing to π(gfp(E)) cannot belong to any self-supported lattice. By Proposition 5,
Q∞(gfp(E)) ∈ S(L ). If Q∞(gfp(E)) (cid:54)∈ fp(E), this entails Q∞(gfp(E)) ≺ E(Q∞(gfp(E)))
and moreover that ∃n; En(Q∞(gfp(E))) ∈ fp(E) (because E is extensive and the space is
ﬁnite). But, by Proposition 3, E preserves self-supportiveness. Thus, En(Q∞(gfp(E))) ∈
fp(E) ∩ S(L ) and Q∞(gfp(E)) ≺ En(Q∞(gfp(E))), which is contradictory with the fact
that Q∞(gfp(E)) is an upper-bound for all ﬁxed points. Thus, Q∞(gfp(E)) is the supre-
mum of fp(E) ∩ S(L ) for (cid:22).

6 Discussion

Our initial goal was to deﬁne which concept lattices could be considered as the result
of RCA on a relational context. RCA provides a practical algorithm (based on F or E
and FCA∗) to ﬁnd out the smallest of these: lfp(E). We have characterised the greatest
one: gfp(Q) or Q∞(gfp(E)).

We end up with two functions, complementary in their structure, one expanding the
context, the other contracting it. In the perspective of enumerating all self-supported
ﬁxed points, it is tempting to either start from lfp(E) and use E or start from gfp(Q) and
use Q. Unfortunately, these starting points being ﬁxed points for these very functions,
this leads nowhere. It is necessary to escape the ﬁxed points. For instance, starting from
lfp(E), one could add non-supported attributes until they become supported. Performing
this attribute by attribute is not very smart. Figure 3 shows possible ﬁxed points: L2
and L3. They require to add 2 or 6 attributes to L1. A smarter strategy would consist
of analysing the sets of attributes that support each others, through the induction of
concepts, and adding these one by one to lfp(E) or suppressing them from gfp(Q).
There is a known bound to this set since none of the attributes not in the intents of
gfp(Q) can be added, and none of those in lfp(E) can be suppressed. Finally, these sets
may entertain dependencies (adding one set of attributes would immediately support
another). This may be dealt with by computing such dependencies or by applying the
required closure operator (E∞ or Q∞) after each addition.

Such a procedure seems to be achievable with RCA0, it will be more difﬁcult to set

up with RCA due to dependencies across lattices.

7 Conclusions

Motivated by the requirement to extract more concepts with relational concept analysis,
we gave a new, ﬁxed-point based, semantics for RCA0. The main contribution of this
work is the formulation of the RCA semantics in terms of ﬁxed points of the function
(F or E) at the core of RCA0. Then it is shown that the well-grounded semantics of
RCA corresponds to the least ﬁxed-point semantics.

We also identiﬁed as self-supported ﬁxed points those other ﬁxed points of interest.
The least ﬁxed point being the smaller of these. This led to develop another function (P
or Q) which, together with FCA∗, allows extracting the greatest of them as an alternative
to RCA.

This result does not mean that RCA is wrong. In FCA, conceptual scaling has been
considered as a human-driven analysis tool: a knowledgeable person could provide at-
tribute in this language for describing better the data to be analysed. In RCA, scaling
is used as an extraction tool, with the drawback to potentially generate many attributes.
By only extracting the least ﬁxed point, RCA avoids generating too many of them.

In the context of extracting a TBox for a particular ABox, extracting the least ﬁxed
point is adequate since it may be relatively complex and it is a good starting point. But
for other applications, such as link key candidate extraction, it is very important to have
all possible ﬁxed points because external measures are used for selecting the best one
(which has no reason to be either the least or the greatest one).

The deﬁnitions and results of Sections 4 and 5 have been restricted to RCA0 for
the sake of clarity. Although this remains to be proved, they should hold for RCA as
a whole. Indeed, all deﬁnitions can be applied to families of contexts and lattices, the
order between them being the product order induced by the piece-wise conjunction. All
operations remain monotone and extensive (or anti-extensive) as soon as the selected
scaling operations are. This is enough to preserve the results.

Acknowledgements

This work has been partially funded by the ANR Elker project (ANR-17-CE23-0007-
01). The author thanks Philippe Besnard for pointing to the Knaster-Tarski theorem.

References

1. Atencia, M., David, J., Euzenat, J.: Data interlinking through robust linkkey extraction. In:
Proc. 21st european conference on artiﬁcial intelligence (ECAI), Praha (CZ). pp. 15–20
(2014)

2. Atencia, M., David, J., Euzenat, J., Napoli, A., Vizzini, J.: Link key candidate extraction with

relational concept analysis. Discrete applied mathematics 273, 2–20 (2020)

3. Baader, F., Calvanese, D., McGuinness, D., Nardi, D., Patel-Schneider, P. (eds.): The de-
scription logic handbook: theory, implementations and applications. Cambridge University
Press (2003)

4. Belohlávek, R.: Introduction to formal concept analysis. Tech. rep., Univerzita Palackého,

Olomouc (CZ) (2008)

5. Ferré, S., Cellier, P.: Graph-FCA: an extension of formal concept analysis to knowledge

graphs. Discrete applied mathematics 273, 81–102 (2020)

6. Ganter, B., Kuznetsov, S.: Pattern structures and their projections. In: Proc. 9th International
conference on conceptual structures (ICCS). Lecture Notes in Computer Science, vol. 2120,
pp. 129–142 (2001)

7. Ganter, B., Wille, R.: Formal concept analysis: mathematical foundations. Springer, Heidel-

berg (DE) (1999)

8. Keip, P., Ferré, S., Gutierrez, A., Huchard, M., Silvie, P., Martin, P.: Practical comparison
of FCA extensions to model indeterminate value of ternary data. In: Proc. 15th International
Conference on Concept Lattices and Their Applications (CLA), Tallinn (EE). CEUR Work-
shop Proceedings, vol. 2668, pp. 197–208 (2020)

9. Kuznetsov, S.: Pattern structures for analyzing complex data. In: Proc. International Work-
shop on Rough Sets, Fuzzy Sets, Data Mining, and Granular-Soft Computing (RSFDGrC).
Lecture notes in computer science, vol. 5908, pp. 33–44 (2009)

10. Kötters, J.: Concept lattices of a relational structure. In: Proc. 21th International Conference
on Conceptual Structures (ICCS). Lecture Notes in Computer Science, vol. 7735, pp. 301–
310 (2013)

11. Nebel, B.: Reasoning and revision in hybrid representation systems. Lecture Notes in Artiﬁ-

cial Intelligence 422, Springer Verlag, Berlin (DE) (1990)

12. Prediger, S.: Logical scaling in formal concept analysis. In: Proc. 5th International Confer-
ence on Conceptual Structures (ICCS), Seattle (WA US). Lecture Notes in Computer Sci-
ence, vol. 1257, pp. 332–341 (1997)

13. Rouane Hacene, M., Huchard, M., Napoli, A., Valtchev, P.: Relational concept analysis: min-
ing concept lattices from multi-relational data. Annals of Mathematics and Artiﬁcial Intelli-
gence 67(1), 81–108 (2013)

14. Rouane Hacene, M., Huchard, M., Napoli, A., Valtchev, P.: Soundness and completeness
of relational concept analysis. In: Proc. 11h International Conference on Formal Concept
Analysis (ICFCA). Lecture Notes in Computer science, vol. 7880, pp. 228–243. Springer
(2013)

15. Tarski, A.: A lattice-theoretical ﬁxpoint theorem and its applications. Paciﬁc journal of math-

ematics 5(2), 285–309 (1955)

