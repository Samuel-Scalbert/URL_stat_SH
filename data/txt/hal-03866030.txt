Exploring the Application of Graph-FCA to the
Problem of Knowledge Graph Alignment
Sébastien Ferré

To cite this version:

Sébastien Ferré. Exploring the Application of Graph-FCA to the Problem of Knowledge Graph Align-
ment. CLA 2022 - 16th International Conference on Concept Lattices and Their Applications, Jun
2022, Tallinn, Estonia. pp.1-12. ￿hal-03866030￿

HAL Id: hal-03866030

https://inria.hal.science/hal-03866030

Submitted on 22 Nov 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Exploring the Application of Graph-FCA to the
Problem of Knowledge Graph Alignment

S´ebastien Ferr´e(cid:63)

Univ Rennes, CNRS, IRISA
Campus de Beaulieu, 35042 Rennes, France
Email: ferre@irisa.fr, orcid: 0000-0002-6302-2333

Abstract. Knowledge Graphs (KG) have become a widespread knowl-
edge representation. When diﬀerent KGs exist for some domain, it is
valuable to merge them into a richer KG. This is known as the problem
of KG alignement, which encompasses related problems such as entity
alignement or ontology matching. Although most recent approaches rely
on supervised representation learning, Formal Concept Analysis (FCA)
has also been proposed as a basis for symbolic and unsupervised ap-
proaches. We here explore the application of Graph-FCA, an extension
of FCA for KGs, to diﬀerent scenarios of KG alignments: (A) when the
two KGs have common values, and (B) when pre-aligned pairs are known.
We show that, compared to previous FCA-based approaches, Graph-FCA
allows for a more natural and scalable representation of the KGs to be
aligned, and makes it simpler to extract alignments from the concepts.
It also features ﬂexibility w.r.t. diﬀerent alignment scenarios.

1

Introduction

A knowledge graph (KG) is a modelling of some domain of interest that sup-
ports many tasks such as question answering, reasoning over data or machine
learning. They are commonly represented in languages of the Semantic Web
(RDF(S), OWL), and published on the web as Linked Open Data (LOD) [9]. A
KG is a set of entities described by their classes, properties, and relations with
other entities. Due to the open nature of the web, it is common that a same
domain of interest is modelled by multiple KGs. Those have in general overlap-
ping, hence redundant, information but also complementary information. It is
therefore valuable to merge the diﬀerent KGs that model a same domain into
a single richer KG. The diﬃculty is that diﬀerent KGs generally use diﬀerent
entity identiﬁers (URIs) for the same real entities, and even diﬀerent schemas or
ontologies, i.e. diﬀerent classes, properties and relations.

The problem of merging two KGs consists in discovering equivalence links
between entities and/or between schemas, which is known as knowledge graph
alignment. A number of other terms are used in the literature, partially depend-
ing on the focus on entities or on the schema: entity alignment, entity matching,

(cid:63) This research is supported by ANR project SmartFCA (ANR-21-CE23-0023).

ontology alignment/matching, data interlinking [2,14]. In order to align two KGs,
they must have something in common, some alignment seeds. Those seeds can
be: a common language for the string values (e.g., names, titles), a set pre-aligned
pairs, or a combination of those. Most existing work consider a single scenario,
and may not apply to other scenarios. A common scenario (called Scenario A in
the following) is to only assume a common language, and no pre-aligned pairs.
This is an unsupervised setting. Another common scenario in recent literature
(called Scenario B in the following), assumes that a set of pre-aligned pairs is
available [14]. This is a supervised setting where the pre-aligned pairs serve as
a training set. Most approaches use similarity measures that combine termino-
logical features (i.e., strings for names, titles, ...), and structural features (i.e.,
relationships between entities). A recent trend is to use KG embeddings as such
features. Formal Concept Analysis (FCA) [7] and FCA extensions, such as Pat-
tern Structures [6] and Relational Concept Analysis [11], have been recently
proposed for tasks related to KG alignment [15,3,1]. Formal concepts are used
there as a symbolic form of similarity.

In this paper, we explore the application of Graph-FCA [5], an extension of
FCA speciﬁcally designed for analyzing KGs, to the two main scenarios of KG
alignment. We propose an approach that makes three contributions to previous
FCA-based approaches.

1. A more natural and scalable representation. The formal context is the union
(rather than the product) of the two KGs to be aligned, with minor adjust-
ments depending on the alignment scenario.

2. A uniform alignment extraction methods for both entities and schema ele-
ments (classes, properties and relations). All alignement pairs are extracted
from concept extents (rather than from both extents and intents).

3. A ﬂexible approach w.r.t. diﬀerent scenarios. They are handled through mi-

nor adjustments to the representation of KGs.

We show the eﬀectiveness of our approach on a few use cases taken or adapted
from previous FCA-based work.

Section 2 states the KG alignment problem. Section 3 presents the related
work. Section 4 shortly describes Graph-FCA. Section 5 explains our approach
from principles to concrete application, and discusses the results on the two main
scenarios. Section 6 concludes and draws perspectives.

2 Problem Statement

We start by deﬁning knowledge graphs (KG), taking care to distinguish between
classes, properties and relations in order to allow for a more accurate modelling.
Many work on KGs only consider entities and relations.

Deﬁnition 1 (knowledge graph). A knowledge graph is a structure
G = (cid:104)E, C, P, R, T (cid:105), where E is the set of entities, C is the set of classes, P
is the set of properties, R is the set of relations, and T is a set of triples. The

Fig. 1. Two KGs (left and right) with cyclic dependencies (from Atencia et al [3])

schema of the KG is made of the classes, properties and relations. There are
three kinds of triples, for any e, e(cid:48) ∈ E, c ∈ C, p ∈ P, r ∈ R:

– (e, type, c) states that class c is the type of entity e;
– (e, p, v) states that property p has value v on entity e, where a value can be

a string, a number, etc.;

– (e, r, e(cid:48)) states that relation r links entity e to entity e(cid:48).

In RDF and OWL, entities are called individuals, values are called literals,
and the distinction between properties and relations corresponds to the distinc-
tion in OWL between datatype properties and object properties. URIs are used
to identify entities, classes, properties, and relations.

Figure 1 shows two knowledge graphs, one on the left and another on the
right. It falls into Scenario A as it uses completely diﬀerent schemas and it only
shares proper names of entities (square boxes). The objective is to ﬁnd the best
alignement between the two. This is the most complex example considered by
Atencia et al [3] (Fig. 8, p.23). It involves cyclic dependencies that have to be
taken into account to ﬁnd the correct alignment.

It is easy to ﬁnd that o1:z1 aligns with o2:i1 because they are the unique
entities in each KG to have "Dupont" as a value. From this ﬁrst alignement,
one can ﬁnd two additional alignments: property o1:lastname with o2:name,
and class o1:Person with o2:Inhabitant. It is more diﬃcult to ﬁnd that o1:z3
aligns with o2:i3. o1:z3 has lastname "Dubois" but both o2:i2 and o2:i3
have name "Dubois". o1:z3 has a home/address in Paris but so do o2:i2 and
o2:i3. Traversing deeper in the graph, we ﬁnd that o1:z3’s home is owned by
a Dupont who lives in Grenoble. Something equivalent can be found for o2:i3
but not for o2:i2. We observe that the alignment of entities, classes, properties

and relations depend on each other, and that handling long-range dependencies
may be necessary to resolve alignments.

The example in Figure 1 can be adapted to cover Scenario B where string
values are in diﬀerent incomparable languages but some pre-aligned pairs may
be available. Imagine for instance that the strings of the left-side KG are in
Chinese, and that we already know that o1:z1 aligns with o2:i1. Without that
pre-aligned pair, one only has structural information, which is not enough to
discriminate between the diﬀerent people and places. Knowing that o1:z1 aligns
with o2:i1 (Dupont), one can align classes o1:Person and o2:Inhabitant, and
also relations o1:home and o2:address. By propagating alignments through
neighborhood, starting from the pre-aligned pair, it is here possible to ﬁnd the
correct alignment for all elements: ﬁrst o1:h1 with o2:a1, then o1:city with
o2:city and o1:z2 with o2:i2, and so on.

3 Related Work

The alignment of KGs (or entities, or ontologies) is a matter of deﬁning and com-
bining similarity measures [2]. There are four kinds of similarities, depending on
the kind of information that is used. Terminological similarity is based on the
strings that are used to name entities and schema elements. Structural similarity
is based on the description of entities by classes, properties, and relations. Ex-
tensional similarity is based on the extensions of classes. Semantic similarity is
based on external sources of knowledge, and on automated reasoning (e.g., sub-
sumption checks in description logics). Terminological and structural similarities
are the most common methods, and are often combined to get better results. In
general, strutural similarity does not consider the KG as a whole but use either
tree-shaped descriptions extracted from the knowledge graph, or neighbor-based
propagation of similarity values (e.g., RiMOM-IM [13]).

The trend in KG alignement is to use representation learning methods, in a
supervised setting where a signiﬁcant number of pre-aligned pairs is supposed
to be known [14]. The principle is ﬁrst to learn embeddings for the two KGs
that coincide for the pre-aligned pairs. Other alignments can then be found by
nearest-neighbor search in the embedding space. Many representation learning
methods exist, such as TransE [4], ComplEx-N3 [10] or R-GCN [12].

Diﬀerent variants of FCA have been applied to tasks related to KG align-
ment. Classical FCA was used for aligning (aka. matching) several biomedical
ontologies, in a system called FCA-Map [15]. The scenario is here to match
classes and relations based on their names and their relationships (e.g., class hi-
erarchies, class disjointness, relation domains and ranges), there are no entities
per se. The intuition behind using FCA is that if a concept has only two objects
in its extent (here classes and relations), one from each ontology, then this is
a strong indication that the two entities should be aligned. This is called an
anchor in FCA-Map. The global alignment is obtained by deﬁning a succession
of ﬁve formal contexts, and computing their concept lattices. This can be seen

Fig. 2. Graph context about dishes, cereals, and countries.

as an ad-hoc form of Relational Concept Analysis (RCA) [11], with the notions
of iterative concept formation, and relational attributes.

RCA was used for the task of link key discovery [3], which consists in ﬁnd-
ing pairs of properties and/or relations that are identifying keys for the entities
of a pair of classes. In Figure 1, the pair o1:lastname/o2:name is not a link
key for the pair of classes o1:Person/o2:Inhabitant, but combined with the
pair o1:home/o2:address, it is. Link key discovery is somewhat stronger than
KG alignment because in addition to provide alignments, it provides a rule for
predicting aligned pairs in unseen data. RCA can be compared to methods that
propagate similarity values through relations, except that formal concepts are
used in place of numerical values. Pattern Structures [6] were used for the same
task with an approach that is similar but does not cover long-range and cyclic
dependencies like in RCA. In those approaches, the discovery of an alignment
between two KGs is somewhat contrived. First, although a KG can be naturally
represented as an RCA context, the RCA context must instead represent the
product of the two KGs: i.e., the objects are all pairs of entities (one from each
KG), the properties are all pairs of properties, and so on. This entails a quadratic
increase in the size of the data, which poses scalibility issues. Second, the discov-
ered alignment is scattered in the extents and intents of formal concepts, across
several concept lattices. We show in this paper that those two disadvantages are
overcome when using Graph-FCA [5] on the task of KG alignment.

4 Graph-FCA

Graph-FCA [5] is an extension of FCA for multi-relational data, and in partic-
ular for knowledge graphs. Graph-FCA deﬁnes a graph context as an incidence
relation between tuples of objects and attributes. A graph context is a triple
K = (O, A, I), where O is a set of objects, A is a set of attributes, and I ⊆ O∗ ×A
is an incidence relation between object tuples o = (o1, . . . , ok) ∈ O∗, for any ar-
ity k, and attributes a ∈ A. A graph context represents a KG with objects as
nodes, and attributes as hyper-edge labels. An hyper-edge ((o1, . . . , ok), a) can

Fig. 3. Compact representation of graph concepts about dishes, cereals, and countries.

be seen as the logical atom a(o1, . . . , ok); we use the latter notation for read-
ability. Unary edges correspond to node labels while binary edges correspond to
labeled edges. Classical FCA is a special case of Graph-FCA where k = 1 (only
unary edges) and n = 1 (only unary concepts).

Figure 2 shows the graphical representation of a graph context about dishes,
cereals, and countries. Each box represents an object o along with the list of
attributes a such that there is an unary edge a(o) ∈ I. Each arrow from box o1
to box o2 labelled by attribute a denotes a binary edge a(o1, o2) ∈ I. An hyper-
edge a(o1, . . . , ok) with k > 2 is represented as an ellipsis labeled by a, and
having an arrow labeled i to each box oi (not illustrated here).

Concept intents express what several n-tuples of objects have in common.
They are graph patterns with n distinguished nodes. They are called Projected
Graph Patterns (PGP), and they are similar to conjunctive queries. For exam-
ple, the PGP [(x, y) ← parent(x, z), parent(y, z)] has three nodes x, y, z, two
edges parent(x, z) and parent(y, z), and two distinguished nodes x, y. It can be
used as a deﬁnition of the ”sibling” relationship, i.e. the fact that x and y are
siblings if they have a common parent z. FCA is extended to graph contexts
by extending the set operations to PGPs. PGP inclusion ⊆q is based on graph
homomorphisms, and PGP intersection ∩q is based on the categorical product of
graphs (see [5] for details).

The Galois connection is deﬁned in Graph-FCA between PGPs (Q, ⊆q)
and sets of object tuples (2O∗
, ⊆). In the deﬁnitions of Q(cid:48) and R(cid:48) below, the
PGP [o ← I] represents the description of an object tuple o by the whole inci-
dence relation I seen from the relative position of o.

Q(cid:48) := {o ∈ On | Q ⊆q [o ← I]}, for Q = [(x1, . . . , xn) ← P ] ∈ Q
R(cid:48) := ∩q{[o ← I] | o ∈ R},

for R ⊆ On, n ∈ N

Informally, Q(cid:48) can be understood as the result set of Q, seen as a query; and
R(cid:48) as the most speciﬁc query whose result set contains R. From there, concepts

can be deﬁned in the usual way, and organized into lattices. A concept is a pair
(R, Q) such that Q(cid:48) = R and R(cid:48) =q Q. The arity of Q and R must be the
same, it determines the arity of the concept. Unary concepts are about sets of
objects, while binary concepts are about relationships between objects, and so
on. Unlike RCA, there is a concept lattice for each concept arity rather than
for each object type.

Figure 3 displays a compact representation of the graph concepts about
dishes, cereals, and countries. It only shows unary concepts (R, Q), with Q =
[x ← P ], s.t. |R| ≥ 2, P (cid:54)= ∅, and P is a “core pattern” (i.e., P has no homomor-
phic subset). Each box x identiﬁes a unary concept, with its name at the top
(e.g., Q1b), and its extent at the bottom (here, Pakistan, Thailand). The con-
cept intent is the PGP [x ← P ], where P is the subgraph made of solid arrows
containing node x. Those arrows denote binary edges while the middle part of
the boxes denote unary edges. By reading the graph, we learn that Concept Q1b
is the concept of “Asian countries, which eat a lot of some dish whose main
cereal is a rice produced in the country itself ”. Formally, its intent is denoted
by [b ← country(b), Asia(b), eatLotOf (b, a), dish(a), hasM ainCereal(a, c),
cereal(c), rice(c), isP roducedIn(c, b)] (using the small letters of concept names
as pattern variables). Concepts Q1a and Q1c have the same graph pattern
as Q1b but with a diﬀerent focus, on dishes for Q1a and on cereals for Q2c.
N-ary concepts are obtained by picking several distinguished nodes. For exam-
ple, (Q1b,Q1a,Q1c) is a ternary concept whose instances are the object triples
(P akistan, biryani, basmatiRice) and (T hailand, khaoM anKai, thaiRice). It
represents the cyclic relationship existing between a country, a dish, and a cereal
in Asian countries. The Q2-concepts are generalizations of the Q1-concepts. For
example, concept Q2b covers all countries. The dashed arrow from Q2b to Q1b
says that Q1b is a subconcept of Q2b. The Q2-intents say that, in the context,
all dishes use some rice as a main cereal, and that all cereals are produced in
some country but that not all countries eat a lot of some dish, and not all dishes
are eaten a lot by some country.

5 Concept-based Knowledge Graph Alignment

In this section, we explain how KG alignments can be extracted from Graph-FCA
concepts, and we discuss the results on the example and scenarios of Section 2.

5.1 Principle

When two entities from two diﬀerent KGs are equivalent, e.g. o1:z1 and o2:i1
in the example, they generally have equivalent types (e.g., o1:Person and
o2:Inhabitant), equivalent properties with equal values (e.g. o1:lastname
and o2:name “Dupont”), and equivalent relations with equivalent entities (e.g.,
o1:home o1:h1 and o2:address o2:a1). Similarly, when two classes are equiv-
alent, they are the type of equivalent entities. In FCA terms, the two equivalent

entities (or classes) belong to the extent of a formal concept whose intent ex-
presses everything they have in common. Here, the intent is not only about how
the entities are described but also about how the entities are related to other en-
tities. Moreover, the equivalence between two entities depend on the equivalence
between the related entities, and so on recursively. This makes Graph-FCA, like
RCA, a good match for the problem of KG alignment.

More precisely, let G1 and G2 be two KGs. If an unary concept C = (R, Q)
has only two elements in its extent, R = {x1, x2}, where x1 belong to G1 and
x2 belongs to G2, then this is a strong indication that x1 and x2 are equivalent
because they are unique in their own KG to match the projected graph pattern Q.
Such a concept is called an anchor in [15]. Concepts that are not anchors can
also contribute to the alignement, although in a less direct and less certain
way. For example, a concept with extent {x1, y1, x2, y2} says that G1-entities
x1 and y1 align with G2-entities x2 and y2, without knowing which aligns to
which. However, if we also have the anchor {x1, x2}, we can deduce an alignment
between y1 and y2. Another example is a concept with extent {x1, y2, z2} where
some ambiguity remains on the alignment of x1 but it nonetheless reduces the
set of possibilities from all G2-entities to only two entities, y2 and z2.

5.2 Graph-FCA Representation

The immediate representation of a KG as a Graph-FCA context is to use classes,
properties and relations as attributes (hyper-edge labels), and entities as objects
(nodes). Each occurrence of a value is represented by a distinct node labelled by
the value as this avoids spurious connections between objects. This is formalized
by the following mappings from KG triples to Graph-FCA hyper-edges:
(e, r, e(cid:48)) (cid:32) r(e, e(cid:48))

(e, p, v) (cid:32) p(e, ”v”)

(e, type, c) (cid:32) c(e)

where p(e, ”v”) is a shorthand for p(e, o), v(o) for some fresh object o.

This immediate representation, however, does not produce any alignment
because the two KG representations do not share any attribute. Indeed, the two
KGs have diﬀerent schemas, hence diﬀerent classes, properties and relations.
Recall that Graph-FCA concept intents are made of attributes and variables. As
a consequence, for all concepts except the top one, the concept extent contains
only objects from a single KG, and no anchor concept can be found.

An adequate representation should use the same set of attributes for the
two KGs to be aligned, and those attributes should reﬂect what they have in
common. In Scenario A, the two KGs only share the values. Actually, they also
share the graph structure, and the distinction between classes, properties and
relations. Anything else must hence be represented as objects: i.e., not only
entities but also classes, properties and relations. We achieve this by introducing
three meta-level common attributes: type for expressing the relation between
entities and classes, prop for relating entities to values through properties, and
rel for relating entities to entities through relations. The new mapping from KG
triples to Graph-FCA hyper-edges is hence as follows:
(e, p, v) (cid:32) prop(e, p, ”v”)

(e, type, c) (cid:32) type(e, c)

(e, r, e(cid:48)) (cid:32) rel (e, r, e(cid:48))

This is a form of reiﬁcation, in which classes, properties and relations are treated
as objects. It is made possible by the fact that Graph-FCA supports hyper-edges
beyond binary edges. As deﬁned above, the notation ”v” for a value implicitly
introduces an attribute v, hence accounts for the values shared between KGs.

In Scenario B, in contrast to Scenario A, even the values are diﬀerent in
the two KGs. This means that values do not bring any information so that the
mapping for properties can be simpliﬁed as (e, p, v) (cid:32) prop(e, p). Obviously,
the two mappings can be mixed if some values are shared and others not. To
compensate for the lack of shared elements, a set of pre-aligned pairs (x1, x2)
may be given as input, and modelled as equivalence triples (x1, sameAs, x2). Such
an equivalence can be represented in Graph-FCA by using a fresh attribute ax
that represents the real entity or schema element x that x1 and x2 refer to. The
mapping rule is

(x1, sameAs, x2) (cid:32) ax(x1), ax(x2),

for some fresh attribute ax.

Attribute ax works like a nominal attribute for each KG, labelling only x1 in
G1, and only x2 in G2.

5.3 Results and Discussion

We ran our Graph-FCA implementation1 on the two scenarios in order to ﬁnd
anchors, and hence KG alignments. We used the following options to make their
computation more eﬃcient, and the output smaller: -minsupp 2 because anchors
have by deﬁnition a support equal to 2, and -only-cores because it excludes
concepts that represent under-optimal alignments (an example is given below).

Scenario A (common values). Graph-FCA ﬁnds 24 unary concepts, grouped in
only two patterns: Q1 and Q2. All anchor concepts are in Q1, and all concepts
in Q1 are anchor concepts. Moreover, all elements of the two KGs (entities and
schema) appear in those concepts. Pattern Q1 therefore represents a complete
alignement between the two KGs. Table 1 lists those concepts with their identiﬁer
(a lowercase letter), their extent (an object from each KG), and their neighboring
intent. For instance, concept g shows the alignment of o1:z1 with o2:i1, and
its intent reads as follows: The two entities have type l, property a with value
“Dupont”, relation d to entity h, and relation c from entity i. Each variable in
the intent refers to a concept in the same pattern, and hence to an aligned pair:
e.g., the common type l is o1:Person/o2:Inhabitant, and the property with
value “Dupont” is o1:lastname/o2:name. One can observe that the alignement
is also correct, not only for entities but also for classes, properties and relations.
The concepts in pattern Q2 are general concepts. One concept gathers all
entities (people and places), another all classes, and similarly for properties
and relations. It simply reﬂects the meta-model used in our representation.
Without option -only-cores, Graph-FCA outputs additional concepts that
represent approximate alignments, such as {o1:z1, o1:z3, o2:i1, o2:i3} or
{o1:lastname, o2:name, o2:given}.

1 Open source at https://bitbucket.org/sebferre/graph-fca/

Table 1. Anchor concepts in Scenario A (common values).

C extent(C)
a

o1:lastname o2:name

intent(C), only adjacent edges
prop(e, a, ”Dubois”), prop(f, a, ”Dubois”),

prop(g, a, ”Dupont”)

b

o1:city

o2:city

prop(h, b, ”Grenoble”), prop(i, b, ”P aris”),

o1:owner
c
o1:home
d
o1:z3
e
o1:z2
f
g
o1:z1
h o1:h1

o2:ownedBy
o2:address
o2:i3
o2:i2
o2:i1
o2:a1

rel(h, c, f ), rel(i, c, g), rel(j, c, e)
rel(e, d, i), rel(f, d, j), rel(g, d, h)
type(e, l), prop(e, a, ”Dubois”), rel(e, d, i), rel(j, c, e)
type(f, l), prop(f, a, ”Dubois”), rel(f, d, j), rel(h, c, f )
type(g, l), prop(g, a, ”Dupont”), rel(g, d, h), rel(i, c, g)
type(h, k), prop(h, b, ”Grenoble”), rel(g, d, h),

prop(j, b, ”P aris”)

rel(h, c, f )

i
j
k
l

o1:h3
o1:h2
o1:House
o1:Person

o2:a3
o2:a2
o2:Place
o2:Inhabitant

type(i, k), prop(i, b, ”P aris”), rel(e, d, i), rel(i, c, g)
type(j, k), prop(j, b, ”P aris”), rel(f, d, j), rel(j, c, e)
type(h, k), type(i, k), type(j, k)
type(e, l), type(f, l), type(g, l)

Scenario B (pre-aligned pairs). Without common values nor any pre-aligned
pairs, Graph-FCA only ﬁnds the meta-concepts, like in pattern Q2 in the above
scenario. Indeed, there is no rationale for making any alignment. When adding
a pre-aligned pair, like o1:z1 with o2:i1, Graph-FCA ﬁnds an almost complete
alignment (see Table 2). The only uncertainty is about o1:lastname that aligns
with either o2:name or o2:given. Indeed, without values, the diﬀerent properties
that apply to an entity cannot be distinguished. Choosing any other pair of
entities as pre-aligned pair gives the same result. However, if the pre-aligned
pair is about the schema (e.g., two equivalent classes), then only the schema
elements are correctly aligned. Entities are grouped by type (people and places)
but they are not aligned individually.

Other results. We also applied our approach to the example of Abbas et al [1],
which falls in Scenario A (common values). It is at the same time simpler than
the example of Atencia et al because it has no relations (only classes and prop-
erties), and more diﬃcult because there is not a one-to-one mapping between
the two KGs. First, there are entities in G1 that are not present in G2. Sec-
ond, the classes are not equivalent: the G1-class o1:Book is split in two G2-
classes, o2:Dictionary and o2:Novel; and the G2-class o2:FemaleScientist
is equivalent to the intersection of two G1-classes, o1:Woman and o1:Scientist.
The alignments produced by Graph-FCA are grouped in two patterns, one for
people and another for books, because there are no relations between them
in the data. All common entities and all properties are completely and cor-
rectly aligned (one anchor concept for each pair). For classes, three interest-
ing concepts are found: {o1:Woman, o1:Scientist, o2:FemaleScientist},
{o1:Book, o2:Novel}, and {o1:Book, o2:Dictionary}. They can be read
as “Woman and Scientist together align with FemaleScientist”, and “Book

Table 2. Anchor concepts in Scenario B (pre-aligned pairs).

o2:city

C extent(C)
o1:city
a
o1:lastname o2:name
b
o2:given
o2:ownedBy
o2:address
o2:i3
o2:i2
o2:a1
o2:a3
o2:a2
o2:Place
o2:Inhabitant
o2:i1

o1:owner
c
o1:home
d
o1:z3
e
o1:z2
f
o1:h1
g
h o1:h3
o1:h2
i
o1:House
j
o1:Person
k
o1:z1
l

intent(C), only adjacent edges
prop(g, a), prop(h, a), prop(i, a)
prop(e, b), prop(f, b), prop(l, b)

rel(g, c, f ), rel(h, c, l), rel(i, c, e)
rel(e, d, h), rel(f, d, i), rel(l, d, g)
type(e, k), prop(e, b), rel(e, d, h), rel(i, c, e)
type(f, k), prop(f, b), rel(f, d, i), rel(g, c, f )
type(g, j), prop(g, a), rel(g, c, f ), rel(l, d, g)
type(h, j), prop(h, a), rel(e, d, h), rel(h, c, l)
type(i, j), prop(i, a), rel(f, d, i), rel(i, c, e)
type(g, j), type(h, j), type(i, j)
type(e, k), type(f, k), type(l, k)
z1i1(l), type(l, k), prop(l, b), rel(h, c, l), rel(l, d, g)

aligns with either Novel or Dictionary”. This is exactly as expected. Note that
each entity with type o1:Book is correctly assigned to one of o2:Novel and
o2:Dictionary (two distinct concepts), based on its properties (“author” for
novels, “year” for dictionaries).

Discussion. Compared to the use of classical FCA, RCA or Pattern Structures,
our approach does not build a context as the “product” of the two KGs, i.e.
with all pairs of entities as objects, and all pairs of classes/properties/relations
as attributes. Instead, the Graph-FCA context is built as the “union” of the two
KGs. This entails that the size of our context is the sum of the size of the two
KGs, rather than the product. This clearly favors the scalability of our approach.
A key enabling feature of Graph-FCA is the support for k-ary relations as
it enables to reify the binary properties and relations as objects, along with
entities, and to use them as arguments of meta-level ternary predicates (e.g.,
prop). Note that this is akin to RDF triples where properties belong to the same
space as individuals. As a consequence, the alignment of classes, properties and
relations (the schema) can be interpreted in the Graph-FCA output exactly like
for entities, through concept extents. This is in contrast with other FCA-based
approaches, where a diﬀerent interpretation method must be used for the schema
because it appears in concept intents. Although it can be diﬃcult to read Graph-
FCA output in general, a KG alignment can be read from the unary concept
extents, which are sets of objects, like in classical FCA.

6 Conclusion and Perspectives

Graph-FCA is FCA for knowledge graphs, and we have shown in this paper that
by adequately representing two KGs in terms of what they have in common, we
can extract aligned pairs of entities, classes, properties and relations from Graph-
FCA concepts in a uniform way. The results in this paper are limited to a few

encouraging illustrative examples in diﬀerent scenarios, and much remains to be
done to apply our approach to real KGs. A ﬁrst issue is scalability. A research
track is to only generate anchors, i.e. concepts that result from the intersection
of two objects, one from each KG. A second issue is to allow for approximate
matching of values, especially texts, as they often slightly diﬀer from one KG to
another.

References

1. Abbas, N., David, J., Napoli, A.: Discovery of link keys in RDF data based on
pattern structures: Preliminary steps. In: Int. Conf. Concept Lattices and Their
Applications (2020)

2. Ardjani, F., Bouchiha, D., Malki, M.: Ontology-alignment techniques: Survey and

analysis. Int. J. Modern Education & Computer Science 7(11) (2015)

3. Atencia, M., David, J., Euzenat, J., Napoli, A., Vizzini, J.: Link key candidate
extraction with relational concept analysis. Discrete applied mathematics 273, 2–
20 (2020)

4. Bordes, A., Usunier, N., Garcia-Duran, A., Weston, J., Yakhnenko, O.: Translating
embeddings for modeling multi-relational data. In: Advances in neural information
processing systems. pp. 2787–2795 (2013)

5. Ferr´e, S., Cellier, P.: Graph-FCA: An extension of formal concept analysis to knowl-

edge graphs. Discrete Applied Mathematics 273, 81–102 (2019)

6. Ganter, B., Kuznetsov, S.: Pattern structures and their projections. In: Delugach,
H.S., Stumme, G. (eds.) Int. Conf. Conceptual Structures. pp. 129–142. LNCS
2120, Springer (2001)

7. Ganter, B., Wille, R.: Formal Concept Analysis — Mathematical Foundations.

Springer (1999)

8. Hahn, G., Tardif, C.: Graph homomorphisms: structure and symmetry. In: Graph

symmetry, pp. 107–166. Springer (1997)

9. Hitzler, P., Kr¨otzsch, M., Rudolph, S.: Foundations of Semantic Web Technologies.

Chapman & Hall/CRC (2009)

10. Lacroix, T., Usunier, N., Obozinski, G.: Canonical tensor decomposition for knowl-
edge base completion. In: Dy, J.G., Krause, A. (eds.) Int. Conf. Machine Learning.
Proceedings of Machine Learning Research, vol. 80, pp. 2869–2878. PMLR (2018)
11. Rouane-Hacene, M., Huchard, M., Napoli, A., Valtchev, P.: Relational concept
analysis: mining concept lattices from multi-relational data. Annals of Mathematics
and Artiﬁcial Intelligence 67(1), 81–108 (2013)

12. Schlichtkrull, M., Kipf, T.N., Bloem, P., van den Berg, R., Titov, I., Welling, M.:
Modeling relational data with graph convolutional networks. In: The Semantic Web
Conf. (ESWC). pp. 593–607. Springer (2018)

13. Shao, C., Hu, L.M., Li, J.Z., Wang, Z.C., Chung, T., Xia, J.B.: Rimom-im: A novel
iterative framework for instance matching. J. computer science and technology
31(1), 185–197 (2016)

14. Zeng, K., Li, C., Hou, L., Li, J., Feng, L.: A comprehensive survey of entity align-

ment for knowledge graphs. AI Open 2, 1–13 (2021)

15. Zhao, M., Zhang, S., Li, W., Chen, G.: Matching biomedical ontologies based on

formal concept analysis. J. biomedical semantics 9(1), 1–27 (2018)

