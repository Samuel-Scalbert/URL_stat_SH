Graph-FCA Meets Pattern Structures
Sébastien Ferré

To cite this version:

Sébastien Ferré. Graph-FCA Meets Pattern Structures. ICFCA 2023 - 17th International Conference
on Formal Concept Analysis, Jul 2023, Kassel, Germany. pp.33-48, ￿10.1007/978-3-031-35949-1_3￿.
￿hal-04186101￿

HAL Id: hal-04186101

https://inria.hal.science/hal-04186101

Submitted on 23 Aug 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution 4.0 International License

Graph-FCA Meets Pattern Structures

Sébastien Ferré(cid:63)

Univ Rennes, CNRS, Inria, IRISA
F-35000 Rennes, France
ferre@irisa.fr

Abstract. A number of extensions have been proposed for Formal Con-
cept Analysis (FCA). Among them, Pattern Structures (PS) bring com-
plex descriptions on objects, as an extension to sets of binary attributes;
while Graph-FCA brings n-ary relationships between objects, as well
as n-ary concepts. We here introduce a novel extension named Graph-
PS that combines the beneﬁts of PS and Graph-FCA. In conceptual
terms, Graph-PS can be seen as the meet of PS and Graph-FCA, seen as
sub-concepts of FCA. We demonstrate how it can be applied to RDFS
graphs, handling hierarchies of classes and properties, and patterns on
literals such as numbers and dates.

1

Introduction

Formal Concept Analysis (FCA) [17] has been applied to many diﬀerent tasks –
such as information retrieval, recommendation, ontology engineering, or knowl-
edge discovery – and in many application domains, e.g., social sciences, soft-
ware engineering, bioinformatics or chemoinformatics, natural language process-
ing [15]. The variety of those tasks and application domains early called for FCA
extensions in order to handle complex data. Complex data includes non-binary
attributes, concrete domains, heterogeneous data, uncertain data, and structured
data.

The earlier extensions enable to use complex descriptions of objects in place
of sets of binary attributes. Three similar extensions have been introduced at al-
most the same time: Generalized Formal Concept Analysis [6], Logical Concept
Analysis [12], and Pattern Structures [16]. They enable to describe objects with
valued attibutes, intervals over numbers and dates, convex polygons, partitions,
sequence patterns, tree patterns, or labelled graph patterns [15]. Other exten-
sions address the uncertainty of object descriptions [22], notably Fuzzy FCA [5]
where the incidence between an object and an attribute is a truth degree in [0, 1]
instead of a crisp Boolean value. Triadic Concept Analysis [21] adds conditions
to the incidence between an object and an attribute, making the formal context
a ternary relation instead of a binary relation. Polyadic Concept Analysis [24]
generalizes this idea by allowing any number of dimensions for the context. Fi-
nally, a number of more recent extensions add relationships between objects, so

(cid:63) This research is supported by ANR project SmartFCA (ANR-21-CE23-0023).

2

S. Ferré

that the concepts do not depend only on the individual descriptions of objects
but also on relationship patterns over interconnected objects. Relational Con-
cept Analysis [23] combines several classical FCA contexts and several binary
relations to form concepts whose intents are similar to description logic class
expressions [3], combining object attributes, binary relations, and quantiﬁer op-
erators. Relational structures [19] and Graph-FCA [8] add n-ary relationships
between objects (n ≥ 1), and form n-ary concepts, i.e. concepts whose intents
are equivalent to conjunctive queries, and whose extents are equivalent to the
results of such queries, i.e. sets of n-tuples of objects.

In this paper, we propose to merge two FCA extensions that are representa-
tive of the ﬁrst and last categories above: Pattern Structures (PS) and Graph-
FCA. The aim is to combine the beneﬁts of the two categories of extensions, in
short complex descriptions and relationships between objects. Logical Concept
Analysis (LCA) could have been used in place of PS but we have chosen PS as
it has been more widely adopted, and because it is better suited to the eﬀective
computation of concepts. In this paper we choose to merge PS with Graph-FCA
but it would be perfectly relevant to do so with Relational Concept Analysis
(RCA). We hope this work will encourage and facilitate the merge with RCA
in a future work. The merge results in a new FCA extension called Graph-PS.
It is an elegant extension in the sense that PS is a special case of Graph-PS,
obtained by not using inter-object relationships; and Graph-FCA is a special
case of Graph-PS, obtained by using sets of binary attributes as descriptions
of individual objects and inter-object relationships. As a consequence, classical
FCA is also a special case of Graph-PS. It therefore acts as an unifying FCA
theory encompassing classical FCA and two mainstream FCA extensions.

The paper is structured as follows. Section 2 recalls the main deﬁnitions and
results of Pattern Structures and Graph-FCA, as preliminaries. Section 3 de-
ﬁnes Graph-PS as the extension of Graph-FCA with PS-like descriptions, and
illustrates the diﬀerent notions with a running example combining binary rela-
tionships, valued attributes and intervals. Section 4 describes its application to
RDFS graphs by deﬁning a custom set of descriptions and similarity operator.
Section 5 concludes the paper, and draws some perspectives.

2 Preliminaries

In this section, we recall the main deﬁnitions of two extensions of Formal Con-
cept Analyis (FCA): Pattern Structures (PS) [16] and Graph-FCA [11]. The
former extends FCA attributes with complex descriptions and patterns. The
latter extends FCA with n-ary relations between objects, and n-ary concepts.

2.1 Pattern Structures (PS)

A pattern structure is a triple K = (O, (D, (cid:117)), δ) where O is a set of objects,
(D, (cid:117)) is a meet-semi-lattice of patterns, and δ ∈ O → D is a mapping taking

Graph-FCA Meets Pattern Structures

3

each object to its description. The meet operator d1 (cid:117) d2 represents the sim-
ilarity between two patterns d1 and d2. It entails a partial ordering (cid:118), called
subsumption, deﬁned for all patterns d1, d2 ∈ D as d1 (cid:118) d2 ⇐⇒ d1 (cid:117) d2 = d1.
Conversely, the pattern d1 (cid:117) d2 is the most speciﬁc pattern, according to (cid:118), that
subsumes patterns d1 and d2. The extension of a pattern d is deﬁned as the set
of objects whose description contains the pattern1.

ext(d) := {o ∈ O | d (cid:118) δ(o)},

for every d ∈ D

The intension of a set of objects X is deﬁned as the most speciﬁc pattern that
subsumes the description of all objects in X, i.e. the similarity between all those
descriptions.

int(X) := (cid:108)
o∈X

δ(o),

for every X ⊆ O

The two derivation operators (ext, int) form a Galois connection between the
two posets (2O, ⊆) and (D, (cid:118)). A pattern concept of a pattern structure K =
(O, (D, (cid:117)), δ) is a pair (X, d) with X ⊆ O and d ∈ D such that X = ext(d) and
d = int(X). The component X of a pattern concept (X, d) is called the extent,
and the component d is called the intent. Pattern concepts are partially ordered
by (X1, d1) ≤ (X2, d2) ⇔ X1 ⊆ X2 ⇔ d2 (cid:118) d1. This partial ordering forms a
complete lattice called the pattern concept lattice.

Pattern structures were ﬁrst applied to labeled graphs [16,20], e.g. to discover
frequent patterns in molecular structures. They were then applied to various
types of descriptions: e.g., numbers and intervals [18], partitions for characteriz-
ing functional dependencies [4], RDF graphs [1].

Classical FCA is the special case of PS when D := 2A for a given set of at-
tributes A, and the similarity between two sets of attributes is their intersection:
((cid:117)) := (∩).

2.2 Graph-FCA

We ﬁrst need to introduce notations for tuples. Given a set X of elements,
a k-tuple of elements is an ordered collection of k elements that is written
(x1, . . . , xk). For the sake of concision, a tuple is often written as an overlined
letter x, whose element at position i can be written x[i], or simply xi if there is
no ambiguity. The set of all k-tuples over X is written X k. The set of all tuples
of any arity is written X ∗ = (cid:83)
k≥0 X k. The latter includes the empty tuple ()
for arity 0.

Graph-FCA extends a formal context into a graph context, deﬁned as a
triple K = (O, A, I) where O is a set of objects, A is a set of attributes, and
I ⊆ O∗ × A is an incidence relation between tuples of objects o ∈ O∗ and at-
tributes a ∈ A. Objects are graph nodes, attributes are graph labels, and an

1 The original notation for the two PS derivation operators is (.)(cid:3). We use the no-
tations ext(.) and int(.) because they are more explicit and also consistent with
notations in other FCA extensions.

4

S. Ferré

incidence ((o1, . . . , ok), a) ∈ I – also written a(o1, . . . , ok) – is an ordered hyper-
edge between nodes o1, . . . , ok, labeled with a.

A projected graph pattern of arity k (k-PGP) is a pair Q = (x, P ) where
x = (x1, . . . , xk) ∈ V k is a tuple of k projected variables, and P ⊆ V ∗×A is a graph
pattern. Variables are here graph nodes, and pattern elements ((y1, . . . , yk), a) –
also written a(y1, . . . , yk) – are hyper-edges. The set of k-PGPs Qk is equipped,
for each arity k, with a subsumption operator ⊆q and a similarity operator ∩q.
The description of a tuple of objects o is the PGP Q(o) := (o, I), which uses
objects as variables.

The extension of a k-PGP Q is deﬁned as the set of k-tuples of objects whose

description contains the PGP.

ext(Q) := {o ∈ Ok | Q ⊆q Q(o)},

for every Q ∈ Qk

The intension of a set of k-tuples of objects R is deﬁned as the most speciﬁc
PGP that subsumes the description of all tuples of objects in R, i.e. the PGP-
intersection of all those descriptions.

int(R) :=

(cid:92)

o∈R

Q(o),

for every R ⊆ Ok

Those two derivation operators (ext, int) form a Galois connection between
the two posets (2Ok
, ⊆) and (Qk, ⊆q). A graph concept of a graph context
K = (O, A, I) is a pair (R, Q) with R ⊆ Ok and Q ∈ Qk, for some arity k,
such that R = ext(Q) and Q =q int(R). The component R of a graph con-
cept (R, Q) is called the extent, and the component Q is called the intent. Graph
concepts are partially ordered by (R1, Q1) ≤ (R2, Q2) ⇔ R1 ⊆ R2 ⇔ Q2 ⊆q Q1.
This partial ordering forms a complete lattice called the graph concept lattice.
There is a distinct lattice for each arity.

Graph-FCA has been applied to syntactic representations of texts, either for
mining linguistic patterns [10] or for information extraction [2]. It has also been
applied to knowledge graphs through the notion of concepts of neighbors for
approximate query answering [9] and for link prediction [14].

Classical FCA is a special case of Graph-FCA when only 1-tuples (i.e., sin-
gletons) are used, for the incidence relation, the projected variables of PGPs,
and hence for concepts. This implies that PGPs and concept intents have the
shape ((x), ({a1(x), . . . , ap(x)})), they use a single variable x, and hence they
are equivalent to sets of attributes {a1, . . . , ap}. Concept extents are then sets
of singleton objects, which are equivalent to sets of objects.

3 Graph-PS: Extending Graph-FCA with Pattern

Structures

For concision sake, we reuse the terms of Graph-FCA in Graph-PS as the graph
structure remains, and only the description of nodes and edges are aﬀected by
the extension. In the following, we ﬁrst deﬁne graph contexts as a common

Graph-FCA Meets Pattern Structures

5

generalization of Graph-FCA contexts and pattern structures. Then, we deﬁne
Projected Graph Patterns (PGP) and operations on them as they play the role
of concept intents. Finally, we deﬁne graph concepts, their formation through a
Galois connection, and their organization into a lattice.

3.1 Graph Context

Deﬁnition 1 (graph context). A graph context is a triple K = (O, (D, (cid:117)), δ),
where O is a set of objects, D is a meet-semi-lattice of descriptions, and
δ ∈ O∗ → D is a mapping taking each tuple of objects to its description.
The meet operator (cid:117) on descriptions entails a smallest description ⊥ (called
the empty description), and a partial ordering (cid:118) (called subsumption), deﬁned
for all descriptions c, d ∈ D as c (cid:118) d ⇐⇒ c (cid:117) d = c.

Compared to Graph-FCA, each hyperedge is mapped to one description in-
stead of to zero, one or several attributes. Graph-FCA is therefore equivalent to
the special case of Graph-PS where descriptions are sets of attributes. An hy-
peredge that is mapped to the empty description is considered as a non-existent
relationship: δ((o1, o2)) = ⊥ means that there is no relation from o1 to o2; in
other words, the pair (o1, o2) is nothing more than a pair of objects. This can
be paralleled with the blank cells ((o, a) (cid:54)∈ I) in a classical formal context.

Compared to PS, descriptions can not only be attached to objects but also to
tuples of objects, which enables to express relationships between objects. Those
relationships are taken into account, in addition to PS-like descriptions, when
forming concepts. Concepts are sets of objects that have similar descriptions, and
that also have similar relationships to objects that have similar descriptions, and
so on.

Example 1. As an example of graph context Kex , we extend an example from
Graph-FCA about the British royal family, introducing taxonomic relationships
between attributes, and numeric invervals. The objects are people belonging to
three generations.

Oex := {Charles, Diana, W illiam, Harry, Kate, George, Charlotte}

They are respectively abbreviated as C, D, W, H, K, G, A. Objects (people) are
described by a pair made of their gender and their birth year:

δ(C) = man : 1948,

δ(D) = woman : 1961,

δ(W ) = man : 1982,

δ(K) = woman : 1982,

δ(H) = man : 1984,

δ(G) = man : 2013,

δ(A) = woman : 2015.

Pairs of objects are described whether the second is a parent of the ﬁrst, and
with the rank among siblings.

δ(W, C) = parent : 1

δ(H, C) = parent : 2

(same for D in place of C)

δ(G, W ) = parent : 1

δ(A, W ) = parent : 2

(same for K in place of W)

6

S. Ferré

For instance, δ(W, C) = parent : 1 tells that William is the ﬁrst child of Charles.
Any other tuple of objects has the empty description: δ(o) = ⊥.

We want to take into account similarities between attributes and values. First,
we deﬁne the similarity between genders, man (cid:117) woman = person, saying that
men and women have in common to be persons. Second, like in [18], we deﬁne
the similarity between two numeric values as the smallest interval that contains
the two values: e.g., 1 (cid:117) 3 = [1, 3]. This extends to intervals by using the convex
hull of two intervals, considering a value v as equivalent to the interval [v, v].

[u1, v1] (cid:117) [u2, v2] = [min(u1, u2), max(v1, v2)]

However, to avoid intervals that are too large and hence meaningless, intervals
[u, v] s.t. v − u > (cid:15) are generalized into the symbol ∗ that represents the range
of all possible values. The threshold (cid:15) depends on the type of values: (cid:15) = 20 for
birth years so that similarity means “in the same generation”, and (cid:15) = 1 for birth
ranks. To summarize, the set of descriptions in our example is deﬁned as:

Dex := {a : [u, v], a : ∗ | a ∈ {person, man, woman, parent}, u ≤ v ∈ Z} ∪ {⊥},

with a : v as a shorthand for a : [v, v], and ⊥ the empty description. The similarity
operator d = d1 (cid:117) d2 is deﬁned as follows. If d1 = ⊥ or d2 = ⊥ then d = ⊥,
otherwise, d1 = a1 : V1 and d2 = a2 : V2. Then, if the attribute similarity a1 (cid:117) a2
is deﬁned as attribute a, then d = a : V where V = V1 (cid:117) V2 as deﬁned above
(cid:3)
with the (cid:15) threshold depending on the attribute, else d = ⊥.

3.2 Projected Graph Patterns (PGP)

A graph pattern over a graph context shares the same structure as a graph
context, with nodes and hyperedges labelled by descriptions, except that nodes
are variables that range over the objects of the context.

Deﬁnition 2 (graph pattern). Let K = (O, (D, (cid:117)), δ) be a graph context. A
graph pattern over K is a pair P = (V, δP ), where V ⊆ V is a ﬁnite set of
variables (nodes), and δP ∈ V ∗ → D is a mapping taking each hyperedge to its
description (hyperedge label).

Compared to Graph-FCA, hyperedges are labelled by custom descriptions
rather than by sets of attributes. An embedding of a graph pattern in a graph
context is a mapping φ ∈ V → O from pattern variables to context objects such
that for each hyperedge x, the pattern description of the edge subsumes the
context description of the corresponding edge, i.e. δP (x) (cid:118) δ(φ(x)).

Example 2. Given the graph context in Example 1, we introduce the example
graph pattern Pex = ({x, y}, δP ), where the description δP is deﬁned as follows:

δP (x) = man : [1980, 1989],

δP (y) = person : ∗,

δP (x, y) = parent : [1, 2].

Graph-FCA Meets Pattern Structures

7

This description can be more concisely written as follows:

δP = {x (cid:55)→ man : [1980, 1989], y (cid:55)→ person : ∗, (x, y) (cid:55)→ parent : [1, 2]}.

This pattern represents the situation where a man born in the eighties (x) is
the ﬁrst or second child of some person with unconstrainted birthdate (y). The
pattern has four embeddings in the context, e.g. {x (cid:55)→ Harry, y (cid:55)→ Diana}
because Harry is a man born in 1984, and is the second child of Diana, who is a
(cid:3)
woman and hence a person.

A Projected Graph Pattern (PGP) is a graph pattern with a tuple of distin-

guished variables, called projected variables.

Deﬁnition 3 (PGP). A projected graph pattern (PGP) is a couple Q = (x, P )
where P = (V, δ) is a graph pattern, and x ∈ V ∗, called projection tuple, is a
tuple of variables from the pattern. |Q| = |x| denotes the arity of the PGP. We
note Q the set of PGPs, and Qk the subset of k-PGPs, i.e. PGPs having arity k.

A PGP can be seen as a SPARQL query SELECT x FROM { P }, whose
answers are the embeddings of the pattern restricted to the projected variables.

Example 3. The PGP Qex = ((x), Pex ) based on the graph pattern in Example 2
selects all men born in the eighties as the ﬁrst or second child of somebody. The
answers over the example context are therefore Harry and William. The PGP
(cid:3)
((x, y), Pex ) would select pairs (child, parent), such as (Harry, Diana).

In Graph-FCA and Graph-PS, PGPs play the role of descriptions in PS. We
therefore have to deﬁne two key operations on them: inclusion ⊆q (aka. sub-
sumption) and intersection ∩q (aka. similarity). In Graph-PS, their deﬁnitions
depend on the corresponding operations on PS-like descriptions, (cid:118) and (cid:117).

Deﬁnition 4 (PGP inclusion). Let K = (O, (D, (cid:117)), δ) be a graph context. Let
Q1 = (x1, (V1, δ1)), Q2 = (x2, (V2, δ2)) be two k-PGPs for some arity k. Q1 is
included in Q2, or equivalently Q2 contains Q1, which is written Q1 ⊆q Q2 iﬀ

∃φ ∈ V1 → V2 : φ(x1) = x2 ∧ ∀y ∈ V ∗

1 : δ1(y) (cid:118) δ2(φ(y))

According to this deﬁnition, the inclusion of Q1 into Q2 is analogous to the
embedding of a pattern into a context, with the diﬀerence that variables are
mapped to the variables of another pattern instead of the objects of the context.
There is also the additional constraint that the projected variables match.

Example 4. For example, the PGP Q(cid:48) = ((z), ({z}, {z (cid:55)→ man : ∗})), which se-
lects the set of men, is included in the above PGP Qex , through the embedding
(cid:3)
φ = {z (cid:55)→ x}.

Deﬁnition 5 (PGP intersection). Let ψ be an injective mapping from pairs
of variables to fresh variables. The intersection of two k-PGPs Q1 = (x1, (V1, δ1))
and Q2 = (x2, (V2, δ2)), written Q1 ∩q Q2, is deﬁned as Q = (x, (V, δ)), where

x = ψ(x1, x2),
V = {ψ(v1, v2) | v1 ∈ V1, v2 ∈ V2},
δ(y) = δ1(y1) (cid:117) δ2(y2), for y = ψ(y1, y2) ∈ V ∗

8

S. Ferré

PGP intersection works as a product of two PGPs where each pair of
edges (y1, y2) makes an edge whose description is the similarity δ1(y1) (cid:117) δ2(y2)
between the descriptions of the two edges.
Example 5. The intersection of Qex and Q(cid:48) results in the PGP

Q(cid:48)(cid:48) = ((xz), ({xz, yz}, {xz (cid:55)→ man : ∗, yz (cid:55)→ person : ∗})).

Variables xz and yz result from the pairing of variables from each PGP (func-
tion ψ). The tuples of variables that are not shown in the δP part have
the empty description. For instance, δP ((xz, yz)) = δex ((x, y)) (cid:117) δ(cid:48)((z, z)) =
parent : [1, 2] (cid:117) ⊥ = ⊥.

In Q(cid:48)(cid:48) the description of yz is disconnected from the projected variable xz,
and is therefore useless to the semantics of Q(cid:48)(cid:48). Q(cid:48)(cid:48) can therefore be simpliﬁed to
((xz), ({xz}, {xz (cid:55)→ man : ∗})), which is equal to Q(cid:48) up to renaming variable xz
(cid:3)
as x. More information about such simpliﬁcations are available in [11].

The above example suggests as expected that Q1 ⊆q Q2 implies Q1 ∩q Q2 =
Q1. The following lemma proves that this is indeed the case, like with PS de-
scriptions.

Lemma 1. Let Q1, Q2 be two PGPs. Their PGP intersection Q1 ∩q Q2 is their
inﬁmum relative to query inclusion ⊆q.

Proof. To prove that Q = Q1 ∩q Q2 is a lower bound, it suﬃces to prove that
Q is included in both Q1 and Q2. To prove Q ⊆q Q1, it suﬃces to choose the
mapping φ1(x) = (ψ−1(x))[1] (recall that ψ is an injective mapping from 2-tuples
of variables to variables), and to prove that φ1(x) = x1 and δ(y) (cid:118) δ1(φ1(y)) for
all y ∈ V ∗. This is easily obtained from the deﬁnition of Q. The proof of Q ⊆q Q2
is identical with φ2(x) = (ψ−1(x))[2].

To prove that Q1 ∩q Q2 is the greatest lower bound (the inﬁmum), we have
to prove that every PGP Q(cid:48) that is included in both Q1 (via φ1) and Q2
(via φ2) is also included in Q. To that purpose, it suﬃces to choose φ(x(cid:48)) =
ψ(φ1(x(cid:48)), φ2(x(cid:48))), and to prove that φ(x(cid:48)) = x and δ(cid:48)(y(cid:48)) (cid:118) δ(φ(y(cid:48))) for all y(cid:48).
(cid:3)
This can be obtained from the deﬁnition of Q, and from the hypotheses.

3.3 Graph Concepts

As usual in FCA, concepts are composed of an extent and an intent. In Graph-PS
like in Graph-FCA, k-PGPs in Qk play the role of intents. For the extents we use
the answers of PGPs seen as queries, i.e. sets of tuples of objects. The latter are
mathematically k-ary relations over objects: R ⊆ Ok, for some arity k ≥ 0. We
note Rk = 2Ok
the set of k-relations over the objects of some graph context K.
Example 6. The set of father-mother-child triples can be represented as the fol-
lowing 3-relation (with abbreviated people names).

R := {(C, D, W ), (C, D, H), (W, K, G), (W, K, A)}

Note that the order of objects in tuples matters while the order of tuples in the
relation does not. A k-relation can be seen as a table with k unlabeled columns.

Graph-FCA Meets Pattern Structures

9

Charles Diana William
Charles Diana Harry
William Kate George
William Kate Charlotte

Before deﬁning the Galois connection between PGPs and relations, we in-
troduce the notion of graph description γ(o) of an object or a tuple of objects.
It incorporates everything that is known about an object or tuple of objects, in
terms of relationships in the graph context around those objects, and in terms
of D-description of those relationships. It therefore integrates the description δ
of individual hyperedges.

(cid:3)

Deﬁnition 6 (graph
con-
text K = (O, (D, (cid:117)), δ), the graph description of any object o ∈ O is
deﬁned as the PGP γ(o) := ((o), PK) where PK = (O, δ). By extension, the
description of any tuple of objects o ∈ O∗ is deﬁned as γ(o) := (o, PK).

description).

Given

graph

a

This deﬁnition says that the graph description of an object is the whole
graph context, seen as a graph pattern (objects as variables), and projected on
the object. In practice, only the part of the graph context that is connected to
the object is relevant. The generalization to tuples of objects enables to have a
description for pairs of objects, triples of objects, and so on.

From there, we can deﬁne two derivation operators between PGPs and rela-

tions, and prove that they form a Galois connection.

Deﬁnition 7 (extension). Let K = (O, (D, (cid:117)), δ) be a graph context. The ex-
tension of a k-PGP Q ∈ Qk is the k-relation deﬁned by

ext(Q) := {o ∈ Ok | Q ⊆q γ(o)}

The extension of a k-PGP is the set of k-tuples of objects whose graph
description contains the PGP. It can be understood as the set of answers of the
PGP seen as a query.

Example 7. In the example context, the extension of the 2-PGP

Q = ((x, y), ({x, y}, {x (cid:55)→ person : ∗, y (cid:55)→ woman : ∗, (x, y) (cid:55)→ parent : 1}))

is the 2-relation

R = ext(Q) = {(W illiam, Diana), (George, Kate)},

i.e. the set of pairs (ﬁrst child, mother).

(cid:3)

Deﬁnition 8 (intension). Let K = (O, A, I) be a graph context. The intension
of a k-relation R ∈ Rk is the k-PGP deﬁned by

int(R) :=

γ(o)

(cid:92)

o∈R

10

S. Ferré

The intension of a k-relation is the PGP intersection of the graph descriptions
of all tuples of objects in the relation, hence the most speciﬁc projected graph
pattern shared by them.

Example 8. In the example context, the intension of the 2-relation from Exam-
ple 7

R = {(W illiam, Diana), (George, Kate)}

is the 2-PGP

Q = int(R) = ((x, y), ({x, y, z, w}, δP ))

where δp = {x (cid:55)→ man : ∗, y (cid:55)→ woman : ∗, z (cid:55)→ man : ∗, w (cid:55)→ person : ∗,
(x, y) (cid:55)→ parent : 1, (x, z) (cid:55)→ parent : 1, (w, y) (cid:55)→ parent : 2, (w, z) (cid:55)→ parent : 2}.
Note that this intension expands the PGP in Example 7 with the following
elements: x is a man, x is the ﬁrst child of some man z, his father, and there is a
second child w of parents y and z. The extension of this expanded PGP remains
(cid:3)
the relation R, which suggests that int ◦ ext is a closure operator.

We can actually prove that ext and int form a Galois connection. This implies
that int ◦ ext and ext ◦ int are closure operators, respectively on PGPs and
relations.

Theorem 1 (Galois connection). Let K = (O, (D, (cid:117)), δ) be a graph con-
text. For every arity k, the pair of mappings (ext, int) forms a Galois connec-
tion between (Rk, ⊆) and (Qk, ⊆q), i.e. for every object relation R ∈ Rk and
PGP Q ∈ Qk,

R ⊆ ext(Q) ⇐⇒ Q ⊆q int(R)

Proof. R ⊆ ext(Q) ⇐⇒ ∀o ∈ R : o ∈ ext(Q)
⇐⇒ ∀o ∈ R : Q ⊆q γ(o)
(cid:84)
⇐⇒ Q ⊆q
⇐⇒ Q ⊆q int(R)

(Deﬁnition 7)

(Deﬁnition 8)

(Lemma 1)

o∈R γ(o)

(cid:3)

From the Galois connection, graph concepts can be deﬁned and organized into
concept lattices, like in classical FCA, with one concept lattice for each arity k.

Deﬁnition 9 (graph concept). Let K = (O, (D, (cid:117)), δ) be a graph context. A
k-graph concept of K is a pair (R, Q), made of a k-relation (the extent) and a
k-PGP (the intent), such that R = ext(Q) and Q =q int(R).

Example 9. The 2-relation and 2-PGP in Example 8 form a 2-graph concept. It
can be understood as the (ﬁrst child, mother) binary relationship. Its intent tells
us that in the example context, every ﬁrst child whose mother is known also has
(cid:3)
a known father, and a sibling (man or woman) that was born after him.

Theorem 2 (graph concept lattices). The set of graph k-concepts Ck, par-
tially ordered by ≤, which is deﬁned by

(R1, Q1) ≤ (R2, Q2) : ⇐⇒ R1 ⊆ R2 ⇐⇒ Q2 ⊆q Q1,

forms a bounded lattice (Ck, ≤, ∧, ∨, (cid:62), ⊥), the k-graph concept lattice.

Graph-FCA Meets Pattern Structures

11

Fig. 1. The 1-graph concept lattice of the royal family context (less the bottom con-
cept). The descriptor parent:1 a _ in box Q5g reads δP 5(a, g) = parent : 1, as part of
the graph pattern P 5 of the intent of concept Q5g. The nodes of pattern P 5 are the
boxes Q5a-g.

Figure 1 is a representation of the 1-graph concept lattice – less the bottom
concept – of the royal family graph context from Example 1. This is a compact
representation because each box represents at the same time a 1-concept and a
node of the graph pattern of a concept intent. Each box is made of three parts:

1. A concept/node identiﬁer Qnx made of a number n and a letter x. The
number identiﬁes a pattern Pn, and the letter identiﬁes a node of this pattern.
Together they form the concept intent Qn = (x, Pn). The set of nodes Vn
of pattern Pn = (Vn, δPn ) is therefore made of all boxes whose identiﬁer has
Qn as a preﬁx. (Some concepts also have an informal description under the
identiﬁer, manually added to help the reading of the lattice.)

2. A list of pattern hyperedges in the form d y1

. . . yn, to be read as
δPn (y1, . . . , yn) = d, where an underscore _ refers to the current node x.

12

S. Ferré

A 1-edge d _ is abbreviated as d as it corresponds to an attribute in classi-
cal FCA.

3. A list of objects composing the concept extent.

A k-concept with k > 1 can be read by selecting k diﬀerent boxes that belong
to the same pattern. The graph pattern is the same, whatever the nodes chosen
as projected variables, so the concept intent can be read like for 1-concepts.
However, the concept extent cannot be read exactly from this representation, it
is a subset of the Cartesian product of the extents of the selected boxes.

Example 10. Given the way diﬀerent concepts share the same graph pattern in
their intent, it makes sense to interpret the concept lattice in Figure 1 pattern
by pattern.

– Pattern P3 is a about a person born at any time. It has a single node a, hence
there is a single concept Q3a, the concept of all persons in the context. It is
the top concept.

– Pattern P1 is the reﬁnement of P3 on women.
– Pattern P4 is the reﬁnement of P3 on men.
– Pattern P2 is the reﬁnement of P3 on people born in the eighties.
– Pattern P5 has 7 nodes (a-g). It is about a man (a) that is the ﬁrst child
of two parents, a man (d) and a woman (c), and about another person (b)
that is the second child of the same parents. Those nodes respectively corre-
spond to the concepts of “male ﬁrst child” (Q5a), “father” (Q5d), “mother”
(Q5c), and “second child” (Q5b). The other nodes in the pattern actually
deﬁne generalizations of those concepts for which the a-b-c-d pattern is al-
ways present in the context: “parent” (Q5g), “male child” (Q5e), and “child”
(Q5f). It can be observed that the latter concepts (e-g) are in a lighter color
and the former concepts (a-d) are in a more vivid color (called core concept-
s/nodes [11]). When reading a concept intent, the boxes in a lighter color can
be ignored when they are not selected because the information they provide
is redundant with the core nodes.

– The core nodes of pattern P6 reproduce the graph context, each node corre-
sponding to a speciﬁc object. The non-core concepts provide generalizations
over single objects: “grand-parents born between 1948 and 1961” (Q6i), “par-
ents born in 1982” (Q6h), “children born between 1982 and 1984” (Q6j), and
“grand-children born between 2013 and 2015” (Q6k).

From the concept lattice structure, it is possible to ﬁnd what diﬀerent people
have in common. For instance, from Q6d ∨ Q6g = Q5f , we learn that what
William (Q6d) and Charlotte (Q6g) have in common is that they are persons
with a father (Q5d, Charles or William) and a mother (Q5c, Diana or Kate) who
have together a male ﬁrst child (Q5a, William or George), and a second child
(Q5b, Harry or Charlotte). We also learn that they share that with Harry and
(cid:3)
George, the other instances of concept Q5f.

Graph-FCA Meets Pattern Structures

13

4 Application to RDFS Graphs

As an application case of Graph-PS we consider RDFS graphs. An RDFS graph
is a structure (cid:104)R, L, (C, ≤), (P, ≤), T (cid:105), where R is a collection of resources (IRIs
and blank nodes), L is a set of literal values of various datatypes (e.g., strings,
numbers, dates), C is a hierarchy of classes, P is a hierarchy of properties, and
T is a set of triples expressing the factual knowledge.

In order to apply Graph-PS to RDFS graphs, we need to identify what are the
objects, the descriptions, and the similarity between descriptions. From the usual
RDFS graph representation that uses resources, literals, and classes as nodes, it
is tempting to use them as objects. However, it is desirable to deﬁne similarity
over literals and classes. The similarity between two integer literals could be an
interval like in the example of the previous section. The similarity between two
classes should be the most speciﬁc common ancestor class. Moreover, we think
that literals and classes are more appropriate as descriptors of objects than as
objects to be described. We therefore deﬁne the set of object as O = R.

We now look at the description of (tuples of) objects. The description in-
formation lies in the triples. We deﬁne below their conversion into elementary
descriptions, according to the three kinds of triples.

– (r, rdf:type, c) (cid:32) δ(r) = {c, . . .}

The triple states that resource r is an instance of class c. The class is used
as a descriptor of the resource, rdf:type can be ignored because it is always
used with a class. We use an open set containing c because a resource can
be declared an instance of several classes.

– (r, p, r(cid:48)) (cid:32) δ(r, r(cid:48)) = {p, . . .}

The triple states that resource r is related to resource r(cid:48) with property p. The
property is used as a descriptor of the pair of resources, hence representing a
binary edge. We again use an open set because RDFS graphs are multigraphs,
i.e. several properties can relate the same resources (e.g., a person who is
both the director and an actor of some ﬁlm).

– (r, p, l) (cid:32) δ(r) = {p : l, . . .}

The triple states that resource r is related to literal l with property p. Both
the property and literal are descriptors, so they must be combined into a
composite descriptor, similarly to the example of previous section. We again
use an open set because RDFS properties can be multi-valued, and also
because resources also have classes as descriptors.

To summarize, the set of descriptions can be deﬁned as follows.

D = D1 ∪ D2 where D1 = 2C × 2P×L and D2 = 2P

D1 is the set of descriptions of individuals resources, where a description is
a pair made of a set of classes, and a set of valued properties. D2 is the set of
descriptions of edges between resources, where a description is a set of properties.
The empty description is therefore simply the empty set: ⊥ = ∅. From there, we

14

S. Ferré

can formally deﬁne the description of every resources and pairs of resources.

δ(r) = ({c | (r, rdf:type, c) ∈ T }, {p : l | (r, p, l) ∈ T, l ∈ L})

δ(r, r(cid:48)) = {p | (r, p, r(cid:48)) ∈ T, r(cid:48) ∈ R}

It remains to deﬁne the similarity operator (cid:117) over descriptions. As our de-
scriptions of RDFS resources are based on sets of elementary descriptors, we
derive similarity on sets from similarity on elements. We can allow the similarity
between two elements to be a set of elements, the least general generalizations
(lgg). This set-based approach has already been used in Pattern Structures, e.g.
for graphs and subgraphs [16]. On classes and properties, we have a partial
ordering ≤ from which the lgg operator can deﬁned as follows:

lgg(x, y) := M in≤{z ∈ X | x ≤ z, y ≤ z}

On literals, given that L is in general inﬁnite, it is more convenient to assume
the lgg operation to be deﬁned, and to derive the partial ordering from it: x ≤
y ⇐⇒ lgg(x, y) = {y}. Here are a few examples on how lgg could be deﬁned
on literals:

– lgg(10, 20) = {[10, 20]},
– lgg([10, 30], [25, 50]) = {[10, 50]},
– lgg("Formal Concept Analysis", "Relational Concept Analysis") =

{"Concept", "Analysis"}.

Of course, this assumes to extend the set of literals L with all patterns that
may be generated by the lgg operator, e.g. intervals. On valued properties the
lgg operator can be obtained by combining the lgg operators on properties and
literals.

lgg(p(cid:48) : l(cid:48), p(cid:48)(cid:48) : l(cid:48)(cid:48)) = {p : l | p(cid:48) ∈ lgg(p(cid:48), p(cid:48)(cid:48)), l ∈ lgg(l(cid:48), l(cid:48)(cid:48))}

Each lgg operator can be lifted to the PS similarity operator on sets of elements
by collecting all least general generalizations of elements pairwise, and then
ﬁltering them to keep only the most speciﬁc ones.

d(cid:48) (cid:117) d(cid:48)(cid:48) = Min ≤{x ∈ lgg(x(cid:48), x(cid:48)(cid:48)) | x(cid:48) ∈ d(cid:48), y(cid:48) ∈ d(cid:48)(cid:48)}

This is enough to deﬁne similarity on D2-descriptions, which are sets of prop-
erties. On D1-descriptions, similarity can be deﬁned element-wise as they are
pairs (C, P L) of sets of elementary descriptors: C is a set of classes, and P L is
a set of valued properties.

(C (cid:48), P L(cid:48)) (cid:117) (C (cid:48)(cid:48), P L(cid:48)(cid:48)) = (C (cid:48) (cid:117) C (cid:48)(cid:48), P L(cid:48) (cid:117) P L(cid:48)(cid:48))

Finally, the similarity between a D1-description and a D2-description is sim-
ply the empty description ⊥, although Graph-PS only applies similarity to the
descriptions of tuples of objects with the same arity.

Graph-FCA Meets Pattern Structures

15

5 Conclusion and Perspectives

We have introduced a new extension of Formal Concept Analysis that merges
two existing FCA extensions, Pattern Structures (PS) and Graph-FCA. In short,
PS-like descriptions are used to describe the nodes and hyperedges of graphs,
in place of sets of attributes. The new extension therefore combines the beneﬁts
of the two existing extensions: complex descriptions and relationships between
objects. A strength of Graph-PS is that it is a proper generalization of PS and
Graph-FCA, in the sense that PS and Graph-FCA – as well as FCA – are spe-
cial cases of Graph-PS. Hence, all previous work about deﬁning custom pattern
structures can be reused in Graph-PS, and the compact graphical representa-
tions of concept lattices in Graph-FCA can be reused in Graph-PS. We have also
shown that Graph-PS can accurately represent existing graph-based models like
RDFS graphs.

This paper focuses on the theoretical aspects of Graph-PS, and the most
immediate perspectives concern its implementation and its applications. The
implementation could be adapted from the existing implementation of Graph-
FCA [7], by taking into account the similarity operator (cid:117) in the PGP operations
⊆q and ∩q. The additional cost of using Graph-PS in PS and Graph-FCA set-
tings should be evaluated. A toolbox of components should be built in order
to facilitate the design of new sets of descriptions, by capitalizing on previous
applications of pattern structures, and by adopting the methodology of logic
functors [13]. In the end, we plan to experiment Graph-PS in diverse knowledge
graphs and other complex structures like sequences and trees.

References

1. Alam, M., Buzmakov, A., Napoli, A.: Exploratory knowledge discovery over web

of data. Discrete Applied Mathematics 249, 2–17 (2018)

2. Ayats, H., Cellier, P., Ferré, S.: Extracting relations in texts with concepts of neigh-
bours. In: Formal Concept Analysis. pp. 155–171. LNCS 12733, Springer (2021)
3. Baader, F., Calvanese, D., McGuinness, D.L., Nardi, D., Patel-Schneider, P.F.
(eds.): The Description Logic Handbook: Theory, Implementation, and Applica-
tions. Cambridge University Press (2003)

4. Baixeries, J., Kaytoue, M., Napoli, A.: Characterizing functional dependencies in
formal concept analysis with pattern structures. Annals of Mathematics and Arti-
ﬁcial Intelligence 72, 129–149 (2014)

5. Belohlavek, R.: Fuzzy closure operators. Journal of Mathematical Analysis and

Appl. 262, 473–489 (2001)

6. Chaudron, L., Maille, N.: Generalized formal concept analysis. In: Mineau, G.,
Ganter, B. (eds.) Int. Conf. Conceptual Structures. LNCS 1867, Springer (2000)
7. Ferré, S., Cellier, P.: Modeling complex structures in Graph-FCA: Illustration on
natural language syntax. In: Existing Tools and Applications for Formal Concept
Analysis (ETAFCA). pp. 1–6 (2022)

8. Ferré, S.: A proposal for extending formal concept analysis to knowledge graphs.
In: Baixeries, J., Sacarea, C., Ojeda-Aciego, M. (eds.) Int. Conf. Formal Concept
Analysis (ICFCA). pp. 271–286. LNCS 9113, Springer (2015)

16

S. Ferré

9. Ferré, S.: Answers partitioning and lazy joins for eﬃcient query relaxation and
application to similarity search. In: Gangemi, A., et al. (eds.) The Semantic Web
(ESWC). pp. 209–224. LNCS 10843, Springer (2018)

10. Ferré, S., Cellier, P.: Graph-FCA in practice. In: Haemmerlé, O., et al. (eds.) Int.
Conf. Conceptual Structures (ICCS). pp. 107–121. LNCS 9717, Springer (2016)
11. Ferré, S., Cellier, P.: Graph-FCA: An extension of formal concept analysis to knowl-

edge graphs. Discrete Applied Mathematics 273, 81–102 (2019)

12. Ferré, S., Ridoux, O.: A logical generalization of formal concept analysis. In:
Mineau, G., Ganter, B. (eds.) Int. Conf. Conceptual Structures. pp. 371–384. LNCS
1867, Springer (2000)

13. Ferré, S., Ridoux, O.: A framework for developing embeddable customized logics.
In: Pettorossi, A. (ed.) Int. Work. Logic-based Program Synthesis and Transfor-
mation. pp. 191–215. LNCS 2372, Springer (2002)

14. Ferré, S.: Application of concepts of neighbours to knowledge graph completion.

Data Science: Methods, Infrastructure, and Applications 4, 1–28 (2021)

15. Ferré, S., Kaytoue, M., Huchard, M., Kuznetsov, S.O., Napoli, A.: A guided tour of
artiﬁcial intelligence research, vol. II, chap. Formal Concept Analysis: from knowl-
edge discovery to knowledge processing (Chapter 13), pp. 411–445. Springer (2020)
16. Ganter, B., Kuznetsov, S.: Pattern structures and their projections. In: Delugach,
H.S., Stumme, G. (eds.) Int. Conf. Conceptual Structures. pp. 129–142. LNCS
2120, Springer (2001)

17. Ganter, B., Wille, R.: Formal Concept Analysis — Mathematical Foundations.

Springer (1999)

18. Kaytoue, M., Kuznetsov, S.O., Napoli, A.: Revisiting numerical pattern mining
with formal concept analysis. In: Int. Joint Conf. Artiﬁcial Intelligence (IJCAI)
(2011)

19. Kötters, J.: Concept lattices of a relational structure. In: Pfeiﬀer, H., and others
(eds.) Int. Conf. Conceptual Structures for STEM Research and Education, pp.
301–310. LNAI 7735, Springer (2013)

20. Kuznetsov, S.O., Samokhin, M.V.: Learning closed sets of labeled graphs for chem-
ical applications. In: Kramer, S., Pfahringer, B. (eds.) Int. Conf. Inductive Logic
Programming. pp. 190–208. LNCS 3625, Springer (2005)

21. Lehmann, F., Wille, R.: A triadic approach to formal concept analysis. In: Int.

Conf. Conceptual Structures (ICCS). pp. 32–43. Springer (1995)

22. Poelmans, J., Ignatov, D.I., Kuznetsov, S.O., Dedene, G.: Fuzzy and rough formal

concept analysis: a survey. Int. J. General Systems 43(2), 105–134 (2014)

23. Rouane-Hacene, M., Huchard, M., Napoli, A., Valtchev, P.: Relational concept
analysis: mining concept lattices from multi-relational data. Annals of Mathematics
and Artiﬁcial Intelligence 67(1), 81–108 (2013)

24. Voutsadakis, G.: Polyadic concept analysis. Order 19, 295–304 (2002)

