Regular Matching and Inclusion on Compressed Tree
Patterns with Constrained Context Variables
Iovka Boneva, Joachim Niehren, Momar Sakho

To cite this version:

Iovka Boneva, Joachim Niehren, Momar Sakho. Regular Matching and Inclusion on Compressed
Information and Computation, 2022, 286,
Tree Patterns with Constrained Context Variables.
￿10.1016/j.ic.2021.104776￿. ￿hal-03151014￿

HAL Id: hal-03151014

https://inria.hal.science/hal-03151014

Submitted on 24 Feb 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Regular Matching and Inclusion on Compressed Tree
Patterns with Constrained Context Variables

Iovka Bonevaa, Joachim Niehrenb, Momar Sakhoa,b,∗

aUniversit´e de Lille, Cit´e Scientiﬁque, 59650 Villeneuve d’Ascq, France
bInria Lille - Nord Europe, Parc scientiﬁque de la Haute-Borne, 40 avenue Halley, 59650
Villeneuve d’Ascq

Abstract

We study the complexity of regular matching and inclusion for compressed tree

patterns with context variables subject to regular constraints. Context vari-

ables with regular constraints permit to properly generalize on unranked tree

patterns with hedge variables. Regular inclusion on unranked tree patterns is

relevant to certain query answering on Xml streams with references. We show

that regular matching and inclusion with regular constraints can be reduced in

polynomial time to the corresponding problem without regular constraints.

Keywords:

tree patterns, tree automata, computational complexity, streams,

Xml, grammar compression.

1. Introduction

A pattern is a term with variables describing a string, a tree, or some other

algebraic value. The following generic problems for patterns were widely studied

in the literature:

5

Pattern matching: Is a given algebraic value an instance of a given pattern?

Pattern uniﬁcation: Do two given patterns have some common instance?

(cid:63)This paper extends the LATA’2019 paper [1] with regular constraints.
∗Corresponding author
Email addresses: iovka.boneva@univ-lille.fr (Iovka Boneva),

joachim.niehren@inria.fr (Joachim Niehren), momar.sakho@inria.fr (Momar Sakho)

Preprint submitted to Information and Computation

February 24, 2021

Dfas
Pspace-c
[5]
Pspace-c
[5]

Nfas
Pspace-c
[5]
Pspace-c
[5]

MATCH

INCL

Dfas
P
[5]
P
[5]

Nfas
P
[5]
Pspace-c
[5]

MATCH

INCL

Figure 1:

(Compressed) string patterns.

Figure 2: Linear restriction.

Dtas
NP-c
[6],Th 7,Prop 26
coNP-c
Th 7, Prop 26

Ntas
Exp-c
[6], Th 7, Prop 26
Exp-c
Lem 23, Th 7, Prop 26

MATCH

INCL

Dtas
P
Prop 35
P
Lem 22, Prop 35

Ntas
P
Prop 35
Exp-c
Lem 23, Th 27

MATCH

INCL

Figure 3:

(Compressed) tree patterns without

Figure 4: Linear restriction.

context variables.

Dtas
Pspace-c
Th 27, Prop 28
Pspace-c
Th 27, Prop 28

Ntas
Exp-c
Th 27, Prop 28
Exp-c
Th 27, Prop 28

MATCH

INCL

Dtas
P
Prop 35
P
Lem 22, Prop 35

Ntas
P
Prop 35
Exp-c
Lem 23 , Th 27

MATCH

INCL

Figure 5: (Compressed) tree patterns with (con-

Figure 6: Linear restriction.

strained) context variables.

Regular pattern matching: Does some instance of the given pattern belong

to the given regular language?

Regular pattern inclusion: Do all instances of the given pattern belong to

10

the given regular language?

As inputs, these problems receive descriptors of patterns, values, and regular

languages. Most typically, a string pattern may be described in a compressed

manner by using a singleton context-free grammar (also called straight-line pro-

gram), and a regular string language may be represented by a nondeterministic

15

ﬁnite automaton (Nfa) or by a deterministic ﬁnite automaton (Dfa). The

problem of string pattern matching is well known to be NP-complete for Nfas

[2] but in P for Dfas, with and without compression [3]. The more general

problem of string uniﬁcation is of quite diﬀerent nature. It is known to be in

Pspace [4].

20

Regular inclusion and matching for string patterns was studied by the au-

2

thors on the way to the present paper [5]. Both problems were shown to be

Pspace-complete, both for Dfas and Nfas, with and without compression.

See Fig. 1 for an overview. When restricted to linear string patterns, the com-

plexity goes down to polynomial time in 3 of the 4 cases, as summarized in

25

Fig. 2. The problem which remains Pspace-complete is regular inclusion on

linear string patterns for Nfas.

The complexity landscape of regular matching and inclusion for tree patterns

without context variables looks quite diﬀerent to the case of string patterns, see

Figs. 3 and 4. Here, regular languages are deﬁned by tree automata, which may

30

either be nondeterministic (Ntas) or (bottom-up) deterministic (Dtas). Reg-

ular matching of tree patterns without context variables for Ntas was named

the ground instance intersection problem in [6], where it was shown to be NP-

complete for Dtas and Exp-complete for Ntas. Furthermore it was shown that

the restriction to linear patterns is in P, both for Dtas and Ntas. Regular

35

inclusion for tree patterns has not been studied so far to the best of our knowl-

edge. We show that it is coNP-complete for Dtas and Exp-complete for Ntas

even when restricted to linear tree patterns. Only for Dtas, the problem of

regular inclusion for linear tree patterns is in P. Compression can be added to

tree patterns by using singleton tree grammars [7]. But as we will see, this

40

doesn’t aﬀect the above results. Indeed, all the missing results cited above will

be proven in the present paper with and without compression, as a byproduct

of our main results.

The prime reason for the asymmetry of the complexity landscapes in the case

of strings and trees is that string patterns cannot be encoded as tree patterns

45

with a monadic signature without adding context variables. For instance, the

string pattern aZZbY corresponds to the tree pattern a(Z@(Z@b(Y ))) with

context variable Z, tree variable Y and application symbol @. The interest of

adding context variables to tree patterns was already noticed when generalizing

string pattern matching to context pattern matching [3], which are both NP-

50

complete, with or without compression. The same was noticed when generalizing

string uniﬁcation to context uniﬁcation, that are both in Pspace [8]. Since we

3

are interested in a proper generalization of regular matching and inclusion from

string to tree patterns, we propose to study these problems for tree patterns

with context variables.

55

In this paper, we relate regular matching of tree patterns to inhabitation

problems of tree automata in a systematic manner. The naive semi-decision

procedure for regular matching guesses some context for all the context variables

in the tree pattern and then checks whether the instance of the pattern obtained

thereby matches the regular language, i.e. whether it is recognized by the tree

60

automaton deﬁning this language. In order to avoid inﬁnite guesses, our decision

algorithm will guess for all context variables a function of type Q → 2Q where

Q is the set of states of the tree automaton, and then test whether this function

is inhabited by some context with respect to the automaton. In order to make

this approach work, we need to study the problem of context inhabitation on

65

its own right.

Our ﬁrst contribution is therefore the formal deﬁnition of the problem of

context inhabitation for tree automata and the study of its complexity. Context

inhabitation is a special case of second-order linear λ-deﬁnability, except that

the input function is represented in a succinct manner. More generally, λ-

70

deﬁnability is known to be decidable up to the order of three [9], while it is

undecidable in general [10, 11]. Context inhabitation for tree automata can also

be understood as a generalization of transition inhabitation for word automata,

which is sometimes called the membership problem of the transition monoid [12].

We show that context inhabitation for Ntas is Exp-complete. The lower bound

75

is obtained by a reduction from the nonemptiness problem of intersections of

a ﬁnite number of Ntas [13], and the upper bound by a novel algorithm using

determinization. We then show that context inhabitation for Dtas is Pspace-

complete. This result may be surprising1. We obtain the Pspace upper bound

1We wrongly stated in the LATA’2019 version of the present paper that the problems of
context inhabitation, regular matching and regular inclusion are Exp-complete for Dtas. We
correct this error here, showing that all these problems are Pspace-complete.

4

by a nontrivial reduction to the nonemptiness problem of intersections of a ﬁnite

80

number of Dfas (for words) [12]. The fact that automata on words are enough

for this purpose rather than automata for trees explains the otherwise surprising

Pspace upper bound.

The second contribution of the present paper is the study of the complexity

of regular matching and inclusion for compressed tree patterns with context

85

variables. All our results are based in a systematic manner on the close rela-

tionship between regular matching of tree patterns with context variables and

context inhabitation for tree automata. They are summarized in Figs. 5 and 6.

The only change compared to compressed string patterns is for Ntas, where the

complexity increases from Pspace-complete to Exp-complete. The main rea-

90

son for this change is that the context inhabitation for Ntas is Exp-complete.

In contrast, for Dtas context inhabitation remains Pspace-complete, so that

there is no diﬀerence to the case of Dfas.

The third contribution is the extension of regular matching and inclusion

with regular constraints on the possible instantiations of the variables of the

95

pattern.

Regular pattern matching with regular constraints: Does some instan-

tiation of the variables satisfying the given regular constraints produce an

instance of the given pattern that belongs to the given regular language?

Regular pattern inclusion with regular constraints: Do all instantiations

100

of the variables satisfying the given regular constraints produce some in-

stance of the given pattern that belong to the given regular language?

We show that the extended problems with regular constraints can be compiled

to the original problems without constraints in polynomial time. Our reduction

preserves the determinism of the automata and the linearity of the patterns.

105

Therefore all our complexity results on regular matching and inclusion listed

above remain valid when adding regular constraints.

The fourth contribution is an application of these results to regular matching

and inclusion for compressed patterns on unranked trees with tree and hedge

5

variables (but without context variables). We show that the complexity results

110

carry over. The idea is that unranked tree patterns can be encoded to ranked

tree patterns, while mapping hedge variables to context variables. We contribute

a reduction of unranked regular matching and inclusion to the ranked case but

with regular constraints. In order to deal with the unranked symbols, we cannot

bound the maximal arity of the ranked signature. Therefore we have to consider

115

the uniform variant of all problems, where the signature is part of the input

rather than being ﬁxed as a parameter. This complicates the algorithms for the

upper bounds, in the case of context inhabitation in particular.

Our original motivation for the present paper is the problem of certain query

answering on hyperstreams [5], i.e., a special kind of stream with references [14].

120

A hyperstream for unranked trees is nothing else than a compressed pattern with

hedge variables for unranked trees. In the case of Boolean queries deﬁned by tree

automata, the problem of certain query answering on hyperstreams is equal to

the problem of regular inclusion of compressed pattern for unranked trees. The

fourth contribution determines the exact complexity of this problem: it is the

125

same as for regular inclusion of tree patterns with context variables on ranked

trees. In particular, we provide an algorithm to decide certain query answering

on hyperstreams with optimal complexity, through a series of reductions which

ends with context inhabitation for tree automata.

Compared with the conference version at LATA’2019, we added the third

130

contribution (the addition of regular constraints) and used it to prove the fourth

contribution (the case of unranked trees), which was stated without proof before.

We also added uniform variants for all the problems, where the signature is part

of the input rather than being ﬁxed as a parameter, since these are needed too,

to prove our results on unranked tree patterns. The uniformity, however, makes

135

the Pspace upper bound of context inhabitation for Dtas considerably more

diﬃcult to establish. Finally, we added complexity results on the restriction of

regular matching and inclusion to linear patterns in the journal version.

Outline. We recall the syntax and semantics of trees and contexts in Section 2.

We then study tree and context inhabitation for tree automata in Section 3 for

6

140

complexity. Tree patterns with context variables are recalled in Section 4 and

enhanced with compression in Section 5. Our main results on regular matching

and inclusion are given in Section 6. The extension with regular constraints and

how to get rid of them again is discussed in Section 7. Patterns of unranked

trees with hedge variables are then investigated in Section 8. Before concluding,

145

we consider the restricted case of linear tree patterns in Section 9.

2. Trees and Contexts

We recall the notion of trees and contexts and then recall how they can be

interpreted in Σ-algebras. Throughout the paper we consider the two types in

T = {tree, context}.

150

A ﬁnite ranked signature is a tuple Σ = (cid:85)
n≥0

Σ(n) of function symbols f ∈ Σ(n)

of arity n. We assume that any ranked signature contains at least one

constant and one symbol of arity at least 2. This will be needed for the

lower bounds.

The only values we will consider are the trees and contexts constructed over

155

the symbols of a ranked signature. We take an approach based on the λ-terms

– as needed on the way to the ﬁnal application to regular inclusion of unranked

tree patterns – but will not consider values of higher types.

Deﬁnition 1. The set of trees TΣ is the least set that contains all tuples
f (t1, . . . , tn) where f ∈ Σ(n) for some n ≥ 0 and t1, . . . , tn ∈ TΣ.

160

Atomic trees a() ∈ TΣ are deliberately identiﬁed with a ∈ Σ(0).
For deﬁning contexts, we ﬁx an arbitrary nonempty set V tree disjoint from

Σ, whose elements are variables of type tree.

Deﬁnition 2. The set of contexts CΣ is the set of all terms λx.t for some tree
t ∈ TΣ∪{x} where x ∈ V tree occurs exactly once in t, and this with arity 0.

165

We will identify contexts modulo α-renaming so that the choice of variable

x does not matter. This means that the contexts λx.t and λx(cid:48).t[x/x(cid:48)] are equal

for all x, x(cid:48) ∈ V tree . The variable serves as the hole marker of the context.

7

A tree in TΣ is a value of the ﬁrst-order type tree, and a context in CΣ a value
of the linear second-order type context = tree (cid:40) tree. This is the subtype of the

more usual function type tree → tree that is restricted to linear functions using

their argument exactly once. Any context λx.t ∈ CΣ denotes a linear function

since x must occur exactly once in t by deﬁnition. The set of all values of both

types is:

Val Σ = TΣ ∪ CΣ

Adding nonlinear or higher-order λ-terms as values would lead to a quite diﬀer-

ent pattern matching problem.

170

We next present the interpretation of the values of both types in arbitrary

Σ-algebras (including tree automata, as we will see later on). Trees will be

interpreted as elements of the domain of the Σ-algebra, and contexts as linear

functions on this domain.

Deﬁnition 3. A Σ-algebra ∆ = (Σ, D, .∆) consists of a ranked signature Σ, a

175

set D called the domain, and a mapping .∆ that interprets symbols f ∈ Σ(n) as
functions f ∆ : Dn → D. The domain of ∆ is dom∆ = D.

We next deﬁne the interpretation of values in a Σ-algebra. The inter-

pretation of a tree t = f (t1, . . . , tn) ∈ TΣ is the domain element

t1

f ∆(
(cid:74)

(cid:75)

tn

(cid:74)

(cid:75)

∆, . . . ,

∆). This interpretation can be extended to trees over the

signature Σ ∪ D by interpreting any symbol d ∈ D by itself, i.e., d∆ = d. The

∆ =

t
(cid:75)

(cid:74)

interpretation of a context C = λx.t ∈ CΣ is the function

C

∆ : D → D with

C

∆(d) =

∆ for all d ∈ D. The elements of D and functions of type

(cid:75)

(cid:74)
D → D that can be obtained by ∆-interpretation of some tree or context are

(cid:74)

t[x/d]
(cid:75)

(cid:74)

(cid:75)

called ∆-inhabited :

Val Σ

∆ =

TΣ

∆ ∪

∆

CΣ
(cid:74)

(cid:74)

(cid:75)

(cid:75)
The set TΣ of trees can be identiﬁed with the free Σ-algebra (Σ, TΣ, .TΣ )
whose interpretation function satisﬁes f TΣ (t1, . . . , tn) = f (t1, . . . , tn) for all sym-
TΣ
bols f ∈ Σ(n) and trees t1, . . . , tn ∈ TΣ. We note that

TΣ = TΣ while

TΣ

CΣ

(cid:74)

(cid:75)

(cid:74)

(cid:75)

(cid:74)

(cid:75)

180

is a proper subset of functions of type TΣ → TΣ. In other words, the interpre-

tation over the Σ-algebra TΣ converts any context C ∈ CΣ into the function on

8

trees

C

TΣ : TΣ → TΣ that it deﬁnes, i.e., if C = λx.t for some tree t in which

(cid:74)

(cid:75)
x occurs once, then

TΣ (t(cid:48)) = t[x/t(cid:48)] for all t(cid:48) ∈ TΣ.

C

(cid:74)

(cid:75)

3. Inhabitation for Tree Automata

185

One of the insights of this paper will be that inhabitation is closely related

to regular matching and inclusion for tree patterns, depending on the class of

tree automata and the type of variables. Therefore, here we study inhabitation

problems of tree automata on their own right.

3.1. Tree Automata

190

We start by recalling the standard notion of tree automata for ranked trees,

their notion of bottom-up determinism, and their relationship to Σ-algebras also

in the nondeterministic case.

Deﬁnition 4. A (nondeterministic) tree automaton ( Nta) over a ranked sig-

nature Σ is a tuple A = (Q, Σ, F, ∆) where Q is a ﬁnite set of states, F ⊆ Q is

195

the set of ﬁnal states, and ∆ ⊆ ∪n≥0Σ(n) × Qn+1 is the transition relation.

A rule (f, q1, . . . , qn, q) ∈ ∆ is written as f (q1, . . . , qn) → q. We will identify
any transition relation ∆ of some Nta as a Σ-algebra (Σ, 2Q, .∆), that interprets

function symbols f ∈ Σ(n) as the n-ary functions f ∆ that satisfy for any subsets

of states Q1 . . . , Qn ⊆ Q:

f ∆(Q1, . . . , Qn) = {q | ∃q1 ∈ Q1 . . . ∃qn ∈ Qn. f (q1, . . . , qn) → q in ∆}.

It should always be clear from the context whether we consider ∆ as a Σ-algebra

or as a transition relation.

The regular language L(A) recognized by A is deﬁned as the set of all trees

in TΣ whose evaluation in the Σ-algebra ∆ yields some ﬁnal state in F :

L(A) = {t ∈ TΣ |

∆ ∩ F (cid:54)= ∅}.

t
(cid:74)

(cid:75)

The more general concept of inhabitation from Σ-algebras can now be ap-

plied to tree automata, yielding the following deﬁnition:

9

200

Deﬁnition 5 (Inhabitation). Let A = (Q, Σ, F, ∆) be a tree automaton.

• A subset Q(cid:48) ⊆ Q is called ∆-inhabited by a tree t ∈ TΣ if Q(cid:48) =

∆.

t
(cid:74)

(cid:75)

• A function S : 2Q → 2Q is called ∆-inhabited by a context C ∈ CΣ if

205

210

215

S =

C
(cid:74)

∆.
(cid:75)

An Nta is called (bottom-up) deterministic or equivalently a Dta if no two

distinct rules of ∆ have the same left-hand side, i.e., if ∆ is a partial function
from (cid:83)
n≥0

Σ(n)×Qn to Q. The determinization of an Nta A is the tree automaton

det(A) = (2Q, Σ, det(F ),det(∆)) where det(F ) = {Q(cid:48) ⊆ Q | Q(cid:48) ∩ F (cid:54)= ∅} and

det(∆) = {f (Q1, . . . , Qn) → f ∆(Q1, . . . , Qn) | f ∈ Σ(n), Q1, . . . , Qn ⊆ Q}. It
is well known that det(A) is a Dta with L(A) = L(det(A)). Furthermore, for

any tree t ∈ TΣ it holds that

t

det(∆) = {
(cid:75)

t
(cid:75)

∆}.

(cid:74)
An Nta is called complete if for all f ∈ Σ(n) and q1, . . . , qn ∈ Q, there exists

(cid:74)

a state q so that the rule f (q1, . . . , qn) → q is in ∆.

Let NtaΣ be the set of all Ntas with signature Σ, and DtaΣ the set of
all Dtas with signature Σ. Clearly, DtaΣ ⊆ NtaΣ. A class of automata is a
function that maps any signature Σ to a subset of NtaΣ. In particular, Nta
and Dta are classes of automata mapping signature Σ to the sets of automata
NtaΣ and DtaΣ.

In the next subsections, we introduce and study the decision problem of con-

text inhabitation, and its relationship to the problem of intersection nonempti-

220

ness. We distinguish the cases of Ntas and Dtas. In both cases, we consider

the non-uniform version where the signature Σ is ﬁxed as a parameter of the

problem, and the uniform version where the signature is given with the input.

An overview of the results on context inhabitation is given in Fig. 8. Con-

text inhabitation for nondeterministic tree automata Inhabcontext

Σ

(Nta) is Exp-

225

complete, while the deterministic restriction, Inhabcontext

Σ

(Dta) is Pspace com-

plete. This might be surprising given that intersection nonemptiness is Exp-

complete for tree automata, while it is Pspace-complete for ﬁnite automata on

words, in both cases independently of determinism (see Fig. 7).

10

Indeed, we will establish a close correspondence for tree automata between

230

the problem of context inhabitation Inhabcontext
(Nta) and the problem of in-
tersection nonemptiness InterΣ(Dta). The surprising result will come from

Σ

another close relationship between context inhabitation for deterministic tree

automata Inhabcontext
terministic ﬁnite automata for words InterΣ(Dfa).

Σ

(Dta) and the intersection nonemptiness problem of de-

235

3.2. Intersection NonEmptiness

For any class of automata A and any signature Σ, the non-uniform version

of intersection nonemptiness for a ﬁnite number of automata is the following

problem.

InterΣ(A).

Input: a ﬁnite number of automata A1, . . . , An ∈ AΣ where n ≥ 0.

Output: whether ∩n

i=1L(Ai) (cid:54)= ∅.

240

The uniform variant of this problem where the signature Σ is passed as an

input is called Inter(A). Analogous problems can be deﬁned for classes of

ﬁnite automata on words, i.e. nondeterministic ﬁnite automata (Nfas) and

deterministic ﬁnite automata (Dfas).

In Fig. 7 we recall the complexities of the problems InterΣ(A) in the cases

245

of deterministic and nondeterministic automata on trees and words, i.e.

for

A ∈ {Nta, Dta, Nfa, Dfa}. The results hold both for the uniform and the

non-uniform variants.

In the case of trees, the hardness result requires our

assumption that the signature Σ contains at least one constant and one symbol

of arity greater than or equal to 2.

250

3.3. Tree Inhabitation

Before moving to context inhabitation, we reconsider known results on the

easier problem of tree inhabitation, that will be instructive for what follows.

For any class of automata A and any signature Σ, tree inhabitation is the

following problem:

11

deterministic

Dfas:

nondeterministic Nfas:

words
Pspace-c
[12]
Pspace-c
[12]

trees

Exp-c
[13]
Exp-c
[13]

Dtas:

Ntas:

Figure 7: Emptiness of intersection of a ﬁnite number of automata.

Tree

Context

Dtas
P
Th 7
Pspace-c
Th 17

Ntas
Exp-c
Th 7
Exp-c
Th 14

Figure 8: Inhabitation for Tree Automata.

Inhabtree

Σ (A).

Input: a tree automaton A = (Q, Σ, F, ∆) ∈ AΣ, Q(cid:48) ⊆ Q.
Output: whether Q(cid:48) is ∆-inhabited by some tree in TΣ.

255

The uniform variant of this problem where the signature Σ is passed as an

input is called Inhabtree (A). The complexity of tree inhabitation is folklore, in

both cases, uniform or not. An overview of the results is given in Fig. 8. An

algorithm for solving the problem for Ntas can be based on determinization.

260

This algorithm will be instructive for context inhabitation as well, so we include

it in the proof.

Proposition 6. Tree inhabitation Inhabtree (Nta) is in Exp. The restriction

to deterministic tree automata Inhabtree (Dta) is in P.

Proof. Let Σ be a ranked signature. If A is a Dta then Q(cid:48) ⊆ Q is ∆-inhabited

265

by some tree, if either Q(cid:48) = ∅ and A is not complete, or Q(cid:48) is a singleton

and the unique state of Q(cid:48) is accessible wrt. ∆. Hence Inhabtree (Dta) is

in polynomial time. For Ntas the Exp upper bound can be obtained by de-

terminization.

If A = (Q, Σ, F, ∆) is an Nta then by deﬁnition Q(cid:48) ⊆ Q is

∆-inhabited by some tree t ∈ TΣ if

t
(cid:74)

(cid:75)

12

∆ = Q(cid:48). This is equivalent to that

270

t

det(∆) = {Q(cid:48)}. Thus Q(cid:48) is ∆-inhabited iﬀ {Q(cid:48)} is det(∆)-inhabited in det(A).
(cid:75)

(cid:74)
This can be tested in polynomial time from det(A), which in turn can be com-

puted in exponential time from A. Thus Inhabtree (Nta) is in Exp.

The worst case exponential blow up coming with determinization cannot be

avoided for solving tree inhabitation of Ntas, as we show next.

275

Theorem 7 (Folklore). Tree inhabitation Inhabtree

Σ (Nta) is Exp-complete,

while its restriction to deterministic tree automata Inhabtree

Σ (Dta) is in P.

3.4. Context Inhabitation

Since the bound variable of a context occurs exactly once, contexts are inter-

preted as union homomorphisms in the transition algebras of a tree automata.

280

These will play a key role for deﬁning the problem of context inhabitation and

for studying its complexity.

Deﬁnition 8. A union homomorphism on 2Q is a function S : 2Q → 2Q such

that S(∅) = ∅ and S(Q(cid:48) ∪ Q(cid:48)(cid:48)) = S(Q(cid:48)) ∪ S(Q(cid:48)(cid:48)) for all Q(cid:48), Q(cid:48)(cid:48) ⊆ Q.

Lemma 9. For any context C ∈ CΣ and Nta A = (Q, Σ, F, ∆) the ∆-inhabited

285

value

C

(cid:74)

(cid:75)

∆ is a union homomorphism on 2Q.

The following example shows that Lemma 9 would fail if it were generalized

from contexts to nonlinear second-order λ-terms.

Example 1. Consider N = λx.f (x, x) over the signature Σ = {a, f } where

a is a constant and f a symbol of arity 2, and the Nta A = (Q, Σ, F, ∆)

290

with Q = {q1, q2, qok}, F = {qok} and ∆ = {a → q1, a → q2, f (q1, q2) →
∆({q1, q2}) = {qok}.
∆ is not a union

∆({q2}) = ∅, while
(cid:75)
(cid:74)
∆({q1}) ∪

(cid:75)
∆({q1, q2}) (cid:54)=

qok}. We have

∆({q1}) =

Hence,

(cid:75)
N

N

N

N

N

N

N

(cid:74)

(cid:74)
∆({q2}), so
(cid:75)

(cid:74)

(cid:74)

(cid:75)

(cid:74)

(cid:75)

(cid:74)
homomorphism.

(cid:75)

Any function s : Q → 2Q deﬁnes the union homomorphism ˆs : 2Q → 2Q such

295

that ˆs(Q(cid:48)) = (cid:83)
q∈Q(cid:48)

s(q) for all Q(cid:48) ⊆ Q. Conversely, any union homomorphism is

determined by the images of all singletons.

13

Lemma 10 (Succinct representations of union homomorphisms). If S : 2Q →

2Q is a union homomorphism then S = ˆs for the function s : Q → 2Q such that

s(q) = S({q}) for all q ∈ Q.

300

Proof. This is straightforward from the deﬁnitions.

As a consequence, the number of union homomorphisms is equal to the num-

ber of functions of type Q → 2Q which is exponential. In contrast the number

of functions of type 2Q → 2Q is doubly exponential. This is the reason why

second-order inhabitation is a more diﬃcult problem than context inhabitation

305

that we formalize next.

Context inhabitation receives as input a function s : Q → 2Q that represents

the union homomorphism ˆs : 2Q → 2Q. Note that the representation is exponen-

tially smaller than the union homomorphism it represents. Using this succinct

representation of a union homomorphism as an input rather than the union ho-

310

momorphism itself will permit to relate the complexity of regular matching to

context inhabitation.

For any ranked signature Σ and class of automata A, we deﬁne the following

decision problem.

Inhabcontext
Σ

(A).

Input: an automaton A = (Q, Σ, F, ∆) ∈ AΣ and a function s : Q → 2Q.

Output: whether the union homomorphism ˆs is ∆-inhabited by some

context in CΣ.

315

The uniform variant of the problem where the signature Σ is given with

the input is denoted by Inhabcontext (A). Based on the properties of union

homomorphisms, we next show that ˆs is ∆-inhabited if and only if its restriction

to singletons is.

Proposition 11. Let A = (Q, Σ, F, ∆) be an Nta and s : Q → 2Q. Then ˆs is

320

∆-inhabited iﬀ there exists C ∈ CΣ such that for all q ∈ Q, s(q) =

∆({q}).

C

(cid:74)

(cid:75)

Proof. The forward implication is straightforward. For the backward direction,

14

let C ∈ CΣ be a context with s(q) =
a union homomorphism, we have for all Q(cid:48) ⊆ Q that ˆs(Q(cid:48)) = (cid:83)
q∈Q(cid:48)

∆({q}) for all q ∈ Q. Since ˆs is

s(q) =

C

(cid:74)

(cid:75)

∆(Q(cid:48)) since

∆ is a union-homomorphism by Lemma 9.

C

(cid:74)

(cid:75)

C

(cid:83)
q∈Q(cid:48)(cid:74)
Thus ˆs is ∆-inhabited.

∆({q}) =
(cid:75)

C

(cid:74)

(cid:75)

325

Context inhabitation is a special case of second-order linear λ-deﬁnability

where the second-order input function is a union homomorphism, except that

the union homomorphism is represented in a succinct manner. Note that λ-

deﬁnability is known to be decidable up to the order of three [9], while it is

330

undecidable in general [10, 11]. We now determine the complexity of context

inhabitation for Ntas and then for Dtas.

Proposition 12. Inhabcontext (Nta) is in Exp.

Proof. As in the case of tree inhabitation, the problem can be solved based on

determinization, but in a more tricky manner. Let Σ be a ranked signature, A =
(Q, Σ, F, ∆) an Nta where Q = {q1, . . . , qn} and s : Q → 2Q. We ﬁx x ∈ Vtree .

335

For each i ∈ {1, . . . , n}, let ∆i = ∆ ∪ {x → qi} and Ai = (Q, Σ (cid:93) {x}, F, ∆i).
Let ˜A be the product Dta ˜A = det(A1) × . . . × det(An) with transition relation
˜∆, recognizing the intersection of the languages of the Dtas det(Ai). Note that
the number of states of ˜A is at most (2n)n = 2n2

, which is exponential.

340

Claim 13. Let p ∈ TΣ(cid:93){x} be a tree having exactly one occurrence of x. Then

˜∆ = {(s(q1), . . . , s(qn))} if and only if

p
(cid:75)

(cid:74)

∆i = s(qi) for all 1 ≤ i ≤ n.

p
(cid:75)

(cid:74)

Recall that for any context C = λx.p, the set

∆i contains all the states

to which C can be evaluated when starting at the hole marker x with state qi.
Let B be the Dta with signature TΣ(cid:93){x} recognizing the set of all trees having

exactly one occurrence of x. We assume w.l.o.g. that B has a single ﬁnal state
qf . Now consider the product Dta ˜A × B recognizing the language L( ˜A) ∩ L(B)
of all the elements of L( ˜A) having exactly one occurrence of x. Then it follows
from Claim 13 that the tuple (s(q1), . . . , s(qn), qf ) is an accessible state of ˜A×B
∆({qi}) = s(qi).

if and only if there exists a context λx.p ∈ CΣ such that

λx.p

By Proposition 11 the latter is equivalent to that ˆs is ∆-inhabited. Testing

(cid:74)

(cid:75)

345

350

p
(cid:75)

(cid:74)

15

whether (s(q1), . . . , s(qn), qf ) is accessible in ˜A × B is in polynomial time in the
size of ˜A × B, which is in Exp.

Theorem 14. Inhabcontext

Σ

(Nta) is Exp-complete.

355

Proof. The Exp upper bound was shown in Proposition 12 even for the uniform

variant of the problem. For Exp-hardness of Inhabcontext

Σ

(Nta) for any Σ with

at least one constant x and one symbol $ of arity at least 2, we use a reduction
from InterΣ(Dta). For the sake of simplicity, we assume that $ is binary, but

the following construction can be generalized in the case where $ has an arity

360

n > 2.

Let A1, . . . , An be Dtas where Ai = (Qi, Σ, Fi, ∆i) for 1 ≤ i ≤ n, and

such that their sets of states are pairwise-disjoint. Let q1, qf
n be fresh
states, i.e. not in Q1 ∪ · · · ∪ Qn. We build the Nta B = (Q, Σ, F, ∆) obtained
by setting Q = Q1 ∪ . . . ∪ Qn ∪ {q1, qf
∆1 ∪ . . . ∪ ∆n ∪ {x → qi | 1 ≤ i ≤ n} ∪ {$(q, qi) → qf
i
s : Q → 2Q be the function so that for all q ∈ Q,

1 , . . . , qf
| q ∈ Fi}. Now let

n}, F = {qf

1 , . . . , qn, qf

1 , . . . , qn, qf

n} and ∆ =




{qf

i }

s(q) =

if q = qi for 1 ≤ i ≤ n



∅

otherwise

L(Ai) (cid:54)= ∅ if and only if ˆs is ∆-inhabited. Indeed,there exists a tree

t ∈

L(Ai) iﬀ

t

∆i ∩ Fi (cid:54)= ∅ for all 1 ≤ i ≤ n, iﬀ

$(t, x)[x/{q}]

(cid:74)

∆ = s(q)
(cid:75)

for all q ∈ Q iﬀ

∆({q}) = s(q) for all q ∈ Q. By Proposition 11, the

(cid:75)

(cid:74)
λx.$(t, x)
(cid:75)

(cid:74)

latter is equivalent to ˆs is ∆-inhabited. This concludes the proof of the theorem.

365

We ﬁnally show that context inhabitation is in Pspace for Dtas, even

though this is a problem concerning automata for trees and not words. Indeed,

inhabitation for Dtas can be reduced to the nonemptiness of intersection for
words InterΣ(Dfa), which is Pspace-complete [12]. The Pspace upper bound

370

holds even for the uniform variant of the problem. Showing this requires two

16

Then

n
(cid:84)
i=1

n
(cid:84)
i=1

additional tricks in the proof, but is worth the eﬀort since the uniform version

of context inhabitation will be needed for solving the uniform version of regular

matching, to which the non-uniform version of regular matching with constraints

will be reduced. The constraints will allow us to solve regular matching in the

375

case of unranked trees, the original motivation of the present work.

Lemma 15. The problem Inhabcontext (Dta) can be reduced in polynomial time

to its restriction where the input function s : Q → 2Q always maps to singletons.

Proof sketch. If there exists q ∈ Q such that s(q) contains more than one element

then s cannot be inhabited for any Dta.

It remains to remove cases where

380

s(q) = ∅ for some q ∈ Q. The main idea to deal with empty sets is to complete

A to A(cid:48) by adding a sink state qsink and to replace function s by s(cid:48) such that
s(cid:48)(q) = s(q) if s(q) (cid:54)= ∅ and s(cid:48)(q) = {qsink} otherwise. Inhabitation of s with
respect to A is then equivalent to inhabitation of s(cid:48) with respect to A(cid:48). However,

this construction may take exponential time in the maximal arity of function

385

symbols of A, which is not ﬁxed for the uniform problem. This problem can be

circumvented by permitting to complete A only partially. The trick that makes

this work is presented in the appendix.

Proposition 16. Inhabcontext (Dta) is in Pspace.

Proof sketch. All the technical details of this proof are formally presented in the

390

appendix. Let Σ be a ranked signature, A = (Q, Σ, F, ∆) a Dta and s : Q → 2Q,

where Q = {q1, . . . , qn}. By Lemma 15, we can assume w.l.o.g. that s(qi) is a

singleton for all 1 ≤ i ≤ n. Let x ∈ Vtree be a tree variable and Σx = Σ ∪ {x}

the ranked signature where x is given arity 0.

We reduce the ∆-inhabitation of ˆs to nonemptiness of intersection of n + 1
related Dtas A1, . . . , An+1. For any i ∈ {1, . . . , n}, deﬁne the tree automaton

395

Ai = (Q, Σx, s(qi), ∆i) on Σx having the same states as A, set of ﬁnal states

s(qi), and whose transition relation is ∆i = ∆ ∪ {x → qi}, and let An+1 be

the automaton that accepts the trees having exactly one occurrence of x. We

show that

n+1
(cid:84)
i=1

L(Ai) (cid:54)= ∅ iﬀ ˆs is ∆-inhabited. Intuitively, any tree t in the above

17

aq1

f q1

bq2

xq1

cq2

aq1

aq1

f q2

bq1

xq2

cq2

aq1

f f (q1,(cid:63),q2)

a

bb((cid:63))

xx

c

a

Figure 9: Left, respectively middle: the run (in red superscript) on the tree f (a, b(x), c(a))

of the automaton A1, respectively A2. Right: the run path (in red superscript) on the tree

f (a, b(x), c(a)) w.r.t. automata A1 and A2.

400

intersection of languages deﬁnes a context λx.t such that

(for any 1 ≤ i ≤ n), and this correspondence is bijective.

∆({qi}) = s(qi)

λx.t

(cid:74)

(cid:75)

Now, the automata A1, . . . , An are related as they diﬀer only by the state in

which x is evaluated and by their ﬁnal state. Actually, for any tree t in Σx that

contains exactly one occurrence of x, the runs of Aj and Ak diﬀer only along the

405

path from the root of the tree to the leaf x. This is illustrated by the following

example. Consider an automaton B on signature {f (3), a(0), b(1), c(1)}, with

states {q1, q2} and transition relation {a → q1, b(q1) → q2, b(q2) → q1, c(q1) →

q2, f ( , q1, ) → q2, f ( , q2, ) → q1} (where stands for any state). The run of B1

and of B2 on the tree f (a, b(x), c(a)) are presented on Fig. 9. We now introduce

410

what we call a run path, which basically represents the sequences of transitions

that are triggered along the path from x to the root of the tree during the

evaluation of an automaton Bi, while erasing the way x and its path contribute

to the run. Back to the example here above, the run path for B1 on the tree

f (a, b(x), c(a)) is presented on the right of Figure 9. It turns out the run path

415

for A2 is the same.

More formally, deﬁne the alphabet ΣQ that contains the symbol x and all
symbols of the form f (u1, . . . , um) where f is a symbol in Σ(m) and f (u1, . . . , um)

is the left hand side of some rule of A in which exactly one of the states is

replaced by (cid:63). Back to the example automaton B, e.g. f (q1, q2, (cid:63)) is a letter in

420

ΣQ because B contains the transition f (q1, q2, q1) → q2. The letters of ΣQ are

underlined in order to not confuse them with the left hand sides of the actual

rules. Then a run path is a word over the alphabet ΣQ∪{⊥}, where ⊥ is a special

18

symbol that indicates that there is a subtree that the Dta couldn’t evaluate.

For instance, the run path on Figure 9 is the word x b((cid:63)) f (q1, (cid:63), q2). The run

425

path for f (a, b(x), c(b)) is x b((cid:63)) ⊥, as the subtree c(b) cannot be evaluated by

the automata Bi.

Naturally, if t ∈ (cid:84)n+1

i=1 An+1, then it has a corresponding run path with no
occurrence of ⊥. More interestingly, given a run path that doesn’t contain the

symbol ⊥, we can always construct a tree “around” it, since all the states of A

are accessible. Back to the example, the tree f (a, b(x), a) is a possible tree for
the run path x b((cid:63)) f (q1, (cid:63), q1). Now, for any Dta Ai, we construct a Dfa A(cid:48)
i
s.t. for all trees t it holds t ∈ L(Ai) iﬀ the run path of t is in L(A(cid:48)
i). Thus the
nonemptiness of (cid:84)n+1
i=1 An+1 is reduced to the nonemptiness of intersection of n
Dfas, which is in Pspace.

430

435

Theorem 17. Inhabcontext

Σ

(Dta) is Pspace-complete.

Proof. The upper bound follows from Proposition 16. The lower bound can

be even shown for less general ranked signatures containing only one constant

440

symbol and unary symbols. This is done by reduction from the nonempti-
ness problem of the intersection of a ﬁnite number of Dfas, i.e InterΣ(cid:48)(Dfa)
for some – word – alphabet Σ(cid:48) containing at least two symbols. Any ﬁnite

word a1, . . . , am−1, am over the alphabet Σ(cid:48) can be encoded by a “string” tree

am(am−1(. . . a1(x) . . .)) over the ranked signature Σ, where a1, . . . , am are unary
symbols and x is a constant symbol. Similarly, any Dfa A can be transformed in

445

linear time to a Dta A(cid:48) that accepts exactly the string encodings of words from

L(A), and which transitions are trivial encodings of transitions of A plus an ad-
ditional transition x → qx for some fresh state qx. Now given Dfas A1, . . . , An
over alphabet Σ(cid:48), which we assume w.l.o.g. to have pairwise disjoint sets of

450

states and single ﬁnal states, let A(cid:48)
Dtas over the ranked signature Σ as described above. We write qf
the only ﬁnal state of the Dta A(cid:48)

1, . . . , A(cid:48)

i to denote
i, for 1 ≤ i ≤ n. Let B be the union of the
i , and ∆ be the transition relation of

i excluding the rules of the form x → qx

n be the respective corresponding

A(cid:48)

19

p, p(cid:48), p1, . . . , pn ∈ P tree
P ∈ P context
Σ

Σ

::= x | f (p1, . . . , pn) | P @p

::= X | λx.p(cid:48) where x occurs exactly once in p(cid:48)

Figure 10: Tree and context patterns where x ∈ V tree , X ∈ V context , f ∈ Σ(n) and n ≥ 0.

B. Notice that B is deterministic. Then the intersection of the languages of
A1, . . . , An is non-empty iﬀ ˆs is ∆-inhabited, where ˆs is deﬁned by s(q) = {qf
i }
if q = qx

i for any 1 ≤ i ≤ n, and s(q) = ∅ otherwise.

455

4. Tree Patterns

We next extend trees and contexts to patterns by adding variables of both

types. For this we assume a set V = (cid:93)τ ∈TV τ with two kinds of variables.
Variables x, y, z ∈ V tree have type tree and variables X, Y ∈ V context type

460

context.

We next introduce patterns for trees p ∈ P tree

Σ

and patterns for contexts

P ∈ P context
Σ

Σ. In both kind
of patterns, tree variables x may now occur freely but can also be bound in the

in Fig. 10. The set of all patterns is PΣ = (cid:93)τ ∈TP τ

scope of a λ-binder as before. For instance, the tree pattern X@(λy.f (y, a)@x)

465

in P context
Σ

contains the free context variable X, the bound tree variable y and

the free tree variable x. Up to β-reduction this pattern is equal to X@f (x, a)

which also belongs to P context

Σ

.

The set of free variables fv(p) and fv(P ) and of bound variables bv(p) and

bv(P ) are deﬁned as usual for λ-terms. A pattern is called linear if each of its

470

free variables has at most one free occurrence.

The set P gr,τ

Σ

of ground patterns of type τ ∈ T is the subset of patterns

Σ without free variables. The set of all ground patterns is denoted by
. Clearly, any tree is a ground pattern of type tree

in P τ
P gr
Σ = P gr,tree
and any context is a ground pattern of type context, i.e., TΣ ⊆ P gr,tree
CΣ ⊆ P gr,context
Σ

. The converse is not true. The ground pattern λx.x@f (a)

∪ P gr,context

and

Σ

Σ

Σ

475

for instance is not a tree. However, it becomes equal to the tree f (a) by β-

reduction. The situation is similar for ground pattern for contexts, which can

20

always be reduced to a context by exhaustive β-reduction. The ground context

pattern λx.λy.y@f (x) for instance can be β-reduced to the context λx.f (x).

480

In general, each β-reduction step replaces some redex of the form (λx.p)@p(cid:48) in

a bigger pattern by p[x/p(cid:48)] if x (cid:54)∈ bv(p) and otherwise renames x beforehand.

Exhaustive β-reduction can be done in any order, but always leads to the same
result. We denote the β-reduced form of a tree pattern p ∈ P gr,tree
and of a context pattern P ∈ P gr,context

by norm β(P ). The overall reduction

by norm β(p)

Σ

Σ

485

requires at most a linear number of steps, since all λ-bound variables in patterns

are constrained to occur exactly once (in the scope of the λ-binder). As a
consequence, we have norm β(P gr,tree
A substitution µ : V → P gr
if it maps tree variables to P gr,tree

Σ on a subset of variables V is called well-typed
and context variables to P gr,context
. For

) = TΣ and norm β(P gr,context

) = CΣ.

Σ

Σ

Σ

Σ

any pattern p ∈ P tree

Σ , the grounding µ(p) ∈ P gr,tree

Σ

is obtained from p by

replacing free variables v by µ(v). The set of all instances of p is obtained by

β-normalizing all groundings of p:

Inst(p) = {norm β(µ(p)) | µ : fv(p) → P gr

Σ well-typed}.

Clearly any instance of p is a tree, that is Inst(p) ⊆ TΣ.

Example 2. Consider the tree pattern p = X@(X@x) and the substitution

490

µ where µ(X) = λx.f (b, x) and µ(x) = a. The β-normal form of µ(p) =

µ(X)@(µ(X)@µ(x)) is the tree norm β(µ(p)) = f (b, f (b, a)) belonging to Inst(p).

We next lift the algebra interpretation of values to patterns. Let σ : V →

∆ be a well-typed variable assignment in that it maps tree variables to

Val Σ

(cid:74)

TΣ

(cid:75)

∆ and context variables to

(cid:75)

(cid:74)
(cid:74)
p with fv(p) ⊆ V the evaluation

patterns P with fv(P ) ⊆ V the interpretation

CΣ

∆. In Fig. 11, we deﬁne for any tree pattern
(cid:75)
p
(cid:75)

∆, and similarly for all context
(cid:75)
P

TΣ
(cid:74)

∆,σ ∈

∆.

CΣ

(cid:74)

∆,σ ∈
(cid:75)

(cid:74)

(cid:74)

(cid:75)

Note that the interpretation of a ground pattern does not depend on the

variable assignment. In this case we can write

∆ instead of

(cid:74)
∆,σ. Note also that these notations for ground patterns are con-

(cid:74)

(cid:74)

p
(cid:75)

p

∆,σ and
(cid:75)

P

∆
(cid:75)

instead of

P
(cid:74)

(cid:75)

sistent with the same notations introduced for trees and contexts earlier. Fur-

21

495

500

∆,σ = σ(x),

∆,σ = σ(X),

x
(cid:74)
(cid:75)
X
(cid:74)

(cid:75)

(cid:74)

(cid:74)

f (p1, . . . , pn)
(cid:75)
∆,σ(d) =

λx.p

∆,σ = f ∆(

p1
(cid:74)
∆,σ[x/d],

(cid:75)

p
(cid:75)

(cid:74)

pn

∆,σ),

(cid:75)

∆,σ, . . . ,

P @p

(cid:74)

(cid:74)
(cid:75)
∆,σ =
(cid:75)

P

(cid:74)

(cid:75)

∆,σ(

p
(cid:74)

∆,σ).
(cid:75)

Figure 11: Algebra interpretation of patterns.

thermore, remark that the algebra interpretation is invariant under β-reduction,

i.e.

∆ =

p
(cid:75)

(cid:74)

norm β(p)
(cid:75)
(cid:74)

∆ and in analogy

∆ =

P

(cid:74)

(cid:75)

(cid:74)

norm β(P )

∆.

(cid:75)

5. Compressed Tree Patterns

We now show how to deﬁne patterns with grammar compression for both

505

types by using a variant of singleton tree grammars with contexts.

Deﬁnition 18. A compressed pattern of type τ ∈ T is an acyclic context-free

tree grammar G = (N, Σ, R, S) where N ⊆ V is a ﬁnite set of nonterminals,

S ∈ N of type τ is the start symbol, R is a partial well-typed function from N

to patterns in PΣ with free variables in N . The set of all compressed patterns
of type τ is denoted by P comp,τ

.

Σ

510

For instance, consider the compressed tree pattern G0 ∈ P comp,tree

Σ

with

the nonterminals N = {z, X, Y, Z, y}, with S = z and with two rules R(z) =

X@a(X@b, Y @c), and R(X) = λx.Z@a(x, y). We illustrate G0 by the graph in

Fig. 12. Each nonterminal is annotated to the left of the corresponding node.

Note that the circled empty nodes correspond to the nonterminals without any

rule. The compressed pattern G0 is acyclic, in that no variable on the left hand

side of some rule does appear in any subsequent rule. In other words, the graph

of G0 is a DAG. It should also be noticed that the tree language of the grammar

G0 is ∅. What interests us instead is its tree pattern:

pat(G0) = (λx.Z@a(x, y))@a((λx.Z@a(x, y))@b, Y @c)

The grammar serves to represent this pattern in a compressed manner, by

sharing the context pattern referred to by X. By exhaustive β-reduction of

22

S = z

@

X

λx

a

z → X@a(X@b, Y @c),

X → λx.Z@a(x, y)

Z

@

x

a

y

@

b

Y

@

c

Figure 12: Graph and rules of the compressed tree pattern G0.

pat(G0) we obtain the following tree pattern with context variables but without

λ-binders:

norm β(pat(G0)) = Z@a(a(Z@a(b, y), Y @c), y)

A compressed tree pattern is called compression-free if the structure of its

grammar is a tree, that is, every nonterminal appears at most once in all the

right-hand sides of the rules. We deﬁne the free variables of a compressed tree

pattern G as the free variables of pat(G), and the bound variables of G as the

515

nonterminals in dom(R).

In what follows we will identify tree patterns p ∈ P tree

Σ with the compressed
tree pattern ctpΣ(p) = ({S}, Σ, {S → p}, S), which has a single rule mapping

a ﬁxed start symbol S to p. Note that ctpΣ(p) is compression-free.
sense, P tree

. A compressed tree pattern G is called linear if its

Σ ⊆ P comp,tree

In this

Σ

520

tree pattern pat(G) is linear.

Our next objective is to evaluate compressed tree patterns eﬃciently over

the Σ-algebra of some Nta for a given variable assignment into this algebra. In

particular, we want to avoid any kind of decompression when doing so.

The precise formalization of this statement needs a little care, since we

525

have to work with representations of variable assignments as inputs rather

than with variable assignment themselves. Let A = (Q, Σ, F, ∆) be an Nta

and σ : V →

Val Σ

∆ a well-typed variable assignment into the Σ-algebra

∆ = (Σ, 2Q, .∆). The problem is that the context variables X in V are mapped

(cid:74)

(cid:75)

23

to union homomorphisms σ(X) : 2Q → 2Q (see Deﬁnition 8) which may be

530

of exponential size, but can be represented in polynomial space by a function
s(X) : Q → 2Q with σ(X) = (cid:91)s(X).

Deﬁnition 19. A function s represents a variable assignment σ : V →

into the Σ-algebra of the Nta A = (Q, Σ, F, ∆) if dom(s) = dom(σ), σ(X) =
(cid:91)s(X) for all context variables X ∈ dom(s), and σ(x) = s(x) for all tree variables

Val Σ

∆
(cid:75)

(cid:74)

535

x ∈ dom(s). In this case, we write σ = ˆs.

A similar result to the following lemma can be found for instance in [15].

Lemma 20. For any Nta A = (Q, Σ, F, ∆), compressed tree pattern G =
P comp,tree

, and representation s of a variable assignment ˆs into the Σ-algebra

Σ

∆ with fv(G) ⊆ dom(s) we can compute the ∆-value of the pattern

540

in polynomial time from Σ, ∆, G, and s.

∆,ˆs

pat(G)
(cid:75)

(cid:74)

Proof. The algorithm evaluates the pattern inductively along the partial order

on the nonterminals of G; the latter exists because G is acyclic. For any v ∈ V ,

let Gv be the compressed tree pattern equal to G except that the start symbol

is changed to v. Then we can show for all v ∈ V that

pat(Gv)

(cid:74)

∆,ˆs can be
(cid:75)

545

computed in polynomial time from Σ, ∆, G, and s. In particular this holds for

pat(G)
(cid:75)

(cid:74)

∆,ˆs =

(cid:74)

pat(GS)

∆,ˆs.
(cid:75)

6. Regular Matching and Inclusion

We now study the complexity of regular matching and inclusion for classes

of compressed tree patterns with context variables.

550

A class of compressed tree patterns G is a function that maps any signature

Σ to a subset of compressed tree patterns GΣ ⊆ P comp,tree
Σ
are the classes P tree and P comp,tree given that P tree

. Typical examples

Σ ⊆ P comp,tree

Σ

. To see this

recall that we identify any tree pattern p with the compression-free compressed

tree pattern ctpΣ(p) = ({S}, Σ, {S → p}, S) where S is the ﬁxed start symbol.
For any class G of compressed tree patterns, any class A of Ntas, and for

555

any ranked alphabet Σ we deﬁne two decision problems:

24

Regular pattern inclusion: InclΣ(G, A).

Input: a compressed tree pattern G ∈ GΣ and a tree automaton A ∈ AΣ.

Output: whether Inst(pat(G)) ⊆ L(A).

Regular pattern matching: MatchΣ(G, A).

Input: a compressed tree pattern G ∈ GΣ and a tree automaton A ∈ AΣ.

Output: whether Inst(pat(G)) ∩ L(A) (cid:54)= ∅.

The uniform versions of these problems where the signature Σ is given with

560

the input are called Incl(G, A) and respectively Match(G, A).

6.1. Lower Bounds

We ﬁrst establish the lower bounds for regular matching by reduction from

automata intersection problems.

In the second step, we establish the lower

bounds for the dual problem of regular inclusion.

In the deterministic case,

565

the lower bounds for regular matching can be lifted to regular inclusion based

on automaton complementation. In the nondeterministic case, another lower

bound result needs to be established.

Proposition 21 (Regular matching). MatchΣ(P tree , Nta) is Exp-hard, while
MatchΣ(P tree , Dta) is Pspace-hard.

570

Proof. We ﬁrst notice that MatchΣ(P tree , Nta) generalizes the ground instance

intersection problem from [6] by adding compression and context variables. The

latter problem is known to be Exp-complete for Ntas, so the Exp-hardness of
MatchΣ(P tree , Nta) follows.

In order to clarify the role of nondeterminism

575

here, we recall the proof of this result, which is based on a reduction from the
nonemptiness of the intersection of a ﬁnite number of Dtas, i.e. InterΣ(Dta).
The reduction is as follows. Given a sequence of Dtas A1, . . . , An over
the same signature Σ we can construct in P an Nta A over Σ ∪ {f } that

recognizes the language f (L(A1), . . . , L(An)), where f is a fresh function symbol

of arity n. The transition relation of A is the union of the transition relations

25

of A1, . . . , An extended with rule f (qf

1 , . . . , qf
of Ai, whose uniqueness can be assumed without loss of generality. Note that

n) → qok where qf

is the ﬁnal state

i

A is nondeterministic. We ﬁx a tree variable x ∈ V arbitrarily. The regular tree

pattern matching task

Inst(f (x, . . . , x
(cid:124) (cid:123)(cid:122) (cid:125)
n

)) ∩ L(A) = ∅

is then equivalent to the intersection emptiness task L(A1) ∩ . . . ∩ L(An) = ∅.

To ﬁnish the reduction, we note that one can reduce the problem with signature

Σ ∪ {f } to the same problem with signature Σ by simulating the new symbol

f by the function symbol of arity at least 2 and the constant available in Σ by

580

assumption.

It should be noticed that A is inherently nondeterministic by construction.
Therefore, this Exp-hardness proof does not apply to MatchΣ(P tree , Dta).
And indeed, as we will see – in Theorem 27 – this problem is not Exp-hard but

only Pspace-complete. For the moment we show that it’s Pspace-hard.

The Pspace-hardness of MatchΣ(P tree , Dta) follows from the special case
of regular string matching, which was shown to be Pspace-complete for deter-

ministic ﬁnite automata (Dfas) recently [5]. String patterns H over a ﬁnite

alphabet Γ have the syntax:

H, H (cid:48) := a | ε | Z | HH (cid:48)

where a ∈ Γ, Z ∈ V context

585

Here we abuse context variables as string variables, i.e., any instantiation of H

maps variables to words in Γ∗. String patterns can be translated to tree patterns

with context variables as follows: The signature of the trees contains all letters

of Γ as monadic function symbols and a fresh constant #. Any string pattern

can then be encoded by a monadic tree pattern, such as for instance aZbZ (cid:48)c by

590

c(Z (cid:48)@b(Z@a(#))). In this way, regular string pattern matching can be reduced

to regular tree pattern matching with context variables in polynomial time.

26

Lemma 22 (Duality via Complementation). For any class of compressed tree
patterns G, the problems InclΣ(G, Dta) and coMatchΣ(G, Dta) are equivalent

595

modulo polynomial time reductions.

Proof. For any compressed tree pattern G and Dta A, we have Inst(pat(G)) ⊆

L(A) iﬀ Inst(pat(G)) ∩ L(A) = ∅ iﬀ Inst(pat(G)) ∩ L(A) = ∅, where A is the

complement automaton for A that can be computed in polynomial time since

A is a Dta.

600

As a consequence of Lemma 22 the problem InclΣ(G, Nta) is equivalent
to coMatchΣ(G, Nta) modulo Nta determinization, which however requires
exponential time. We now show that regular inclusion for Ntas is Exp-hard

even for linear tree patterns. Even the class of tree patterns V tree in which each

pattern consists simply of a tree variable is enough. More formally this is the

605

class of compressed tree patterns such that V tree

Σ = {ctpΣ(x) | x ∈ V tree } for all

signatures Σ.

Lemma 23. InclΣ(V tree , Nta) is Exp-hard.

Proof. Let A be an Nta. The instance set of any pattern x ∈ V tree is equal to

TΣ. This set is included in L(A) if and only if A is universal. The universality
problem for Ntas is well known to be ExpTime-complete.

610

Proposition 24 (Regular inclusion). InclΣ(P tree , Dta) is Pspace-hard, while
InclΣ(P tree , Nta) is Exp-hard.

Proof. Lemma 22 states that InclΣ(P tree , Dta) = coMatchΣ(P tree , Dta)
modulo polynomial time reductions. By Proposition 21, MatchΣ(P tree , Dta) is
Pspace-hard and since Pspace is closed by complement, coMatchΣ(P tree , Dta)
is Pspace-hard too. Hence InclΣ(P tree , Dta) is Pspace-hard.

615

In the case of Ntas, the Exp-hardness of InclΣ(P tree , Nta) follows imme-

diately from Lemma 23.

27

6.2. Upper Bounds

620

All upper bounds will be obtained in a systematic manner by some algorithm

that instead of guessing trees or contexts in Val Σ will guess ∆-inhabited values

∆. For the guessing, a subroutine will be applied that decides tree or

in

Val Σ

(cid:74)

(cid:75)

context inhabitation.

We start with a characterization of regular matching and inclusion, on which

625

our decision procedure will rely.

Lemma 25 (Characterization). Let A = (Q, Σ, F, ∆) be an Nta and p ∈ P tree

Σ

a tree pattern.

Regular matching: Inst(p) ∩ L(A) (cid:54)= ∅ holds iﬀ there exists some well-typed

variable assignment to ∆-inhabited values σ : fv(p) →

630

∆,σ ∩ F (cid:54)= ∅.

p
(cid:75)

(cid:74)

∆ such that

Val Σ

(cid:74)

(cid:75)

Regular inclusion: Inst(p) ⊆ L(A) holds iﬀ all well-typed variable assign-

ments to ∆-inhabited values σ : fv(p) →

Val Σ
(cid:74)

∆ satisfy
(cid:75)

p
(cid:75)

(cid:74)

∆,σ ∩ F (cid:54)= ∅.

Proof. We start with the case of regular matching. For the forward direction, we

assume Inst(p) ∩ L(A) (cid:54)= ∅. By deﬁnition of instances, there exists a well-typed

635

assignment µ : fv(p) → Val Σ such that norm β(µ(p)) ∈ L(A). Let σ =

Clearly σ : fv(p) →

∆ is a well-typed variable assignment. Since

∆ =

norm β(µ(p))

µ(p)
(cid:75)

(cid:74)

(cid:74)

(cid:75)
∆ it follows that
(cid:75)

p

∆,σ ∩ F (cid:54)= ∅.
(cid:75)

(cid:74)

Val Σ
(cid:74)

For the inverse direction, we ﬁx a well-typed variable assignment to ∆-

.
(cid:74)
(cid:75)
p

(cid:74)

∆ ◦ µ.

∆,σ =
(cid:75)

640

645

inhabited values σ : fv(p) →

Val Σ

∆ such that

∆,σ∩F (cid:54)= ∅. By ∆-inhabitation

(cid:74)

(cid:75)

p
(cid:75)

(cid:74)

there exists a well-typed variable assignment µ : fv(p) → Val Σ such that σ =

.
(cid:75)

∆ ◦ µ. Hence,

∆ ∩ F (cid:54)= ∅, so that

norm β(µ(p))

∆ ∩ F (cid:54)= ∅. Thus

(cid:74)
(cid:75)
norm β(µ(p)) ∈ L(A), that is norm β(µ(p)) ∈ Inst(p) ∩ L(A).

(cid:74)

(cid:74)

µ(p)
(cid:75)

The case of regular inclusion is similar. For the forward direction, we assume

Inst(p) ⊆ L(A) and ﬁx a variable assignment to ∆-inhabited values σ : fv(p) →

Val Σ

(cid:74)
(cid:75)
such that σ =

∆. By ∆-inhabitation, there exists a variable assignment µ : fv(p) → Val Σ
∆ ◦ µ. Since norm β(µ(p)) ∈ Inst(p) it follows from Inst(p) ⊆
(cid:75)

(cid:74)

.

28

L(A) that norm β(µ(p)) ∈ L(A). Therefore, it follows from

∆,σ =

p
(cid:75)

(cid:74)

∆ =

µ(p)
(cid:75)

(cid:74)

norm β(µ(p))

(cid:74)

∆ that
(cid:75)

p
(cid:75)

(cid:74)

∆,σ ∩ F (cid:54)= ∅.

For the inverse direction, we assume that any variable assignment to ∆-

650

inhabited values σ : fv(p) →

∆ satisﬁes

Val Σ
(cid:74)

(cid:75)

p

∆,σ ∩ F (cid:54)= ∅. We ﬁx an el-
(cid:75)

(cid:74)

ement of t ∈ Inst(p), which must be of the form t = norm β(µ(p)) for some

µ : fv(p) → Val Σ. The variable assignment σ =

∆ ◦ µ then maps to ∆-

inhabited values, so that by assumption

∆ =

µ(p)
(cid:75)

(cid:74)

(cid:74)

norm β(µ(p))

∆ =
(cid:75)

t
(cid:75)

(cid:74)

p

∆,σ ∩ F (cid:54)= ∅. Since
(cid:75)
∆ it follows that t ∈ L(A).

(cid:74)

∆,σ =

p
(cid:75)

(cid:74)

.
(cid:74)

(cid:75)

655

We now show how to decide regular matching and inclusion based on algo-

rithms with oracles for solving inhabitation problems. Given two complexity

classes Ξ1 and Ξ2, we will write Ξ1(Ξ2) for problems solvable in Ξ1 when having
an oracle in Ξ2. We recall in particular that NP(Ξ) ⊆ Exp(Ξ), coNP(Ξ) ⊆
Exp(Ξ) and that Exp(Exp) ⊆ Exp. As a consequence, NP(Exp) ⊆ Exp and
coNP(Exp) ⊆ Exp. We also equip T with the total order ≤T deﬁned by

tree ≤T context.

Proposition 26. Let G be a class of compressed tree patterns and A a class

of Ntas. Let τ be the maximal type of free variables in a pattern in G wrt.
≤T and suppose that Inhabτ (A) belongs to complexity class Ξ. In this case,
Match(G, A) belongs to NP(Ξ) and Incl(G, A) to coNP(Ξ).

Proof. Let Σ be a ranked signature, G = (N, Σ, , S) a compressed tree pat-

tern of type tree in class G, and A = (Q, Σ, F, ∆) be a tree automaton in class

A. According to Lemma 25, pat(G) matches L(A) iﬀ some well-typed variable

assignment σ : fv(G) →

Val Σ

∆ satisﬁes

(cid:74)
variables X ∈ fv(G), the value σ(X) belongs to

(cid:75)

(cid:74)

pat(G)
(cid:75)

∆,σ ∩ F (cid:54)= ∅. For all context

∆ so it is a union homo-

morphism. Therefore, σ can be associated to a function s representing it in

CΣ
(cid:74)

(cid:75)

660

665

670

the sense of Deﬁnition 19. In order to ﬁnd a suitable value for σ(X), we guess

a function s(X) : Q → 2Q of which there are exponentially many (while the

number of functions of type 2Q → 2Q is doubly exponential) and test whether
(cid:91)s(X) is ∆-inhabited. The procedure is analogous for tree variables x ∈ fv(G),

675

except that sets of states s(x) ⊆ Q are guessed and tested for inhabitation.

29

The inhabitation test is an instance of Inhabτ (A) which can be done by an

Ξ oracle by assumption. Therefore, the guessing can be done by an algorithm

in NP(Ξ). After having found ∆-inhabited values for all the free variables of

680

G, the computation of

∆,σ which equals to

∆,ˆs can be done in

pat(G)
(cid:75)
(cid:74)

pat(G)
(cid:75)

(cid:74)

polynomial time by Lemma 20, so the characterization of regular matching can

be tested by an algorithm in NP(Ξ).

For Incl(G, A), the procedure is almost the same, except that by Lemma 25

we now have to guess a representation of a variable assignment s : fv(G) →

685

∆ such that

Val Σ
(cid:74)
This can be done by an algorithm in coNP(Ξ).

∆,ˆs ∩ F = ∅ in order to contradict regular inclusion.
(cid:75)

pat(G)

(cid:75)

(cid:74)

We next establish the complexity of the regular matching and inclusion prob-

lems.

Theorem 27. MatchΣ(P comp,tree , Dta) and InclΣ(P comp,tree , Dta) are Pspace-
complete, while MatchΣ(P comp,tree , Nta) and InclΣ(P comp,tree , Nta) are Exp-

690

complete.

Proof. The hardness results were shown in Proposition 21 and 24, so only the

upper bounds remain to be proven. Let Σ be a ranked signature.

On one hand, since Inhabcontext (Dta) is in Pspace by Theorem 17, it

695

follows from Proposition 26 that Match(P comp,tree , Dta) is in NP(Pspace)

and thus in NPspace ⊆ Pspace by Savitch’s Theorem [16].

It also follows

that Incl(P comp,tree , Dta) is in coNP(Pspace) which is in coNPspace =

NPspace and thus in Pspace too. This allows to conclude that the problems
MatchΣ(P comp,tree , Dta) and InclΣ(P comp,tree , Dta) are in Pspace.

700

On the other hand, since Inhabcontext (Nta) is in Exp by Theorem 17, it

follows by Proposition 26 that Match(P comp,tree , Nta) is in NP(Exp) and

that Incl(P comp,tree , Nta) is in coNP(Exp). Hence both problems are in
Exp, which imply that MatchΣ(P comp,tree , Nta) and InclΣ(P comp,tree , Nta)
are also in Exp.

30

705

7. Adding Regular Constraints

So far, regular matching and inclusion consider all the possible instances of

the compressed tree pattern given as input, but it may be interesting to consider

only instances satisfying some constraints. This is the case when schemas are

deﬁned for XML documents. In this part, we generalize the regular matching

and inclusion problems by allowing constraints restricting how free variables

are instantiated. Let Σ be a ranked signature and G a compressed tree pattern

over Σ. An instantiation constraint ρ on G is a total function that maps every

free tree variable of G to a Dta over Σ and every free context variable of
G to a Dta over Σ (cid:93) {xρ} where xρ ∈ V tree . Furthermore, Dtas associated

with context variables are allowed to recognize only languages of trees having

exactly one occurrence of xρ. Note that xρ is used to indicate the position

of the hole in the contexts, that is the variable to be instantiated. A well-
typed variable assignment σ : fv(G) → P gr

Σ satisﬁes ρ if for every free tree
variable x ∈ fv(G), norm β(σ(x)) ∈ L(ρ(x)) and for every free context variable

X ∈ fv(G), norm β(σ(X)@xρ) ∈ L(ρ(X)). We can now deﬁne the set of instances

of pG = pat(G) that satisfy ρ as the set:

Inst ρ(pG) = {norm β(σ(pG)) | σ : fv(G) → P gr

Σ well-typed and satisﬁes ρ}.

For any class of compressed tree patterns G and of Ntas A and any ranked

signature Σ, the problems of regular pattern inclusion and matching with con-

straints are the following:

Regular pattern inclusion with constraints: cInclΣ(G, A).

Input: a compressed tree pattern G ∈ GΣ, a tree automaton A ∈ AΣ and
an instantiation constraint ρ : fv(G) → DtaΣ ∪ DtaΣ(cid:93){xρ}.
Output: whether Inst ρ(pat(G)) ⊆ L(A).

31

Regular pattern matching with constraints: cMatchΣ(G, A).

Input: a compressed tree pattern G ∈ GΣ, a tree automaton A ∈ AΣ and
an instantiation constraint ρ : fv(G) → DtaΣ ∪ DtaΣ(cid:93){xρ}.
Output: whether Inst ρ(pat(G)) ∩ L(A) (cid:54)= ∅.

710

The uniform versions of these problems, where the signature can vary with

the input, are written cMatch(G, A) and cIncl(G, A). It can easily be seen

that regular matching (resp. regular inclusion) is a special case of regular match-

ing with constraints (resp. regular inclusion with matching), and that an al-

715

gorithm for the general case can be used to solve the special case. What is

more interesting is that regular matching with constraints (resp. regular inclu-

sion with constraints) can also be reduced to uniform regular matching (resp.

uniform regular inclusion), as stated in the next proposition:

Proposition 28. For any class G of compressed tree patterns and any class of

720

tree automata A ∈ {Nta, Dta}, cMatch(G, A) and cIncl(G, A) are reducible

in polynomial time to respectively Match(G, A) and Incl(G, A).

Proof. Let G be a class of compressed tree patterns, A ∈ {Nta, Dta} a class

of tree automata, Σ a ranked signature, G ∈ GΣ a compressed tree pattern,

A = (Q, Σ, F, ∆) ∈ AΣ a tree automaton and ρ an instantiation constraint on

725

G. The general idea is to build a new compressed tree pattern wherein there

are places marked as test zones, that is, places that tell the automaton where

constraints should be tested. Then we restrict the instances of this compressed

tree pattern to the instances that satisfy ρ using two new automata, before

testing matching and inclusion. We ﬁrst associate to every free tree variable

730

x ∈ V tree ∩ fv(G) a fresh unary symbol rootx and to every free context variable
X ∈ V context ∩ fv(G) two fresh unary symbols rootX , holeX . These symbols,

called markers, are used to delimit the test zones. Let Θ = {rootν | ν ∈
fv(G)} ∪ {holeX | X ∈ fv(G) ∩ V context (G)} be the set of markers. We deﬁne a

function mark Σ that associates every compressed tree pattern G1 over Σ with a

735

new compressed tree pattern G2 over Σ ∪ Θ that is almost equal to G1, except

32

S = z

@

X

λx

a

rootZ

@

@

b

rootY

@

Z

holeZ

Y

a

x

rooty

y

holeY

c

z → rootX (X@holeX (a(rootX (X@holeX (b)), rootY (Y @holeY (c))))),

X → λx.rootZ(Z@holeZ(a(x, rooty(y))))

Figure 13: G(cid:48) = mark Σ(G) built from the compressed tree pattern G in Figure 12.

that

• every occurrence of a free tree variable x ∈ fv(G1) in G1 is replaced by

rootx(x) in G2

• every subterm X@p of G1 where X ∈ fv(G1) is a free context variable and

740

p ∈ PΣ a pattern is replaced by rootX (X@holeX (p)) in G2

Figure 13 illustrates the compressed tree pattern G(cid:48) obtained after applying the

mark Σ function on the compressed tree pattern of Figure 12.

Let A(cid:48) be the automaton over Σ∪Θ built from A, so that L(A(cid:48)) = {mark Σ(t) |
t ∈ L(A)}. A(cid:48) can be built in linear time from A such that if A is deterministic,

745

then so will be A(cid:48). We now build a new Nta B that will allow to test the con-

straints speciﬁed in ρ. Let qwait be a fresh state. The state qwait is the state in

which B waits before testing a constraint, but also its ﬁnal state. For every part

of its input, B guesses whether it’s in a test zone, and guesses the constraint

to test. Thus, if B is reading the test zone of some free variable ν ∈ fv(G),

750

it runs the automaton ρ(ν).

If the constraint in ρ(ν) is satisﬁed, B returns

to qwait and waits for the next constraint to test. However, if no constraint is

satisﬁed in a test zone, B blocks and doesn’t get back to qwait . For all ν ∈ fv(h),

deﬁne Qν as the set of states of ρ(ν) and ∆ν as its transition relation. We set

33

B = (QB, Σ ∪ Θ, {qwait }, ∆B) where QB = {qwait } ∪ (cid:83)

Qν. The transition

ν∈fv(G)

755

relation ∆B is deﬁned as the union of ∆ν for all ν ∈ fv(G), plus the following

updates:

1. for all f ∈ Σ(n) where n ≥ 0, add f (qwait , . . . , qwait
) → qwait to ∆B
(cid:125)

(cid:124)

(cid:123)(cid:122)
n

2. for all X ∈ fv(G)∩V context , replace the only rule xρ → qX by holeX (qwait ) →

qX in ∆B

760

3. for all ν ∈ fv(G) and ﬁnal state qf

ν of ρ(ν), add rootν(qf

ν ) → qwait to ∆B.

Note the rule (2) that allows to simulate the reading of xρ by constraint

automata of contexts. So xρ is not in the signature of B. Furthermore, B

checks only whether the constraints that have been tested are satisﬁed, but

cannot guarantee that all the constraints are tested. For this, one could have

765

built an automaton that tests whether all the occurrences of all the variables of

G(cid:48) are instantiated. However, the instance set of G(cid:48) is not a regular language in

general. Instead, a Dta C that just tests whether all the variables of G(cid:48) have one

occurrence that is instantiated is enough. C is built in a way that it recognizes

all the trees that have the same skeleton as G(cid:48). By same skeleton we mean

770

that the language of trees recognized by C is a regular language obtained by

removing all non-linearities from G(cid:48). By replacing for instance the occurrences of

variables – bound or free – in G(cid:48) that are not ﬁrst occurrences by fresh variables,

we have a new compressed tree pattern whose instance set is a regular language.

The Dta C recognizes this language. We illustrate in Figure 14 a compressed

775

tree pattern obtained with this construction. Notice the new free variable X (cid:48)

replacing the second occurrence of X. Now remark that for some tree t ∈ TΣ,
t ∈ Inst ρ(pat(G)) if and only if mark Σ(t) ∈ Inst(pat(G(cid:48))) ∩ L(B) ∩ L(C).

The main problem with our reduction is that B is not deterministic, although

it is built from the Dtas ρ(ν). In order to solve this, we consider a new ranked

780

signature Σ(cid:48) where symbols f ∈ Σ are associated to the variables ν, such that

the tuple (f, ν) is used only in some instantiation of ν. More formally, Σ(cid:48) =

34

S = z

@

X

λx

a

rootZ

@

@

X (cid:48)

Z

holeZ

a

b

Y

rootY

@

holeY

c

x

rooty

y

Figure 14: Compressed tree pattern built from G(cid:48) in Figure 13 and used to build C.

Θ ∪ Σ ∪ (Σ × fv(G)). We modify G(cid:48), A(cid:48), B, and C to take into account the new

signature Σ(cid:48). For G(cid:48) we build a new compressed tree pattern G(cid:48)(cid:48) in linear time,

that is equal to it but has the extended signature Σ(cid:48). Note that G(cid:48)(cid:48) is linear if

785

G is. For B, we construct in linear time a Dta B(cid:48) over Σ(cid:48) equal to B except

that every rule f (q1, . . . , qn) → q ∈ ∆B – where n ≥ 0 – that originates from
a Dta ρ(ν) for some ν ∈ fv(G) is replaced by (f, ν)(q1, . . . , qn) → q. This way,

the set of rules of B is partitioned, according to their automata ρ(ν) of origin.

Assuming – w.l.o.g. – that the state sets of the automata ρ(ν) for ν ∈ fv(G) are

790

disjoint, B(cid:48) is indeed deterministic. Another consequence is that all letters of

an instance of a free variable ν ∈ fv(G) must be annotated by the free variable

ν itself. Unlike B, B(cid:48) does not need to guess the constraint to test, as this is

now indicated in the input. Finally, for A(cid:48) and C, we build automata A(cid:48)(cid:48) and

C (cid:48) over Σ(cid:48) – in polynomial time – so that for any rule f (q1, . . . , qn) → q – where

795

n ≥ 0 – of their transition relations and any free variable ν ∈ fv(G), a new rule

(f, ν)(q1, . . . , qn) → q is added.

Now observe that

Claim 29. There exists a bijection ϕ : Inst ρ(pat(G)) → Inst(pat(G(cid:48)(cid:48)))∩L(B(cid:48))∩

L(C (cid:48)) such that for all t ∈ Inst ρ(pat(G)), t ∈ L(A) if and only if ϕ(t) ∈ L(A(cid:48)(cid:48)).

800

Using Claim 29, we show that one can build an automaton D (resp. D(cid:48)) with

signature Σ(cid:48) such that Inst ρ(pat(G)) ∩ L(A) (cid:54)= ∅ (resp. Inst ρ(pat(G)) ⊆ L(A))

if and only if Inst(pat(G(cid:48)(cid:48))) ∩ L(D) (cid:54)= ∅ (resp. Inst(pat(G(cid:48)(cid:48))) ⊆ L(D(cid:48))). This

35

allows to reduce uniform regular matching (resp. inclusion) with constraints to

uniform regular matching (resp. inclusion).

805

Claim 30. cMatch(G, A) is reducible in polynomial time to Match(G, A).

Claim 31. cIncl(G, A) is reducible in polynomial time to Incl(G, A).

The Proposition thus follows from Claims 30 and 31.

Note that because of the constraints, Σ(cid:48) depends not only on Σ, but also on
G. So cMatchΣ(G, A) (resp. cInclΣ(G, A)) cannot be reduced to MatchΣ(cid:48)(cid:48)GA,
InclΣ(cid:48)(cid:48) GA) for some signature Σ(cid:48)(cid:48), but only to Match(G, A) (resp.

(resp.

810

Incl(G, A)).

8. Encoding Patterns for Unranked Trees

The original motivation of the present work was to understand the prob-

lems of regular matching and inclusion for hedge patterns. We next show that

815

these problems can be solved using reductions to the corresponding problems of

(ranked) tree patterns with context variables.

Unlike ranked trees, unranked trees are constructed from symbols without

ﬁxed arities. We ﬁx a ﬁnite set Γ of such symbols. The set of hedges HΓ is
∗ and all pairs a(H) where

the least set that contains all words of hedges in HΓ

820

a ∈ Γ and H ∈ HΓ is a hedge. The set of unranked trees UΓ is the subset of

hedges of the form a(H).

We assume a set of variables for unranked trees Y ∈ V u and a set of hedge

variables Z ∈ V h. The set of hedge patterns H ∈ P h

of variables is then deﬁned by the abstract syntax in Fig. 15. The set P u

Γ with these two types
Γ of
patterns for unranked trees is the subset of hedge patterns of the forms a(H) or

825

Y ∈ V u. The set of free variables fv(H) is deﬁned as usual. A well-typed variable

assignment σ : V → HΓ where V ⊆ V u (cid:93) V h is a function that maps variables
from V u to unranked trees in UΓ and variables from V h to hedges in HΓ. The

application σ(H) is the hedge obtained from H by replacing all variables Y by

830

the unranked tree σ(Y ) and all variables Z by the hedge σ(Z). The instance

36

Hedge patterns H, H (cid:48) ∈ P h
Γ

::= Y | a(H) | ε | Z | HH (cid:48)

(cid:104)ε(cid:105)context = λy.y,

(cid:104)H(cid:105)tree = (cid:104)H(cid:105)context @#,

Encoding

(cid:104)Y (cid:105)context = Y,

(cid:104)Z(cid:105)context = Z,

(cid:104)a(H)(cid:105)context = λy.a((cid:104)H(cid:105)context @#, y),

(cid:104)HH (cid:48)(cid:105)context = λy.((cid:104)H(cid:105)context @((cid:104)H (cid:48)(cid:105)context @y)).

Figure 15: Encoding of a hedge pattern H ∈ P h

Γ into a context pattern (cid:104)H(cid:105)context ∈ P context

Σ

,

where Y ∈ V u, Z ∈ V h, a ∈ Γ, and ε is the empty word.

set of H is denoted Inst(H) = {σ(H) | σ : fv(H) → HΓ well-typed}. Note that
Inst(H) ⊆ UΓ for any unranked tree pattern H ∈ P u
Γ .

We next show in Fig. 15 how to encode hedge patterns into (ranked) context

patterns over a ranked signature Σ = Σ(2) (cid:93) Σ(0) where Σ(2) = Γ, Σ(0) = {#}

835

and # is a fresh symbol not in Γ. Our encoding is an extension of the ﬁrst-

child-next-sibling encoding [6]. For instance, the hedge pattern H0 = a(ZbcY ) is
encoded into the context pattern (cid:104)H0(cid:105)context = λy.a(Z@(b(#, c(#, Y @#))), y).

The concatenation operation on hedges is simulated by the application operation

of contexts. The set of context variables used in the encoding is V context =

840

V u (cid:93) V h. Finally, we deﬁne for any unranked tree H ∈ P u

Γ its encoding as a tree

pattern (cid:104)H(cid:105)tree ∈ P tree

Σ

by (cid:104)H(cid:105)tree = (cid:104)H(cid:105)context @#.

In order to show the soundness of this encoding (Lemma 32 below), we need

to restrict the instantiation operation.

Intuitively, we cannot allow arbitrary

substitutions to be applied to (cid:104)H(cid:105)tree because then the resulting tree pattern

845

might not be a correct encoding of an unranked tree. A variable assignment

σ : V → Val Σ is called unranked if it maps unranked tree variables to (cid:104)UΓ(cid:105)context
and hedge variables to (cid:104)HΓ(cid:105)context . The unranked-restricted instance set of a tree
pattern p is deﬁned by Inst unr (p) = {norm β(σ(p)) | σ : fv(p) → Val Σ well-typed

and unranked}.

850

Lemma 32. norm β((cid:104)Inst(H)(cid:105)tree ) = Inst unr ((cid:104)H(cid:105)tree ) for any H ∈ P u
Γ .

Let P comp,u
Γ

be the set of compressed unranked tree patterns over Γ, deﬁned

37

in an analogous way as compressed tree patterns. For a class of automata A ∈

{Dta, Nta} we deﬁne problems of regular matching and inclusion of compressed

unranked tree patterns:

Unranked regular matching: MatchΓ(P comp,u, A).
Input: an unranked tree pattern H ∈ P comp,u
Output: whether Inst unr ((cid:104)H(cid:105)tree ) ∩ L(A) (cid:54)= ∅.

Γ

and an automaton A ∈ AΣ

855

Unranked regular inclusion: InclΓ(P comp,u, A).
Input: an unranked tree pattern H ∈ P comp,u
Output: whether Inst unr ((cid:104)H(cid:105)tree ) ⊆ L(A).

Γ

and an automaton A ∈ AΣ

The uniform versions of these problems where the signature Γ is given with

the input are called Match(P comp,u, A) and respectively Incl(P comp,u, A).

Note that using tree automata in the above deﬁnitions is not a restriction, as it

860

is well known [6] that for any unranked tree language L recognizable by a hedge

automaton, there exists a tree automaton that recognizes the ﬁrst-child-next-

sibling encoding of the trees in L.

Proposition 33. For any class of automata A ∈ {Dta, Nta} there exist re-

ductions in polynomial time from Match(P comp,u, A) to Match(P comp,tree , A)

865

and from Incl(P comp,u, A) to Incl(P comp,tree , A).

Proof. Let Γ be an alphabet, Σ = Σ(2) ∪ Σ(0) a ranked signature constituted of

binary symbols taken from Γ and a constant #, that is Σ(2) = Γ, Σ(0) = {#}
and # (cid:54)∈ Γ. Let H ∈ P comp,u

be a compressed pattern, A ∈ {Dta, Nta}

Γ

870

a class of automata and A ∈ AΣ a tree automaton. Thanks to Lemma 32,
we have norm β((cid:104)Inst(H)(cid:105)tree ) = Inst unr ((cid:104)H(cid:105)tree ), and thus deciding whether
norm β((cid:104)Inst(H)(cid:105)tree )∩L(A) (cid:54)= ∅ is equivalent to deciding whether the inequality
Inst unr ((cid:104)H(cid:105)tree ) ∩ L(A) (cid:54)= ∅ holds. Notice that unr is actually an instantiation

constraint. It associates every free tree variable with the universal Dta over

Σ. Context variables are mapped to the Dta that recognizes all the trees over

875

Σ (cid:93) {y} having only one occurrence of y, which is furthermore either the only

38

node of the tree, or the second son of its parent, as enforced by the encoding.

We have thus reduced the problem of regular matching of compressed unranked

tree patterns to the problem of regular matching with constraints – on ranked

patterns – in polynomial time. Then the regular matching problem with con-

880

straints is reduced to uniform regular matching using Proposition 28. We use

an analogous procedure for the inclusion problem.

Theorem 34. For any alphabet Γ having at least two symbols, the problems
MatchΓ(P comp,u, Dta) and InclΓ(P comp,u, Dta) are Pspace-complete while
MatchΓ(P comp,u, Nta) and InclΓ(P comp,u, Nta) are Exp-complete.

885

Proof. The upper bounds follow via the polynomial time reduction from Propo-

sition 33 and the complexities in Proposition 26. The lower bounds can be ob-

tained by reducing the equivalent problems on ranked patterns to the version on

unranked patterns, and further using the results in Propositions 21 and 24.

9. Linearity Restriction

890

We now study the complexity of regular matching and inclusion for the class

LinP comp,tree that maps ranked signatures Σ to the set of linear compressed
tree patterns LinP comp,tree

.

Σ

Proposition 35. Match(LinP comp,tree , Nta) is in P.

Proof. Let Σ be a ranked signature, G = (N, Σ, R, S) ∈ LinP comp,tree
compressed tree pattern and A = (Q, Σ, F, ∆) an Nta. Given that the instance

a linear

Σ

895

set of the linear pattern pat(G) is regular, one could think of building an Nta

that recognizes Inst(pat(G)), but since P(G) may be exponential in the size of

G, this approach does not work in polynomial time.

Instead we evaluate the pattern G directly in the Σ-algebra ∆, while mapping

900

context variables to the accessibility relation of ∆. So let acc∆ : Q → 2Q be the

function that maps every q ∈ Q to the set of states accessible from state q

with respect to ∆. We consider the well-typed assignment s that maps all

39

tree variables x in fv(G) to s(x) = Q and all context variables X ∈ fv(G) to

s(X) = acc∆. The following then holds:

905

Claim 36. Inst(pat(G)) ∩ L(A) (cid:54)= ∅ if and only if

pat(G)
(cid:75)

(cid:74)

∆,(cid:98)s ∩ F (cid:54)= ∅.

Thanks to Claim 36, one can simply test

∆,(cid:98)s ∩ F (cid:54)= ∅ in order to

pat(G)
(cid:75)

(cid:74)

decide whether Inst(pat(G))∩L(A) (cid:54)= ∅. By Lemma 20, it takes polynomial time

in the sizes of ∆, G and s to compute
MatchΣ(LinP comp,tree , Nta) is in P.

pat(G)
(cid:75)

(cid:74)

∆,(cid:98)s. It follows that the problem

910

We next consider regular inclusion for linear tree patterns. Proposition 35

and the duality via complementation (Lemma 22) yield for Dtas that regular

inclusion for linear patterns is in P too. So it remains to consider the case

of regular inclusion for Ntas. By Lemma 23, this problem is Exp-hard even

without context variables and without compression. Therefore regular inclusion

915

for Ntas and (compressed) linear patterns with or without context variables is

Exp-complete.

Conclusion

We have shown that regular matching and inclusion of ranked tree pat-

terns with context variables against nondeterministic tree automata is Exp-

920

complete with and without compression, while the problem is Pspace-complete

for bottom-up deterministic tree automata. The complexity goes down to P for

linear compressed tree patterns in 3 of 4 cases. The analogous results hold for

unranked tree patterns with hedge variables, which is relevant to certain query

answering on hyperstreams. Previous approaches were limited to hyperstreams

925

containing words (compressed string patterns), while the present approach can

deal with hyperstreams containing unranked data trees (compressed unranked

tree patterns).

40

Acknowledgments

We are grateful to Sylvain Salvati for discussing the relationship of inhabi-

930

tation and lambda-deﬁnability, for pointing out the additional diﬃculties when

generalizing from context to unrestricted second-order functions, and for help-

ing us to reduce the upper bounds from double exponential time to exponential

time.

We also thank the reviewers of Information & Computation for their high

935

quality feedback which helped us improve the presentation of this article.

This work was partially supported by a grant from CPER Nord-Pas de

Calais/FEDER DATA Advanced data science and technologies 2015-2020.

References

[1] I. Boneva, J. Niehren, M. Sakho, Regular Matching and Inclusion on Com-

940

pressed Tree Patterns with Context Variables, in: LATA 2019 - 13th Inter-

national Conference on Language and Automata Theory and Applications,

Saint Petersburg, Russia, 2019.

URL https://hal.inria.fr/hal-01811835

[2] D. Angluin, Finding patterns common to a set of strings., Journal of Com-

945

puter and System Sciences 21 (1980) 46–62.

[3] A. Gasc´on, G. Godoy, M. Schmidt-Schauß, Context matching for com-

pressed terms, in: Proceedings of the Twenty-Third Annual IEEE Sym-

posium on Logic in Computer Science, LICS 2008, 24-27 June 2008,

Pittsburgh, PA, USA, IEEE Computer Society, 2008, pp. 93–102. doi:

950

10.1109/LICS.2008.17.

URL http://dx.doi.org/10.1109/LICS.2008.17

[4] W. Plandowski, Satisﬁability of word equations with constants is in

PSPACE, J. ACM 51 (3) (2004) 483–496. doi:10.1145/990308.990312.

URL https://doi.org/10.1145/990308.990312

41

955

[5] I. Boneva, J. Niehren, M. Sakho, Certain query answering on com-

pressed string patterns: From streams to hyperstreams, in: Reachabil-

ity Problems - 12th International Conference, RP 2018, Marseille, France,

September 24-26, 2018, Proceedings, 2018, pp. 117–132. doi:10.1007/

978-3-030-00250-3\_9.

960

URL https://doi.org/10.1007/978-3-030-00250-3_9

[6] H. Comon, M. Dauchet, R. Gilleron, C. L¨oding, F. Jacquemard, D. Lugiez,

S. Tison, M. Tommasi, Tree automata techniques and applications, Avail-

able online since 1997: http://tata.gforge.inria.fr (Oct. 2007).

[7] M. Schmidt-Schauß, Linear pattern matching of compressed terms and

965

polynomial rewriting, Mathematical Structures in Computer Science 28 (8)

(2018) 1415–1450. doi:10.1017/S0960129518000208.

URL https://doi.org/10.1017/S0960129518000208

[8] A. Jez, Context uniﬁcation is in PSPACE, in: J. Esparza, P. Fraigni-

aud, T. Husfeldt, E. Koutsoupias (Eds.), Automata, Languages, and Pro-

970

gramming - 41st International Colloquium, ICALP 2014, Copenhagen,

Denmark, July 8-11, 2014, Proceedings, Part II, Vol. 8573 of Lecture

Notes in Computer Science, Springer, 2014, pp. 244–255. doi:10.1007/

978-3-662-43951-7\_21.

URL https://doi.org/10.1007/978-3-662-43951-7_21

975

[9] M. Zaionc, Probabilistic approach to the lambda deﬁnability for fourth

order types, Electr. Notes Theor. Comput. Sci. 140 (2005) 41–54. doi:

10.1016/j.entcs.2005.06.025.

URL https://doi.org/10.1016/j.entcs.2005.06.025

[10] R. Loader, The undecidability of λ-deﬁnability, in: Z. M. Anderson C.A.

980

(Ed.), Logic, Meaning and Computation, Vol. 305, Springer, 2001. doi:

https://doi.org/10.1007/978-94-010-0526-5_15.

[11] T. Joly, Encoding of the halting problem into the monster type & applica-

tions, in: M. Hofmann (Ed.), Typed Lambda Calculi and Applications, 6th

42

International Conference, TLCA 2003, Valencia, Spain, June 10-12, 2003,

985

Proceedings., Vol. 2701 of Lecture Notes in Computer Science, Springer,

2003, pp. 153–166. doi:10.1007/3-540-44904-3\_11.

URL https://doi.org/10.1007/3-540-44904-3_11

[12] D. Kozen, Lower bounds for natural proof systems, in: 18th Annual Sym-

posium on Foundations of Computer Science, Providence, Rhode Island,

990

USA, 31 October - 1 November 1977, IEEE Computer Society, 1977, pp.

254–266. doi:10.1109/SFCS.1977.16.

URL https://doi.org/10.1109/SFCS.1977.16

[13] H. Seidl, Deciding equivalence of ﬁnite tree automata, SIAM J. Comput.

19 (3) (1990) 424–437. doi:10.1137/0219027.

995

URL https://doi.org/10.1137/0219027

[14] S. Maneth, A. O. Pereira, H. Seidl, Transforming XML streams with

references, in: C. S. Iliopoulos, S. J. Puglisi, E. Yilmaz (Eds.), String

Processing and Information Retrieval - 22nd International Symposium,

SPIRE 2015, London, UK, September 1-4, 2015, Proceedings, Vol. 9309

1000

of Lecture Notes in Computer Science, Springer, 2015, pp. 33–45. doi:

10.1007/978-3-319-23826-5_4.

URL https://doi.org/10.1007/978-3-319-23826-5_4

[15] M. Lohrey, S. Maneth, M. Schmidt-Schauß, Parameter reduction and au-

tomata evaluation for grammar-compressed trees, J. Comput. Syst. Sci.

1005

78 (5) (2012) 1651–1669. doi:10.1016/j.jcss.2012.03.003.

URL https://doi.org/10.1016/j.jcss.2012.03.003

[16] W. J. Savitch, Relationships between nondeterministic and deterministic

tape complexities, Journal of Computer and System Sciences 4 (2) (1970)

177 – 192. doi:https://doi.org/10.1016/S0022-0000(70)80006-X.

1010

URL

http://www.sciencedirect.com/science/article/pii/

S002200007080006X

43

Appendix A. Proofs for Section 3 (Inhabitation for Tree Automata)

Theorem 7 (Folklore). Tree inhabitation Inhabtree

Σ (Nta) is Exp-complete,

while its restriction to deterministic tree automata Inhabtree

Σ (Dta) is in P.

1015

Proof. The upper bounds were shown in Proposition 6. The Exp lower bound

for Ntas follows from a reduction from nonemptiness of intersection of a ﬁnite
number of deterministic tree automata InterΣ(Dta), which is well known to
be ExpTime-complete [13].

Let A1, . . . , An be a sequence of Dtas with signature Σ. We want to know

whether ∩n

generality, we can assume that each of them has a single ﬁnal state F i = {qi

i=1L(Ai) (cid:54)= ∅. Suppose that Ai = (Qi, Σ, Fi, ∆i). Without loss of
f } 2.
i=1Qi,
f }. Since all Ai are deterministic, it holds that
L(Ai) (cid:54)= ∅. In order to see (*), let t ∈ TΣ

Let A be the disjoint union of all Ai, that is A = (Q, Σ, F, ∆) where Q = (cid:93)n
∆ = (cid:93)n

f , . . . , qn
i=1∆i and F = {q1
(*) F is ∆-inhabited if and only if

n
(cid:84)
i=1

be a tree. It then holds that:

t ∈

n
(cid:84)
i=1

L(Ai)

iﬀ for all i ∈ {1, . . . , n} : qi

∆i

f ∈

t
(cid:74)
(cid:75)
f } =

t

∆i
(cid:75)

(cid:74)

iﬀ for all i ∈ {1, . . . , n} : {qi

(Ai is deterministic)

iﬀ {q1

iﬀ {q1

∆

f , . . . , qn
f , . . . , qn

t
(cid:75)

f } =
f } is ∆-inhabited by t.

(cid:74)

The property (*) shows that InterΣ(Dta) can be reduced to Inhabtree
in polynomial time, so Inhabtree

Σ (Nta) is Exp hard.

Σ (Nta)

1020

Lemma 9. For any context C ∈ CΣ and Nta A = (Q, Σ, F, ∆) the ∆-inhabited

value

C

∆ is a union homomorphism on 2Q.
(cid:75)

(cid:74)

Proof. Any context C ∈ CΣ has the form λx.t such that x occurs exactly once

in t. The proof is by induction on the structure of t.

automata A(cid:48)

2Otherwise, we ﬁx a nonconstant g ∈ Σ \ Σ(0) and a constant a ∈ Σ(0). We then compute
i) = g(L(Ai), a, . . . , a). These can be constructed in P from Ai such
i) (cid:54)= ∅.

that they have a unique ﬁnal state. Furthermore, ∩n

i=1L(Ai) (cid:54)= ∅ if and only if ∩n

i with L(A(cid:48)

i=1L(A(cid:48)

44

1025

• Case t = x. We then have that

for all Q(cid:48) ⊆ Q.

In particular

(cid:74)
subsets Q(cid:48), Q(cid:48)(cid:48) ⊆ Q, it holds that

C

∆(Q(cid:48)) =

λx.x

∆(Q(cid:48)) =

Q(cid:48)

∆ = Q(cid:48)

(cid:74)
C

(cid:75)
∆(∅) = ∅. Furthermore for any two

(cid:75)

(cid:74)

(cid:74)

(cid:75)

∆(Q(cid:48) ∪ Q(cid:48)(cid:48)) = Q(cid:48) ∪ Q(cid:48)(cid:48) =
(cid:75)
∆ is a union homomorphism.

C

∆(Q(cid:48)) ∪
(cid:75)

(cid:74)

(cid:75)
C
(cid:74)

∆(Q(cid:48)(cid:48)). Thus

C

(cid:74)

(cid:75)

C

(cid:74)

(cid:75)

• Case t = f (t1, . . . , tn) and x occurs exactly once in t, say in tk but not

1030

elsewhere.

Let Sk =

∆ for all i (cid:54)= k. Clearly Sk is ∆-
(cid:75)
inhabited. We then have by the induction hypothesis that Sk is a union

∆ and Qi =
(cid:75)

λx.tk
(cid:74)

ti

(cid:74)

homomorphism. Furthermore, we have that for all Q(cid:48) ⊆ Q,

C

∆(Q(cid:48)) =

(cid:74)
∆(Q(cid:48)). By deﬁnition of

(cid:75)

λx.f (t1, . . . , tn)
(cid:75)

(cid:74)
(cid:74)
algebra evaluation, we have

∆(Q(cid:48)) =

f (t1, . . . , λx.tk, . . . , tn)
(cid:75)

f (t1, . . . , λx.tk, . . . , tn)
(cid:75)
(cid:74)

∆(Q(cid:48)) = {q | ∃q1 ∈
Q1, . . . , qk ∈ Sk(Q(cid:48)), . . . , ∃qn ∈ Qn. f (q1, . . . , qn) → q in ∆}. This im-
∆(Q(cid:48) ∪ Q(cid:48)(cid:48)) = {q | ∃q1 ∈
plies that for any two subsets Q(cid:48), Q(cid:48)(cid:48) ⊆ Q,
Q1, . . . , qk ∈ Sk(Q(cid:48)) ∪ Sk(Q(cid:48)(cid:48)), . . . ∃qn ∈ Qn. f (q1, . . . , qn) → q in ∆} =
∆ is a union
(cid:75)

∆(Q(cid:48)(cid:48)). In particular,

∆(∅) = ∅. So

∆(Q(cid:48)) ∪

C
(cid:74)

C
(cid:74)

C

C

C

(cid:75)

(cid:74)

(cid:75)

(cid:75)

(cid:74)
(cid:75)
homomorphism.

(cid:74)

1035

1040

Lemma 15. The problem Inhabcontext (Dta) can be reduced in polynomial time

to its restriction where the input function s : Q → 2Q always maps to singletons.

Proof. If there exists q ∈ Q such that s(q) contains more than one element

1045

then s cannot be inhabited for any Dta.

It remains to remove cases where

s(q) = ∅ for some q ∈ Q. The main idea to deal with empty sets is to complete

A to A(cid:48) by adding a sink state qsink and to replace function s by s(cid:48) such that
s(cid:48)(q) = s(q) if s(q) (cid:54)= ∅ and s(cid:48)(q) = {qsink} otherwise. Inhabitation of s with
respect to A is then equivalent to inhabitation of s(cid:48) with respect to A(cid:48). However,

1050

this construction may take exponential time in the maximal arity of function

symbols of A with is not ﬁxed for the uniform problem. This problem can be

circumvented by a trick, permitting to complete A only partially.

45

Here is how it works. We consider a Dta A = (Q, Σ, F, ∆) and a function

s : Q → 2Q. We construct another Dta A(cid:48) = (Q(cid:48), Σ(cid:48), F (cid:48), ∆(cid:48)) and a function
s(cid:48) : Q(cid:48) → 2Q(cid:48)

\ ∅ such that ˆs is ∆-inhabited if and only if ˆs(cid:48) is ∆(cid:48)-inhabited.

1055

The ﬁrst idea would be to set A(cid:48) as the completion of A. We then have

Σ(cid:48) = Σ and Q(cid:48) = Q ∪ {qsink} where qsink is some fresh sink state. Furthermore,
the set of rules ∆(cid:48) subsumes ∆ and all the rules f (q1, . . . , qn) → qsink with
q1, . . . , qn ∈ Q(cid:48) for which f (q1, . . . , qn) is not a left-hand side of any rule in ∆.
The function s(cid:48) is deﬁned such that s(cid:48)(q) = s(q) if s(q) (cid:54)= ∅ and s(cid:48)(q) = {qsink}

1060

otherwise. One can then see for any context C ∈ CΣ that ˆs is ∆-inhabited by
C if and only if ˆs(cid:48) is ∆(cid:48)-inhabited by C. The size of ∆(cid:48) is in O(|∆| + |Σ||Q|n)

where n is the maximal arity of function symbols in Σ. Unfortunately, the

maximal arity is not ﬁxed in the uniform version since Σ is part of the input.

1065

Therefore, this reduction requires exponential space in the worst case, while

polynomial time was claimed.

The second idea is to perform some kind of partial completion, so that only

polynomially many rules need to be added. For this, we deﬁne the signature

Σ(cid:48) = Σ ∪ {g} where g is a fresh monadic function symbol. For any context

C ∈ CΣ we deﬁne a context in CΣ(cid:48) by C (cid:48) = λx.C@g(x). The state set of A(cid:48)
remains Q(cid:48) = Q ∪ {qsink} where qsink is some fresh state as before. The set of
rules ∆(cid:48) extends ∆ by the following rules for all q ∈ Q:




h(q) →

qsink

if s(q) = ∅



q

else

Furthermore, we add the following rule for all rules f (q1, . . . , qn) → q(cid:48) of ∆ and

all 1 ≤ i ≤ n:

f (q1 . . . , qi−1, qsink, qi+1, . . . , qn) → qsink

It can then be shown for any context C ∈ CΣ, that ˆs is ∆-inhabited by C if
and only if ˆs(cid:48) is ∆(cid:48)-inhabited by C (cid:48). Now the construction of A(cid:48) is in time

O(|A|2 + |s|) which is polynomial even if the maximal arity of function symbols

1070

in Σ is not bounded.

Proposition 16. Inhabcontext (Dta) is in Pspace.

46

Proof. Let Σ be a ranked signature, A = (Q, Σ, F, ∆) a Dta where Q =

{q1, . . . , qn} and all the states are accessible, s : Q → 2Q a function and x a

fresh constant not in Σ. We assume w.l.o.g. that s(qi) (cid:54)= ∅ for all 1 ≤ i ≤ n

1075

(see Lemma 15). If |s(qi)| > 1 for some 1 ≤ i ≤ n, then ˆs is not ∆-inhabited,

given that A is deterministic. The following lines consider the case where all

the images by s are singletons. First we reduce the inhabitation of ˆs to the
nonemptiness of the intersection of n + 1 Dtas A1, . . . , An+1. In a second step,

we reduce the nonemptiness of the intersection of A1, . . . , An+1 to the nonempti-
ness of the intersection of n Dfas A(cid:48)

1, . . . , Wi.

1080

We write Σx = Σ∪{x}. For any i ∈ {1, . . . , n}, let Ai = (Q, Σx, s(qi), ∆i) be

the tree automaton on Σx having the same states as A, whose set of ﬁnal states

is s(qi), and whose transition relation is ∆i = ∆ ∪ {x → qi}. We also write
An+1 to denote the simple Dta that accepts all trees t ∈ TΣx having exactly
one occurrence of x. We ﬁrst show that

1085

Claim 37. There exists a context λx.p ∈ CΣ such that

if

n+1
(cid:84)
i=1

L(Ai) (cid:54)= ∅.

∆ = ˆs if and only

λx.p
(cid:74)

(cid:75)

1090

1095

λx.p

∆ =

(cid:74)

(cid:75)

Proof. On one hand, if there is a context λx.p ∈ CΣ such that

ˆs, then by Proposition 11 we have

p[x/{qi}]

(cid:74)

∆ = s(qi) for any 1 ≤ i ≤ n.
(cid:75)

This implies that p ∈ L(Ai) for any 1 ≤ i ≤ n, and since λx.p is a context,

p contains exactly one occurrence of x and thus belongs to L(An+1). Hence
n+1
(cid:84)
i=1

L(Ai) ⊇ {p} (cid:54)= ∅. On the other hand, assume

L(Ai) (cid:54)= ∅ and let

n+1
(cid:84)
i=1

n+1
(cid:84)
i=1

p ∈

L(Ai). Given that p ∈ L(An+1), it contains exactly one occurrence of

states s(qj), and p ∈

x. Furthermore, since the automata Aj are all deterministic with unique ﬁnal
∆i = s(qi) for 1 ≤ i ≤ n. This
(cid:75)

n
(cid:84)
j=1
∆ = s(qi) for 1 ≤ i ≤ n, and thus

L(Aj), we have

implies that

p

(cid:74)

λx.p
(cid:74)

∆ = ˆs.
(cid:75)

p[x/{qi}]
(cid:74)

(cid:75)

According to Claim 37, deciding whether or not ˆs is ∆-inhabited is equivalent
to determining if the Dtas Ai have an nonempty intersection. Next we show a
Pspace algorithm to decide

L(Ai) (cid:54)= ∅, by reduction to Inter(Dfa).

n+1
(cid:84)
i=1

47

f (q(cid:48)

Let ΣQ be the alphabet that contains the symbol x, and for any rule
1, . . . , q(cid:48)
k−1, q(cid:48)
the symbol f (q(cid:48)

m) → q(cid:48)(cid:48) in ∆ and any 1 ≤ k ≤ m, ΣQ contains
k+1, . . . , q(cid:48)
m), where m is the arity of f . Formally,

k+1, . . . , q(cid:48)
k−1, (cid:63), q(cid:48)

k, q(cid:48)
1, . . . , q(cid:48)

ΣQ = {x} ∪





f (q(cid:48)

1, . . . , q(cid:48)

k+1, . . . , q(cid:48)
k−1, (cid:63), q(cid:48)
f ∈ Σ(m), 1 ≤ k ≤ m and ∃q(cid:48)

f (q(cid:48)

1, . . . , q(cid:48)

k−1, q(cid:48)

k, q(cid:48)

k+1, . . . , q(cid:48)

m) | m is an arity in Σ,
k, q(cid:48)
m) → q(cid:48)

m+1 ∈ Q.

m+1 ∈ ∆





1100

The notation introduced for the elements of ΣQ allows us to distinguish them

from the trees in TΣx∪Q. This is because the elements of ΣQ are considered as

atomic symbols. Now let the alphabet S = ΣQ ∪ {⊥}. For some i ∈ {1, . . . , n}

and a tree t ∈ TΣx ∩ L(An+1) over Σx containing exactly one occurrence of x,
we deﬁne inductively the run path rpi(t) of t with respect to the Dta Ai as a
word over S such that:

1105

• if t = x, then rpi(t) = x

• if t = f (t1, . . . , tk−1, tk, tk+1, . . . , tm) for some arity m ≥ 0, symbol f ∈
Σ(m), integer k ∈ {1, . . . , m} so that tk contains the only occurrence of x

in t, then

rpi(t) =






1, . . . , q(cid:48)

rpi(tk)f (q(cid:48)
1 ≤ j ≤ m and f (q(cid:48)

k−1, (cid:63), q(cid:48)
1, . . . , q(cid:48)

k+1, . . . , q(cid:48)
k−1, (cid:63), q(cid:48)

m) if {q(cid:48)
k+1, . . . , q(cid:48)

j} =

tj

(cid:75)
(cid:74)
m) ∈ ΣQ

∆i for all j (cid:54)= k,

rpi(tk)⊥ otherwise

Example 3. For instance, consider that Σ = {f (2), b(1), c(1), a(0)} and the tran-
sition relation ∆1 of the Dta A1 is such that ∆1 = {x → q1, a → q2, b(q1) →
q3, f (q2, q3) → q4} ∪ ∆(cid:48) where ∆(cid:48) consists of the remaining rules that make

1110

∆1 complete. Then the run path of the tree f (a, b(x)) with respect to A1 is

x b((cid:63)) f (q2, (cid:63)) as illustrated in Figure A.16. On the other hand, the run path

of f (c(a), b(x)) with respect to A1 is x b((cid:63)) ⊥, as the subtree c(a) cannot be

evaluated.

48

f f (q2,(cid:63))

a

bb((cid:63))

xx

Figure A.16: Run path (in blue) of the tree f (a, b(x)) with respect to A1.

Claim 38. Let t ∈ TΣx ∩ L(An+1) be a tree over Σx containing exactly one

1115

occurrence of x. Then rpi(t) = rpj(t) for all i, j ∈ {1, . . . , n}.

Proof. Let i, j ∈ {1, . . . , n}. The proof is by induction on the structure of t.

Case t = x. Then rpi(t) = rpj(t) = x by deﬁnition.

Case t = f (t1, . . . , tk, . . . , tm) for some arity m, symbol f ∈ Σ(m), integer k ∈

{1, . . . , m} so that tk contains the only occurrence of x in t. By deﬁnition,

1120

• rpi(t) = rpi(tk)ai

• and rpj(t) = rpj(tk)aj

where ai and aj are such that ai ∈ {f (q(cid:48)
k−1, (cid:63), q(cid:48)(cid:48)
aj ∈ {f (q(cid:48)(cid:48)

m), ⊥},
l ∈ Q, l (cid:54)=
k and l ∈ {1, . . . , m}. By the induction hypothesis, rpi(tk) = rpj(tk).

1, . . . , q(cid:48)
m), ⊥} for states q(cid:48)

k+1, . . . , q(cid:48)(cid:48)

k+1, . . . , q(cid:48)

l ∈ Q, q(cid:48)(cid:48)

k−1, (cid:63), q(cid:48)

1 , . . . , q(cid:48)(cid:48)

1125

Furthermore, we show that ai = aj. Let l ∈ {1, . . . , m} be diﬀerent from k.

Since tl contains no occurrence of x, we have

∆i =

tl
(cid:74)

(cid:75)

tl

∆ =
(cid:75)

(cid:74)

tl

(cid:74)

(cid:75)

∆j . Two

cases may occur, depending on the run of A on tl. Either the run blocks,

1130

tl

(cid:74)

(cid:75)

that is

∆ = ∅, or it doesn’t, implying that

q(cid:48)
l ∈ Q. Now if for all l ∈ {1, . . . , m} diﬀerent from k,
l} , then by deﬁnition ai = f (q(cid:48)
singleton {q(cid:48)
k−1, (cid:63), q(cid:48)(cid:48)

1 , . . . , q(cid:48)(cid:48)

1, . . . , q(cid:48)

f (q(cid:48)(cid:48)

diﬀerent from k such that

k+1, . . . , q(cid:48)(cid:48)
tl

m) = aj. And if there is some l ∈ {1, . . . , m}
∆ = ∅, then by deﬁnition ai = ⊥ = aj. In

tl

(cid:74)

∆ = {q(cid:48)
(cid:75)

l} for some state
∆ equals some
tl
(cid:75)
(cid:74)
k+1, . . . , q(cid:48)
k−1, (cid:63), q(cid:48)

m) =

both cases, ai = aj. Thus rpi(t) = rpj(t).

(cid:74)

(cid:75)

49

1135

Next we build Dfas that accept run paths. Let q0 and q⊥ be fresh states,
and note QDfa = Q ∪ {q0, q⊥}. For all 1 ≤ i ≤ n, we build the Dfa Wi having

QDfa as its set of states, S as its alphabet, {q0} as its set of initial states, s(qi)

as its set of ﬁnal states and δi as its transition function, so that

• δi(q0, x) = qi (1)

1140

1145

• for all f (q(cid:48)

1, . . . , q(cid:48)
1, f ((cid:63), q(cid:48)

m) → q(cid:48)
2, . . . , q(cid:48)

m+1 ∈ ∆i where f ∈ Σ(m) for some arity m, we
1, (cid:63), q(cid:48)
m)) = q(cid:48)
m+1,
m−1, (cid:63))) = q(cid:48)

m+1, δi(q(cid:48)
m+1 (2)

m)) = q(cid:48)

3, . . . , q(cid:48)

2, f (q(cid:48)

m, f (q(cid:48)

1, . . . , q(cid:48)

have δi(q(cid:48)
. . . , δi(q(cid:48)

• for all q ∈ QDfa, δi(q, ⊥) = q⊥ (3)

• for all state q ∈ QDfa and symbol f (q(cid:48)

i−1, (cid:63), q(cid:48)
where m ≥ 0 and 1 ≤ i ≤ m, if no rule in ∆i having f (q(cid:48)
i−1, (cid:63), q(cid:48)
as its left-hand side exists, then δi(q, f (q(cid:48)

1, . . . , q(cid:48)

1, . . . , q(cid:48)

i+1, . . . , q(cid:48)
1, . . . , q(cid:48)
i+1, . . . , q(cid:48)

m) ∈ ΣQ
i+1, q(cid:48)
m)) = q⊥

i−1, q, q(cid:48)

m)

(4).

Note that any Dfa Wi has a size that is polynomial in |A|. Now let p ∈

TΣx ∩ L(An+1) be a tree over Σx containing exactly one occurrence of x.

1150

Claim 39. For all i ∈ {1, . . . , n} and state q ∈ Q,
rpi(p) is evaluated to q by the Dfa Wi.

p
(cid:74)

(cid:75)

∆i = {q} if and only if

Proof. Let i ∈ {1, . . . , n} and q ∈ Q. The proof is by induction on the structure

of p. The backward direction is shown by contraposition.

Case p=x. Then we have rpi(p) = x. First let’s assume that
∆i =

we have q = qi, since

x

∆i = {qi}. Furthermore, Wi in its initial

∆i = {q}. So

p
(cid:75)

(cid:74)

p
(cid:75)

(cid:74)

(cid:74)

(cid:75)

state q0 reads x and enters by (1) in state qi = q. Thus rpi(p) is evaluated

to q by Wi.

For the backwards direction, assume that

x

∆i = {qi} (cid:54)= {q}, that is qi (cid:54)= q. On the other hand, starting from q0,
(cid:75)

(cid:74)
Wi evaluates x to qi (cid:54)= q according to (1).

p

∆i (cid:54)= {q}. This implies that
(cid:75)

(cid:74)

1155

1160

50

Case p = f (p1, . . . , pk) where f ∈ Σ(k) and p1, . . . pk ∈ TΣx . Then there exists

a unique l ∈ {1, . . . , k} such that pl contains exactly one occurrence of x,

and for all j ∈ {1, . . . , k}, if j (cid:54)= l then pj ∈ TΣ – that is pj contains only

symbols in Σ.

1165

First assume that

all 1 ≤ j ≤ k,

pj

(cid:74)

(cid:75)

p
(cid:75)

∆i = {q}. Then there exist states γ1, . . . , γk s.t. for
∆i = {γl}

(cid:74)
∆i = {γj}. By the induction hypothesis,

pl

(cid:74)

(cid:75)

if and only if rpi(pl) is evaluated to γl by Wi. By deﬁnition rpi(p) =
∆i =
(cid:75)

rpi(pl)f (γ1, . . . , γl−1, (cid:63), γl+1, . . . , γk). We also have the equalities

∆i = {q}. So the rule f (γ1, . . . , γk) → q exists in ∆i. By
f (p1, . . . , pk)
(cid:74)
(cid:75)
(2), we also have δi(γl, f (γ1, . . . , γl−1, (cid:63), γl+1, . . . , γk)) = q. So the Dfa

p

(cid:74)

Wi in state q0 ﬁrst reads the word rpi(pl) to get in state γl, before ﬁnally

entering state q after having read f (γ1, . . . , γl−1, (cid:63), γl+1, . . . , γk). So rpi(p)

can be evaluated to q by Wi.

For the backwards direction, assume that

p

∆i (cid:54)= {q}. Two cases may
(cid:75)

(cid:74)

1170

1175

occur:

Case

∆i = ∅ . Then

p
(cid:75)

(cid:74)
• either

∆i = ∅ for some j ∈ {1, . . . , k} (i),

pj

(cid:74)

(cid:75)

• or there exist states γ1, . . . , γk s.t. for all j ∈ {1, . . . , k},

pj
(cid:74)

∆i =
(cid:75)

{γj}, but there is no rule in ∆i having f (γ1, . . . , γk) as its left-

1180

hand side (ii).

In (i), if j (cid:54)= l we have by deﬁnition that rpi(p) = rpi(pl)⊥. Ac-
cording to rule (3), whatever the state in which the Dfa Wi

is

after having read rpi(pl), Wi goes to state q⊥ when reading ⊥.

1185

and

And since q⊥ (cid:54)= q, the claim holds. On the other hand, if j = l
∆i = {γj(cid:48)} for all j(cid:48) ∈ {1, . . . , k} diﬀerent from j, then
(cid:75)

rpi(p) = rpi(pl)f (γ1, . . . , γl−1, (cid:63), γl+1, . . . , γk). By the induction hy-

pj(cid:48)
(cid:74)

pothesis, Wi evaluates rpi(pl) to a state that is not in Q. The only

states in QDfa that are not in Q are q0 and q⊥, and given that

rpi(pl) (cid:54)= ε and q0 has no looping transition – Wi can’t stay in state

51

1190

q0 after having read pl –, it follows that the only possible state to

1195

1200

which rpi(pl) has been evaluated by Wi is q⊥. All the transitions in

δi that leave q⊥ end up in q⊥ by the rule (4). Thus Wi evaluates

rpi(p) in state q⊥ (cid:54)= q, and the claim holds.

In (ii), rpi(p) = rpi(pl)f (γ1, . . . , γl−1, (cid:63), γl+1, . . . , γk). By the induc-

tion hypothesis, Wi evaluates rpi(pl) to state γl. But since no rule
f (γ1, . . . , γk) → q(cid:48) exists in ∆i, Wi in state γl – after having read

rpi(pl) – goes to state q⊥ after reading f (γ1, . . . , γl−1, (cid:63), γl+1, . . . , γk),

according to rule (4). Thus the claim holds.

Case

(cid:74)

(cid:74)

(cid:75)

pj

p
(cid:75)

1 ≤ j ≤ k,

∆i = {q(cid:48)} (cid:54)= {q} . Then there exist states γ1, . . . , γk s.t. for all
∆i = {γj}. Moreover, there is a rule f (γ1, . . . , γk) →
q(cid:48) ∈ ∆i, but no rule f (γ1, . . . , γk) → q in ∆i. Thus by (2), we have
that δ(γl, f (γ1, . . . , γl−1, (cid:63), γl+1, . . . , γk)) = q(cid:48). This implies that the
Dfa Wi in state q0, ﬁrst reads rpi(pl) to get in state γl, then reads
the symbol f (γ1, . . . , γl−1, (cid:63), γl+1, . . . , γk) to enter state q(cid:48) (cid:54)= q. Thus

1205

the claim holds.

We next state:

Claim 40.

n+1
(cid:84)
i=1

L(Ai) (cid:54)= ∅ if and only if

n
(cid:84)
i=1

L(Wi) (cid:54)= ∅.

1210

x. By Claim 39, for all i ∈ {1, . . . , n},

Proof. Let p ∈ Σx ∩ L(An+1) be a tree containing exactly one occurrence of
∆i = s(qi) if and only if rpi(p) is
evaluated to the single element of s(qi) by Wi. So p ∈ L(Ai) if and only if

p
(cid:74)

(cid:75)

rpi(p) ∈ L(Wi) for 1 ≤ i ≤ n. Claim 38 has established that rpj(p) = rpk(p)

for all j, k ∈ {1, . . . , n}. It then follows that p ∈

L(Ai) if and only if rp1(p) =

n
(cid:84)
i=1

. . . = rpn(p) ∈

n
(cid:84)
i=1

L(Wi). So

n+1
(cid:84)
i=1

L(Ai) (cid:54)= ∅ if and only if

n
(cid:84)
i=1

L(Wi) (cid:54)= ∅.

1215

if

It follows from Claim 37 and Claim 40 that ˆs is ∆-inhabited if and only
n
(cid:84)
L(Wi) (cid:54)= ∅. Thus Inhabcontext (Dta) is reducible in polynomial time to
i=1

Inter(Dfa). Hence Inhabcontext (Dta) is in Pspace.

52

Appendix B. Proofs for Section 7 (Adding Regular Constraints)

1220

Claim 29. There exists a bijection ϕ : Inst ρ(pat(G)) → Inst(pat(G(cid:48)(cid:48)))∩L(B(cid:48))∩

L(C (cid:48)) such that for all t ∈ Inst ρ(pat(G)), t ∈ L(A) if and only if ϕ(t) ∈ L(A(cid:48)(cid:48)).

Proof. We construct ϕ as the function that transforms an element of t ∈ Inst ρ(pat(G))

satisfying the constraints in ρ to an element of t(cid:48) ∈ Inst(pat(G(cid:48)(cid:48))) in which all

the constraints in ρ are satisﬁed – modulo the change of signature from Σ to Σ(cid:48)

–, thus implying that t(cid:48) ∈ L(B(cid:48)) ∩ L(C (cid:48)). We ﬁrst introduce a function ann ν

for all variable ν ∈ V, such that for all tree variable x, n-ary function symbol f

and trees t1, . . . , tn where n ≥ 0:

ann ν(x) = holeν(x)

ann ν(f (t1, . . . , tn)) = (f, ν)(ann ν(t1), . . . , ann ν(tn))

Then we deﬁne ϕ so that for all well-typed substitution µ : fv(G) → P gr

Σ , the

image of the grounding p = norm β(µ(pat(G)))) is such that

• every subterm of p obtained by instantiating some tree variable x of G is

1225

replaced by rootx(ann x(µ(x)))

• every subterm of p obtained by instantiating some context variable X is

replaced by rootX (ann X (t)), where µ(X) = λxρ.t

For example, if we set Σ = {f (2), a(0), b(0)}, G = ({z, x, X}, Σ, {z → f (x, X@b)}, z),

µ(x) = a and µ(X) = λxρ.f (a, xρ), then the pattern in Figure B.17 gives the

1230

value of ϕ(norm β(µ(pat(G)))).

Furthermore, for all t ∈ Inst ρ(pat(G)), t ∈ L(A) if and only if ϕ(t) ∈ L(A(cid:48)(cid:48)).

Claim 30. cMatch(G, A) is reducible in polynomial time to Match(G, A).

Proof. Let t ∈ Inst ρ(pat(G)) be a constrained instance of G by ρ. By Claim 29,

1235

t ∈ L(A) iﬀ ϕ(t) ∈ L(A(cid:48)(cid:48)). Given that ϕ(t) ∈ Inst(pat(G(cid:48)(cid:48))) ∩ L(B(cid:48)) ∩ L(C (cid:48)),

53

f

rootx

rootX

(a, x)

(f, X)

(a, X)

holeX

b

Figure B.17: Example of image value by ϕ

it follows that Inst ρ(pat(G)) ∩ L(A) (cid:54)= ∅ iﬀ Inst(pat(G(cid:48)(cid:48))) ∩ (L(B(cid:48)) ∩ L(C (cid:48)) ∩

L(A(cid:48)(cid:48))) (cid:54)= ∅. One can compute a product automaton D in polynomial time

from A(cid:48)(cid:48) and B(cid:48) and C (cid:48) so that L(D) = L(A(cid:48)(cid:48)) ∩ L(B(cid:48)) ∩ L(C (cid:48)). Furthermore,

if A(cid:48)(cid:48) is deterministic, then D is also deterministic – knowing that B(cid:48) and C (cid:48)

1240

are deterministic. Thus Inst ρ(pat(G)) ∩ L(A) (cid:54)= ∅ iﬀ Inst(pat(G(cid:48)(cid:48))) ∩ L(D) (cid:54)= ∅,

hence cMatch(G, A) is reducible in polynomial time to Match(G, A).

Claim 31. cIncl(G, A) is reducible in polynomial time to Incl(G, A).

Proof. Let t ∈ Inst ρ(pat(G)) be a constrained instance of G by ρ. By Claim 29,

t ∈ L(A) iﬀ ϕ(t) ∈ L(A(cid:48)(cid:48)). Given that ϕ(t) ∈ Inst(pat(G(cid:48))) ∩ L(B(cid:48)) ∩ L(C (cid:48)), it

1245

follows that Inst ρ(pat(G)) ⊆ L(A) iﬀ Inst(pat(G(cid:48)(cid:48))) ∩ L(B(cid:48)) ∩ L(C (cid:48)) ⊆ L(A(cid:48)(cid:48)).

Let the product automaton B(cid:48) × C (cid:48) recognizing the language L(B(cid:48)) ∩ L(C (cid:48)).

Then Inst ρ(pat(G)) ⊆ L(A) iﬀ Inst(pat(G(cid:48)(cid:48))) ∩ L(B(cid:48) × C (cid:48)) ⊆ L(A(cid:48)(cid:48)), that is

Inst(pat(G(cid:48)(cid:48))) ⊆ L(A(cid:48)(cid:48)) ∪ L(B(cid:48) × C (cid:48)) where B(cid:48) × C (cid:48) is the automaton recogniz-

ing the complement of L(B(cid:48) × C (cid:48)). The Dta B(cid:48) × C (cid:48) can be complemented

1250

in linear time to obtain B(cid:48) × C (cid:48), since it is deterministic. Moreover a product

automaton D(cid:48) recognizing L(A(cid:48)(cid:48)) ∪ L(B(cid:48) × C (cid:48)) can be built in polynomial time

from A(cid:48)(cid:48) and B(cid:48) × C (cid:48), so that D(cid:48) is deterministic if A(cid:48)(cid:48) is deterministic. Thus

Inst ρ(pat(G)) ⊆ L(A) iﬀ Inst(pat(G(cid:48))) ⊆ L(D(cid:48)), hence cIncl(G, A) is reducible

in polynomial time to Incl(G, A).

54

1255

Appendix C. Proofs for Section 8 (Encoding Patterns for Unranked

Trees)

Lemma 32. norm β((cid:104)Inst(H)(cid:105)tree ) = Inst unr ((cid:104)H(cid:105)tree ) for any H ∈ P u
Γ .

Proof. Let H ∈ P u

Γ be an unranked tree pattern. The proof is by induction on

the structure of H.

1260

Case H = a(ε) where a ∈ Γ. Then the following equalities Inst(H) = {a(ε)}

and (cid:104)Inst(H)(cid:105)tree = {λy.a((λy.y)@#, y)@#} hold. This implies that
norm β((cid:104)Inst(H)(cid:105)tree ) = {a(#, #)} = Inst unr ((cid:104)H(cid:105)tree ), since H contains

no variable to instantiate.

1265

Case H = Y ∈ V u . Then Inst(H) = {a(H (cid:48)) | a ∈ Γ and H (cid:48) ∈ HΓ} and
(cid:104)Inst(H)(cid:105)tree = {(λy.a((cid:104)H (cid:48)(cid:105)tree , y))@# | a ∈ Γ and H (cid:48) ∈ HΓ}. This im-
plies that norm β((cid:104)Inst(H)(cid:105)tree ) = {a(norm β((cid:104)H (cid:48)(cid:105)tree ), #) | a ∈ Γ and H (cid:48) ∈
HΓ} = Inst unr ((cid:104)H(cid:105)tree ) since no unranked tree a(H (cid:48)) ∈ Inst(H) contains

a variable to instantiate.

Case H = b(H (cid:48)) where b ∈ Γ and H (cid:48) ∈ P h

Γ . Then Inst(H) = {b(H (cid:48)(cid:48)) | H (cid:48)(cid:48) ∈
Inst(H (cid:48))} and (cid:104)Inst(H)(cid:105)tree = {(λy.b((cid:104)H (cid:48)(cid:48)(cid:105)tree , y))@# | H (cid:48)(cid:48) ∈ Inst(H (cid:48))}.

1270

So norm β((cid:104)Inst(H)(cid:105)tree ) = {b(norm β((cid:104)H (cid:48)(cid:48)(cid:105)tree ), #) | H (cid:48)(cid:48) ∈ Inst(H (cid:48))}.
By the induction hypothesis, norm β((cid:104)Inst(H (cid:48))(cid:105)tree ) = Inst unr ((cid:104)H (cid:48)(cid:105)tree ),
which implies that norm β((cid:104)Inst(H)(cid:105)tree ) = {b(t, #) | t ∈ Inst unr ((cid:104)H (cid:48)(cid:105)tree )} =
Inst unr ((cid:104)H(cid:105)tree ).

1275

Appendix D. Proofs for Section 9 (Linearity Restriction)

Claim 36. Inst(pat(G)) ∩ L(A) (cid:54)= ∅ if and only if

pat(G)
(cid:75)

(cid:74)

∆,(cid:98)s ∩ F (cid:54)= ∅.

Proof. For the forward direction, assume Inst(pat(G)) ∩ L(A) (cid:54)= ∅. According

to Lemma 25, there exists a well-typed assignment σ : fv(G) →

Val Σ
(cid:74)

∆ such
(cid:75)

1280

that

pat(G)
(cid:74)

(cid:75)

∆,σ ∩ F (cid:54)= ∅. For all tree variable x ∈ fv(G) (resp. context variable

55

X ∈ fv(G)), the construction of s guarantees that σ(x) ⊆ s(x) = Q (resp. for all

q ∈ Q, σ(X)(q) ⊆ s(X)(q) = acc∆(q)). This implies that

too.

pat(G)
(cid:74)

∆,ˆs ∩ F (cid:54)= ∅
(cid:75)

For the inverse direction, let pS ∈ P tree

Σ

be such that R(S) = pS in G

1285

and assume

pat(G)
(cid:74)

∆,(cid:98)σ ∩ F (cid:54)= ∅. We prove the property by induction on the

(cid:75)

structure of pS.

1290

1295

• Case pS = x ∈ V. Then

∆,(cid:98)s = s(x) = Q. Since A is reduced

and that all the states of the Nta are accessible, it holds that for all

pat(G)
(cid:75)

(cid:74)

q ∈

qf ∈

(cid:74)
pat(G)

∆. Let
∆,(cid:98)s there exists a tree t ∈ TΣ such that q ∈
pat(G)
(cid:75)
(cid:75)
∆,(cid:98)s ∩ F . There exists a tree tf ∈ L(A) such that qf ∈
(cid:75)

∆,

tf

(cid:74)

(cid:74)

(cid:75)

t

(cid:74)

hence tf ∈ Inst(pat(G)) ∩ L(A).

• Case pS = X@x. We have

pat(G)

qf ∈ (cid:91)s(X)(s(x)) ∩ F be in the intersection of
s(X) = acc∆, there is a state qr ∈ Q such that qf ∈ acc∆(qr), and
∆({qr}). Furthermore,

thus a context λx.pf ∈ CΣ such that qf ∈

pat(G)
(cid:74)

(cid:75)

∆,(cid:98)s = (cid:91)s(X)(s(x)). Let the state
(cid:75)
∆,(cid:98)s and F . Since

(cid:74)

λx.pf
(cid:74)

(cid:75)

qr ∈ s(x) = Q is an accessible state of A, and so there is a tree tr such
∆({qr}), and

∆. Notice that qf ∈

(λx.pf )@tr

that qr ∈

tr

∆ =
(cid:75)

λx.pf
(cid:74)

(cid:75)

(cid:74)

(cid:75)

(cid:74)

thus (λx.pf )@tr ∈ Inst(pat(G)) ∩ L(A).

• The cases pS = t and pS = X@t where t ∈ TΣ and X ∈ V context are

1300

respectively special instances of the ﬁrst and second cases.

• Case pS = f (S1, . . . , Sn) where f ∈ Σ(n), S1, . . . , Sn ∈ N \ fv(G) are

starting symbols for some linear compressed tree patterns G1, . . . , Gn ∈
LinP comp,tree and for all diﬀerent i, j ∈ {1, . . . , n}, fv(Gi) ∩ fv(Gj) (cid:54)= ∅.

Here we have assumed without loss of generality that any compressed

1305

tree pattern is built only from smaller compressed tree patterns. Thus

if there were some constant symbol or free variable v occurring in pS,

one could just create a new compressed tree pattern G(cid:48) from G where

the occurrences of v in S are replaced by a new nonterminal Sv, and

with the additional rule Sv → v. But for the sake of simplicity, we sup-

56

1310

pose that G is already in the form we want it to be. Thus every Si

∆,(cid:98)s =

We have that

pat(G)
(cid:74)

can be considered as the start symbol of the compressed tree pattern Gi.
∆,(cid:98)s = {q | ∃q1 ∈
(cid:75)
∆,(cid:98)s. f (q1, . . . , qn) → q in ∆}. Let qf ∈
∆,(cid:98)s, . . . , ∃qn ∈
(cid:75)
∆,(cid:98)s ∩ F (cid:54)= ∅. Then by the induction hypothesis, there exists t1 ∈
∆,ˆs,

f (pat(G1), . . . , pat(Gn))
(cid:74)
(cid:75)
pat(Gn)
(cid:75)

(cid:74)
Inst(pat(G1)), . . . , tn ∈ Inst(pat(Gn)) such that qf ∈

pat(G)
(cid:75)

pat(G1)

(cid:74)

(cid:74)

f (t1, . . . , tn)
(cid:75)

(cid:74)

and thus f (t1, . . . , tn) ∈ Inst(pat(G)) ∩ L(A). Hence the property holds.

1315

57

