Integrating Connection Search in Graph Queries
Angelos Christos Anadiotis, Ioana Manolescu, Madhulika Mohanty

To cite this version:

Angelos Christos Anadiotis, Ioana Manolescu, Madhulika Mohanty. Integrating Connection Search in
Graph Queries. BDA 2022 - 38ème Conférence sur la Gestion de Données - Principes, Technologies
et Applications (Informal publication only), Oct 2022, Clermont-Ferrand, France. ￿hal-03886320￿

HAL Id: hal-03886320

https://inria.hal.science/hal-03886320

Submitted on 24 Dec 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution 4.0 International License

Integrating connection search in graph queries

Angelos Christos Anadiotis∗
Oracle, Switzerland
angelos.anadiotis@oracle.com

Ioana Manolescu
Inria and IPP, France
ioana.manolescu@inria.fr

Madhulika Mohanty
Inria and IPP, France
madhulika.mohanty@inria.fr

ABSTRACT

Graph data management and querying has many practical appli-
cations. When graphs are very heterogeneous and/or users are
unfamiliar with their structure, they may need to find how two or
more groups of nodes are connected in a graph, even when users are
not able to describe the connections. This is only partially supported
by existing query languages, which allow searching for paths, but
not for trees connecting three or more node groups. The latter is re-
lated to the NP-hard Group Steiner Tree problem, and has been
previously considered for keyword search in databases.

In this work, we formally show how to integrate connecting tree
patterns (CTPs, in short) within a graph query language such as
SPARQL or Cypher, leading to an Extended Query Language (or EQL,
in short). We then study a set of algorithms for evaluating CTPs;
we generalize prior keyword search work, most importantly by
(𝑖) considering bidirectional edge traversal and (𝑖𝑖) allowing users
to select any score function for ranking CTP results. To cope with
very large search spaces, we propose an efficient pruning technique
and formally establish a large set of cases where our algorithm,
MoLESP, is complete even with pruning. Our experiments validate
the performance of our CTP and EQL evaluation algorithms on a
large set of synthetic and real-world workloads.

1 INTRODUCTION

Graph databases are increasingly adopted in a wide range of ap-
plications spanning from social network analysis to scientific data
exploration, the financial industry, and many more. To query RDF
graphs, one can use the W3C’s standard SPARQL [13] query lan-
guage; for property graphs, Cypher [35] is among the best known.
An interesting but challenging query language feature is reacha-
bility: a SPARQL 1.1 query can check, e.g., if there are some paths
along which Mr. Shady deposits funds into a given bank ABC. Such
queries are important in investigative journalism applications [5],
in the fight against money laundering, etc. SPARQL allows checking
for the existence of a path, but does not return the matching paths
to users. In contrast, a Cypher query may also return the paths
between two given sets of nodes.

Unfortunately, none of these languages support finding trees,
connecting three (or more) sets of nodes, while the latter can be
very useful. For instance, when investigating ill-acquired wealth,
one may want to find “all connections between Mr. Shady, bank
company ABC, and the tax office of the DEF republic”: an answer
to this query is a tree, connecting three nodes corresponding to the
person, bank, and tax office, respectively.

Searching for connections among 𝑚 sets of nodes is closely re-
lated to the Group Steiner Tree Problem (GSTP), which asks for the
least-cost, e.g., fewest-edges, tree; the problem is NP-hard. The data-
base literature has studied many variants of this problem under the

∗Work done while at Ecole Polytechnique.

name of keyword search in databases, for e.g., [1, 4, 10, 12, 16, 26, 30,
39, 40, 44]. To cope with the high complexity, existing algorithms
(𝑖) consider a fixed cost function and leverage its properties to limit
the search, (𝑖𝑖) propose approximate solutions, within a known dis-
tance from the optimum, and/or (𝑖𝑖𝑖) implement heuristics without
guarantees but which have performed well on some problems.
Requirements Our recent collaborations with investigative jour-
nalists [5, 6] lead to identifying the following set of needs. First, (R1)
graph query languages should allow returning trees that connect 𝑚
node sets, for some integer 𝑚 ≥ 2; (R2) it must be possible to search
for connecting trees orthogonally to (or, in conjunction with any)
score functions used to compare and rank the trees. This is because
different graphs and applications are best served by different scores,
and when exploring a graph, journalists need to experiment with
several before they find interesting patterns. For instance, in the
example above, if Mr. Shady is a citizen of DEF and ABC has offices
there, the smallest solution connects them through the DEF coun-
try node; however, this is not interesting to journalists. Instead, a
connection through three ABC accounts, sending money from DEF
to Mr. Shady in country GHI, is likely much more interesting. An
orthogonal requirement is (R3) to treat graphs as undirected when
searching for trees. For instance, the graph may contain “Mr. Shady
belongsTo
hasAccount
−−−−−−−−−→ acct1”, or, just as likely, “acct1
−−−−−−−−→ Mr. Shady”.
We cannot afford to miss a connecting tree because we “expected”
an edge in a direction and it happens to be in the opposite direction.
Further, (R4) all answers need to be found (within a time and/or
space budget) for several reasons: (𝑖) continuity with the seman-
tics of standard graph query languages, that also return all results
(unless users explicitly LIMIT the result size); (𝑖𝑖) to remain indepen-
dent of, and thus orthogonal to, the cost function (recall (R2)); and,
(𝑖𝑖𝑖) for practical reasons, given the problem complexity, which is
further exacerbated by (R3), and renders complete search on large
graphs unfeasible. Finally, (R5) the extended queries should be effi-
ciently executed, even when graphs are highly heterogeneous, as in
investigative journalism scenarios, where text, structured, and/or
semistructured sources are integrated together.
Contributions To address the above requirements, we make the
following contributions:

(1) We formally define an Extended Query Language (EQL, in
short), which combines together Basic Graph Pattern (or conjunc-
tive) queries at the core of both SPARQL and Cypher, and Connect-
ing Tree Patterns (CTPs, in short). A CTP allows searching for trees
that connect 𝑚 groups of nodes, for 𝑚 ≥ 2. BGPs and CTPs can
be freely joined. This addresses requirements (R1), (R2), and also
(R3), since our CTP semantics returns trees regardless of the edge
directions (Section 2).

(2) We provide a scalable EQL query evaluation strategy, which
leverages existing algorithms for the well-studied problem of eval-
uating conjunctive queries, contributing to (R5) (Section 3).

2.investsIn

3.Alice
(entrepreneur)

1

4

.
c
i
t
i
z

1

7

.f

e

n

O

f

u

n

d

s

3.p

are

nt

O
f

4.Carole
(entrepreneur)

10.founded
7.OrgC
(company)

19.investsIn

12.Falcon
(politician)

1.founded

1.OrgB
(company)
4.lo

c
ate

dIn

10.USA
(country)

2.Bob
(entrepreneur)

5.citizenOf

6.citizenOf

7.founded

5.OrgA
(company)
15.locatedIn

8.France
(country)

11.“National
Liberal Party”

8.CEO

O f

n

e

3 . c iti z

1

n

I

s

t

s

e

v

9 .i n

6.Doug
(entrepreneur)

11.parentOf

9.Elon
(politician)

12.citizenOf
6 . a ffi l i

1

n

o

t i

a

n

t i o

8 . a ffi li a

1

Figure 1: Sample data graph.

(3) For CTP evaluation, we study a set of baseline algorithms,
and explain that their performance suffers due to repeated (wasted)
work and/or the need to minimize the trees they find; GAM [6]
algorithm is more efficient, but it does not scale in all cases. We
introduce a powerful Edge Set Pruning (ESP) technique, which signif-
icantly speeds up the execution, but can lead to incompleteness. We
then bring two orthogonal modifications which, combined, lead to
our MoLESP algorithm, for which we formally establish complete-
ness for 𝑚 ∈ {2, 3}, which are most frequent, as well as for a large
class of results for arbitrarily large 𝑚. This addresses requirement
(R4) and contributes to (R5) (Section 4).

(4) We experimentally show that: (𝑖) baseline algorithms inspired
from breadth-first search are unfeasible even for small graphs;
(𝑖𝑖) the optimizations we bring here over the GAM algorithm [6]
strongly reduce the search time; (𝑖𝑖𝑖) integrating our MoLESP al-
gorithm with a simple conjunctive graph query engine allows to
efficiently evaluate queries in our extended language (Section 5).
2 EXTENDED QUERY LANGUAGE (EQL)
Definition 2.1 (Graph). A graph G(N, E) consists of a set of nodes
N and a set of edges E ⊆ N × N. Each node 𝑛 ∈ N carries a label
𝑙 (𝑛) from a label set L, which includes the empty label 𝜖. Similarly,
each edge 𝑒 ∈ E has a label 𝑙 (𝑒) ∈ L.

The two main graph data models are RDF graphs, and property
graphs (PGs). To illustrate, in the following, we will rely on RDF
graphs; our work can be transposed with only surface changes to
PGs. Figure 1 introduces a sample graph, assigning an integer ID
and label to each node and edge. We will refer to nodes as 𝑛1, 𝑛2,
etc., e.g., 𝑛1 is the node whose ID is 1 and label is OrgB, and similarly
to edges as 𝑒1, 𝑒2, etc. Labels of literal nodes, e.g., 𝑛11, are enclosed
in quotes; the other nodes are URIs.
Node and edge properties Graph nodes and edges may have other
properties beyond labels; for instance, an RDF node may have 0 or
more types. In our example, types are shown in parentheses under
the nodes. In a PG, nodes and edges can have multiple properties.
We denote by P the set of all properties that nodes and edges may
have; each property 𝑝 ∈ P is a function 𝑝 that, given a node 𝑛
(or edge 𝑒), returns 𝑝 (𝑛), the value of property 𝑝 on node 𝑛 (and
similarly for 𝑒). Without loss of generality, we consider that 𝑙:N→L
belongs to P, that is, the label is a node and/or edge property.

Let V be a set of variable names, to be used in queries. Let
Ω = {=, <, ≤, ∼} be a set of comparison operators, where ∼ denotes
pattern matching such as SQL’s like operator. They are used to
express predicates over nodes and/or edges, as follows:

Definition 2.2 (Predicate). A condition over a variable 𝑣 ∈ V is of
the form 𝑝 (𝑣) 𝑜𝑝 𝑐 where 𝑝 ∈ P, 𝑜𝑝 ∈ Ω and 𝑐 is a constant such
that the operator 𝑜𝑝 is well-defined on any value of property 𝑝
together with 𝑐. A predicate over 𝑣 is a conjunction of conditions
over 𝑣. An empty predicate (no conditions) over 𝑣 is simply 𝑣.

A node 𝑛 ∈ N (or edge 𝑒 ∈ E) satisfies the predicate if and only
if, in every condition of the predicate, replacing 𝑣 with 𝑛 (respec-
tively, 𝑒) and evaluating 𝑜𝑝 yields true. For instance, 𝑙 (𝑣)∼"*lice" ∧
𝜏 (𝑣)=𝜏entrepreneur is a predicate consisting of two conditions, one on
the label (which must end in the string “lice”) and one on the type,
which must be entrepreneur. This predicate is true on the node
𝑛3 in our example, and false on the other nodes and edges. Any
node or edge satisfies the empty predicate. For readability, when
a predicate consists of exactly an equality between a node or edge
label and a constant, we simply use the constant to denote the predi-
cate, thus, 𝑙 (𝑣) = "Alice" can be simply written "Alice", when this is
unambiguous. However, each predicate always involves exactly one
variable (𝑣 in our example), even when the short syntax hides it. We
will revert to the longer syntax when we need to make the variable
explicit, e.g., use it several times in the query.
Definition 2.3 (Edge Pattern). An edge pattern is a triple (𝑝1, 𝑝2, 𝑝3)
of three predicates: 𝑝1 holds over the source node of an edge, 𝑝2
over the edge itself, and 𝑝3 over the target node.

For instance, (𝑙 (𝑠)="Alice", 𝑙 (𝑒)="citizenOf", 𝑑) states that the
source node 𝑠 is labeled "Alice" and the edge 𝑒 is labeled "citizenOf".
The third predicate is a variable. With the above simplification, we
can also write this pattern as ("Alice", "citizenOf", 𝑑).
A core construct of graph query languages is:

Definition 2.4 (Basic Graph Pattern). A Basic Graph Pattern (BGP)
𝑏 is a set of edge patterns that are connected in the following sense.
If the BGP contains at least 2 edge patterns, each pattern must have
a common variable with another edge pattern.

A sample BGP 𝑏1 is: {(𝑥, "citizenOf", "USA"), (𝑥, "founded", "OrgB")}.

Definition 2.5 (CT Pattern). A connecting tree pattern (CTP, in
short) is a tuple of the form: 𝑔 = (𝑔1, 𝑔2, . . . , 𝑔𝑚, 𝑣𝑚+1) where each 𝑔𝑖 ,
1≤𝑖≤𝑚 is a predicate and 𝑣𝑚+1 is a variable. All variables occurring
in 𝑔1, . . . , 𝑔𝑚, 𝑣𝑚+1 are pairwise distinct.

CTPs are used to find connections among nodes, as follows.
When replacing each 𝑔𝑖 with a graph node, 𝑣𝑚+1 is bound to a
subtree of G, having these nodes as leaves (we formalize this below).
To visually distinguish BGPs from CTPs, we always underline the
last variable of a CTP.

Definition 2.6 (Core query). A core query 𝑄 has a head and a body.
The body is a set of 𝑘 BGPs, 𝑘 ≥ 0, and 𝑙 CTPs, 𝑙 ≥ 0, such that
𝑘 + 𝑙 > 0, and each underlined (last) variable from a CTP appears
exactly once in 𝑄. The head is a subset of the body variables.

An example core query, 𝑄1, consists of 3 BGPs and a CTP:

(𝑥, 𝑦, 𝑧, 𝑤):- (𝜏 (𝑥) = 𝜏entrepreneur, "citizenOf", "USA")

𝑄1

2

(𝜏 (𝑦) = 𝜏entrepreneur, "citizenOf", "France"),
(𝜏 (𝑧) = 𝜏politician, "citizenOf", "France"), (𝑥, 𝑦, 𝑧, 𝑤)

𝑄1 asks: “What are the connections 𝑤 between some American
entrepreneur 𝑥, some French entrepreneur 𝑦, and some French
politician 𝑧?” We denote the CTP of this query by 𝑔1. To define core
query semantics, our first notion is:
Definition 2.7 (BGP embedding). Given a BGP 𝑏 = {𝑡1, . . . , 𝑡𝑘 }, an
embedding of 𝑏 into G is a function 𝜙, associating to each variable
𝑣 in 𝑏, a node 𝑛 ∈ N or an edge 𝑒 ∈ E, such that (𝑖) 𝜙 (𝑣) satisfies all
the predicates on 𝑣 in 𝑏; and (𝑖𝑖) for every edge pattern (𝑠, 𝑒, 𝑑) in 𝑏,
the edge 𝜙 (𝑒) ∈ E goes from 𝜙 (𝑠) to 𝜙 (𝑑).

A sample embedding 𝜙 for the first BGP of 𝑄1 maps 𝑥 to 𝑛4,

"USA" to 𝑛10, "citizenOf" to 𝑒6, etc.

Next, we define:

Definition 2.8 (Set-based CTP result). Let 𝑔 = (𝑔1, . . . , 𝑔𝑚, 𝑣𝑚+1)
be a CTP pattern and 𝑆1, . . . , 𝑆𝑚 be sets of G nodes, called seed
sets, such that every node in 𝑆𝑖 satisfies 𝑔𝑖 , for 1≤𝑖≤𝑚. The result
of 𝑔 based on 𝑆1, . . . , 𝑆𝑚, denoted 𝑔(𝑆1, . . . , 𝑆𝑚), is the set of all
(𝑠1, . . . , 𝑠𝑚, 𝑡) tuples such that 𝑠1∈ 𝑆1, . . ., 𝑠𝑚 ∈ 𝑆𝑚 and 𝑡 is a minimal
subtree of G containing the nodes 𝑠1, . . . , 𝑠𝑚. By minimal, we mean
that (𝑖) removing any edge from 𝑡 disconnects it and/or removes
some 𝑠𝑖 from 𝑡, and (𝑖𝑖) 𝑡 contains only one node from each 𝑆𝑖 .

𝑒10−−→ 𝑛7

In our sample graph, let 𝑆1 = {𝑛2, 𝑛4} (US entrepreneurs), 𝑆2 =
{𝑛3, 𝑛6} (French entrepreneurs), and 𝑆3 = {𝑛9} (French politicians).
Then, 𝑔1 (𝑆1, 𝑆2, 𝑆3) includes (𝑛4, 𝑛6, 𝑛9, 𝑡𝛼 ) where the tree 𝑡𝛼 con-
𝑒9←−− 𝑛6
𝑒11←−− 𝑛9, also denoted by
sists of the edges 𝑛4
{𝑒10, 𝑒9, 𝑒11} for brevity. Another result of this CTP is (𝑛2, 𝑛3, 𝑛9, 𝑡𝛽 ),
with 𝑡𝛽 = {𝑒1, 𝑒2, 𝑒17, 𝑒16}. This result is only possible because
Def. 2.8 allows trees to span over G edges regardless of the edge
direction. Had it required directed trees, 𝑡𝛽 would not qualify, since
none of its nodes can reach the others through unidirectional paths.
The above definition allows arbitrary seed sets, in particular, an
𝑆𝑖 can be N, the set of all graph nodes. We adjust Def. 2.8 to allow
a connecting tree to have any number of nodes from those seed sets
equal to N (otherwise, only 1-node trees would appear in results).
Difference wrt path-based semantics Consider a simple CTP
𝑔′ = (𝑣1, 𝑣2, 𝑣3) and two seed sets 𝑆1, 𝑆2. 𝑔′ (𝑆1, 𝑆2) may differ from
the set of all paths between an 𝑆1 node and an 𝑆2 node: for instance,
a path going from 𝑠1∈ 𝑆1 through 𝑠′
1∈ 𝑆1 to 𝑠2∈ 𝑆2 cannot appear in
𝑔′ (𝑆1, 𝑆2), because of our minimality condition (𝑖𝑖), requiring direct
connections between seeds from different sets. Further, consider a
CTP 𝑔′′ = (𝑣1, 𝑣2, 𝑣3, 𝑣4) and some seed sets 𝑆1, 𝑆2, 𝑆3. One may try
to compute 𝑔′′ (𝑆1, 𝑆2, 𝑆3) by a three-way join of the paths from a
common root node 𝑟 , to a node from 𝑆1, one from 𝑆2 and one from
𝑆3; we call this approach path stitching. The results may differ
even more: (𝑖) for each tree of 𝑛 nodes that appears in 𝑔′′ (𝑆1, 𝑆2, 𝑆3),
the three-way join produces 𝑛 results, that need deduplication; (𝑖𝑖) if
a path from 𝑟 to 𝑠1 has common nodes or even common edges with
a path from 𝑟 to 𝑠2 and/or the one from 𝑟 to 𝑠3, the join of these
paths is not a tree, thus it cannot appear in a CTP result. This is why
in this work, we compute CTP results directly (not via stitching).
Note that a CTP can have a very large number of results, as
illustrated by the graph in Figure 2. A CTP (1, 𝑁 + 1, 𝑣3), asking
for all the connections between the end nodes, has 2𝑁 solutions,
or 2|𝐸 |/2, which grows exponentially in |𝐸|, the number of graph
edges. This is why complete CTP result computation may be
unfeasible in some cases, and we will include in our language
CTP filters for limiting the CTP result computation effort.

𝑎

𝑎

1

𝑎

𝑎

2

3

4

𝑎

. . .

𝑁

𝑁 + 1

𝑏

𝑏

𝑏
Figure 2: Sample “chain” graph.

We call simple variable in a query a variable that does not occur

in the last position in a CTP. For a core query 𝑄, we define:

Definition 2.9 (Simple embedding). A simple embedding of 𝑄 in
G is a function 𝜙 mapping each simple variable into a G node or
edge, such that:

(1) The restriction of 𝜙 to each BGP pattern 𝑏 of 𝑄 is an em-

bedding of 𝑏 into G (Def. 2.7);

(2) For each query CTP of the form 𝑔 = (𝑔1, . . . , 𝑔𝑚, 𝑣𝑚+1),
such that the simple variable in the predicate 𝑔𝑖 , for 1≤𝑖≤𝑚,
is 𝑣𝑖 , 𝜙 maps each 𝑣𝑖 into a G node satisfying 𝑔𝑖 .

𝑣 𝑗
𝑖

𝑖 , as 𝜋

(Φ), that is: all the nodes to which 𝑣 𝑗

Definition 2.10 (Core query result). Let 𝑄 be a core query having
the head variables 𝑢1, . . . , 𝑢𝑛, and the simple variables 𝑣1, . . . , 𝑣𝑝 . Let
Φ be the set of all (𝜙 (𝑣1), . . . , 𝜙 (𝑣𝑝 )) tuples for any simple embed-
ding 𝜙 of 𝑄 in G. For each CTP 𝑔 𝑗 in 𝑄 of the form (𝑔1, . . . , 𝑔𝑚, 𝑣𝑚+1),
let 𝑣 𝑗
𝑖 be the simple variable in 𝑔𝑖 , 1≤𝑖≤𝑚. We define the 𝑖-th seed
set of 𝑔 𝑗 , denoted 𝑆 𝑗
𝑖 is
bound in Φ. The result of 𝑄 is:
𝑄 (G) = 𝜋𝑢1,...,𝑢𝑛 (Φ ⊲⊳ 𝑔1 (𝑆1
, . . . , 𝑆1
1
where 𝑔1, . . . , 𝑔𝑙 are the CTPs of 𝑄, having respectively 𝑚 𝑗 simple
variables, 1≤ 𝑗 ≤𝑙, 𝑔 𝑗 (𝑆 𝑗
𝑚 𝑗 ) is the set-based CTP result of 𝑔 𝑗
1
(Def. 2.8) on its seed sets derived from Φ, and ⊲⊳ denotes the natural
join on all the simple variables.
CTP filters A set of orthogonal language extensions, which allow
to filter (restrict) set based CTP results, are also provided.

) ⊲⊳ . . . ⊲⊳ 𝑔𝑙 (𝑆𝑙
1

, . . . , 𝑆 𝑗

, . . . , 𝑆𝑙

𝑚𝑙 ))

𝑚1

The keyword UNI after a CTP indicates that only unidirectional
trees are sought, that is: a tree 𝑡, as in Def. 2.8, must have a root
node, from which a directed path goes to each seed node in 𝑡.

Adding LABEL and a set of labels {𝑙1, 𝑙2, . . . , 𝑙𝑘 } after a CTP in-
dicates that the edges in any result of that CTP must have labels
from the given set.

Adding MAX 𝑛 after a CTP indicates that only trees of at most 𝑛

edges are sought.

A score function 𝜎 can be used to assign to each tree in a CTP
result a real number 𝜎 (𝑡) (the higher, the better). Specifying (for
a given CTP or for the whole query) SCORE 𝜎 [TOP 𝑘] means that
the results of each CTPs must be scored using 𝜎, and the scores
included in the query result. The optional TOP 𝑘 allows to restrict
the CTP result to those having the 𝑘-highest 𝜎 scores.

Finally, a practical way to limit the evaluation of a CTP (recall the
example on Figure 2) is to specify a timeout 𝑇 (maximum allowed
evaluation time); for simplicity, we consider the same 𝑇 is allotted
to each CTP in a query.

Definition 2.11 (Query). A query consists of a core query, together
with 0 or more filters for each CTP.

The semantics of a query is easily derived from that of a core

query (Def. 2.10), by filtering set-based CTP results accordingly.

3

3 QUERY EVALUATION STRATEGY

An EQL query consists of a set of BGPs and a set of CTPs. Our
evaluation strategy consists of the following steps:
(A) Evaluate each BGP 𝑏𝑖 , that is, compute all embeddings of its
variables, and materialize them in a table 𝐵𝑖 .
(B) For each CTP 𝑔 𝑗 of the query, of the form (𝑔 𝑗
1

, . . . , 𝑔 𝑗
𝑚 𝑗

𝑚 𝑗 +1

, 𝑣 𝑗

):

(1) For 1 ≤ 𝑖 ≤ 𝑚 𝑗 , where 𝑣 𝑗

𝑖 is the variable in 𝑔 𝑗

𝑖 , compute the

seed set 𝑆 𝑗
• If 𝑣 𝑗

𝑖 as follows.
𝑖 appears also in one of the 𝐵𝑖 , take 𝑆 𝑗

𝑖 to be 𝜋

𝑣 𝑗
𝑖

(𝐵𝑖 )

(all the nodes to which 𝑣 𝑗
𝑖 is not an empty predicate, restrict 𝑆 𝑗
𝑔 𝑗
nodes that also satisfy 𝑔 𝑗
𝑖 .
• Otherwise, we obtain 𝑆 𝑗
𝑖 by restricting N (the graph’s

𝑖 has been bound). Further, if
𝑖 to only those

nodes set) to those that match 𝑔 𝑗
𝑖 .
, . . . , 𝑆 𝑗

(2) Compute 𝐹 𝑗 (𝑔 𝑗 (𝑆 𝑗
1

𝑚 𝑗 )), where 𝐹 𝑗 (·) applies all the
CTP filters that may be attached to 𝑔 𝑗 . In practice, we actu-
ally push the filters in the CTP evaluation. Thus, we use the
notation 𝑔 𝑗 (𝑆 𝑗
, 𝐹 𝑗 ) to denote the set-based result of
1
𝑔 𝑗 given its seed sets and filters, and store it in a table 𝐶𝑇 𝑃 𝑗 .

, . . . , 𝑆 𝑗
𝑚 𝑗

(C) Compute the query result as a projection on the head variables,
over the natural join of the 𝐵𝑖 and 𝐶𝑇 𝑃 𝑗 tables.

All the above steps but (B) can be implemented by leveraging an
existing conjunctive graph query engine. Thus, in the sequel, we
focus on efficiently computing set-based CTP results.

4 COMPUTING SET-BASED CTP RESULTS
To compute 𝑔(𝑆1, . . . , 𝑆𝑚, 𝐹 ), we must find all the minimal subtrees
of G = (N, E) containing exactly one node (or seed) from each 𝑆𝑖 ,
also taking into account the filters 𝐹 . Since 𝐹 is optional, we first
discuss how to compute CTP results without any filter (Section 4.1
to 4.7), before discussing pushing filters (Section 4.8).
Observation 1. Let us call leaf any node in a tree that is adjacent
to exactly one edge. It is easy to see that in each CTP result, every
leaf node is a seed. (Otherwise, the leaf could be removed while
still preserving an answer, which contradicts the minimality of the
result.) Clearly, the converse does not hold: in a result, some seeds
may be internal nodes. We denote by sat(𝑡) the node sets from
which 𝑡 has a seed.
Observation 2. As stated in Section 2, we may be only computing
partial CTP results. In such cases, it is reasonable to return at least
the smallest-size results, given that tree size (smaller is better) is
an ingredient of many score functions (see Section 6), and small
results are easy to understand. However, we do not assume “smaller
is always better”: that is for the score function 𝜎 to decide. Nor do
we require users to specify a maximum result size, which may be
hard for them to guess. Rather, we consider algorithms that find as
many results as possible, as fast as possible, also taking into account
the CTP filters, which may limit the search.
Seed set size Most of our discussion assumes that no seed set is N,
and that they all fit easily in memory. We briefly discuss how the
contrary situations could be handled, in Section 4.9.

4.1 Simple Breadth-First algorithm (BFT)
The first algorithm we consider finds the tree results in breadth-first
fashion, thus we call it BFT. It starts by creating a first generation of
trees 𝑇0, containing a one-node tree, denoted Init (𝑛), for each seed
node 𝑛 ∈ 𝑆1 ∪ . . . ∪ 𝑆𝑚. Then, from each generation 𝑇𝑖 , it builds the
trees 𝑇𝑖+1, by “growing” each tree 𝑡 in 𝑇𝑖 , successively, with every
edge (𝑛, 𝑛′) adjacent to one of its nodes 𝑛 ∈ 𝑡, such that:

• (Grow1): 𝑛′ is not already in 𝑡, and
• (Grow2): 𝑛′ is not a seed from a set 𝑆 𝑗 ∈ sat(𝑡).

Condition (Grow1) ensures we only build trees. (Grow2) en-
forces the CTP result minimality condition (𝑖𝑖) (Def. 2.8). As trees
grow from their original seed, they can include more seeds. When a
tree has a seed from each set, it must be minimized, by removing all
edges that do not lead to a seed, before reporting it in the result. For
instance, with the seed sets {𝑛2} and {𝑛4} on the graph in Figure 1,
starting from 𝑛2, BFT may build {𝑒5, 𝑒4}, then {𝑒5, 𝑒4, 𝑒6} before
realizing that 𝑒4 is useless, and removing it through minimization.
Minimization slows BFT down, as we experimentally show in Sec-
tion 5.4.1. BFT can build a tree in multiple ways; to avoid duplicate
work, any tree built during the search must be stored, and each
new tree is checked against this memory of the search.

It is easy to see that BFT is complete, i.e., given enough time

and memory, it finds all CTP results.
4.2 GAM algorithm

The GAM (Grow and Aggressive Merge) algorithm has been intro-
duced recently [6], reusing some ideas from [16]. Unlike BFT that
views a tree as a set of edges, GAM distinguishes one root node in
each tree it builds. The algorithm uses a priority queue where Grow
opportunities are inserted, as (tree, edge) pairs such that the tree
could grow from its root with that edge.

GAM also starts from the set of Init trees built from the seed sets.
Next, it inserts in the priority queue all (𝑡, 𝑒) pairs for some Init
tree 𝑡 and edge 𝑒 adjacent to the root (only node) of 𝑡, satisfying the
conditions (Grow1) and (Grow2) introduced in Section 4.1. GAM
then repeats the following, until no new trees can be built, or a
time-out is reached:

(1) (Grow): Pop a highest-priority (𝑡, 𝑒) pair from the priority
queue, where 𝑒 = (𝑡 .𝑟𝑜𝑜𝑡, 𝑛′), and build the tree 𝑡𝑖 having
all edges of 𝑡 as well as 𝑒, and rooted in 𝑛′.
(2) (Merge): For any tree 𝑡𝑖𝑖 already built, such that:

• (Merge1): 𝑡𝑖𝑖 has the same root as 𝑡𝑖 , and no other

node in common with 𝑡𝑖 ; and
• (Merge2): sat(𝑡𝑖 ) ∩ sat(𝑡𝑖𝑖 )= ∅,

take the following steps:
(a) Create 𝑡𝑖𝑖𝑖 , a tree having the edges of 𝑡𝑖 and those of

𝑡𝑖𝑖 , and the same root as 𝑡𝑖 and 𝑡𝑖𝑖 ;

(b) Immediately Merge 𝑡𝑖𝑖𝑖 with all qualifying trees (see
conditions Merge1, Merge2), and again merge the
resulting trees etc., until no more Merge are possible;
(3) For each tree 𝑡𝑖𝑣 created via Grow or Merge as above: (𝑖) if
𝑡𝑖𝑣 has a seed from each set, report it as a result; (𝑖𝑖) other-
wise, push in the priority queue all (𝑡𝑖𝑣, 𝑒𝑖𝑣) pairs such that
𝑒𝑖𝑣 is adjacent to the (only) root node of 𝑡𝑖𝑣, satisfying the
conditions (Grow1) and (Grow2).

Property 1 (GAM completeness). The GAM algorithm is complete.

4

Property 2 (GAM result minimality). By construction, each result
tree built by GAM is minimal (in the sense of Def. 2.8).

Thus, GAM does not need to minimize the results it finds.

Search space exploration order Unlike BFT, GAM does not build
trees in the strictly increasing order of their size; Merge may build
quite large trees before some other, smaller trees. The order in
which GAM enumerates trees is determined, first, by the priority
of the queue which holds (𝑡, 𝑒) entries, and second, by the available
Merge opportunities. In this work, to remain compatible with
any score function, we study search algorithms regardless of
(orthogonally to) the search order.

Like BFT, GAM may also build a tree in multiple ways. Formally:

Definition 4.1 (Tree with provenance). A tree with provenance (or
provenance, in short) is a formula of one of the forms shown below,
together with one node called the provenance root:

(1) Init (𝑛) where 𝑛 is a seed; the root of such a provenance is

𝑛 itself;

(2) Grow (𝑡, 𝑒) where 𝑡 is a provenance, its root is 𝑛0, 𝑒 is an
edge going from 𝑛0 to 𝑛1 and 𝑛1 does not appear in 𝑡; in
this case, 𝑛1 is the root of the Grow provenance;

(3) Merge (𝑡1, 𝑡2), where 𝑡1 and 𝑡2 are provenances, rooted in
𝑛1=𝑛2; in this case, 𝑛1 is the root of the Merge provenance.

We call rooted tree a set of edges that, together, form a tree,
together with one distinguished root node. GAM may build several
provenances for the same rooted tree, e.g., Merge (Merge (𝑡1, 𝑡2),𝑡3)
and Merge (𝑡2,Merge (𝑡1, 𝑡3)), for some trees 𝑡1, 𝑡2, 𝑡3. The interest of
a tree as part of a possible result does not depend on its provenance.
Therefore, GAM discards all but the first provenance built for
a given rooted tree.
4.3 BFT variants with Merge

The Merge operation can also be injected in the BFT algorithm
to allow it to build some larger trees before all the smaller trees
have been enumerated. We study two variants: BFT-M merges each
new tree resulting from Grow with all its compatible partners
(Step (2a) in Section 4.2), but does not apply Merge on top of these
Merge results; in contrast, BFT-AM applies both Step (2a) and
Step (2b) to aggressively merge. BFT-M and BFT-AM are obviously
complete. Like BFT, they still need to minimize a potential result
before reporting it. This is because BFT algorithms grow trees from
any of their nodes, thus may add edges on one side of one seed node,
which later turn to be useless. GAM avoids this by growing only
from the root.
4.4 Edge set pruning and ESP algorithm

GAM may build several rooted trees for the same set of edges. For
example, on the graph in Figure 3 with the seeds {𝐵}, {𝐶}, denoting
a rooted tree by its edges and underlining the root, successive
Grow from B lead to B-3-C, successive Grow from C lead to B-3-C,
and Merge of two Grow provenances yields B-3-C. However, the
root is meaningless in a CTP result, which is simply a set of edges.
We introduce:

Definition 4.2 (Edge set). An edge set is a set of edges that, together,
form a tree such that at most 1 leaf is not a seed.

5

A

1

2

B

3

C

Figure 3: ESP incompleteness example.

A result is a particular case of edge set, where all leaves are seeds

(recall Observation 1).

As GAM builds several rooted trees for an edge set, it repeats
some effort: we only need to find each result once. This leads to the
following pruning idea:
Definition 4.3 (Edge-set pruning (ESP)). The ESP pruning technique
during GAM consists of discarding any provenance 𝑡1 whose edge
set is non-empty, such that another provenance 𝑡0, corresponding
to the same edge set, had been created previously.

We will call ESP, in short, the GAM algorithm (Section 4.2) en-
hanced with ESP. As we will show, ESP significantly speeds up
GAM execution. However, ESP compromises completeness for
some graphs, seed sets, and execution orders. That is: depending on
the order in which various trees are built, the first (and only, due to
ESP) provenance for a given edge set may prevent the algorithm
from finding some results.

For instance, consider the graph in Figure 3, and the seed sets

𝑆1 = {𝐴}, 𝑆2 = {𝐵}, 𝑆3 = {𝐶}. A possible execution of GAM is:

(1) Initial trees: A, B, C.
(2) A set of Grow lead to these trees: A–1, B–2, B–3, C–3.
(3) B-3 and C-3 merge into B-3-C.
(4) Grow on A-1 leads to A-1-2, which immediately merges

with B-2, forming A-1-2-B.

(5) After this point:

• If the tree A-1-2-B is built, for instance by Grow on A-
1-2, ESP discards it since A-1-2-B was found in step (4).
Lacking A-1-2-B, we cannot Grow over it to build the
result provenance A-1-2-B-3-C. Nor can we build the
result provenance Merge (A-1-2-B, B-3-C).

• By a similar reasoning, when B-3-C is built, it is dis-
carded by ESP, preventing the construction of of A-1-
2-B-3-C.

Thus, no result is found.

Note that with a favorable execution order, the CTP result would

be found. For instance, from A, B, C, ESP could build:

(1) Through successive Grow: A–1, A-1-2, A-1-2-B, C-3, C-3-B
(2) Then, Merge (A-1-2-B, C-3-B) is a provenance for the result.
This raises the question: can we pick a GAM execution order that
would ensure completeness, even when using ESP? Intuitively, the
order should ensure that for each result 𝑟 , there exists a provenance
𝑝𝑟 for 𝑟 which is certainly built, which requires that at every sub-
expression 𝑒 of 𝑝𝑟 , over an edge set 𝑒𝑠, the first provenance 𝑝𝑒𝑠 we find
for 𝑒𝑠 happens to be rooted in a node that allows to build on 𝑒 until 𝑝𝑟 .
Thus, the decisions made up to building 𝑝𝑒𝑠 would need to have a
“look-ahead” knowledge of the future of the search, which is clearly
not possible. In the above example the “bad” order builds A-1-2-B
first, whereas it would be more favorable to build A-1-2-B. However,
when exploring these three edges, the future of the exploration is
not known; thus, we cannot “pre-determine” the best provenance
for 𝑒𝑠. Recall also from Section 4.2 that different orders may be
suited for partial exploration with different score functions. In a
conservative way, we consider an algorithm incomplete when for
some “bad” execution order it may miss results.

We show that ESP finds some answers for any execution order:

Property 3 (2-seed sets ESP completeness). Let 𝑡 be a result of a
CTP with 2 seed sets. Then, 𝑡 is guaranteed to be found by ESP.

Here and throughout this paper, guaranteed to be found, for a
rooted tree or an edge set, means that at least one provenance for
it is built; ESP cannot prune the one built first.

For 1 seed set, Property 3 is trivially shown, thus we focus on
𝑚 = 2 (two seed sets). In this case, any result is path of 0 or more
edges. We introduce:

Definition 4.4 ((𝑛, 𝑠)-rooted path). Given a CTP and its seed sets
𝑆1, 𝑆2, . . . , 𝑆𝑚, an (𝑛, 𝑠)-rooted path is a rooted path from a seed 𝑠 to
a root node 𝑛, such that the only seed in the path is 𝑠.

Lemma 4.1. Any (𝑛, 𝑠)-rooted path is guaranteed to be found by

GAM with ESP.

Proof. We prove this by exhibiting a provenance for it. First,
for each seed 𝑠 ∈ 𝑆1 ∪ . . . ∪ 𝑆𝑚, Init (𝑠) is guaranteed to be built.
ESP pruning does not apply. Then, any provenance applying only
Grow steps on an Init provenance, is guaranteed to be built by
GAM. Such a provenance is not pruned by ESP, because it is the
only provenance that could lead to its edge set. Thus, successive
Grow on top of any seed 𝑠 is guaranteed to build up to 𝑛, leading
□
to the (𝑛, 𝑠)-rooted path.

Based on the above lemma, we prove Property 3:

Proof. If the result 𝑡 is a node (𝑠1 = 𝑠2), the property is trivial.
If the result is a path of 1 edge, there are two provenances of the
form Grow (Init); the first is already a result. Now, assume 𝑡 has
at least two edges. For any internal node 𝑛 in 𝑡, the (𝑛, 𝑠𝑖 )-rooted
paths from both the (seed) leaves 𝑠1, 𝑠2 of 𝑡 are guaranteed to be
found, by Lemma 4.1. Then, one of two cases may occur: (1) For
some internal node 𝑛0, both rooted paths (𝑛0, 𝑠1) and (𝑛0, 𝑠2) are
created before a sequence of Grow gets from Init (𝑠1) to 𝑠2, and
before the opposite sequence of Grow is built from Init (𝑠2), to
𝑠1. Without loss of generality, let 𝑛0 denote the first internal node
for which these two rooted paths are created. Immediately, Merge
on these creates a provenance of 𝑡. By the way we chose 𝑛0, this
is the first provenance for this edge set, thus not pruned. (2) On
the contrary, assume that successive Grow get from one end of
the path to another, before two rooted paths meet in any internal
node. Assume without loss of generality that Grow (Grow (. . . Init
(𝑠1). . . )) is the first one to reach 𝑠2. Again, by design, this is the first
□
provenance for 𝑡, thus not pruned.

CTP with two seed sets (path queries) are frequent in practice;
on these, GAM [6] and ESP are comparable, and we experimen-
tally show the latter is much more efficient. Next, we add more
algorithmic refinements to significantly extend our completeness
guarantees.
4.5 MoESP algorithm
We now introduce an algorithmic variant called Merge-oriented ESP,
or MoESP, which finds many (but not all) CTP results for arbitrary
numbers of seed sets.

MoESP works like ESP, but it creates more trees. Specifically,
whenever Grow or Merge produces a provenance 𝑡 having strictly

6

A

4

D

1

2

5

6

10

B

7

E

3

8

C

9

F

Figure 4: Sample graph for MoESP discussion.
more seeds than any of its (one or two) children, the algorithm builds
from 𝑡 all the so-called MoESP trees 𝑡 ′ such that:
• 𝑡 ′ has the same edges (and nodes) as 𝑡, but
• 𝑡 ′ is rooted in a seed node, distinct from the root of 𝑡.
The provenance of any such 𝑡 ′ is denoted Mo (𝑡, 𝑟 ) where Mo is
special symbol and 𝑟 is the root of 𝑡 ′. Within MoESP, Merge is
allowed on MoESP trees, but not Grow. More generally, Grow
is disabled on any tree whose provenance includes Mo.

Clearly, MoESP builds a strict superset of the rooted trees created
by ESP (thus, it finds all results of ESP). It also finds the result in
Figure 3. Namely, after creating A, B, C:

(1) Grow leads to the trees: A–1, B–2, B–3, C–3.
(2) B-3 and C-3 merge into B-3-C. MoESP trees are added at

this point: B-3-C and B-3-C.

(3) Grow on A-1 leads to A-1-2, which merges with B-2, form-
ing A-1-2-B. Similarly, A-1-2-B and A-1-2-B are added.

(4) A-1-2-B merges with B-3-C, leading to the result.
We now generalize the example by establishing completeness

guarantees for MoESP.
Definition 4.5 (Simple and 𝑝-simple edge set). A simple edge set
is an edge set (Def. 4.2) where each leaf is a seed and no internal
(non-leaf) node is a seed. A simple edge set is 𝑝-simple, for some
integer 𝑝, if its number of leaves is at most 𝑝.

For instance, consider the sample graph in Figure 4, and the 6
seed sets {𝐴}, {𝐵}, {𝐶}, {𝐷 }, {𝐸}, {𝐹 }. The edge set A-4-D, shown
in red, is 2-simple, and so are: A-1-2-B, shown in blue; B-8-F, etc.
Definition 4.6 (Simple tree decomposition of a solution). Let 𝑡 be a
CTP result. A simple tree decomposition of 𝑡, denoted 𝜃 (𝑡), is a set
of simple edge sets which (𝑖) are a partition of the edges of 𝑡 and
(𝑖𝑖) may share (leaf) nodes with each other.

For instance, in Figure 4, the red, blue, and violet edges, together,
form a result for the 6-seed sets CTP. A simple tree decomposition
of this solution is: {A-4-D, A-1-2-B, B-7-E, B-8-F, B-3-C}. It is easy
to see that a tree 𝑡 has a unique simple tree decomposition 𝜃 (𝑡).
Definition 4.7 (𝑝-piecewise simple solution). A result 𝑡 is 𝑝-piecewise
simple (𝑝ps, in short), for some integer 𝑝, if every edge set in the
simple tree decomposition 𝜃 (𝑡) is 𝑝-simple (Def. 4.5).

The sample result above in Figure 4 is 2ps, since its simple tree
decomposition only contains 2-simple edge sets. The following
important MoESP property guarantees it is found:
Property 4 (MoESP finds 2-piecewise simple solutions). For any
number of seed sets 𝑚, MoESP is guaranteed to find any 2-piecewise
simple result.

Proof. Let 𝑡 be a 2-piecewise simple solution and 𝜃 (𝑡) = {𝑡1, . . . , 𝑡𝑟 }

be its simple tree decomposition. It is easy to see that each 𝑡𝑖 ,
1 and 𝑛𝑖
1 ≤ 𝑖 ≤ 𝑟 , is a path of the form 𝑛𝑖
𝑚
1

𝑚 such that 𝑛𝑖

, . . . , 𝑛𝑖

A

1

x

3

2

C

B

Figure 5: MoESP incompleteness example.

1 and 𝑛𝑖
1 and another rooted in 𝑛𝑖

are seeds, while no other intermediary node is a seed. Lemma 4.1,
which still holds for MoESP, guarantees that rooted paths are built
starting from both 𝑛𝑖
𝑚. As soon as these paths meet, a tree
over the edges of 𝑡𝑖 is created, then thanks to MoESP, one tree
rooted in 𝑛𝑖
𝑚, over the edge set of 𝑡𝑖 , are
created. Because 𝜃 (𝑡) is a simple tree decomposition of 𝑡, if 𝑟 = 1,
the property is proved. If 𝑟 > 1, each seed-rooted tree based on
the edge set of a 𝑡𝑖 has its root in common with at least another
seed-rooted tree over another edge set(s) from 𝜃 (𝑡). Therefore, ag-
gressive Merge ensures that they are eventually all merged, leading
□
to one provenance for 𝑡.

For a CTP with any number 𝑚 of seed sets, a path result is one in
which no node has more than two adjacent edges. In a path result,
seed and non-seed nodes alternate, with the two ends of the paths
being seeds. Thus, any path result is 2ps. It follows then, as a direct
consequence of Property 4:

Property 5 (MoESP finds all path results). For any CTP, MoESP
finds all the path results.

However, outside 2ps results, MoESP may still fail. For instance,
consider the graph in Figure 5, and the seed sets {𝐴}, {𝐵}, {𝐶}. The
only result here is 3-simple. A possible MoESP execution order is:
(1) Starting from A, B, C, Grow produces A–1, B–2, C–3;
(2) B–2–x, followed by B–2–x–3, which merges with C-3 into
B–2–x–3–C, leading also to B–2–x–3–C and B–2–x–3–C.
(3) B-2–x-1 which merges with A-1, leading to B-2-x-1-A and

similar trees rooted in B and A.

(4) Grow produces A-1-x. ESP discards the Merge of A-1-x
with B–2–x, due to the rooted tree built at step (3), over the
same set of edges.

(5) A–1–x–3 is built, then Merge with C-3 creates A–1–x–3–C,

and similar trees rooted in A and C.

(6) Grow produces C-3-x. ESP discards the merges of C-3-x
with A-1-x due to the 3-rooted tree built at step (5) and with
B–2–x due to the 3-rooted tree built at step (2).

(7) At this point, we have trees with two seeds, rooted in 1, 3, A,
B and C. Grow on any of them is impossible, because they
already contain all the edges adjacent to their roots. There
are no Merge possibilities on their roots, either. Thus, the
search fails to find a result.

At steps (4) and (6), ESP is “short-sighted”: it prevents the con-
struction of some trees, necessary for finding the result. Next, we
present another optimization which prevents such errors.
4.6 LESP algorithm

The Limited Edge-Set Pruning (LESP), in short, works like ESP
(Section 4.4), but it limits edge-set pruning, as follows.

(a single 1 in the 𝑖-th position). For a non-seed 𝑛, initially
𝑠𝑠𝑛=0; the 𝑖-th bit is set to 1 when node 𝑛 is reached by the
first rooted path from a seed in 𝑆𝑖 .

• Prevent ESP from discarding a Merge tree rooted in 𝑛 such
that: (𝑖) (cid:205)(𝑠𝑠𝑛) ≥ 3, that is, there are at least 3 bits set to 1
in the signature 𝑠𝑠𝑛; and (𝑖𝑖) 𝑛 has at least 3 adjacent edges
in G.

Intuitively, the condition on 𝑠𝑠𝑛 encourages merging on nodes
already well-connected to seeds. We denote by 𝑑𝑛 the number of G
edges adjacent to 𝑛; it can be computed and stored before evaluating
any query. The condition on 𝑑𝑛 focuses the “protection against ESP”
to Merge trees rooted in nodes where such protection is likely to
be most useful: specifically, those where 3 or more rooted paths
can meet (see Lemma 4.2 below). Grow and Merge apply on trees
“spared” in this way with no restriction.

Clearly, LESP creates all the trees built by ESP, and may create
more. In particular, reconsider the graph in Figure 5, the associated
seed sets, and the execution steps we traced in Section 4.5. At step
(2), 𝑠𝑠𝑥 is initialized with 010 (there is a path from B to x). At step
(4), when A-1-x is built, 𝑠𝑠𝑥 becomes 110; since (cid:205)(𝑠𝑠𝑥 ) = 2, the
tree A-1-x-2-B is pruned. However, at step (6), when C-3-x is built,
𝑠𝑠𝑥 becomes 111, which, together with 𝑑𝑥 = 3, spares its Merge
result A-1-x-3-C (despite the presence of several trees with the same
edges). In turn, this merges immediately with B-2-x into a result.

We formalize the guarantees of LESP as follows.

Definition 4.8 ((𝑢, 𝑛) rooted merge). For an integer 𝑢 ≥ 3 and non-
seed node 𝑛, the (𝑢, 𝑛) rooted merge is the rooted tree resulting from
merging a set of 𝑢 (𝑛, 𝑠𝑖 ) rooted paths, for some seeds 𝑠1, . . . , 𝑠𝑢 .

It follows from the (Merge2) pre-condition (Section 4.2) that
in an (𝑢, 𝑛) rooted merge, each 𝑠𝑖 belongs to a different seed set.
Further, it follows from the definition of an (𝑛, 𝑠𝑖 )-rooted path, that
in a (𝑢, 𝑛) rooted merge, all seeds are on leaves. In other words, a
(𝑢, 𝑛) rooted merge is a 𝑢-simple edge set.

Lemma 4.2. Any (3, 𝑛) rooted merge is guaranteed to be found by

LESP.

Proof. For any non-seed node 𝑛, Lemma 4.1 (which also holds
for LESP) ensures that any (𝑛, 𝑠𝑖 )-rooted path is found. As soon as
the third one is built, (cid:205)(𝑠𝑠𝑛) becomes 3. This, and the hypothesis
□
𝑑𝑛 ≥ 3, ensure that the Merge of the three is not pruned.

Property 6. For any integer 𝑢 ≥ 3 and non-seed node 𝑛, any (𝑢, 𝑛)
rooted merge is guaranteed to be found by LESP.

Proof. For 𝑢 = 3 this is established by Lemma 4.2. Once the
first (3, 𝑛) rooted merge has been built and kept, this ensures both
that 𝑑𝑛 ≥ 3 and (cid:205)(𝑠𝑠𝑛) ≥ 3. Then, whenever a new (𝑛, 𝑠𝑖 ) rooted
path, satisfying the Merge pre-conditions, is built, it is aggressively
merged with the first (3, 𝑛) rooted path, and the result is protected
from pruning by LESP’s special provision. The same holds during
□
all subsequent merges with other (𝑛, 𝑠 𝑗 ) rooted paths.

• We assign to each node 𝑛, and maintain throughout LESP
execution, a seed signature 𝑠𝑠𝑛, indicating the seed sets 𝑆𝑖 ,
1 ≤ 𝑖 ≤ 𝑚, such that a (𝑛, 𝑠𝑖 )-rooted path (Def. 4.4) has been
built from a seed 𝑠𝑖 ∈ 𝑆𝑖 , to 𝑛, since execution started. For
any seed 𝑠 ∈ 𝑆𝑖 , the signature 𝑠𝑠𝑠 is initialized to 0 . . . 1 . . . 0

For 4 or more seed sets, LESP may miss results that are not
(𝑢, 𝑛) rooted merges. For instance, consider the following order of
execution for 𝑆 = ({𝐴}, {𝐵}, {𝐶}, {𝐷 }) on the graph in Figure 6:
(1) From A, B, C, D, Grow builds: A–1, B–2, C-3, D-4.
(2) Grow builds B–2-1 which merges with A-1 into A-1–2-B.

7

A

1

2

B

x

3

C

4

D

Figure 6: LESP incompleteness example with 4 seed sets.

(3) Grow builds C-3-4 which merges with D-4 into C-3-4-D.
(4) Grow builds: A-1-2; B–2-x which cannot merge with B-2 as
A-1–2-B exists, and (cid:205)(𝑠𝑠2) = 2; D-4-3 which cannot merge
with C-3 as C-3-4-D exists, and (cid:205)(𝑠𝑠3) = 2.
(5) C-3-x merges with B–2-x to build B–2-x-3-C.
(6) C-3-x-2 merges with: A-1-2, leading to C-3-x-2-1-A; and

B–2, leading to C-3-x-2-B.

(7) Similarly, B-2-x-3, aggressively merges with C-3, leading

to B-2-x-3-C, and D-4-3, leading to B-2-x-3-4-D.

(8) Progressing similarly, we can only merge at most 3 rooted
paths, in nodes 2, x or 3. We cannot merge with a path
leading to the 4th seed, because the trees with the edge sets
A-1-2-B and C-3-4-D, built at (2), (3) above, are not rooted in
2 nor 3, respectively, and these are the only nodes satisfying
the LESP condition that “spares” some Merge trees.

4.7 MoLESP algorithm

Our last algorithm, called MoLESP, is a GAM variant with ESP and
both the modifications of MoESP (which injects more trees) and
LESP (which avoids ESP pruning for some Merge trees). Clearly,
MoLESP finds all the trees found by MoESP and LESP. Further:

Property 7 (MoLESP finds all 3ps results). MoLESP is guaranteed
to find all the 3-piecewise simple results.

Proof. Let 𝑡 be a 3ps result. If 𝑡 was 2ps, MoESP finds it (Prop-

erty 4), thus MoLESP also does.

Now consider that 𝜃 (𝑡) has some 3-simple edge sets that are
not 2-simple (thus, 𝑚 ≥ 3). We show that for any 3-simple edge
set in 𝜃 (𝑡), one provenance is built. Let 𝑡 3 be such an edge set: its
three leaves, denoted 𝑛1, 𝑛2, 𝑛3, are seeds, and no internal node is a
seed. Let 𝑐 denote the central node in 𝑡 3 (connected to 𝑛1, 𝑛2, 𝑛3 by
pairwise disjoint paths). 𝑡 3 is a (3, 𝑐) rooted merge (recall Def. 4.8)
and one provenance for it is built (Lemma 4.2).

The rest of the proof follows the idea in the proof of Property 4.
The MoESP aspect of MoLESP guarantees that for each edge set in
𝜃 (𝑡), one tree rooted in each seed is built and not pruned; eventually,
□
aggressive Merge of these trees builds a provenance for 𝑡.

As an important consequence:

Property 8. MoLESP is complete for 𝑚 ≤ 3 seed sets.

Proof. Consider the possible result shapes: (𝑖) a single node
𝑠1 = 𝑠2 = 𝑠3: no ESP applies, thus it is found; (𝑖𝑖) a path going from
𝑠1 = 𝑠2 to 𝑠3; such a result is 2-simple; (𝑖𝑖𝑖) a path going from 𝑠1 to
𝑠2 and then to 𝑠3, for some pairwise distinct 𝑠1, 𝑠2, 𝑠3; such a result is
2ps; (𝑖𝑣) a tree with three distinct leaves 𝑠1, 𝑠2, 𝑠3, which is 3-simple.
□
In cases (𝑖𝑖), (𝑖𝑖𝑖), (𝑖𝑣), Property 7 ensures the result is found.

Our strongest completeness result is:

Property 9 (Restricted MoLESP completeness). For any CTP of
𝑚 ≥ 1 seeds, MoLESP finds any result 𝑡, such that: each edge
set 𝑒𝑠 ∈ 𝜃 (𝑡) is a (𝑢, 𝑛)-rooted merge (Def. 4.8), for some integer
1 ≤ 𝑢 ≤ 𝑚 and non-seed node 𝑛 in 𝑒𝑠.

A

1

2

3

C

4

5

D

6

7

E
Figure 7: MoLESP completeness example.
Algorithm 1: MoLESP(graph G, seed sets (𝑆1 . . . , 𝑆𝑚))
Output: Set of results, Res

F

1 Priority queue PrioQ ← new priority queue;
2 History Hist ← new set of edge sets;
3 foreach 𝑆𝑖, 1 ≤ 𝑖 ≤ 𝑚 do
4

𝑖 ∈ 𝑆𝑖 do

foreach 𝑛 𝑗
𝑖 ← Init (𝑛 𝑗
𝑡 𝑗
end

5

𝑖 ); processTree(𝑡 𝑗
𝑖 );

6
7 end
8 while PrioQ is not empty do
9

(𝑡, 𝑒) ← 𝑝𝑜𝑙𝑙 (PrioQ); 𝑡 ′ ← Grow (𝑡, 𝑒);
Update 𝑠𝑠𝑟𝑜𝑜𝑡 (𝑡 ′ ) ; processTree(𝑡 ′);

10
11 end

Algorithm 2: Procedure processTree(provenance 𝑡)
1 if isNew(𝑡) then
Add 𝑡 to Hist ;
2
if isResult(𝑡) then
Add 𝑡 to Res;

3
4

end
else

5

6
7

8
9
10
11

12

13

14

end

end

end

recordForMerging(𝑡);
if 𝑡 is not a MoESP tree then

for edge 𝑒 ∈ adjacentEdges(𝑡 .𝑟𝑜𝑜𝑡) do
if ℎ𝑎𝑠𝑁𝑜𝑡𝐵𝑒𝑒𝑛𝐼𝑛𝑄𝑢𝑒𝑢𝑒 (𝑡, 𝑒) then

Add (𝑡, 𝑒) to PrioQ;

end

15
16 end

Algorithm 3: Procedure recordForMerging(tree 𝑡)
1 Add 𝑡 to TreesRootedIn[𝑡 .𝑟𝑜𝑜𝑡];
2 for 𝑛 ∈ (𝑛𝑜𝑑𝑒𝑠 (𝑡) ∩ ∪𝑖 (𝑆𝑖 )) do
3

Copy 𝑡 into a new tree 𝑡 ′, rooted at 𝑛, with provenance
Mo(𝑡, 𝑛);
Add 𝑡 ′ to TreesRootedIn[𝑛];
MergeAll(𝑡 ′);

4

5
6 end

Proof. Let 𝑡 be a result, and assume it is 𝑣-piecewise simple, for
some integer 𝑣. If 𝑣 ∈ {2, 3}, Property 7 ensures MoLESP finds it.
On the contrary, assume 𝑣 ≥ 4 and let 𝑡 4 ∈ 𝜃 (𝑡) be a (𝑣, 𝑛)-rooted
merge for some non-seed node 𝑛, thus, also 𝑣-simple. Property 6,
which also holds during MoLESP, guarantees that one provenance
for 𝑡 4 is built. The end of our proof leverages the MoESP aspect
of the algorithm: for each such edge set in 𝜃 (𝑡), one tree rooted in
each seed is built and not pruned; eventually, aggressive Merge of
□
these trees builds a provenance for 𝑡.
For example, in Figure 7, with the six seeds 𝐴 to 𝐹 , the result is
guaranteed to be found by MoLESP. Depending on the exploration
order, MoESP and LESP may not find it.
MoLESP algorithm Algorithms 1 to 5, together, implement MoLESP.
They share a set of global variables whose names start with an up-
percase letter: Res, PrioQ, Hist (the search history), and TreesRootedIn
(to store the trees by their roots); the latter is needed to find Merge
candidates fast. Variables with lowercase names are local to each
algorithm. processTree feeds the priority queue with (tree, edge)
pairs at line 10. recordForMerging injects the extra MoESP trees

8

Algorithm 4: Procedure isNew(tree 𝑡)
1 if 𝑡 ∉ Hist then
return 𝑡𝑟𝑢𝑒;
2
3 end
4 if Σ(𝑠𝑠𝑡 .𝑟𝑜𝑜𝑡 ) ≥ 3 and 𝑑𝑡 .𝑟𝑜𝑜𝑡 ≥ 3 then
if 𝑡 ∉ TreesRootedIn[𝑡 .𝑟𝑜𝑜𝑡] then
5
6
end

return 𝑡𝑟𝑢𝑒;

7
8 end
9 return 𝑓 𝑎𝑙𝑠𝑒;

Algorithm 5: Procedure MergeAll(tree 𝑡)
1 toBeMerged ← {𝑡 };
2 while toBeMerged ≠ ∅ do
3

currentTrees ← toBeMerged; toBeMerged ← ∅;
for 𝑡 ′ ∈ currentTrees do

mergePartners ← TreesRootedIn[𝑡 ′.𝑟𝑜𝑜𝑡];
for 𝑡𝑝 ∈ mergePartners do

if sat(𝑡 ′) ∩ sat(𝑡𝑝 ) = ∅ and 𝑡 ′ ∩ 𝑡𝑝 = {𝑡 ′.𝑟𝑜𝑜𝑡 }
then

𝑡 ′′ ← Merge (𝑡 ′, 𝑡𝑝 );
if isNew(𝑡 ′′) then

Add 𝑡 ′′ to toBeMerged;
processTree(𝑡 ′′);

end

end

end

4
5

6

7

8

9
10

11

12

13

14

end

15
16 end

(Section 4.5) at lines 2 to 4. isNew implements limited edge-set prun-
ing based on the history, and the two conditions that can “spare”
a tree from pruning (Section 4.6). mergeAll implements aggres-
sive merging; by calling processTree on each new Merge result,
through recordForMerging, the result is available in the future
iterations of mergeAll, thus ensuring all the desired Merge.
4.8 CTP evaluation in the presence of filters

We now briefly explain how various CTP filters (Section 2) can
be inserted within the above algorithms. UNI-directional search is
enforced by adding pre-conditions to Grow and Merge, to ensure
we only create the desired provenances. LABEL {𝑙1, 𝑙2, . . . , 𝑙𝑘 } is
enforced by restricting the Grow edges to only those carrying one
of these labels; in GAM and its variants, we only add in the queue
(line 10 in processTree), (tree, edge) pairs where the edge has an
allowed label. MAX 𝑛 prevents Grow and Merge from creating a
tree of more than 𝑛 edges. timeout 𝑇 is checked after each newly
found rooted tree and within each algorithm’s main loop.

For SCORE 𝜎 [TOP 𝑘], the simplest implementation calls 𝜎 on
each new result; a vast majority of the proposed score functions
can score each result independently. If the score of a result can
only be computed once all the results are found, e.g. [37, 38], the
results need to be accumulated. For any given score 𝜎, a smarter
implementation may favor (with guarantees, or just heuristically) the
early production of higher-score results, by appropriately chosing the
priority queue order; this allows search to finish faster. Any order
can be chosen in conjunction with MoLESP, since its completeness
guarantees are independent of the exploration order.
4.9 Handling very large seed sets

Our CTP evaluation algorithms build Init trees for each seed. This
has two risks: (𝑖) when one or more seed sets are N (all graph nodes),

exploring them all may be unfeasible; (𝑖𝑖) one or more seed sets may
be subsets of N, yet still much larger, e.g., one or more orders of
magnitude, than the other seed sets. To handle (𝑖), assuming other
seed sets are smaller, we only start exploring (Init, Grow etc.)
from the other seed sets, and simplify accordingly the algorithms,
since any encountered node is acceptable as a match for the N seed
set(s). To handle (𝑖𝑖), borrowing ideas from prior work [26], we use
multiple priority queues, one for each subset of the seed sets, and
Grow at any point from the queue having the fewest (tree, edge)
pairs. Thus, exploration initially focuses on the neighborhood of
the smaller seed sets, and hopefully encounters Init trees from the
large seed sets, leading to results.
5 EXPERIMENTAL EVALUATION

We compare CTP evaluation algorithms, then consider systems
capable, to some extent, to evaluate the language we introduced.
5.1 Software and hardware setup

We implemented a parser and a query compiler for our language
(Section 2) as an extension of SPARQL, and all the CTP evaluation
algorithms from Section 4, in Java 11. Our graphs are stored in
a simple table graph(id,source, edgeLabel, target) within PostgreSQL
12.4; unless otherwise specified, we delegate to Postgres the BGP
evaluation, and joining their results with CTP ones (Section 3).
When comparing CTP evaluation algorithms with in-memory com-
petitors, we load the graph in memory prior to evaluating CTPs.

We executed our experiments on a server equipped with 2x10-
core Intel Xeon E5-2640 CPUs @ 2.4GHz, with 128-GB DRAM.
Every execution point is averaged over 3 executions.
5.2 Baselines
CTP evaluation (keyword search) algorithms Our focus is on
algorithms that search for connecting trees (𝑖) traversing edges in
both directions, (𝑖𝑖) orthogonally wrt the score function, (𝑖𝑖𝑖) ex-
haustively, at least up to 𝑚=3 seed sets, (𝑖𝑣) capable of returning as
many solutions as requested, if given enough time and memory, and
(𝑣) applicable to arbitrary graphs, i.e., not requiring a regular graph
structure. In the literature, only the GAM algorithm [6] (Section 4.2)
fits the bill. The BFT, BFT-M, BFT-AM algorithms (Section 4.1 and
4.3) also satisfy these conditions, and are thus natural comparison
baselines; like virtually all algorithms from the literature, they start
from the seeds and move gradually away looking for results.

QGSTP [39] and LANCET [40] are the most recent GSTP ap-
proximation algorithms, for specific cost functions based on node
and edge (LANCET) weights. LANCET relies on DPBF [16] to find
an initial result, which it then improves. Since QGSTP has shown
strong advantage over DPBF [39], we select QGSTP as a baseline.
QGSTP runs in polynomial time in the size of the graph, and by
design, returns only one result; we used the authors’ code.
Graph query engines Our first two baselines only support check-
ing, but not returning unbounded-length, unidirectional paths whose
edge labels match a regular expression that users must provide, that
is: one cannot ask for “any path”. Specifically, we use Virtuoso
OpenSource v7.2.6 to evaluate SPARQL 1.1 queries that come as
close as possible to the semantics of our language. Internally, Vir-
tuoso translates an incoming SPARQL query into an SQL dialect1

1Accessible using the built-in function sparql_to_sql_text().

9

1

2

A

5

D

B

7

F

3

4

C

9

H

5

A

C

1

3

2

4

B

D

1

2

C

A

B
Figure 8: Synthetic graphs: Comb(3, 1, 2, 3) at the top left,
Star(4, 2) at the top right, and Line(3, 1) at the bottom.
before executing it. Our second baseline, named Virtuoso-SQL,
consists of editing these SQL-like queries to remove label con-
straints and thus query the graph for connectivity between nodes.
However, Virtuoso’s SQL dialect prevented us from returning the
nodes and edge labels along the found paths (whereas standard
recursive SQL allows it).

Our next three baselines support checking and returning paths.
JEDI [2] returns all the data paths matching a SPARQL property
path; we use the authors’ code. Neo4j supports Cypher queries
asking for all directed or undirected paths between two sets of nodes.
Finally, we used recursive queries in Postgres v12.4 to return the
label on paths between node pairs.

5.3 Datasets and queries

We experiment with both synthetic and real-world RDF graphs.
To compare CTP evaluation algorithms, we generate three sets
of parameterized graphs and associated CTPs (Figure 8). The seeds
are labeled 𝐴, 𝐵, . . . , 𝐻 , non-seed nodes are labeled 1, 2 etc.; each
seed set is of size 1. Line(𝑚, 𝑛𝐿) contains 𝑚 seeds, each connected
to the next/previous seed by 𝑛𝐿 intermediary nodes, using 𝑠𝐿=𝑛𝐿+1
edges. Comb(𝑛𝐴, 𝑛𝑆, 𝑠𝐿, 𝑑𝐵𝐴) consists of a line, from which a lateral
segment (called bristle) exits each seed. There are 𝑛𝐴 bristles, each
made of 𝑛𝑆 segments (a segment ends in another seed); each bristle
segment has 𝑠𝐿 triples, and there are 𝑑𝐵𝐴 nodes in the main line be-
tween two successive bristles. The number of seeds is 𝑚=𝑛𝐴·(𝑛𝑆+1).
Star(𝑚, 𝑠𝐿) has a central node connected to each of the 𝑚 seeds by
a line of 𝑠𝐿 edges.

On each Line, Comb, and Star graph, we run a CTP defined by the
𝑚 seeds, having 1 result. For instance, on the Star in Figure 8, the
seed sets are {𝐴}, {𝐵}, {𝐶}, {𝐷 }. On Line and Comb, the result is 2ps
(Def. 4.7), while on Star, it is a (𝑢, 𝑛) rooted merge (Def. 4.8). Thus,
by Property 9, MoLESP is guaranteed to find them. The topology of
Line graphs minimizes the number of subtrees for a given number of
edges and seeds; specifically, there are 𝑂 ((𝑚·𝑛𝐿)2) subtrees, while
the number of rooted trees is in 𝑂 ((𝑚·𝑛𝐿)3). On the contrary, the
Star topology raises the number of subtrees to 𝑂 (2𝑚·𝑠𝐿2), while its
number of rooted trees is in 𝑂 (2𝑚·𝑠𝐿3). In Comb and Line graphs,
MoESP trees (Section 4.5) are part of results.
To study the evaluation of our extended query language, we
generate parameterized Connected Dense Forest (CDF) graphs
(see Figure 9). Each graph contains a top forest, and a bottom forest;
each of these is a set of 𝑁𝑇 disjoint, complete binary trees of depth 3.
Links connect leaves from the top and bottom forests. We generate
CDFs for 𝑚∈{2,3}: when 𝑚=2, chains of triples connect a top leaf
to a bottom one; when 𝑚=3, a Y-shaped connection goes from a
top-forest leaf, to two bottom-forest ones. A CDF graph contains
𝑁𝐿 links, each made of 𝑆𝐿 triples. Only top leaves that are targets of
“c” edges can participate to links, and we concentrate the links on
50% of them (the others have no links). When 𝑚=2, only 50% of the

10

c

4

link

12

g

1

a

d

2

5
link
8

13
h
10
e

18

a
. . .

b
. . .

b

c

3

d

7

6
link

16

link

14
g
11

15

h

. . .

. . .

. . .

9

f

e

f

19

4
link

link
12

c

8

g

a

d

2

5

link
13
h
10
e

1

b

c

3

6
link

16

link

14
g
11

17

a
. . .

b
. . .

d

7

link
15

h

. . .

. . .

. . .

9

f

e

f

18

Figure 9: CDF graphs generated with 𝑚=2, 𝑆𝐿=2 (left), and
with 𝑚=3, 𝑆𝐿 = 3 (right).
bottom forest leaves that are targets of “g” edges can participate;
when 𝑚=3, 50% of all the bottom forest leaf can participate. The
links are uniformly distributed across the eligible leaves. A CDF has
12·𝑁𝑇 +𝑁𝐿·𝑆𝐿 edges; it has 14·𝑁𝑇 +𝑁𝐿·(𝑆𝐿−1) nodes if 𝑚=2, and
14·𝑁𝑇 +𝑁𝐿·𝑆𝐿 if 𝑚=3.

On CDF graphs with 𝑚=2, we run the query (𝑣,𝑡𝑙,𝑙) :- (𝑥,"c",𝑡𝑙),
(𝑣,"g",𝑏𝑙), (𝑏𝑙,𝑡𝑙,𝑙) whose two BGPs bind 𝑡𝑙, respectively, 𝑏𝑙 to leaves
from the top and bottom forest, while its CTP asks for all the paths
between each pair of such leaves. On graphs with 𝑚=3, we run
(𝑣,𝑡𝑙,𝑙):- (𝑥, "c", 𝑡𝑙), (𝑣,"g",𝑏𝑙1), (𝑣,"h",𝑏𝑙2),(𝑡𝑙, 𝑏𝑙1, 𝑏𝑙2, 𝑙), requiring con-
necting trees between 𝑡𝑙, 𝑏𝑙1 and 𝑏𝑙2. Each CDF query has 𝑁𝐿 an-
swers, one for each link.
Real-world graphs To compare with JEDI [2] and QGSTP [39],
we reused their datasets (a 6M triples subset of YAGO3, and a 18M
triples subset of DBPedia), as well as their queries.
5.4 CTP evaluation algorithms

5.4.1 Complete (baseline) algorithms. We start by comparing the
algorithms without any pruning: BFT (Section 4.1), GAM (Section
4.2), and the BFT variants BFT-M and BFT-AM (Section 4.2), on
synthetic Line, Comb and Star graphs of increasing size. We used a
timeout 𝑇 of 10 minutes. In all experiments with GAM and all
its variants, our exploration order (queue priority) favors the
smallest trees, and breaks ties arbitrarily. Figure 10 depicts the
algorithm running time; the color indicates the number of seed sets
(3, 5 or 10), while the line pattern indicates the algorithm. Missing
points (or curves) denote algorithms that did not complete by the
timeout. Note the logarithmic 𝑦 axes.

Across these plots, BFT-M performs worse than BFT-AM.
On Line graphs, the difference is a factor 2× for 𝑚 = 3 and up to
100× for 𝑚 = 10. On the Comb and Star graphs, BFT-M times out
on the larger graphs and queries. BFT-AM takes even more than
BFT-M, by a factor of 15×, thus more executions timed out. GAM
is much faster and completes execution in all cases. The reason, as
explained in Section 4.1, is that breadth-first algorithms waste effort
by minimizing results, and may find a tree in even more different
ways than GAM, since they grow from any node. Thus, we exclude
breadth-first algorithms from the subsequent comparisons.
5.4.2 GAM algorithm variants. On the same graphs, we compare
GAM (Section 4.2), ESP (Section 4.4), MoESP (Section 4.5), LESP
(Section 4.6) and MoLESP (Section 4.7) with the same timeout.
Figure 11 shows the algorithm running time as well as the number
of provenances they built. In all graphs but Figure 11a, the 𝑦 axis is

(a) CTP runtime on Line

(b) CTP runtime on Comb
Figure 10: Comparison of complete CTP evaluation baselines.

(c) CTP runtime on Star

(a) CTP runtime on Line

(b) CTP runtime on Comb

(c) CTP runtime on Star

(d) Number of provenances on Line

(e) Number of provenances on Comb
Figure 11: Graphs for GAM variants on synthetic benchmarks.

(f) Number of provenances on Star

logarithmic. On Line and Comb graphs, ESP and LESP failed to
find results due to edge set pruning, as explained in Section 4.4,
thus the corresponding curves are missing. MoESP and MoLESP
build the same number of provenances on Line and Comb graphs.
The plots show, first, that edge set pruning significantly reduces
the running time: MoLESP is faster than GAM by a factor rang-
ing from 1.3× (Line graphs) to 15× (Comb graphs, 𝑛𝐴=6, 𝑚=18).
Second, on the Star graphs, where the limited edge-set pruning
(Section 4.6) applies, the performance difference between MoESP
and MoLESP is small. This shows that the extra cost incurred
by LESP and MoLESP, which limit or compensate for edge-
set pruning (by injecting more trees), is worth paying for the
completeness guarantees of MoLESP. Overall, the algorithm run-
ning times closely track the numbers of built provenances, further
highlighting the interest of controlling the latter through pruning.

5.4.3 Comparison with QGSTP on real-world data. We now com-
pare the winner of the above comparisons, namely MoLESP, with
QGSTP [39] on the 18M edges DBPedia dataset and 312 CTPs used
in their evaluation. Among these, 83 CTPs (respectively, 98, 85, 38,
8) have 2 (respectively, 3, 4, 5, 6) seed sets. To align with QGSTP, we
added a UNI filter (unidirectional exploration only), and LIMIT 1 to

stop after the first result. Each QGSTP returned result is such that
Property 9 ensures MoLESP finds it. Figure 12 shows the average
runtimes grouped by 𝑚. GAM is faster than QGSTP for 𝑚≤5, but
timed-out for the 8 CTPs with 𝑚=6. MoLESP is about 6-7× faster
than QGSTP for all 𝑚 values, and scales well as 𝑚 increases. Thus,
MoLESP is competitive also on large real-world graphs and
queries.
5.5 Extended query evaluation

Synthetic queries on CDF benchmark. We now compare our
5.5.1
EQL query evaluation system with the graph query baselines, on our
CDF graphs (Section 5.3) generated with 𝑚∈{2,3}, 𝑆𝐿 ∈{3,6}, 18K to
2.4M edges, leading to 2K up to 200K results (𝑁𝐿), respectively. We
used 𝑇 =15 minutes. As explained in Section 2, the paths returned
by the baselines, which we “stitch” for 𝑚=3, semantically differ
from CTP results; the baselines’ reported time do not include the
time to minimize nor deduplicate their results.

For 𝑚=2, Figure 13 shows that all systems scale linearly in the
input size (note the logarithmic time axis). For each system, the lower
curve is on graphs with 𝑆𝐿=3, while the upper curve is on graphs with
𝑆𝐿=6 (these graphs are larger, thus curves go farther at right). All
missing points correspond to time-out. JEDI succeeded only on the

11

2345678910Distance between the seeds, sL102103104CTP evaluation time (ms)m=3m=5m=10BFS_GBFS_MBFS_AMGAM2345678910Distance between the seeds, sL102103104CTP evaluation time (ms)nA=2,m=6nA=4,m=12nA=6,m=18BFS_GBFS_MBFS_AMGAM2345678910Distance between seeds and the central node, sL102103104CTP evaluation time (ms)m=3m=5m=10BFS_GBFS_MBFS_AMGAM2345678910Distance between the seeds, sL50100150200250CTP evaluation time (ms)m=3m=5m=10GAMESPMoESPMoLESPLESP2345678910Distance between the seeds, sL102103104CTP evaluation time (ms)nA=2,m=6nA=4,m=12nA=6,m=18GAMESPMoESPMoLESPLESP2345678910Distance between seeds and the central node, sL102103104CTP evaluation time (ms)m=3m=5m=10GAMESPMoESPMoLESPLESP2345678910Distance between the seeds, sL102103Number of provenancesm=3m=5m=10GAMESPMoESPMoLESPLESP2345678910Distance between the seeds, sL102103104105Number of provenancesnA=2,m=6nA=4,m=12nA=6,m=18GAMESPMoESPMoLESPLESP2345678910Distance between seeds and the central node, sL102103104105Number of provenancesm=3m=5m=10GAMESPMoESPMoLESPLESPQuery
𝐽1: 3 BGPs, 2 CTPs
𝐽2: 2 BGPs, 1 CTP, large seed set
𝐽3: 1 CTP, N seed set

3.9
0.9
0.75
Table 1: Query evaluation times (seconds) on YAGO3 dataset.

Neo4j
TimeOut
OOM TimeOut
1.27
OOM

JEDI MoLESP
1.9
1
2.3

Virtuoso
0.2

Figure 12: GAM and MoLESP vs. QGSTP [39] on DBPedia.

Figure 13: CDF benchmark performance for 𝑚=2, 𝑆𝐿 ∈{3,6}.

Figure 14: CDF benchmark performance for 𝑚=3, 𝑆𝐿 ∈{3,6}.
smallest graph, Neo4j timed-out on all. Virtuoso-SPARQL is the
fastest, closely followed by Virtuoso-SQL; they are both unidirec-
tional, require the edge labels, and do not return paths. Unidirec-
tional MoLESP, which we included to compare with unidirectional
baselines, is slower by approximately 3× only. JEDI is slower than
MoLESP by 102× on the smallest graph, and timed-out on the others.
Postgres is faster than JEDI, yet at least 10× slower than MoLESP.
MoLESP is the only feasible bidirectional algorithm; it runs
in under 2 minutes on the largest graph with 2.4M edges.

Figure 14 shows similar results for 𝑚=3. Postgres timed-out in
all cases. Virtuoso-SPARQL is 7× faster than Virtuoso-SQL; both
return non-minimal, duplicate results. UNI-MoLESP outperforms
every system, while also returning connecting trees. Note that the
bidirectional MoLESP found about 7× more results than the 𝑁𝐿
expected ones, by also connecting bottom leaves without a common
parent through their grandparent node; these results are filtered
by the join between the BGPs and the CTP (Section 3). Despite the
much larger search space due to bidirectionality, MoLESP scales
well with the size of the graph.

5.5.2 Comparison with JEDI on real-world data. JEDI [2] used a
set of (unidirectional, label-constrained) SPARQL 1.1 queries over
YAGO3. Table 1 shows the queries’ characteristics. We compare
MoLESP similarly constrained (UNI and LABEL), on these queries,

12

with JEDI, Virtuoso and Neo4j (Postgres timed-out on all). Query
𝐽2 has one very large seed set, while query 𝐽3 has a N seed set.
On queries 𝐽2 and 𝐽3, MoLESP timed out. Thus, we applied the op-
timizations described in Section 4.9, which enabled it to perform
as shown. Virtuoso-SPARQL completed query 𝐽1, then ran out of
memory. Compared with JEDI, our query evaluation engine is 2×
faster on 𝐽1, close on 𝐽2, and around 3× slower on 𝐽3. MoLESP took
around 30% of the total time, the rest being spent by Postgres in the
BGP evaluation and final joins. This shows that the optimizations
described in Section 4.9 make MoLESP robust also to large
seed sets.

6 RELATED WORK AND PERSPECTIVES
We focused on extending a graph query language, such as SPARQL
[13], Cypher [35] or GraphQL [18], with connecting tree patterns
(CTPs) that they currently do not support (our requirement (R1)
from Section 1). Specifically, SPARQL 1.1 property paths (𝑖) allow
to check that some paths connect two nodes, not to return the
path(s); (𝑖𝑖) do not allow searching for arbitrary paths (users have
to specify a regular expression); (𝑖𝑖𝑖) are restricted to unidirectional
paths only. Some PG query languages such as Neo4j’s Cypher lift
these restrictions, however, its implementation does not scale (Sec-
tion 5.5.1) [11]. RPQProv [15] uses recursive SQL to return path
labels; JEDI [2, 3] builds over SPARQL 1.1 by returning all unidirec-
tional paths. Many works focus on finding label-constrained paths
between nodes [7, 8, 17, 19, 20, 28, 34, 36, 42, 43, 45], typically by
using precomputed indexes or sketches. In our CTP evaluation al-
gorithm, an index could be integrated by “reading from it” paths (or
subtrees) on which to Grow and Merge. Our CTPs extend finding
paths, to finding trees that connect an arbitrary number of seed sets
(𝑚≥3), traversing edges in any direction by default; we guarantee
completeness for 𝑚≤3 and finding a large set of results for arbitrary
𝑚. As we explained (Section 2), path stitching leads to different
results, which may require deduplication and minimization.

The CTP evaluation problem is directly related to keyword
search in (semi-)structured data, addressed in many algorithms,
some of which are surveyed in [12, 44]. These prior studies differ
from ours as follows: (𝑖) [4, 14, 21, 23–25, 27, 32, 33, 41] are schema-
dependent; (𝑖𝑖) [9, 29, 41] assume available a compact summary
of the graph; (𝑖𝑖𝑖) [16, 22, 26, 31] depend heavily on their score
functions for pruning the search, particularly to approximate the
best result [16, 31] or return only top-𝑘 results [10, 22, 30, 32, 46];
(𝑖𝑣) [1, 4, 10, 22, 24] are only unidirectional. For these reasons, they
fail to meet our requirements (R2) to (R5) as outlined in Section 1.
The Java-based GAM algorithm used in this work [6] was sped
up by up to 100× in a multi-threaded, C++ version [5]. MoLESP
brings new, orthogonal, optimizations, and novel guarantees.

Our future work includes developing adaptive EQL optimization
and execution strategies and applying it to graph exploration for
investigative journalism.
Acknowledgments. This work is funded by AI Chair SourcesSay
project (ANR-20-CHIA-0015-01) grant.

23456Number of seed sets, m04080120160200CTP evaluation time (s)QGSTPMoLESPGAM0.00.51.01.52.02.5Number of edges in the graph1e6102103104105Query evaluation time (ms)MoLESP (any path,return)Postgres (any path,return)UNI JEDI (labelledpath, return)UNI Virtuoso(labelled path,check-only)UNI Virtuoso (anypath, check-only)Neo4j (any path,return)UNI MoLESP (anypath, return)0.00.51.01.52.02.5Number of edges in the graph1e6103104105Query evaluation time (ms)MoLESP (any path,return)Postgres (any path,return)UNI JEDI (labelledpath, return)UNI Virtuoso(labelled path,check-only)UNI Virtuoso (anypath, check-only)Neo4j (any path,return)UNI MoLESP (anypath, return)REFERENCES
[1] B. Aditya, Gaurav Bhalotia, Soumen Chakrabarti, Arvind Hulgeri, Charuta Nakhe,
Parag, and S. Sudarshan. 2002. BANKS: Browsing and Keyword Searching in
Relational Databases. In Proceedings of 28th International Conference on Very
Large Data Bases, VLDB 2002, Hong Kong, August 20-23, 2002. 1083–1086. https:
//doi.org/10.1016/B978-155860869-6/50114-1

[2] Christian Aebeloe, Gabriela Montoya, Vinay Setty, and Katja Hose. 2018. Dis-
covering Diversified Paths in Knowledge Bases. Proc. VLDB Endow. 11, 12
(2018), 2002–2005. https://doi.org/10.14778/3229863.3236245 Code available at:
http://qweb.cs.aau.dk/jedi/.

[3] Christian Aebeloe, Vinay Setty, Gabriela Montoya, and Katja Hose. 2018. Top-K
Diversification for Path Queries in Knowledge Graphs. In Proceedings of the ISWC
2018 Posters & Demonstrations, Industry and Blue Sky Ideas Tracks co-located with
17th International Semantic Web Conference (ISWC 2018), Monterey, USA, October
8th - to - 12th, 2018 (CEUR Workshop Proceedings), Marieke van Erp, Medha
Atre, Vanessa López, Kavitha Srinivas, and Carolina Fortuna (Eds.), Vol. 2180.
CEUR-WS.org. http://ceur-ws.org/Vol-2180/paper-01.pdf

[4] Sanjay Agrawal, Surajit Chaudhuri, and Gautam Das. 2002. DBXplorer: A System
for Keyword-Based Search over Relational Databases. In Proceedings of the 18th
International Conference on Data Engineering, San Jose, CA, USA, February 26
- March 1, 2002, Rakesh Agrawal and Klaus R. Dittrich (Eds.). IEEE Computer
Society, 5–16. https://doi.org/10.1109/ICDE.2002.994693

[5] Angelos-Christos Anadiotis, Oana Balalau, Théo Bouganim, Francesco Chimienti,
Helena Galhardas, Mhd Yamen Haddad, Stéphane Horel, Ioana Manolescu, and
Youssr Youssef. 2021. Empowering Investigative Journalism with Graph-based
Heterogeneous Data Management. Bulletin of the Technical Committee on Data
Engineering (Sept. 2021). https://hal.archives-ouvertes.fr/hal-03337650

[6] Angelos-Christos G. Anadiotis, Oana Balalau, Catarina Conceição, Helena Gal-
hardas, Mhd Yamen Haddad, Ioana Manolescu, Tayeb Merabti, and Jingmao You.
2022. Graph integration of structured, semistructured and unstructured data for
data journalism. Inf. Syst. 104 (2022), 101846. https://doi.org/10.1016/j.is.2021.
101846

[7] Kemafor Anyanwu, Angela Maduko, and Amit P. Sheth. 2007. SPARQ2L: towards
support for subgraph extraction queries in rdf databases. In Proceedings of the
16th International Conference on World Wide Web, WWW 2007, Banff, Alberta,
Canada, May 8-12, 2007. 797–806. https://doi.org/10.1145/1242572.1242680
[8] Diego Arroyuelo, Aidan Hogan, Gonzalo Navarro, and Javiel Rojas-Ledesma.
2022. Time- and Space-Efficient Regular Path Queries on Graphs. (2022).
[9] Andrey Balmin, Vagelis Hristidis, and Yannis Papakonstantinou. 2004. Objec-
tRank: Authority-Based Keyword Search in Databases. In (e)Proceedings of the
Thirtieth International Conference on Very Large Data Bases, VLDB 2004, Toronto,
Canada, August 31 - September 3 2004. 564–575. https://doi.org/10.1016/B978-
012088469-8.50051-6

[10] Gaurav Bhalotia, Arvind Hulgeri, Charuta Nakhe, Soumen Chakrabarti, and S.
Sudarshan. 2002. Keyword Searching and Browsing in Databases using BANKS.
In Proceedings of the 18th International Conference on Data Engineering, San Jose,
CA, USA, February 26 - March 1, 2002. 431–440. https://doi.org/10.1109/ICDE.
2002.994756

[11] Andrew Bowman. 2022. Tuning Cypher queries by understanding cardinality.
(2022). https://neo4j.com/developer/kb/understanding-cypher-cardinality/#_
distinct_nodes_from_variable_length_paths
Joel Coffman and Alfred C. Weaver. 2014. An Empirical Performance Evaluation
of Relational Keyword Search Techniques. IEEE Trans. Knowl. Data Eng. 26, 1
(2014), 30–42. https://doi.org/10.1109/TKDE.2012.228

[12]

[13] WWW Consortium. 2013. SPARQL 1.1. (2013). https://www.w3.org/TR/sparql11-

overview/

[14] Pericles de Oliveira, Altigran S. da Silva, Edleno Silva de Moura, and Rosiane
Rodrigues. 2018. Match-Based Candidate Network Generation for Keyword
Queries over Relational Databases. In 34th IEEE International Conference on
Data Engineering, ICDE 2018, Paris, France, April 16-19, 2018. 1344–1347. https:
//doi.org/10.1109/ICDE.2018.00146

[15] Saumen C. Dey, Víctor Cuevas-Vicenttín, Sven Köhler, Eric Gribkoff, Michael
Wang, and Bertram Ludäscher. 2013. On implementing provenance-aware regular
path queries with relational query engines. In Joint 2013 EDBT/ICDT Conferences,
EDBT/ICDT ’13, Genoa, Italy, March 22, 2013, Workshop Proceedings, Giovanna
Guerrini (Ed.). ACM, 214–223. https://doi.org/10.1145/2457317.2457353
[16] Bolin Ding, Jeffrey Xu Yu, Shan Wang, Lu Qin, Xiao Zhang, and Xuemin Lin.
2007. Finding Top-k Min-Cost Connected Trees in Databases. (2007), 836–845.
https://doi.org/10.1109/ICDE.2007.367929

[17] George H. L. Fletcher, Jeroen Peters, and Alexandra Poulovassilis. 2016. Effi-
cient regular path query evaluation using path indexes. In Proceedings of the
19th International Conference on Extending Database Technology, EDBT 2016, Bor-
deaux, France, March 15-16, 2016, Bordeaux, France, March 15-16, 2016, Evaggelia
Pitoura, Sofian Maabout, Georgia Koutrika, Amélie Marian, Letizia Tanca,
Ioana Manolescu, and Kostas Stefanidis (Eds.). OpenProceedings.org, 636–639.
https://doi.org/10.5441/002/edbt.2016.67

[18] The GraphQL Foundation. 2022. GraphQL. (2022). https://graphql.org/

13

[19] Andrey Gubichev, Srikanta J. Bedathur, and Stephan Seufert. 2013. Sparqling
kleene: fast property paths in RDF-3X. In First International Workshop on Graph
Data Management Experiences and Systems, GRADES 2013, co-located with SIG-
MOD/PODS 2013, New York, NY, USA, June 24, 2013. 14. https://doi.org/10.1145/
2484425.2484443

[20] Andrey Gubichev and Thomas Neumann. 2011. Path Query Processing on
Very Large RDF Graphs. In Proceedings of the 14th International Workshop on
the Web and Databases 2011, WebDB 2011, Athens, Greece, June 12, 2011. http:
//webdb2011.rutgers.edu/papers/Paper21/pathwebdb.pdf

[21] Lin Guo, Feng Shao, Chavdar Botev, and Jayavel Shanmugasundaram. 2003.
XRANK: Ranked Keyword Search over XML Documents. In Proceedings of the
2003 ACM SIGMOD International Conference on Management of Data, San Diego,
California, USA, June 9-12, 2003. 16–27. https://doi.org/10.1145/872757.872762
[22] Hao He, Haixun Wang, Jun Yang, and Philip S. Yu. 2007. BLINKS: ranked
keyword searches on graphs. In Proceedings of the ACM SIGMOD International
Conference on Management of Data, Beijing, China, June 12-14, 2007. 305–316.
https://doi.org/10.1145/1247480.1247516

[23] Vagelis Hristidis, Luis Gravano, and Yannis Papakonstantinou. 2003. Efficient
IR-Style Keyword Search over Relational Databases. In Proceedings of 29th Interna-
tional Conference on Very Large Data Bases, VLDB 2003, Berlin, Germany, September
9-12, 2003. 850–861. https://doi.org/10.1016/B978-012722442-8/50080-X
[24] Vagelis Hristidis and Yannis Papakonstantinou. 2002. DISCOVER: Keyword
Search in Relational Databases. In VLDB. http://www.vldb.org/conf/2002/S19P02.
pdf

[25] Vagelis Hristidis, Yannis Papakonstantinou, and Andrey Balmin. 2003. Key-
word Proximity Search on XML Graphs. In Proceedings of the 19th International
Conference on Data Engineering, March 5-8, 2003, Bangalore, India. 367–378.
https://doi.org/10.1109/ICDE.2003.1260806

[26] Varun Kacholia, Shashank Pandit, Soumen Chakrabarti, S. Sudarshan, Rushi
Desai, and Hrishikesh Karambelkar. 2005. Bidirectional Expansion For Keyword
Search on Graph Databases. In Proceedings of the 31st International Conference
on Very Large Data Bases, Trondheim, Norway, August 30 - September 2, 2005.
505–516. http://www.vldb.org/archives/website/2005/program/paper/wed/p505-
kacholia.pdf

[27] Gjergji Kasneci, Maya Ramanath, Mauro Sozio, Fabian M. Suchanek, and Gerhard
Weikum. 2009. STAR: Steiner-Tree Approximation in Relationship Graphs. In
Proceedings of the 25th International Conference on Data Engineering, ICDE 2009,
March 29 2009 - April 2 2009, Shanghai, China. 868–879. https://doi.org/10.1109/
ICDE.2009.64
Jochem Kuijpers, George Fletcher, Tobias Lindaaker, and Nikolay Yakovets. 2021.
Path Indexing in the Cypher Query Pipeline. In Proceedings of the 24th Interna-
tional Conference on Extending Database Technology, EDBT 2021, Nicosia, Cyprus,
March 23 - 26, 2021. 582–587. https://doi.org/10.5441/002/edbt.2021.68

[28]

[29] Wangchao Le, Feifei Li, Anastasios Kementsietsidis, and Songyun Duan. 2014.
Scalable Keyword Search on Large RDF Data. IEEE Trans. Knowl. Data Eng. 26,
11 (2014), 2774–2788. https://doi.org/10.1109/TKDE.2014.2302294

[30] Guoliang Li, Beng Chin Ooi, Jianhua Feng, Jianyong Wang, and Lizhu Zhou.
2008. EASE: an effective 3-in-1 keyword search method for unstructured, semi-
structured and structured data. In Proceedings of the ACM SIGMOD International
Conference on Management of Data, SIGMOD 2008, Vancouver, BC, Canada, June
10-12, 2008. 903–914. https://doi.org/10.1145/1376616.1376706

[31] Rong-Hua Li, Lu Qin, Jeffrey Xu Yu, and Rui Mao. 2016. Efficient and Progressive
Group Steiner Tree Search. In Proceedings of the 2016 International Conference on
Management of Data, SIGMOD Conference 2016, San Francisco, CA, USA, June 26 -
July 01, 2016. 91–106. https://doi.org/10.1145/2882903.2915217

[32] Yi Luo, Xuemin Lin, Wei Wang, and Xiaofang Zhou. 2007. Spark: top-k keyword
query in relational databases. In Proceedings of the ACM SIGMOD International
Conference on Management of Data, Beijing, China, June 12-14, 2007. 115–126.
https://doi.org/10.1145/1247480.1247495

[34]

[33] Yi Luo, Wei Wang, Xuemin Lin, Xiaofang Zhou, Jianmin Wang, and Keqiu Li.
2011. SPARK2: Top-k Keyword Query in Relational Databases. IEEE Trans. Knowl.
Data Eng. 23, 12 (2011), 1763–1780. https://doi.org/10.1109/TKDE.2011.60
Inju Na, Ilyeop Yi, Kyu-Young Whang, Yang-Sae Moon, and Soon J. Hyun. 2022.
Regular Path Query Evaluation Sharing a Reduced Transitive Closure Based on
Graph Reduction. (2022).
Inc. Neo4j. 2022. Cypher Query Language. (2022). https://neo4j.com/developer/
cypher/

[35]

[36] You Peng, Xuemin Lin, Ying Zhang, Wenjie Zhang, and Lu Qin. 2022. Answering
reachability and K-reach queries on large graphs with label constraints. VLDB J.
31, 1 (2022), 101–127. https://doi.org/10.1007/s00778-021-00695-0

[37] Vinay M. S. and Jayant R. Haritsa. 2019. Root Rank: A Relational Operator
for KWS Result Ranking. In Proceedings of the ACM India Joint International
Conference on Data Science and Management of Data, COMAD/CODS 2019, Kolkata,
India, January 3-5, 2019. 103–111. https://doi.org/10.1145/3297001.3297014
[38] Vinay M. S. and Jayant R. Haritsa. 2020. Operator implementation of Result
https:

Inf. Syst. 89 (2020), 101465.

Set Dependent KWS scoring functions.
//doi.org/10.1016/j.is.2019.101465

[39] Yuxuan Shi, Gong Cheng, Trung-Kien Tran, Evgeny Kharlamov, and Yulin Shen.
2021. Efficient Computation of Semantically Cohesive Subgraphs for Keyword-
Based Knowledge Graph Exploration. In WWW ’21: The Web Conference 2021,
Virtual Event / Ljubljana, Slovenia, April 19-23, 2021, Jure Leskovec, Marko Grobel-
nik, Marc Najork, Jie Tang, and Leila Zia (Eds.). ACM / IW3C2, 1410–1421. https:
//doi.org/10.1145/3442381.3449900 Code available at: https://github.com/nju-
websoft/QGSTP.

[40] Yahui Sun, Xiaokui Xiao, Bin Cui, Saman K. Halgamuge, Theodoros Lappas, and
Jun Luo. 2021. Finding Group Steiner Trees in Graphs with both Vertex and Edge
Weights. Proc. VLDB Endow. 14, 7 (2021), 1137–1149. https://doi.org/10.14778/
3450980.3450982

[41] Thanh Tran, Haofen Wang, Sebastian Rudolph, and Philipp Cimiano. 2009. Top-
k Exploration of Query Candidates for Efficient Keyword Search on Graph-
Shaped (RDF) Data. In Proceedings of the 25th International Conference on Data
Engineering, ICDE 2009, March 29 2009 - April 2 2009, Shanghai, China. 405–416.
https://doi.org/10.1109/ICDE.2009.119

[42] Lucien D. J. Valstar, George H. L. Fletcher, and Yuichi Yoshida. 2017. Land-
mark Indexing for Evaluation of Label-Constrained Reachability Queries. In
Proceedings of the 2017 ACM International Conference on Management of Data,

SIGMOD Conference 2017, Chicago, IL, USA, May 14-19, 2017. 345–358. https:
//doi.org/10.1145/3035918.3035955

[43] Sarisht Wadhwa, Anagh Prasad, Sayan Ranu, Amitabha Bagchi, and Srikanta
Bedathur. 2019. Efficiently Answering Regular Simple Path Queries on Large
Labeled Networks. In Proceedings of the 2019 International Conference on Man-
agement of Data, SIGMOD Conference 2019, Amsterdam, The Netherlands, June 30
- July 5, 2019. 1463–1480. https://doi.org/10.1145/3299869.3319882

[44] Haixun Wang and Charu C. Aggarwal. 2010. A Survey of Algorithms for Keyword
Search on Graph Data. In Managing and Mining Graph Data, Charu C. Aggarwal
and Haixun Wang (Eds.). Advances in Database Systems, Vol. 40. Springer, 249–
273. https://doi.org/10.1007/978-1-4419-6045-0_8

[45] Nikolay Yakovets, Parke Godfrey, and Jarek Gryz. 2016. Query Planning for
Evaluating SPARQL Property Paths. In Proceedings of the 2016 International
Conference on Management of Data, SIGMOD Conference 2016, San Francisco, CA,
USA, June 26 - July 01, 2016. 1875–1889. https://doi.org/10.1145/2882903.2882944
[46] Yueji Yang, Divyakant Agrawal, H. V. Jagadish, Anthony K. H. Tung, and Shuang
Wu. 2019. An Efficient Parallel Keyword Search Engine on Knowledge Graphs.
In 35th IEEE International Conference on Data Engineering, ICDE 2019, Macao,
China, April 8-11, 2019. 338–349. https://doi.org/10.1109/ICDE.2019.00038

14

