Enumerating Answers to First-Order Queries over
Databases of Low Degree
Arnaud Durand, Nicole Schweikardt, Luc Segoufin

To cite this version:

Arnaud Durand, Nicole Schweikardt, Luc Segoufin. Enumerating Answers to First-Order Queries over
Databases of Low Degree. Logical Methods in Computer Science, 2022, 18 (2), pp.23. ￿10.46298/lmcs-
18(2:7)2022￿. ￿hal-03809756￿

HAL Id: hal-03809756

https://inria.hal.science/hal-03809756

Submitted on 10 Oct 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Enumerating Answers to First-Order Queries over
Databases of Low Degree

Arnaud Durand, IMJ-PRG, Universit ´e de Paris, CNRS
Nicole Schweikardt, Humboldt-Universit ¨at zu Berlin
Luc Segouﬁn, INRIA, Laboratoire Cogitamus

Abstract

A class of relational databases has low degree if for all δ > 0, all but ﬁnitely many databases in the class have
degree at most nδ, where n is the size of the database. Typical examples are databases of bounded degree or of
degree bounded by log n.

It is known that over a class of databases having low degree, ﬁrst-order boolean queries can be checked in
pseudo-linear time, i.e. for all ε > 0 in time bounded by n1+ε. We generalize this result by considering query
evaluation.

We show that counting the number of answers to a query can be done in pseudo-linear time and that after a
pseudo-linear time preprocessing we can test in constant time whether a given tuple is a solution to a query or
enumerate the answers to a query with constant delay.

1 Introduction

Query evaluation is a fundamental task in databases and a vast literature is devoted to the complexity
of this problem. However, for more demanding tasks such as producing the whole set of answers
or computing aggregates on the query result (such as counting the number of answers), complexity
bounds are often simply extrapolated from those for query evaluation; and until recently, few speciﬁc
methods and tools had been developed to tackle these problems. Given a database A and a ﬁrst-
order query q, it may be not satisfactory enough to express complexity results in terms of the sizes
of A and q as it is often the case. The fact that the solution set q(A) may be of size exponential in
the query is intuitively not sufﬁcient to make the problem hard, and alternative complexity measures
had to be found for query answering. In this direction, one way to deﬁne tractability is to assume
that tuples of the query result can be generated one by one with some regularity, for example by
ensuring a ﬁxed delay between two consecutive outputs once a necessary precomputation has been
done to construct a suitable index structure. This approach, that considers query answering as an
enumeration problem, has deserved some attention over the last few years.
In this vein, the best
that one can hope for is constant delay, i.e., the delay depends only on the size of q (but not on the
size of A). Surprisingly, a number of query evaluation problems have been shown to admit constant
delay algorithms, usually preceded by a preprocessing phase that is linear or almost linear. This is
the case when queries are evaluated over the class of structures of bounded degree [6, 15], over the
class of structures of “bounded expansion” [17] and, more generally, over the class of nowhere dense

0 This is the extended version of the conference contribution [7].

1

,

2

structures [20]. Similar results have been shown for monadic second-order logic over structures of
bounded tree-width [4, 1, 16] or for fragments of ﬁrst-order logic over arbitrary structures [2, 3].
However, as shown in [2], the fact that evaluation of boolean queries is easy does not guarantee the
existence of such efﬁcient enumeration algorithms in general: under some reasonable complexity
assumption, there is no constant delay algorithm with linear preprocessing enumerating the answers
of acyclic conjunctive queries (although it is well-known that the model checking of boolean acyclic
queries can be done in linear time [23]).

In this paper, we investigate the complexity of the enumeration, counting, and testing problems
for ﬁrst-order queries over classes of low degree. A class of relational databases has low degree if for
all δ > 0, all sufﬁciently large databases in the class have degree at most nδ, where n is the size of the
database. Databases of bounded degree or of degree bounded by (log n)c, for any ﬁxed constant c, are
examples of low degree classes. However, it turns out to be incomparable with the class of nowhere
dense databases mentioned above.

It has been proved in [13] that over a class of databases of low degree, ﬁrst-order boolean queries
can be checked in pseudo-linear time, i.e., for all ε > 0 there is an algorithm running in time bounded
by O(n1+ε) checking the given ﬁrst-order query. In this paper, we prove that counting the number
of answers to a query can be done in pseudo-linear time, and that enumerating the answers to a
query can be done with constant delay after a pseudo-linear time preprocessing. We also prove that
testing membership of a tuple to a query result can be done in constant time after a pseudo-linear
time preprocessing. We adopt a uniform approach to prove all these results by using at the heart of
the preprocessing phases a quantiﬁer elimination method that reduces our different problems to their
analog but for colored graphs and quantiﬁer-free queries. With such a tool, we can then focus within
each speciﬁc task on very simple instances.

Over a class of databases of low degree, the difﬁculty is to handle queries requiring that in all
its answers, some of its components are far away from each other. When this is not the case, for
instance when in all answers all its components are within short distance from the ﬁrst component,
then the low degree assumption implies that there are only few answers in total and those can be
computed in pseudo-linear time. In the difﬁcult case, the number of answers may be exponential in
the arity of the query and the naive evaluation algorithm may spend too much time processing tuples
with components close to each other. To avoid this situation, we introduce suitable functions that can
be precomputed in pseudo-linear time, and that allow us to jump in constant time from a tuple with
components close to each other to a correct answer.

Related work. Enumerating the answers to a boolean query q over a database A is more gen-
eral than testing whether q holds on A, a problem also known as the model checking problem. An
enumeration algorithm with constant delay after a preprocessing phase taking pseudo-linear time, or
even polynomial time, induces a model checking algorithm that is ﬁxed-parameter tractable (FPT),
i.e, works in time f (q)·||A||c for some constant c and some function f depending only on the class of
databases. There is a vast literature studying the model checking problem for ﬁrst-order logic aiming
at ﬁnding FPT algorithms for larger and larger classes of databases. Starting from classes of databases
of bounded degree, or bounded treewidth, FPT algorithms were derived for classes of databases hav-
ing bounded expansion [8] (see also [17]). Actually, recently an FPT algorithm has been obtained for
classes of databases known as “nowhere dense”, generalizing all the previously known results [14].
This last result is in a sense “optimal” as it is known that if a class of databases is closed under sub-
structures and has no FPT model checking algorithm then it is somewhere dense [18], modulo some
reasonable complexity hypothesis.

Classes of databases of low degree do not belong to this setting. It is easy to see that they are
neither nowhere dense nor closed under substructures (see Section 2.3). Our algorithms build on

,

3

the known model checking algorithm for low degree databases [13]. They generalize the known
enumeration algorithms for databases of bounded degree [6, 15].

This paper is the journal version of [7]. There is an important difference with the conference
version. In the conference version we needed the extra hypothesis that even though we would use
only a memory of pseudo-linear size, a total amount of memory of quadratic size was necessary for
our algorithms to work. This extra memory is no longer necessary here thanks to the data structure
constructed in Theorem 2.1. This makes the technical lemma slightly more complicated to state, but
does not affect the general results.

Organization. We ﬁx the basic notation and formulate our main results in Section 2. In Section 3
we present the algorithms for counting, testing, and enumerating answers to ﬁrst-order queries over
classes of structures of low degree. These algorithms rely on a particular preprocessing which trans-
forms a ﬁrst-order query on a database into a quantiﬁer-free query on a colored graph. The result is
stated in Section 3.3, while its proof is presented in Section 4. We conclude in Section 5.

2 Preliminaries and Main Results

We write N to denote the set of non-negative integers, and we let N(cid:62)1 := N \ {0}. Q denotes the set
of rationals, and Q

>0 is the set of positive rationals.

2.1 Databases and queries

A database is a ﬁnite relational structure. A relational signature σ is a ﬁnite set of relation symbols
R, each of them associated with a ﬁxed arity ar(R) ∈ N(cid:62)1. A relational structure A over σ, or a
σ-structure (we omit to mention σ when it is clear from the context) consists of a non-empty ﬁnite
set dom(A) called the domain of A, and an ar(R)-ary relation RA ⊆ dom(A)ar(R) for each relation
symbol R ∈ σ.

The degree of a structure A, denoted degree(A), is the degree of the Gaifman graph associated
with A (i.e., the undirected graph with vertex set dom(A) where there is an edge between two nodes
if they both occur in a tuple that belongs to a relation of A). With this deﬁnition, in a structure with n
domain elements and of degree d, each r-ary relation may have at most n · (d+1)r−1 tuples.

In the sequel we only consider structures of degree (cid:62) 2. As structures of degree 1 are quite trivial,

this is without loss of generality.

We deﬁne the size ||A|| of A as ||A|| = |σ| + |dom(A)| + (cid:80)

R∈σ |RA|·ar(R). It corresponds to
the size of a reasonable encoding of A. We assume that the input structure A is presented in a way
such that given a relation symbol R in the signature we can directly access the list of tuples in RA
(i.e. without reading the remaining tuples). The cardinality of A, i.e. the cardinality of its domain, is
denoted by |A|.

By query we mean a formula of FO(σ), the set of all ﬁrst-order formulas of signature σ, for some
relational signature σ (again we omit σ when it is clear from the context). For ϕ ∈ FO, we write ϕ(¯x)
to denote a query whose free variables are ¯x, and the number of free variables is called the arity of the
query. A sentence is a query of arity 0. Given a structure A and a query ϕ, an answer to ϕ in A is a
tuple ¯a of elements of dom(A) such that A |= ϕ(¯a). In the special case where ϕ is a sentence, it is
either true of false in A, and the former is denoted A |= ϕ and the latter is denoted A (cid:54)|= ϕ. We write
ϕ(A) for the set of answers to ϕ in A, i.e. ϕ(A) = {¯a : A |= ϕ(¯a)}. As usual, |ϕ| denotes the size
of ϕ.

,

4

Let C be a class of structures. The model checking problem of FO over C is the computational

problem of given a sentence ϕ ∈ FO and a database A ∈ C to test whether A |= ϕ.

Given a k-ary query ϕ, we care about “enumerating” ϕ(A) efﬁciently. Let C be a class of struc-
tures. The enumeration problem of ϕ over C is, given a database A ∈ C, to output the elements of
ϕ(A) one by one with no repetition. The time needed to output the ﬁrst solution is called the prepro-
cessing time. The maximal time between any two consecutive outputs of elements of ϕ(A) is called
the delay. We are interested here in enumeration algorithms with pseudo-linear preprocessing time
and constant delay. We now make these notions formal.

2.2 Model of computation and enumeration

We use Random Access Machines (RAMs) with addition and uniform cost measure as a model of
computation. For further details on this model and its use in logic see [9, 12].

In the sequel we assume that the input relational structure comes with a linear order on the domain.
If not, we use the one induced by the encoding of the structure as an input to the RAM. Whenever
we iterate through all nodes of the domain, the iteration is with respect to the initial linear order. The
linear order induces a lexicographical order on tuples of elements of the domain.

Our algorithms over RAMs will take as input a query ϕ of size k and a structure A of size n.
We adopt the data complexity point of view and say that a problem can be solved in linear time
(respectively, constant time) if it can be solved by an algorithm outputting the solution within f (k)·n
steps (respectively, f (k) steps), for some function f . We also say a problem can be solved in pseudo-
linear time if, for all ε ∈ Q
>0, there is an algorithm solving it within f (k, ε)·n1+ε steps, for some
function f .

We will often compute partial k-ary functions f associating a value to a tuple of nodes of the
input graph. Such functions can be easily implemented in the RAM model using k-dimensional cubes
allowing to retrieve the value of f in constant time. This requires a memory usage of O(nk) and an
initialization process of O(nk). However our functions will have a domain of size pseudo-linear and
can be computed in pseudo-linear time. The following theorem states that we can use the RAM model
to build a data structure that stores our functions in a more efﬁcient way. The data structure is a trie
of depth 1
ε and of degree nε where each pair (key,value) is a tuple ¯a in the domain of f and its image
b = f (¯a). The details can be found in [21].

Theorem 2.1 (Storing Theorem). For every ﬁxed n, k ∈ N and ε > 0, there is a data structure that
stores the value of a k-ary function f of domain dom(f ) ⊆ [n]k with:

• computation time and storage space O(|dom(f )| · nε),

• lookup time only depending on k and ε,

Here, lookup means that given a tuple ¯a ∈ [n]k, the algorithm either answers b if ¯a ∈ dom(f ) and
f (¯a) = b, or void otherwise.

An important consequence of Theorem 2.1 is that, modulo a preprocessing in time pseudo-linear
in the size of the database, we can test in constant time whether an input tuple is a fact of the database:

Corollary 2.2. Let A be a database over the schema σ. Let ε > 0. One can compute in time
O(drn1+ε) a data structure such that on input of a tuple ¯a and a relation symbol R ∈ σ one can test
whether A |= R(¯a) in time O(1), where n = |dom(A)|, d = degree(A), and r is a number that only
depends on σ.

,

5

Proof. Immediate from Theorem 2.1, as the number of tuples in an r-ary relation of a σ-structure
whose Gaifman graph has degree d is at most (d+1)r−1n.

Note that a simple linear time preprocessing would provide a data structure allowing for a test as in
Corollary 2.2 in time O(d) (to see how, just think of the special case where A only contains one binary
relation R. In this case, the preprocessing can build an adjacency list representation where upon input
of an a we can access in time O(1) the ﬁrst element of a list of all those b satisfying R(a, b). This list
has length at most d. Upon input of a tuple (a, b) we access a’s adjacency list and check if it contains
b). With the help of the Storing Theorem we get a test in constant time, i.e. depending only on ε and
σ and not on d.

We say that the enumeration problem of FO over a class C of structures can be solved with
constant delay after a pseudo-linear preprocessing, if it can be solved by a RAM algorithm which, on
input ε > 0, q ∈ FO and A ∈ C, can be decomposed into two phases:

• a preprocessing phase that is performed in time f (ε, |q|) · ||A||1+ε for some function f , and
• an enumeration phase that outputs q(A) with no repetition and a delay depending only on q,
ε, and C between any two consecutive outputs. The enumeration phase has full access to the
output of the preprocessing phase and can use extra memory whose size depends only on q, ε
and C.

Notice that if we can enumerate q with constant delay after a pseudo-linear preprocessing, then all
answers can be output in time g(|q|, ε) · (||A||1+ε + |q(A)|), for some function g, and the ﬁrst solution
is computed in pseudo-linear time. In the particular case of boolean queries, the associated model
checking problem must be solvable in pseudo-linear time.

Example 2.3. To illustrate these notions, consider the binary query q(x, y) over colored graphs com-
puting the pairs of nodes (x, y) such that x is blue, y is red, and there is no edge from x to y. It can
be expressed in FO by

B(x) ∧ R(y) ∧ ¬E(x, y).

A naive algorithm for evaluating q would iterate through all blue nodes, then iterate through all red
nodes, check if they are linked by an edge and, if not, output the resulting pair, otherwise try the next
pair.

With our RAM model, after a linear preprocessing, we can easily iterate through all blue nodes
with a constant delay between any two of them and similarly for red nodes. By Corollary 2.2, we can
test in constant time whether there is an edge between any two nodes. The problem with this algorithm
is that many pairs of appropriate color may be false hits. Hence the delay between two consecutive
outputs may be arbitrarily large.

If the degree is assumed to be bounded by a ﬁxed constant, then the above algorithm enumerates
all answers with constant delay, since the number of false hits for each blue node is bounded by the
degree. We will see that for structures of low degree we can modify the algorithm in order to achieve
the same result.

2.3 Classes of structures of low degree

Intuitively a class C of structures has low degree if for all δ > 0, all but ﬁnitely many structures A of
C have degree at most |A|δ (see [13]). More formally, C has low degree if for every δ ∈ Q
>0 there is
an nδ ∈ N(cid:62)1 such that all structures A ∈ C of cardinality |A| (cid:62) nδ have degree(A) (cid:54) |A|δ. If there
is a computable function associating nδ from δ then we furthermore say that the class is effective.

,

6

For example, for every ﬁxed number c > 0, the class of all structures of degree at most (log n)c is
of low degree and effective. Clearly, an arbitrary class C of structures can be transformed into a class
C(cid:48) of low degree by padding each A ∈ C with a suitable number of isolated elements (i.e., elements
of degree 0). Therefore classes of low degree are usually not closed under taking substructures. In
particular if we apply the padding trick to the class of cliques, we obtain a class of low degree that
is not in any of the classes with known low evaluation complexity such as the “nowhere dense” case
mentioned in the introduction.

Notice that degree(A) (cid:54) |A|δ implies that ||A|| (cid:54) c·|A|1+δ·r, where r is the maximal arity of the

signature and c is a number only depending on σ.

It is known that on classes of graphs of low degree, model checking of ﬁrst-order sentences can

be done in pseudo-linear time. We will actually need the following stronger result:

Theorem 2.4 (Grohe [13]). There is a computable function h such that on input of a structure A ∈ C
of degree d and a sentence q ∈ FO, one can test in time h(|q|)·|A|·dh(|q|) whether A |= q.

In particular, if C is a class of structures of low degree, then there is a function g such that, given
a structure A ∈ C, a sentence q ∈ FO, and ε > 0, one can check if A |= q in time g(|q|, ε)·|A|1+ε. If
C is effective then g is computable.

2.4 Our results

We are now ready to state our main results, which essentially lift Theorem 2.4 to non-boolean queries
and to counting, testing, and enumerating their answers.

Our ﬁrst result is that we can count the number of answers to a query in pseudo-linear time.

Theorem 2.5. Let C be a class of structures of low degree. There is a function g such that, given a
structure A ∈ C, a query q ∈ FO, and ε > 0, one can compute |q(A)| in time g(|q|, ε)·|A|1+ε. If C
is effective then g is computable.

Our second result is that we can test whether a given tuple is part of the answers in constant time

after a pseudo-linear time preprocessing.

Theorem 2.6. Let C be a class of structures of low degree. There is a function g such that, given
a structure A ∈ C, a query q ∈ FO, and ε > 0, one can compute in time g(|q|, ε)·|A|1+ε a data
structure such that, on input of any ¯a, one can then test in time g(|q|, ε) whether ¯a ∈ q(A). If C is
effective then g is computable.

Finally, we show that we can enumerate the answers to a query with constant delay after a pseudo-

linear time preprocessing.

Theorem 2.7. Let C be a class of structures of low degree. There is a function g such that, given a
structure A ∈ C, a query q ∈ FO and ε > 0, the enumeration problem of q over A can be solved
with delay g(|q|, ε) after a preprocessing running in time g(|q|, ε)·|A|1+ε. If C is effective then g is
computable.

2.5 Further notation

We close this section by ﬁxing technical notations that will be used throughout this paper.

For a structure A we write distA(a, b) for the distance between two nodes a and b of the Gaifman
graph of A. For an element a ∈ dom(A) and a number r ∈ N, the r-ball around a is the set N A
r (a) of
all nodes b ∈ dom(A) with distA(a, b) (cid:54) r. The r-neighborhood around a is the induced substructure
i=0 di < dr+1.
N A

r (a). Note that if A is of degree (cid:54) d for d (cid:62) 2, then |N A

r (a) of A on N A

r (a)| (cid:54) (cid:80)r

,

7

3 Evaluation algorithms

In this section, we present our algorithms for counting, testing, and enumerating the solutions to a
query (see Sections 3.4, 3.5, and 3.6). They all build on the same preprocessing algorithm which runs
in pseudo-linear time and which essentially reduces the input to a quantiﬁer-free query over a suitable
signature (see Section 3.3). However, before presenting these algorithms, we start with very simple
cases.

3.1 Computing the neighborhoods

Unsurprisingly, all our algorithms will start by computing the neighborhood N A
r (a) for all the ele-
ments a of the input structure A for a suitable constant r depending only on q. We actually do not
need to compute N A
(a) where A↓q is the restriction of A to the relational symbols
occurring in q.

r (a) but only N A↓q

r

The next lemma states that all these neighborhoods can be computed in reasonable time.

Lemma 3.1. There is an algorithm which, at input of a structure A, a query q and a number r
computes N A↓q
(a) for all elements a of the domain of A in time O(|q| · n · dh(r,|q|)), where n =
|dom(A)|, d = degree(A) and h is a computable function.

r

Proof. We ﬁrst compute the Gaifman graph associated to A↓q. We consider each relation symbol R
occurring in q. We scan RA and for each of its tuples we add the corresponding clique to the Gaifman
graph. As each element a of dom(A) can appear at the ﬁrst component of at most (d + 1)ar(R)−1
tuples of RA, the total time is |q| · n · (d + 1)k−1 where k is the maximal arity of the relation symbols
occurring in q. This yields a graph with n nodes and degree d corresponding to the Gaifman graph
of A ↓ q. From this graph we easily derive, in time O(n · d), a structure associating to each node
a ∈ dom(A) the set of its immediate neighbors, i.e N A↓q

(a).

1

With r steps of transitive closure computation we get a structure associating to each node a ∈

dom(A) the set N A↓q

r

(a) of nodes at distance at most r from a. This can be done in time O(n · dr).

With an extra scan over the database we can derive N A↓q

r

(a) from N A↓q

r

(a). Altogether we get

the desired time bounds.

3.2 Connected conjunctive queries

As a warm-up for working with classes of structures of low degree, we ﬁrst consider the simple case
of queries which we call connected conjunctive queries, and which are deﬁned as follows.

A conjunction is a query γ which is a conjunction of relational atoms and potentially negated
unary atoms. Note that the query of Example 2.3 is not a conjunction as it has a binary negated atom.
With each conjunction γ we associate a query graph Hγ. This is the undirected graph whose vertices
are the variables x1, . . . , xk of γ, and where there is an edge between two vertices xi and xj iff γ
contains a relational atom in which both xi and xj occur. We call the conjunction γ connected if its
query graph Hγ is connected.

A connected conjunctive query is a query q(¯x) of the form ∃¯y γ(¯x, ¯y), where γ is a connected

conjunction in which all variables of ¯x, ¯y occur (here, |¯y| = 0 is allowed).

The next simple lemma implies that over a class of structures of low degree, connected conjunctive
queries can be evaluated in pseudo-linear time.
It will be used in several places throughout this
paper: in the proof of Proposition 3.3, and in the proofs for our counting and enumeration results in
Sections 3.4 and 3.6.

,

8

Lemma 3.2. There is an algorithm which, at input of a structure A and a connected conjunctive
query q(¯x) computes q(A) in time O(|q|·n·dh(|q|)), where n = |dom(A)|, d = degree(A), and h is a
computable function.

Proof. Let q(¯x) be of the form ∃¯y γ(¯x, ¯y), for a connected conjunction γ. Let k = |¯x| be the number
of free variables of q, let (cid:96) = |¯y|, and let r = k + (cid:96).

In view of Lemma 3.1 we can assume that all the neighborhoods N A↓q(a) have been computed.

In order to simplify the notations, in the rest of the proof we will write N A

r (a) instead of N A↓q

r

(a).

Note that since γ is connected, for every tuple ¯c ∈ γ(A) the following is true, where a is the ﬁrst
r (a) of a in dom(A). Thus,

component of ¯c. All components c(cid:48) of ¯c belong to the r-neighborhood N A
q(A) is the disjoint union of the sets

Sa := (cid:8) ¯b ∈ q(N A

r (a)) : the ﬁrst component of ¯b is a (cid:9),

for all a ∈ dom(A). For each a ∈ dom(A), the set Sa can be computed as follows:

(1) Initialize Sa := ∅.

(2) Use a brute-force algorithm that enumerates all k-tuples ¯b of elements in N A

r (a) whose ﬁrst

component is a.
For each such tuple ¯b, use a brute-force algorithm that checks whether N A
insert ¯b into Sa
Note that the number of considered tuples ¯b is (cid:54) d(r+1)(k−1). And checking whether N A
q(¯b) can be done in time O(|γ|·d(r+1)(cid:96)): for this, enumerate all (cid:96)-tuples ¯c of elements in N A
and take time O(|γ|) to check whether γ(¯x, ¯y) is satisﬁed by the tuple (¯b, ¯c).
Thus, we are done after O(|γ|·dr2) steps.

r (a) |= q(¯b). If so,

r (a) |=
r (a)

In summary, we can compute q(A) = (cid:83)

a∈A Sa in time O(n·|q|·dh(|q|)), for a computable function h.

As an immediate consequence we can compute in pseudo-linear time the answers to a connected

conjunctive query over a class of structures of low degree.

Proposition 3.3. Let C be a class of structures of low degree. Given a structure A ∈ C, a connected
conjunctive query q, and ε > 0, one can compute q(A) in time g(|q|, ε) · |A|1+ε for some function g
which is computable when C is effective.

Proof. We use the algorithm provided in Lemma 3.2. To see that the running time is as claimed, we
use the assumption that C is of low degree: for every δ > 0 there is an mδ ∈ N(cid:62)1 such that every
structure A ∈ C of cardinality |A| (cid:62) mδ has degree(A) (cid:54) |A|δ.

For a given ε > 0 we let δ := ε

h(|q|) and deﬁne nε := mδ. Then, every A ∈ C with |A| (cid:62) nε
has degree(A) (cid:54) |A|ε/h(|q|). Thus, on input of A and q, the algorithm from Lemma 3.2 has running
time O(|q|·|A|1+ε) if |A| (cid:62) nε and takes time bounded by O(|q|·n1+h(q)
) otherwise. This gives the
bounds claimed by the proposition with a computable function g as soon as we can compute nε.

ε

The method of the proof of Proposition 3.3 above will be used several times in the paper.

,

9

3.3 Quantiﬁer elimination and normal form

In this section, we make precise the quantiﬁer elimination approach that is at the heart of the prepro-
cessing phase of the query evaluation algorithms of our paper.

A signature is binary if all its relation symbols have arity at most 2. A colored graph is a ﬁnite

relational structure over a binary signature.

Proposition 3.4. There is an algorithm which, at input of a structure A, a ﬁrst-order query ϕ(¯x),
and ε > 0, produces a binary signature τ (containing, among other symbols, a binary relation symbol
E), a colored graph G of signature τ , an FO(τ )-formula ψ(¯x), a mapping f , and a data structure
such that the following is true for k = |¯x|, n = |dom(A)|, d = degree(A) and h some computable
function:

1. ψ is quantiﬁer-free. Furthermore, ψ is of the form (ψ1 ∧ ψ2), where ψ1 states that no distinct
free variables of ψ are connected by an E-edge, and ψ2 is a positive boolean combination of
unary atoms.

2. τ and ψ are computed in time and space h(|ϕ|)·n·dh(|ϕ|).

Moreover, |τ | (cid:54) h(|ϕ|) and |ψ| (cid:54) h(|ϕ|).

3. G is computed in time and space h(|ϕ|)·n·dh(|ϕ|).

Moreover, degree(G) (cid:54) dh(|ϕ|).

4. f is an injective mapping from dom(A)k to dom(G)k such that f is a bijection between ϕ(A)

and ψ(G).
The data structure representing f can be computed in time and space h(|ϕ|)·n1+ε·dh(|ϕ|) and
can then be used as follows: on input of any tuple ¯a ∈ dom(A)k, the tuple f (¯a) can be computed
in time O(k2); and on input of any tuple ¯v ∈ ψ(G), the tuple f −1(¯v) can be computed in time
O(k2).

The proof of Proposition 3.4 is long and technical and of a somewhat different nature than the
results we now describe. It is postponed to Section 4. However, this proposition is central in the
proofs of the results below.

3.4 Counting

Here we consider the problem of counting the number of solutions to a query on low degree structures.
A generalized conjunction is a conjunction of relational atoms and negated relational atoms
(hence, also atoms of arity bigger than one may be negated, and the query of Example 2.3 is a gener-
alized conjunction).

Example 3.5. Before moving to the formal proof of Theorem 2.5, consider again the query q from
Example 2.3. Recall that it computes the pairs of blue-red nodes that are not connected by an edge.
To count its number of solutions over a class of structures of low degree we can proceed as follows.
We ﬁrst consider the query q(cid:48)(x, y) returning the set of blue-red nodes that are connected. In other
words, q(cid:48) is

B(x) ∧ R(y) ∧ E(x, y).

Notice that this query is a connected conjunction. Hence, by Proposition 3.3 its answers can be
computed in pseudo-linear time and therefore we can also count its number of solutions in pseudo-
linear time. It is also easy to compute in pseudo-linear time the number of pairs of blue-red nodes.
The number of answers to q is then the difference between these two numbers.

,

10

The proof sketch for Theorem 2.5 goes as follows. Using Proposition 3.4 we can assume modulo
a pseudo-linear preprocessing that our formula is quantiﬁer-free and over a binary signature. Each
connected component is then treated separately and we return the product of all the results. For
each connected component we eliminate the negated symbols one by one using the trick illustrated in
Example 3.5. The resulting formula is then a connected conjunction that is treated in pseudo-linear
time using Proposition 3.3.

Lemma 3.6. There is an algorithm which, at input of a colored graph G and a generalized conjunction
γ(¯x), computes |γ(G)| in time O(2m·|γ|·n·dh(|γ|)), where h is a computable function, m is the number
of negated binary atoms in γ, n = |dom(G)|, and d = degree(G).

Proof. By induction on the number m of negated binary atoms in γ. The base case for m=0 is
obtained as follows. We start by using O(|γ|) steps to compute the query graph Hγ and to compute
the connected components of Hγ.

In case that Hγ is connected, we can use Lemma 3.2 to compute the entire set γ(G) in time
O(|γ|·n·dh(|γ|)), for a computable function h. Thus, counting |γ(G)| can be done within the same
time bound.

In case that γ is not connected, let H1, . . . , H(cid:96) be the connected components. For each i ∈
{1, . . . , (cid:96)} let ¯xi be the tuple obtained from ¯x by removing all variables that do not belong to Hi.
Furthermore, let γi(¯xi) be the conjunction of all atoms or negated unary atoms of γ that contain
variables in Hi. Note that γ(¯x) is equivalent to (cid:86)(cid:96)

i=1 γi(¯xi), and

|γ(G)| =

(cid:96)
(cid:89)

i=1

|γi(G)|.

Since each γi is connected, we can compute |γi(G)| in time O(|γi|·n·dh(|γi|)) by using the algo-
rithm of Lemma 3.2. We do this for each i ∈ {1, . . . , (cid:96)} and output the product of the values. In
summary, we are done in time O(|γ|·n·dh(|γ|)) for the base case m = 0.

For the induction step, let γ be a formula with m+1 negated binary atoms. Let ¬R(x, y) be a

negated binary atom of γ, and let γ1 be such that

γ = γ1 ∧ ¬R(x, y),
:= γ1 ∧ R(x, y).
γ2

and let

Clearly, |γ(G)| = |γ1(G)| − |γ2(G)|. Since each of the formulas γ1 and γ2 has only m negated
binary atoms, we can use the induction hypothesis to compute |γ1(G)| and |γ2(G)| each in time
O(2m·|γ|·n·dh(|γ|)). The total time used for computing |γ(G)| is thus O(2m+1·|γ|·n·dh(|γ|)).

By using Proposition 3.4, we can lift this to arbitrary structures and ﬁrst-order queries:

Proposition 3.7. There is an algorithm which at input of a structure A and a ﬁrst-order query ϕ(¯x)
computes |ϕ(A)| in time h(|ϕ|)·n·dh(|ϕ|), for a computable function h, where n = |dom(A)| and
d = degree(A).

Proof. We ﬁrst use the algorithm of Proposition 3.4 to compute the according graph G and the
quantiﬁer-free formula ψ(¯x). This takes time h(|ϕ|)·n·dh(|ϕ|) for a computable function h. And
we also know that |ψ| (cid:54) h(|ϕ|). By Proposition 3.4 we know that |ϕ(A)| = |ψ(G)|.

,

11

Next, we transform ψ(¯x) into disjunctive normal form

γi(¯x),

(cid:95)

i∈I

such that the conjunctive clauses γi exclude each other (i.e., for each ¯v ∈ ψ(G) there is exactly one
i ∈ I such that ¯v ∈ γi(G)). Clearly, this can be done in time O(2|ψ|). Each γi has length at most |ψ|,
and |I| (cid:54) 2|ψ|.

Obviously, |ψ(G)| = (cid:80)

i∈I |γi(G)|. We now use, for each i ∈ I, the algorithm from Lemma 3.6

to compute the number si = |γi(G)| and output the value s = (cid:80)

i∈I si.

By Lemma 3.6 we know that for each i ∈ I computing si can be done in time O(2m·|γi|·˜n· ˜dh0(|γi|)),
where m is the number of binary atoms in γ, ˜n = |dom(G)|, ˜d = degree(G), and h0 is some com-
putable function.

By Proposition 3.4 we know that ˜n (cid:54) h(|ϕ|)·n·dh(|ϕ|) and ˜d (cid:54) dh(|ϕ|). Since also |γi| (cid:54) |ψ| (cid:54)
h(|ϕ|), the computation of si, for each i ∈ I, takes time h1(|ϕ|)·n·dh1(|ϕ|), for some computable
function h1 (depending on h and h0).

To conclude, since |I| (cid:54) 2|ψ|, the total running time for the computation of |ϕ(A)| = (cid:80)
i∈I si
is h2(|ϕ|)·n·dh2(|ϕ|), for a suitably chosen computable function h2. Hence, we meet the required
bound.

Theorem 2.5 is an immediate consequence of Proposition 3.7, following arguments similar with
the proof of Proposition 3.3: For a given ε > 0 we let δ := ε
h(|ϕ|) , where h is the function of
Proposition 3.7, and deﬁne nε := mδ. Then, every A ∈ C with |A| (cid:62) nε has degree(A) (cid:54) |A|ε/h(|ϕ|).
Thus, on input of A and ϕ, the algorithm from Proposition 3.7 has running time O(h(|ϕ|)·|A|1+ε) if
|A| (cid:62) nε and takes time bounded by h(|ϕ|) · n1+h(|ϕ|)
otherwise. This gives the bounds claimed by
the proposition with a computable function g as soon as we can compute nε.

ε

3.5 Testing

Here we consider the problem of testing whether a given tuple is a solution to a query. By Proposi-
tion 3.4 it is enough to consider quantiﬁer-free formulas. Those are treated using the data structure
computed by Corollary 2.2.

Proposition 3.8. There is an algorithm which at input of a structure A, a ﬁrst-order query ϕ(¯x),
and an ε > 0 has a preprocessing phase of time g(|ϕ|, ε)·n1+ε·dg(|ϕ|,ε) in which it computes a data
structure such that, on input of any ¯a ∈ dom(A)k for k = |¯x|, it can be tested in time g(|ϕ|, ε) whether
¯a ∈ ϕ(A), where g is a computable function, n = |dom(A)|, and d = degree(A).

Proof. Fix ε > 0.

We ﬁrst use the algorithm of Proposition 3.4 to compute the graph G, the quantiﬁer-free formula
ψ(¯x) and the data structure for function f . For some computable function h, all of this is done within
time h(|ϕ|)·n1+ε·dh(|ϕ|), and furthermore, |ψ| (cid:54) h(|ϕ|) and degree(G) (cid:54) dh(|ϕ|). Note that ||G|| (cid:54)
h(|ϕ|)·n·dh(|ϕ|). By construction, we furthermore know for all ¯a ∈ dom(A)k that ¯a ∈ ϕ(A) ⇐⇒
f (¯a) ∈ ψ(G).

Recall from Proposition 3.4 that ψ(¯x) is a quantiﬁer-free formula built from atoms of the form
E(y, z) and C(y) for unary relation symbols C. Thus, checking whether a given tuple ¯v ∈ dom(G)k
belongs to ψ(G) can be done easily, provided that one can check whether unary atoms C(u) and
binary atoms E(u, u(cid:48)) hold in G for given nodes u, u(cid:48) of G.

,

12

Let ˜n = |dom(G)| and ˜d = degree(G). Recall that ˜n (cid:54) h(|ϕ|)·n·dh(|ϕ|) and ˜d (cid:54) dh(|ϕ|). We apply

Corollary 2.2 to G and ε.

This gives an extra preprocessing time of O( ˜d˜r · ˜n1+ε), where ˜r only depends on τ , i.e., ˜r is
bounded by ˜h(|ϕ|) for some computable function ˜h. Inserting the known bounds on ˜r, ˜n, and ˜d shows
that this extra preprocessing time is in O(g(|ϕ|, ε) · n1+ε · dg(|ϕ|,ε)) for some computable function g.
Finally, the testing algorithm works as follows. Given a tuple ¯a ∈ dom(A)k, we ﬁrst construct
¯v := f (¯a) and then check whether ¯v ∈ ψ(G). Building ¯v := f (¯a) can be done in time O(k2) (see
Proposition 3.4), and by Corollary 2.2 checking whether ¯v ∈ ψ(G) depends only on ψ, ε and σ.
Hence, we meet the required bound for testing.

Theorem 2.6 is an immediate consequence of Proposition 3.8 using the usual argument: For a
given query φ and an ε > 0 we let δ :=
2g(|ϕ|,ε/2) , where g is the function of Proposition 3.8,
and deﬁne nε := mδ. Then, every A ∈ C with |A| (cid:62) nε has degree(A) (cid:54) |A|ε/2g(|ϕ|,ε/2).
Thus, on input of A, ϕ and ε/2, the testing algorithm from Proposition 3.8 has preprocessing time
O(g(|ϕ|, ε/2)·|A|1+ε) if |A| (cid:62) nε and takes time bounded by g(|ϕ|, ε/2) · n1+ε/2+g(|ϕ|,ε/2)
other-
wise, and it has testing time O(g(|ϕ|, ε/2) . This gives the bounds claimed by the theorem with a
computable function as soon as we can compute nε.

ε

ε

3.6 Enumeration

Here we consider the problem of enumerating the solutions to a given query. We ﬁrst illustrate the
proof of Theorem 2.7 with our running example.

Example 3.9. Consider again the query q of Example 2.3. In order to enumerate q with constant delay
over a class of low degree we proceed as follows. During the preprocessing phase we precompute
those blue nodes that contribute to the answer set, i.e. such that there is a red node not connected
to it. This is doable in pseudo-linear time because our class has low degree and each blue node is
connected to few red nodes. We call green the resulting nodes. We then order the green nodes and
the red nodes in order to be able to iterate through them with constant delay. Finally, we compute
the binary function skip(x, y) associating to each green node x and red node y such that E(x, y) the
smallest red node y(cid:48) such that y < y(cid:48) and ¬E(x, y(cid:48)), where < is the order on red nodes precomputed
above. From Proposition 3.3 it follows that computing skip can be done in pseudo-linear time. It
is crucial here that the domain of skip has pseudo-linear size and this is a consequence of the low
degree.

The enumeration phase now goes as follows: We iterate through all green nodes. For each of them
we iterate through all red nodes. If there is no edge between them, we output the result and continue
with the next red node. If there is an edge, we apply skip to this pair and the process continues with
the resulting red node. Note that the new red node immediately yields an answer. Note also that all
the red nodes that will not be considered are safely skipped as they are linked to the current green
node.

The proof of Theorem 2.7 can be sketched as follows. By Proposition 3.4 it is enough to consider
quantiﬁer-free formulas looking for tuples of nodes that are disconnected and have certain colors.
Hence the query q described in Example 2.3 corresponds to the binary case. For queries of larger
arities we proceed by induction on the arity. If q is given by the formula ϕ(¯xy) we know by induction
that, modulo some preprocessing pseudo-linear in the size of the input database D, we can enumerate
with constant delay all tuples ¯a satisfying D |= ∃yϕ(¯xy). For each such tuple ¯a it remains to enumer-
ate all b such that D |= ϕ(¯ab). We then proceed as in Example 3.9. Starting from an arbitrary node

,

13

b of the appropriate color, we iterate the following reasoning. If the current node b is not connected
to ¯a, then ¯ab forms an answer and we proceed to the next b. If b is connected to ¯a then we need
to jump in constant time to the next node of the appropriate color forming a solution. This is done
by precomputing a suitable function skip that depends on the arity of the query and is slightly more
complex that the one described in Example 3.9. The design and computation of this function is the
main technical originality of the proof. The fact that the database has low degree implies that for each
tuple ¯a there are few nodes b that are connected to ¯a. This makes the computation efﬁcient.

The technical details are summarized in the following proposition.

Proposition 3.10. There is an algorithm which at input of a structure A, a ﬁrst-order query ϕ(¯x),
and ε > 0 enumerates ϕ(A) with delay h(|ϕ|, ε) after a preprocessing of time h(|ϕ|, ε)·n1+ε·dh(|ϕ|,ε),
where n = |dom(A)|, d = degree(A), and h is a computable function.

Proof. The proof is by induction on the number k := |¯x| of free variables of ϕ. In case that k = 0,
the formula ϕ is a sentence, and we are done using Theorem 2.4. In case that k > 0 we proceed as
follows.

We ﬁrst use the algorithm of Proposition 3.4 to compute the according colored graph G, the
quantiﬁer-free formula ψ(¯x), and the data structure representing f . This takes time g(|ϕ|)·n1+ε·dg(|ϕ|)
for a computable function g. And we know that |ψ| (cid:54) g(|ϕ|), that G has degree ˜d (cid:54) dg(|ϕ|), and that
dom(G) has ˜n elements, where ˜n (cid:54) g(|ϕ|)·n·dg(|ϕ|).

From Item 1 of Proposition 3.4 we know that the formula ψ(¯x) is of the form (ψ1 ∧ ψ2), where
ψ1 states that no distinct free variables of ψ are connected by an E-edge and ψ2 is a positive boolean
combination of unary atoms.

We now prove the Proposition in the case of G, i.e. we enumerate ψ(G) and go back to A using
f in constant time by Item 4 of Proposition 3.4. We assume an arbitrary linear order (cid:54)G among the
nodes of G.

In case that k = 1, ψ(x1) = ψ2(x1) is a positive boolean combination of unary atoms. We can use
Lemma 3.2 for each unary atom in order to compute ψ(G) in time O(|ψ|·˜n· ˜dg(|ψ|)) for a computable
function g. From this the constant delay enumeration is immediate.

Altogether the preprocessing time is in h(ϕ)·n1+ε·dh(ϕ), for a computable function h as required.

The delay is O(1), and we are done for k = 1.

The case k > 1 requires much more elaborate constructions.
We let ¯x = (x1, . . . , xk) and ¯xk−1 := (x1, . . . , xk−1). We ﬁrst transform ψ into a normal form
j∈J θj(¯x) such that the formulas θj exclude each other (i.e., for each ¯v ∈ ψ(G) there is exactly one

(cid:87)

j ∈ J such that ¯v ∈ θj(G)), and each θj(¯x) is of the form

φj(¯xk−1) ∧ Pj(xk) ∧ γ(¯x),

where

γ(¯x)

:=

k−1
(cid:94)

i=1

(cid:0) ¬E(xi, xk) ∧ ¬E(xk, xi) (cid:1),

Pj(xk) is a boolean combination of unary atoms regarding xk, and φj(¯xk−1) is a formula with only
k−1 free variables. Note that the transformation into this normal form can be done easily, using the
particularly simple form of the formula ψ.

As the θj are mutually exclusive, we can enumerate ψ(G) by enumerating for each j ∈ J, θj(G).
In the following, we therefore restrict attention to θj for a ﬁxed j ∈ J. For this θj we shortly write

θ(¯x) = φ(¯xk−1) ∧ P (xk) ∧ γ(¯x).

,

14

We let θ(cid:48)(¯xk−1) := ∃xk θ(¯x).

By induction hypothesis (since θ(cid:48) only has k−1 free variables) we can enumerate θ(cid:48)(G) with delay

h(|θ(cid:48)|, ε) and preprocessing h(|θ(cid:48)|, ε)·˜n1+ε· ˜dh(|θ(cid:48)|,ε)

Since P (xk) is a boolean combination of unary atoms on xk, we can use Lemma 3.2 to compute
P (G) in time O(|P |·˜n· ˜dg(|P |)) for a computable function g. Afterwards, we have available a list of all
nodes v of G that belong to P (G). In the following, we will write (cid:54)P
G to denote the linear ordering of
P (G) induced by (cid:54)G on P (G), and we write ﬁrstP
G for the
successor function, such that for any node v ∈ P (G), nextP
G (v) is the next node in P (G) in this list (or
the value void, if v is the last node in the list).

G for the ﬁrst element in this list, and nextP

We extend the signature of G by a unary relation symbol P and a binary relation symbol next,
and let ˆG be the expansion of G where P is interpreted by the set P (G) and next is interpreted by the
G (v)). Note that ˆG has degree at
successor function nextP
most ˆd = ˜d+2.

G (i.e., next(v, v(cid:48)) is true in ˆG iff v(cid:48) = nextP

We now start the key idea of the proof, i.e., the function that will help us skipping over irrelevant
nodes. To this end consider the ﬁrst-order formulas E1, . . . , Ek deﬁned inductively as follows, where
E(cid:48)(x, y) is an abbreviation for (E(x, y) ∨ E(y, x)). The reason for deﬁning these formulas will
become clear only later on, in the proof.

E1(u, y) := E(cid:48)(u, y),

and

Ei+1(u, y) := Ei(u, y) ∨ ∃z∃z(cid:48)∃v (cid:0)E(cid:48)(z, u) ∧ next(z(cid:48), z) ∧ E(cid:48)(v, z(cid:48)) ∧ Ei(v, y)(cid:1).
A simple induction shows that for Ei(u, y) to hold, y must be at distance (cid:54) 3(i−1) + 1 < 3i from u.
In our algorithm we will have to test, given i (cid:54) k and nodes u, v ∈ dom(G), whether (u, v) ∈
Ei( ˆG). Since Ei is a ﬁrst-order formula, Proposition 3.8 implies that, after a preprocessing phase using
time g(cid:48)(|Ei|, ε)·˜n1+ε· ˆdg(cid:48)(|Ei|,ε) (for some computable function g(cid:48)), testing membership in Ei( ˆG), for
any given (u, v) ∈ dom(G)2, is possible within time g(cid:48)(|Ei|, ε).

The last step of the precomputation phase computes the function skip that associates to each node
y ∈ P (G) and each set V of at most k−1 nodes that are related to y via Ek, the smallest (according
to the order (cid:54)P
G y in P (G) that is not connected by an E-edge to any node in
V . More precisely: For any node y ∈ P (G) and any set V with 0 (cid:54) |V | < k and (v, y) ∈ Ek( ˆG) for
all v ∈ V , we let

G of P (G)) element z (cid:62)P

skip(y, V ) := min{z ∈ P (G) : y (cid:54)P

G z and ∀v ∈ V : (v, z) (cid:54)∈ E(cid:48)(G)},

respectively, skip(y, V ) := void if no such z exists.

Notice that the nodes of V are related to y via Ek and hence are at distance < 3k from y. Hence

for each y, we only need to consider at most ˆd(3k2) such sets V .

For each set V , skip(y, V ) can be computed by running consecutively through all nodes z (cid:62)P
G y
in the list P (G) and test whether E(cid:48)(z, v) holds for some v ∈ V . This can be done in constant time as
we have done the preprocessing for testing for all of the Ei.

Since |V | (cid:54) k and each v ∈ V is of degree at most ˜d in G, the value skip(y, V ) can be found in
time O(k2· ˜d). Therefore, the entire skip-function can be computed, and stored in a data structure by
Theorem 2.1, in time O(˜n1+ε· ˆd(3k2)·g(cid:48)(cid:48)(|ϕ|, ε)) for some computable function g(cid:48)(cid:48). Later, given y and
V as above, the value skip(y, V ) can be looked-up within constant time.
We are now done with the preprocessing phase. Altogether it took

1. the time to compute ψ and G, which is g(|ϕ|)·n1+ε·dg(|ϕ|), for a computable function g

,

15

2. the time to compute (cid:87)

j∈J θj, which is g(|ϕ|), for a computable function g

3. for each j ∈ J and θ := θj, it took

(a) the preprocessing time for θ(cid:48)(G),

which is by induction h(|θ(cid:48)|, ε)·˜n1+ε· ˜dh(|θ(cid:48)|,ε), for the computable function h in the Propo-
sition’s statement

(b) the time for computing P (G), which is

g(|ϕ|)·˜n· ˜dg(|ϕ|), for a computable function g

(c) for all i (cid:54) k, the preprocessing time for testing membership in Ei( ˆG), which can be done

in time g(cid:48)(|Ei|, ε)·˜n1+ε· ˆdg(cid:48)(|Ei|,ε), for a computable function g(cid:48)

(d) and the time for computing the skip-function and to compute the associated data structure,

which is g(cid:48)(cid:48)(|ϕ|, ε)·˜n1+ε· ˜dg(cid:48)(cid:48)(|ϕ|,ε), for a computable function g(cid:48)(cid:48).

It is straightforward to see that, by suitably choosing the computable function h, all the preprocessing
steps can be done within time h(|ϕ|, ε)·n1+ε·dh(|ϕ|,ε).

We now turn to the enumeration procedure. As expected we enumerate all tuples ¯u ∈ ψ(G) and

return f −1(¯u).

In order to enumerate ψ(G) it sufﬁces to enumerate θj(G) for each j. Fix j and let θ = θj and θ(cid:48)

be as in the preprocessing phase. The enumeration of θ(G) is done as follows.

1. Let ¯u be the ﬁrst output produced in the enumeration of θ(cid:48)(G).

If ¯u = void then STOP with output void,
else let (u1, . . . , uk−1) = ¯u and goto line 2.

2. Let y := ﬁrstP

G be the ﬁrst element in the list P (G).

3. Let V := {v ∈ {u1, . . . , uk−1} : (v, y) ∈ Ek( ˆG)}.

4. Let z := skip(y, V ).

5. If z (cid:54)= void then OUTPUT (¯u, z) and goto line 9.

6. If z = void then

7. Let ¯u(cid:48) be the next output produced in the enumeration of θ(cid:48)(G).
8. If ¯u(cid:48) = void then STOP with output void,

else let ¯u := ¯u(cid:48) and goto line 2.

9. Let y := nextP

G (z).

10. If y = void then goto line 7, else goto line 3.

We prove that the above process enumerates θ(G) with constant delay.
To see this, notice ﬁrst that the algorithm never outputs any tuple more than once. Before proving
that this algorithm enumerates exactly the tuples in θ(G), let us ﬁrst show that it operates with delay
at most h(|ϕ|, ε).

,

16

By the induction hypothesis, the execution of line 1 and each execution of line 7 takes time at
most h(|θ(cid:48)|, ε). Furthermore, each execution of line 3 takes time (k−1)·g(cid:48)(|Ek|, ε). Concerning the
remaining lines of the algorithm, each execution can be done in time O(1).

Furthermore, before outputting the ﬁrst tuple, the algorithm executes at most 5 lines (namely, lines
1–5; note that by our choice of the formula θ(cid:48) we know that when entering line 5 before outputting
the ﬁrst tuple, it is guaranteed that z (cid:54)= void, hence an output tuple is generated).

Between outputting two consecutive tuples, the algorithm executes at most 12 lines (the worst
case is an execution of lines 9, 10, 3, 4, 5, 6, 7, 8, 2, 3, 4, 5; again, by our choice of the formula θ(cid:48), at
the last execution of line 5 it is guaranteed that z (cid:54)= void, hence an output tuple is generated).

Therefore, by suitably choosing the function h, we obtain that the algorithm enumerates with

delay at most h(|ϕ|, ε).

We now show that any tuple outputed is a solution.
To see this consider a tuple ¯uz outputed at step 5. By construction we have z ∈ P ( ˆG) and
¯u ∈ φ( ˆG). Hence in order to show that ¯uz ∈ θ( ˆG), it remains to verify that z is not connected to any
of the elements in ¯u.

We can therefore assume that z >P

By deﬁnition of skip it is clear that z is not connected to the elements of V . Assume now that
z = y. Then by deﬁnition of V , z is also not connected to all the elements not in V and we are done.
G y. Let z(cid:48) be the predecessor of z in P (i.e. next(z(cid:48)) = z,
possibly z(cid:48) = y). Assume towards a contradiction that z is connected to an element x of ¯u. From
the remark above, we know that x (cid:54)∈ V . As z(cid:48) was skipped by skip this means that (z(cid:48), v) ∈ E(cid:48)(G)
for some v ∈ V . Consider c ∈ V . By deﬁnition of V we have (c, y) ∈ Ek( ˆG). It turns out that
(c, y) ∈ Ek−1( ˆG). This is because when one Ej does not produce anything outside of Ej−1 then
all the Ej(cid:48) for j(cid:48) > j also do not produce anything outside of Ej−1. Hence, as |V | < k, we must
have (c, y) ∈ Ek−1( ˆG) and in particular (v, y) ∈ Ek−1( ˆG). Altogether, z, z(cid:48), v witness the fact that
(x, y) ∈ Ek( ˆG) contradicting the fact that x is not in V .

It remains to show that all tuples are outputed. This is done by induction. By induction we know
that we consider all relevant ¯u. By deﬁnition, the function skip skips only elements y such that ¯uy is
not a solution. Therefore we eventually output all solutions.

ε

Theorem 2.7 follows immediately from Proposition 3.10 using the usual argument: For a given
2h(|ϕ|,ε/2) , where h is the function of Proposition 3.10, and deﬁne nε := mδ.
ε > 0 we let δ :=
Then, every A ∈ C with |A| (cid:62) nε has degree(A) (cid:54) |A|ε/2h(|ϕ|,ε). Thus, on input of A, ϕ and
ε/2, the enumeration algorithm from Proposition 3.8 has preprocessing time O(h(|ϕ|, ε/2)·|A|1+ε) if
|A| (cid:62) nε and takes time bounded by h(|ϕ|, ε/2)·n1+ε/2+h(|ϕ|,ε/2)
otherwise and delay time h(|ϕ|, ε).
ε
This gives the bounds claimed by the proposition with a computable function as soon as we can
compute nε.

4 Proof of quantiﬁer elimination and normal form

This section is devoted to the proof of Proposition 3.4. The proof consists of several steps, the ﬁrst of
which relies on a transformation of ϕ(¯x) into an equivalent formula in Gaifman normal form, i.e., a
boolean combination of basic-local sentences and formulas that are local around ¯x. A formula λ(¯x)
is r-local around ¯x (for some r (cid:62) 0) if every quantiﬁer is relativized to the r-neighborhood of ¯x. A

,

17

basic-local sentence is of the form

∃y1 · · · ∃y(cid:96)

(cid:94)

dist(yi, yj) > 2r ∧

1(cid:54)i<j(cid:54)(cid:96)

(cid:96)
(cid:94)

i=1

θ(yi),

where θ(y) is r-local around y. By Gaifman’s well-known theorem we obtain an algorithm that
transforms an input formula ϕ(¯x) into an equivalent formula in Gaifman normal form [11].

The rest of the proof can be sketched as follows. Basic-local sentences can be evaluated on classes
of structures of low degree in pseudo-linear time by Theorem 2.4, so it remains to treat formulas that
are local around their free variables. By the Feferman-Vaught Theorem (cf., e.g. [19]), we can fur-
ther decompose local formulas into formulas that are local around one of their free variables. The
latter turns out to have a small answer set that can be precomputed in pseudo-linear time. The re-
maining time is used to compute the structures useful for reconstructing the initial answers from their
components. We now give the details.

Proof of Proposition 3.4.
Step 1: transform ϕ(¯x) into a local formula ϕ(cid:48)(¯x).

We ﬁrst transform ϕ(¯x) into an equivalent formula ϕG(¯x) in Gaifman normal form. For each
basic-local sentence χ occurring in ϕG(¯x), check whether A |= χ and let χ(cid:48) := true if A |= χ and
χ(cid:48) := false if A (cid:54)|= χ. Let ϕ(cid:48)(¯x) be the formula obtained from ϕG(¯x) by replacing every basic-local
sentence χ occurring in ϕG(¯x) with χ(cid:48). By using Gaifman’s theorem and Theorem 2.4, all this can be
done in time O(h(|ϕ|)·n·dh(|ϕ|)), for a computable function h.

Clearly, for every ¯a ∈ dom(A)k we have A |= ϕ(cid:48)(¯a) iff A |= ϕ(¯a). Note that there is a number
r (cid:62) 0 such that ϕ(cid:48)(¯x) is r-local around ¯x, and this number is provided as a part of the output of
Gaifman’s algorithm.
Step 2: transform ϕ(cid:48)(¯x) into a disjunction (cid:87)

P (¯x).
Let ¯x = (x1, . . . , xk). A partition of the set {1, . . . , k} is a list P = (P1, . . . , P(cid:96)) with 1 (cid:54) (cid:96) (cid:54) k

P ∈P ψ(cid:48)

such that

• ∅ (cid:54)= Pj ⊆ {1, . . . , k}, for every j ∈ {1, . . . , (cid:96)},
• P1 ∪ · · · ∪ P(cid:96) = {1, . . . , k},
• Pj ∩ Pj(cid:48) = ∅, for all j, j(cid:48) ∈ {1, . . . , (cid:96)} with j (cid:54)= j(cid:48),
• min Pj < min Pj+1, for all j ∈ {1, . . . , (cid:96)−1}.

Let P be the set of all partitions of {1, . . . , k}. Clearly, |P| (cid:54) k!. For each P = (P1, . . . , P(cid:96)) ∈ P
and each j (cid:54) (cid:96) let ¯xPj be the tuple obtained from ¯x by deleting all those xi with i (cid:54)∈ Pj.

For every partition P = (P1, . . . , P(cid:96)) ∈ P let (cid:37)P (¯x) be an FO(σ)-formula stating that each of the

following is true:

1. The r-neighborhood around ¯x in A is the disjoint union of the r-neighborhoods around ¯xPj for

j (cid:54) (cid:96). I.e.,

δP (¯x) :=

(cid:94)

(cid:94)

dist(xi, xi(cid:48)) > 2r+1.

1(cid:54)j<j(cid:48)(cid:54)(cid:96)

(i,i(cid:48))∈Pj ×Pj(cid:48)

2. For each j (cid:54) (cid:96), the r-neighborhood around ¯xPj in A is connected, i.e., satisﬁes the formula

γPj (¯xPj ) :=

(cid:95)

(cid:94)

dist(xi, xi(cid:48)) (cid:54) 2r+1.

E⊆Pj ×Pj such that the
graph (Pj ,E) is connected

(i,i(cid:48))∈E

,

18

Note that the formula (cid:37)P (¯x) := δP (¯x) ∧ (cid:86)(cid:96)
obviously is equivalent to the formula (cid:87)

P ∈P

j=1 γPj (¯xPj ) is r-local around ¯x. Furthermore, ϕ(cid:48)(¯x)
(cid:0) (cid:37)P (¯x) ∧ ϕ(cid:48)(¯x) (cid:1).

Using the Feferman-Vaught Theorem (see e.g. [19]), we can, for each P = (P1, . . . , P(cid:96)) ∈ P,
compute a decomposition of ϕ(cid:48)(¯x) into r-local formulas ϑP,j,t(¯xPj ), for j ∈ {1, . . . , (cid:96)} and t ∈ TP ,
for a suitable ﬁnite set TP , such that the formula (cid:0)(cid:37)P (¯x) ∧ ϕ(cid:48)(¯x)(cid:1) is equivalent to

(cid:37)P (¯x) ∧

(cid:95)

t∈TP

(cid:0) ϑP,1,t(¯xP1) ∧ · · · ∧ ϑP,(cid:96),t(¯xP(cid:96)) (cid:1)

which, in turn, is equivalent to ψ(cid:48)

P := (ψ(cid:48)

P,1 ∧ ψ(cid:48)

P,2), where ψ(cid:48)

P,1 := δP (¯x) and

ψ(cid:48)

P,2

:=

(cid:16) (cid:96)
(cid:94)

j=1

γPj (¯xPj )

(cid:17)

∧

(cid:95)

(cid:16) (cid:96)
(cid:94)

t∈TP

j=1

ϑP,j,t(¯xPj )

(cid:17)

.

In summary, ϕ(cid:48)(¯x) is equivalent to (cid:87)

ϕ(cid:48)(¯a), there is exactly one partition P ∈ P such that A |= ψ(cid:48)
one such P ∈ P).

P ∈P ψ(cid:48)

P (¯x), and for every tuple ¯a ∈ dom(A)k with A |=
P (¯a) (since A |= (cid:37)P (¯a) is true for only

Step 3: deﬁning G, f , and ψ.

We deﬁne the domain G of G to be the disjoint union of the sets A and V , where A := dom(A),

and V consists of a “dummy element” v⊥, and an element v(¯b,ι)

• for each ¯b ∈ A1 ∪ · · · ∪ Ak such that A |= γP (¯b) where P := {1, . . . , |b|} and

• for each injective mapping ι : {1, . . . , |¯b|} → {1, . . . , k}.

Note that the ﬁrst item ensures that the r-neighborhood around ¯b in A is connected. The second item
ensures that we can view ι as a description telling us that the i-th component of ¯b shall be viewed as
an assignment for the variable xι(i) (for each i ∈ {1, . . . , |¯b|}).

We let f be the function from Ak to V k deﬁned as follows: For each ¯a ∈ Ak let P = (P1, . . . , P(cid:96))
be the unique element in P such that A |= (cid:37)P (¯a). For each j (cid:54) {1, . . . , (cid:96)}, we write ¯aPj for the tuple
obtained from ¯a by deleting all those ai with i (cid:54)∈ Pj. Furthermore, we let ιPj be the mapping from
{1, . . . , |Pj|} to {1, . . . , k} such that ι(i) is the i-th smallest element of Pj, for any i ∈ {1, . . . , |Pj|}.
Then,

f (¯a) := (cid:0) v(¯aP1 ,ιP1 ), . . . , v(¯aP(cid:96)

), v⊥, . . . , v⊥

,ιP(cid:96)

(cid:1),

where the number of v⊥-components is (k−(cid:96)). It is straightforward to see that f is injective.

We let τ1 be the signature consisting of a unary relation symbol C⊥, and a unary relation symbol

Cι for each injective mapping ι : {1, . . . , s} → {1, . . . , k} for s ∈ {1, . . . , k}.

In G, the symbol C⊥ is interpreted by the singleton set {v⊥}, and each Cι is interpreted by the set

of all nodes v(¯b,ˆι) ∈ V with ˆι = ι.

We let E be a binary relation symbol which is interpreted in G by the set of all tuples (v(¯b,ι), v(¯c,ˆι)) ∈

V 2 such that there are elements b(cid:48) ∈ A in ¯b and c(cid:48) ∈ A in ¯c such that distA(b(cid:48), c(cid:48)) (cid:54) 2r+1.

For each P = (P1, . . . , P(cid:96)) ∈ P, each j ∈ {1, . . . , (cid:96)}, and each t ∈ TP we let CP,j,t be a unary
relation symbol which, in G, is interpreted by the set of all nodes v(¯b,ι) ∈ V such that ι = ιPj and
A |= ϑP,j,t(¯b).

We let τ2 be the signature consisting of all the unary relation symbols CP,j,t.

,

19

We let ¯y = (y1, . . . , yk) be a tuple of k distinct variables, and we deﬁne ψ1(¯y) to be the FO(E)-

formula

ψ1(¯y)

:=

(cid:94)

¬E(yj, yj(cid:48)).

1(cid:54)j,j(cid:48)(cid:54)k
with j(cid:54)=j(cid:48)

For each P = (P1, . . . , P(cid:96)) we let ψP (¯y) be the FO(τ1 ∪ τ2)-formula deﬁned as follows:

ψP (¯y)

:=

(cid:16) (cid:96)
(cid:94)

j=1

CιPj

(yj)

(cid:17)

∧

(cid:16) k
(cid:94)

j=(cid:96)+1

(cid:17)

C⊥(yj)

∧

(cid:95)

(cid:16) (cid:96)
(cid:94)

(cid:17)

CP,j,t(yj)

.

t∈TP

j=1

It is straightforward to verify that the following is true:

(1) For every ¯a ∈ Ak with A |= ψ(cid:48)

P (¯a), we have G |= (ψ1 ∧ ψP )(f (¯a)).

(2) For every ¯v ∈ Gk with G |= (ψ1 ∧ ψP )(¯v), there is a (unique) tuple ¯a ∈ Ak with ¯v = f (¯a), and

for this tuple we have A |= ψ(cid:48)

P (¯a).

Finally, we let

ψ(¯y) := (cid:0)ψ1(¯y) ∧ ψ2(¯y)(cid:1) with ψ2(¯y) :=

(cid:95)

P ∈P

ψP (¯y).

It is straightforward to see that f is a bijection between ϕ(A) and ψ(G).

In summary, we now know that items 1 and 2, as well as the non computational part of item 4 of

Proposition 3.4 are true.

Later on in Step 5 we will provide details on how to build a data structure that, upon input of any

tuple ¯a ∈ Ak, returns the tuple f (¯a) within the claimed time bounds.

In order to be able to also compute f −1(¯v) upon input of any tuple ¯v ∈ ψ(G), we use additional
binary relation symbols F1, . . . , Fk which are interpreted in G as follows: Start by initializing all
of them to the empty set. Then, for each v = v(¯b,ι) ∈ V and each j ∈ {1, . . . , |¯b|}, add to F G
ι(j)
the tuple (v, a), where a is j-th component of ¯b. This completes the deﬁnition of G and τ , letting
τ := τ1 ∪ τ2 ∪ {E, F1, . . . , Fk}.

Using the relations F1, . . . , Fk of G, in time O(k) we can, upon input of v = v(¯b,ι) ∈ V compute
the tuple ¯b and the mapping ι (for this, just check for all i ∈ {1, . . . , k} whether node v has an outgoing
Fi-edge). Using this, it is straightforward to see that upon input of ¯v ∈ ψ(G), the tuple f −1(¯v) ∈ Ak
can be computed in time O(k2),

Step 4: Computing G within the time bounds of Item 3.

First of all, note that for each v(¯b,ι) ∈ V , the tuple ¯b is of the form (b1, . . . , bs) ∈ As for some
ˆr (b1) of b1 in A, for

s (cid:54) k, such that all components of the tuple belong to the ˆr-neighborhood N A
ˆr := k(2r+1).

By Lemma 3.1 we can compute in total time O(|ϕ| · n · dh(cid:48)(|ϕ|)) all the neigborhoods N A

ˆr (a) (for
all a ∈ dom(A)), where h(cid:48) is some computable function (recall that ˆr depends only on ϕ). Within
the same time bound, we can also compute all the neighborhoods N A
r(cid:48)−r(a), for
˜r := ˆr+r and r(cid:48) := r + (2k+1)(2r+1) (later on it will be convenient to have efﬁcient access to all
these neighborhoods).

r(cid:48) (a), and N A

˜r (a), N A

Thus, the set V , along with the relations C⊥, Cι and F1, . . . , Fk of G, can be computed as follows:
Start by letting V := {v⊥} and initializing all relations to the empty set. Let CG
⊥ := {v⊥}. Then, for
each a ∈ A, consider the ˆr-neighborhood N A
ˆr (a) of a in A, and compute (by a brute-force algorithm),
for each s ∈ {1, . . . , k}, the set of all s-tuples ¯b of elements from this neighborhood, which satisfy

,

20

the following: The ﬁrst component of ¯b is a, and N A
ˆr (a) |= γPj (¯b) for Pj = {1, . . . , s}. For each
such tuple ¯b do the following: For each injective mapping ι : {1, . . . , s} → {1, . . . , k} add to V a
new element v(¯b,ι), add this element to the relation CG
ι(j) the
tuple (v(¯b,ι), a), where a is the j-th component of ¯b.

ι , and for each j ∈ {1, . . . , s}, add to F G

This way, the domain G = A ∪ V of G, along with the relations Cι and F1, . . . , Fk of G, can be

computed in time O(h(|ϕ|)·n·dh(|ϕ|)), for a computable function h.

For computing the unary relations CP,j,t of G, start by initializing all of them to the empty set.
For each v(¯b,ι) ∈ V do the following: Compute (by using the relations F1, . . . , Fk) the tuple ¯b and
the mapping ι. Let a be the ﬁrst component of ¯b. Consider the ˜r-neighborhood N A
˜r (a) of a in A, for
˜r := ˆr+r. For each P = (P1, . . . , P(cid:96)) ∈ P, each j ∈ {1, . . . , (cid:96)} such that ιPj = ι, and each t ∈ TP ,
˜r (a) |= θP,t,j(¯b). If so, add the element v(¯b,ι) to the relation CP,j,t of G. (This is
check whether N A
correct, since the formula θP,j,t is r-local around its free variables, and the radius of the neighborhood
is large enough.)

This way, G’s relations CP,j,t can be computed in time O(h(|ϕ|)·n·dh(|ϕ|)), for a computable

function h.

To compute the E-relation of G, note that for all tuples (v(¯b,ι), v(¯c,ˆι)) ∈ EG, we have distA(a, cj) (cid:54)
(2k+1)(2r+1), for all components cj of ¯c, where a is the ﬁrst component of ¯b. Thus, the E-relation
of G can be computed as follows: Start by initializing this relation to the empty set. For each v(¯b,ι) ∈
V do the following: Compute (by using the relations F1, . . . , Fk) the tuple ¯b. Let a be the ﬁrst
component of ¯b. Consider the r(cid:48)-neighborhood N A
r(cid:48) (a) of a in A, for r(cid:48) := r + (2k+1)(2r+1).
r(cid:48)−r(a), such that |¯c| (cid:54) k and
Use a brute-force algorithm to compute all tuples ¯c of elements in N A
r(cid:48) (a) |= γPj (¯c) for Pj = {1, . . . , |¯c|}. Check if there are components b(cid:48) of ¯b and c(cid:48) of ¯c such
N A
that distN A
r(cid:48) (a)(b(cid:48), c(cid:48)) (cid:54) 2r+1. If so, add to EG the tuple (v(¯b,ι), v(¯c,ˆι)) for each injective mapping
ˆι : {1, . . . , |¯c|} → {1, . . . , k}.

This way, the E-relation of G can be computed in time O(h(|ϕ|)·n·dh(|ϕ|)), for a computable

function h.

In summary, we obtain that G is computable from A and ϕ within the desired time bound.
To ﬁnish the proof of item 3, we need to give an upper bound on the degree of G. As noted above,
(v(¯b,ι), v(¯c,ˆι)) ∈ EG implies that distA(a, cj) (cid:54) r(cid:48) for r(cid:48) := (2k+1)(2r+1), for all components cj of
¯c, where a is the ﬁrst component of ¯b. Thus, for each ﬁxed v(¯b,ι) ∈ V , the number of elements v(¯c,ˆι)
such that (v(¯b,ι), v(¯c,ˆι)) ∈ EG is at most

k! ·

k
(cid:88)

s=1

|N A

r(cid:48) (a)|s (cid:54) k! · |N A

r(cid:48) (a)|k+1 (cid:54) k! · d(r(cid:48)+1)(k+1).

Thus, since EG is symmetric, its degree is (cid:54) 2k!d(r(cid:48)+1)(k+1).

Similarly, for each tuple (v(¯b,ι), a) ∈ F G
i

(with i ∈ {1, . . . , k}) we know that a is the ι−1(i)-th
component of ¯b and each component of ¯b belongs to the ˆr-neighborhood of a in A, for ˆr = k(2r+1).
Thus, for each ﬁxed a ∈ A, the number of elements v(¯b,ι) ∈ V such that (v(¯b,ι), a) ∈ F G
is at most
i
k! · (cid:80)k
ˆr (a)|s (cid:54) k! · d(ˆr+1)(k+1). In summary, we thus obtain that G is of degree at most dh(|ϕ|)
for a computable function h.

s=1 |N A

Step 5: Computing f within the time bounds of Item 4.

Recall that for ¯a ∈ Ak we have

f (¯a) := (cid:0) v(¯aP1 ,ιP1 ), . . . , v(¯aP(cid:96)

,ιP(cid:96)

), v⊥, . . . , v⊥

(cid:1),

,

21

for the unique partition P = (P1, . . . , P(cid:96)) ∈ P such that A |= (cid:37)P (¯a). The number of v⊥-components
in f (¯a) is (k−(cid:96)).

We ﬁrst show how to compute f (¯a) from ¯a in constant time. This is where we use ε.
To compute the partition P for a given tuple ¯a = (a1, . . . , ak), we can proceed as follows: Con-
struct an undirected graph H with vertex set {1, . . . , k}, where there is an edge between i (cid:54)= j iff
distA(ai, aj) (cid:54) 2r+1. This can be done as follows. Let R be the binary relation over dom(A) con-
taining all pairs (a, b) such that distA(ai, aj) (cid:54) 2r+1. As A as degree at most d, the size of R is
bounded by n·d2r+2 and R can be computed by a brute-force algorithm in time O(n · d2r+2). Hence
by the Storing Theorem (Theorem 2.1), we can compute a data structure in time O(n1+ε · d2r+2) such
that afterwards we can test in time depending only on ε whether a given pair is in R or not.

Once H is computed, we can compute its connected components in time depending only on k.
Let (cid:96) be the number of connected components of H. For each j ∈ {1, . . . , (cid:96)} let Pj be vertex set of
the j-th connected component, such that min Pj < min Pj+1 for all j ∈ {1, . . . , (cid:96)−1}. After having
constructed the partition P = (P1, . . . , P(cid:96)), further O(k2) steps sufﬁce to construct the tuples ¯aP1,
. . . , ¯aP(cid:96), the mappings ιP1, . . . , ιP(cid:96), and the according tuple f (¯a). Let ζP be the function associating
to each pair (¯aPj , ιPj ) the element v(¯aPj ,ιPj ). The domain of ζP is at most n·dk(2r+1)+1 and ζP can
be computed in O(n · dk(2r+1)+1) by a brute-force algorithm. Hence, using Theorem 2.1 we can
compute in time O(n1+ε · dk(2r+1)+1) a data structure such that afterwards we can obtain the result
of the function ζP in time depending only on ε.

Altogether, after the preprocessing, we can compute f (¯a) in time O(k2).
Recall that using the relation F , it is straightforward to compute f −1(¯v) upon input of ¯v ∈ dom(G)

in time O(k2).

This concludes the proof of proof of Proposition 3.4.

5 Conclusion

For classes of databases of low degree, we presented an algorithm which enumerates the answers to
ﬁrst-order queries with constant delay after pseudo-linear preprocessing. An inspection of the proof
shows that the constants involved are non-elementary in the query size (this is already the case for
Theorem 2.4 and we build upon this result, this is also a consequence of Gaifman Normal Form
which derives a new formula of non-elementary size [5]).

In the bounded degree case the constants are triply exponential in the query size [15].

In the
(unranked) tree case the constants are provably non-elementary [10] (modulo some complexity as-
sumption). We do not know what is the situation for classes of low degree.

If the database is updated, for instance if a tuple is deleted or inserted, it would be desirable to be
able to update efﬁciently the data structure that is computed for deriving in constant time counting,
testing, and enumeration. With the data structure given in this paper it is not clear how to do this with-
out recomputing everything from scratch. However it has been shown recently that there is another
data structure, providing the same constant time properties that furthermore can be updated in time
O(nε) upon insertion or deletion of a tuple [22].

It would also be interesting to know whether we can enumerate the answers to a query using the

lexicographical order (as it is the case over structures of bounded expansion [17]).

,

References

22

[1] Guillaume Bagan. MSO queries on tree decomposable structures are computable with linear

delay. In Proc. of Computer Science Logic (CSL’06), pages 167–181, 2006.

[2] Guillaume Bagan, Arnaud Durand, and Etienne Grandjean. On acyclic conjunctive queries and
In Proc. of Computer Science Logic (CSL’07), pages 208–222,

constant delay enumeration.
2007.

[3] Johann Brault-Baron. A negative conjunctive query is easy if and only if it is beta-acyclic. In

Proc. of Computer Science Logic (CSL’12), 2012.

[4] Bruno Courcelle. Linear delay enumeration and monadic second-order logic. Discrete Applied

Mathematics, 157(12):2675–2700, 2009.

[5] Anuj Dawar, Martin Grohe, Stephan Kreutzer, and Nicole Schweikardt. Model theory makes
In Automata, Languages and Programming, 34th International Colloquium,
formulas large.
ICALP 2007, Wroclaw, Poland, July 9-13, 2007, Proceedings, volume 4596 of Lecture Notes in
Computer Science, pages 913–924. Springer, 2007.

[6] Arnaud Durand and Etienne Grandjean. First-order queries on structures of bounded degree are
computable with constant delay. ACM Transactions on Computational Logic, 8(4), 2007.

[7] Arnaud Durand, Nicole Schweikardt, and Luc Segouﬁn. Enumerating answers to ﬁrst-order
In Proc. Symp. on Principles of Database Systems

queries over databases of low degree.
(PODS’14), 2014.

[8] Zdenek Dvor´ak, Daniel Kr´al, and Robin Thomas. Testing ﬁrst-order properties for subclasses of

sparse graphs. J. ACM, 60(5):36:1–36:24, 2013.

[9] J¨org Flum and Martin Grohe. Parameterized Complexity Theory. Springer-Verlag, 2006.

[10] Markus Frick and Martin Grohe. The complexity of ﬁrst-order and monadic second-order logic

revisited. Annals of Pure and Applied Logic, 130(1-3):3–31, 2004.

[11] Haim Gaifman. On local and nonlocal properties.

In J. Stern, editor, Logic Colloquium’81,

pages 105–135. North-Holland, 1982.

[12] Etienne Grandjean and Fr´ed´eric Olive. Graph properties checkable in linear time in the number

of vertices. Journal of Computer and System Sciences, 68(3):546–597, 2004.

[13] Martin Grohe. Generalized model-checking problems for ﬁrst-order logic. In Proc. Symp. on

Theoretical Aspects of Computer Science (STACS’01), 2001.

[14] Martin Grohe, Stephan Kreutzer, and Sebastian Siebertz. Deciding ﬁrst-order properties of

nowhere dense graphs. J. ACM, 64(3):17:1–17:32, 2017.

[15] Wojciech Kazana and Luc Segouﬁn. First-order query evaluation on structures of bounded de-

gree. Logical Methods in Computer Science, 7(2), 2011.

[16] Wojciech Kazana and Luc Segouﬁn. Enumeration of monadic second-order queries on trees.

ACM Transactions on Computational Logic, 14(4), 2013.

,

23

[17] Wojciech Kazana and Luc Segouﬁn. Enumeration of ﬁrst-order queries on classes of structures

with bounded expansion. Logical Methods in Computer Science, 16(1), 2020.

[18] Stephan Kreutzer and Anuj Dawar. Parameterized complexity of ﬁrst-order logic. Electronic

Colloquium on Computational Complexity (ECCC), 16:131, 2009.

[19] Johann A. Makowsky. Algorithmic uses of the Feferman-Vaught Theorem. Annals of Pure and

Applied Logic, 126(1-3):159–213, 2004.

[20] Nicole Schweikardt, Luc Segouﬁn, and Alexandre Vigny. Enumeration for FO queries over
nowhere dense graphs. In Proc. of Symp. on Principles of Database Systems (PODS), 2018.

[21] Nicole Schweikardt, Luc Segouﬁn, and Alexandre Vigny. Enumeration for FO queries over

nowhere dense graphs. Journal version of [20], submitted, 2020.

[22] Alexandre Vigny. Dynamic query evaluation over structures with low degree. CoRR,

abs/2010.02982, 2020.

[23] Mihalis Yannakakis. Algorithms for acyclic database schemes. In Proc. Intl. Conf. on Very Large

Data Bases (VLDB’81), 1981.

