Generalized Bundled Fragments for First-Order Modal
Logic
Mo Liu, Anantha Padmanabha, R Ramanujam, Yanjing Wang

To cite this version:

Mo Liu, Anantha Padmanabha, R Ramanujam, Yanjing Wang. Generalized Bundled Fragments for
First-Order Modal Logic. 47th International Symposium on Mathematical Foundations of Computer
Science (MFCS 2022), Aug 2022, Vienna, Austria. pp.70:1–70:14, ￿10.4230/LIPIcs.MFCS.2022.70￿.
￿hal-03765358￿

HAL Id: hal-03765358

https://inria.hal.science/hal-03765358

Submitted on 31 Aug 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution 4.0 International License

Generalized Bundled Fragments for First-Order
Modal Logic

Mo Liu !
LORIA, Unviersity of Lorraine, Nancy, France

Anantha Padmanabha !
DI ENS, École Normale Supérieure, Université PSL, CNRS, Inria, Paris, France

R. Ramanujam !
Institute of Mathematical Sciences, HBNI, Chennai, India (Retired)
Azim Premji University, Bengaluru (Visiting)

Yanjing Wang !
Department of Philosophy, Peking University, Beijing, China

Abstract

When we bundle quantifiers and modalities together (as in ∃x□, ♢∀x etc.) in first-order modal logic
(FOML), we get new logical operators whose combinations produce interesting bundled fragments of
FOML. It is well-known that finding decidable fragments of FOML is hard, but existing work shows
that certain bundled fragments are decidable [14], without any restriction on the arity of predicates,
the number of variables, or the modal scope. In this paper, we explore generalized bundles such as
∀x∀y□, ∀x∃y♢ etc., and map the terrain with regard to decidability, presenting both decidability and
undecidability results. In particular, we propose the loosely bundled fragment, which is decidable
over increasing domains and encompasses all known decidable bundled fragments.

2012 ACM Subject Classification Theory of computation → Modal and temporal logics; Theory of
computation → Logic and verification

Keywords and phrases bundled fragments, first-order modal logic, decidability, tableaux

Digital Object Identifier 10.4230/LIPIcs.MFCS.2022.70

Related Version Full Version: https://arxiv.org/abs/2202.01581

Funding This work is supported by NSSF grant 19BZX135.
Anantha Padmanabha: The author is funded by the French government under management of
Agence Nationale de la Recherche as part of the “Investissements d’avenir” program, reference
ANR-19-P3IA-0001 (PRAIRIE 3IA Institute).

Acknowledgements The authors thank the anonymous reviewers of MFCS2022 for their comments
that improved the presentation of the paper.

1

Introduction

While propositional modal logic (ML) has had extensive applications in system verification
and artificial intelligence, and first-order logic (FOL) in finite model theory and database
theory, first-order modal logic (FOML) has been studied much less, as it seems to combine
the worst of both computationally, leading to undecidability. FOML is a natural specification
language for state transition systems where states are given by first-order descriptions of
computational domains, with applicability in the realm of database updates, in the control
of infinite-state systems, networks with unbounded parallelism and cryptographic protocols.
This motivates the study of decidable fragments of FOML.

© Mo Liu, Anantha Padmanabha, R. Ramanujam, and Yanjing Wang;
licensed under Creative Commons License CC-BY 4.0

47th International Symposium on Mathematical Foundations of Computer Science (MFCS 2022).
Editors: Stefan Szeider, Robert Ganian, and Alexandra Silva; Article No. 70; pp. 70:1–70:14

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

70:2

Generalized Bundled Fragments for FOML

This is a challenge, since even the two-variable fragment of FOML with one unary
predicate is undecidable over almost all useful model classes [15]. This situation is to be
contrasted against the robust decidability of propositional modal logics ([16, 1, 7]), and the
many decidable fragments of first-order logic ([4]).

Despite such discouragement, there have been a few successful attempts: for instance, the
monodic restriction, mandating only one free variable in the scope of any modal subformula,
yields decidability when combined with a decidable fragment of FOL ([8, 19]). This idea,
arising originally from description logics (cf. [9]) has led to applications in temporal and
epistemic logics ([6], [10], [2, 3]).

Rather than placing a restriction on variables, or on quantification scope as in the case of
guarded fragments [1], Wang ([17]) suggested a fragment in which the existential quantifier
and the box modality were always bundled together to appear as a single quantifier-modality
pair (∃x□). The resulting fragment of FOML enjoys many attractive properties: finite
tree model property, PSpace decision procedure and a simple axiom system, without any
restriction on predicates or the occurrences of variables. The new operator ∃x□ captures
the logical structure of various knowing-wh expressions such as knowing what, knowing how,
knowing why, and so on (cf. [18]), e.g., knowing how to achieve φ can be rendered as there is
a plan x such that the agent knows that x can be executed and will guarantee φ.

In [14], we took the next step by considering not only the combination ∃x□ but also its
companion ∀x□: the logic with both of these combinations continued to be decidable (over
increasing domain models). Such modal-quantifier combinations were thus called bundled
fragments of FOML. Over models where the domain remains the same in all states, the
fragment with both ∃x□ and ∀x□ is undecidable, while the ∃x□-fragment is still decidable.
Clearly, we can define more bundles such as □∀x, □∃x, etc., and indeed further combina-
tions such as ∀x∀y□, and combinations thereof. These (generalized) bundled fragments offer
us many interesting possibilities for system specification:

¬∃x□ (x < c): No element is guaranteed to be bounded by constant c (after update).
∃x□ □∃y (x > y): There is an element that dominates some element after every update.
□∃x □∀y (x ≤ y): All updates admit a local minimum.
∃x□ (∃y□ (x > y) ∧ ∃y□ (x < y)): There is an element that dominates another no matter
the update and is dominated by another no matter the update.

Computationally this raises the natural question of what is the most general bundled fragment
that is decidable. This is the project taken up in this paper. We consider all possible
combinations of the bundled formulas and classify their decidability status. The classification
is described in Table 1. We provide a trichotomy: decidable fragments, undecidable fragments
and fragments that do not have a finite model property (but where decidability is open).

Towards proving the trichotomy, we first define the notion of loosely bundled fragment
which subsumes many decidable bundled fragments of FOML and prove its decidability via a
tableau method. We also prove the decidability of another combination of bundled operators
where we allow only formulas of the form ∀x□ + □∀x + □∃x (but is not included in the
loosely bundled fragment). This requires us to introduce a new proof technique that helps us
switch quantifiers in a specific context.

Due to space restrictions, we present only the main ideas and proof techniques of the
decidable fragments over increasing domain models in the paper. The proof details, as well
as undecidability and lack of finite model property for the other fragments can be found in
the detailed technical report in the arXiv [13].

M. Liu, A. Padmanabha, R. Ramanujam, and Y. Wang

70:3

Table 1 Satisfiability problem classification for combinations of bundled fragments over increasing

domain models. A “∗” means no matter the corresponding bundle is included or not.

∀□ ∃□ □∀ □∃
✓
✗
✗
✗
✓
✗

✗
✗
✗
✓
✗
✓

✗
✗
✓
✗
✗
✓

✗
✓
✗
✗
✓
✗

Decidability

Subsumed by the
Loosely Bundled Fragment

*
✗
✓
✓

✓
✓
✓
✗

✓
✗
✗
✓

*
✓
✓
✓

Undecidable
No Finite Model Property
Undecidable
ExpSpace

Loosely Bundled Fragment

ExpSpace

2

Syntax and Semantics

The syntax of first-order modal logic is given by extending the first-order logic with modal
operators. Note that we exclude equality, constants and function symbols from the syntax.

▶ Definition 1 (FOML syntax). Given a countable set of predicates P and a countable set of
variables Var, the syntax of FOML is given by:

α ::= P (x1, . . . , xn) | ¬α | α ∧ α | ∃xα | □α

where P ∈ P has arity n and x, x1, . . . , xn ∈ Var.

The boolean connectives ∨, →, ↔, and the modal operator ♢ which is the dual of □, and
the quantifier ∀ are all defined in the standard way. The notion of free variables, denoted by
FV(α) is similar to what we have for first-order logic with FV(□α) = FV(α). We write α(x)
to mean that x occurs as a free variable of α. Also, α[y/x] denotes the formula obtained
from α by replacing every free occurrence of x by y.

▶ Definition 2 (FOML structure). An increasing domain model for FOML is a tuple M =
(W, D, δ, R, ρ) where W is a non-empty countable set called worlds;1 D is a non-empty
countable set called domain; R ⊆ (W × W) is the accessibility relation. The map δ : W 7→ 2D
assigns to each w ∈ W a non-empty local domain set such that whenever (w, v) ∈ R we
have δ(w) ⊆ δ(v) and ρ : (W × P) 7→ S
is the valuation function, which specifies the
n

2Dn

interpretation of predicates at every world over the local domain with appropriate arity. The
model M is said to be a constant domain model if for all w ∈ W we have δ(w) = D.

The monotonicity condition requiring δ(w) ⊆ δ(v) for (w, v) ∈ R is required for evaluating
the free variables present in the formula [11]. Because of this, the models are called increasing
domain models.

For a given model M we denote WM, RM etc to indicate the corresponding components.

We simply use W, R, δ etc when M is clear from the context.

1 Note that FOML can be translated into two-sorted FOL, and due to the Löwenheim–Skolem theorem

for countable languages, every model has an equivalent countable model, cf. [5].

M F C S 2 0 2 2

70:4

Generalized Bundled Fragments for FOML

To evaluate formulas, we need an assignment function for variables. For a given model
M, an assignment function σ : Var 7→ D is relevant at w ∈ W if σ(x) ∈ δ(w) for all x ∈ Var.

▶ Definition 3 (FOML semantics). Given an FOML model M = (W, D, δ, R, ρ) and w ∈ W,
and σ relevant at w, for all FOML formulas α define M, w, σ |= α inductively as follows:

M, w, σ |= P (x1, . . . , xn) ⇔ (σ(x1), . . . , σ(xn)) ∈ ρ(w, P )
M, w, σ |= ¬α
M, w, σ |= α ∧ β
M, w, σ |= ∃xα
M, w, σ |= □α

⇔ M, w, σ ̸|= α
⇔ M, w, σ |= α and M, w, σ |= β
⇔ there is some d ∈ δ(w) such that M, w, σ[x7→d] |= α
⇔ for every u ∈ W if (w, u) ∈ R then M, u, σ |= α

We sometimes write M, w |= α(a) to mean M, w, [x 7→ a] |= α(x).
A formula α is satisfiable if there is some FOML structure M and w ∈ W and some
assignment σ relevant at w such that M, w, σ |= α. In the sequel, we will only talk about
the relevant σ for a given pointed model. Also, while evaluating α, it is enough to consider σ
to be a partial function that gives an interpretation for the free variables of α. A formula α
is valid if ¬α is not satisfiable.

2.1 Bundled fragments

The motivation for “bundling” is to restrict the occurrences of quantifiers using modalities.
For instance, allowing only formulas of the form ∀x□α is one such bundling. We could also
have ♢∃yα. Thus, there are many ways to “bundle” the quantifiers and modalities. We call
these the “bundled operators/modalities”. The following syntax defines all possible bundled
operators of one quantifier and one modality:

▶ Definition 4 (Bundled-FOML syntax). The bundled fragment of FOML is the set of all
formulas constructed by the following syntax:

α ::= P (x1, . . . , xn) | ¬α | α ∧ α | □α | ∃x□α | ∀x□α | □∃xα | □∀xα

where P ∈ P has arity n and x, x1, . . . , xn ∈ Var.

Note that the duals of the bundled operators give us the formulas of the form ∀x♢α, ∃x♢α,
♢∀xα, ♢∃xα. Also, note that □α can be defined using any one of the bundled operators
where the quantifier is applied to a variable that does not occur in α. However, we retain
□α in the syntax for technical convenience.

The following constant domain models may help to get familiar with bundles.

v1 : P a

u1 : P b

w1

M1

w2

v2 : P c

w3

(cid:47) v3 : P c

u2

M2

M3

Let DM1 = {a, b}, DM2 = DM3 = {c}. □∃xP x holds at w1 and w3 but not at w2; ∃x□P x
holds only at w3; ¬∀x□P x holds at w1 and w2; ¬□∀x¬P x holds at all the wi.

We denote ∀□-fragment to be the language that allows only atomic formulas, negation,
conjunction, □α and ∀x□α (dually ∃x♢α) formulas, similarly for ∃□-fragment and so on. In
general, these fragments are not equally expressive, e.g., as shown by [17], the ∃□-fragment
cannot express □∃, ∀□ and □∀ bundles over models with increasing (or constant) domains.
In [14, 12] we proved that the ∀□+∃□ and □∀+□∃ fragments are decidable over increasing
domain models, while ∀□-fragment and □∀-fragment are undecidable over constant domain
models. Since simple bundles become undecidable over constant domain models, in this
paper we focus on generalized bundles over increasing domain models.

(cid:47)
(cid:47)
(cid:41)
(cid:41)
(cid:47)
(cid:47)
(cid:41)
(cid:41)
(cid:47)
M. Liu, A. Padmanabha, R. Ramanujam, and Y. Wang

70:5

Note that we can have more general bundled operators of the form ∀x∀y□α etc. This
naturally raises the question of what is the most general fragment of this form that is
decidable. Towards this, we define a general fragment that subsumes all known decidable
bundled fragments so far.

2.2 The Loosely Bundled Fragment

Note that a bundled formula of the form ∃x□α imposes a restriction that there is exactly
one modal formula in the scope of ∃x. But this is a strong requirement. We weaken this
condition to allow formulas of the form ∃xβ where β is a boolean combination of atomic
formulas and modal formulas. Moreover, we can allow a quantifier alternation of the form
∃x1 · · · ∃xn ∀y1 · · · ∀ym β. As we will see, the fact that the existential quantifiers are outside
the scope of universal quantifiers can help us to obtain decidability results over increasing
domain models.

▶ Definition 5 (LBF syntax). The loosely bundled fragment of FOML is the set of all formulas
constructed by the following syntax:

ψ ::=P (z1, . . . zn) | ¬P (z1, . . . zn) | ψ ∧ ψ | ψ ∨ ψ | □α | ♢α
α ::=ψ | α ∧ α | α ∨ α | ∃x1 . . . ∃xk∀y1 . . . ∀yl ψ

where k, l, n ≥ 0 and P ∈ P has arity n and x1, . . . xk, y1, . . . yl, z1, . . . , zn ∈ Var.

Let LBF be the set of all formulas that can be obtained from the grammar of α above.
Note that the syntax does not allow a quantifier alternation of the form ∀x∃y α. Also, inside
the scope of quantifier prefix ∃∗∀∗, we can only have boolean combinations of atomic and
modal formulas. The ∃∗∀∗ fragment in FO, (Bernays-Schönfinkel-Ramsey class) has a similar
quantifier prefix structure but is different in spirit since there is no modality.

The loosely bundled fragment subsumes some of the combinations of bundled fragments.
Hence proving the decidability for LBF implies the decidability for these combinations as well.

▶ Proposition 6. The fragments ∀□ + ∃□ and □∀ + □∃ are subfragments of LBF.

Note that many combinations of bundled operators (for instance □∀ + ∃□) do not form a

subfragment of LBF.

3

Tableau Procedure

Note that the formulas of LBF are in negation normal form (where ¬ appears only in front of
atomic formulas). We first define some useful terms and notations.

▶ Definition 7. For any FOML formula φ:

φ is a literal if φ is of the form P (x1, . . . xn) or of the form ¬P (x1, . . . xn)
φ is a module if φ is a literal or φ is of the form ∆α where ∆ ∈ {□, ♢}
The component of φ is defined inductively as follows:

If φ is a module then C(φ) = {φ}
If φ is of the form φ1 ∧ φ2 or φ1 ∨ φ2 then
C(φ) = C(φ1) ∪ C(φ2)
If φ is of the form ∀x φ1 or ∃x φ1 then
C(φ) = {φ} ∪ C(φ1)

A formula φ is called Existential-safe if every ψ ∈ C(φ) is a module or of the form ∀x ψ′.
A finite set of formulas Γ is Existential-safe if every φ ∈ Γ is Existential-safe.

M F C S 2 0 2 2

70:6

Generalized Bundled Fragments for FOML

Intuitively, C(φ) is the set of all subformulas of φ that are “to be evaluated” at the current
world. An Existential-safe formula φ does not need any witness from the current local domain
in order to make the formula true. The notions of components and existential-safeness will
play a role in the tableau-based decision procedure to be introduced below.

Before going into the specific tableau rules, we first explain the general method. A tableau
is a tree-like structure generated from a single formula α by repeatedly applying a few rules
with some auxiliary information as the root of the tree. Intuitively, a tableau for α is a
pseudo model which can be transformed into a real model of α under some simple consistency
conditions. We can then decide the satisfiability of a formula by trying to find a proper
tableau. As in [17], a tableau T in our setting is a tree structure such that each node is a
triple (w, Γ, σ) where w is a symbol or a finite sequence of symbols intended as the name of a
possible world in the real model, Γ is a finite set of FOML-formulas, and σ is an assignment
function for variables. Since we intend to use the set of variables as the domain in the
tableau-induced real model, σ is simply a partial identity function on Var, i.e., σ(x) = x for
all x ∈ Dom(σ) ⊆ Var, where the domain of σ, Dom(σ), is intended to be the local domain
of the real model. The intended meaning of the node (w, Γ, σ) is that all the formulas in Γ
are satisfied on w with the assignment σ, thus we also write (w : Γ, σ) for the triple.

A tableau rule specifies how the node in the premise of the rule is transformed to or
connected with one or more new nodes given by the conclusion of the rule. Applying the rules
can generate a tree-like structure, a tableau, which is saturated if every leaf node contains
only literals. For any formula α, we refer to a saturated tableau of α simply as a tableau of
α. Further, a saturated tableau is open if in every node (w : Γ, σ) of the tableau, Γ does not
contain both β and ¬β for any formula β.2

We call a formula clean if no variable occurs both bound and free in it and every use
of a quantifier quantifies a distinct variable. A finite set of formulas Γ is clean if V Γ, the
conjunction of all formulas in Γ, is clean. Note that every FOML-formula can be rewritten into
an equivalent clean formula. For instance, the formulas ∃x□P x∨∀x♢Qx and P x∧□∃xQx are
not clean, whereas ∃x□P x ∨ ∀y♢Qy and P x ∧ □∃yQy are their clean equivalents respectively.
Clean formulas help in handling the witnesses for existential formulas in the tableau in a
syntactic way.

Consider a finite set of formulas Γ that is clean. Suppose we want to expand Γ to
Γ ∪ {α1, . . . αk}, then even if each of αi is clean, it is possible that a bound variable of αi also
occurs in some φ ∈ Γ or another αj. To avoid this, first, we rewrite the bound variables in
each αi one by one by using the fresh variables that do not occur in Γ and other previously
rewritten αj.

Such a rewriting can be fixed by always using the first fresh variable in a fixed enumeration
of all the variables. When Γ and {α1, . . . αk} are clear from the context, we denote α∗
i to
be such a fixed rewriting of αi into a clean formula. It is not hard to see that the resulting
finite set Γ ∪ {α∗

1, . . . α∗

k} is clean.

3.1 Tableaux for LBF

The tableau rules for the LBF fragment are described in Fig. 1. The (∧) and (∨) rules are
standard, where we make a non-deterministic choice of one of the branches for (∨). The
rule (END) says that if we are left with only modules and there are no ♢ formulas, then
the branch does not need to be explored further. The (♢) rule creates one successor world
for every ♢ formula at the current node and includes all the □ formulas that need to be

2 Refer [17] for an illustration of a similar tableau construction.

M. Liu, A. Padmanabha, R. Ramanujam, and Y. Wang

70:7

w : φ1 ∨ φ2, Γ, σ
w : φ1, Γ, σ || w : φ2, Γ, σ

(∨)

w : φ1 ∧ φ2, Γ, σ
w : φ1, φ2, Γ, σ

(∧)

w : ∃xφ, Γ, σ
w : φ, Γ, σ′ (∃)
where σ′ = σ ∪ {(x, x)}

w : ∀yφ, Γ, σ
w : {φ∗[z/y] | z ∈ Dom(σ)}, Γ, σ

(∀)

where Γ is Existential-safe and every φ∗[z/y] is a clean rewriting of φ[z/y]
with respect to Γ ∪ {φ[z/y] | z ∈ Dom(σ)}

Given n ≥ 1: and m, s ≥ 0

Given m ≥ 1, s ≥ 0:

w : ♢φ1, . . . , ♢φn
□β1, . . . □βm

l1, · · · , ls, σ

⟨wvi : φi, {βj | j ∈ [1, m]}, σ⟩ for all i ∈ [1, n]

(♢)

w : □β1, . . . □βm, l1, . . . , ls, σ
w : l1, · · · , ls, σ

(END)

Figure 1 Tableau rules for LBF, here every li is a literal.

satisfied along with the ♢ formula and σ is inherited in the successor worlds to preserve the
increasing domain property. The (∃) rule picks x itself as the witness to satisfy ∃xφ and (∀)
rule expands the set of formulas to include a clean version of φ[z/y] for every variable z in
the current local domain.

Note that only the (♢) rule can change (the name of) the possible world, thus creating a
new successor. It simply extends the name w by new symbols vi for each successor. Therefore
there can be many nodes in the tableau sharing the same world name but such nodes form a
path. Given w we use tw to denote the last node sharing the first component w. Given a
node t = (w : Γ, σ) in a tableau, we use Dom(t) to denote the domain of σ.

Also, there is an implicit ordering on how the rules are applied: (♢) rule can be applied
at a node (w, Γ, σ) only if all formulas of Γ are modules and hence may be applied only
after the (∧, ∨, ∀, ∃) rules have been applied as many times as necessary at w. Similarly (∀)
rule can be applied only when Γ is Existential-safe which means that the (∃) rule cannot be
applied anymore at the current node.

▶ Proposition 8. For every tableau T and every node v = (w, Γ, σ) in T , if v is a leaf then
either Γ contains only literals or there is some rule that can be applied at v.

The proposition is true since the LBF ensures that if Γ is not Existential-safe and the
(∧, ∨, ♢, END) rules cannot be applied, then it has to be the case that there is some ∃xφ ∈ Γ,
for which we can apply the (∃) rule.

▶ Theorem 9. For any clean LBF formula θ, let σr be an identity mapping over FV(θ) ∪ {z}
where z does not occur in θ. There is an open tableau T with root (r : {θ}, σr) iff θ is
satisfiable in an increasing domain model.

Proof. First, we claim that the rules preserve the cleanliness of the formulas. To see this,
we verify that for every rule, if Γ in the antecedent of the rule is clean, then the Γ′ obtained
after the application of the rules is also clean. This is obvious for (∧), (∨), (♢) and (END)
rules. The (∃) rule preserves cleanliness because it frees variable x which is not bound by
any other quantifier in the antecedent. The (∀) rule preserves cleanliness by rewriting.

M F C S 2 0 2 2

70:8

Generalized Bundled Fragments for FOML

(⇒): Let T be an open tableau rooted at (r : {θ}, σr). Define a model M = (W, D, δ, R, ρ)

as follows:

W = {w | (w : Γ, σ) is a node in T }
D = Var
R = {(w, v) | v is of the form wv′ for some v′}
For every w ∈ W, define δ(w) = Dom(tw) where tw is the last node of w in T
For every w ∈ W and p ∈ P, define ρ(w, P ) = {x | P x ∈ Γ where tw = (w, Γ, σ)}

Clearly, M is an increasing domain model, and since z ∈ Dom(σr), there is no empty

local domain. As T is an open tableau, ρ is well-defined.

Claim. For every node (w : Γ, σ) in T and for every LBF formula φ, if φ ∈ Γ then

M, w, σ |= φ.

The claim is proved using a standard argument by induction on the height of the nodes
of T from the leaves to the root (details in [13]). Thus, from the claim it follows that
M, r, σr |= θ since the label of the root of T is (r : {θ}, σr).

(⇐) From Proposition 8 it follows that we can always apply some rule until every leaf
node (w : Γ, σ) is such that Γ contains only literals. Thus every (partial) tableau can be
extended to a saturated tableau. To prove that such a tableau is open, it suffices to show
◀
that all rules preserve satisfiability (details in [13]).

Note that the depth of the tableau is linear in the size of the formula. However, as we
have to rewrite formulas using new variables when applying (∀) rule, the size of the domain
is exponential in the size of the formula. Hence, the tableau procedure can be implemented
in ExpSpace.

▶ Corollary 10. LBF is decidable in ExpSpace.

4

The (Un)decidability Border

Note that the fragment LBF cannot express formulas of the form ∀x∃y□ α and also
∀x□∀y□∀zα. There are many combinations of the bundled fragments that can express
thesse formulas (like ∃□ + □∀ and ∀□ + ∃□ + □∃ fragments). In fact, we can prove that
a bundled fragment is undecidable if we can assert both ∀x∃y□α and ∀x□∀y□∀z α in the
fragment.

To prove this, we can use tiling encoding where ∀x∃y□α can be used to assert that every
“grid point” x has a horizontal/vertical successor y. In this case, it is important that both
quantifiers are applicable over the same local domain and □α in ∀x∃y□α ensures that the
witness y acts uniformly across all the descendants. The second formula ∀x□∀y□∀z α is
used to verify the “diagonal property” of the grid. In the companion technical report of this
paper [13] we prove these results formally.

Also, note that there are fragments like ∃□ + □∃ where ∀x∃y□α is expressible but not
∀x□∀y□∀z α. In these cases, we can prove that such fragments do not have a finite model
property. This is also proved in the companion technical report [13] where we show that this
fragment gives a formula that can induce a linear order on the local domain of some world in
the model and assert that this linear order does not have a maximal element.

This leaves us with the fragments that cannot express ∀x∃y□α formulas and LBF is one
such fragment which we proved to be decidable. The fragments ∀□ + ∃□ and □∀ + □∃ also
fall in this category and since they are subfragments of LBF, decidability follows. So we only
need to consider the fragment ∀□ + ∃□ + □∀ to complete the terrain (cf. Table. 1).

M. Liu, A. Padmanabha, R. Ramanujam, and Y. Wang

70:9

5

The ∀□ + □∀ + □∃ Fragment

In this fragment, we are allowed to express ∀x□α, □∀xα and □∃xα and their duals. Note
(cid:17)
that this fragment is not closed under subformulas. For instance, φ := ∀x

∃y♢α ∨ ∀z□β

(cid:16)

is a subformula of φ′
. But φ′ is in the fragment and φ is not in
the fragment. We say that φ is a subformula of ∀□ + □∀ + □∃ if there is some formula
φ′ ∈ ∀□ + □∀ + □∃ such that φ is a subformula of φ′.

∃y♢α ∨ ∀z□β

:= ♢∀x

(cid:16)

(cid:17)

Note that even though we cannot express formulas of the form ∀x∃y□φ in the fragment,
∀x∃y♢φ is still allowed. For instance, the formula ♢∀x
is in the fragment. Thus, we
can have ∀x∃y♢φ but not ∀x∃y□φ. Intuitively this means that the different witnesses y for
each x can work on different successor worlds. The fragment cannot enforce the interaction
between x and y at all successors. This property can be used to prove that we can reuse the
witnesses by creating new successor subtrees as required.

∃y♢α

(cid:17)

(cid:16)

To get the decidability for ∀□ + □∀ + □∃ fragment, the main idea is to prove that the
formulas of the form ∀x∃y♢φ can be satisfied by picking some boundedly many witnesses
y that will work for all x. This is the same as proving that if ∀x∃y♢φ is satisfiable then
∃y1, . . . ∃yl∀x(cid:0) W ♢φ[y/yi](cid:1) is satisfiable (where l is bounded). We illustrate the proof idea
with an example.

▶ Example 11. Consider the formula α := ∀x
of the fragment. Let T , r |= α where T is a tree model rooted at r. Now we will modify T
□¬P xx ∧
to obtain M which is also a tree model rooted at r such that M, r |= ∃y1∃y2∀x
(cid:0) ♢P xy1 ∨ ♢P xy2

□¬P xx ∧ ∃y♢P xy

which is a subformula

(cid:1)(cid:17)

(cid:16)

.

(cid:16)

(cid:17)

The model M is obtained by extending T in the following way. Let δT (r) = Dr. To
obtain M, first we extend the local domain of r by adding a fresh element a. The idea is
that for every d ∈ Dr (when assigned to x) we will ensure that the new element a can be
picked as the y-witness. To achieve this, we do the following: For every d ∈ Dr let d′ ∈ Dr
and (r, sd) ∈ RT such that T , sd |= P dd′. Let T d be the subtree of T rooted at sd. We will
create a new copy of T d and call its root ud. Now, in the new subtree rooted at ud, we make
the new element a “behave” like d′ and we add an edge from r to ud. So, in particular, M
will have (r, ud) ∈ RM such that M, ud |= P da. Since we do this construction for every
d ∈ Dr we obtain that for all d ∈ Dr we have M, r |= ♢P da.

Now note that while evaluating α at (M, r) the ∀x quantification will now also apply
to a (since a is added to the local domain at r in M). But then, we cannot use a itself as
the witness for a since we also need to ensure that M, r |= ∀x□¬P xx. Hence we will add
another element b that acts as a witness for a. Further, b also needs a witness. But now we
can choose a to be the witness for b since that does not violate the formula ∀x□¬P xx.

So to complete the construction, we pick some arbitrary d ∈ Dr for which we have some
d′ ∈ Dr and (r, sd) ∈ RT such that T , sd |= P dd′. We create two copies of T d (subtree
rooted at sd) and call their roots as vd and wd respectively. In the subtree rooted at vd
we ensure that a and b “behave” like d, d′ respectively and in the subtree rooted at wd we
ensure that a and b “behave” like d′, d respectively. In particular, we have M, vd |= P ab and
M, wd |= P ba. Finally we add edges from r to vd and from r to wd in M.

Thus, we have: δM(r) = δT (r) ∪ {a, b} and M, r |= ∃y1∃y2∀x

(cid:16)

□¬P xx ∧ (cid:0) ♢P xy1 ∨

(cid:1)(cid:17)

♢P xy2
y2 to a and b respectively.

. With the above construction, this assertion can be verified by assigning y1 and

M F C S 2 0 2 2

70:10 Generalized Bundled Fragments for FOML

Note that in principle, it is possible for an ∃ quantified formula to occur in the scope
of a ∀ quantifier as a boolean combination with other ∃ quantified formulas and modules.
Moreover, these additional formulas can assert some “type” information that may force us to
pick additional witnesses. For example, if the formula is

h(cid:16)

∀x

□(¬P xx∧Rx)∨□(¬P xx∧¬Rx)

(cid:17)

∧∃y♢(cid:0)Rx → (P xy ∧¬Ry) ∧ ¬Rx → (P xy ∧Ry)(cid:1)i

then we need two initial y-witnesses a1, a2 where one is used for witness whose “type” is
□(¬P yy ∧ Ry) and other for witness whose “type” is □(¬P yy ∧ ¬Ry) and we also need
the corresponding additional witnesses b1, b2. In general, the formula can force us to pick
witnesses of a particular “1-type” which means we might need exponentially many witnesses.
Thus, we need to replace one ∃ inside the scope of ∀ by 2l many ∃ quantifiers outside the
scope of ∀ where l is bounded exponentially in the size of the given formulas. We now prove
this formally.

For any formula φ if α ∈ C(φ) we denote this by φ[α]. This means that α does not occur
inside the scope of any modality in φ. Further, for every α ∈ C(φ) and a formula β, we
denote φ[β/α] obtained by rewriting φ where every occurrence of α in φ is replaced by β.
In particular, we are interested in the case where α is of the form ∃y♢ψ. Thus we always
consider φ[∃y♢ψ].

For every l ≥ 0 if y = y1, y′
(cid:0)♢ψ[yi/y] ∨ ♢ψ[y′

l are fresh variables, we denote y♢ψ to be the formula
i/y](cid:1) which is a big disjunction where each disjunct replaces y in ψ with

1 . . . yl, y′

W
i≤l
one of yi or y′

i. Further, we denote φ[y♢ψ/∃y♢ψ] as simply φ[y♢ψ].
(cid:16)

(cid:17)

For instance, for the formula φ :=

P x ∨ ∃y♢Qxy

where ψ := ∃y♢Qxy, for l = 2

and y = y1, y′
♢Qxy2 ∨ ♢Qxy′
2

1, y2, y′
(cid:1)(cid:17)

.

2 being fresh variables, φ[y♢ψ] is given by:

(cid:16)

P x ∨ (cid:0)♢Qxy1 ∨ ♢Qxy′

1 ∨

The size of a formula, denoted by |φ|, is the number of symbols occurring in φ and for a

finite set of formulas Γ, let |Γ| = P
φ∈Γ

|φ|.

▶ Lemma 12. Let Γ′ be a clean finite set of formulas such that every α ∈ Γ is a subformula
of ∀□ + □∀ + □∃ where Γ′ = Γ ∪ {∀xφ[∃y♢ψ]}. If V Γ ∧ ∀xφ[∃y♢ψ] is satisfiable then
there exists l ≤ 2|Γ′| such that V Γ ∧ ∃y1∃y′
l ∀x φ[y♢ψ] is satisfiable, where
1∃y2∃y′
y = y1, y′

2 . . . ∃yl∃y′

l are fresh variables.

1, . . . yl, y′

Note that the ∃y quantifier is pulled outside the scope of the ∀x quantifier and replaced
l. Consequently ♢ ψ is replaced with

2 . . . yl, y′

with a bounded number of witnesses y1, y′
a disjunction each replacing y with one of yi or y′

i for every i ≤ l.

1, y′

2, y′

To prove the lemma first we formally define the tree editing operation described in the
example. Given a tree model T rooted at r, let d ̸∈ DT . To add the new domain element d
to a local domain of r, we also need to specify the “type” of the new element d at r and its
descendants. Towards this, we pick some domain element c that is already present in δ(r)
and assign the type of d to the type of c at every world.

▶ Definition 13. Given a tree model T = (W, D, R, δ, ρ) rooted at r, let d ̸∈ D and c ∈ δ(r).
Define the operation of “adding d to δ(r) by mimicking c”, denoted by Td7→c = (W, D′, R, δ′, ρ′)
where:

D′ = D ∪ {d}
for all w ∈ W we have δ′(w) = δ(w) ∪ {d}

M. Liu, A. Padmanabha, R. Ramanujam, and Y. Wang

70:11

For every w ∈ W and predicate P define
ρ′(w, P ) = {e′ | there is some e ∈ ρ(w, P ) and e′ is obtained from e by replacing zero or
more occurrences of c in e by d}.

Suppose that we want to extend the domain with d = d1 · · · dn which are fresh. Let
ω : d 7→ D′ where D′ ⊆ δT (r) and we want each di to mimic ω(di). Then we denote Tω to be
the tree obtained by

(cid:16)(cid:0)Td17→ω(d1)

(cid:17)

(cid:1)

.

d27→ω(d2)...

dn7→ω(dn)

▶ Proposition 14. Let T = (W, D, R, δ, ρ) be a tree model rooted at r with Td7→c being an
extended tree where d ̸∈ D and c ∈ δ(r). Then for all interpretations σ and for all FOML
formulas φ and for all w ∈ W we have:
T , w, σ[x7→c] |= φ iff Td7→c, w, σ[x7→c] |= φ iff Td7→c, w, σ[x7→d] |= φ.

The proposition holds since there is no equality in the syntax and at every world in the
extended model, the new element d “behaves” like c and the old elements “behave” like
themselves (details in [13]). Now we are ready to prove Lemma 12.

Proof of Lemma 12. Let T be a tree model rooted at r such that T , r, σ |= V Γ∧∀xφ[∃y♢ψ].

For every domain element a ∈ δT (r) define:

Π(r, a) =

[

∀x′α∈Γ′

{λ | λ ∈ C(α) and T, r, σ[x′7→a] |= λ}

Note that Π(r, a) formalizes the notion of “type” of a at the world r. This includes
the information of all subformulas that are true at the current world, when a universal
variable is instantiated with a. Also, since the size of |C(α)| is at most the size of Γ′,
the set Π(r) = {Π(r, a) | a ∈ δT (r)} has size |Π(r)| = l where l ≤ 2|Γ′|. Enumerate
Π(r) = {Λ1, . . . Λl} and for every i ≤ l pick ai ∈ δT (r) such that Π(r, ai) = Λi. Now let
d = d1, d′
l be fresh domain elements and let ω : d 7→ {a1, a2, . . . al} where for
all i ≤ l we have ω(di) = ω(d′
i) = ai. We define the required model M = (W ′, D′, R′, δ′, ρ′)
as follows:

2, . . . dl, d′

1, d2, d′

Let M0 = Tω be the new tree model rooted at r obtained by adding d1, d′

1, . . . , dl, d′
i mimics ai. Now M is obtained by extending M0 as follows:

δT (r) where each di and d′

For every c ∈ δ(r) such that T , r, [x 7→ c] |= ∃y♢ψ we pick c′ ∈ δT (r) and r → sc be such

l to

0 = T c
j) = c′. Let uc be the root of T c

that T , sc, [xy 7→ cc′] |= ψ. Let T c be the sub-tree of T rooted at sc and Π(r, c′) = Λj.
Create a new subtree T c
ω′(dj) = ω′(d′
Further, for every i ≤ l if T , r, σ[x7→ai] |= ∃y♢ψ then let b ∈ δT (r) and r → si ∈ RT be such
that T , si, σ[xy7→aib] |= ψ. Let Π(r, b) = Λj. Then create T i
where ω1
and ω2 are defined as follows:

ω′ where for all h ̸= j we have ω′(dh) = ω′(d′
0 . Add an edge from r to uc in M.

h) = ah and

2 = T i
ω2

1 = T i
ω1

and T i

h) = ω2(dh) = ω2(d′

h) = ah

For all h ̸= j, ω1(dh) = ω1(d′
ω1(dj) = aj and ω1(d′
ω2(dj) = b and ω2(d′

j) = b
j) = aj
2 respectively. Add the edges from r to vi and from r
Let vi and wi be the root of T i
to wi in M. The two copies of subtrees are intended to provide witnesses for ∃y♢ψ for dj
and d′
j respectively. We need the two copies to ensure that ω1 and ω2 are well defined in the
case when i = j and aj ̸= b.

1 and T i

We now explain the idea behind the construction. Note that T c

0 rooted at uc is created
for every c ∈ δT (r) such that T , r, σ[x7→c] |= ∃y♢ψ. If c′ is the picked witness for c with
(r, sc) ∈ RT such that T , sc, σ[xy7→cc′] |= ψ and Π(r, c′) = Λj then by construction, T c
0 is

M F C S 2 0 2 2

70:12 Generalized Bundled Fragments for FOML

rooted uc where dj mimics c′ in the subtree rooted at uc. All these together indicate that we
can use dj and the subtree rooted at uc in M to verify that M, uc, σ[xy7→cdj ] |= ψ. Also note
that for all h ̸= j the fresh elements dh and d′
0 (i.e, we have not
added any extra “types”).

h mimic ah in the subtree T c

Further, we want the type of di and d′

i at r in M to mimic the type of ai at r in T . All
type information is taken care of in M0 where both di and d′
i mimic ai except the formula
∃y♢ψ. So if T , r, σ[x7→ai] |= ∃y♢ψ then we need a witness to verify M, r, σ[x7→di] |= ∃y♢ψ
i] |= ∃y♢ψ. If the witness for y for ai is b and Π(r, b) = Λj then we want d′
and M, r, σ[x7→d′
j
to be the witness for di and dj to be the witness for d′
i.

Consequently if si is the world such that a → si ∈ RT and T , si, [xy 7→ aib] |= ψ then we
2 . By construction, in
i mimics ai and
1 ) and pick

create two new copies of subtree T i rooted at si and call it T i
particular, the new element di mimics ai and d′
j mimics b in T i
dj mimics b in T i
dj to be the witness for d′

j to be the witness for di (and consider T i

1 and T i
1 . Similarly d′

2 . Thus, we can pick d′

i (and consider T i

2 ).

Also, it is important to note that for every r → v ∈ RM , if di mimics c and d′

i mimics c′
at v then we will always have Π(r, c) = Π(r, c′) = Λi = Π(r, ai). Now it can be verified that
M, r, σ |= V Γ ∧ ∃y1∃y′

l ∀xφ[y♢ψ].

1 . . . ∃yl∃y′
The details are provided in [13].

◀

▶ Corollary 15. Let Γ′ be a clean finite set of formulas such that every α ∈ Γ is a subformula
of ∀□ + □∀ + □∃ where Γ′ = Γ ∪ {∀xφ[∃y♢ψ]}. If V Γ ∧ ∀xφ[∃y♢ψ] is satisfiable then
V Γ ∧ ∃y1∃y′
1, . . . yl, y′
1∃y2∃y′
l
are fresh variables.

l ∀x φ[y♢ψ] is satisfiable, where l = 2|Γ′| and y = y1, y′

2 . . . ∃yl∃y′

To see why the corollary is true, by Lemma 12 we get some l ≤ 2|Γ′|, and we can pad
sufficiently many dummy variables to get a strict equality. This gives us a useful tableau
rule which we call (∀∃♢) rule for ∀□ + □∀ + □∃ fragment, described in Fig. 2. The full
tableau rules for ∀□ + □∀ + □∃ is given by the tableau rules of LBF (Fig. 1) along with the
(∀∃♢)-rule.

w : ∀x φ[∃y♢ψ], Γ, σ
w : ∀x φ[y♢ψ], Γ, σ′ (∀∃♢)

where l = 2|Γ|+|φ| and y = y1, y′
are fresh variables and σ′ = σ ∪ {(yi, yi) , (y′

1, . . . yl, y′
l
i, y′
i) | i ≤ l}

Figure 2 (The ∀∃♢) rule for ∀□ + □∀ + □∃ fragment.

▶ Theorem 16. For any clean ∀□ + □∀ + □∃ formula θ, let σr be an identity mapping over
FV(θ) ∪ {z} where z does not occur in θ. There is an open tableau with (r : {θ}, σr) as the
root iff θ is satisfiable in an increasing domain model.

The proof follows along the lines of Theorem 9. The only interesting part of the proof is
to show that the (∀∃♢) rule preserves satisfiability and this is by Lemma 12(details in [13]).
Note that at if we start with a formula of length n then the application of (∀∃♢) rule will
blow up the formula to size 2n. So we have a tableau procedure that can be implemented as
an algorithm in ExpSpace.

▶ Corollary 17. The fragment ∀□ + □∀ + □∃ is decidable in ExpSpace.

M. Liu, A. Padmanabha, R. Ramanujam, and Y. Wang

70:13

6

Conclusion

In this paper, we have studied the decidability of bundled fragments of FOML, where we
have no restrictions on the use of variables or arity of relations. Specifically, we proved the
decidability of the loosely bundled fragment LBF and the ∀□ + □∀ + □∃ fragment. The
decidability of these fragments hinges on the observation that ∀x∃y□α is not expressible. A
NexpTime lower bound follows for ∀□ + ∃□ and □∀ + □∃ (via encoding the corresponding
version of the tiling problem [13]), which implies the same lower bound for LBF and ∀□ +
□∀ + □∃. There is a significant gap between the upper and lower complexity bounds and we
need sharper technical tools for investigating lower bounds for bundled fragments.

Note that the quantifier prefix in LBF is of the form ∃∗∀∗ and hence any extension of this
quantifier prefix or extending LBF with negation closure will result in a fragment that will be
able to express ∀x∃y□ α (and hence will not have the finite model property, [13]). In this
sense, LBF is the largest fragment in which ∀x∃y□α is not (syntactically) expressible. For
the fragment ∀□ + □∀ + □∃ we introduced a technique to pull out ∃ quantifiers outside the
immediate scope of ∀ and obtain a finite model property. This technique may be useful in
studying other fragments of first-order modal logic.

The results in the paper, along with those in [13], provide a trichotomy classification of
combinations of bundled operators over increasing domain models (Table 1). The fragments
in which we can express both ∀x∃y□α and ∀x□∀y□∀zβ are undecidable, fragments in which
we can express the former but not the latter lack finite model property (but decidability is
open) and fragments where we cannot express the former are decidable. Similar trichotomy
can also be proved for satisfiability over constant domain models [13].

We have considered only the “pure” fragments, without constants, function symbols,
or equality. The addition of constants is by itself simple, but equality complicates things
considerably. Since equality is extensively used in specifications, mapping fragments with
equality is an important direction. The study of bundles over models with various frame
conditions is also relevant for applications. Unfortunately, while it is clear that equivalence
frames lead to undecidability [17], even with transitive frames the situation is unclear.
Obtaining good decidable fragments over linear frames is an important challenge.

In the context of verification of infinite-state systems, we are often more interested in the
model checking problem than in satisfiability. If the domain is finite, the problem is no
different from model checking of first-order modal logic. However, we are usually interested
in the specification being checked against a finitely specified (potentially infinite) model, e.g.,
when the domain elements form a regular infinite set. This is a direction to be pursued in
the context of bundled fragments.

We have presented tableau-based decision procedures that are easily implementable, but

inference systems for reasoning in these logics require further study.

References

2

1 Hajnal Andréka, István Németi, and Johan van Benthem. Modal languages and bounded frag-
ments of predicate logic. J. Philos. Log., 27(3):217–274, 1998. doi:10.1023/A:1004275029985.
Francesco Belardinelli and Alessio Lomuscio. Quantified epistemic logics for reasoning about
knowledge in multi-agent systems. Artif. Intell., 173(9-10):982–1013, 2009. doi:10.1016/j.
artint.2009.02.003.
Francesco Belardinelli and Alessio Lomuscio. Interactions between knowledge and time in a
first-order logic for multi-agent systems: Completeness results. J. Artif. Intell. Res., 45:1–45,
2012. doi:10.1613/jair.3547.

3

M F C S 2 0 2 2

70:14 Generalized Bundled Fragments for FOML

4

5

Egon Börger, Erich Grädel, and Yuri Gurevich. The classical decision problem. Springer
Science & Business Media, 2001.
Torben Braüner and Silvio Ghilardi. First-order modal logic. In P. Blackburn, J. van Benthem,
and F. Wolter, editors, Handbook of Modal Logic, pages 549–620. Elsevier, 2007.

8

6 Clare Dixon, Michael Fisher, Boris Konev, and Alexei Lisitsa. Practical first-order temporal
reasoning. In Proceedings of TIME 2008, pages 156–163, 2008. doi:10.1109/TIME.2008.15.
7 Harald Ganzinger, Christoph Meyer, and Margus Veanes. The two-variable guarded fragment
with transitive relations. In Proceedings of LICS ‘99, pages 24–34, 1999. doi:10.1109/LICS.
1999.782582.
Ian Hodkinson, Frank Wolter, and Michael Zakharyaschev. Decidable fragment of first-order
temporal logics. Ann. Pure Appl. Log., 106(1-3):85–134, 2000. doi:10.1016/S0168-0072(00)
00018-X.
Ian Hodkinson, Frank Wolter, and Michael Zakharyaschev. Monodic fragments of first-order
temporal logics: 2000-2001 A.D. In Robert Nieuwenhuis and Andrei Voronkov, editors, Proceed-
ings of LPAR ’01, volume 2250, pages 1–23. Springer, 2001. doi:10.1007/3-540-45653-8_1.
Ian Hodkinson, Frank Wolter, and Michael Zakharyaschev. Decidable and undecidable
fragments of first-order branching temporal logics. In Proceedings LICS 2002, pages 393–402,
2002. doi:10.1109/LICS.2002.1029847.

9

10

11 G. E. Hughes and M. J. Cresswell. A New Introduction to Modal Logic. Routledge, 1996.
12 Mo Liu. On the decision problems of some bundled fragments of first-order modal logic.
Master’s thesis, Peking University, 2019. URL: https://arxiv.org/abs/2201.02336.
13 Mo Liu, Anantha Padmanabha, Ramaswamy Ramanujam, and Yanjing Wang. Are bundles

good deals for FOML? CoRR, abs/2202.01581, 2022. arXiv:2202.01581.

14 Anantha Padmanabha, R Ramanujam, and Yanjing Wang. Bundled Fragments of First-Order
Modal Logic: (Un)Decidability. In Proceedings of FSTTCS 2018, volume 122, pages 43:1–43:20,
2018. doi:10.4230/LIPIcs.FSTTCS.2018.43.

15 Mikhail N. Rybakov and Dmitry Shkatov. Undecidability of first-order modal and intuitionistic
logics with two variables and one monadic predicate letter. Stud Logica, 107(4):695–717, 2019.
doi:10.1007/s11225-018-9815-7.

16 Moshe Y Vardi. Why is modal logic so robustly decidable? Technical report, Rice University,

1997.

17 Yanjing Wang. A new modal framework for epistemic logic. In Proceedings of TARK 2017,

pages 515–534, 2017. doi:10.4204/EPTCS.251.38.

18 Yanjing Wang. Beyond Knowing That: A New Generation of Epistemic Logics. In Outstanding
Contributions to Logic, volume 12, pages 499–533. Springer Nature, 2018. doi:10.1007/
978-3-319-62864-6_21.
Frank Wolter and Michael Zakharyaschev. Decidable fragments of first-order modal logics. J.
Symb. Log., 66(3):1415–1438, 2001. URL: http://www.jstor.org/stable/2695115.

19

