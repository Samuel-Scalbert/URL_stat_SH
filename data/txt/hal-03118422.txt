An Analytical Study of Large SPARQL Query Logs
Angela Bonifati, Wim Martens, Thomas Timm

To cite this version:

Angela Bonifati, Wim Martens, Thomas Timm. An Analytical Study of Large SPARQL Query Logs.
The VLDB Journal, 2020, 29 (2-3), pp.655-679. ￿10.1007/s00778-019-00558-9￿. ￿hal-03118422￿

HAL Id: hal-03118422

https://hal.science/hal-03118422

Submitted on 22 Jan 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Noname manuscript No.
(will be inserted by the editor)

An Analytical Study of Large SPARQL Query Logs

Angela Bonifati · Wim Martens · Thomas Timm

the date of receipt and acceptance should be inserted later

Abstract With the adoption of RDF as the data model
for Linked Data and the Semantic Web, query speciﬁ-
cation from end-users has become more and more com-
mon in SPARQL endpoints. In this paper, we conduct
an in-depth analytical study of the queries formulated
by end-users and harvested from large and up-to-date
structured query logs from a wide variety of RDF data
sources. As opposed to previous studies, ours is the
ﬁrst assessment on a voluminous query corpus, span-
ning over several years and covering many represen-
tative SPARQL endpoints. Apart from the syntactical
structure of the queries, that exhibits already interest-
ing results on this generalized corpus, we drill deeper in
the structural characteristics related to the graph and
hypergraph representation of queries.

We outline the most common shapes of queries when
visually displayed as undirected graphs, characterize
their tree width, length of their cycles, maximal de-
gree of nodes, and more. For queries that cannot be
adequately represented as graphs, we investigate their
hypergraphs and hypertree width. Moreover, we ana-
lyze the evolution of queries over time, by introduc-
ing the novel concept of a streak, i.e., a sequence of
queries that appear as subsequent modiﬁcations of a

A. Bonifati
Lyon 1 University
Lyon, France

W. Martens
University of Bayreuth
Bayreuth, Germany

T. Timm
University of Bayreuth
Bayreuth, Germany

seed query. Our study oﬀers several fresh insights on
the already rich query features of real SPARQL queries
formulated by real users, and brings us to draw a num-
ber of conclusions and pinpoint future directions for
SPARQL query evaluation, query optimization, tuning,
and benchmarking.

1 Introduction

As more and more data is exposed in RDF format, we
are witnessing a compelling need from end-users to for-
mulate more or less sophisticated queries on top of this
data. SPARQL endpoints are increasingly used to har-
vest query results from available RDF data repositories.
But how do these end-user queries look like? As opposed
to RDF data, which can be easily obtained under the
form of dumps (DBpedia and Wikidata dumps [45,46,
51]), query logs are often inaccessible, yet hidden trea-
sures to understand the actual usage of these data. In
this paper, we investigate a large corpus of query logs
from diﬀerent SPARQL endpoints, which spans over
several years (2009–2017). In comparison to previous
studies on real SPARQL queries [3,21, 36, 41,42], which
typically1 investigated query logs of a single source,
we consider a multi-source query corpus that is two
orders of magnitude larger. Furthermore, our analysis
goes signiﬁcantly deeper. In particular, we are the ﬁrst
to do a large-scale analysis on the topology of queries,
which has seen signiﬁcant theoretical interest in the
last decades (e.g., [14,18,20]) and is now being used
for state-of-the-art structural decomposition methods

1 The exception is [21], where logs from the Linked
SPARQL Queries (LSQ) dataset were studied, combining
data from four sources (from 2010 and 2014) that we also
consider.

for query optimization [1,2,26]. As a consequence, ours
is the ﬁrst analytical study on real (and most recent)
SPARQL queries from a variety of domains reﬂecting
the recent advances in theoretical and system-oriented
studies of query evaluation.

Our paper makes the following contributions. Apart
from classical measures of syntactic properties of the in-
vestigated queries, such as their keywords, their number
of triples, and operator distributions, which we apply
to our new corpus, we also mine the usage of projec-
tion in queries and subqueries in the various datasets.
Projection indeed is the cause of increased complexity
(from Ptime to NP-Complete) of the following central
decision problem in query evaluation [13,8,30]: Given
a conjunctive query Q, a database D, and a candidate
answer a, is a an answer of Q on D?

We then proceed by considering queries under their
graph and hypergraph structures. Such structural as-
pects of queries have been investigated in the database
theory community for over two decades [18] since they
can indicate when queries can be evaluated eﬃciently.
Recently, several studies on new join algorithms lever-
age the hypergraph structure of queries in the con-
texts of relational and RDF query processing [1, 26].
Theoretical research in this area traditionally focused
on conjunctive queries (CQs). For CQs, we know that
tree-likeness of their structure leads to polynomial-time
query evaluation [18]. For larger classes of queries, the
topology of the graph of a query is much less informa-
tive. For instance, if we additionally allow SPARQL’s
Opt operator, evaluation can be NP-complete even if
the structure is a tree [8]. For this reason, we focus
our structural study on CQ-like queries.2 We develop a
shape classiﬁer for such queries and identify their most
occurring shapes. Interestingly enough, these queries
have quite regular shapes. The overwhelming major-
ity of the queries is acyclic (i.e., tree- or forest-shaped).
We discovered that the cyclic queries mostly consist of
a central node with simple, small attachments (which
we call ﬂower ). In terms of tree- and hypertreewidth,
we discovered that the cyclic queries have width two,
up to a few exceptions with width three.

At this point we should make a note about interpre-
tation of our results. Even though almost all CQ-like
queries have (hyper-)treewidth one, we do not want to
claim that queries of larger treewidth are not important
in practice. The overwhelming majority of the queries
we see in the logs are very small and simple, which
we believe may be typical for SPARQL endpoint logs.
For instance, the majority of the queries in our logs

only use one triple. More precisely, this holds for over
52% of the valid queries and for over 58% of the unique
valid queries. One of our data sets, Wikidata17 is not a
SPARQL endpoint log and we see throughout the paper
that it has completely diﬀerent characteristics.

In order to gauge the performances of cyclic and
acyclic queries from a practical viewpoint, we have run
a comparative analysis of chain and cycle queries syn-
thetically generated with an available graph and query
workload generator [4]. This experiment showed diﬀer-
ent behaviors of SPARQL query engines, such as Blaze-
graph and PostgreSQL with query workloads of CQs of
increasing sizes (intended as number of conjuncts). It
also lets us grasp a tangible diﬀerence between chain
and cycle queries in either query engine, this diﬀerence
being more pronounced for PostgreSQL. We may inter-
pret this result as a lack of maturity of practical query
engines for cyclic queries, thus motivating the need of
speciﬁc query optimization techniques for such queries
as in [1,26].

Finally, we deal with the problem of identifying se-
quences of similar queries in the query logs. These queries
are then classiﬁed as gradual modiﬁcations of a seed
query, possibly by the same user. We measure the length
of such streaks in three log ﬁles from DBpedia. We con-
clude our study with insights on the impact of our ana-
lytical study of large SPARQL query logs on query eval-
uation, query optimization, tuning, and benchmarking.
This paper extends its conference version [11] as fol-

lows:

(1) We augment our corpus with 169M queries from
the DBpedia17 dataset, which was not considered
before and let us almost double the size of our total
valid queries.

(2) We perform all our analyses twice: once on the set
of all valid and once on the set of all unique valid
queries. The conference version only considered the
unique valid queries. We note that the valid and
unique valid logs give diﬀerent insights about the
data, which are complementary. The valid set gives
an idea about the diﬀerent types of queries in the
logs and the unique valid set gives a better view
on the queries and the workload that the SPARQL
endpoint actually receives.3

(3) We extend our study to the Construct clause apart
from Select and Ask queries considered in [11]. This
means that the present study includes all types of
SPARQL queries with a well-deﬁned semantics. We
also consider the Values keyword in the queries, be-
cause it is more frequent in our new corpus. The

2 We consider extensions with Filter, Opt, and Values, but
only in a way for which we know that tree-likeness of the query
graph ensures the existence of eﬃcient evaluation algorithms.

3 For instance, as can be seen immediately in Figure 1, the
DBpedia endpoint receives many more large queries than the
unique valid logs lead us to suspect.

addition of Values leads to additional insights, such
as a signiﬁcant increase of cyclic queries in Table 7.
(4) On top of investigating well-designedness of queries
(introduced by Perez et al. [40]), we also investi-
gate weak well-designedness, a notion introduced
by Kaminski and Kostylev [27], which is important
because it also identiﬁes a fragment of queries us-
ing And, Opt, and Filter that can be evaluated more
eﬃciently than in the general case.

(5) We perform our shape analysis once for the graphs
of queries with constants and once for the graphs
without constants (i.e., only the variables). We be-
lieve that the shapes of queries with constants can
be interesting for practitioners working on query
evaluation and optimization. The shapes of queries
without constants are usually considered in theoret-
ical research on query evaluation, i.e., the treewidth
and hypertreewidth of queries is usually only con-
sidered for the graph of the queries containing only
the variables.

(6) We add more tests to the shape analysis, which give
researchers a much more precise idea of the shape of
queries. For instance, we investigate speciﬁc mea-
sures on the characteristics of the most common
shapes, such as the longest path, the size of the
maximal degree vertex, the number of high degree
vertices and for cyclic queries the cycle lengths.
(7) We extend the hypergraph analysis with an anal-
ysis of free-connex acyclicity. This measure is very
important in theory and practice, since it charac-
terizes the conjunctive queries for which eﬃcient al-
gorithms exist for enumerating their output [6, 24]
(under standard complexity theory assumptions).
(8) We analyse the number of tree pattern queries in
the query logs. Tree pattern queries or twig queries
were heavily researched in the context of XML query
languages and, due to their modal nature, can also
be used for querying graphs [15,31]. We discover
that they are quite prominent in the logs.

(9) Due to the additional queries, we obtain 404,721
property paths from unique queries (compared to
247,404 in [11]). Still, we manage to completely
classify all these property paths in 35 types of ex-
pressions. (We only needed 21 types of expressions
in [11].) Since property paths are a challenging issue
in SPARQL queries and graph database queries in
general [10], we believe this data to be very useful
for developers of graph database engines.

have mainly investigated statistical features of the queries,
such as occurrences of triple patterns, types of queries,
or query fragments [3,21,36,42]. The only early study
that investigated the relationship between structural
features of practical queries and query evaluation com-
plexity has been presented in [41]. However, they fo-
cus on a limited corpus (3M queries from DBpedia
2010) and in that sense their ﬁndings cannot be general-
ized. Our work moves onward by precisely characteriz-
ing the occurrences of conjunctive and non-conjunctive
patterns under the latest complexity results, by per-
forming an accurate shape analysis of the queries under
their (hyper)graph representation and introducing the
evolution of queries over time. USEWOD and DBpedia
datasets have also been considered in [3]. It takes into
account the log ﬁles from DBpedia and SWDF reach-
ing a total size of 3M. The work mainly investigates
the number of triples and joins in the queries. Based
on the observation of [39] that SPARQL graph pat-
terns are typically chain- or star-shaped, they also look
at their occurrences. They found very scarce chains and
high coverage of almost-star-shaped graph patterns, but
they do not characterize the latter. To the best of our
knowledge, we are the ﬁrst to carry out a comprehen-
sive shape analysis on such a large and diverse corpus
of SPARQL queries.

A query analysis and clustering of DBpedia SPARQL
queries has been performed in [37] in order to build a
set of prototypical benchmarking queries. Query logs
have been inspected in a user study in [23] to under-
stand whether facts that are queried together provide
intra-fact relatedness in the Linked Open Data graph.
The objectives of both papers are diﬀerent from the one
pursued in our work.

Large collections of Wikidata queries have been an-
alyzed recently in [32,9], which focused on basic char-
acteristics of queries related to their usage in the Wiki-
data query service and spanning from SPARQL fea-
ture prevalence and correlation to annotations and lan-
guage distributions. They also do a classiﬁcation of the
queries in their corpus into robotic and organic, which
would not be possible in our case since our logs lacks
the information about browser- and machine-generated
traﬃc. However, our analysis signiﬁcantly diﬀers from
theirs since they do not study in-depth characteristics
of the queries reﬂecting complexity classes, involving
query shapes and property paths, along with the evo-
lution of streaks, as we do in this paper.

We conclude the paper with observations and insights
about further analyses on query logs.

2 Data Sets

Related Work. Whereas several previous studies have
focused on the analysis of real SPARQL queries, they

Our data set has a total of 350,089,005 queries, which
were obtained as follows. We obtained the 2013–2016

Table 1 Sizes of query logs in our corpus.

Source

Total #Q

Valid #Q Unique #Q

DBpedia9-12
DBpedia13
DBpedia14
DBpedia15
DBpedia16
DBpedia17

28,651,075
5,243,853
37,219,788
43,478,986
15,098,176
169,110,041

27,622,233
4,819,837
33,996,486
42,709,781
14,687,870
164,297,723

13,437,966
2,628,000
17,217,416
13,253,798
4,369,755
34,440,636

357,843
628,640

LGD13
LGD14

BioP13
BioP14

BioMed13

SWDF13

BritM14

1,927,695
1,999,961

1,531,164
1,951,973

4,627,270
26,438,932

4,624,449
26,404,716

687,773
2,191,151

883,375

882,847

27,030

13,853,604

13,670,550

1,229,759

1,555,940

1,545,643

135,112

Wikidata17

309

308

308

Total

350,089,005

338,745,580

90,605,187

USEWOD query logs, some additional DBpedia query
logs for 2013, 2014, 2015, 2016, and 2017 directly from
Openlink4, the 2014 British Museum query logs from
LSQ5, and we crawled the user-submitted example queries
from Wikidata6 in February 2017. These log ﬁles are
associated with 7 diﬀerent data sources from various
domains: DBpedia, Semantic Web Dog Food (SWDF),
LinkedGeoData (LGD), BioPortal (BioP), OpenBioMed
(BioMed), British Museum (BritM), and Wikidata.

Table 1 gives an overview of the analyzed query
logs, along with their main characteristics. Since we
obtained logs for DBpedia from diﬀerent sources, we
proceeded as follows. DBpedia9-12 contains the DBpe-
dia logs from USEWOD’13, which are query logs from
2009–2012. All other DBpedia’X sets contain the query
logs from the year ’X, be it from USEWOD or from
Openlink.7

Compared to the conference version of this article
[11], we have obtained 169,110,041 new queries from
Openlink, which is reﬂected in the DBpedia17 dataset.
Some of the other data sets are slightly larger than in
the conference version, due to an issue with the parser,
which we ﬁxed. In some cases, the parser would have
an internal error and the query would not even show
up in our total count.

4 http://www.openlinksw.com
5 http://aksw.github.io/LSQ/
6 https://www.wikidata.org/wiki/Wikidata:SPARQL_query_

service/queries/examples

7 We discovered that we received three log ﬁles from USE-
WOD as well as from Openlink, in the sense that only the
hash values used for anonymisation were diﬀerent. These du-
plicate log ﬁles were deleted prior to all analysis and are not
taken into account in Table 1.

We prepared the logs for analysis as follows. We
ﬁrst cleaned the logs, since some contained entries that
were not queries (e.g., http requests). In the following
we only report on the actual SPARQL queries in the
logs. For each of the logs, the table summarizes the to-
tal number of queries (Total ) and the number of queries
that we could parse using Apache Jena 3.7.0 (Valid ).
From the latter set, we removed duplicate queries af-
ter whitespace normalization, resulting in the unique
queries that we could parse (Unique). In the remain-
der of the paper, we present results on both Valid and
Unique data sets. In [11] we reported the results for the
Unique corpus only. Adding the Valid data set is im-
portant for improving our understanding of the query
logs though: while the Unique data set gives us an idea
of the diﬀerent types of queries that appear in the logs,
the Valid data set gives a better idea of the queries and
the workload that the SPARQL endpoints actually re-
ceive.
In summary, our corpus of query logs contains
the latest blend of USEWOD and Openlink DBPedia
query logs (the latter providing 51M more queries in
the period 2013–2016 than the USEWOD corpus, and
169M more for 2017), plus BritM and Wikidata queries.
We are not aware of other existing studies on such a
large and up-to-date corpus. Finally, although the on-
line Wikidata example queries (Feb 13th, 2017) are a
manually curated set, there was one query that we could
not parse.8

Throughout the article, we will use the following no-
tation to discuss results on the Valid and Unique data
sets. Whenever we report a number or a percentage in
the format X (Y), the number X refers to the Valid
and the number Y to the Unique set of queries. This
notation allows the reader to stay informed about the
queries that the endpoint actually receives (Valid ) and
about those without duplicates in this set (Unique).

The query logs we received are anonymized in the
sense that they do not contain IP addresses, precise
time stamps, or user agents. Time stamps are typically
either completely absent, or rounded to an hour. (In
some of the logs, all time stamps are set to 3:00.) This
means, in particular, that these logs do not allow a clas-
siﬁcation into robotic and organic queries, as was done
by Bielefeldt et al. [9] and Malyshev et al. [32].

In the total data set, 16,639,701 (2,978,945) queries,
or 4.91% (3.29%) of the logs do not have a body. All
these queries are Describe queries and almost exclu-
sively occur in DBpedia14–DBpedia17. To be more pre-
cise, 99.47% (97.22%) of the Describe queries do not

8 The query was called “Public Art in Paris” and was mal-
formed (closing braces were missing and it had a bad aggre-
gate). It was still malformed on June 29th, 2017.

have a body. We therefore conduct some of our analy-
ses only on Select, Ask, and Construct queries.

path. A SPARQL pattern is an expression generated
from the following grammar:

3 Preliminaries

We recall some basic deﬁnitions on RDF and SPARQL
[40, 41]. We closely follow the exposition of [41].

RDF. RDF data consists of a set of triples
s, p, o
(cid:105)
(cid:104)
where we refer to s as subject, p as predicate, and o
as object. According to the speciﬁcation, s, p, and o
(blank
can come from pairwise disjoint sets
nodes), and
,
∈ I
and o
. For this paper, the precise deﬁnition
of IRIs, blank nodes, and literals is not important. The
most important thing to know is that we treat blank
nodes similar to variables, which we discuss later.

I
(literals) as follows: s

∈ I ∪ B ∪ L

∈ I ∪ B

(IRIs),

B
, p

L

SPARQL. For our purposes, a SPARQL query Q can
be seen as a tuple of the form

(query-type, pattern P , solution-modiﬁer ).

We now explain how such queries work conceptually.
The central component is the Pattern P , which con-
tains patterns that are matched onto the RDF data.
The result of this part of the query is a multiset of
mappings that match the pattern to the data.

The solution-modiﬁer allows aggregation, grouping,
sorting, duplicate removal, and returning only a speciﬁc
window (e.g., the ﬁrst ten) of the multiset of mappings
returned by the pattern. The result is a list L of map-
pings.

The query-type determines the output of the query.
It is one of four types: Select, Ask, Construct, and De-
scribe. Select-queries return projections of mappings from
L. Ask-queries return a Boolean and answer true iﬀ the
pattern P could be matched. Construct queries con-
struct a new set of RDF triples based on the map-
pings in L. Finally, Describe queries return a set of RDF
triples that describes the IRIs and the blank nodes in L.
The exact output of Describe queries is implementation-
dependent. Such queries are meant to help users ex-
plore the data. Compared to [41], we allow more solu-
tion modiﬁers and more complex patterns, as explained
next.

V

=

Patterns. Let
set of variables, disjoint from
we always preﬁx variables by a question mark. A triple
pattern is an element of (

be an inﬁnite
?x, ?y, ?z, ?x1, . . .
}
{
. As in SPARQL,
, and
,
L

(
I ∪ B ∪
I ∪ B ∪ V
). A property path is a regular expression over the
. A property path pattern is an element of
), where pp is a property

I ∪ V

pp

×

×

B

I

)

(

)

L ∪ V
alphabet
(
I ∪ B ∪ V

I
)
×

(
I ∪ B ∪ L ∪ V

×

P ::= t

|
|
|

|

pp
Q
|
P1 Union P2 |
Graph iv P
|

P1 And P2 |

P1 Opt P2
Values tup T

P Filter R

∈ I ∪ V

Here, t is a triple pattern, pp is a property path pat-
tern, Q is again a SPARQL query, R is a so-called
SPARQL ﬁlter constraint, and iv
. We note that
property paths (pp) and subqueries (Q) in the above
grammar are new features since SPARQL 1.1. SPARQL
ﬁlter constraints R are built-in conditions which can
have unary predicates, (in)equalities between variables,
and Boolean combinations thereof. The keyword Values
binds a tuple tup to values in a given table T . We refer
to the SPARQL 1.1 recommendation [22] and the liter-
ature [40] for the precise syntax of ﬁlter constraints and
the semantics of SPARQL queries. We write vars(P ) to
denote the set of variables occurring in P .

We illustrate by example how our deﬁnition corre-
sponds to real SPARQL queries. The following query
comes from WikiData (“Locations of archaeological sites”,
from [45]).

SELECT ?label ?coord ?subj
WHERE
{?subj wdt:P31/wdt:P279* wd:Q839954 .

?subj wdt:P625 ?coord .
?subj rdfs:label ?label filter(lang(?label)="en")}

The query uses the property path wdt:P31/wdt:P279*,
literal wd:Q839954, and triple pattern ?subj wdt:P625
?coord. It also uses a ﬁlter constraint. In SPARQL,
the And operator is denoted by a dot (and is sometimes
implicit in alternative, even more succinct syntax). The
Select query will return all bindings of ?label, ?coord,
and ?subj for which the body can be satisﬁed. If we
would turn it into an Ask query, i.e., replace the entire
with the keyword ASK, it would return true if and only
if the Select query would return at least one output.

The following Construct query from WikiData [45]
constructs a new RDF graph related to “asthma” ( lit-
eral wd:Q35869), by recording the respective qualiﬁers
and their provenance information if available as Opt
edges.

CONSTRUCT {

wd:Q35869 ?p ?o . ?o ?qualifier ?f .
?o prov:wasDerivedFrom ?u . ?u ?a ?b .}

WHERE {

wd:Q35869 ?p ?o . OPTIONAL {?o ?qualifier ?f .}
OPTIONAL {?o prov:wasDerivedFrom ?u . ?u ?a ?b .}}

Finally, we deﬁne conjunctive queries, which are a
central class of queries in database research and which
we will build on in the remainder of the paper. In the
context of SPARQL, we deﬁne them as follows.

Deﬁnition 1 A conjunctive query (CQ) is a SPARQL
pattern that only uses the triple patterns and the op-
erator And.

prevalent data sets for queries with Oﬀset are LGD14
(30% (38%)), LGD13 (52%(13%)), and DBpedia13 (10%
(12%)).

4 Shallow Analysis

In this section we investigate simple syntactical prop-
erties of queries.

4.1 Keywords

A basic usage analysis of SPARQL features was done
by counting the keywords in queries. The results are in
Table 2.9

The table contains four blocks: types of queries, so-
lution modiﬁers, SPARQL algebra operators, and ag-
gregation operators. In each of the blocks, we sorted
the operators by their number of occurrences in the
Valid data set.

The ﬁrst block in Table 2 describes the type of
queries. In total, 91.96% (88.22%) of the queries are
Select queries, 4.94% (3.38%) Describe queries, 2.44%
(6.56%) are Ask queries, and 0.67% (1.84%) Construct
queries. There are, however, tremendous diﬀerences be-
tween the data sets. BioMed13 has less than 3.47% (12.83%)
Select queries and almost 94% (85%) Describe queries,
whereas LGD13 has 17% (28%) Select queries and almost
81% (71%) Construct queries.

Even within the same kind of data, we see signiﬁcant
diﬀerences. DBpedia16 has 85% (62%) Select queries
(and 12.1% (34%) Describe queries), whereas DBpedia15
has 92% (81.5%) Select queries and 4% (11.5%) Ask
queries. The other DBpedia data sets have over 87.5%
Select queries. DBpedia17 has 91% (88%) Select queries,
2.1% (9.1%) Ask queries and 5.8% (1.4%) Describe queries.
The second block in Table 2 contains solution mod-
iﬁers, ordered by their popularity.10 Looking into the
speciﬁc data sets, we see the following things stand out.
Almost all 89% (97%) of BritM14 queries use Distinct.
This is similar, but to a lesser extent in BioP13 (96%
(82%)) and BioP14 (92%(68%)). In DBpedia we again
see signiﬁcant diﬀerences. From ’12 to ’17, we have 21%
(18%), 7% (8%), 16% (11%), 20% (38%), 6% (8%) and
26% (52%) of queries with Distinct respectively.

Limit is used most widely in SWDF13 (48 (47%)), in
LGD13 (59% (17%)) and LGD14 (54 (41%)). The most

9 We also investigated the occurrence of other operators
(Service, Bind, Assign, Data, Dataset, Sample, Group Concat),
each of which appeared in less than 1% of the queries. We
omit them from the table for succinctness.
10 The remaining solution modiﬁer, Reduced, was only found
in 6,126 (1,149) queries.

Order By is used by far the most in Wikidata (44%),
which may be due to the case that Wikidata17 is not a
query log, but a Wiki page that contains cherry-picked
and user-submitted queries. These queries are intended
to showcase system’s behavior or highlight features of
the Wikidata data set and should therefore produce a
nice output. The other data sets are true query logs,
which may therefore also contain the “development pro-
cess” of queries: users start by asking a query and grad-
ually reﬁne it until they have the one they want. (We
come back to this in Section 10).

The third block has keywords associated to SPARQL
algebra operators that occur in the body. We see that
Filter, And, Union, and Opt are quite common.11 The
next commonly used operator is Graph but, looking
closer at our data, we see that 96% (78%) and 85%
(40%) of the queries using Graph originate from BioP13
and BioP14. The use of Filter ranges from 63% (58%)
for DBpedia13 to 0.7% (3%) or less for BioMed13 and
BioP13, respectively.

The fourth block has aggregation operators. We were
surprised that these operators are used so sparsely, even
though aggregates are only supported since SPARQL
1.1 (March 2013) [22]. In all data sets, each of these
operators was used in 3% or less of the Unique queries,
except for LGD14 (31% with Count), DBpedia17 (11%
with Group By) and Wikidata17 (30% with Group By).
We see a higher relative use of aggregation operators
in Wikidata17 than in the other sets, which we again
believe is due to the fact that the Wikidata17 set is not
a query log.

Overall, when we compare the Unique and Valid
logs, it is striking that the relative occurrences of the
four main SPARQL algebra operators Filter, And, Union,
and Opt all decrease when eliminating duplicate queries.

4.2 Number of Triples in Queries

In order to measure the size of the queries belonging
to the datasets under study, we have counted the total
number of triples of the kind
contained in Se-
lect, Ask and Construct queries. In this experiment, we
merely counted the number of triples contained in each
query without further investigating the possible rela-
tionships among them (such as join conditions, unions
etc.), which are studied in the remainder of the paper.

s, p, o
(cid:104)

(cid:105)

11 Conjunctions in SPARQL are actually denoted by “.” or
“;” for brevity, but we group them under “And” in this paper
for readability.

Table 2 Keyword count in queries

Element

AbsoluteV

RelativeV

AbsoluteU

RelativeU

Select
Describe
Ask
Construct

Distinct
Limit
Oﬀset
Order By

Filter
And
Opt
Union
Graph
Values
Not Exists
Minus
Exists

Group By
Count
Having
Avg
Min
Max
Sum

311,496,923
16,727,191
8,265,673
2,255,793

96,055,447
46,442,970
8,651,005
3,481,015

148,681,968
129,524,653
107,447,875
85,024,759
27,556,055
7,595,583
2,527,452
2,199,152
13,965

9,100,381
924,474
197,463
7,714
7,040
6,504
2,768

91.96% 79,929,422
3,061,636
5,943,216
1,670,913

4.94%
2.44%
0.67%

28.36% 29,973,911
13.71% 17,043,706
4,112,839
1,609,921

2.55%
1.03%

43.89% 34,609,372
38.24% 26,737,378
31.72% 13,119,429
25.10% 15,761,764
1,523,675
5,086,033
1,096,099
1,664,359
7,832

8.13%
2.24%
0.75%
0.65%
0.00%

2.69%
0.27%
0.06%
0.00%
0.00%
0.00%
0.00%

3,887,216
653,756
40,401
731
3,749
3,796
785

88.22%
3.38%
6.56%
1.84%

33.08%
18.81%
4.54%
1.78%

38.20%
29.51%
14.48%
17.40%
1.68%
5.61%
1.21%
1.84%
0.01%

4.29%
0.72%
0.04%
0.00%
0.00%
0.00%
0.00%

Fig. 1 Percentages of queries exhibiting diﬀerent number of triples (in colors) for each dataset for Valid (left hand side of each
bar) and Unique queries (right hand side of each bar).

We focus on Select, Ask and Construct queries as op-
posed to [11], which analysed Select and Ask on their
corpus. We discard the Describe statements, which have
an implementation-dependent semantics. 12

The plot in Figure 1 illustrates how queries contain-
ing 0 to 11+ triples are distributed over the Select, Ask
and Construct queries in each of the data sets. A ﬁrst

12 For instance, 95% (97%) of the Describe statements in our
corpus do not have a body and therefore no triples.

observation that we can draw from Figure 1 is that for
the majority of the datasets, the queries with a low
number of triples (from 0 to 2) have a noticeable share
within the total amount of queries per dataset. Whereas
these queries are almost the only queries present in
the BioP13 and BioP14 datasets, they have the least
concentration in BritM14 and Wikidata17. The latter
datasets have in fact unique characteristics, BritM14
being a collection of queries with ﬁxed templates and

DBpedia9-12DBpedia13DBpedia14DBpedia15DBpedia16DBpedia17LGD13LGD14BioP13BioP14BioMed13SWDF13BritM14Wikidata170%20%40%60%80%100%11+10987654321011+109876543210Fig.1Percentagesofqueriesexhibitingdi↵erentnumberoftriples(incolors)foreachdatasetforValid(lefthandsideofeachbar)andUniquequeries(righthandsideofeachbar).datasetsexhibitingthemostcomplexquerieswithex-tremelyhighnumbersoftriplesexceeding10.WeshouldnotethatBioMed13hasalmost94%(87%)Describequeries.Thenumbersreportedhereonlyde-picttheremaining6%(13%).Overall,weobservethat63.62%(58.40%)oftheSe-lect,AskandConstructqueriesinourcorpususeatmostonetriple,77.89%(90.16%)usesatmostsixtriples,and99.44%(98.35%)atmosttwelvetriples.ThelargestquerieswefoundcamefromDBpedia15(209and211triples)andBioMed13(221and229triples).InthenewquerylogsofDBpedia17,thelargestqueriescontain207and209triples.4.3OperatorDistributionInTable2weseethatFilter,And,Union,Opt,andGraphareusedfairlycommonlyinthebodiesofSelect-andAskqueries.WecannoticethatthenumbersinTa-ble2aregenerallycompatiblewiththoseofourprevi-ouscorpusin[10].WecannoticehoweveraremarkableincreaseintheusageofGroupByqueries(from0.3%to4.29%inthenewcorpus).Wetheninvestigatedhowtheseoperatorsoccurto-gether.Inparticular,weinvestigatedforwhichqueriesthebodyonlyusesconstructswiththeseoperators.13TheresultsareinTable3,whichhastwokindsofrows.Eachwhiterowhas,onitsleft,asetSofoperatorsfromO={Filter,And,Opt,Graph,Union,Values}and,13Thereisoneexception:ForWikidata,weremovedSER-VICEsubqueriesbeforetheanalysis(whichappearsinap-proximately200ofitsqueriesandisusedtochangethelan-guageoftheoutput).onitsright,theamountofqueriesinourlogsforwhichthebodyusesexactlytheoperatorsinS(andnonefromO\S).ThevaluefornoneistheamountofqueriesthatdonotuseanyoftheoperatorsinO(includingqueriesthatdonothaveabody).ConjunctivepatternswithﬁltersareconsideredtobeanimportantfragmentofSPARQLpatterns,be-causetheyarebelievedtoappearofteninpractice[33,44]Deﬁnition2Aconjunctivequerywithﬁlters(CQF)isaSPARQLpatternthatonlyusestriplepatternsandtheoperatorsAndandFilter.Ourlogscontain50.51%(66.89%)CQFqueries.AddingOpttotheCQFfragmentwouldincreaseitsrelativesizewith11.80%(7.20%)resultingin62.31%(74.09%)ourqueries.(SimilarlyforUnion,GraphandValues.)Table3classiﬁes95.07%(96.62%)oftheSelect,AskandConstructqueriesinourcorpus.TheremainingquerieseitheruseothercombinationsfromO1.64%(2.79%)oruseotherfeaturesthanthoseinOintheirbody2.10%(3.61%)likeBind,Minus,subqueries,orpropertypaths.ArecurrentcombinationoffeaturesthanthoseinOhasbeenobservedinthelatestquerylogs(DBpedia17),inwhichUnionandValuesappeartogetherin1.30%(5.08%)ofthequeries,whereastheyaremostlynotexistingintheotherdatasets.4.4SubqueriesandProjectionOnly1309040(575666)queriesinourcorpususesub-queries.ThefeaturewasmostusedinWikiData(9.74%),Wikidata17 being the most diverse dataset of all, gath-
ering queries of rather disparate nature that are repre-
sentatives of classes of real queries issued on Wikidata.
Finally, DBpedia9-12 until DBpedia17, along with LGD14
and BioMed13 are the datasets exhibiting the most com-
plex queries with extremely high numbers of triples ex-
ceeding 10.

We should note that BioMed13 has almost 94% (87%)
Describe queries. The numbers reported here only de-
pict the remaining 6% (13%).

Overall, we observe that 63.62% (58.40%) of the Se-
lect, Ask and Construct queries in our corpus use at most
one triple, 77.89% (90.16%) uses at most six triples,
and 99.44% (98.35%) at most twelve triples. The largest
queries we found came from DBpedia15 (209 and 211
triples) and BioMed13 (221 and 229 triples). In the new
query logs of DBpedia17, the largest queries contain 207
and 209 triples.

If we compare the Unique and Valid query logs over-
all, we see that the Valid logs usually have more large
queries than the Unique logs (sometimes quite signiﬁ-
cantly, e.g., in DBpedia17). This means that, in partic-
ular, the DBpedia SPARQL endpoint seems to receive
signiﬁcantly more large queries than what the results
on Unique queries in [11] suggest, but also that there
are many duplicates among these large queries.

4.3 Operator Distribution

In Table 2 we see that Filter, And, Union, Opt, and Graph
are used fairly commonly in the bodies of Select-, Ask-,
and Construct queries. We can notice that the num-
bers in Table 2 are generally compatible with those of
our previous corpus in [11]. We can notice, however, a
remarkable increase in the usage of Group By queries
(from 0.3% to 4.29% in the new corpus).

cause they are believed to appear often in practice [39,
50]

Deﬁnition 2 A conjunctive query with ﬁlters (CQF) is
a SPARQL pattern that only uses triple patterns and
the operators And and Filter.

Our logs contain 50.51% (66.89%) CQF queries. Adding
Opt to the CQF fragment would increase its relative
size with 11.80% (7.20%) resulting in 62.31% (74.09%)
our queries. (Similarly for Union, Graph and Values.)
Table 3 classiﬁes 95.07% (96.62%) of the Select, Ask and
Construct queries in our corpus. The remaining queries
either use other combinations from
1.64% (2.79%) or
O
in their body 2.10%
use other features than those in
(3.61%) like Bind, Minus, subqueries, or property paths.
A recurrent combination of features than those in
O
has been observed in the latest query logs (DBpedia17),
in which Union and Values appear together in 1.30%
(5.08%) of the queries, whereas they are mostly not
existing in the other datasets.

O

When we compare the Valid with the Unique data
sets, two changes stand out: Graph and the A,F,O,U
fragment become much less common when duplicates
are removed. For Graph, it seems that the BioPortal
query logs are responsible, since these logs harbor al-
most all queries that use Graph. For the A,F,O,U frag-
ment, we see that all DBpedia logs from 2013 on contain
many duplicates of A,F,O,U queries. For instance, in the
Valid DBpedia17 logs we have 25.87% A,F,O,U queries,
but in the Unique DBpedia17 logs, this fragment only
constitutes 6.06% of the queries.

We then investigated how these operators occur to-
gether. In particular, we investigated for which queries
the body only uses constructs with these operators.13
The results are in Table 3, which has two kinds of
rows. Each white row has, on its left, a set S of operators
from
and,
on its right, the amount of queries in our logs for which
the body uses exactly the operators in S (and none from
S). The value for none is the amount of queries that
(including queries

Filter, And, Opt, Graph, Union, Values

O \
do not use any of the operators in
that do not have a body).

O

O

=

{

}

Conjunctive patterns with ﬁlters are considered to
be an important fragment of SPARQL patterns, be-

13 There is one exception: For Wikidata, we removed SER-
VICE subqueries before the analysis (which appears in ap-
proximately 200 of its queries and is used to change the lan-
guage of the output).

4.4 Subqueries and Projection

Only 1309040 (575666) queries in our corpus use sub-
queries. The feature was most used in WikiData (9.74%),
about an order of magnitude more than in any of the
other data sets.

Projection plays a crucial role in the complexity of
query evaluation. Many papers [8, 30, 27,40,41] deﬁne
evaluation as the following question: Given an RDF
graph G, a SPARQL pattern P , and a mapping µ, is µ
an answer to P when evaluated on G? In other words,
the question is to verify if a candidate answer µ is in-
deed an answer to the query. If P is a CQ, this problem
is NP-complete if the queries use projection [13, 8, 30],
but its complexity drops to Ptime if projection is ab-

Table 3 Sets of operators used in queries: And (A), Filter (F), Graph (G), Opt (O), Union (U), and Values (V)

Operator Set

AbsoluteV

RelativeV

AbsoluteU

RelativeU

none 107,285,016
15,106,778
30,679,572
9,583,490
CQF subtotal 162,654,856

A
F
A,F

O
A,O
F,O
A,F,O

2,921,810
3,436,987
7,115,439
24,512,799
CQF+O +37,987,035

U
A,U
F,U
A,F,U

8,533,645
1,627,742
627,559
1,824,697
CQF+U +12,613,643

V
A,V
F,V
A,F,V

151,078
207,180
2,497,572
142,211
CQF+V +2,998,041

G
A,G
F,G
A,F,G

26,288,960
391,433
876
34,418
CQF+G +26,715,687

33.32% 31,785,844
4.69%
7,769,170
9.53% 14,822,993
4,176,586
2.98%
50.51% 58,554,593

0.91%
1.07%
2.21%
7.61%

625,663
1,807,483
2,096,526
1,773,624
+11.80% +6,303,296

2.65%
0.51%
0.19%
0.57%

4,627,921
1,010,579
254,640
1,057,080
+3.92% +6,950,220

0.05%
0.06%
0.78%
0.04%

63,912
164,175
2,204,598
98,560
+0.93% +2,531,245

8.16%
0.12%
0.00%
0.01%

1,380,991
42,315
269
9,495
+8.30% +1,433,070

36.31%
8.87%
16.93%
4.77%
66.89%

0.71%
2.06%
2.39%
2.03%
+7.20%

5.29%
1.15%
0.29%
1.21%
+7.94%

0.07%
0.19%
2.52%
0.11%
+2.89%

1.58%
0.05%
0.00%
0.01%
+1.64%

A,F,O,U

67,026,601

20.81%

6,170,843

7.05%

sent [40,8,30].14 Therefore, the use of projection has a
huge inﬂuence of the complexity of query evaluation.

and 12.18% for Valid queries (13.13% and 18.5% for
Unique queries, respectively).

Surprisingly, we discovered that at least 9.1% (13.13%)

of the queries use projection, which is signiﬁcantly higher
than what Picalausa and Vansummeren discovered in
DBpedia logs from 2010 [41]. The 9.1% (13.13%) con-
sists of 8.33% (11.88%) Select queries plus 0.76% (1.24%)
Ask queries. Notice that the total number of Ask queries
2.44% (6.56%) is signiﬁcantly higher, even though they
just return a Boolean value and one would intuitively
expect that almost all of them would use projection.
The reason is that most Ask queries do not use vari-
ables: they ask if a concrete RDF triple is present in
the data. Following the test for projection in Section
18.2.1 in the SPARQL recommendation [22], we classi-
ﬁed these queries as not using projection.

Due to the use of the Bind operator or to the pres-
ence of subqueries, there was a number of queries (3.08%
for Valid and 5.37% for Unique queries) where we could
not determine if they use projection or not. Therefore
the number of queries with projection lies between 9.1%

14 This diﬀerence can be understood as follows: If the query
tests the presence of a k-clique, then without projection we
are given a k-tuple of nodes and need to verify if they form a
k-clique. With projection, we need to solve the NP-complete
k-clique problem.

5 Structural Analysis

SPARQL patterns of queries using only triple patterns
and the operators And, Opt, and Filter (and, in partic-
ular, not using subqueries or property paths) received
considerable attention in the literature (see, e.g., [40,
27,8,29, 30]). We refer to such Select, Ask, or Filter pat-
terns as And/Opt/Filter patterns or, for succinctness,
AOF patterns. Our corpus has 200,641,891 (64,857,889)
AOF patterns, which amounts to 62.31% (74.09%) of
the Select, Ask, and Construct queries.

In Sections 6 and 7 we investigate the graph- and hy-
pergraph structure of AOF patterns. The graph struc-
ture gives us a clear view on how such queries are struc-
tured and can tell us how complex such queries are
to evaluate. For a signiﬁcant portion of queries, how-
ever, the graph structure is not meaningful to capture
their complexity (cf. Example 1) and we therefore need
to turn to their hypergraph structure. Since the graph
structure may be easier to understand and is often suf-
ﬁcient, we use the graph structure whenever we can.

We provide some background on the relationship
between the (hyper)graph structure of queries and the
complexity of their evaluation. Evaluation of CQs is
NP-complete in general [13], but becomes Ptime if
their hypertree width is bounded by a constant [20].
Here, the hypertree width measures how close the query
is to a tree (the lower the width, the closer the query
is to a tree). Several state-of-the-art join evaluation al-
gorithms (e.g., [1, 26]) eﬀectively use the hypergraph
structure of queries to improve their performance, even
in the context of RDF processing [2]. We establish in
Section 5.2 that there are signiﬁcant performance dif-
ferences in today’s query engines, even when the hyper-
treewidth of queries just increases from one to two.

5.1 Graph and Hypergraph of a Query

We ﬁrst make more precise what we mean by the graph
and hypergraph of a query. An (undirected) graph G is
a pair (V, E) where V is its (ﬁnite) set of nodes and
E is its set of edges, where an edge e is a set of one
= 2. A
or two nodes, i.e., e
V and
and a
hypergraph
set of hyperedges
2V , that is, a hyperedge is a set
of nodes.

e
|
consists of a (ﬁnite) set of nodes

= 1 or

E ⊆

e
|

H

⊆

V

|

|

)

x, y

|
{{
and V =

Most SPARQL patterns do not use variables as pred-
icates, that is, they use triple patterns (s, p, o) where p
is an IRI. We also allow p
vars if p is not used else-
∈
where in the query (in this case, p serves as a wildcard,
possibly binding to a value that is returned to the out-
put). We call such patterns graph patterns. Evaluation
of graph patterns is tightly connected to ﬁnding embed-
dings of the graph representation of the query into the
data.15 We deﬁne the triple graph of graph pattern P to
(x, (cid:96), y) is a triple
be the following graph: E =
.
x, y
pattern in P and (cid:96)
}
Hypergraph representations can be considered for
all AOF patterns. The triple hypergraph of a SPARQL
there is a triple pat-
=
pattern P is deﬁned as
tern t in P such that X is the set of blank nodes and
variables appearing t
}

V
For several types of queries, we will analyse the
structure of their triple graph. However, the usage of
some keywords of types of subqueries (notably, Filter
and Values) can put additional constraints on the query
that are not reﬂected in the triple (hyper)graph and
we therefore need to augment it with additional (hy-
per)edges. We will call the resulting graphs the canon-
ical (hyper)graphs of the queries. For CQs however, we

∈ I ∪ V}

X
{

x
{

and

Ee.

} ∈

∪e

| {

=

E

E

}

∈

|

15 In particular, it consists of ﬁnding embeddings of the di-
rected and edge-labeled variant of the graph, but we omit
the edge directions and -labels for simplicity. They do not
inﬂuence the structure and cyclicity of graph patterns.

x2

x1

x3

:a

x1

x2

x2

x1

x3

:b

:a

:c

x3

x4

x2

x5

x4

x5

x4

Fig. 2 Canonical graphs and hypergraph for queries in Ex-
ample 1.

deﬁne their canonical (hyper)graph to be equal to their
triple (hyper)graph.

Example 1 Consider the following (synthetic) CQs:

ASK WHERE {?x1 :a ?x2 . ?x2 :b ?x3 . ?x3 :c ?x4}
ASK WHERE {?x1 ?x2 ?x3 . ?x3 :a ?x4 . ?x4 ?x2 ?x5}

Figure 2 (top left) depicts the canonical graph of the
ﬁrst query, which is a sequence of three edges. (We an-
notated the edges with their labels in the query to im-
prove understanding.) The bottom left graph in Fig-
ure 2 shows why we do not consider canonical graphs
for queries with variables on the predicate position in
triples. The topological structure of this graph is a se-
quence of three edges, just as for the ﬁrst query. This
completely ignores the join condition on ?x2. For this
query, the canonical hypergraph in Figure 2 (right) cor-
rectly captures the cyclicity of the query.

5.2 Comparative Evaluation of Chain and Cycle
Queries

x1, x2}
{

,
x0, x1}
{

We conducted a set of experiments aiming at compar-
ing the execution times of conjunctive queries whose
canonical graphs exhibit speciﬁc shapes. We have cho-
sen chain and cycle queries in this empirical study.
A chain query (of length k) is a CQ for which the
canonical graph is isomorphic to the undirected graph
. (The ﬁrst
with edges
query in Example 1 is a chain query of length three.) A
cycle query (of length k) is a CQ for which the canon-
ical graph is isomorphic to
. As
{
an edge case, we also allow chains of length zero. Such
chains consist either of a single node or no node at all.
These shapes have been selected as representatives of
the queries with hypertreewidth 1 and 2, respectively,
and have also been used to compare the performances
of join algorithms in other studies, e.g., [26].

x0, x1}

1, xk}

1, x0}

xk
{

, . . . ,

, . . . ,

xk

{

−

−

In order to generate query workloads containing the
aforementioned types of queries, we have used gMark [4],
a publicly available16 schema-driven generator for graph

16 https://github.com/graphMark/gmark

instances and graph queries. We tuned gMark to gener-
ate diverse query workloads, each containing 100 chain
and cycle queries, respectively.17 Each workload has
been generated by using chains and cycles of diﬀer-
ent length varying from 3 to 8. In these experiments,
we have considered and contrasted two opposite graph
database systems, namely PostgreSQL [49], an open-
source relational DBMS, and BlazeGraph [47], a high-
performance SPARQL query engine powering the Wiki-
media’s oﬃcial query service [51] and thus used for the
oﬃcial Wikidata SPARQL endpoint. We have run these
experiments on 2-CPUs Intel Xeon E5-2630v2 2.6 GHz
server18 with 128GB RAM and running Ubuntu 16.04
LTS. We used PostgreSQL v.9.3 and Blazegraph v.2.1.4
for the experimental setup. We employed the Bib use
case in the gMark conﬁguration [4] for the schema of the
generated graph (of size 100k nodes) and of the gener-
ated queries as well. We employed the query workloads
in SQL and SPARQL as generated by gMark after elim-
ination of empty unions (since gMark is geared towards
generating UCRPQs) and of the keyword Distinct in the
body of the queries. Since gMark allowed us to obtain
mixed workloads of Select/Ask queries and we wanted
to focus on one query type at a time, we manually re-
placed the Select clauses with compatible Ask clauses.

Figure 3 (top) depicts the average runtime (in ns,
logscale) of our workloads of chain (cycle, resp.) queries
with length from 3 to 8 on Blazegraph (BG) and Post-
greSQL (PG). We can observe that the overall perfor-
mance of BG is superior to that of PG. Indeed, in PG
many cycles queries are timed out (after 300s per query)
and we expect that the real overall performance of PG is
even worse 19 than the results reported in Figure 3. Fig-
ure 3 (bottom) reports the reached timeouts for work-
loads of cycle queries of various sizes when executed in
PG. It is worthwhile observing that for both systems
the diﬀerence between average runtime of chain query
workloads and cycle query workloads is non negligible,
thus conﬁrming that we cannot ignore the graph rep-
resentation and the shape of queries. This experiment
also motivated us to dig deeper in the shape analysis of
our query logs, which we report in Section 6.

17 We recall that gMark can generate queries of four shapes:
chain, star, chain-star and cycle. We have thus cherry-
picked chain queries as representatives of queries with hy-
pertreewidth equal to 1.
18 Every CPU has 6 physical cores and, with hyperthread-
ing, 12 logical cores.
19 in the case in which we let PG run beyond the time out
and collect the new numbers.

Fig. 3 Execution times
(top) of diverse workload of
chain/cycle queries (of length 3,4,5,6) on Blazegraph (BG)
and Postgresql (PG). Number of timeouts per workload for
CyclePG only (bottom). CyclePG times include t/o of 300s
(per query).

5.3 Classes of Queries for (Hyper)graphs

We now discuss the classes of queries for which we
will investigate their canonical graph- and hypergraph
structures in Section 6. To the best of our knowledge, all
the literature relating (hyper)graph structure of queries
to eﬃcient evaluation was done on AOF patterns. Here,
we focus on fragments of AOF patterns, plus a mild
extension, namely with additional Values-blocks. The
simplest queries we consider are the CQs, which moti-
vated the classical literature on query evaluation and
hypertree structure [13,20]. We discovered that 61.00%
(60.99%) of the AOF patterns are CQs.

Deﬁnition 3 A CQ is suitable for graph analysis if
it is a graph pattern. For a CQ that is suitable for
graph analysis, its canonical graph is deﬁned as its triple
graph. For every other CQ, its canonical hypergraph is
deﬁned as its triple hypergraph.

Next, we extend the above terminology for CQs
with Filter, Opt, and Values. We only want to consider
canonical (hyper)graphs for queries such that the re-
lationship between eﬃcient query evaluation and their
(hyper)graph structure is still similar as for CQs. How-
ever, this requires some care, especially when consider-
ing Opt [8,40].

CQF patterns can be evaluated similarly to CQs,
but we need discuss the fragment for which we will
analyse the graph- structures. We say that a ﬁlter con-

cyclequery(oflengthk)isaCQforwhichthecanon-icalgraphisisomorphicto{x0,x1},...,{xk 1,x0}.Asanedgecase,wealsoallowchainsoflengthzero.Suchchainsconsisteitherofasinglenodeornonodeatall.Theseshapeshavebeenselectedasrepresentativesofthequerieswithhypertreewidth1and2,respectively,andhavealsobeenusedtocomparetheperformancesofjoinalgorithmsinotherstudies,e.g.,[23].Inordertogeneratequeryworkloadscontainingtheaforementionedtypesofqueries,wehaveusedgMark[4],apubliclyavailable16schema-drivengeneratorforgraphinstancesandgraphqueries.WetunedgMarktogener-atediversequeryworkloads,eachcontaining100chainandcyclequeries,respectively.17Eachworkloadhasbeengeneratedbyusingchainsandcyclesofdi↵er-entlengthvaryingfrom3to8.Intheseexperiments,wehaveconsideredandcontrastedtwooppositegraphdatabasesystems,namelyPostgreSQL[43],anopen-sourcerelationalDBMS,andBlazeGraph[41],anhigh-performanceSPARQLqueryenginepoweringtheWiki-media’so cialqueryservice[45]andthususedforWikidatareal-worldqueries.Wehaveruntheseex-perimentson2-CPUsIntelXeonE5-2630v22.6GHzserver18with128GBRAMandrunningUbuntu16.04LTS.WeusedPostgreSQLv.9.3andBlazegraphv.2.1.4fortheexperimentalsetup.WeemployedtheBibusecaseinthegMarkconﬁguration[4]fortheschemaofthegeneratedgraph(ofsize100knodes)andofthegener-atedqueriesaswell.WeemployedthequeryworkloadsinSQLandSPARQLasgeneratedbygMarkafterelim-inationofemptyunions(sincegMarkisgearedtowardsgeneratingUCRPQs)andofthekeywordDistinctinthebodyofthequeries.SincegMarkallowedustoobtainmixedworkloadsofSelect/Askqueriesandwewantedtofocusononequerytypeatatime,wemanuallyre-placedtheSelectclauseswithcompatibleAskclauses.Figure3(top)depictstheaverageruntime(inns,logscale)ofourworkloadsofchain(cycle,resp.)querieswithlengthfrom3to8onBlazegraph(BG)andPost-greSQL(PG).Wecanobservethattheoverallperfor-manceofBGissuperiortothatofPG.Indeed,inPGmanycyclesqueriesaretimedout(after300sperquery)andweexpectthattherealoverallperformanceofPGisevenworsethantheresultsreportedinFigure3.Fig-ure3(bottom)reportsthereachedtimeoutsforwork-loadsofcyclequeriesofvarioussizeswhenexecutedinPG.Itisworthwhileobservingthatforbothsystems16https://github.com/graphMark/gmark17WerecallthatgMarkcangeneratequeriesoffourshapes:chain,star,chain-starandcycle.Wehavethuscherry-pickedchainqueriesasrepresentativesofquerieswithhy-pertreewidthequalto1.18EveryCPUhas6physicalcoresand,withhyperthread-ing,12logicalcores.W-3W-4W-5W-6W-7W-810810910101011Avg.queryruntimeperworkloadW-x(inns)chainBGchainPGcycleBGcyclePG*W-xW-3W-4W-5W-6W-7W-8%t/o18%34%43%39%43%30%Fig.3Executiontimes(top)ofdiverseworkloadofchain/cyclequeries(oflength3,4,5,6)onBlazegraph(BG)andPostgresql(PG).NumberoftimeoutsperworkloadforCyclePGonly(bottom).CyclePGtimesincludet/oof300s(perquery).thedi↵erencebetweenaverageruntimeofchainqueryworkloadsandcyclequeryworkloadsisnonnegligible,thusconﬁrmingthatwecannotignorethegraphrep-resentationandtheshapeofqueries.Thisexperimentalsomotivatedustodigdeeperintheshapeanalysisofourquerylogs,whichwereportinSection6.5.3ClassesofQueriesfor(Hyper)graphsWenowdiscusstheclassesofqueriesforwhichwewillinvestigatetheircanonicalgraph-andhypergraphstructuresinSection6.Tothebestofourknowledge,alltheliteraturerelating(hyper)graphstructureofqueriestoe cientevaluationwasdoneonAOFpatterns.Here,wefocusonfragmentsofAOFpatterns,plusamildextension,namelywithadditionalValues-blocks.ThesimplestqueriesweconsideraretheCQs,whichmoti-vatedtheclassicalliteratureonqueryevaluationandhypertreestructure[11,17].Wediscoveredthat61.00%(60.99%)oftheAOFpatternsareCQs.Deﬁnition3ACQissuitableforgraphanalysisifitisagraphpattern.ForaCQthatissuitableforgraphanalysis,itscanonicalgraphisdeﬁnedasitstriplegraph.ForeveryotherCQ,itscanonicalhypergraphisdeﬁnedasitstriplehypergraph.Next,weextendtheaboveterminologyforCQswithFilter,Opt,andValues.Weonlywanttoconsiderstraint R is simple if vars(R) contains at most two vari-
ables. (An almost identical class of queries was consid-
ered in [41].)

Deﬁnition 4 A CQF query is suitable for graph anal-
ysis if it is a graph pattern and all ﬁlter constraints are
simple. For such a CQF query, we deﬁne its canonical
x, y
graph as its triple graph, to which we add an edge
}
{
for each ﬁlter constraint that uses the two variables x
and y. For all other CQF queries, its canonical hyper-
graph is obtained from its triple graph, to which we add
for each ﬁlter constraint that
x1, . . . , xk}
a hyperedge
uses precisely the k variables x1, . . . , xk.

{

In our corpus, 81.07% (90.28%) of the CQF patterns
are suitable for graph analysis.

We now additionally consider Opt. P´erez et al. [40]
showed that unrestricted use of Opt in SPARQL pat-
terns makes query evaluation Pspace-complete, which
is signiﬁcantly more complex than the NP-completeness
of CQs or CQF queries. They discovered that patterns
that satisfy an extra condition called well-designedness [40],
can be evaluated more eﬃciently. Letelier et al. [30]
show that, in the presence of projection, evaluation of
well-designed patterns is ΣP

2 -complete.

Deﬁnition 5 A SPARQL pattern P using only the op-
erators And, Filter, and Opt is well-designed if for every
occurrence i of an Opt-pattern (P1 Opt P2) in P , the
variables from vars(P2)
vars(P1) occur in P only inside
i.20

\

In our corpus, 98.74% (98.18%) of the AOF patterns
are well-designed (but do not necessarily have simple
ﬁlters). Unfortunately, it is not yet suﬃcient for well-
designed patterns to have a hypergraph of constant hy-
pertreewidth for their evaluation to be tractable [8].
However, Barcel´o et al. show that this can be mended
by an additional restriction called bounded interface
width. We explain this notion by example and refer to
[8] for details.

Example 2 The following patterns come from [40, 30]:
P1 = (((?A, name, ?N) Opt (?A, email, ?E))

Opt (?A, webPage, ?W))

and P2 = ((?A, name, ?N)

Opt ((?A, email, ?E) Opt (?A, webPage, ?W)))
Figure 4 has tree representations T1 and T2 for P1 and
P2, respectively, called pattern trees. The pattern trees
Ti are obtained from the parse trees of Pi by apply-
ing a standard encoding based on Currying [33, Section
4.1.1]. The encoding only aﬀects the arguments of the

20 Perez et al.’s deﬁnition also has a safety condition on
the ﬁlter statements of the patterns, but the omission of this
condition does not aﬀect the results in this paper.

T1:

(?A, name, ?N)

T2:

(?A, name, ?N)

(?A, email, ?E) (?A, webPage, ?W)

(?A, email, ?E)

Fig. 4 Pattern trees that correspond to the queries in Exam-
ple 2

(?A, webPage, ?W)

Opt operators in the queries. If the query also uses And,
then it should ﬁrst be brought in Opt-normal form [40]
and then turned into a pattern tree. The resulting pat-
tern trees will then have a CQ in each of its nodes.

Barcel´o et al. deﬁne pattern trees to be well-designed
if, for each variable, the set of nodes in which it occurs
forms a connected set. Notice that this is the case for
T1 and T2. It would be violated in T1 if the root would
not use the variable ?A. Likewise, it would be violated
in T2 if the node labeled (?A, email, ?E) would not use
the variable ?A.

The interface width of the pattern trees is the maxi-
mum number of common variables between a node and
its child. Both trees in Figure 4 (and both queries P1
and P2) therefore have interface width one. (Common
variables are bold in Figure 4.) If T1 would use variable
?W instead of ?N , then its interface width would be
two.

Deﬁnition 6 A SPARQL pattern P using only the op-
erators And, Filter, and Opt is a CQOF query if it has a
well-designed pattern tree with interface width 1. It is
suitable for graph analysis if it is a graph pattern and
all its ﬁlter conditions are simple. The canonical graph
and hypergraph of a CQOF query is deﬁned analogously
to that of CQF queries. That is, its triple graph (resp.
hypergraph) is augmented with edges
for each ﬁl-
ter constraint that uses precisely the variables x and y
(resp. hyperedges
for each ﬁlter constraint
that uses precisely the variables x1, . . . , xk).

x1, . . . , xk}
{

x, y

}

{

We discovered that 98.72% (98.13%) of the AOF pat-
terns are CQOF queries, which is almost equal to the
number of well-designed patterns. Moreover, 85.30%
(93.87%) are CQOF patterns that are suitable for graph
analysis.

The Values keyword was used in 2.24% (5.61%) of
the queries. It is particularly often used in DBpedia17,
where it appears in 4.03% (13.37%) of the queries. The
purpose of Values blocks is to test if a variable (or a
tuple of variables) appears in a set that is given in the
query. For instance, the subquery

VALUES (?country) {"Belgium" "France" "Germany"}

restricts the variable ?country to be assigned to one
of the values "Belgium", "France", or "Germany". The
Values block is used almost exclusively for unary condi-
tions, that is, to test if the value of a single variable is
in a given set of constants. However, it can also be used
to test higher arity constraints, as in the subquery

VALUES (?x ?y) {(:a :b) (:a :c)}

which imposes a binary constraint, i.e., it binds the vari-
able pair (?x ?y) to one of the two pairs in the body
of the Values block. Concerning our shape analysis, we
distinguish between Values blocks that use constraints
of arity two or less and the others.

Table 4 Well-designedness (wd), weak well-designedness
(wwd) and unions thereof

Property

AbsoluteV RelativeV AbsoluteU RelativeU

wd
wwd
AOF

uwd
uwwd
AOFU

198,109,323
200,064,814
200,641,891

208,672,931
210,638,343
280,672,732

98.74% 63,677,171
99.71% 64,749,468
100.00% 64,857,889

74.35% 69,279,286
75.05% 70,360,134
100.00% 78,088,794

98.18%
99.83%
100.00%

88.72%
90.10%
100.00%

Deﬁnition 7 A CQOFV query is a SPARQL pattern
P using only the operators And, Filter, Opt, and Values,
such that the pattern obtained from P by removing all
Values blocks is a CQOF query. It is suitable for graph
analysis if all ﬁlters are simple and all values blocks
have arity at most two. If a CQOFV query is suitable
for graph analysis, its canonical graph is obtained from
the triple graph by augmenting it with an edge for each
binary ﬁlter constraint, and an edge for each binary Val-
ues block. For every other CQOFV queries, its canonical
hypergraph is obtained from the triple hypergraph by
augmenting it with a hyperedge
for each
ﬁlter- or values block that uses precisely the variables
x1, . . . , xk.

x1, . . . , xk}

{

5.4 (Weak) Well-Designedness And Unions

We conclude the section with a brief note on the usage
of well-designedness with respect to the entire corpus of
queries. Kaminski and Kostylev [27] deﬁned a weaker
version of well-designedness that has similar favorable
computational properties. We therefore also analysed
whether queries are weakly well-designed. Table 4 shows
the number of AOF queries and the percentages thereof
that are well-designed (wd ) and weakly well-designed
(wwd ). We also took the set of queries that only use
And, Opt, Filter, and Union (AOFU in Table 4) and in-
vestigated the percentages of queries thereof that are
unions of wd or wwd queries. In most cases where the
query is not a union of wd or wwd queries, it is because
the union is not the top-level operator.

6 Shape Classiﬁcation

In this section, we analyze the shapes of the canoni-
cal graphs and the tree- and hypertree width of CQ,
CQF, CQOF, and CQOFV queries. We start with a note
on the size of these queries. Figure 5 shows the re-
spective sizes of these queries that have at least two

Fig. 5 Size of Valid (versus Unique) CQ-like queries with at
least two triples.

triples by considering both Valid and Unique queries
side by side. The fractions of queries with one triple are
90.65% (85.36%), 87.71% (83.22%), 81.54% (76.99%)
and 81.81%(77.81%) for CQ, CQF, CQOF and CQOFV
respectively. Unsurprisingly, small queries are more likely
to be in one of these fragments and, therefore, simple
queries are represented even more in these data sets
than in the overall data set. Nevertheless, we have CQs
and CQF queries with up to 81 triples and CQOF and
CQOFV queries with up to 211 triples.

6.1 Graph Structure

We analyse the graph structure of queries. We only con-
sider graphs for queries that were deﬁned to be suitable
for graph analysis in Section 5.1. We consider the re-
maining 27.27 million queries in CQOF in Section 6.2.
We ﬁrst recall or deﬁne the basic shapes of the
canonical graphs that we will study in this section. The
shapes chains and cycle are already deﬁned in Sec-
tion 5.2. A chain set is a graph in which every con-
nected component is a chain. (So, each chain is also a
chain set.)

TheValueskeywordwasusedin2.24%(5.61%)ofthequeries.ItisparticularlyoftenusedinDBpedia17,whereitappearsin4.03%(13.37%)ofthequeries.ThepurposeofValuesblocksistotestifavariable(oratupleofvariables)appearsinasetthatisgiveninthequery.Forinstance,thesubqueryVALUES(?country){"Belgium""France""Germany"}restrictsthevariable?countrytobeassignedtooneofthevalues"Belgium","France",or"Germany".TheValuesblockisusedalmostexclusivelyforunarycondi-tions,thatis,totestifthevalueofasinglevariableisinagivensetofconstants.However,itcanalsobeusedtotesthigherarityconstraints,asinthesubqueryVALUES(?x?y){(:a:b)(:a:c)}whichemposesabinaryconstraint,i.e.,itbindsthevariablepair(?x?y)tooneofthetwopairsinthebodyoftheValuesblock.Concerningourshapeanaly-sis,wedistinguishbetweenValuesblocksthatusecon-straintsofaritytwoorlessandtheothers.Deﬁnition7ACQOFVqueryisaSPARQLpatternPusingonlytheoperatorsAnd,Filter,Opt,andValues,suchthatthepatternobtainedfromPbyremovingallValuesblocksisaCQOFquery.Itissuitableforgraphanalysisifallﬁltersaresimpleandallvaluesblockshavearityatmosttwo.IfaCQOFVqueryissuitableforgraphanalysis,itscanonicalgraphisobtainedfromthetriplegraphbyaugmentingitwithanedgeforeachbinaryﬁlterconstraint,andanedgeforeachbinaryVal-uesblock.ForeveryotherCQOFVqueries,itscanonicalhypergraphisobtainedfromthetriplehypergraphbyaugmentingitwithahyperedge{x1,...,xk}foreachﬁlter-orvaluesblockthatusespreciselythevariablesx1,...,xk.5.4(Weak)Well-DesignednessAndUnionsWeconcludethesectionwithabriefnoteontheusageofwell-designednesswithrespecttotheentirecorpusofqueries.KaminskiandKostylev[24]deﬁnedaweakerversionofwell-designednessthathassimilarfavorablecomputationalproperties.Wethereforealsoanalysedwhetherqueriesareweaklywell-designed.Table4showsthenumberofAOFqueriesandthepercentagesthereofthatarewell-designed(wd)andweaklywell-designed(wwd).WealsotookthesetofqueriesthatonlyuseAnd,Opt,Filter,andUnion(AOFUinTable4)andin-vestigatedthepercentagesofqueriesthereofthatareunionsofwdorwwdqueries.Inmostcaseswherethequeryisnotaunionofwdorwwdqueries,itisbecausetheunionisnotthetop-leveloperator.Table4Well-designedness(wd),weakwell-designedness(wwd)andunionsthereofPropertyAbsoluteVRelativeVAbsoluteURelativeUwd198,109,32398.74%63,677,17198.18%wwd200,064,81499.71%64,749,46899.83%AOF200,641,891100.00%64,857,889100.00%uwd208,672,93174.35%69,279,28688.72%uwwd210,638,34375.05%70,360,13490.10%AOFU280,672,732100.00%78,088,794100.00%CQCQFCQOFCQOFV0%20%40%60%80%100%11+1098765432CQCQFCQOFCQOFV0%20%40%60%80%100%11+1098765432Fig.5SizeofValid(versusUnique)CQ-likequerieswithatleasttwotriples.6ShapeClassiﬁcationInthissection,weanalyzetheshapesofthecanoni-calgraphsandthetree-andhypertreewidthofCQ,CQF,CQOF,andCQOFVqueries.Westartwithanoteonthesizeofthesequeries.Figure5showsthere-spectivesizesofthesequeriesthathaveatleasttwotriplesbyconsideringbothValidandUniquequeriessidebyside.Thefractionsofquerieswithonetripleare90.65%(85.36%),87.71%(83.22%),81.54%(76.99%)and81.81%(77.81%)forCQ,CQF,CQOFandCQOFVrespectively.Unsurprisingly,smallqueriesaremorelikelytobeinoneofthesefragmentsand,therefore,simplequeriesarerepresentedevenmoreinthesedatasetsthanintheoveralldataset.Nevertheless,wehaveCQsandCQFquerieswithupto81triplesandCQOFandCQOFVquerieswithupto211triples.6.1GraphStructureWeanalysethegraphstructureofqueries.Weonlycon-sidergraphsforqueriesthatweredeﬁnedtobesuitableforgraphanalysisinSection5.1.Weconsiderthere-maining6.96millionqueriesinCQOFinSection6.2.Table 5 Cumulative shape analysis of graph patterns in CQ, CQF, CQOF, and CQOFV, across all logs. The relative numbers
are w.r.t. the queries that are suitable for graph analysis.

VALID

CQ/graph

Shape

#Queries Relative %

CQF/graph
#Queries Relative %

CQOF/graph
#Queries Relative %

CQOFV/graph
#Queries Relative %

no edge
≤ 1 edge
chain
star
tree
ﬂower

chain set
forest
bouquet

73,147
107,268,916
116,816,836
117,683,253
118,059,399
118,225,680

116,835,460
118,078,726
118,245,059

0.06%
90.71%
98.78%
99.52%
99.83%
99.98%

98.80%
99.85%
99.99%

73,155
137,634,760
151,963,617
155,325,069
155,716,314
156,730,621

151,990,203
155,748,689
156,763,406

0.05%
87.56%
96.68%
98.82%
99.07%
99.71%

96.70%
99.09%
99.73%

73,155
139,234,499
159,787,714
168,220,691
168,936,241
170,174,607

159,931,312
169,089,411
170,328,206

0.04%
81.35%
93.36%
98.29%
98.71%
99.43%

93.45%
98.80%
99.52%

74,891
141,642,411
162,216,710
170,671,088
171,386,859
172,922,659

162,287,197
171,466,918
173,003,151

0.04%
81.49%
93.32%
98.19%
98.60%
99.48%

93.36%
98.64%
99.53%

tw ≤ 2
tw ≤ 3

118,254,672
118,254,676

100.00%
100.00%

157,183,767
157,183,771

100.00%
100.00%

171,147,726
171,147,730

100.00%
100.00%

173,822,690
173,822,694

100.00%
100.00%

total

118,254,676

100.00%

157,183,771

100.00%

171,147,730

100.00%

173,822,694

100.00%

UNIQUE CQ/graph

Shape

#Queries Relative %

CQF/graph
#Queries Relative %

CQOF/graph
#Queries Relative %

CQOFV/graph
#Queries Relative %

no edge
≤ 1 edge
chain
star
tree
ﬂower

chain set
forest
bouquet

1,279
31,785,575
36,839,344
37,123,785
37,184,810
37,202,015

36,851,176
37,197,115
37,214,357

tw ≤ 2
tw ≤ 3

37,216,150
37,216,153

0.00%
85.41%
98.99%
99.75%
99.92%
99.96%

99.02%
99.95%
100.00%

100.00%
100.00%

1,284
46,480,574
54,131,560
55,417,051
55,487,815
55,892,860

54,150,770
55,509,443
55,914,792

0.00%
83.05%
96.72%
99.02%
99.15%
99.87%

96.76%
99.19%
99.91%

1,284
46,772,128
56,042,768
60,203,786
60,311,400
60,735,713

56,096,837
60,370,204
60,794,835

0.00%
76.82%
92.05%
98.89%
99.06%
99.76%

92.14%
99.16%
99.86%

1,661
48,866,909
58,142,029
62,306,677
62,414,439
63,010,697

58,196,121
62,473,266
63,069,846

0.00%
77.37%
92.06%
98.65%
98.82%
99.77%

92.15%
98.92%
99.86%

55,965,143
55,965,146

100.00%
100.00%

60,881,508
60,881,511

100.00%
100.00%

63,156,533
63,156,536

100.00%
100.00%

total

37,216,153

100.00%

55,965,146

100.00%

60,881,511

100.00%

63,156,536

100.00%

at most one node u such that there exist u1, u2, and
u3, all pairwise diﬀerent and diﬀerent from u, for which
u, ui} ∈
{

E for each i = 1, 2, 3.

Inspired by the results obtained with gMark on syn-
thetic queries, we proceeded with the analysis of the
query logs by looking at the encountered query shapes.
Here, we consider queries as edge-labeled graphs, as de-
ﬁned in Section 5. In the next subsection we also inves-
tigate the hypergraph structure.

Fig. 6 An example of a ﬂower query found in our DBpedia
query logs (we added arrows to indicate the edge directions
in the query; labels are omitted).

A tree is an undirected graph such that, for every
pair of nodes x and y, there exists exactly one undi-
rected path from x to y. (Hence, every chain is also
a tree.) A forest is a graph in which every connected
component is a tree.

A star is a tree for which there exists at most one
node with more than two neighbors, that is, there is

We investigate CQs, CQF queries, CQOF queries,
and CQOFV queries. The last three fragments are inter-
esting in that they bring under scrutiny more queries
than the plain CQ set of query logs (by an increase
of roughly 33% (50%), 44% (64%), and 47% (70%) re-
spectively). We ﬁrst wanted to identify classical query
shapes, such as all variants of tree-like shapes (single
edges, chains, sets of chains, stars, trees, and forests).
The results are summarized in Table 5. From the anal-
ysis, we can draw the following observations. While
tree-shaped queries even in their simple forms (chain
of length 1 or single edges) are very frequent, the only
observed exception occurs with star queries, which have

Table 6 Cumulative shape analysis of graph patterns in CQ, CQF, CQOF, and CQOFV, after removal of IRIs, across all logs.
The relative numbers are w.r.t. the queries that are suitable for graph analysis.

VALID

CQ/graph

Shape

#Queries Relative %

CQF/graph
#Queries Relative %

CQOF/graph
#Queries Relative %

CQOFV/graph
#Queries Relative %

no edge
≤ 1 edge
chain
star
tree
ﬂower

chain set
forest
bouquet

106,952,766
116,643,820
117,774,655
117,876,831
118,235,060
118,243,330

117,785,058
118,245,559
118,253,840

tw ≤ 2
tw ≤ 3

118,254,674
118,254,676

90.44%
98.64%
99.59%
99.68%
99.98%
99.99%

99.60%
99.99%
100.00%

100.00%
100.00%

136,357,792
150,954,951
155,832,073
156,787,151
157,146,906
157,162,189

155,852,116
157,167,354
157,182,660

157,183,769
157,183,771

86.75%
96.04%
99.14%
99.75%
99.98%
99.99%

99.15%
99.99%
100.00%

100.00%
100.00%

144,549,634
160,737,562
167,819,465
170,062,935
170,423,705
170,439,245

167,851,157
170,732,618
170,748,181

84.46%
93.92%
98.06%
99.37%
99.58%
99.59%

98.07%
99.76%
99.77%

144,643,932
163,386,730
170,472,931
172,737,353
173,098,147
173,114,179

170,504,640
173,407,077
173,423,132

83.21%
94.00%
98.07%
99.38%
99.58%
99.59%

98.09%
99.76%
99.77%

171,147,728
171,147,730

100.00%
100.00%

173,822,692
173,822,694

100.00%
100.00%

total

118,254,676

100.00%

157,183,771

100.00%

171,147,730

100.00%

173,822,694

100.00%

UNIQUE CQ/graph

Shape

#Queries Relative %

CQF/graph
#Queries Relative %

CQOF/graph
#Queries Relative %

CQOFV/graph
#Queries Relative %

no edge
≤ 1 edge
chain
star
tree
ﬂower

chain set
forest
bouquet

32,886,654
36,511,703
37,150,107
37,164,017
37,210,340
37,213,881

37,151,726
37,212,024
37,215,574

tw ≤ 2
tw ≤ 3

37,216,152
37,216,153

88.37%
98.11%
99.82%
99.86%
99.98%
99.99%

99.83%
99.99%
100.00%

100.00%
100.00%

47,048,004
52,939,383
55,596,772
55,898,107
55,944,891
55,954,879

55,605,967
55,954,365
55,964,373

55,965,145
55,965,146

84.07%
94.59%
99.34%
99.88%
99.96%
99.98%

99.36%
99.98%
100.00%

100.00%
100.00%

49,453,297
56,293,258
60,134,203
60,743,607
60,791,019
60,801,134

60,148,326
60,834,660
60,844,795

81.23%
92.46%
98.77%
99.77%
99.85%
99.87%

98.80%
99.92%
99.94%

49,490,285
58,562,031
62,405,465
63,018,260
63,065,687
63,076,131

62,419,603
63,109,343
63,119,807

78.36%
92.73%
98.81%
99.78%
99.86%
99.87%

98.83%
99.93%
99.94%

60,881,510
60,881,511

100.00%
100.00%

63,156,535
63,156,536

100.00%
100.00%

total

37,216,153

100.00%

55,965,146

100.00%

60,881,511

100.00%

63,156,536

100.00%

very low occurrence with respect to the other tree-like
shapes.

Since simple queries are overrepresented in query
logs (already over 87.76% (83.23%) of CQF patterns
uses only one triple, for example), it is no surprise that
the overwhelming majority of the queries is acyclic, i.e.,
a forest. However, we also wanted to get a better under-
standing of the more complex queries in the logs, so we
also investigated the cyclic queries. Our goal is to ob-
tain a cumulative shape analysis where simpler shapes
are subsumed by more sophisticated query shapes, with
the latter reaching almost 100% coverage of the query
logs.

A ﬁrst observation was that plain cycles are not very
common. By visually inspecting the remaining cyclic
queries, we observed that many of them could be seen as
a node with simple attachments, which we call ﬂower.

Deﬁnition 8 A petal is a graph consisting of a source
node s, target node t, and a set of at least two node-
disjoint paths from s to t. (For instance, a cycle is a
petal that uses two paths.) A ﬂower is a graph consist-
ing of a node x with three types of attachments: chains

(the stamens), trees that are not chains (the stems),
and petals. As an edge case, we also consider the empty
graph to be a ﬂower.

An example of a real ﬂower query posed by users in one
of our DBpedia logs is illustrated in Figure 6. It consists
of a central node with four petals (one of which using
three paths), ten stamens and zero stems attached.

We also considered sets of ﬂowers, which we called
bouquets, to further increase the ratio of queries that
could be classiﬁed from the original logs. The number
of ﬂowers and bouquets in the query logs only over-
come those of trees and forests by roughly 0.01%–0.09%
(0.03–0.10%) for all the four fragments. Furthermore,
for all fragments, the majority of the cyclic queries is
captured by bouquets.

In the above analysis, we have analyzed the shapes
of queries when the latter are represented as graphs as
deﬁned in Section 5, i.e., the nodes can be either vari-
ables or constants. Constants are in fact helpful for us
to obtain a rough idea of the shape of patterns that
users try to ﬁnd in graphs, but research on query opti-
mization often focuses on the shape of patterns without

constants. (The reason is that constants can typically
be matched to only one node in the graph and therefore
do not highly contribute to the complexity of evalua-
tion.) For that reason, we have rerun the above analy-
sis on queries excluding constants in order to identify
the diﬀerences in the obtained shape classiﬁcation. The
most signiﬁcant observation here is that many shapes
disintegrate to a set of variables (i.e., no more edges
are present in their graph). More precisely, for the four
fragments CQ, CQF, CQOF, and CQOFV, we have that
respectively 90.44% (88.37%), 86.75% (84.07%), 84.46
(81.23%), and 83.21% (78.36%) of the queries that are
suitable for graph analysis have no more edges when
considering the restriction of their canonical graphs to
variables only. This is a huge change, since such shapes
only constituted 0.00%–0.06% of the shapes of queries
with constants in Table 5.

As a ﬁnal remark, we can notice that the shift from
shapes with constants to shapes with only variables is
signiﬁcantly aﬀecting the “no edge” fragment and has
less impact on the other shapes. For the “no edge” frag-
ment, many queries boil down to a set of isolated nodes
or to a singleton when constants are removed. We could
not observe in both Tables huge diﬀerences between the
Valid and Unique query logs, that rather resemble each
other in terms of relative percentages of shapes.

6.2 Tree- and Hypertreewidth

It is well-known that the tree- or hypertreewidth of
queries are important indicators to gauge the complex-
ity of their evaluation. We therefore investigated the
tree- and hypertreewidth of CQ, CQF CQOF, and CQOFV
queries. We do not formally deﬁne tree- or hypertreewidth
in this paper but instead refer to an excellent introduc-
tion [19]. In the terminology of Gottlob et al., we in-
vestigate the treewidth of the graphs of the queries and
the generalized hypertree width of the canonical hyper-
graphs of queries.

Treewidth. All shapes we discussed in Section 6.1 have
treewidth at most two. Forests (and all subclasses thereof)
have treewidth one, whereas ﬂowers and bouquets have
treewidth two. We investigated the remaining queries
using the tool21 JDrasil [7] and discovered that three
queries had treewidth three (one such query is in Fig-
ure 7) and all others had treewidth two, see Table 5.
This new tool let us compute the treewidth of the queries
in our corpus, whereas in the conference version of the
paper we used detkdecomp, which outputs the general-
ized hypertreewidth. The latter can be lower than the

21 Available on https://maxbannach.github.io/Jdrasil/

treewidth, thus the results reported here exhibit more
precision. From the treewidth perspective, it is inter-
esting to note that many queries of treewidth two are
also ﬂowers or bouquets (Deﬁnition 8), which are a very
restricted fragment.

Hypertree Width. We recall that we only considered the
graph of queries for which variables in the predicate po-
sition are not re-used elsewhere (if they occur at all). In
CQOFV, 58,782,592 (17,333,741) queries used a variable
in a predicate condition or a ﬁlter or values condition of
arity more than two, and we therefore considered their
hypergraph structure, without constants, to assess the
cyclicity of these queries. We determined their gener-
alized hypertree width with the tool detkdecomp from
the Hypertree Decompositions home page [17]. Further-
more, we measure the cyclicity of the hypergraphs with-
out constants, as it is usually done in the literature.

Our results are summarized in Table 7, which con-
tains the hypertreewidth of queries from CQ, CQF,
CQOF, and CQOFV that were not yet analysed in Sec-
tion 6.1. Concerning CQs, all the remaining queries had
hypertree width one, except for 68 (56) queries with
hypertree width two and eight queries with hypertree
width three. In the largest fragment, CQOFV, we have
542,409 (242,941) such queries with hypertreewidth two
and nine with hypertreewidth three. So, especially in
the fragment CQOFV, we see a signiﬁcant portion of the
queries that exhibits cyclicity, i.e., 8.03% of the unique
queries. This means that considering Values constructs
indeed can have an impact on the cyclicity of queries.
We also looked at the number of nodes in the hy-
pertree decompositions that the tool gave us, since this
number can be a guide for how well caching can be
exploited for query evaluation [26] (the higher the num-
ber, the better caching can be exploited). For the queries
with hypertree width one, the number of nodes in the
decompositions corresponds to their number of edges,
which can already be seen in Figure 5. (Nevertheless, we
found several hundred queries in CQOFV queries with
100 or more nodes in their hypertree decompositions,
the vast majority occurring in the DBpedia logs.) Fi-
nally, out of the queries with hypertreewidth two, 598
(465) had decompositions of size more than 10, going
up to a maximum of 16. The CQOFV queries of hyper-
treewidth three all had decompositions of size smaller
than 10, except for one query in DBpedia17 which had
a decomposition of size 33.

7 Analysis of the Shapes

In this section, we provide a deeper characterization of
the query shapes found in our large corpus, by present-

Table 7 Hypertreewith (htw ) of the queries that were not analysed in Section 6.1, i.e., queries that use ﬁlter- or values
conditions of arity three or more; or that re-use some variable in the predicate position elsewhere

CQ

CQF

AbsoluteV RelativeV AbsoluteU RelativeU

AbsoluteV RelativeV AbsoluteU RelativeU

htw = 1
htw = 2
htw = 3

4,137,042
68
8

100.00%
0.00%
0.00%

2,338,797
56
8

100.00%
0.00%
0.00%

5,162,377
248,050
8

95.42%
4.58%
0.00%

2,557,651
21,410
8

99.17%
0.83%
0.00%

Total new

4,137,118

100.00%

2,338,861

100.00%

5,410,435

100.00%

2,579,069

100.00%

CQOF

CQOFV

AbsoluteV RelativeV AbsoluteU RelativeU

AbsoluteV RelativeV AbsoluteU RelativeU

htw = 1
htw = 2
htw = 3

26,680,385
249,126
8

99.07%
0.93%
0.00%

2,743,833
21,678
8

99.22%
0.78%
0.00%

26,725,649
542,409
9

98.01%
1.99%
0.00%

2,780,838
242,941
9

91.97%
8.03%
0.00%

Total new 26,929,519

100.00%

2,765,519

100.00%

27,268,067

100.00%

3,023,788

100.00%

Table 8 Analysis of longest paths in chain, star, and tree queries (Valid and Unique queries)

longest path length

#V chain Relative %

#V star Relative % #V tree Relative %

1
2
3
4
5
6
7
8
9
10–23

142,644,649
16,185,787
3,880,284
601,580
1,970
2,132
1,011
1,015
4
8

87.34%

9.91% 7,884,906
376,217
2.38%
264,287
0.37%
6,408
0.00%
136
0.00%
10
0.00%
8
0.00%
7
0.00%
11
0.00%

92.42%
4.41%
59,537
3.10% 284,953
0.08%
14,167
0.00% 385,110
436
0.00%
2
0.00%
0
0.00%
2
0.00%

8.00%
38.29%
1.90%
51.75%
0.06%
0.00%
0.00%
0.00%

total

163,318,440

100.00% 8,531,990

100.00% 744,207

100.00%

longest path length #U chain Relative %

#U star Relative % #U tree Relative %

1
2
3
4
5
6
7
8
9
10–23

49,039,098
6,853,199
2,400,853
76,828
1,333
1,468
1,009
1,011
3
7

84.01%
11.74% 3,833,545
212,739
155,883
901
50
8
8
6
7

4.11%
0.13%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%

91.21%
5.06%
3.71%
0.02%
0.00%
0.00%
0.00%
0.00%
0.00%

17,213
31,779
12,752
48,792
79
2
0
2

15.56%
28.73%
11.53%
44.11%
0.07%
0.00%
0.00%
0.00%

total

58,374,809

100.00% 4,203,147

100.00% 110,619

100.00%

?subject birthPlace

?subject genre

?subject nationality

?object birthPlace

?object nationality

?object genre

Fig. 7 The DBpedia query exhibiting tree width equal to 3

Fig. 8 A tree-shaped query with longest path of length 7 (in
bold) and maximal degree of nodes equal to 4 (for the grey
node).

ing various measures of these shapes. We ﬁrst focus on
chain, tree, and star-shaped queries, which are the most
recurrent shapes in our logs and we identify some mea-

sures for the ensemble of these shapes or separately for
each class. At the end of the Section, we also provide
more insights about the cyclic queries found in our logs.

Table 9 Maximal degree of nodes in star and tree queries (Valid and Unique)

max degree

#V star Relative %

#U star Relative % #V tree Relative % #U tree Relative %

3
4
5
6
7
8
9
10–19
20–29
30–39
40–49
50–59
60–63

5,791,971
1,183,578
350,676
710,511
223,651
78,890
38,711
147,266
2,758
230
64
6
3,678

67.89% 3,173,041
406,272
13.87%
191,479
4.11%
228,573
8.33%
68,179
2.62%
55,056
0.92%
25,152
0.45%
53,067
1.73%
2,077
0.03%
192
0.00%
51
0.00%
6
0.00%
2
0.04%

75.49% 401,873
9.67%
26,154
4.56% 279,092
31,258
5.44%
5,367
1.62%
375
1.31%
47
0.60%
39
1.26%
0.05%
2
0.00%
0.00%
0.00%
0.00%

54.00%
3.51%
37.50%
4.20%
0.72%
0.05%
0.01%
0.01%
0.00%

73,125
2,640
30,844
3,305
589
51
36
27
2

66.11%
2.39%
27.88%
2.99%
0.53%
0.05%
0.03%
0.02%
0.00%

total

8,531,990

100.00% 4,203,147

100.00% 744,207

100.00% 110,619

100.00%

Table 10 Number of high-degree nodes (#HD) in tree
shaped queries (Valid and Unique)

Table 12 Maximal cycle length in cyclic queries

#HD #V tree Relative % #U tree Relative %

2
3
4
5
6
7
9
11

59,537
281,184
14,348
365,318
23,811
7
1
1

8.00%
37.78%
1.93%
49.09%
3.20%
0.00%
0.00%
0.00%

17,213
31,197
12,877
47,920
1,405
5
1
1

15.56%
28.20%
11.64%
43.32%
1.27%
0.00%
0.00%
0.00%

total

744,207

100.00% 110,619

100.00%

Table 11 Average degree of inner nodes (AvgDeg) in tree
shaped queries (Valid and Unique)

AvgDeg #V tree Relative % #U tree Relative %

2–2.9
3–3.9
4–4.9
5–5.9
6–6.9
7–7.9
8–8.9

400,426
308,649
34,514
346
103
157
12

53.81%
41.47%
4.64%
0.05%
0.01%
0.02%
0.00%

61,955
44,358
4,027
160
52
58
9

56.01%
40.10%
3.64%
0.14%
0.05%
0.05%
0.01%

total

744,207

100.00% 110,619

100.00%

An immediate measure of the span of a query shape
is the size of the longest (undirected) path in the query.
Such a measure is readily applicable to chains, stars and
tree-shaped queries. The size of the longest path for a
tree-shaped query is the length of the longest path from
one leaf to another leaf. For instance, if we consider
the tree-shaped query in Figure 8, we observe that its
longest path has length 7 (highlighted in bold). The
same applies to star-shaped queries where the longest
path is the path from one vertex to another traversing
the central node of the star, whereas the longest path
in a chain is the length of the chain itself.

MaxCyc

# Valid # Unique

3
4
5
6
7
8
10

1,455,724
51,308
25,062
3,243
7
1
1

328,118
23,946
5,865
79
7
1
1

total

1,535,346

358,017

Table 13 Minimal cycle length in cyclic queries

MinCyc

# Valid # Unique

3
4
5
6
7
10

1,456,037
51,023
25,048
3,230
7
1

328,347
23,739
5,853
70
7
1

total

1,535,346

358,017

Table 8 reports the lengths of the longest paths in
chain, tree, and star-shaped queries in our logs. We can
notice that the longest paths in chain and star queries
are majorly small (signiﬁcant percentages go up to size
of the longest path equal to 3 for chain queries and to 4
for star queries, respectively), whereas trees are some-
how diﬀerent. Their non-zero percentages characterize
lengths of longest paths up to 6 for tree-shaped queries.
In all shapes, we could ﬁnd some examples of queries
with quite long paths (from length 10 to 23) and these
are comparably higher in chains and stars than in tree-
shaped queries.

We then proceeded with the analysis of the shapes
by focusing on the nodes with the maximal degree of
nodes in star- and tree-shaped queries. In our example
of a tree-shaped query in Figure 8, we can easily see that

Table 14 Free-connex acyclicity (FCA) and htw of all the CQs in our logs.

CQ

CQF

AbsoluteV RelativeV AbsoluteU RelativeU

AbsoluteV RelativeV AbsoluteU RelativeU

FCA 117,669,790
118,245,559
122,391,781
122,391,794

htw ≤ 1
htw ≤ 2
htw ≤ 3

96.14% 36,786,611
96.61% 37,212,024
100.00% 39,555,004
100.00% 39,555,014

93.00%
94.08%
100,00%
100.00%

152,870,355
157,167,354
162,654,843
162,654,856

93.98% 53,393,254
96.63% 55,954,365
100.00% 58,554,583
100.00% 58,554,593

91.19%
95.56%
100.00%
100.00%

Total

122,391,794

100.00% 39,555,014

100.00%

162,654,856

100.00% 58,554,593

100.00%

CQOF

CQOFV

AbsoluteV RelativeV AbsoluteU RelativeU

AbsoluteV RelativeV AbsoluteU RelativeU

FCA 160,545,014
170,732,618
200,641,878
200,641,891

htw ≤ 1
htw ≤ 2
htw ≤ 3

80.02% 55,059,069
85,09% 55,954,365
100.00% 64,857,879
100.00% 64,857,889

84.89%
86.27%
100.00%
100.00%

163,203,235
173,407,077
280,672,718
280,672,732

58.15% 57,331,127
61.78% 63,109,343
100.00% 78,088,783
100.00% 78,088,794

73.42%
80.82%
100.00%
100.00%

Total

200,641,891

100.00% 64,857,889

100.00%

280,672,732

100.00% 78,088,794

100.00%

the maximal degree of nodes is equal to 4. Obviously,
this measure is not informative for chain queries, which
are completely characterized by their length (and whose
vertices have a maximal degree of two). Table 9 shows
the results for stars and tree-shaped queries. The higher
percentages of star queries have maximal degree of their
vertices equal to 3, whereas for tree-shaped queries, the
majority has maximal degree equal to 3 or 5. The high-
est values of maximal degrees can be observed in stars
more than in tree-shaped queries.

We then focused on tree-shaped queries and com-
puted the number of nodes we found with high degrees.
This measure is only applicable to tree-shaped queries
and neither to stars (that always have one node with
highest degree) nor to chains. The results are shown in
Table 10, where we can notice 49.09% (43.32%) of the
tree-shaped queries have 5 high-degree vertices. We also
found one query with 11 high-degree vertices.

We did not dig further into the actual values of the
degrees for these high-degree nodes, even though a com-
bined view of Table 8 and Table 9 provides a quick grasp
on that.

Further investigating the tree shapes, we computed
in Table 11 the average degrees of inner nodes in these
shapes (again not applicable to chains and stars). We
can observe that the majority of inner nodes degrees
stay in between 2 and 4 on average.

Finally, we looked at the class of cyclic queries and
measured the maximal and minimal cycle lengths of
the cycles. The cycle computation considered again the
queries as undirected graphs and aimed at constructing
the cycle basis for such graphs. A cycle basis is formed
from any spanning tree or spanning forest of the given
graph, by selecting the cycles obtained by combining
a path in the tree with a single edge outside the tree.

In order to keep the computation of cycle basis poly-
nomial, we set up an empirical bound (equal to 8) to
the number of cycles that form the cycle basis. We thus
counted the minimal and maximal cycle length of the
discovered cycle basis of each query. Tables 12 and 13
report the results of this analysis for CQOFV queries.

We also computed the property of free-connex acyclic-

ity for CQ, CQF, CQOF and CQOFV. A conjunctive
query is free-connex acyclic if it is acyclic and the set
of its free variables 22 is a connex subset of the join tree
of the query [6]. The join tree of a query corresponds
to the tree-structure of the acyclic hypergraph underly-
ing the query. Free-connex acyclicity is interesting be-
cause it characterizes the conjunctive queries for which
certain kinds of eﬃcient algorithms exist for enumer-
ating their output [6,24] (under standard complexity-
theoretical assumptions). Table 14 shows the results by
comparing the number of all conjunctive queries (in-
cluding those that are not suitable for graph analysis
and thus are not considered in Table 5) and the number
of free-connex acyclic queries found in our logs. We can
notice that the latter are abundant in all the fragments
CQ, CQF, CQOF and CQOFV. For a cross comparison,
we also show the hypertreewidth of all the conjunctive
queries in our logs (and not only those reported in Ta-
ble 5). We can observe that all the CQs in our logs have
htw less or equal to 3.

8 Tree Pattern Queries

Tree pattern queries (e.g., [35,28,16,15]) are a well-
studied query formalism on trees which is inspired on

22 The free or distinguished variables of a query considered
as a ﬁrst-order propositional formula are the set of variables
used as output in the formula.

XPath but which can just as well be used for query-
ing graph-structured data [31,15].We next deﬁne a tree-
pattern-like fragment of our queries and investigate how
common it appears in the logs.

Property paths have the power to do forward and
backward navigation through edges. For instance, if a
is an IRI, then the property path ˆa allows to follow an
a-edge in the graph in backward direction. In the fol-
lowing deﬁnition, we only allow forward navigation. A
directed tree is a connected, directed graph such that
there is a unique node without incoming edges (the
root) and, for all edges (u, v) and (u(cid:48), v), we have that
u = u(cid:48) (every node has at most one parent).

Deﬁnition 9 A conjunctive regular path query (CRPQ)
is a SPARQL pattern that only uses triple patterns, the
operator And, and property paths.

The directed canonical graph of a CRPQ P is the di-
rected graph obtained from the edges E
Ep, where
(x, (cid:96), y) is a triple pattern in P and
E =
(cid:96)
(x, pp, y) is a property
path pattern in P

{
∈ I ∪ V}

and Ep =

(x, y)

(x, y)

∪

{

|

|

.
}

Deﬁnition 10 A CRPQ P is a tree pattern query if

– its directed canonical graph is a directed tree and
– every property path is a concatenation of IRIs and
property paths of the form a∗, where a is an IRI.

Our analysis shows that 99.77% (99.91%) of the CR-
PQs have a canonical graph that is an undirected tree.
Out of these, 87.92% (84.96%) are tree pattern queries.
This is a fairly signiﬁcant number, considering that we
require the shape to be a directed tree. If we addition-
ally allow the Filter operator (in a similar way as in
Section 6), these percentages remain roughly the same.

9 Property Paths

We found 1,412,762 (329,984) queries using property
paths in our corpus. From these queries, we extracted
1,528,701 (404,721) property paths in total, which is
about 67% more than the 247,404 unique property paths
considered in [11]. Although property paths are there-
fore rare in relation to the entire corpus, this is not so
for every data set: 92 queries (29.87%) in Wikidata17
have property paths.23

A large fraction of these property paths are ex-
tremely simple. For instance, 65,693 (63,428) property
paths are !a (“follow an edge not labeled a”) and 80,421

23 Even though our set of Wikidata queries is very small,
Malyshev et al. [32] recently found a similar percentage of
property path usage in Wikidata logs consisting of ∼ 480M
valid queries.

(58,156) are ˆa (“follow an a-edge in reverse direction”).
In total, 65,751 (63,478) queries use the diﬀerent-from
operator “!” and 394,726 (144,569) use the reverse nav-
igation operator “ˆ”.

In Table 15, we present an overview of all the prop-
erty paths we found in the corpus. For readability, we
don’t explicitly denote the concatenation operator “/”,
so we write ab instead of a/b. In our classiﬁcation, we
treat ˆa and !a the same as a literal. For instance, we
ak with k = 2.
classify ab, (ˆa)b, and (!a)b all as a1 · · ·
We use capital letters to denote subexpressions that
b)
can match a set of diﬀerent IRIs. For example, (a
|
can match a and b, i.e., a set of two symbols. In the
column Set Sizes, we wrote these sizes of sets we found.
If the expression uses the !-operator, it can actually be
matched by an inﬁnite number of IRIs and can be seen
as a wildcard test. (Some users even write the expres-
sion (!a
!b) to obtain a wildcard that can match any
|
IRI.) If we found expressions that use the !-operator,
we annotate this with (wc) in the Set Sizes column.

Furthermore, each row represents the expression type
listed on the left plus its symmetric form. For instance,
when we write a∗b, we count the expressions of the form
a∗b and ba∗. The variant listed in the table is the one
that occurred most often in the data. That is, a∗b oc-
curred more often than ba∗.

In the new corpus, we could enumerate a total of
111 diﬀerent property paths, regrouped into 35 classes.
This corresponds to an increase of roughly one third in
the number of diﬀerent property paths and classes (re-
spectively equal to 87 and 22 in the conference version
of this paper [11].) The occurrences of classes already
found in [11] is roughly preserved in the new corpus if
we focus on Unique queries. However, the new analysis
presented here includes the percentages of occurrences
in the logs of Valid queries, which is interesting by it-
self. For instance, the transitive closure of a single label
a+ is quite prominent in the Valid queries (more than
40% compared to 2% in the logs of Unique queries in
the previous corpus).

Bagan et al. [5] proved a dichotomy on the data
complexity of evaluating property paths under a simple
path semantics, i.e., expressions can only be matched
on paths in the RDF graph in which nodes appear only
once. They showed that, although evaluating property
paths under this semantics is NP-complete in general,
it is possible in Ptime if the expressions belong to a
class called Ctract. Remarkably, we only found eight ex-
pressions in our corpus which are not in Ctract, namely
(ab)∗ (once) and ab(ab)∗ (seven times). The complex-
ity of enumerating answers to property paths of the
form as in Table 15 is studied in [34]. More precisely,
the paper investigates enumeration problems for simple

Table 15 Structure of property paths in our corpus. Capital letters denote unions of symbols or wildcards.

Expression Type AbsoluteV

RelativeV

AbsoluteU

RelativeU

Set Sizes Values for k

a+
A∗
a∗
a∗b
a∗b∗
A∗B?
abc∗
(ab∗)|c
a∗b?
A+
ab(ab)∗
a+|b+
Ab∗
aB∗
a|b∗
a|b+
A+B?
A∗B
A∗bc
a?b∗
(ab)∗

A
a1 · · · ak
ˆa
a?
a1? · · · ak?
a1? · · · ak−1?ak
aB?
ab?c?d
Ab
AB
a|ba|c|d
A?
abc?d?
AAAAAA

618,459
361,402
160,628
23,523
14,674
7,252
70
45
45
19
7
3
2
2
2
2
1
1
1
1
1

139,662
109,166
80,421
9,864
2,704
664
40
12
8
7
6
4
2
1

Total

1,528,701

40.46%
23.64%
10.51%
1.54%
0.96%
0.47%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%

9.14%
7.14%
5.26%
0.65%
0.18%
0.04%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%

100%

5,968
89,379
68,681
20,566
997
1,326
54
15
15
18
7
3
1
2
2
2
1
1
1
1
1

129,515
25,431
58,156
3,347
971
197
34
10
6
4
2
4
2
1

404,721

1.47%

≤ 5

22.08% ≤ 4 (wc)
16.97%
5.08%
0.25%
0.33%
0.01%
0.00%
0.00%
0.00% ≤ 7 (wc)
0.00%
0.00%
0.00% ≤ 1 (wc)
0.00% ≤ 2 (wc)
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%

≤ 5
≤ 5
= 5

32.00% ≤ 6 (wc)

≤ 2

6.28%
14.37%
0.83%
0.24%
0.05%
0.01%
0.00%
0.00%
0.00%
0.00%
0.00% ≤ 2 (wc)
0.00%
0.00%

≤ 2
≤ 2

= 2

100%

≤ 6

≤ 5
≤ 3

transitive expressions, which capture 99.03% (99.74%)
of the expressions in Table 15.

10 Evolution of Queries over Time

In a typical usage scenario of a SPARQL endpoint, a
user queries the data and gradually reﬁnes her query
until the desired result is obtained. In this section, we
analyse to which extent such behavior occurs. The re-
sults are very preliminary but show that, in certain con-
texts, it can be interesting to investigate optimization
techniques for sequences of similar queries.

We consider a query log to be an ordered list of
queries q1, . . . , qn. We introduce the notion of a streak,
which intuitively captures a sequence of similar queries
within close distance of each other. To this end we as-
sume the existence of a similarity test between two
queries. We then say that queries qi and qj with i < j

match if (1) qi and qj are similar and (2) no query qi(cid:48)
with i < i(cid:48) < j is similar to qi. A streak (with window
size w) is a sequence of queries qi1, . . . , qik such that,
for each (cid:96) = 1, . . . , k
w
and qi(cid:96)+1 matches qi(cid:96).

1, we have that i(cid:96)+1 −

i(cid:96) ≤

−

In theory, it is possible for a query to belong to
multiple streaks. E.g., it is possible that q1 and q2 do
not match, but query q3 is suﬃciently similar to both.
In this case, q3 belongs to both streaks q1, q3 and q2, q3.
In the present study, we used Levenshtein distance
as a similarity test. More precisely, we said that two
queries are similar if their Levenshtein distance, after
removal of namespace preﬁxes, is at most 25%.24 We
removed namespace preﬁxes prior to measuring their
Levenshtein distance, because they introduce superﬁ-
cial similarity. As such, we require queries to be at least
75% identical starting from the ﬁrst occurrence of the

24 We normalized the measure by dividing the Levenshtein
distance by the length of the longer string.

Table 16 Length of streaks in three single-day logs

Table 17 Largest query occurring in streaks

Streak length #DBP’14 #DBP’15 #DBP’16

Max

Max

1–10
11–20
21–30
31–40
41–50
51–60
61–70
71–80
81–90
91–100
>100

42,272
3,732
2,425
884
283
88
27
15
5
5
4

167,292
24,001
4,813
667
162
40
8
4
1
0
0

199,375
37,402
17,749
5,849
1,998
711
322
129
47
27
24

#Triples #Streaks

#Triples #Streaks

1
2
3
4
5
6
7
8
9
10
11
12

130,706
41,811
34,081
9,990
3,325
1,733
8,465
10,604
7,837
1,080
51,521
43,819

13–20
21–30
31–40
41–50
51–60
61–70
71–80
81–90
91–100
101–110
> 110

9,509
544
233
86
44
32
17
11
3
9
7

keywords Select, Ask, Construct, or Describe. We took a
window size of 30.

Streak Length. Since the discovery of streaks was ex-
tremely resource-consuming, we only analysed streaks
in three randomly selected log ﬁles from DBpedia14,
DBpedia15, and DBpedia16. The sizes of these log ﬁles,
each reﬂecting a single day of queries to the endpoint,
were 273MiB, 803MiB, and 1004MiB respectively.

For the ordering of the queries, we simply considered
the ordering in the log ﬁles, since the logs are sorted
over time.

The results on streak length are in Table 16. Using
window size 30, the longest streak we found had length
169 and was in the 2016 log ﬁle. When we increased
the window size, we noticed that it was still possible to
obtain longer streaks. We believe that a more reﬁned
analysis on the encountered streaks can be carried out
when tuning the window size and deriving more com-
plex metrics on the similarity of the queries within each
streak. These issues are, however, subject of further re-
search, which we plan to pursue in future work.

Evolution of Size and Structure. In addition to the length
of streaks, we also investigated how the number of triples
and structure of queries in streaks change over time. To
this end, we needed to parse the queries in streaks. The
three log ﬁles contain a combined amount of 510,361
streaks. Out of these streaks, 321,042 have at least two
queries and 234,627 additionally have at least one query
that parses. Remarkably, in the latter set, only 1,402
streaks have an erroneous query. Here, 1,202 have an
erroneous query followed by a correct one, and 789 have
a correct query followed by an erroneous one.

We then investigated the number of triples of queries
in streaks. We have 355,466 streaks which have at least
one parsable query that contains at least one triple.25

25 For 88,201 streaks, all queries had an empty body. An-
other 31 streaks had a non-empty body, containing no triples.

Table 18 Structures of queries appearing in the same streak
(chn = chain, bt = ’branching tree’, i.e., tree that is not a
chain, cyc = cyclic)

Shapes

#Streaks

containing chn
consisting only of chn
containing bt
consisting only of bt
containing cyc
consisting only of cyc

containing bt and cyc
consisting only of bt or cyc
containing bt and chn
consisting only of bt or chn
containing chn and cyc
consisting only of chn or cyc

consisting only of chn, bt, or cyc

148,632
147,106
39,839
39,810
526
493

12
40,315
2
186,918
21
147,620

187,444

Table 17 contains, for each of the 355,466 streaks, what
is the maximal number of triples in any of its queries.
We noticed that this number is quite stable: we only
have 3,915 streaks in which this number changes during
the streak.

Table 18 contains results on the shapes of queries in
streaks. We considered chain queries, trees that branch
(and therefore are no chains), and cyclic queries, that is,
queries that contain a cycle. Table 18 contains, for each
subset S of these three shapes, the number of streaks
that contain only shapes from S and the number of
streaks that consist only of shapes from S.

Interestingly, we found a correlation between streak
length and query shape and size. For instance, out of the
526 streaks that contain a cyclic query, 472 (89.73%)
only consist of a single query. This strongly contrasts
the entire log, where only 189,319 streaks (37.10%) con-
sist of a single query. Similarly, we have 1,378 streaks
that contain a query of at least 16 triples, but 1,332 of
these streaks (96.66%) only have a single query. This
suggests that highly complex queries are less likely to

occur in longer streaks. We stress again that the data
sets used for this study only consisted of DPpedia query
logs for three days, which is a very small sample. We
leave the evaluation on the total corpus for future work.

11 Conclusions and Discussion

We have conducted an extensive analytical study on a
large corpus of real SPARQL query logs. Our corpus is
inherently heterogeneous and consists of a majority of
DBpedia query logs along with query logs on biological
datasets (namely BioPortal and BioMed datasets), ge-
ological datasets (LGD), bibliographic data (SWDF),
and query logs from a museum’s SPARQL endpoint
(British Museum). We have completed this corpus with
the example queries from Wikidata (Feb. 2017), which
are cherry picked from real SPARQL queries on this
data source. Compared to the conference version of
this paper, we have augmented the corpus with 169M
queries from DBpedia, which let us almost double the
size of the corpus and also corroborate or deﬂect some
of the insights gained before on the old logs. Further-
more, novel non-trivial analyses have been run as also
recapitulated in this concluding section.

A Note on Query Logs and Interpretation of Results.
When one wants to draw conclusions from our anal-
yses, one always needs to keep in mind what kind of
data we analysed, in order to put the conclusions in
the right perspective. In this paper, we mainly anal-
ysed query logs from SPARQL endpoints. We believe
that this means that simple queries may be overrepre-
sented. For instance, some users may decide to down-
load a local copy of the database to their own server
and process the complex queries locally, e.g., to avoid
time-out issues with the public SPARQL endpoint.

Another point to keep in mind is that we believe
that it is diﬃcult to conclude from such a log analysis
that certain types of queries are not interesting. Again,
this is due to the open-world nature of the logs. There
can be very interesting types of queries, that some users
are highly interested in, but that are absent from the
logs.

What one can discover in our analysis is classes of
queries, or aspects (such as sequences of queries) that
are interesting for future research. After all, the queries
we studied here are indeed precisely the ones that have
been submitted to SPARQL endpoints, which makes
them interesting.

Considerations About the Datasets. The majority of the
datasets exhibit similar characteristics, such as for in-
stance the simplicity of queries amounting to 1 or 2

triples. The only exception occurs with British Museum
and Wikidata datasets (Figure 1), where the former is
a set of queries generated from ﬁxed templates and the
latter is a query wiki rather than a query log. Clearly,
the DBpedia datasets are the most voluminous and re-
cent in our corpus, thus making their results quite sig-
niﬁcant. For instance, despite the fact that single triple
queries are numerous in these datasets, more complex
queries (with 11 triples or more) have lots of occur-
rences (up to 21% of the total number of queries for
DBpedia13). Strikingly, the largest queries of all belong
to DBpedia (especially the last logs newly analyzed in
this paper), which is one of the outcome of the new
comparison between Valid and Unique queries, as car-
ried out in this paper and could not be observed before
in [11], which only focused on Unique queries.

We observed that most of the analyzed queries across
all datasets are Select/Ask/Construct, which range be-
tween 94% and 100% for all datasets except DBpedia16,
BioMed, and SWDF, which have 88% or less. There-
fore, we focused on such queries in the remainder of
the paper since these queries turn out to be the queries
that users most often formulate in SPARQL query end-
points. We have further examined the occurrences of op-
erator distributions and the number of projections and
subqueries. This analysis lets us address a speciﬁc frag-
ment, namely the And/Opt/Filter patterns (AOF pat-
terns). For such patterns, we derived the graph- and
hypergraph structures and analyzed the impact of the
structure on query evaluation.

Beneﬁts of Shape Analysis. We synthetically reproduced
the observed real chain and cycle query logs with a
synthetic generator by building diverse workloads of
Ask queries and measured their average runtime in two
systems, Blazegraph, used by the Wikimedia founda-
tion, and PostgreSQL. In both systems, the diﬀerence
between average performances of such diﬀerent query
shapes are perceivable. We decided to dig deeper in
the shape analysis in order to classify these queries un-
der general query shapes as canonical graphs and char-
acterize their tree-likeness as hypergraphs. We believe
that this shape analysis can serve the need of fostering
the discussion on the design of new query languages
for graph data [10,44], as pursued for instance by the
LDBC Graph Query Language Task Force [43]. It can
also inspire the conception of novel query optimization
techniques suited for these query shapes, along with
tuning and benchmarking methods. For instance, we
are not aware of existing benchmarks targeting ﬂowers
and ﬂower sets. The analysis on property paths showed
that these are not yet widely used in the entire corpus,
even though they are numerous in the Wikidata corpus.

A recent discussion (July 6th, 2017) in a Neo4J working
group [48] concerned the support of full-ﬂedged regu-
lar path queries in OpenCypher. This discussion, and
other discussions on standard graph query languages
[43, 10, 44] could beneﬁt from our analysis, devoted to
ﬁnd which property paths are actually used most often
when ordinary users have the power of regular expres-
sions. On both shape analysis and property path analy-
sis, the addition of the new DBpedia17 logs provided us
with both (1) conﬁrmation of the trends observed be-
fore on a restricted corpus [11]; (2) new insights due to
the injection of new logs. Concerning the shape anal-
ysis, we introduced a new class (no edge) leading to
classify queries consisting of isolated nodes, such class
being inﬂated when constants are disregarded in the
analysis. Furthermore, the shapes of Valid queries stud-
ied for the ﬁrst time in this paper are comparably more
complex than the shapes of Unique queries. Precisely,
we have observed that Valid queries exhibit on aver-
age longer paths and higher degree nodes compared to
their Unique counterparts. For the property paths, we
could conﬁrm the presence of classes observed before
with most occurrences but also introduce entirely new
classes due to the presence of more diversiﬁed DBpedia
query logs.

Beneﬁts of Streak Analysis. Finally, we performed a
study on the way users specify their queries in SPARQL
query logs, by identifying streaks of similar queries.
This analysis is for instance crucial to understand query
speciﬁcation from real users and thus usability of data-
bases, which is a hot research topic in our community
[25,38].

Extensibility. Our analysis has been carried out with
scripts in diﬀerent languages, amounting to a total of
roughly 9, 000 source lines of code (SLOC). We plan
to make these scripts open-source and extensible to
the new query logs that will be produced by users on
SPARQL endpoints in the near future.

Future Work. A preliminary investigation on our data
set showed that a shape analysis that incorporates prop-
erty paths (and therefore considering extensions of CR-
PQs instead of CQs) may reveal interesting results. For
instance, we found a 7-clique query (6-clique without
constants) similar to the one in Figure 9. We also found
this particular query interesting because we believe that
its semantics is probably diﬀerent from what the user
intended. We believe that the user wanted to search for
(possibly all permutations of) six diﬀerent spouses of
Henry VIII. However, “!dbpedia-owl:sameAs” tests if

?Spouse2

?Spouse1

Henry VIII

?Spouse3

?Spouse4

?Spouse6

?Spouse5

Fig. 9 The Henry VIII query, a 7-clique containing one con-
stant and six variables. All edges between Henry VIII and the
variables are labeled “dbpedia-owl:spouse” and all edges be-
tween variables are labeled with the property path “!dbpedia-
owl:sameAs”.

there exists an edge between two nodes that is not clas-
siﬁed as dbpedia-owl:sameAs. We embarked on a study
for Wikidata query logs in [12].

Acknowledgments

We would like to acknowledge USEWOD and Patrick
van Kleef together with the team of OpenLink Software
for hosting the oﬃcial DBPedia endpoint and granting
us the access to the large DBpedia query logs analysed
in this paper. We thank Stijn Vansummeren for his sug-
gestion to investigate free-connex acyclicity of queries.

References

1. C. R. Aberger, S. Tu, K. Olukotun, and C. R´e. Emp-
tyHeaded: A relational engine for graph processing. In
International Conference on Management of Data (SIG-
MOD), pages 431–446, 2016.

2. C. R. Aberger, S. Tu, K. Olukotun, and C. R´e. Old tech-
niques for new join algorithms: A case study in RDF pro-
cessing. In International Conference on Data Engineering
(ICDE) Workshops, pages 97–102, 2016.

3. M. Arias, J. D. Fern´andez, M. A. Mart´ınez-Prieto, and
P. de la Fuente. An empirical study of real-world
SPARQL queries. CoRR, abs/1103.5043, 2011.

4. G. Bagan, A. Bonifati, R. Ciucanu, G. H. L. Fletcher,
A. Lemay, and N. Advokaat. gmark: Schema-driven gen-
eration of graphs and queries. IEEE Trans. Knowl. Data
Eng., 29(4):856–869, 2017.

5. G. Bagan, A. Bonifati, and B. Groz. A trichotomy for
regular simple path queries on graphs. In Principles of
Database Systems (PODS), pages 261–272, 2013.

6. G. Bagan, A. Durand, and E. Grandjean. On acyclic
conjunctive queries and constant delay enumeration. In
Computer Science Logic (CSL), pages 208–222, 2007.
7. M. Bannach, S. Berndt, and T. Ehlers. Jdrasil: A modu-
lar library for computing tree decompositions. In 16th In-
ternational Symposium on Experimental Algorithms (SEA),
pages 28:1–28:21, 2017.

8. P. Barcel´o, R. Pichler, and S. Skritek. Eﬃcient evalu-
ation and approximation of well-designed pattern trees.
In Principles of Database Systems (PODS), pages 131–144,
2015.

9. A. Bielefeldt, J. Gonsior, and M. Kr¨otzsch. Practical
linked data access via SPARQL: the case of wikidata. In
Workshop on Linked Data (LDOW), 2018.

10. A. Bonifati, G. H. L. Fletcher, H. Voigts, and
N. Yakovets. Querying Graphs. Synthesis Lectures on
Data Management. Morgan & Claypool Publishers, 2018.
11. A. Bonifati, W. Martens, and T. Timm. An analytical
study of large SPARQL query logs. PVLDB, 11(2):149–
161, 2017.

12. A. Bonifati, W. Martens, and T. Timm. Navigating the
maze of Wikidata query logs. In The World Wide Web
Conference (WWW), pages 127–138, 2019.

13. A. Chandra and P. Merlin. Optimal implementation of
conjunctive queries in relational data bases. In Sympo-
sium on the Theory of Computing (STOC), pages 77–90,
1977.

14. C. Chekuri and A. Rajaraman. Conjunctive query
In International Conference on

containment revisited.
Database Theory (ICDT), pages 56–70, 1997.

15. W. Czerwi´nski, W. Martens, M. Niewerth, and P. Parys.
Minimization of tree patterns. J. ACM, 65(4):26:1–26:46,
2018.

16. W. Czerwi´nski, W. Martens, P. Parys, and M. Przybylko.
The (almost) complete guide to tree pattern contain-
ment. In ACM Symposium on Principles of Database Sys-
tems (PODS), pages 117–130, 2015.

17. detkdecomp. wwwinfo.deis.unical.it/~frank/Hypertrees.

Visited on August 10th, 2016.

18. G. Gottlob, G. Greco, N. Leone, and F. Scarcello. Hyper-
tree decompositions: Questions and answers. In Principles
of Database Systems (PODS), pages 57–74, 2016.

19. G. Gottlob, G. Greco, and F. Scarcello. Treewidth and
hypertree width. In Tractability: Practical Approaches to
Hard Problems, pages 3–38. Cambridge University Press,
2014.

20. G. Gottlob, N. Leone, and F. Scarcello. Hypertree de-
compositions and tractable queries. J. Comput. Syst. Sci.,
64(3):579–627, 2002.

21. X. Han, Z. Feng, X. Zhang, X. Wang, G. Rao, and
S. Jiang. On the statistical analysis of practical SPARQL
queries. In WebDB, page 2, 2016.

22. S. Harris and A. Seaborne. SPARQL 1.1 query lan-
guage. Technical report, World Wide Web Consor-
tium (W3C), March 2013. https://www.w3.org/TR/2013/
REC-sparql11-query-20130321.

23. J. Huelss and H. Paulheim. What SPARQL query logs
tell and do not tell about semantic relatedness in LOD
— or: The unsuccessful attempt to improve the browsing
experience of DBpedia by exploiting query logs. In ESWC
Satellite Events, pages 297–308, 2015.

24. M. Idris, M. Ugarte, and S. Vansummeren. The dynamic
yannakakis algorithm: Compact and eﬃcient query pro-
cessing under updates.
In International Conference on
Management of Data (SIGMOD), pages 1259–1274, 2017.
25. H. V. Jagadish, A. Chapman, A. Elkiss, M. Jayapandian,
Y. Li, A. Nandi, and C. Yu. Making database systems us-
able. In International Conference on Management of Data
(SIGMOD), pages 13–24, 2007.

26. O. Kalinsky, Y. Etsion, and B. Kimelfeld. Flexible
caching in trie joins.
In International Conference on
Extending Database Technology (EDBT), pages 282–293,
2017.

27. M. Kaminski and E. V. Kostylev. Beyond well-designed
SPARQL. In International Conference on Database Theory
(ICDT), pages 5:1–5:18, 2016.

28. B. Kimelfeld and Y. Sagiv. Revisiting redundancy and
minimization in an XPath fragment.
In International
Conference on Extending Database Technology (EDBT),
pages 61–72, 2008.

29. M. Kr¨oll, R. Pichler, and S. Skritek. On the complexity of
enumerating the answers to well-designed pattern trees.
In International Conference on Database Theory (ICDT),
pages 22:1–22:18, 2016.

30. A. Letelier, J. P´erez, R. Pichler, and S. Skritek. Static
analysis and optimization of semantic web queries. ACM
Trans. Database Syst., 38(4):25:1–25:45, 2013.

31. L. Libkin, W. Martens, and D. Vrgoc. Querying graphs

with data. J. ACM, 63(2):14:1–14:53, 2016.

32. S. Malyshev, M. Kr¨otzsch, L. Gonz´alez, J. Gonsior, and
A. Bielefeldt. Getting the most out of wikidata: Semantic
technology usage in wikipedia’s knowledge graph. In In-
ternational Semantic Web Conference (ISWC), pages 376–
394, 2018.

33. W. Martens and J. Niehren. On the minimization of
XML schemas and tree automata for unranked trees. J.
Comput. Syst. Sci., 73(4):550–583, 2007.

34. W. Martens and T. Trautner. Enumeration problems for
regular path queries. CoRR, abs/1710.02317, 2017.
35. G. Miklau and D. Suciu. Containment and equivalence
for a fragment of xpath. J. ACM, 51(1):2–45, 2004.
36. K. M¨oller, M. Hausenblas, R. Cyganiak, S. Handschuh,
and G. Grimnes. Learning from linked open data usage:
Patterns & metrics. In Web Science Conference (WSC),
2010.

37. M. Morsey, J. Lehmann, S. Auer, and A. N. Ngomo. DB-
pedia SPARQL benchmark — performance assessment
with real queries on real data. In International Semantic
Web Conference (ISWC), pages 454–469, 2011.

38. A. Nandi and H. V. Jagadish. Guided interaction: Re-
thinking the query-result paradigm. PVLDB, 4(12):1466–
1469, 2011.

39. T. Neumann and G. Weikum. The RDF-3X engine for
scalable management of RDF data. VLDB J., 19(1):91–
113, 2010.

40. J. P´erez, M. Arenas, and C. Gutierrez. Semantics and
complexity of SPARQL. ACM Trans. Database Syst.,
34(3):16:1–16:45, 2009.

41. F. Picalausa and S. Vansummeren. What are real
SPARQL queries like? In International Workshop on Se-
mantic Web Information Management (SWIM), pages 1–7,
2011.

42. M. Saleem, I. Ali, A. Hogan, Q. Mehmood, and A.-
C. Ngonga Ngomo. LSQ: The linked SPARQL queries
dataset.
In International Semantic Web Conference
(ISWC), pages 261–269, 2015.

43. http://ldbcouncil.org.
44. https://databasetheory.org/node/47.
45. http://wikidata.org.
46. http://wiki.dbpedia.org/datasets.
47. http://www.blazegraph.com.
48. http://www.opencypher.org/ocig2.
49. http://www.postgresql.org.
50. M. Vidal, E. Ruckhaus, T. Lampo, A. Mart´ınez, J. Sierra,
and A. Polleres. Eﬃciently joining group patterns in
SPARQL queries. In Extended Semantic Web Conference
(ESWC), pages 228–242, 2010.

51. D. Vrandecic and M. Kr¨otzsch. Wikidata: a free col-
laborative knowledgebase. Commun. ACM, 57(10):78–85,
2014.

