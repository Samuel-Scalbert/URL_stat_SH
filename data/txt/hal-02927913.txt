Answering Counting Queries over DL-Lite Ontologies
Meghyn Bienvenu, Quentin Manière, Michaël Thomazo

To cite this version:

Meghyn Bienvenu, Quentin Manière, Michaël Thomazo. Answering Counting Queries over DL-Lite
Ontologies. IJCAI 2020 - Twenty-Ninth International Joint Conference on Artificial Intelligence, Jul
2020, Yokohama, Japan. ￿hal-02927913￿

HAL Id: hal-02927913

https://inria.hal.science/hal-02927913

Submitted on 2 Sep 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Answering Counting Queries over DL-Lite Ontologies

Meghyn Bienvenu1 , Quentin Mani`ere1 and Micha¨el Thomazo2
1University of Bordeaux, CNRS, Bordeaux INP, LaBRI, Talence, France
2Inria, DI ENS, ENS, CNRS, University PSL, Paris, France
{meghyn.bienvenu, quentin.maniere}@u-bordeaux.fr, michael.thomazo@inria.fr

Abstract

Ontology-mediated query answering (OMQA) is
a promising approach to data access and integra-
tion that has been actively studied in the knowl-
edge representation and database communities for
more than a decade. The vast majority of work
on OMQA focuses on conjunctive queries, whereas
more expressive queries that feature counting or
other forms of aggregation remain largely unex-
plored. In this paper, we introduce a general form
of counting query, relate it to previous proposals,
and study the complexity of answering such queries
in the presence of DL-Lite ontologies. As it fol-
lows from existing work that query answering is in-
tractable and often of high complexity, we consider
some practically relevant restrictions, for which we
establish improved complexity bounds.

1 Introduction
Ontology-mediated query answering (OMQA) utilizes on-
tologies to provide a convenient vocabulary for query for-
mulation and to capture domain knowledge that is exploited
during the querying process to obtain more complete sets
of answers [Poggi et al., 2008; Bienvenu and Ortiz, 2015;
Xiao et al., 2018]. Much of the work on OMQA considers
ontologies formulated using description logics (DLs), a fam-
ily of knowledge representation languages that provide the
logical foundations of the OWL web ontology language. Par-
ticular attention has been to the DL-Lite family of DLs [Cal-
vanese et al., 2007], which were developed with OMQA in
mind and enjoy favorable computational properties.

The vast majority of work on OMQA supposes that user
queries are given as conjunctive queries (CQs). However,
there are many other kinds of database queries, beyond plain
CQs, that are relevant in practice. This motivates research
into the feasibility of adopting other database query lan-
guages for OMQA. While enriching CQs with either negated
atoms or inequalities has been shown to lead to undecidabil-
ity even in very restricted settings [Guti´errez-Basulto et al.,
2015], the situation is more positive for navigational queries
(like regular path queries), which can be adopted without los-
ing decidability, sometimes even retaining tractable data com-
plexity [Bienvenu et al., 2015b].

Aggregate queries, which use numeric operators (e.g.
count, sum, max) to summarize selected parts of a dataset,
constitute another prominent class of database queries. Al-
though such queries are widely used for data analysis, they
have been little explored in context of OMQA. This may
be partly due to the fact that it is not at all obvious how to
deﬁne the semantics of such queries in the OMQA setting.
A ﬁrst exploration of aggregate queries in OMQA was con-
ducted by Calvanese et al. (2008). They argued that the most
straightforward adaptation of classical certain answer seman-
tics to aggregate queries was unsatisfactory, as often values
would differ from model to model, leading to no certain an-
swers. For this reason, an epistemic semantics was proposed,
in which variables involved in the aggregation are required to
match to data constants. However, as discussed in [Kostylev
and Reutter, 2015], this semantics can also give unintuitive
results by ignoring ways of mapping aggregate variables to
anonymous elements inferred due the ontology axioms. For
instance, if no children of alex are listed in the data, then a
query that asks to return the number of children will yield
0 under epistemic semantics, even if it can be inferred (e.g.
due to a family tax beneﬁt) that there must be at least 3 chil-
dren. This led Kostylev and Reutter to deﬁne an alternative
semantics for two kinds of counting queries (inspired by the
COUNT and COUNT DISTINCT in SQL) which adopts a
form of certain answer semantics but considers lower and up-
per bounds on the count value across different models. For
the two considered logics (DL-Litecore and DL-LiteR), only
the lower bounds on the count value are non-trivial, and a
complexity analysis shows that they are challenging to iden-
tify: coNP-data complexity for both logics, and Πp
2-hard
(resp. coNEXP-hard) in combined complexity for DL-Litecore
(resp. DL-LiteR). Several question were left unanswered by
their work, including the exact combined complexity, the dif-
ﬁculty of recognizing the optimal lower bound, and the im-
pact of allowing multiple aggregation variables.

This paper returns to the issue of handling counting queries

in OMQA and makes several important contributions:

1. We propose a new notion of counting CQ that general-
izes the two forms of queries from [Kostylev and Reutter,
2015] and allows arbitrarily many counting variables.
2. We show that existing complexity results for DL-Litecore
and DL-LiteR KBs continue to hold for our more general
notion of counting CQ, and provide an improved coNEXP

upper bound for the relevant case of ﬁnite-depth TBoxes.
3. We consider the impact of restricting the query structure,
focusing on the class of rooted queries, in which every
query variable must be connected to an answer variable
or individual in the query graph. A recent result, obtained
as part of a study of bag semantics for OMQA, identiﬁed
a case in which rootedness leads to tractable data com-
plexity for counting queries [Nikolaou et al., 2019]. This
motivates us to perform a more thorough investigation of
rooted counting queries, which yields several improve-
ments upon existing complexity bounds.

4. We prove that the problem of identifying the best certain

interval is DP-complete in data complexity.

Our results close some questions that were left open by the
work of Kostylev and Reutter and pave the way for further
study of counting and aggregate queries in the OMQA setting.
An appendix with full proofs can be found in the long ver-

sion of this paper, available on arXiv.

2 Preliminaries
We recall the basics of description logics (DLs), focusing on
DL-Lite, see [Baader et al., 2017] for more details.
Syntax and Semantics. A description logic vocabulary
consists of a set NC of atomic concepts (unary predicates), a
set NR of atomic roles (binary predicates), and a set NI of indi-
vidual names (constants). By role, we mean either an atomic
role P ∈ NR or an inverse role P − (where P ∈ NR). We let
N±
R denote the set NR ∪ {P − | P ∈ NR} of roles and use the
notation R− to mean P − if R = P ∈ NR and P if R = P −.
A DL knowledge base (KB) is a pair K = (T , A), con-
sisting of an ABox A that contains facts about particular in-
dividuals and a TBox T that expresses general knowledge
about the domain. Formally, an ABox is a ﬁnite set of con-
cept assertions A(b), with A ∈ NC and b ∈ NI, and role
assertions P (a, b), with P ∈ NR and a, b ∈ NI. We use
Ind(A) to denote the set of individuals in A. A TBox is a
ﬁnite set of axioms, whose syntax depends on the particular
DL. In DL-Litecore, axioms take the form of concept inclu-
sions B1 (cid:118) (¬)B2, where each Bi is either A (for A ∈ NC)
or ∃R (with R ∈ N±
R ). DL-LiteR TBoxes additionally allow
role inclusions R1 (cid:118) (¬)R2, where R1, R2 ∈ N±
R .
Example 1. Our example KB talks about leading (LeadIn)
and supporting actors (SuppIn) in movies:

Aact = {ActsIn(doona, cloud), SuppIn(berry, cloud),

SuppIn(hanks, cloud), SuppIn(hanks, catch)}

Tact = {LeadIn (cid:118) ActsIn, SuppIn (cid:118) ActsIn,

∃SuppIn− (cid:118) ∃LeadIn−}

An interpretation takes the form I = (∆I, ·I), where ∆I
is a non-empty set (the domain of I), and .I is a function that
maps each A ∈ NC to a subset AI ⊆ ∆I, each P ∈ NR to
a binary relation P I ⊆ ∆I × ∆I, and each a ∈ NI to an
element aI of ∆I. We make the unique names assumption
(UNA) by requiring that aI (cid:54)= bI for every a, b ∈ NI with
a (cid:54)= b. The function ·I naturally extends to complex concepts
and roles: (∃R)I = {d | ∃d(cid:48) : (d, d(cid:48)) ∈ RI}, (P −)I =

{(d1, d2) | (d2, d1) ∈ P I}, (¬B)I = ∆I \ BI, (¬R)I =
(cid:0)∆I × ∆I(cid:1) \ RI. A (concept or role) inclusion F (cid:118) G is
satisﬁed in I if F I ⊆ GI; assertion A(b) is satisﬁed in I if
bI ∈ AI; P (a, b) is satisﬁed in I if (aI, bI) ∈ P I. We call I
a model of K, written I |= K, if it satisﬁes all inclusions and
assertions in K. A KB is satisﬁable if has at least one model.
Queries. We recall that a conjunctive query (CQ) takes the
form ∃y ψ(x, y), where x and y are tuples of variables drawn
from an inﬁnite set of variables V, and ψ is a conjunction of
atoms, which can be either concept atoms A(t1) or role atoms
P (t1, t2), where A ∈ NC, P ∈ NR, and terms ti are drawn
from NI ∪ x ∪ y. Consider an interpretation I and CQ q =
∃y ψ(x, y) with |x| = n. A tuple α ∈ (cid:0)∆I(cid:1)n
is an answer
to q in I, written I |= q(α), if there is a homomorphism of q
into I, i.e., a function σ that maps the terms of q to elements
of ∆I such that (i) σ(a) = aI for a ∈ NI, (ii) σ(t) ∈ AI for
every atom A(t) of q, and (iii) (σ(t1), σ(t2)) ∈ P I for every
atom P (t1, t2) of q. A tuple a ∈ Ind(A)n is a certain answer
to q w.r.t. the KB K iff I |= q(aI) for every model I of K.
Canonical Model. We recall the deﬁnition of the canonical
model CK of a DL-LiteR KB K = (T , A). The domain of
CK consists of Ind(A) and all words of the form aR1 . . . Rn,
with a ∈ Ind(A), Ri ∈ N±
• K |= ∃R1(a) and there is no R1(a, b) ∈ A;
• for 1 ≤ i < n, T |= ∃R−
i (cid:118) ∃Ri+1 and R−
We interpret individuals as themselves (aCK = a) and atomic
concepts and roles as follows:
ACK = {a ∈ Ind(A) | K |= A(a)}

R , and n (cid:62) 1, such that:

(cid:54)= Ri+1.

i

∪ {aR1 . . . Rn ∈ ∆CK \ Ind(A) | T |= ∃R−

n (cid:118) A}

P CK = {(a, b) | P (a, b) ∈ A} ∪

{(e1, e2) | e2 = e1R and T |= R (cid:118) P } ∪
{(e2, e1) | e2 = e1R and T |= R (cid:118) P −}

The term ‘canonical model’ is motivated by the following
well-known property of CK (see e.g. [Calvanese et al., 2007]):
Lemma 1. Let K be a satisﬁable DL-LiteR KB. Then CK |=
K and if I |= K, there is a homomorphism of CK into I.
A useful corollary is that the certain answers to a CQ q w.r.t.
K are the tuples from Ind(A) that are answers to q in CK.

Note that CK may be inﬁnite. The depth of a TBox T is
deﬁned as the maximal length of any word that appears in the
domain of CK for any KB K whose TBox is T . If this number
is ﬁnite, we say that T is a ﬁnite-depth TBox; such TBoxes
can be identiﬁed in polynomial time [Bienvenu et al., 2015a].

3 Counting Queries
We now introduce our formalization of counting queries. In
addition to the set V of (classical) variables, we assume a
second inﬁnite set of counting variables Vc, disjoint from V.
Deﬁnition 1. A counting conjunctive query (CCQ) q takes the
form q(x) = ∃y∃z ψ(x, y, z), where x ∪ y ⊆ V, z ⊆ Vc,
and ψ is a conjunction of concept and role atoms whose terms
are drawn from NI ∪ x ∪ y ∪ z. We call x (resp. y, resp. z)
the answer (resp. existential, resp. counting) variables of q.

We ﬁrst deﬁne the semantics of counting queries on a sin-
gle interpretation I, by considering those pairs (a, n) such
that n is the number of possible ways to map z into I when
x is mapped to a. Such pairs are called the answers to q in I.
Deﬁnition 2. A match of a CCQ q(x) = ∃y∃z ψ(x, y, z) in
I is a homomorphism1 from q into I. If a match σ maps x to
a, then the restriction of σ to z is called a counting match (c-
match) of q(a) in I. The set of answers to q in I, denoted qI,
contains all pairs (a, qI
a), where qI
a is the number of distinct
c-matches of q(a) in I.

As has been previously noted (see e.g. [Kostylev and Reut-
ter, 2015]), the exact count values of the answers in qI
are usually too speciﬁc to hold across models. Considering
bounds on the exact value provides more insight, while still
allowing unnamed elements to be counted. This motivates the
following notion of answer interval.
Deﬁnition 3. The set [q]I of answer intervals for a CCQ q in
I contains all pairs (a, [m, M ]) with a ∈ Ind|x| and m, M
integers such that m ≤ qI
a ≤ M . The set [q]K of certain
(counting) answers to q w.r.t. KB K is obtained by consid-
ering those answer intervals that hold in all models of K:
[q]K = (cid:84)
Note that (a, [m, M ]) ∈ [q]K does not imply that for any
n ∈ [m, M ] there exists a model I in which (a, n) ∈ qI.

I|=K [q]I.

Deﬁnition 1 is a proper generalization of the two forms
of counting query considered by Kostylev and Reutter.
Reusing their notations, a Cntd()-query q(x, Cntd(z)) =
∃y ψ(x, y, z) corresponds to the CCQ q(x) = ψ(x, y, z),
while a Count()-query q(x, Count()) = ∃y ψ(x, y) cor-
responds to the CCQ q(x) = ψ(x, ∅, ˆy) (with ˆy a tuple of
variables from Vc in bijection with y). We will use the term
exhaustive to refer to the latter CCQs, i.e. those in which ev-
ery non-answer variable is a counting variable.
Example 2. Reconsider the KB Kact = (Tact, Aact). We can
use CCQs to count the pairs of actors (leading role, support-
ing role) having acted together (q1), return movies together
with a count of their supporting actors (q2), and count the
number of actors having acted with Tom Hanks (q3):

q1 = ∃y∃z1∃z2 LeadIn(z1, y) ∧ SuppIn(z2, y)

q2(x) = ∃z SuppIn(z, x)

q3 = ∃y∃z ActsIn(hanks, y) ∧ ActsIn(z, y)

According to our semantics, we have:
• (∅, [2, +∞]) ∈ [q1]Kact, since z2 can be mapped to either
berry or hanks, and z1 mapped to the lead actor (which
must exist due to Tact). As the lead actors of the two ﬁlms
could be the same, (∅, [3, +∞]) (cid:54)∈ [q1]Kact.

• (cloud, [2, +∞]) ∈ [q2]Kact , mapping z to berry and hanks.
• (∅, 5) ∈ qCKact
, since in CKact, we can map z to a named

actor or the two elements standing in for the lead actors.
• (∅, [5, +∞]) /∈ [q3]Kact , since the lead actors could possi-

3

bly be the same or one of the named actors.

The latter two points show that the canonical model does not
yield the minimal number of matches.

1The notion of homomorphism of a CCQ is deﬁned in the same
way as for CQs, simply treating variables from Vc like those in V.

DL-Litecore
DL-LiteR

Data

coNP-c

coNP-c

Combined
Πp
2-h, PP-h & in coNEXP
coNEXP-h & in coN2EXP
coNEXP-c (T of ﬁnite depth)

Table 1: Data and combined complexity of CCQ answering

4 General Counting CQs
We shall consider the following CCQ answering decision
problem: given a KB K = (T , A), CCQ q, and candidate
answer (a, [m, M ]), decide whether (a, [m, M ]) ∈ [q]K.

As ontology languages, we will consider DL-LiteR (which
underlies OWL 2 QL) and its sublogic DL-Litecore. We know
from [Kostylev and Reutter, 2015] that in these DLs, the least
upper bound M can take one of three values (0, 1, or +∞) and
is easily computed. The argument2 transfers to our more gen-
eral notion of CCQ. We can therefore restrict our attention to
identifying certain answers of the form (a, [m, +∞]).

We will consider the two usual complexity measures: com-
bined complexity which is in terms of the size of the whole
input (T , A, q, a, m), and data complexity which is only in
terms of the size of A and m (T and q are treated as ﬁxed).
We will assume that m is given in binary.

4.1 General Case
Table 1 displays complexity results for answering general
CCQs over DL-Litecore and DL-LiteR TBoxes (we use ‘-c’
and ‘-h’ as abbreviations for ‘-complete’ and ‘-hard’).

With the exception of the PP-hardness result (discussed in
Section 6.1), the lower bounds are inherited from [Kostylev
and Reutter, 2015]. We will thus concentrate on the upper
bounds from Table 1, which are obtained by generalizing and
clarifying the constructions of Kostylev and Reutter. We give
an overview of the proof both to give the ﬂavor of the tech-
niques involved and to enable us to discuss the necessary
adaptations used to prove later results.

The proof constructs a decision procedure for the comple-
mentary problem of deciding whether (a, [m, +∞]) (cid:54)∈ [q]K.
The latter holds iff there exists a countermodel, i.e., a model
of K with fewer than m c-matches of q(a). The main ingre-
dient of the proof is the following theorem, which shows that
it is sufﬁcient to consider countermodels of bounded size.
Theorem 1. For every DL-LiteR (resp. DL-Litecore) KB K =
(T , A) and CCQ q, if there is a model of K with fewer
than m c-matches of q(a), then there exists one of size3
O(|A||T ||q|+1

) (resp. O(|A||q|)).

With Theorem 1 in hand, we can easily deﬁne non-
deterministic procedures that witness the complexity upper
bounds from Table 1: simply guess an interpretation of poly-
nomial / exponential / double-exponential size (depending on
the case) and verify whether it is a countermodel.

The proof of Theorem 1 starts with an arbitrary counter-
model I and modiﬁes it in order to make it smaller, being

2Brieﬂy, the upper bound is 0 if the tuple is not a certain answer;

otherwise, it is either 1 if z = ∅, else +∞.

3As usual, |T | (resp. |A|, |q|) denotes the size of T (resp. A, q).

careful not to introduce any new c-matches of q(a). We ﬁrst
identify a relevant subset ∆∗ of the domain of I, consisting
of the interpretations of all individual names from A and the
images of all c-matches of q(a). We then deﬁne a new in-
terpretation that intuitively preserves ∆∗ and replaces the rest
of I with parts of the canonical model, to introduce a more
regular structure. Formally, we ﬁx a homomorphism f of CK
into I (see Lemma 1) and consider the following mapping
f (cid:48) : ∆CK → ∆∗ ∪ ∆CK from [Kostylev and Reutter, 2015]:
(cid:26) f (d)
d

if f (d) ∈ ∆∗
otherwise

f (cid:48)(d) =

We deﬁne the interleaving4 I (cid:48) of I as the image of CK by f (cid:48),
i.e., with domain f (cid:48)(∆CK) and interpretation function f (cid:48)◦·CK.
It is not difﬁcult to prove that the interleaving I (cid:48) is a model
of K. Moreover, by exhibiting a homomorphism ρ from I (cid:48) to
I, we can translate matches of I (cid:48) into matches in I. As the
images of c-matches of q(a) are contained in ∆∗, which is
left unchanged in I (cid:48), the homomorphism ρ is in fact a one-to-
one mapping of c-matches of q(a) in I (cid:48) to those in I. This
shows that I (cid:48) is also a countermodel.

The interleaving I (cid:48) may be arbitrarily large, even inﬁnite.
To reduce its size, an equivalence relation is introduced, and
elements from ∆I(cid:48)
\ ∆∗ that belong to the same equivalence
class are merged (elements from ∆∗ are retained). In the case
of DL-LiteR, there can be double-exponentially many equiv-
alence classes, as elements are grouped based upon the prop-
erties of their |q|-neighborhoods, while for DL-Litecore, we
can use a more reﬁned relation with only exponentially many
classes. This means that the resulting models are either of
single- or double-exponential size w.r.t. combined complex-
ity, depending on the chosen DL.

A crucial ﬁnal step is to show that the merging of elements
does not introduce any new c-matches of q(a), so the result-
ing model is still a countermodel. This part of the argument,
only sketched in [Kostylev and Reutter, 2015], requires a de-
tailed and technical analysis of the construction to ensure that
this property holds for our more general class of CCQs. We
show that this is indeed the case, which answers a question
left open by Kostylev and Reutter about counting CQs with
both existential variables and multiple counting variables.

4.2 Case of Finite-Depth TBoxes
We give an improved upper bound for ﬁnite-depth TBoxes
(which arguably cover many practical ontologies [Grau et al.,
2013]), pinpointing the exact combined complexity.
Theorem 2. For ﬁnite-depth DL-LiteR TBoxes, CCQ an-
swering is coNEXP-complete w.r.t. combined complexity.

Proof sketch. Fix a KB K = (T , A). If T has ﬁnite depth,
then CK contains at most |Ind(A)| × |T ||T | elements, which
implies that, for every model I of K, the interleaving of I
is ﬁnite and of single exponential size in |K|. Since the inter-
leaving of a countermodel is itself a countermodel, this shows
that the smallest countermodel is of single-exponential size,
from which derives the improved coNEXP upper bound.

4We have slightly modiﬁed the deﬁnition of interleaving to cor-
rect a small bug in the deﬁnition from [Kostylev and Reutter, 2015].

We note that the proofs of the coNP and Πp
listed in Table 1 already use ﬁnite-depth TBoxes.

2 lower bounds

5 Rooted Counting CQs
We next explore whether structural restrictions on CCQs al-
low us to obtain lower complexity. As the lower bounds from
[Kostylev and Reutter, 2015] use disconnected counting vari-
ables, a natural idea is to consider the subclass of rooted
queries that were introduced in [Bienvenu et al., 2012] and
are believed to capture a large portion of real-world CQs.

Rooted CCQs can be deﬁned analogously to rooted CQs.
The deﬁnition utilizes the notion of a Gaifman graph of a
CCQ, whose vertices are the query terms, and which has an
undirected edge {t1, t2} iff t1, t2 co-occur in a role atom.
Deﬁnition 4. A CCQ q(x) := ∃y∃zψ(x, y, z) is rooted if
every connected component of the Gaifman graph of q con-
tains at least one answer variable or individual name.

Example queries q2 and q3 are rooted, while q1 is not.

Rootedness has been shown to lower the complexity of rea-
soning in several settings. Most relevant to us is a recent re-
sult by Nikolaou et al. (2019) that rooted CQ answering under
bag semantics5 has tractable data complexity in DL-Litecore,
and furthermore, the same holds for rooted versions of the
Count()-queries of Kostylev and Reutter under suitable re-
strictions on the TBox. These techniques can be adapted to
show tractability for arbitrary DL-LitecoreTBoxes:
Theorem 3. (Implicit in [Nikolaou et al., 2019; Cima et al.,
2019]) In DL-Litecore, exhaustive rooted CCQ answering is
TC0-complete6 w.r.t. data complexity.

Proof sketch. Nikolaou et al. prove that answering rooted
CQs under bag semantics can be done via a rewriting to
BCALC, whose evaluation problem is known to be in TC0
due to [Libkin, 2001], see [Cima et al., 2019] for discussion.
Moreover, they further show that for a syntactically restricted
class of DL-Litecore TBoxes, it is possible to reduce exhaus-
tive rooted CCQ answering to rooted CQ answering under
bag semantics. To obtain TC0 membership for unrestricted
TBoxes, the BCALC rewriting can be adapted to set-based
rather than bag interpretations. In the long version, we pro-
vide an alternative self-contained proof which directly con-
structs a family of TC0 circuits. A matching lower bound
has not been stated, but can be shown by a simple reduction
(using an empty TBox) from the TC0-complete problem that
asks, given a binary string s and number k, whether the num-
ber of 1-bits in s exceeds k [Aehlig et al., 2007].

The preceding result naturally leads us to ask whether root-
edness also bring beneﬁts for general CCQs. Unfortunately,
we show that restricting to rooted CCQs (without exhaustive-
ness) does not allow us to escape existing hardness results:

5Bag semantics, which underly practical database systems, inter-

prets relations using multisets rather than sets [Albert, 1991].

6We recall that TC0 is a circuit complexity class deﬁned simi-
larly to AC0 but additionally allowing threshhold gates. It is known
that AC0 (cid:40) TC0 ⊆ NC1 ⊆ LogSpace ⊆ PTime.

Theorem 4. In DL-Litecore, rooted CCQ answering is coNP-
complete w.r.t. data complexity.

Proof sketch. The proof borrows some ideas from the proofs
of Lemmas 12 and 16 from [Kostylev and Reutter, 2015]. It
proceeds by reduction from the well-known coNP-complete
3COL problem: given an undirected graph G = (V, E), re-
turn yes iff G has no 3-coloring, i.e., a mapping from V to
{red, green, blue} such that adjacent vertices map to different
colors (equivalently: there is no monochromatic edge).

The reduction uses atomic roles Edge and Vertex to en-
code the graph and HasCol to assign colors. The TBox Tcol
has a single axiom: ∃Vertex− (cid:118) ∃HasCol. The ABox AG
contains an individual v for each vertex v ∈ V and an as-
sertion Edge(u, v) for each edge {u, v} ∈ E. All vertices
are connected to a special root individual a: Vertex(a, u),
for each u ∈ V. The three colors are represented by in-
dividuals r, g and b. To ensure that the query has matches
in every model, we include a ‘dummy’ vertex individual av
and the following assertions: Vertex(a, av), Edge(av, av),
HasCol(av, r), HasCol(av, g), and HasCol(av, b).

The query q is the conjunction of the two subqueries:

qedge = ∃yc ∃z1 ∃z2 Vertex(a, z1) ∧ Vertex(a, z2)∧

Edge(z1, z2) ∧ HasCol(z1, yc) ∧ HasCol(z2, yc)

qcol = ∃y ∃z Vertex(a, y) ∧ HasCol(y, z)

serving respectively to detect monochromatic edges and to
check whether any additional colors have been introduced.

By construction, there are at least 3 c-matches for q(∅) in
any model of the KB Kcol = (Tcol, AG). Moreover, it can be
veriﬁed that (∅, [4, +∞]) is a certain answer to q w.r.t. Kcol
iff G is not 3-colorable.

Theorem 5.
coNEXP-hard w.r.t. combined complexity.

In DL-LiteR,

rooted CCQ answering is

Proof sketch. The proof adapts a reduction from the expo-
nential grid tiling problem (Lemma 18 from [Kostylev and
Reutter, 2015]), the key difference being the use of existential
query variables to access (and count) the colors and bits.

6 Exhaustive Rooted Counting CQs
We have seen in Section 5 that the rootedness restriction is
not by itself sufﬁcient to lower the complexity of CCQ an-
swering, whereas imposing both rootedness and exhaustive-
ness can sometimes yield better results. This motivates us to
take a closer look at the case of exhaustive rooted CCQs. The
emerging complexity landscape is summarized in Table 2.

Note that exhaustive CCQs constitute a very natural form
of counting query, which ask for the number of different
query matches for a given answer tuple. The query q2 from
Example 2 is an exhaustive rooted CCQ.

6.1 Exhaustive Rooted CCQs in DL-Litecore
We ﬁrst consider DL-Litecore KBs and pinpoint the precise
combined complexity, which had not yet been considered.

An essential ingredient is the following result that shows
that it is possible to focus on query matches in the canonical

DL-Litecore
DL-LiteR

Data
TC0-c
coNP-c Πp

Combined

PP-c
2-h, PP-h & in coNEXP

Table 2: Complexity results for exhaustive rooted CCQs

model. It can be obtained by adapting a similar result about
canonical bag interpretations [Nikolaou et al., 2019].
Theorem 6. For every DL-Litecore KB K and exhaustive
rooted CCQ q, it holds that [q]K = [q]CK .

Proof sketch. Exploiting the structure of DL-Litecore canoni-
cal models, one can show that if σ1, σ2 are distinct matches
of an exhaustive rooted CCQ q in CK, then there exists a vari-
able v such that σ1(v) (cid:54)= σ2(v) and σ1(v), σ2(v) ∈ Ind(A).
It follows that if we take an arbitrary model I of K, and let
f be a homomorphism of CK into I, then f injectively maps
query matches in CK to query matches in I.

We will also use the next lemma, implicit in [Bienvenu et
al., 2013], constraining the possible images of matches in CK:
Lemma 2. For every DL-Litecore TBox T and CCQ q, we can
construct in polynomial time a set of words Γq,T such that for
every KB K = (T , A), match σ of q in CK, and variable v
of q: σ(v) = aw for some a ∈ Ind(A) and w ∈ Γq,T .

We are now ready to show that the problem is PP-complete

in combined complexity, and hence in PSpace.
Theorem 7. In DL-Litecore, exhaustive rooted CCQ answer-
ing is PP-complete w.r.t. combined complexity.

Proof sketch. The class PP contains all decision problems for
which there exists a non-deterministic Turing machine (TM)
such that, when the input is a ‘yes’ instance, then at least half
of the computation paths accept, while on ‘no’ instances, less
than half of the computation paths accept.

The lower bound is obtained by a reduction from the fol-
lowing PP-complete problem [Bailey et al., 2007]: given
a propositional formula ψ in CNF and number n, decide
whether ψ has at least n satisfying assignments.

We sketch the TM used to show PP membership, which
takes as input a DL-Litecore KB K = (T , A), an exhaustive
rooted CCQ q(x), and candidate answer (a, [m, +∞]):

Phase 1. The TM constructs the set Γq,T from Lemma 2.
Phase 2. The TM guesses a mapping σ of the variables in q
to elements from {aw | a ∈ Ind(A), w ∈ Γq,T }. It then com-
pares m with the number C = |Γq,T ||q| of possible mappings
and proceeds accordingly:
• if m ≥ C

2 + 1, the TM guesses an integer i with 0 ≤ i ≤
2m − 3 and accepts iff σ is a c-match of q(a) and i < C;
2 + 1, the TM guesses an integer i with 0 ≤
i ≤ 2C − 2m + 1 and accepts iff σ is c-match for q(a) or
i < C − 2m + 2.

• if m < C

The guessed integer and comparisons ensure a suitable num-
ber of accepting paths. It can be veriﬁed that at least half of
the paths are accepting iff (a, [m, +∞]) ∈ [q]CK.

6.2 Exhaustive Rooted CCQs in DL-LiteR
We now turn to DL-LiteR KBs. Our ﬁrst result is negative:
exhaustive rooted CCQs do not enjoy lower data complex-
ity. This is shown by another reduction from 3COL which
involves ideas from our proof of Theorem 4 and the proof of
Lemma 16 from [Kostylev and Reutter, 2015].
Theorem 8. In DL-LiteR, exhaustive rooted CCQ answering
is coNP-complete w.r.t. data complexity.

More positively, we can show an improved coNEXP upper
bound in combined complexity for exhaustive rooted CCQs.
We brieﬂy sketch the proof, which involves highly non-trivial
modiﬁcations to the argument used for general CCQs.

We ﬁrst introduce a more reﬁned notion of interleaving,
which replaces the mapping f (cid:48) by the following mapping f ∗:

f ∗(a) = f (a)

f ∗(ωR) =

(cid:26) f (ωR)

if f ∗(ω), f (ωR) ∈ ∆∗

f ∗(ω)R otherwise

It is possible to prove that when q is an exhaustive rooted
this modiﬁed interleaving yields a countermodel.
CCQ,
Moreover, it has a very particular structure, essentially cor-
responding to the canonical model of the restriction of f (CK)
to ∆∗ (viewed as an ABox). Importantly, this means that in-
stead of guessing a whole countermodel, it sufﬁces to guess
an initial, exponential-size portion (the |q|-neighborhood of
∆∗), providing the basis for a coNEXP decision procedure.
Theorem 9. In DL-LiteR, exhaustive rooted CCQ answering
is in coNEXP w.r.t. combined complexity.

of

that

deﬁnition

7 Best Certain Answers
The
if
(a, [m, M ]) ∈ [q]K, then we also have (a, [m(cid:48), M (cid:48)]) ∈ [q]K
for every m(cid:48) ≤ m and M (cid:48) ≥ M . It is naturally of interest
to focus on certain answers providing the best bounds, i.e.,
those of the form (a, [minI|=K qI

a, maxI|=K qI

answers

implies

certain

a]).

In this section, we show that the problem of identifying
the best lower bound (minI|=K qI
a) is DP-complete in data
complexity. It is easily seen that checking whether m is such
an optimal bound can be done in DP, by making a call to a
coNP oracle (is (a, [m, +∞]) ∈ [q]K?) and an NP oracle (is
(a, [m+1, +∞]) /∈ [q]K?). The DP-hardness of this problem
was left as an open question by Kostylev and Reutter.
Theorem 10. The following problem is DP-hard in data com-
plexity: given a DL-Litecore KB K = (T , A), rooted CCQ q,
tuple a, and number m, decide whether m = minI|=K qI
a.

Proof sketch. We give a reduction from the following prob-
lem (DP-complete due to [Garey et al., 1976]): given planar
graphs G1 and G2, decide if G1 ∈ 3COL and G2 /∈ 3COL.

Let the TBox Tcol and ABoxes AG1, AG2 be deﬁned as in
the proof of Theorem 4. Rename the individuals to ensure
Ind(AG1) ∩ Ind(AG2) = ∅, then set K = (Tcol, AG1 ∪ AG2).
Let qcolor
) be deﬁned as
2
1
before, but using disjoint variables and the root individual
from the AG1 (resp. AG2 ). The challenge is to make sure that
we can determine the 3-colorability status of the two graphs
solely by looking at the number of c-matches of the query. To

(resp. qcolor

and qedge
2

and qedge
1

be able to distinguish G1 from G2, we introduce an asymme-
try by duplicating the color counter query for G1, i.e., create
of qcolor
a copy qcolor
that uses fresh variables but the same
1
root individual. We then take the query

0

q() := qcolor

∧ qedge
1
We claim (a∅, [36, +∞]) ∈ [q]K iff G1 ∈ 3COL and G2 (cid:54)∈

∧ qedge
2

∧ qcolor
1

∧ qcolor
2

0

.

3COL. This is proven by a case analysis, summarized here:

G2 ∈ 3COL
G2 /∈ 3COL

G1 ∈ 3COL
27 (= 3 × 3 × 3)
36 (= 3 × 3 × 4)

G1 /∈ 3COL
48 (= 4 × 4 × 3)
64 (= 4 × 4 × 4)

Each of the four cells displays the least value of m such that
(a∅, [m, +∞]) ∈ [q]K, under different assumptions on the 3-
colorability of G1 and G2. To establish these values, one must
ﬁrst prove that every model has at least this many c-matches,
and then exhibit a model that realizes the exact number. For
the latter, we utilize our assumption that the graphs are planar,
hence 4-colorable [Gonthier, 2008], which we use to show
that the minimal number of c-matches is realized in a model
that encodes proper 3- or 4-colorings of the graphs.

The preceding reduction can be adapted to show DP-
hardness also for the two kinds of CCQs from [Kostylev and
Reutter, 2015], but without the rootedness restriction.

8 Conclusion & Future Work
We have revisited the issue of counting queries in OMQA
and advanced our understanding of the complexity landscape,
both by extending existing results to a more general notion of
counting CQ and by exploring when structural restrictions on
the ontology and query can lead to improved complexity.

There are several natural avenues for future study. A ﬁrst
challenging problem is to provide a full classiﬁcation of the
data complexity of ontology-mediated queries (i.e. query-
ontology pairs), in order to identify further tractable cases. It
would also be relevant to extend the complexity study to DLs
with functional roles or quantiﬁed number restrictions, which
would allow for non-trivial upper bounds on the number of
matches. Tackling general CCQs for such DLs will likely
require wholly different techniques from the model manipu-
lations used in Section 4. However, a recent result by Cima
et al. (2019) shows that the canonical model property (The-
orem 6) holds also for DL-LiteF (which extends DL-Litecore
with functional roles), and hence both TC0 data complexity
(Theorem 3) and our PP-completeness result (Theorem 7) for
exhaustive rooted CCQs transfer to DL-LiteF .

Much remains to be explored for queries involving other
kinds of aggregate functions (min, max, sum, average), which
manipulate data values. Recent studies of bag semantics
for OMQA [Nikolaou et al., 2019; Cima et al., 2019] and
databases with incomplete information [Hernich and Kolaitis,
2017; Console et al., 2017] provide important formal founda-
tions for supporting such queries.

Acknowledgements
This work was partially supported by ANR project CQFD
(ANR-18-CE23-0003).

References

[Aehlig et al., 2007] Klaus Aehlig, Stephen Cook,

and
Phuong Nguyen. Relativizing Small Complexity Classes
and Their Theories. Springer Berlin Heidelberg, Berlin,
Heidelberg, 2007.

[Albert, 1991] Joseph Albert. Algebraic properties of bag
data types. In Proceedings of the 17th International Con-
ference on Very Large Data Bases (VLDB), pages 211–
219, 1991.

[Baader et al., 2017] Franz Baader, Ian Horrocks, Carsten
Lutz, and Ulrike Sattler. An Introduction to Description
Logic. Cambridge University Press, 2017.

[Bailey et al., 2007] Delbert D. Bailey, V´ıctor Dalmau, and
Phokion G. Kolaitis. Phase transitions of PP-complete
satisﬁability problems. Discrete Applied Mathematics,
155(12):1627 – 1639, 2007.

[Bienvenu and Ortiz, 2015] Meghyn Bienvenu and Mag-
dalena Ortiz. Ontology-mediated query answering with
In Tutorial Lectures of
data-tractable description logics.
the 11th Reasoning Web International Summer School,
pages 218–307, 2015.

[Bienvenu et al., 2012] Meghyn Bienvenu, Carsten Lutz,
and Frank Wolter. Query containment in description log-
ics reconsidered. In Proceedings of the 13th International
Conference on the Principles of Knowledge Representa-
tion and Reasoning (KR), 2012.

[Bienvenu et al., 2013] Meghyn Bienvenu, Magdalena Ortiz,
Mantas Simkus, and Guohui Xiao. Tractable queries for
lightweight description logics. In Proceedings of the 23rd
International Joint Conference on Artiﬁcial Intelligence
(IJCAI), pages 768–774, 2013.

[Bienvenu et al., 2015a] Meghyn Bienvenu, Stanislav Kikot,
and Vladimir V. Podolskii. Tree-like queries in OWL 2
QL: Succinctness and complexity results. In Proceedings
of the 30th Annual ACM/IEEE Symposium on Logic in
Computer Science (LICS), pages 317–328, 2015.

[Bienvenu et al., 2015b] Meghyn Bienvenu, Magdalena Or-
tiz, and Mantas Simkus.
Regular path queries in
lightweight description logics: Complexity and algo-
rithms. Journal of Artiﬁcial Intelligence Research (JAIR),
53:315–374, 2015.

[Calvanese et al., 2007] Diego Calvanese, Giuseppe De Gi-
acomo, Domenico Lembo, Maurizio Lenzerini, and Ric-
cardo Rosati. Tractable reasoning and efﬁcient query an-
swering in description logics: The DL-Lite family. Journal
of Automated Reasoning (JAR), 39(3):385–429, 2007.

[Calvanese et al., 2008] Diego Calvanese, Evgeny Khar-
lamov, Werner Nutt, and Camilo Thorne. Aggregate
queries over ontologies. In Proceedings of the 2nd Interna-
tional Workshop on Ontologies and Information Systems
for the Semantic Web (ONISW), pages 97–104, 2008.

[Cima et al., 2019] Gianluca Cima, Charalampos Nikolaou,
Egor V. Kostylev, Mark Kaminski, Bernardo Cuenca Grau,

and Ian Horrocks. Bag semantics of dl-lite with function-
ality axioms. In Proceedings of the 18th International Se-
mantic Web Conference (ISWC), pages 128–144, 2019.
[Console et al., 2017] Marco Console, Paolo Guagliardo,
and Leonid Libkin. On querying incomplete information
in databases under bag semantics. In Carles Sierra, editor,
Proceedings of the 26th International Joint Conference on
Artiﬁcial Intelligence (IJCAI), pages 993–999, 2017.

[Garey et al., 1976] M.R. Garey, D.S.

and
L. Stockmeyer.
Some simpliﬁed NP-complete graph
problems. Theoretical Computer Science, 1(3):237 – 267,
1976.

Johnson,

[Gonthier, 2008] Georges Gonthier. Formal proof – The
four-color theorem. Notices of the American Mathemat-
ical Society, 55(11):1382–1393, 2008.

[Grau et al., 2013] Bernardo Cuenca Grau, Ian Horrocks,
Markus Kr¨otzsch, Clemens Kupke, Despoina Magka,
Boris Motik, and Zhe Wang. Acyclicity notions for ex-
istential rules and their application to query answering
in ontologies. Journal of Artiﬁcial Intelligence Research
(JAIR), 47:741–808, 2013.

[Guti´errez-Basulto et al., 2015] V´ıctor Guti´errez-Basulto,
Yazmin Ang´elica Ib´a˜nez-Garc´ıa, Roman Kontchakov, and
Egor V. Kostylev. Queries with negation and inequalities
over lightweight ontologies. Journal of Web Semantics
(JWS), 35:184–202, 2015.

[Hernich and Kolaitis, 2017] Andr´e Hernich and Phokion G.
Kolaitis. Foundations of information integration under bag
semantics. In Proceedings of the 32nd Annual ACM/IEEE
Symposium on Logic in Computer Science (LICS), pages
1–12, 2017.

[Kostylev and Reutter, 2015] Egor V. Kostylev and Juan L.
Reutter. Complexity of answering counting aggregate
queries over DL-Lite. Journal of Web Semantics (JWS),
33(1):94–111, 2015.

[Libkin, 2001] Leonid Libkin. Expressive power of SQL.
In Proceedings of the 8th International Conference on
Database Theory (ICDT), pages 1–21, 2001.

[Nikolaou et al., 2019] Charalampos Nikolaou, Egor V.
Kostylev, George Konstantinidis, Mark Kaminski,
Bernardo Cuenca Grau, and Ian Horrocks. Foundations of
ontology-based data access under bag semantics. Artiﬁcial
Intelligence (AIJ), 274:91 – 132, 2019.

[Poggi et al., 2008] Antonella Poggi, Domenico Lembo,
Diego Calvanese, Giuseppe De Giacomo, Maurizio Lenz-
erini, and Riccardo Rosati. Linking data to ontologies.
Journal of Data Semantics, 10:133–173, 2008.

[Xiao et al., 2018] Guohui Xiao, Diego Calvanese, Roman
Kontchakov, Domenico Lembo, Antonella Poggi, Ric-
cardo Rosati, and Michael Zakharyaschev. Ontology-
based data access: A survey. In Proceedings of the 27th
International Joint Conference on Artiﬁcial Intelligence
(IJCAI), pages 5511–5519, 2018.

A Proofs for Section 4 (General Counting CQs)
Theorem 1. For every DL-LiteR (resp. DL-Litecore) KB K = (T , A) and CCQ q, if there is a model of K with fewer than m
c-matches of q(a), then there exists one of size7 O(|A||T ||q|+1

) (resp. O(|A||q|)).

We recall the construction of the interleaving and some of its basic properties. We start with an arbitrary countermodel I,

and consider the subdomain ∆∗ consisting of individual names from A and the images of all c-matches of q(a):

∆∗ = {aI | a ∈ Ind(A)} ∪

(cid:91)

σ(z).

σ match for q(a) in I

We ﬁx a homomorphism f of CK into I (see Lemma 1) and consider the following mapping from [Kostylev and Reutter, 2015]:

f (cid:48) : ∆CK → ∆∗ ∪ ∆CK

d (cid:55)→

(cid:26) f (d)
d

if f (d) ∈ ∆∗
otherwise

The interleaving8 I (cid:48) of I is deﬁned as the image of CK by f (cid:48). More precisely, I (cid:48) has domain f (cid:48)(∆CK ) = {f (cid:48)(d) | d ∈ ∆CK }
and interpretation function f (cid:48) ◦ ·CK, i.e., AI(cid:48)

= {f (cid:48)(d) | d ∈ ACK } and RI(cid:48)
It will be useful to exhibit a homomorphism from the interleaving into the original model, which will embed matches.

= {(f (cid:48)(d1), f (cid:48)(d2)) | (d1, d2) ∈ RCK }.

Lemma 3. The following mapping is a homomorphism from I (cid:48) to I.

ρ : ∆I(cid:48)
f (cid:48)(d)

→ ∆I
(cid:55)→ f (d).

Proof. We ﬁrst check that the deﬁnition is well-founded, that is: ρ(f (cid:48)(d)) does not depend on the choice of d. To this end,
consider d1, d2 such that f (cid:48)(d1) = f (cid:48)(d2). Since f (cid:48) maps to ∆∗ ∪ ∆CK , we have two cases to examine:

• if f (cid:48)(d1) = f (cid:48)(d2) ∈ ∆∗, that means f (cid:48)(d1) = f (d1) and f (cid:48)(d2) = f (d2), thus ensuring f (d1) = f (d2).
• if f (cid:48)(d1) = f (cid:48)(d2) ∈ ∆CK , that means f (cid:48)(d1) = d1 and f (cid:48)(d2) = d2, thus ensuring again f (d1) = f (d2).

In both cases, we obtain f (d1) = f (d2), so the function is well-founded.

To show that ρ is a homomorphism of I (cid:48) into I, we use the deﬁnition of f (cid:48) and fact that f is a homomorphism of CK to I.
Suppose ﬁrst that f (cid:48)(d) ∈ AI. Then d ∈ ACK , and since f is a homomorphism, ρ(f (cid:48)(d)) = f (d) ∈ AI. Suppose next that
(f (cid:48)(d1), f (cid:48)(d2)) ∈ RI. Then there exist (d(cid:48)
2) ∈ RCK such that f (cid:48)(d1) = f (cid:48)(d(cid:48)
2). Using again the fact
that f is a homomorphism, we obtain (f (d(cid:48)

. By the preceding paragraph, this means (f (d1), f (d2)) ∈ RI(cid:48)

1) and f (cid:48)(d2) = f (cid:48)(d(cid:48)

2)) ∈ RI(cid:48)

1, d(cid:48)
1), f (d(cid:48)
Lemma 4. The interleaving I (cid:48) is a model of K.

.

Proof. We check that all axioms and assertions from the KB are satisﬁed.

• All ABox assertions from A are satisﬁed in CK. Since f (cid:48) = f when restricted to the ABox individuals, and f is a

homomorphism of CK in I, it follows that these ABox assertions must also be satisﬁed in I.

• Since I (cid:48) maps homomorphically into I (by Lemma 3), any violation of an axiom from the TBox in I (cid:48) implies a similar

violation in I. Since I is a model of K, this cannot occur.

Theorem 11. The interleaving I (cid:48) is a countermodel, and every c-match σ in I (cid:48) satisﬁes that σ(z) ⊆ ∆∗.

Proof. Assume we have a c-match in the interleaving σ : z → ∆I(cid:48)
, which has an associated match σ for q(a). Since ρ is a
homomorphism, ρ ◦ σ is a match for q(a) in the original model I, and its restriction to z, that is, ρ ◦ σ, is a c-match in I. Hence,
it follows from the deﬁnition of ∆∗ that (ρ ◦ σ)(z) ⊆ ∆∗. As ρ−1(∆∗) = ∆∗, this implies σ(z) ⊆ ∆∗.

Moreover, since ρ|∆∗ = id, we in fact have ρ ◦ σ = σ. We have thus shown that every c-match for q(a) in I (cid:48) is also a
c-match for q(a) in I, which means the number of c-matches in I (cid:48) cannot exceed the number of c-matches. As I was assumed
to be a countermodel (i.e. having less than m c-matches), it follows that the same holds for I (cid:48).

In general, the interleaving has an unbounded size. To reduce the size, we will merge some domain elements, while paying
attention not to introduce any new matches. To decide which elements can be merged, we will look at their local properties,
which will be formalized using the following notions of chains and neighbourhoods (as in [Kostylev and Reutter, 2015]).
Deﬁnition 5 (k-chains with respect to a subdomain). A k-chain in a model M with respect to a subdomain D ⊆ ∆M is a
sequence (d0, . . . dk) with di in ∆M, such that for all 0 ≤ i < k, we have (i) di /∈ D, and (ii) there exists a positive role Ri
such that (di, di+1) ∈ RM

. Note that the ﬁnal element dk might belong to D.

i

7As usual, |T | (resp. |A|, |q|) denotes the size of T (resp. A, q).
8We have slightly modiﬁed the deﬁnition of interleaving to correct a small bug in the deﬁnition from [Kostylev and Reutter, 2015].

Deﬁnition 6 (n-neighbourhood with respect to a subdomain). Consider a model M and an element d ∈ ∆M.
Its n-
neighbourhood Nn(d, M, D) w.r.t. a subdomain D is the set of elements d(cid:48) ∈ ∆M such that there exists a k-chain (d0, . . . dk)
in M with respect to D such that k ≤ n, d0 = d, and dk = d(cid:48).

Recall that the deﬁnition of ∆I(cid:48)

\ ∆∗ is actually an element of ∆CK and therefore we have d = aw
for some individual name a and word w. The tree-shaped structure of ∆CK ensures that there exists a unique preﬁx rn,d of aw
such that :

ensures that any d ∈ ∆I(cid:48)

• f (cid:48)(rn,d) ∈ Nn(d, I (cid:48), ∆∗) ;
• for any d(cid:48) ∈ Nn(d, I (cid:48), ∆∗), there exists a unique word wd(cid:48)

n,d such that d(cid:48) = f (cid:48)(rn,dwd(cid:48)

n,d).

We denote by Ωn the set of words over the alphabet of role names occuring in the TBox T and with length less or equal to 2n.
Local properties around d are then captured by the following function.

χn,d : Ωn → ∆∗ ∪ {∅}

w (cid:55)→

(cid:26) f (cid:48)(rn,dw)

∅

if rn,dw ∈ ∆CK and f (cid:48)(rn,dw) ∈ ∆∗
otherwise

.

The next deﬁnition groups together elements having the same local properties.
Deﬁnition 7 (Equivalent elements in the interleaving). The equivalence relation ∼n on ∆I(cid:48)

is deﬁned as follows:

• for d ∈ ∆I(cid:48)
• for d ∈ ∆∗, d ∼n e iff d = e.

\ ∆∗, we have d ∼n e iff wd

n,d = we

n,e, χn,d = χn,e, and |d| = |e| mod 2|q| + 3,

Remark 1. Notice that if d ∼n e, then d ∼m e for any m ≤ n. This property will be used several times without mention.

We can now deﬁne a smaller countermodel for our CCQ q by merging elements with respect to ∼|q|+1. We will use d for
the equivalence class of d w.r.t. ∼|q|+1, and we denote by π the canonical projection, which maps elements to their respective
equivalence classes:

π : ∆I(cid:48)

→ ∆I(cid:48)

/∼|q|+1

d (cid:55)→ d

Deﬁnition 8 (Reduced interleaving). The reduced interleaving J is the interpretation with domain ∆I(cid:48)
pretation of individual names, atomic concepts and roles given by ·J := π ◦ ·I(cid:48)

.

/ ∼|q|+1 and inter-

Once again, it follows from the deﬁnition that π : I (cid:48) → J is a homomorphism and that J is a model of K. Since we are
considering a quotient, we will not be able to build a general homomorphism from J to I (cid:48) as in Lemma 3. However, local
solutions are possible. To improve the readability of the following theorem and later material, we introduce the notation ∆∗ for
the set {σ | σ ∈ ∆∗}.
Theorem 12. For any d ∈ ∆I(cid:48)

, there exists a homomorphism ρd : N|q|(d, J , ∆∗) → N|q|(d, I (cid:48), ∆∗) satisfying that :

1. if e ∈ ∆∗, then ρd(e) = e ;
2. ρ−1
Let us ﬁrst explain how this will conclude our proof, through the following consequence.

d (∆∗) = ∆∗.

Corollary 1. If I is a countermodel, then its reduced interleaving J is a countermodel.

Proof. Assume we have a match σ in J . Consider a minimal covering of σ(x ∪ y ∪ z) by |q|-neighbourhoods in J : that is a
family of neighbourhoods (N|q|(d1, J ), . . . N|q|(dl, J )), with l being minimal and such that σ(x∪y∪z) ⊆ (cid:83)l
k=1 N|q|(dk, J ).
In particular, the minimality ensures that the only possible overlapping elements between two different neighbourhoods are
elements of ∆∗. Along with condition 1 from Theorem 12, this ensures that the following mapping is well deﬁned:

σ(cid:48) : x ∪ y ∪ z → I (cid:48)

v

(cid:55)→ ρdk (σ(v))

if σ(v) ∈ N|q|(dk, J )

Furthermore, as the mappings ρdk provided by Theorem 12 are homomorphisms, it follows that σ(cid:48) is a match in I (cid:48). Hence,
by Theorem 11, we have σ(cid:48)(z) ⊆ ∆∗. However, condition 2 from Theorem 12 ensures (ρdk )−1(∆∗) = ∆∗, hence σ(z) ⊆ ∆∗.
Therefore, for each z ∈ z, we have σ(z) = {ez} with ez ∈ ∆∗. From condition 1, it follows that σ(cid:48)(z) = ez. In particular, the
|z is injective, so there are at most as many counting matches in J than in I (cid:48). Hence, if I (cid:48) is a countermodel,
mapping σ|z (cid:55)→ σ(cid:48)
then J also is.

Recalling Theorem 11, we obtain that if I is a countermodel, then J also is.

To conclude the proof of Theorem 1, notice that an equivalence class d is fully characterized by :

• |d| mod 2|q| + 3, that is one equivalent class among 2|q| + 3 possible classes,
• wd

|q|+1,d, that is a word over an alphabet with at most |T | symbols and a length at most |q| + 1,

• χ|q|+1,d, that is a function from words over an alphabet with at most |T | symbols and length at most 2(|q| + 1), to a set

with size at most |∆∗| + 1.

Therefore, the amount of possibly different equivalence classes, that is |∆J |, is at most:

(2|q| + 3) × |T ||q|+2 × (|∆∗| + 1)|T |2|q|+3

.

Since |∆∗| ≤ |Ind| + n0|q| (recall n0 is the amount of c-matches in I, and that we can assume n0 ≤ (|Ind| + |T |)|q|), we have
the claimed bounds for the size of J , which proves Theorem 1.

Coming back to the proof of Theorem 12, we start by building the mappings ρd. To do so, we need to transform k-chains in

the reduced interleaving into k-chains in the interleaving.
Deﬁnition 9. (primary role, core of a k-chain) Given a couple (d1, d2) of elements in ∆I(cid:48)
\ ∆∗ (resp (d1, d2) in ∆J \ ∆∗),
if there exists a positive role R connecting these two elements, then we call the primary role of the edge (d1, d2) the role SNR
such that either d2 = d1S or d1 = d2S− (resp wd2

S−). Notice that T |= S (cid:118) R.

S or wd1

= wd1

= wd2

|q|+1,d2

|q|,d1

|q|+1,d1

|q|,d2

The action of a role R on a word w, denoted R (cid:5) w, is either w(cid:48) if w = w(cid:48)R−, or wR otherwise.
Given a k-chain C = (d0, . . . dk) in I (cid:48) (resp in J ), we consider its core, denoted (cid:101)C, being the k-sequence of role names

such that (cid:101)Ci is the primary role of (di−1, di).

Given the core (cid:101)C of a k-chain C, we deﬁne its action on a word w, denoted (cid:101)C (cid:5) w, by (cid:101)Ck (cid:5) · · · (cid:5) (cid:101)C1 (cid:5) w.

Remark 2. For any couple (d1, d2) of elements in ∆I(cid:48)
the primary role of the edge (d1, d2) (in J ).

\ ∆∗, the role S is the primary role of the edge (d1, d2) (in I (cid:48)) iff S is

Lemma 5. For any k-chain in J from d to e, we have we

|q|+1−k,e = w (cid:101)C(cid:5)d

|q|+1−k, (cid:101)C(cid:5)d

.

Proof. We proceed by a straightforward induction on the length of C.

• If C is a 0-chain, that is e = d, then (cid:101)C is empty and thus (cid:101)C (cid:5) d = d.
• Otherwise, C is a (k + 1)-chain (d, d1, . . . dk, e),

then consider the primary role S of the edge (dk, e).

If

w( (cid:101)C1...Ck)(cid:5)d

|q|+1−k,( (cid:101)C1... (cid:102)Ck)(cid:5)d

= w(cid:48)S−, then we have :

Otherwise, we have :

w (cid:101)C(cid:5)d

|q|+1−(k+1), (cid:101)C(cid:5)d

= S (cid:5) w( (cid:101)C1,... (cid:101)Ck)(cid:5)dk

(q+1−k,( (cid:101)C1,... (cid:101)Ck)(cid:5)dk

= S (cid:5) wdk
= we

|q|+1−k,dk
|q|+1−(k+1),e.

w (cid:101)C(cid:5)d

|q|+1−(k+1), (cid:101)C(cid:5)d

= S (cid:5) w( (cid:101)C1,... (cid:101)Ck)(cid:5)dk

(q+1−(k+2),( (cid:101)C1,... (cid:101)Ck)(cid:5)dk

= S (cid:5) wdk
= we

|q|+1−(k+1),e.

|q|+1−(k+2),dk

Lemma 6. For any k ≤ |q|, any d, e ∈ ∆I(cid:48)

\ ∆∗, and any two k-chains C and C (cid:48) from d to e in J , we have (cid:101)C (cid:5) d = (cid:102)C (cid:48) (cid:5) d.

Proof. Since C and C (cid:48) have the same endpoints d and e, we have (cid:101)C (cid:5) wd

|q|+1,d| = |q| + 1, then (cid:101)C (cid:5) d = (cid:101)C (cid:5) (r|q+1|,dwd

If |wd
Otherwise, |wd
|q|+1,d, since it would lead, by Lemma 6, to an element along C (resp C (cid:48)) being in ∆∗. Thus, we still have (cid:101)C (cid:5) d = (cid:102)C (cid:48) (cid:5) d.

|q|+1,d| < |q| + 1, we have r|q|+1,d ∈ ∆∗. Therefore the action of (cid:101)C (resp (cid:102)C (cid:48)) cannot empty the initial word

|q|+1,d) = r|q+1|,d( (cid:101)C (cid:5) wd

|q|+1,d) = (cid:102)C (cid:48) (cid:5) d.

wd

|q|+1,d = (cid:102)C (cid:48) (cid:5) wd

|q|+1,d.
|q|+1,d) = r|q+1|,d((cid:102)C (cid:48) (cid:5) wd

Intuitively, the latter proof means that (cid:101)C equals (cid:102)C (cid:48), up to deleting ”dummy” steps in both chains, that are subsequences with
shape S1 . . . SpS−
1 . But since the action of such dummy steps on any word is the identity, then the action of C and C (cid:48)
on d are equal. Notice that in general, these dummy steps are necessary to go from d to e, hence we cannot get rid of them by
asking for some sort of minimality about chains.

p . . . S−

This allows us to deﬁne an image for elements in a neighbourhood in the reduced interleaving regardless of the k-chain used

to reach this element.
Lemma 7. The following mapping is well deﬁned :

ρd : N|q|(d, J ) → N|q|(d, I (cid:48))

e (cid:55)→

(cid:26) e

(cid:101)C (cid:5) d with C any k-chain from d to e, with k ≤ |q|

if e ∈ ∆∗
otherwise

In particular, it satisﬁes conditions 1 and 2 from

Furthermore, ρd satisﬁes that for any e ∈ ∆J , we have ρd(e) ∼1 e.
Theorem 12.
Proof. It only remains to prove that the action of a k-chain always provide an actual element in ∆I(cid:48)
. We proceed by induction
on k, building intermediate mappings ρd,k : Nk(d, J ) → Nk(d, I (cid:48)). We also prove that, at each step, we have for any
e ∈ Nk(d, J ), ρd,k(e) ∼|q|+1−k e.
Base case: k = 0. We have N0(d, J ) = {d}. If d ∈ ∆∗, we set ρd,0 := d which is well-deﬁned. Otherwise, consider the
0-chain (d), we have ρd,0(d) := ε (cid:5) d = d, which is well deﬁned. In both cases, we obviously have ρd,0(d) ∼|q|+1 d.
Induction step: k ⇒ k + 1. Assume the mapping ρd,k : Nk(d, J ) → Nk(d, I (cid:48)) is well deﬁned for some k < |q|. We explain
how to extend it to a mapping ρd,k+1 : Nk+1(d, J ) → Nk+1(d, I (cid:48)). Consider an element e ∈ Nk+1(d, J ) \ Nk(d, J ).

If e ∈ ∆∗, then we set ρd,k+1(e) := e, which is well-deﬁned and satisﬁes ρk+1(e) ∼|q|+1−(k+1) e.
Otherwise, e /∈ ∆∗, we know that there is a k + 1-chain (d0, . . . dk+1) linking d and e. In particular, we have a role R such

that (dk, e) ∈ RJ . From the deﬁnition of RJ , we can infer the existence of (cid:15)(cid:48), (cid:15) ∈ ∆CK such that:

(cid:15)(cid:48) ∼|q|+1 dk

(cid:15) ∼|q|+1 e,

and either (cid:15)(cid:48) = (cid:15)S− or (cid:15) = (cid:15)(cid:48)S, where S denotes the primary role of the edge (dk, e). We consider these two cases in turn:

• If (cid:15)(cid:48) = (cid:15)S−, we have ρd,k((cid:15)(cid:48)) ∼|q|+1−k dk ∼|q|+1−k (cid:15)(cid:48) due to dk ∈ Nk(d, J ) and the assumption for k, which implies
that ρk(dk) ends with S−. The action of S on ρd,k(dk) hence provides the well-deﬁned word obtained from ρk(dk) by
removing its ﬁnal symbol S−. Therefore, ρk+1(e) is well deﬁned. Since the equivalence class of ρd,k(dk) for ∼|q|+1−k
fully determines the equivalence class of its immediate neighbour ρd,k+1(e) for ∼|q|+1−(k+1), and since we know that
ρd,k(dk) ∼|q|+1−k dk by the induction hypothesis, we obtain ρd,k+1(e) ∼|q|+1−(k+1) e.

• Otherwise, if (cid:15) = (cid:15)(cid:48)S, the action of S on ρd,k(dk) provides ρd,k(dk)S, which is well deﬁned since (cid:15)(cid:48) and ρd,k(dk) must end
by the same letter, as the induction hypothesis ensures (cid:15)(cid:48) ∼1 ρd,k(dk) (recall k < |q|). Again, since the equivalence class
of ρd,k(dk) for ∼|q|+1−k fully determines the equivalence class of its immediate neighbour ρd,k+1(e) for ∼|q|+1−(k+1),
and since we know that ρd,k(dk) ∼|q|+1−k dk by the induction hypothesis, we obtain ρd,k+1(e) ∼|q|+1−(k+1) e.

The mapping ρd is obtained as ρd,|q|. Notice the two conditions are satisﬁed.

We now need to prove ρd is a homomorphism. We start by proving the following lemma, which states the links of an element

e1 to elements in ∆∗ fully determines such links for any other element e2 that is 1-equivalent to e1.
Lemma 8. If (e1, d) ∈ RJ for some d ∈ ∆∗, and if e1 ∼1 e2, then (e2, d) ∈ RI(cid:48)
Proof. The deﬁnition of RJ provides (cid:15)1, δ ∈ ∆CK such that :

.

Notice that since d ∈ ∆∗, we have d = {d} and therefore f (cid:48)(δ) = d.

f (cid:48)((cid:15)1) = e1

f (cid:48)(δ) = d

((cid:15)1, δ) ∈ RCK.

• If e1 ∈ ∆∗, then e1 = {e1}.

(f (cid:48)((cid:15)1), f (cid:48)(d)) ∈ f (cid:48)(RCK) = RI(cid:48)

It follows that f (cid:48)((cid:15)1) = e1 and e2 = e1. We therefore obtain (e2, d) = (e1, d) =
.

• Otherwise, e1 /∈ ∆∗, which means that f (cid:48)((cid:15)1) (cid:54)∈ ∆∗, and hence f (cid:48)((cid:15)1) = (cid:15)1 and f (cid:48)((cid:15)1) ∈ ∆CK \ Ind(A). Then, the
R such that T |= S (cid:118) R and either (cid:15)1 = δS− or δ = (cid:15)1S. Let us consider these

deﬁnition of RCK provides a role S ∈ N±
two cases in turn:

– If (cid:15)1 = δS−, then the 1-root of f (cid:48)((cid:15)1) = (cid:15) is f (cid:48)(δ) and we1
1,e1

ε denotes the empty word). But since f (cid:48)((cid:15)1) ∼1 e1 ∼1 e2, we have χ1,e2 = χ1,f (cid:48)((cid:15)1) and we2
1,e2
the preceding facts, we obtain (e2, d) = (r1,e2 we2
1,e2

, χ1,e2 (ε)) = (f (cid:48)(r1,e2S−), f (cid:48)(r1,e2 )) ∈ f (cid:48)(RCK ) = RI(cid:48)

= S−. We thus have: χ1,f (cid:48)((cid:15)1)(ε) = f (cid:48)(δ) = d (where
1,e1. Combining
.

= we1

– If δ = (cid:15)1S, then we have χ1,f (cid:48)((cid:15)1)(wf (cid:48)((cid:15)1)

1,f (cid:48)((cid:15)1). Hence : (e2, d) = (r1,e2we2

1,f (cid:48)((cid:15)1)S) = f (cid:48)(δ) = d. But since f (cid:48)((cid:15)1) ∼1 e1 ∼1 e2, we have χ1,e2 = χ1,f (cid:48)((cid:15)1)
S)) =

, χ1,f (cid:48)((cid:15)1)(wf (cid:48)((cid:15)1)

1,f (cid:48)((cid:15)1)S)) = (r1,e2we2

, χ1,e2(we2
1,e2

1,e2

1,e2

= wf (cid:48)((cid:15)1)

and we2
1,e2
(f (cid:48)(r1,e2 we2
1,e2

), f (cid:48)(r1,e2 we2
1,e2

S)) ∈ f (cid:48)(RCK) = RI(cid:48)

.

RI(cid:48)

Proof of Theorem 12. Let e, e(cid:48) ∈ ∆I(cid:48)

, and let R ∈ NR be such that (e, e(cid:48)) ∈ RJ .
If e ∈ ∆∗, then Lemma 8 applies by setting (e1, e2, d, R) := (e(cid:48), ρd(e(cid:48)), e, R) and therefore (ρd(e), ρd(e(cid:48)) ∈ RI(cid:48)
Otherwise, if e(cid:48) ∈ ∆∗, then Lemma 8 also applies, by setting (e1, e2, d, R) := (e, ρd(e), e(cid:48), R) and again (ρd(e), ρd(e(cid:48)) ∈
.
Otherwise, e, e(cid:48) /∈ ∆∗. Notice that both cannot be in N|q|(d, J ) \ N|q|−1(d, J ) at the same time. Indeed, if both were, there
would be a 2|q| + 1-chain from d to d (recall e, e(cid:48) /∈ ∆∗). However, the depth modulo 2|q| + 3 encoded in each equivalent
class along this chain only increases or decreases by 1 at each step (since none of its element belongs to ∆∗). Hence, |d|
mod 2|q| + 3 would equal itself up to 2|q| + 1 such 1-steps, which is impossible modulo 2|q| + 3. Therefore, we can assume
that e ∈ N|q|−1(d, J ). We have a k-chain Cd→e from d to e, with k < |q|. Complete it by R into a k + 1 chain Cd→e(cid:48) to reach
e(cid:48). Since k + 1 ≤ |q|, we have by deﬁnition ρd(e(cid:48)) = S (cid:5) ρd(e), with S the primary role of the edge (e, e(cid:48)). In both cases, ρd(e(cid:48))
ending by S− or not, it ensures that (ρd(e), ρd(e(cid:48)) ∈ SI(cid:48)
.
The preservation of positive concepts follows. Indeed, if we have an element e and a concept name A such that e ∈ AJ ,
then, from the deﬁnition of AJ , either e is the interpretation of an individual name e and B(e) ∈ A for some concept B such
that T |= B (cid:118) A, or there exists another element e(cid:48) connected to e by a positive role S such that T |= ∃S− (cid:118) A.

⊆ RI(cid:48)

.

In the ﬁrst case, we have in particular e ∈ ∆∗, thus ρd(e) = e = eI(cid:48)
In the second case, since ρd preserves positive roles, we have (ρd(e(cid:48)), ρd(e)) ∈ SI(cid:48)

∈ AI(cid:48)

since I (cid:48) is a model.

, and therefore ρd(e) ∈ AI(cid:48)

since I (cid:48) is a

model.

B Proofs for Section 5 (Rooted Counting CQs)
Theorem 3. (Implicit in [Nikolaou et al., 2019; Cima et al., 2019]) In DL-Litecore, exhaustive rooted CCQ answering is
TC0-complete9 w.r.t. data complexity.

Proof. We start with the TC0 hardness. The reduction from the NUMONES problem works as follows: given an instance
(s, k), we create an ABox As := {R(a, sk) | sk ∈ s ∧ sk = 1}, along with the empty TBox T = ∅ and exhaustive rooted CCQ
q := ∃z R(a, z). It is clear that (∅, [k, +∞]) ∈ [q](T ,As) ⇐⇒ (s, k) ∈ NUMONES. It can be veriﬁed that this simple reduction
can be implemented by AC0 circuits (so constitutes an AC0-reduction, as required).

As explained in the body of the paper, TC0 membership follows from results in [Nikolaou et al., 2019]. While that paper
only formally states membership in LogSpace, a follow-up paper on bag semantics [Cima et al., 2019] states TC0 membership
for DL-LiteF (which properly contains DL-Litecore), by making use of prior complexity results for bag relational algebra. We
believe it is nevertheless instructive to have a direct proof and therefore describe what follows how to construct a family of TC0
circuits to decide our problem.

We need a family of circuits in order to be able to handle ABoxes of different sizes. More precisely, we will create one circuit
for each possible number (cid:96) of individual names. We can assume w.l.o.g. that the same set of individuals, denoted Ind(cid:96), is used
for all of the ABoxes having (cid:96) individuals. Let us now explain how to represent an input (A∗, a∗, m∗) to the circuit that handles
(cid:96)-individual ABoxes.

• Each atomic role P appearing in T and/or q is represented by input gates

is set to 1 iff P(a, b) ∈ A∗.

P(a,b)∈A? for a, b ∈ Ind(cid:96). The gate

P(a,b)∈A?

• Each atomic concept A appearing in T and/or q is represented by input gates

is set to 1 iff A(a) ∈ A∗.

A(a)∈A? for a ∈ Ind(cid:96). The gate

A(a)∈A?

• The tuple a∗ is represented by input gates

ak=a for 1 ≤ k ≤ |x| and a ∈ Ind(cid:96). The gate is set to 1 iff a∗

k = a.

9We recall that TC0 is a circuit complexity class deﬁned similarly to AC0 but additionally allowing threshhold gates. It is known that

AC0 (cid:40) TC0 ⊆ NC1 ⊆ LogSpace ⊆ PTime.

• The integer m∗ is represented in binary by input gates

bk=1 for each 0 ≤ k < log2(|Ind(A∗)| + |T |)|q|). The gate

bk=1 is set to 1 iff the kth bit of m∗ is 1 (with 0th-bit being the least signiﬁcant bit).

Regarding the last point, we use the observation from [Kostylev and Reutter, 2015] that if (a∗, [m∗, +∞]) ∈ [q](T ,A∗), then m∗
cannot exceed (|Ind(A∗)| + |T |)|q| = (|Ind(cid:96)| + |T |)|q|. This is a direct consequence of the fact that every satisﬁable DL-LiteR
KB K = (T , A) has a model with at most |Ind(A)| + |T | elements.

We now describe the other parts of the circuit. We introduce, for each relevant positive concept C (i.e., atomic concept or
existential concept ∃R that uses concept and role names from T and/or q) and each individual name a ∈ Ind(cid:96), a disjunctive
gate ∨

taking as inputs:

K|=C(a)?
A(a)∈A? for each atomic concept A such that T |= A (cid:118) C.
P(a,b)∈A? for all b ∈ Ind(A) such that T |= ∃P (cid:118) C.
P(b,a)∈A? for all b ∈ Ind(A) such that T |= ∃P− (cid:118) C.

•

•

•

The preceding gates determine the ABox part of the canonical model. We next need to decide the existence of each element
of the form aw, where a ∈ Ind(A) and w ∈ Γq,T \ ε (by Lemma 2, these are the only anonymous elements that can occur in a
match for q). For each such aw, we denote by Rw the ﬁrst role name of w and introduce a conjunctive gate ∧
which
takes as input:

aw∈∆CK ?

• The negation ¬

∀b∈Ind(A) ¬R(a,b)?

of a disjunctive gate ∨

∃b∈Ind(A) R(a,b)?

taking as inputs the gates:

–

–

P(a,b) for each b ∈ Ind(cid:96), if R = P ∈ NR.
P(b,a) for each b ∈ Ind(cid:96) if R = P− with P ∈ NR.

which veriﬁes that there is not already a Rw-successor to a.

• The gate ∨

K|=∃Rw(a)?

that checks that a witnessing Rw-successor is needed.

The circuit next determines for each mapping σ : x ∪ z (cid:55)→ {aw|a ∈ Ind(cid:96), w ∈ Γq,T }, whether σ is a match for q(a∗). Notice
that, regardless of the input ABox, we can restrict to a set of relevant mappings by keeping only those which map the answer
variables x to individuals from Ind(cid:96) and which map variables v1, v2 occurring in a role atom R(v1, v2) from q onto either:

• a pair of individual names, or
• a pair w1, w2 such that w2 = w1R or w1 = R−w2.

Similarly, we can restrict the set of relevant mappings by keeping only those which map variable v occuring in a concept atom
A(v) from q onto either an individual name, or an element awR, where K |= ∃R− (cid:118) A. Clearly, any mapping σ that does not
respect these conditions cannot be a match, due to the deﬁnition of RCK . This restriction simpliﬁes the process of checking if a
mapping is a match for q(a∗): we are only left with verifying the existence of the anonymous elements in its image, as well as
the validity of the atoms mapped onto the ABox part of the canonical model.

For each relevant mapping σ, we introduce a conjunctive gate ∧

taking as inputs all gates:

σ match ?

•

ak=σ(xk)? for each 1 ≤ k ≤ |x| (to check x is mapped on a∗).

• ∧

•

for each z ∈ z such that σ(z) /∈ Ind(cid:96) (to check for existence of σ(z) under input A∗).

σ(z)∈∆CK ?
R(σ(v1),σ(v2))∈A? for each v1, v2 ∈ x ∪ z such that R(v1, v2) ∈ q and σ(v1), σ(v2) ∈ Ind(A) (to check the validity of

the mapping for pairs of variables mapped on individual names).

• ∨

K|=A(σ(v))?

for each v ∈ x ∪ z such that A(v) ∈ q and σ(v) ∈ Ind(A) (to check the validity of the mapping for

variables mapped on individual names).

We will next use threshold gates in order to compute the total number of matches. Introduce, for each k = 0, . . . , (Ind(cid:96) ×
returns 1 iff at least k of its inputs

. The gate (cid:62)k

Γq,T )|q|, a threshold gate (cid:62)k
are 1. By construction, the latter holds iff there are at least k matches for q(a∗).

taking as input every ∧

qCK
a ≥k?

qCK
a ≥k?

σ match ?

In parallel, we introduce a conjunctive gate ∧

for each k = 0, . . . , (Ind(cid:96) × Γq,T )|q| taking as inputs:

m=k?

• the input gates

bj =1? such that the jth bit of the binary encoding of k is 1

• the negation of each input gate

bj =1? such that the jth bit of the binary encoding of k is 0

The gate ∧

returns 1 iff m∗ = k.

m=k?

We combine the preceding two types of gates to compare m∗ and the computed number of matches. For each k =

0, . . . , (Ind(cid:96) × Γq,T )|q|, we introduce a conjunctive gate ∧

qCK
a ≥m?

taking as input (cid:62)k

qCK
a ≥k?

and ∧

.

m=k?

Finally, our output gate is a disjunctive gate ∨

taking as inputs all gates ∧

. By construction, this gate outputs

output

qCK
a ≥m?

1 iff there are at least m∗ matches of q(a∗) in the canonical model of the considered KB.
The depth of the circuit is 7, and is hence constant, showing membership in TC0.

Example 3. Let T be the following DL-Litecore TBox

T = {D (cid:118) ∃R, ∃R− (cid:118) ∃R}

and q be the exhaustive rooted CCQ given by

q(x) = ∃z R(x, z)
Observe that even if the second axiom from T suggests the need to consider sufﬁxes R . . . R of arbitrary length, we only have
Γq,T = {ε, R}.

We propose to illustrate the construction of the circuit designed for 2-individual ABoxes, with individual names a and b. We

thus require (cid:100)log2((2 + 2)1)(cid:101) + 1 = 3 input gates representing the input integer, and we have 6 relevant matches given by:

• (σ1)
• (σ2)
• (σ3)
• (σ4)
• (σ5)
• (σ6)

x (cid:55)→ a
x (cid:55)→ a
x (cid:55)→ a
x (cid:55)→ b
x (cid:55)→ b
x (cid:55)→ b

z (cid:55)→ a
z (cid:55)→ b
z (cid:55)→ aR
z (cid:55)→ b
z (cid:55)→ a
z (cid:55)→ bR

The corresponding circuit is depicted in Figure 1.

Theorem 4. In DL-Litecore, rooted CCQ answering is coNP-complete w.r.t. data complexity.

Proof. We brieﬂy recall the reduction sketched in the body of the paper. Starting from an instance G = (V, E) of the decision
problem 3COL, we consider the ABox AG given by:

AG ={Vertex(a, u) | u ∈ V} ∪ {Edge(u1, u2) | (u1, u2) ∈ E}

∪ {Vertex(a, av), Edge(av, av), HasCol(av, r), HasCol(av, g), HasCol(av, b)}

and the TBox T := {∃Vertex− (cid:118) ∃HasCol}, and we denote by KG = (T , AG) the resulting KB. A part of the canonical
model of KG is depicted in Figure 2.

We consider the two following rooted CCQs:

qedge = ∃yc ∃z1 ∃z2 Vertex(a, z1) ∧ Vertex(a, z2) ∧ Edge(z1, z2) ∧ HasCol(z1, yc) ∧ HasCol(z2, yc)
qcol = ∃y ∃z Vertex(a, y) ∧ HasCol(y, z)

We let q be the query obtained by taking the conjunction of these two queries and keeping all of the variables existentially
quantiﬁed. The query q is displayed in Figure 3. The three counting variables (z1, z2, z) are indicated by large gray dots.
It is not hard to see that (a∅, [3, +∞]) ∈ [q]KG . Indeed, there are at least 9 matches of q in any model I of K, given by:

z1, z2, y (cid:55)→ av

yc (cid:55)→ r | g | b

z (cid:55)→ r |g | b

These 9 matches give rise to 3 c-matches for q, corresponding to the three ways of mapping counting variable z. To complete
the proof, we establish the following claim.
Claim. (a∅, [4, +∞]) ∈ [q]KG ⇐⇒ G /∈ 3COL.
(⇒) Assume (a∅, [4, +∞]) ∈ [q]KG , and take some possible coloring τ : V → {r, g, b} of the graph G. Let I G
τ be the model
of KG whose domain is Ind(AG) and which interprets roles Vertex and Edge exactly following the ABox, and which interprets
HasCol according to τ :

HasColIG

τ = {(av, r), (av, g), (av, b)} ∪ {(v, τ (v)) | v ∈ V}

Intuitively, Iτ is obtained from the canonical model by replacing the element vHasCol with τ (v).

By hypothesis, there is a fourth c-match σ for q in I G

τ . It is easily veriﬁed that the additional match can only result from the
atom Edge(z1, z2) being mapped onto an edge Edge(u1, u2) that is different from Edge(av, av). From the deﬁnition of I G
τ , this
implies that the edge (u1, u2) of G is monochromatic, both vertices sharing the color σ(yc). Thus, τ is not a 3-coloring. As this
construction holds for any possible coloring τ , we obtain G /∈ 3COL.

∧

∧

∧

∧

∧

4
(cid:62)

3
(cid:62)

2
(cid:62)

1
(cid:62)

0
(cid:62)

∧

∧

∧

∧

∧

∧

∧

∧

∧

∧

∧

∨

.
q
d
n
a

T

.
t
.
r
.

w
s
e
x
o
B
A

l
a
u
d
i
v
i
d
n
i
-
2
r
o
f

t
l
i
u
b

t
i
u
c
r
i
c

0
C
T
e
h
T

:
1

e
r
u
g
i
F

¬

∧

¬

∧

?
K
C
∆
∈
R
b

?
K
C
∆
∈
R
a

¬

¬

¬

∨

∨

∨

∨

?
1
=
2
b

?
1
=
1
b

?
1
=
0
b

?
b
=
a

?
a
=
a

?
)
b
,
b
(
R
?
)
a
,
b
(
R
?
)
b
,
a
(
R

?
)
a
,
a
(
R

?
)
b
(
D

?
)
a
(
D

u1HasCol
◦

HasCol

HasCol

◦
u2HasCol

u1
•

E
d
g
e

•
u2

Vertex

•
a

Edge

•
av

Vertex

x

e

t

r

V e

o l

a

s C
H
HasCol

HasCol

• r

• g

• b

Figure 2: A part of CKG with (u1, u2) ∈ E.

ol

a s C

H

yc

◦

H

as

C

ol

z1

E
d
g
e

z2

Vertex

•
a

V e rt e x

Vertex

◦
y

HasCol

z

Figure 3: The rooted CCQ q, which is the conjunction of qedge (left part) and qcol (right part).

(⇐) Assume G /∈ 3COL, and take some model I of KG. By Lemma 1, there is a homomorphism f : CKG → I (which
preserves individual names). Deﬁne τ : V → ∆I as follows: τ (u) = f (uHasCol). There are two cases to consider:

• If there exists u ∈ V such that τ (u) /∈ {r, g, b}, then this provides a match of q in I given by z (cid:55)→ τ (u) and y (cid:55)→ uI,

whose restriction to the counting variables is a new c-match.

• Else, since G /∈ 3COL, there exists an edge (u1, u2) ∈ E such that τ (u1) = τ (u2). It provides a new match given by:

z (cid:55)→ r

y (cid:55)→ av

z1 (cid:55)→ u1

z2 (cid:55)→ u2

yc (cid:55)→ τ (u1) (= τ (u2))

In both cases, there is a fourth c-match for q. We thus obtain (a∅, [4, +∞]) ∈ [q]KG .

Theorem 5. In DL-LiteR, rooted CCQ answering is coNEXP-hard w.r.t. combined complexity.

Proof. The proof is by reduction from the exponential grid tiling problem (EXPTIL). We recall that an instance of this problem
consists of a set C of colors, two relations H, V ⊆ C × C that give the horizontal and vertical tiling conditions, and a number
n. The task is to decide whether there exists a valid (H, V)-tiling of an 2n × 2n grid, i.e., a mapping τ : {0, . . . , 2n − 1} ×
{0, . . . , 2n − 1} (cid:55)→ C such that (τ (i, j), τ (i + 1, j)) ∈ H for every 0 ≤ i < 2n − 1 and (τ (i, j), τ (i, j + 1)) ∈ V for every
0 ≤ j < 2n − 1. In what follows, we consider an instance (n, C, H, V) be an instance of the EXPTIL problem.

To be able to test for the existence of a tiling of a 2n × 2n grid, we must start by ensuring we can ﬁnd such a grid in
each model. Furthermore, we will need to detect horizontal and vertical adjacency in this grid, it is thus appropriate to use
horizontal/vertical coordinates. To ensure a polynomial reduction, we need to use a binary encoding of these coordinates. We
start from a root a and an initial element b and use TBox axioms to build two witnesses to represent the two possible values for
the nth bit of the horizontal coordinates:

Roots(a, b)

∃Roots− (cid:118) ∃Hn
0

∃Roots− (cid:118) ∃Hn
1

We use further axioms to generate all possible horizontal coordinates, and we proceed similarly with the vertical coordinates,
until we generate all possible pairs of coordinates. Concretely, we include the following axioms:

∃(Hi

b)− (cid:118) ∃Hi−1

b(cid:48)

∃(H1

b)− (cid:118) ∃Vn
b(cid:48)

∃(Vi

b)− (cid:118) ∃Vi−1

b(cid:48)

for all b, b(cid:48) ∈ {0, 1}, 1 < i ≤ n

The preceding axioms will generate a binary tree of height 2n in the canonical model, whose leaves represent all possible grid
positions. We use the following two axioms assign a color to each of the points representing a grid position:
0)− (cid:118) ∃HasCol
To help us compare positions, we will include the following TBox axioms, for all b ∈ {0, 1} and 1 ≤ i ≤ n:

1)− (cid:118) ∃HasCol

∃(V1

∃(V1

∃(Hi

b)− (cid:118) ∃HasBitb

∃(Vi

b)− (cid:118) ∃HasBitb

We will also introduce a general role (HV) to more compactly navigate the tree:

Hi

b (cid:118) HV

Vi

b (cid:118) HV

(b ∈ {0, 1}, 1 ≤ i ≤ n)

This completes our description of the TBox. We will ﬁnish our description of the ABox later in the proof, but it will be useful
to know that it will contain an ABox individual c for every color c ∈ C and two ABox individuals (one, zero) to represent bits.
Let us now deﬁne the query q. To keep track of the colors used in a candidate tiling, we will use the following subquery:

qcol = ∃ycol

0

. . . ∃ycol

2n ∃zcol Roots(a, ycol

0 ) ∧

2n−1
(cid:94)

i=0

HV(ycol

i

, ycol

i+1) ∧ HasCol(ycol

2n , zcol)

Observe that zcol is the only counting variable. We also need to be able to detect if other bits than the intended ones (one, zero)
are being used to satisfy the axioms H−
b (cid:118) ∃HasBitb. For this purpose, we will introduce the two
following subqueries:

b (cid:118) ∃HasBitb and V−

q0 =∃y0

0 . . . ∃y0

2n∃z0 Roots(a, y0

0) ∧

q1 =∃y1

0 . . . ∃y1

2n∃z1 Roots(a, y1

0) ∧

2n−1
(cid:94)

i=0

2n−1
(cid:94)

HV(y0

i , y0

i+1) ∧ HasBit0(y0

2n, z0)

HV(y1

i , y1

i+1) ∧ HasBit1(y1

2n, z1)

i=0
We note that each of the preceding queries has a single counting variable (z0 or z1). The axioms for HV together with the
construction of the ABox will ensure that every element used as a bit (i.e., in the second argument of HasBit) gives rise to a
c-match for one of these two queries.

We next discuss the parts of the query that are used to check the tiling conditions. To detect adjacency, we remark that two

grid positions (h1, v1), (h2, v2) ∈ {0, . . . , 2n − 1} × {0, . . . , 2n − 1} are vertically adjacent iff:

• h1 = h2, so the binary encodings of h1 and h2 are the same;
• v2 = v1 + 1, so the binary encodings of v2 and v1 are the same until, at some point, v2 ends with 1 · 0k while v1 ends with

0 · 1k.

To detect a violation of the vertical tiling condition (i.e. two vertically adjacent tiles with colors c and c(cid:48) such that (c, c(cid:48)) /∈ V),
we need n queries, one for each possible position where the bit from the vertical coordinates differ. For each 1 ≤ k ≤ n, we
create a subquery qV,(c,c(cid:48)),k deﬁned as follows. Note that the variables in qV,(c,c(cid:48)),k all have the superscript ·V,(c,c(cid:48)),k, which
means they do not occur in any other subquery, but these superscripts are omitted in the deﬁnition for the sake of readability.

qV,(c,c(cid:48)),k = ∃z∃yl,1 . . . ∃yl,2n∃yr,1 . . . ∃yr,2n∃ys,1 . . . ∃ys,n+k
(cid:32)2n−1
(cid:94)

Roots(a, z) ∧ HV(z, yl,1) ∧ HV(z, yr,1) ∧

HV(yl,i, yl,i+1) ∧ HV(yr,i, yr,i+1)

(cid:33)

∧ HasCol(yl,2n, c) ∧ HasCol(yr,2n, c(cid:48)) ∧

i=1
(cid:32)n+k−1
(cid:94)

i=1

HasBit(yl,i, ys,i) ∧ HasBit(yr,i, ys,i)

(cid:33)

∧ HasBit(yl,n+k, zero) ∧ HasBit(yr,n+k, one) ∧

(cid:32) 2n
(cid:94)

i=n+k+1

HasBit(yl,i, one) ∧ HasBit(yr,i, zero)

(cid:33)

Note that z is the only counting variable of qV,(c,c(cid:48)),k. We can similarly deﬁne a set of subqueries qH,(c,c(cid:48)),k (1 ≤ k ≤ n) that
detect violations of the horizontal tiling conditions.

Finally, we let q be the conjunction of the all of the preceding subqueries. It is displayed in Figure 4. The set of counting
variables of q is the union of the counting variables of its subqueries. We observe that q is rooted, as it has a single connected
component which contains the individual a.

We can now deﬁne the ABox, which introduces individuals for the intended colors and bits and a further individual d that

serves to ensure that all parts of the query can be matched:

A = {Roots(a, b), Roots(a, d), HV(b, b), HasBit0(d, zero), HasBit1(d, one)}

b (d, d) | b ∈ {0, 1}, k = 1, . . . n} ∪ {Vk

∪ {Hk
∪ {HasCol(d, c) | c ∈ C}.

b (d, d) | b ∈ {0, 1}, k = 1, . . . n}

Let p = |C|, and let K be the KB with the preceding TBox and ABox. A part of the canonical model CK is displayed in

Figure 5. To complete the proof, it sufﬁces to establish the following claim:

HasBit0

◦
y0
2n

HV

◦

y0
2n−1

z0

HV

◦
y0
0

◦
y0
1

R

o

o

t

s

HV

◦
y1
1

◦
y1
0

HasBit1

HV

◦

y1
2n−1

◦
y1
2n

z1

R oots

a
•

HasCol

◦
ycol
2n

HV

◦
ycol
2n−1

zcol

◦
ycol
1

HV

◦
ycol
0

R oots

R

o

o

t

s

yl,1
◦

V
H

H
a

s

B

yl,2n−2
◦

HV

yl,2n−1
yl,2n
HV HasCol
◦
◦
HasBit

• c

H
a

s

B

i

i

t

t

◦ ys,1

. . .

◦ ys,2n−2

H

a

s

B

i

t

Bit
s
a
H

• one

• zero

t
i
B
s
a
H

s B i t

a

H

◦
yr,2n−2

◦
yr,2n−1

◦
HV HasCol
yr,2n

HV

• c(cid:48)

z

H

V

t
i
B
s
a
H

◦
yr,1

Figure 4: A part of the rooted query q, being the conjunction of q0 (above left), q1 (above right), qcol (below left), several qV,(c,c(cid:48)),k (below
right, only one is depicted with omitted superscripts), and several qH,(c,c(cid:48)),k (none is depicted).

Claim (∅, [p + 1, +∞]) ∈ [q]K ⇐⇒ (n, C, H, V) /∈ EXPTIL.
The proof of this claim is similar in spirit to the proof of Theorem 4. First observe that there are always at least p c-matches
given by mapping the counting variables as follows:

zcol (cid:55)→ c1 | . . . | cp

z0 (cid:55)→ zero

z1 (cid:55)→ one

zH,(c,c(cid:48)),k, zV,(c,c(cid:48)),k (cid:55)→ d

and mapping all of the existential variables to d.

(⇒) Assume (∅, [p + 1, +∞]) ∈ [q]K, and take some potential tiling τ : {0, . . . 2n − 1} × {0, . . . 2n − 1} → {c | c ∈ C}. Let
Iτ be the model of K that is obtained from CK as follows:

• ∆Iτ contains all elements from ∆CK except those anonymous elements whose last symbol is HasCol, HasBit0, or

HasBit1 (i.e. witnesses for axioms involving ∃HasCol, ∃HasBit0, or ∃HasBit1);

• the roles HasCol, HasBit0, HasBit1 are interpreted as follows:

. . . H1
h1

HasBitIτ
0

HasBitIτ
1

:={(d, zero)} ∪ {(bHn
hn
Vn
vn
. . . Hk
hk
. . . Vk
vk

∪ {(bHn
hn
:={(d, one)} ∪ {(bHn
hn
Vn
∪ {(bHn
hn
vn
HasColIτ :={(d, ck) | k = 1, . . . p}
Vn
∪ {(bHn
vn
hn

Hk−1
. . . Hk
hk
0
Vk−1
. . . Vk
vk
0
Hk−1
1
Vk−1
1

. . . H1
h1

. . . H1
h1

, zero) | hn, . . . hk ∈ {0, 1}, k = 1, . . . n + 1}

, zero) | hn, . . . h1, vn, . . . vk ∈ {0, 1}, k = 0, . . . n + 1}

, one) | hn, . . . hk ∈ {0, 1}, k = 1, . . . n + 1}

, one) | hn, . . . h1, vn, . . . vk ∈ {0, 1}, k = 0, . . . n + 1}

. . . V1
v1

, τ (hn . . . h1, vn . . . v1) | hn, . . . h1, vn, . . . v1 ∈ {0, 1}}

where by a slight abuse of notation, we use τ (hn . . . h1, vn . . . v1) to mean τ (h, v), with h and v the numbers whose binary
encodings are hn . . . h1 and vn . . . v1 respectively;

• the remaining roles are interpreted exactly as in CK.

The model Iτ is displayed in Figure 6. By hypothesis, there is an additional c-match σ for q in Iτ . It is easily veriﬁed that the
additional match can only result from an atom Roots(a, zD,(c,c(cid:48)),k), with D ∈ {H, V}, (c, c(cid:48)) ∈ (C × C) \ D and k ∈ {1, ...n},
being mapped onto Edge(a, b). From the deﬁnition of Iτ , this implies that there are two horizontally (or vertically) adjacent
tiles, which positions are given by the elements σ(yD,(c,c(cid:48)),k
), whose respective colors c and c(cid:48) violate D.
Thus, τ is not an (H, V)-tiling. As this construction holds for any possible tiling τ , we can infer that (n, C, H, V) /∈ EXPTIL.

) and σ(yD,(c,c(cid:48)),k

r,2n

l,2n

HV

•
b

Hn

0

H

n

1

s B i t

a

0

◦

H
◦

◦

HasBit
◦

1

Roots

zero

•

s B i t

a

0

◦

H
◦

◦

H0

0

H

0

1

◦

n 0
V
◦

0

s B i t

a

H
◦

n

V

1

HasBit
◦
HasBit
◦

◦

1

1

• one

H

a

s

B

i
t

1

◦

V0

0

V

0

1

s B i t

0

a

H
◦

◦
H
a
s
C
o
◦
l

HasBit
◦

1

◦
H
a
s
C
o
◦
l

s C o l

H a

. . .

•
c1

HasBit0

H asC ol

•
cp

Figure 5: A part of the canonical model CK.

a
•

R
o
o
t
s

•d

H
kb
,

V
kb

(⇐) Assume (n, C, H, V) /∈ EXPTIL, and take some model I of K. By Lemma 1, there is a homomorphism f : CK → I.
Deﬁne τ : {0, . . . , 2n − 1} × {0, . . . n} → ∆I as follows: τ (hn . . . h1, vn . . . v1) := f (bHn
HasCol)
hn
(again slightly abusing notation by applying working with binary encodings of numbers). There are three cases to consider:

. . . H1
h1

. . . V1
v1

Vn
vn

• If there exists (hn . . . h1, vn . . . v1) such that τ (hn . . . h1, vn . . . v1) /∈ {c | c ∈ C}, then this provides a match of q in I in

which the subquery qcol is mapped as follows:

zcol (cid:55)→ τ (hn . . . h1, vn . . . v1)

ycol
0

(cid:55)→ b

ycol
1

(cid:55)→ f (bHn
hn

)

. . .

2n (cid:55)→ f (bHn
ycol
hn

. . . H1
h1

Vn
vn

. . . V1
v1

),

and whose restriction to the counting variables provides a new c-match.

• Otherwise, suppose there exists an element that is in the range of HasBit0 that is not zero, or that is in the range of HasBit1
but not equal to one, then this also provides a new c-match of q, in which either z0 or z1 is mapped to this element. Note
that this kind of ‘error’ may occur at any level of the tree of positions. This is why we included the ABox assertion
HV(b, b), which makes it possible for us to loop as long as needed in order to obtain a sufﬁciently long chain of HV to
satisfy the query q0 or q1.

1, v(cid:48)

n . . . v(cid:48)

n . . . h(cid:48)

• Else, since (n, C, H, V) /∈ EXPTIL, there exist two adjacent positions with coordinates (hn . . . h1, vn . . . v1) and
(h(cid:48)
1)) ∈ (C × C) \ D, for D either H or V. Letting
k be the bit from which the encoding of the non-D coordinate differs, we obtain a new c-match for q, in which the subquery
1)),k) is satisﬁed by mapping zD,(τ (hn...h1,vn...v1),τ (h(cid:48)
qD,(τ (hn...h1,vn...v1),τ (h(cid:48)
In every case, there is an additional c-match for q. We thus obtain (a∅, [p + 1, +∞]) ∈ [q]K.

1) such that (τ (hn . . . h1, vn . . . v1), τ (h(cid:48)

1)),k) to b.

n . . . h(cid:48)

n . . . v(cid:48)

1, v(cid:48)

n...h(cid:48)

n...h(cid:48)

n...v(cid:48)

n...v(cid:48)

1,v(cid:48)

1,v(cid:48)

HasBit0

zero

•

HV

•
b

H

n

1

Hn

0

◦

◦

◦

◦

H0

0

H

0

1

◦

Roots

H

as

Bit

1

t 0

H a s B i

HasBit 0

n 0
V
◦

V

n

1

◦

HasBit1

HasBit1

a
•

R
o
o
t
s

HasBit0

• one

HasBit1

H

a

s

B

i
t

1

•d

H
kb
,

V
kb

◦

V0

0

◦

V

0

1

◦

H asC ol

s C o l

H a

. . .

•
cp

H asC ol

ol
C
s
a
H

•
c1

HasBit0

Figure 6: A part of Iτ with τ (2n − 1, 2n − 2) = τ (2n − 1, 2n − 1) = c1.

C Proofs for Section 6 (Exhaustive Rooted Counting CQs)
We start by recalling an important property of the canonical model construction for DL-Litecore KBs.
Lemma 9. For any role R ∈ N±
one element d2 ∈ CK such that (d1, d2) ∈ RCK.

R and anonymous element d1 in the canonical model CK of a DL-Litecore KB K, there is at most

Proof. We provide a proof for the sake of completeness. From the deﬁnition of RCK , if d1 is an anonymous domain element
and (d1, d2) ∈ RCK, then either:

• d1 = d2S− for some role S such that T |= S (cid:118) R, or
• d2 = d1S for some role S such that T |= S (cid:118) R.

In both cases, since T is a DL-Litecore TBox, the condition on S holds only if S = R. Moreover, we observe that if the ﬁrst
case holds, i.e., d1 = d2R−, then the deﬁnition of ∆CK prevents the creation of an element d1R. It follows that only one of the
preceding cases can hold, and so there can be at most one d2 with (d1, d2) ∈ RCK .

Theorem 6. For every DL-Litecore KB K and exhaustive rooted CCQ q, it holds that [q]K = [q]CK .

Proof. The general argument was given in the sketch. All that remains to show is that if σ1, σ2 are distinct matches of a
exhaustive rooted CCQ q in CK, then there exists a variable v such that σ1(v) (cid:54)= σ2(v) and σ1(v), σ2(v) ∈ Ind(A).

Suppose for a contradiction that this is not the case. There there are distinct matches σ1, σ2 of q in CK such that for all
variables v such that σ1(v) (cid:54)= σ2(v), either σ1(v) (cid:54)∈ Ind(A) or σ2(v) (cid:54)∈ Ind(A). As q is exhaustive rooted, every variable v is
connected to either an answer variable or individual in the Gaifman graph. Let d(v) denote the length of the shortest path from

v to an answer variable of individual. Note that d(v) = 0 iff v is an answer variable. Since σ1 and σ2 are distinct, there exists a
variable v such that σ1(v) (cid:54)= σ2(v). Choose such a variable v∗ with minimal d-value, i.e., if d(u) < d(v∗), then σ1(u) = σ2(u).
By assumption, either σ1(v∗) (cid:54)∈ Ind(A) or σ2(v∗) (cid:54)∈ Ind(A). We’ll suppose the former (the other case is treated analogously).
Note that v∗ cannot be an answer variable (else we would have σ1(v∗) ∈ Ind(A)). It follows that d(v∗) > 0, and so we
can ﬁnd another variable u∗ and role name R ∈ N±
R , with d(u∗) = d(v∗) − 1 and either R(u∗, v∗) ∈ q or R−(v∗, u∗) ∈ q
(recall that if R = P −, then R− = P ). As σ1 and σ2 are matches of q in CK, we therefore have (σ1(u∗), σ1(v∗)) ∈ RCK and
(σ2(u∗), σ2(v∗)) ∈ RCK . Moreover, since d(u∗) < d(v∗), we have σ1(u∗) = σ2(u∗). There are two cases to consider:

• Case 1: σ1(u∗) = σ2(u∗) = c ∈ Ind(A). From the proof of Lemma 9, we know that σ1(v∗) = cR. The fact that
cR ∈ ∆CK implies that there is no individual b such that (c, b) ∈ RCK . Thus, we must have σ2(v∗) = cR, which yields
σ1(v∗) = σ2(v∗), contradicting our earlier assumption.

• Case 2: σ1(u∗) = σ2(u∗) (cid:54)∈ Ind(A). By Lemma 9, there is a unique element e such that (σ1(u∗), e) ∈ RCK. We thus

obtain σ1(v∗) = e = σ2(v∗), a contradiction.

As both cases lead to a contradiction, it must therefore be the case that the statement holds.

Theorem 7. In DL-Litecore, exhaustive rooted CCQ answering is PP-complete w.r.t. combined complexity.

We start by completing the argument for the PP upper bound.

Proof. Recall the algorithm described in the proof sketch.
Phase 1 The TM deterministically constructs the set Γq,T of words from Lemma 2.
Phase 2 The TM guesses a mapping σ of the variables in q to elements from {aw | a ∈ Ind(A), w ∈ Γq,T }. It then compares
m with the number C = |Γq,T ||q| of possible mappings and proceeds accordingly:
• if m ≥ C
• if m < C

2 + 1, the TM guesses an integer i with 0 ≤ i ≤ 2m − 3 and accepts iff σ is a c-match of q(a) and i < C;
2 +1, the TM guesses an integer i with 0 ≤ i ≤ 2C −2m+1 and accepts iff σ is c-match for q(a) or i < C −2m+2.
a denotes the exact number of
c-matches for q(a) in CK). To ﬁnish the proof of PP membership, we need to examine the number of accepting computation
paths for the described TM and show that when qCK
a < m,
less than half of the computation paths accept. Let us consider the two cases from Phase 2:
2 + 1, then the number of accepting computation paths is qCK

a × C, corresponding to cases where the TM guesses
a mapping that is a c-match, then guess a number 0 ≤ i < C. The total number of computation paths is C × (2m − 2),
corresponding to a guess of one of the C mappings, then the guess of an integer 0 ≤ i ≤ 2m − 3.

a ≥ m, at least half of the computation paths accept, and when qCK

Due to Theorem 6 and Lemma 2, an input is a ‘yes’ instance iff qCK

a ≥ m (recall that qCK

• If m (cid:62) C

• If m < C

2 + 1, then the number of accepting computation paths is
a × (2C − 2m + 2) + (C − qCK
qCK

a ) × (C − 2m + 2) = C(C − 2m + qCK

a + 2),

corresponding to the sum of the number of cases where we guess a c-match followed by an integer 0 ≤ i ≤ 2C−2m+1 and
the number of cases where we guess a mapping that is not a c-match followed by an integer i with 0 ≤ i < C − 2m + 2.
The total number of computation paths is C × (2C − 2m + 2) (guess one of the C mappings, then guess an integer
0 ≤ i ≤ 2C − 2m + 1).

In both cases, it is easily veriﬁed that:

qCK
a ≥ m ⇐⇒

#accepting computation paths
#possible computation paths

>

1
2

.

(Note that in the ﬁrst case, we always have m ≥ 2, so the value 2m − 2 in the denominator is positive, while in the second case,
C ≥ 1 implies that the value (2C − 2m + 2) in the denominator is positive.)

We next give the proof of PP-hardness.

Proof. We recall that the lower bound is by reduction from the following PP-complete problem: given a propositional formula
ψ in CNF and number n, decide whether ψ has at least n satisfying assignments.
Consider an instance of this problem, given by the formula ψ := ∃u (cid:86)l

k=1 ξk (with ξk is a 3-clause) and number N . We

consider the KB Kψ = (∅, Aψ), which has an empty TBox, and whose ABox Aψ contains the following assertions:

k ) for each clause ξk and each p ∈ {1, ...7}, with each ξp

k representing one of the 7 satisfying assignments for

k)), Asn2(ξp
truth value (true or false) assigned by ξp

k , ξp

k(ω1

k(ω2

k)) and Asn3(ξp

k , ξp

k(ω3

k)) for each p = 1, ...7 and each clause ξk, where ξp

k(ωi

k) is the

k to the ith variable occurring in the kth clause.

• Clausek(a, ξp
the clause ξk;
k , ξp

• Asn1(ξp

true
•

false
•

1,2,3

1,2

1,3

3

21

2

2 , 3

3

1,3

1,2

1,2,3 1

,

2

,

3

1

,

2

1,3
3

2,3

2

12

1

33

,

1

,

2

1,2,3

ξ1
1

•

ξ2
1

•

ξ3
1

•

ξ4
1

•

ξ5
1

•

ξ6
1

•

ξ7
1

•

ξ1
2

•

ξ2
2

•

ξ3
2

•

ξ4
2

•

ξ5
2

•

ξ6
2

•

ξ7
2

•

Clause

Clause

Cla

1

1

use

1

C

la

u

s

e
1

C

l
a

C

l

a

u

s

e

u

s

e

1

1

C

l

a

u

s

e

1

e2
s
u
Cla

Clause2

C la use 2

C l a

2

u s e

C l a

e

s

u

2
C l a

e

s

u

2
C l

a

e

2

s

u

•
a

Figure 7: The canonical model CKψ with ψ = (u1 ∨ ¬u2 ∨ ¬u3) ∧ (¬u1 ∨ u3 ∨ u4)

It may be helpful to refer to Figure 7, which depicts the canonical model of CKψ for an example formula ψ.

As for the query, we consider the following exhaustive rooted CCQ (depicted in Figure 8):

qψ := ∃zξ1 . . . ∃zξl ∃zu1 . . . ∃zun

l
(cid:94)

k=1

(cid:32)

Clausek(a, zξk ) ∧

Asni(zξk , zωi

k

(cid:33)

(cid:17)

)

3
(cid:94)

(cid:16)

i=1

zu1

zu2

zu3

zu4

A

s

n

2 Asn3
zξ2

Asn2

A

s

n

1

zξ1

3

A s n

Asn

1

C

l
a

u

s

e
1

Clause 2

•
a

Figure 8: The query qψ with ψ = (u1 ∨ ¬u2 ∨ ¬u3) ∧ (¬u1 ∨ u3 ∨ u4)

To complete the proof, we establish the following claim.

(∅, [N, +∞]) ∈ [qψ]Kψ ⇐⇒ ψ has at least N satisﬁying assignments

Claim.
(⇒) Assume (∅, [N, +∞]) ∈ [qψ]Kψ . This implies in particular that there are N c-matches for qψ in CKψ . Since the TBox is
empty, the domain of CKψ is Ind(Aψ), and CKψ makes true precisely the assertions in Aψ. By examining qψ and Aψ, we see
that each of the matches of qψ in CKψ maps each of the variables zui to either true or false. We can therefore associate with each
match σ the following truth assignment for the variables u1, . . . , un: τσ(ui) = σ(zui). By further examining the deﬁnition of
the individuals ξp
k and the roles Asn1, Asn2, Asn3, it is easy to verify that each τσ is a satisfying assignment for ψ. Moreover,
since we know we have N such assignments, it only remains to show that each match σ yields a distinct assignment τσ. To see
why this is the case, observe that once we know the images of all of the variables zui, there is a unique way of mapping the
variables zξp . It follows that ψ has at least N satisfying assignments.

(⇐) Assume ψ has at least N satisfying assignments. Therefore, we have τ1, . . . τN distinct assignments for u1, . . . un
satisfying ψ. This ensures that, if we deﬁne στm(zui) = τm(ui), we can always extend the mapping στm(zui) into a match
for qψ, yielding N distinct matches. Note that this holds in any model since we only need the ‘ABox part’ of the model, hence
(∅, [N, +∞]) ∈ [qψ]Kψ .

Theorem 8. In DL-LiteR, exhaustive rooted CCQ answering is coNP-complete w.r.t. data complexity.

Proof. The main idea is the same as in proof of Theorem 4. However, due to the lack of existential variables, we can no longer
‘reach’ the colors without taking into account the paths leading to them. To address this difﬁculty, we translate into our context
an idea from [Kostylev and Reutter, 2015], which takes advantage of role inclusions.

Starting from an instance G = (V, E) of the decision problem 3COL, we consider the ABox AG given by:

AG ={Vertex(a, u) | u ∈ V} ∪ {Edge(u1, u2) | (u1, u2) ∈ E}
∪ {Vertex(a, av), Edge(av, av), HasCol(av, r)}
∪ {Colors(u, r) | u ∈ V} ∪ {Colors(u, g) | u ∈ V} ∪ {Colors(u, b) | u ∈ V}

and the TBox T := {∃Vertex− (cid:118) ∃HasCol, HasCol (cid:118) Colors}, and we denote by KG = (T , AG) the resulting KB. A part
of the canonical model of KG is depicted in Figure 9. As in the proof of Theorem 4, we use ∃Vertex− (cid:118) ∃HasCol to assign
colors to vertices, and the more general role Colors will be used to detect colors.

u1HasCol
◦

H
a

s

C

o

l

u1

•

E
d
g
e

•

u2

l
o
C
s
a
H

b
•

g
•

r
•

Colors

C

olo
rs
s
C o l o r

Colors
C olors
C o l o r s

Edge

a
•

Vertex

• av

Vertex

V e r t e x

◦
u2HasCol

HasCol

Figure 9: A part of CKG with (u1, u2) ∈ E.

We consider the two following exhaustive rooted CCQs:

qedge = ∃zc ∃z1 ∃z2 Vertex(a, z1) ∧ Vertex(a, z2) ∧ Edge(z1, z2) ∧ HasCol(z1, zc) ∧ HasCol(z2, zc)
qcol = ∃zv ∃z Vertex(a, zv) ∧ Colors(zv, z)

and let q be the query obtained by taking the conjunction of these two queries and keeping all of the variables existentially
quantiﬁed. The query q is displayed in Figure 10. Observe that while it is similar to the query from the proof of Theorem 4 (see
Figure 3), the two existential variables in that query (yc, y) have been replaced with counting variables (zc, zv), and one of the
HasCol atom has been changed to a Colors atom.
It is not hard to see that (a∅, [3|V| + 1, +∞]) ∈ [q]KG . Indeed, there are at least 3|V| matches of q in any model I of K,
obtained as follows:

z1, z2 (cid:55)→ av

zc (cid:55)→ r

zv (cid:55)→ u (u ∈ V)

z (cid:55)→ r | g | b

and one additional match given by:

z1, z2, zv (cid:55)→ av

zc, z (cid:55)→ r

To complete the proof, we establish the following claim.
Claim. (∅, [3|V| + 2, +∞]) ∈ [q]KG ⇐⇒ G /∈ 3COL.

ol

a s C

H

zc

H

as

C

ol

z1

E
d
g
e

z2

Vertex

•
a

V e rt e x

Vertex

Colors

z

zv

Figure 10: The exhaustive rooted CCQ q, which is the conjunction of qedge (left part) and qcol (right part).

(⇒) This direction is proven in the same manner as the claim in the proof of Theorem 4. We assume (a∅, [3|V| + 2, +∞]) ∈
[q]KG and take a possible coloring τ : V → {r, g, b}. We then use τ to build a model Iτ of KG and use the existence of an
additional match σ to show that τ contains a monochromatic edge (hence G /∈ 3COL).
(⇐) Assume G /∈ 3COL, and take some model I of KG. By Lemma 1, there is a homomorphism f : CKG → I. Deﬁne
τ : V → ∆I as follows: τ (u) = f (uHasCol). Note that τ is well deﬁned, as the inclusion ∃Vertex− (cid:118) ∃HasCol ensures that
there is an element uHasCol in CKG . There are two cases to consider:

• If there exists u ∈ V such that τ (u) /∈ {r, g, b}, then the axiom HasCol (cid:118) Colors ensures (uI, τ (u)) ∈ ColorsI, which

provides an additional match of qcolor in I with z (cid:55)→ τ (u) and zv (cid:55)→ uI.

• Else, since G /∈ 3COL, there exists an edge (u1, u2) ∈ E such that τ (u1) = τ (u2). It yields a new match given by:

z (cid:55)→ r

zv (cid:55)→ av

z1 (cid:55)→ u1

z2 (cid:55)→ u2

zc (cid:55)→ τ (u1) (= τ (u2))

In both cases, there is an additional c-match for q. We thus obtain (a∅, [3|V| + 2, +∞]) ∈ [q]KG .

Theorem 9. In DL-LiteR, exhaustive rooted CCQ answering is in coNEXP w.r.t. combined complexity.

Proof. We may assume w.l.o.g. that the initial homomorphism f : CK → I is chosen to respect the following property ((cid:70)):
if w1R, w2R ∈ ∆CK and f (w1) = f (w2), then f (w1R) = f (w2R). Such a homomorphism can easily be built starting from
an arbitrary homomorphism g, by choosing a ‘main branch’ whenever a choice is possible and copying from it. Formally,
given a breadth-ﬁrst ordering (cid:22) of elements in ∆CK , we start by setting f := g. Then, we explore the elements according to
(cid:22) and at each step, say at element w1, we explore all elements w2 such that w1 (cid:22) w2. If ever f (w1) = f (w2), we redeﬁne
f (w2w) := f (w1w) for every word w such that w1w, w2w ∈ ∆CK. Since (cid:22) is breadth-ﬁrst, the image f (w1) will no longer
be redeﬁned after step w1, which ensures the resulting homomorphism f is well-deﬁned.

Recall that we introduced in the body of the paper a more reﬁned notion of interleaving, which replaces the mapping f (cid:48) by

the following mapping f ∗:

f ∗ : ∆CK → ∆∗ ∪ ∆CK
a (cid:55)→ f (a)

(cid:26) f (wR)

if f ∗(w), f (wR) ∈ ∆∗

wR (cid:55)→

f ∗(w)R otherwise
We let I ∗ be the interpretation obtained by applying f ∗ to CK. It is helpful to observe that I ∗ essentially coincides with the
canonical model CK∗
of the KB K∗ whose TBox is T and whose ABox A∗ consists of the facts from ∆∗ ∩ f ∗(CK) (treating
such elements as ABox individuals). More explicitly, A∗ contains the concept assertion A(t) for each atomic concept A ∈ NC
and domain element t ∈ ∆∗ ∩ f ∗(CK) such that t ∈ f ∗(ACK ), and the role assertion R(t1, t2) for each atomic role R ∈ NR and
domain elements t1, t2 ∈ ∆∗ ∩ f ∗(CK) such that (t1, t2) ∈ f ∗(RCK).

This alternative way of viewing I ∗, together with our assumption ((cid:70)), makes clear that the following mapping is a homo-

morphism from I ∗ to I:

ρ∗ : ∆I∗
f ∗(d)

→ ∆I
(cid:55)→ f (d).

Indeed, ((cid:70)) ensures the choice of d doesn’t affect the image f (d), thus ρ∗ is well-deﬁned. Formally, we proceed by induction
on elements of I ∗.
If f ∗(d) ∈ ∆∗, then by the deﬁnition of f ∗, we must have either d ∈ Ind with f ∗(d) = f (d), or
d = wR with f ∗(w) ∈ ∆∗, f (d) ∈ ∆∗ and f ∗(d) = f (d). In both cases, ρ∗(f ∗(d)) = f (d) = f ∗(d), which is independent
from the choice of d. Otherwise, suppose ρ∗ is well-deﬁned for ω, and consider some f ∗(d) = ωR /∈ ∆∗ and d(cid:48) such that
f ∗(d(cid:48)) = f ∗(d) = ωR. By the deﬁnition of f ∗, we must have d = wR with f ∗(w) = ω, and same for d(cid:48), that is, d(cid:48) = w(cid:48)R with
f ∗(w(cid:48)) = ω. By our inductive assumption, we have ρ∗(ω) = f (w) = f (w(cid:48)). Property ((cid:70)) now ensures f (wR) = f (w(cid:48)R),
that is ρ∗(f ∗(d)) = ρ∗(f ∗(d(cid:48))).

The mapping ρ∗ being a homomorphism then follows from the deﬁnition of concept and role interpretations in I ∗.
In
particular, this means that I ∗ is a model of K. Compared to the homomorphism ρ used to connect the interleaving I (cid:48) with
the countermodel I, we have lost the property that ρ−1(∆∗) = ∆∗. Therefore, proving that I ∗ is a countermodel requires a
different argument that exploits the exhaustive rooted assumption on the query.

Consider a match σ : x ∪ z → ∆I∗

of q(a) in I ∗. Let us ﬁrst suppose that there is a counting variable z ∈ z such that
σ(z) /∈ ∆∗, in which case we must have σ(z) = tw for some t ∈ ∆∗ ∩ f ∗(CK) and some non-empty word w. Since q is
exhaustive rooted, all intermediate elements tw(cid:48) with w(cid:48) a preﬁx of w, must be reached by some other counting variables. In
particular, one of these counting variables, say z0, must map onto tw0, with w0 the ﬁrst symbol of w. From the deﬁnition of f ∗,
we also have a word wt such that f ∗(wt) = f (wt) = t. However, via the homomorphism ρ∗, we can transform σ into a match
ρ∗ ◦ σ : x ∪ z → ∆I in the original countermodel I. In particular, we will have ρ∗(σ(z0)) = ρ∗(tw0) = ρ∗(f ∗(wt)w0) =
ρ∗(f ∗(wtw0)) = f (wtw0). Thus, f (wtw0) belongs to the image of the match ρ∗ ◦ σ in I. From the deﬁnition of ∆∗, we can
thus infer that f (wtw0) ∈ ∆∗. But since f ∗(wt) = t ∈ ∆∗ and f (wtw0) ∈ ∆∗, we have f ∗(wtw0) = f (wtw0), and therefore
the element tw0 is not introduced by f ∗ (it would contradict the property ((cid:70))), which contradicts z0 mapping onto this element.
Therefore, this situation, that is, the existence of a match in I ∗ with a counting variable mapping outside ∆∗, does not occur.
Hence, we have σ(x ∪ z) ⊆ ∆∗. Then since ρ∗
|∆∗ = id, we have ρ∗ ◦ σ = σ, which shows that the mapping σ (cid:55)→ ρ∗ ◦ σ
is injective. This means that I contains at least as many c-matches as I ∗, and since I is a countermodel, I ∗ must also be a
countermodel.

As observed earlier, the obtained countermodel I ∗ has a particular structure: it can be seen as the canonical model of an ABox
A∗ whose size is polynomially bounded by the size of ∆∗, itself being single exponential in the size of the input. The modiﬁed
interleaving thus allows us to improve the algorithm used in the general case. Indeed, it is now sufﬁcient for a Turing machine
to (i) guess an ABox of single-exponential size in |K| and |q|, and (ii) check that the canonical model of the guessed ABox and
original TBox contains fewer c-matches for q(a) than the integer provided as input. Importantly, due to our assumption that
q is exhaustive rooted, matches cannot reach elements in the canonical model that have depth greater than |q|. There are thus
only single-exponentially many domain elements that may appear in the image of a match, and so it is possible to enumerate
and count all matches in single-exponential time w.r.t. |K| and |q|.

D Proofs for Section 7 (Best Certain Answers)
Theorem 10. The following problem is DP-hard in data complexity: given a DL-Litecore KB K = (T , A), rooted CCQ q, tuple
a, and number m, decide whether m = minI|=K qI
a.

ol

a s C

H

y1
c

◦

H

as

C

ol

z1
1

E
d
g
e

z1
2

V e rt e x

Vertex

Vertex

a1
•

V e rt e x

HasCol

HasCol

◦
y0

◦
y1

z0

z1

ol

a s C

H

y2
c

◦

H

as

C

ol

z2
1

E
d
g
e

z2
2

Vertex

a2
•

V e rt e x

Vertex

◦
y2

HasCol

z2

Figure 11: The rooted CCQ q, which is the conjunction of q1, q0 (left part) and q2 (right part).

Proof. We provide more details on the case analysis mentioned in the body of the paper. In what follows, I will denote an
arbitrary model of K = (Tcol, AG1 ∪ AG2). We ﬁrst remark that every model contains the c-matches given by:

z0, z1 (cid:55)→ r1 | g1 | b1

1, z1
z1

2 (cid:55)→ av

1

z2 (cid:55)→ r2 | g2 | b2

1, z2
z2

2 (cid:55)→ av

2

Hence, qI

∅ ≥ 3 × 3 × 1 × 3 × 1 = 27.

In what follows, we will use I G

τ to denote a minimal model of KG complying with a given coloring τ of a graph G, constructed
as in the proof of Theorem 4. We observe that if τ1 and τ2 are respectively colorings for the graphs G1 and G2, then the
interpretation I G1
τ2 is a model of the considered KB K. We use such models to
τ1
establish the minimum number of c-matches in the four different cases:

τ2 which is the disjoint union of I G1

τ1 and I G2

∪ I G2

• G1, G2 ∈ 3COL: We have already seen that every model of K contains at least 27 c-matches. Let τ1 (resp. τ2) be a

3-coloring for G1 (resp. G2). Then the model I G1
τ1

∪ I G2

τ2 has exactly 27 c-matches.

• G1 ∈ 3COL, G2 /∈ 3COL: As G2 is not 3-colorable, the part of I describing G2 must either introduce a fourth color,
providing a new value for z2 (hence at least 3 × 3 × 1 × 4 × 1 = 36 c-matches), or contain a monochromatic edge,
2) (hence at least 32 × 1 × 3 × 2 = 54 c-matches). Therefore, every model
providing another possible value for (z2
contains at least 36 c-matches for q. To show we cannot ensure more than 36 c-matches, let τ1 (resp. τ2) be a 3-coloring
(resp. 4-coloring) for G1 (resp G2). Then I G1
τ1

τ2 has exactly 36 c-matches.

∪ I G2

1, z2

u1
1HasCol
◦

HasCol

HasCol

◦
u1
2HasCol

u2
1HasCol
◦

HasCol

HasCol

◦
u2
2HasCol

u1
1
•

E
d
g
e

•
u1
2

u2
1
•

E
d
g
e

•
u2
2

Vertex

x

e

t

r

V e

Vertex

x

e

t

r

V e

•
a1

•
a2

Vertex

Edge

•
a1
v

Vertex

Edge

•
a2
v

o l

• r1

s C

a

H

HasCol

• g1

HasCol

• b1

o l

• r2

s C

a

H

HasCol

• g2

HasCol

• b2

Figure 12: A part of CK(G1,G2 ) with (u1

1, u1

2) ∈ E1 and (u2

1, u2

2) ∈ E2.

• G1 /∈ 3COL, G2 ∈ 3COL: The part of I describing G1 must introduce either a fourth color, providing a new value for z0
and z1 (hence at least 4 × 4 × 1 × 3 × 1 = 48 c-matches), or contain a monochromatic edge, providing another possible
value for (z1
2) (hence at least 3 × 3 × 2 × 3 × 1 = 54 c-matches). It follows that every model contains at least 48
c-matches. To show this is the best value that can be attained, let τ1 (resp. τ2) be a 4-coloring (resp. 3-coloring) for G1
(resp. G2). Then I G1
τ1

τ2 has exactly 48 c-matches.

∪ I G2

1, z1

• G1, G2 /∈ 3COL: For each of the two graphs, I must introduce either a fourth color or a monochromatic edge. There are

four cases to consider:

Fourth color in G2’s part
Monochromatic edge in G2’s part

42 × 1 × 4 × 1 = 64
42 × 1 × 3 × 2 = 96

32 × 2 × 4 × 1 = 72
32 × 2 × 3 × 2 = 108

Fourth color in G1’s part Monochromatic edge in G1’s part

We therefore see that every model contains at least 64 c-matches of q. To realize the minimal number, we let τ1 (resp. τ2)
be a 4-coloring (resp. 4-coloring) for G1 (resp. G2) and observe that I G1
τ1

τ2 has exactly 64 c-matches.

∪ I G2

This completes the case analysis, the rest of the argument is contained in the proof sketch.

DP-hardness for Count queries from [Kostylev and Reutter, 2015]

Proof. We recall that the Count queries from [Kostylev and Reutter, 2015] are obtaining by requiring all of the non-answer
variables to be counting variables. The queries from the preceding reduction do not satisfy this restriction, as they use existential
variables, but we can modify the reduction in order to make it work for such queries.

In the modiﬁed reduction, each vertex is described in the ABox with a speciﬁc concept, either Vertex1 or Vertex2 depending

on which graph it appears in. The TBox contains the following axioms:

{Vertex1 (cid:118) ∃HasCol1, Vertex2 (cid:118) ∃HasCol2, ∃HasCol−

1 (cid:118) Color1, ∃HasCol−

2 (cid:118) Color2}.

The subqueries qedge

i

and qcol

are then modiﬁed as follows for i ∈ {1, 2}:

i
qedge
c ∃zi
i
i =∃zi Colori(zi)
qcol

1 ∃zi

=∃zi

2 Edge(zi

1, zi

2) ∧ HasColi(zi

1, zi

c) ∧ HasColi(zi

2, zi
c)

and qcol

0

is redeﬁned as: ∃z0 Color1(z0).

It is easily veriﬁed that after these modiﬁcations, the query q now corresponds to a Count query as deﬁned in [Kostylev
and Reutter, 2015]. The query q is displayed in Figure 13, and the slightly ajusted canonical model CK(G1,G2) is displayed in
Figure 14.

We can then redo the argument in the same manner as before, and the case analysis will give rise to precisely the same numbers
of c-matches.

ol 1

a s C

H

z1
c

H

as

C

ol

1

z1
1

E
d
g
e

z1
2

Color1

z0

Color1

z1

ol 2

a s C

H

z2
c

H

as

C

ol

2

z2
1

E
d
g
e

z2
2

Color2

z2

Figure 13: The Count CQ q, which is the conjunction of qedge

1

, qcol

1 , qcol

0

(left part) and qedge

2

, qcol
2

(right part).

u1
1HasCol1
◦

HasCol1

u1
1
•

Vertex1

HasCol1

◦
u1
2HasCol1

u2
1HasCol2
◦

HasCol2

E
d
g
e

•
u1
2

u2
1
•

Vertex1

Vertex2

E
d
g
e

HasCol2

◦
u2
2HasCol2

Vertex2

•
u2
2

Edge

•
a1
v

Edge

•
a2
v

o l 1

s C

o l 2

s C

a

a

H

H

Color1

Color1

Color1

Color2

Color2

Color2

•
r1

•
g1

•
b1

•
r2

•
g2

•
b2

Figure 14: A part of CK(G1,G2) with (u1

1, u1

2) ∈ E1 and (u2

1, u2

2) ∈ E2.

DP-hardness for Cntd queries from [Kostylev and Reutter, 2015]

Proof. We recall that the Cntd queries from [Kostylev and Reutter, 2015] correspond to CCQs with exactly one counting
variable. As in the previous reductions, we aim to force additional matches whenever an input graph is not 3-colorable, and the
challenge is to track of the amount of colors used to color the two graphs.

Having only a single counting variable forces us to count colors used for G1 in exactly the same as we count those used for G2.
In particular, the asymmetry we introduced in the query must now be introduced into the ABox. This is done by considering
a copy of our ﬁrst graph. However, this is not enough as two different graphs could use the same additional color, making it
impossible to detect with our single counting variable that both graphs are using more than three colors. Therefore, we will
provide a set of basic colors for each graph and additionally check whether a graph uses a color that is intended for another
graph. Concretely, we achieve this by connecting vertices from different graphs using a new role Diﬀ, and by adding a new
subquery that will generate new c-matches whenever two vertices connected by Diﬀ use the same color.

Let us now give a more formal description of the construction. As mentioned earlier, we will introduce a copy G0 = (V0, E0)

of the graph G1. Without loss of generality, we can assume that V0 ∩ V1 ∩ V2 = ∅. As ABox individuals, we will use:

• an individual name u for each u ∈ V0 ∪ V1 ∪ V2, to represent our graphs;
• individuals r0, g0, b0 (resp. r1, g1, b1 and r2, g2, b2), intended to color G0 (resp. G1 and G2);
• auxiliary individuals for vertices (a0, a1, a2, c, d, e) and auxiliary individuals for colors (r, g, b).

We then consider the following ABox:

A(G1,G2) ={Vertex(u) | u ∈ V0 ∪ V1 ∪ V2}

∪ {Edge(u1, u2) | (u1, u2) ∈ E0 ∪ E1 ∪ E2}
∪ {Edge(a0, a0), Edge(a1, a1), Edge(a2, a2), Edge(c, c), Edge(d, d)}
∪ {Diﬀ(u1, u2) | u1 ∈ Vi, u2 ∈ Vj, i (cid:54)= j}

∪ {Diﬀ(u, ai) | u ∈ Vj, i, j ∈ {0, 1, 2}, i (cid:54)= j}
∪ {Diﬀ(a0, a0), Diﬀ(a1, a1), Diﬀ(a2, a2), Diﬀ(c, c), Diﬀ(e, e)}
∪ {Auxe(a0, a0), Auxe(a1, a1), Auxe(a2, a2), Auxe(d, d)}
∪ {Auxe(e, u) | u ∈ V0 ∪ V1 ∪ V2}
∪ {Auxe(u, c) | u ∈ V0 ∪ V1 ∪ V2}
∪ {Auxd(a0, a0), Auxd(a1, a1), Auxd(a2, a2), Auxd(e, e)}
∪ {Auxd(d, u) | u ∈ V0 ∪ V1 ∪ V2}
∪ {Auxd(u, c) | u ∈ V0 ∪ V1 ∪ V2}
∪ {HasCol(ai, t) | t ∈ {ri, gi, bi}, i ∈ {0, 1, 2}}
∪ {HasCol(c, r), HasCol(d, r), HasCol(d, g), HasCol(d, b), HasCol(e, r), HasCol(e, g), HasCol(e, b)}.

and the TBox T := {Vertex (cid:118) ∃HasCol}. We denote by KG = (T , A) the resulting KB. A part of the canonical model of K
is depicted in Figure ??.

We consider the three following subqueries:
qdif f (y) = ∃yd
qedge(y) = ∃ye
qcol(y) = ∃z HasCol(y, z)

2 ∃yd
2 ∃ye

1 ∃yd
1 ∃ye

c Auxd(y, yd
c Auxe(y, ye

1 ) ∧ Diﬀ(yd
1) ∧ Edge(ye

1 , yd
1, ye

2 ) ∧ HasCol(yd
2) ∧ HasCol(ye

1 , yd
1, ye

c ) ∧ HasCol(yd
c ) ∧ HasCol(ye

2 , yd
c )
2, ye
c )

and let q = ∃y qdif f (y) ∧ qedge ∧ qcol be the complete CCQ, which corresponds to a Cntd query class as there is only one
counting variable z. The query q is displayed in Figure 15.

z

l
o
C
s
a
H

◦
y

Edge

ye
2

◦

ye
1
◦

Auxe

H

a

s

C

o

l

HasCol

◦
ye
c

Auxd

yd
1
◦

Diﬀ

◦ yd
2

H

a

s

C

o

l

HasCol

◦
yd
c

Figure 15: The Cntd CQ q, which is the conjunction of qedge (left part), qdif f (right part) and qcol (upper part).

Claim: (a∅, [10, +∞]) ∈ [q]K iff G1 ∈ 3COL and G2 (cid:54)∈ 3COL.
We prove this claim using the following case analysis:

G2 ∈ 3COL
G2 /∈ 3COL

G1 ∈ 3COL
9 (= 3 + 3 + 3)
10 (= 3 + 3 + 4)

G1 /∈ 3COL
11 (= 4 + 4 + 3)
12 (= 4 + 4 + 4)

To obtain the values in the preceding table, consider an arbitrary model I of K, along with a homomorphism f : CK → I.

First observe that there are always 9 c-matches, which are obtained from the matches given by:
y, ye

z (cid:55)→ ri | gi | bi

2, yd

1 , yd

2 (cid:55)→ ai

c (cid:55)→ ri

c , yd
ye

1, ye

(i ∈ {0, 1, 2})

Hence qI

∅ ≥ 3 + 3 + 3 = 9.

Furthermore, let us deﬁne τI : V0 ∪ V1 ∪ V2 → ∆I as follows: τI(u) = f (uHasCol). We’ll use the notation τI(Vi) to refer
to the set {τI(u) | u ∈ Vi}. Notice that, if τI(Vi) ∩ τI(Vj) (cid:54)= ∅ with i (cid:54)= j, that is, we have u ∈ Gi, v ∈ Gj with i (cid:54)= j and
τI(u) = τI(v), then we have 3 additional c-matches corresponding to the matches given by:
yd
c (cid:55)→ τI(u)

c (cid:55)→ r | g | b

yd
1 (cid:55)→ u

yd
2 (cid:55)→ v

2 (cid:55)→ d

1, ye

y, ye

z, ye

Therefore, in such a model I, we have qI
We will therefore assume in the following that τI(Vi) ∩ τI(Vj) = ∅ for i (cid:54)= j (assumption (i)).

∅ ≥ 9 + 3 = 12, and thus sufﬁciently many c-matches w.r.t. the numbers in the table.

The same applies in the case where τI(Vi) ∩ {rj, gj, bj} (cid:54)= ∅ for i (cid:54)= j, as one can exhibit the same three additional c-
matches by replacing the individual v by aj in the latter deﬁnition of matches. Therefore, we can also assume in what follows
that τI(Vi) ∩ {rj, gj, bj} = ∅ for all i (cid:54)= j (assumption (ii)).

Finally, notice that if τI introduces a monochromatic edge, i.e. an edge (u, v) ∈ E0 ∪ E1 ∪ E2 such that τI(u) = τI(v), we

again have 3 additional c-matches obtained from the matches given by:

z, yd

c (cid:55)→ r | g | b

y, yd

1 , yd

2 (cid:55)→ e

ye
1 (cid:55)→ u

ye
2 (cid:55)→ v

ye
c (cid:55)→ τI(u)

Therefore, we can also restrict our attention to models without monochromatic edges (assumption (iii)). Any model that
satisﬁes properties (i), (ii) and (iii) will be called non-trivial.

We now proceed to consider the four cases. In each case, the minimal amount of c-matches is obtained by exhibiting a
model built from colorings for each graph that use a minimal amount of colors. The only important difference w.r.t preceding
reductions is that when more than one graph utilizes a fourth color, we need to use distinct fourth colors for each graph. We
now complete the proof by showing that every non-trivial model has at least the number of c-matches as listed in the table.

• G1, G2 ∈ 3COL: We have already seen that every model contains at least 9 c-matches.
• G1 /∈ 3COL, G2 ∈ 3COL: Since G0 and G1 are not 3-colorable, any non-trivial model I must satisfy τI(V0) ≥ 4 and
τI(V1) ≥ 4, due to assumption (iii). In particular, we have a vertex u0 ∈ V0 (resp. u1 ∈ V1) such that τI(u0) /∈
{r0, g0, b0} (resp. τI(u1) /∈ {r1, g1, b1}). This yields the following matches:

z (cid:55)→ τI(ui)

1 , yd
which give rise to two new c-matches because of assumptions (i) (ensuring the two colors τI(u0) and τI(u1) are different)
and (ii) (ensuring τI(u0) and τI(u1) are different from the colors in the 9 basic c-matches). Hence, every non-trivial model
contains at least 11 c-matches.

(i ∈ {0, 1})

c , yd
ye

1, ye
ye

y (cid:55)→ ui

2 (cid:55)→ c

c (cid:55)→ r

2, yd

• G1 ∈ 3COL, G2 /∈ 3COL: Since G2 is not in 3COL, any non-trivial model I must satisfy τI(V2) ≥ 4 because of assumption

(iii). In particular, we have a vertex u2 ∈ V2 such that τI(u2) /∈ {r2, g2, b2}. This provides a new match given by:

1, ye
ye
which gives rise to a new c-match because of the assumption (ii) (which ensures τI(u2) is different from the colors in the
9 basic c-matches). Hence, every non-trivial model contains at least 10 c-matches.

z (cid:55)→ τI(u2)

y (cid:55)→ u2

ye
c , yd

2 (cid:55)→ c

c (cid:55)→ r

1 , yd

2, yd

• G1, G2 /∈ 3COL: We can proceed similarly to the two previous cases to exhibit u0 ∈ V0, u1 ∈ V1, u2 ∈ V2 that are

assigned new colors, providing three new matches given by:

z (cid:55)→ τI(ui)

1 , yd
which give rise to three new c-matches because of assumptions (i) (the colors τI(u0), τI(u1), τI(u2) are all different) and
(ii) (they are also different from the colors in the 9 basic c-matches). Hence, we have that every non-trivial model contains
at least 12 matches.

(i ∈ {0, 1, 2})

c , yd
ye

1, ye
ye

y (cid:55)→ ui

2 (cid:55)→ c

c (cid:55)→ r

2, yd

