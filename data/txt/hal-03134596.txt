Determinization and Minimization of Automata for
Nested Words Revisited
Joachim Niehren, Momar Sakho

To cite this version:

Joachim Niehren, Momar Sakho. Determinization and Minimization of Automata for Nested Words
Revisited. Algorithms, 2021, ￿10.3390/a14030068￿. ￿hal-03134596￿

HAL Id: hal-03134596

https://inria.hal.science/hal-03134596

Submitted on 8 Feb 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Article
Determinization and Minimization of Automata for
Nested Words Revisited

Joachim Niehren 1

and Momar Sakho 2

1

2

Inria Lille, joachim.niehren@inria.fr
Inria Lille, momar.sakho@inria.fr

Version February 8, 2021 submitted to Algorithms

Abstract: We consider the problem of determinizing and minimizing automata for nested words in
practice. For this we compile the nested regular expressions (NREs) from the usual XPath benchmark
to nested word automata (NWAs). The determinization of these NWAs, however, fails to produce
reasonably small automata. In the best case, huge deterministic NWAs are produced after few hours,
even for relatively small NREs of the benchmark.
We propose a different approach to the determinization of automata for nested words. For this, we
introduce stepwise hedge automata (SHAs) that generalize naturally on both (stepwise) tree automata
and on ﬁnite word automata. We then show how to determinize SHAs, yielding reasonably small
deterministic automata for the NREs from the XPath benchmark. The size of deterministic SHAs
automata can be reduced further by a novel minimization algorithm for a subclass of SHAs.
In order to understand why the new approach to determinization and minimization works so
nicely, we investigate the relationship between NWAs and SHAs further. Clearly, deterministic SHAs
can be compiled to deterministic NWAs in linear time, and conversely, NWAs can be compiled
to nondeterministic SHAs in polynomial time. Therefore, we can use SHAs as intermediates
for determinizing NWAs, while avoiding the huge size increase with the usual determinization
algorithm for NWAs. Notably, the NWAs obtained from the SHAs perform bottom-up and left-to-right
computations only, but no top-down computations. This NWA-behavior can be distinguished
syntactically by the (weak) single-entry property, suggesting a close relationship between SHAs
and single-entry NWAs. In particular, it turns out that the usual determinization algorithm for NWAs
behaves well for single-entry NWAs, while it quickly explodes without the single-entry property.
Furthermore, it is known that the class of deterministic multi-module single-entry NWAs enjoys
unique minimization. The subclass of deterministic SHAs to which our novel minimization algorithm
applies is different though, in that we do not impose multiple modules.
As further optimizations for reducing the sizes of the constructed SHAs, we propose schema-based
cleaning and symbolic representations based on apply-else rules, that can be maintained by
determinization. We implemented the optimizations and report the experimental results for the
automata constructed for the XPathMark benchmark.

Keywords: Regular Expressions; Tree Automata; Nested Words; Hedges, Logical Queries; XPath

1. Introduction

Nested words are hierarchical structures that are omnipresent in computer science. They were
used to represent sequences of data trees, like XML or JSON documents, and to analyze the call
structure of recursive programs. The idea of nested words is to generalize on both words and trees,
resulting in sequences of unranked trees that are also known as hedges. Or else, nested words can
be obtained by enriching Dyck words with internal letters, besides opening and closing parentheses.
Furthermore, nested words are the elements of the least set containing internal letters from a given

Submitted to Algorithms, pages 1 – 32

www.mdpi.com/journal/algorithms

5

10

15

20

25

30

35

Version February 8, 2021 submitted to Algorithms

2 of 32

alphabet, triples consisting of an opening parenthesis, a nested word, and a closing parenthesis, and all
sequences of nested words. Last but not least, nested words can be seen as words over an alphabet with
internal letters, opening parentheses and closing parentheses, under the conditions that the parenthesis
are well-nested, so that every opening parenthesis is properly closed and every closing parenthesis
properly opened.

From the viewpoint of formal language theory, a natural question is how to lift the notions of
ﬁnite automata and regular expressions, from words and trees to nested words, while preserving their
well-known relationships. Nested word automata (NWAs) were heavily studied since the eighties [1–4],
under then name input driven automata. They are the same as visibly pushdown automata [5], pushdown
forest automata [6] and streaming tree automata [7]. NWAs can recognize the same languages of unranked
trees as hedge automata [8], a generalization of tree automata for ranked trees [9]. NWAs are often
deﬁned as pushdown automata with visible stacks, meaning that exactly one symbol is pushed when
reading an opening parenthesis, and exactly one symbol is popped when reading a closing parenthesis,
while the stack is not used otherwise. Their main advantage is a powerful notion of determinism,
generalizing both over bottom-up and top-down determinism of tree automata for ranked trees [2,3].
We note that general pushdown automata do not permit determinization in contrast.

Regular expressions for nested words were proposed more recently by Hosoya and Pierce [10]
under the name of regular expression types. In the present article, we will call them nested regular
expressions (NREs) instead. Independently, more complex notions of nested regular expressions were
introduced [11,12] in order to deal with generalizations of nested words with dangling opening and
closing parentheses, which are not of interest to us. It was already claimed in [10], that our simpler
notion of NREs has the same expressiveness as hedge automata [8,9], which in turn have the same
expressiveness as NWAs [3]. However, the question under which conditions NREs can be compiled to
small deterministic NWAs has not been studied. For classes of NREs for which deterministic NWAs can
be computed in polynomial time, we can decide language inclusion or equivalence in polynomial time
too. For other classes, these problems may not be feasible since language inclusion for nondeterministic
NWAs is EXP-complete.

Our concrete interest in the universality of deterministic NWAs is motivated by XML stream
processing: we want to compute the certain answers of a navigational XPath query on an XML stream
[13,14], i.e., those elements that are selected in all possible futures of the stream. Whether an answer is
certain is computationally hard, even for tiny syntactic fragments of navigational XPath [14,15], but
can be done in polynomial time for queries deﬁned by deterministic NWAs [16]. A natural question is
therefore, whether it is possible to compile navigational XPath queries as in the usual benchmark [17]
to deterministic NWAs of reasonable size. Unfortunately, the existing compilers fail to do so [18], since
they are based on NWA determinization for dealing with disjunction, negation, and recursive steps.
Thereby they produce huge deterministic automata even for very simple navigational XPath queries
from the benchmark, or do not terminate after some hours.

In this article, we consider NREs for deﬁning queries on nested words. For benchmarking with
realistic example, we consider the navigational XPATH queries in the XPathMark benchmark with only
forwards axis, that we compiled to NREs of the same size up to a constant factor. The question is then
whether these NREs can be compiled to reasonably small deterministic NWAs.

As a ﬁrst approach, we distinguish a subclass of “deterministic” NREs that can be compiled in
polynomial time to deterministic NWAs by generalizing on Glushkov’s construction of deterministic
ﬁnite-state automata (DFAs) from “deterministic” regular expressions [19,20]. However, the NREs
obtained by compilation from navigational XPath queries are rarely deterministic, so neither are the
NWAs compiled from them. And since we cannot apply NWA determinization to them in practice as
argued above, this ﬁrst approach has a much too low coverage to reach the objective. So we will report
it only at the end in Section 9.

40

45

50

55

60

65

70

75

80

For our second approach, we propose a novel variant of automata for nested words that we call
stepwise hedge automata (SHAs). Even though motivated by the wish to create deterministic automata for

85

Version February 8, 2021 submitted to Algorithms

3 of 32

the NREs of our benchmark, they are of general interest: they generalize naturally on both (stepwise)
tree automata [21] and on ﬁnite word automata. In contrast to stepwise tree automata, SHAs cannot
only recognize unranked trees but also sequences thereof, i.e., hedges or nested words. Furthermore,
SHAs can be determinized in a bottom-up and left-to-right manner, by combining in a natural manner
the determinization procedures for tree and word automata.

By adapting existing compilers for stepwise tree automata [21], SHAs can be compiled to NWAs
with the same language in linear time while preserving determinism. And conversely, NWAs can be
compiled to SHAs in polynomial time, but at the cost of introducing nondeterminism. By compiling
NWAs to SHAs, determinizing the SHA, and compiling the obtained deterministic SHA back to a
deterministic NWA, we can determinize NWAs by determinizing the corresponding SHAs. This
alternative determinization algorithm for NWAs is different from the usual determinization algorithm
for NWAs [2,3,18]. Indeed, it yields reasonably small deterministic NWAs for the NREs from the XPath
benchmark.

Yet another alternative algorithm for determinizing NWAs can be obtained by compiling NWAs
to SHAs and back, and then determinizing the NWAs obtained in this manner. When applied
to back-and-forth converted NWAs, the usual NWA determinization algorithm turns out to be
well-behaved: it produces deterministic NWAs of reasonable size for all our benchmark NREs. This
might be surprising, given that the same determinization algorithm behaved so poorly for the
non-converted NWAs that were obtained from the benchmark NREs directly.

We contribute two further solutions for producing deterministic NWAs for our benchmark NREs.
These are both based on a direct compiler from NREs to SHAs. We can then determinize these SHAs,
followed by compilation to deterministic NWAs. Or else, we can ﬁrst compile the SHAs to NWAs and
then determinize these NWAs.

The next question is why the new determinization algorithms for NWAs, that use SHAs as
intermediates, work so nicely. In order to understand this, we need to investigate the relationship
between NWAs and SHAs more deeply. Clearly, the NWAs obtained via SHAs do all their work in
a bottom-up and left-to-right manner, and nothing when moving top-down. We can characterize
the subclass of NWAs with this restricted behavior syntactically by the (weak) single-entry property: it
requires that all opening rules of the NWA go into into the same target state while popping the sources
state onto the stack. Note that our single-entry property is weaker than the (multi-module) single-entry
property studied previously [22–24], which in addition requires that the automaton can be split into at
least 2 modules, one for the top level and one for the nested level. The NWAs obtained by compilation
from SHAs all have the (weak) single-entry property (but not necessarily multiple modules). So when
compiling NWAs to SHAs and back, the resulting NWAs also have the (weak) single-entry property. It
seems that the usual determinization algorithm from NWAs is well-behaved when applied to NWAs
with the (weak) single-entry property. The relationship between SHAs and (weak) single-entry NWAs
seems sufﬁciently close, so that their determinization algorithms seem to operate in a somehow similar
manners.

It is known that the subclass of deterministic multi-module single-entry NWAs (also called call
driven automata) enjoys unique minimization [22,23]. The separation of the module for the top level
from the module for the nested level can be obtained w.l.o.g., by building a product with the NWA with
2 hedge states that distinguishes the two levels. In our application, minimization could thus be used
to reduce the size of the deterministic NWAs produced by our four algorithms for converting NREs,
with the hope to eventually obtain a unique outcome after minimization. However, since we will use
some symbolic representations for sets of rules, the uniqueness will hold only for the non-symbolic
counterpart. In any case, the number of states of the deterministic minimal NWAs obtained for the
same NRE could be expected to become unique.

Motivated by our application, we found it more relevant to minimize deterministic SHAs rather
than deterministic (weak) single-entry NWAs (despite of their close correspondence). As for the class
of deterministic (weak) single-entry NWAs, a restriction is needed for the class of deterministic SHAs

90

95

100

105

110

115

120

125

130

135

Version February 8, 2021 submitted to Algorithms

4 of 32

140

145

150

155

160

165

170

175

180

to obtain unique minimization. We could have required the existence of multiple modules as for
multi-module single-entry NWAs. Instead we restrict ourselves to deterministic SHAs for which the
initial states for trees and hedges coincide. We then show that minimization for such SHAs can be
reduced to the minimization of tree automata up to a novel encoding of hedges to binary trees.

We implemented all 4 algorithms for compiling our benchmark NREs to deterministic NWAs and
report the experimental results. We have also implemented the novel minimization algorithm for
SHAs with equal tree and hedge initial states, and used it in our experiments. We propose two further
optimization methods for reducing the sizes of the constructed automata.

First, we introduce schema-based cleaning both for SHAs and NWAs. In our application, the
schema expresses the XML data model, stating that hedges must encode valid XML documents. More
generally, an automaton A can be cleaned relatively to an automaton S for the schema, if the language
of interest is the intersection L(A) ∩ L(S) rather than L(A) itself. The idea of schema-based cleaning
is to keep only those transition rules of A that are used to recognize some hedge of L(S). These
transition rules can be computed from the product of A and S. It should be noticed that schema-based
cleaning may change the language of the automaton. Only the intersection L(A) ∩ L(S) is preserved,
not necessarily L(A).

Second we propose a symbolic representations for SHAs based on apply-else rules. They help to
represent more compactly a large number of apply rules produced by the determinization of SHAs.
Before compiling SHAs to NWAs, however, we need to eliminate the apply-else rules. This is because
we have not developed analogous symbolic representations for NWAs so far. A second limitation is
that we have not not implemented any minimization algorithm for NWAs at the time being.

The main improvement of this journal article compared with the conference version [25] is the
addition of the minimization algorithm for the subclass of SHAs with equal tree and hedge initial
states. Furthermore, we added the idea of schema-based cleaning and the symbolic representations
for SHAs by apply-else rules. The experimental results were enhanced with minimization, symbolic
representations of rules, and schema-based cleaning. All the nested regular expressions generated for
the XPathMark benchmark queries that we consider, as well as their corresponding automata – when
we could produce them – can be found at http://researchers.lille.inria.fr/niehren/complementary-
material.
Related Work. In the present article, we restrict ourselves to nested words over signatures with a
single opening parenthesis, a single closing parenthesis, and possibly many internal letters a, b. This
permits us to simplify the presentation of nested regular expressions, the notions of NWAs and SHAs,
their forth and back compilers, but also the determinization algorithms. Note that any multi-module
NWA for such signatures must have exactly 2 modules. From an application perspective, multiple
parentheses can be encoded by using internal letters, that is a named opening parenthesis (cid:104)a by the
word a · (cid:104) and a named closing parenthesis (cid:105)b by the word b · (cid:105). When encoding XML documents as
nested words, such some encoding is needed anyway in order to deal with the complex information
in XML tags, and also to provide symbolic representations with else rules that are able to deal with
inﬁnite signatures.

For the minimization of deterministic NWAs, general signatures with multiple parentheses
raise additional problems. Chervet and Walukiewicz [23] solved such problems by reducing the
minimization for expanded CDAs to the minimization of CDAs. Gauwin, Muscholl and Raskin [24]
showed that the minimization for deterministic NWAs is NP-hard in the case with general signatures.
Their approach is based on a reduction from the problem of minimal immersion for sequences of
DFAs, for which they construct NWAs with an unbounded number of opening parenthesis and an
unbounded number of entry states. Weak single-entry NWAs in our setting do not permit this. Neither
do NWAs over ﬁxed general signatures with a ﬁnite number of opening parenthesis.

Navigational XPath queries on XML documents can be formalized in the language CoreXPath
[26], or more generally by nested regular path queries [27] on data trees. Nested regular path queries

Version February 8, 2021 submitted to Algorithms

5 of 32

(cid:104)(cid:105)

c

(cid:104)(cid:105)

a

(cid:104)(cid:105)

d

(cid:104)(cid:105)

b

Figure 1. Nested word(cid:104)a · (cid:104)b(cid:105) · ε(cid:105) · c · (cid:104)d · (cid:104)ε(cid:105)(cid:105) seen as a graph.

(cid:104)site(cid:105)

(cid:104)closed_auctions(cid:105)

(cid:104)closed_auction(cid:105)

(cid:104)date(cid:105)01/01/2000(cid:104)/date(cid:105)
(cid:104)keyword(cid:105)wine(cid:104)keyword(cid:105)

(cid:104)/closed_auction(cid:105)

(cid:104)/closed_auctions(cid:105)

(cid:104)/site(cid:105)

Figure 2. An XML document.

(cid:104)doc·

(cid:104)elem · site·

(cid:104)elem · closed_auctions·

(cid:104)elem · closed_auction·

(cid:104)elem · date · 0 · 1 · / · 0 · 1 · / · 2 · 0 · 0 · 0(cid:105)
(cid:104)elem · keyword · w · i · n · e · (cid:105)

(cid:105)

(cid:105)

(cid:105)

(cid:105)

Figure 3. The corresponding nested word.

185

were introduced earlier under the name of the propositional dynamic logic (PDL) in the seventies [28],
where they are applied to labeled graphs, that generalize on data trees.

Since certain query answering for XPath was considered difﬁcult, the currently existing
approaches to XPath query evaluation on XML streams [13,18] either approximate certain query
answers based on nondeterministic machines or restrict the queries so that answer certainty can be
decided without latency [15,29]. This also holds for recent streaming algorithms on words without
nesting in the context of complex event processing [30].

190

2. Nested Words

Nested words are words with parentheses that are well-nested. They can be identiﬁed with

hedges, that is sequences of internal symbols and unranked trees.

Nested words are constructed with opening and closing parentheses, respectively (cid:104) and (cid:105). An
unranked alphabet Σ is a possibly inﬁnite set of so called "internal" symbols, that does not contain
the two parentheses. The set of nested words over Σ is denoted NΣ and is deﬁned by the following
abstract syntax:

h, h(cid:48) ∈ NΣ

::= ε

|

a

|

(cid:104)h(cid:105)

|

h · h(cid:48)

where a ∈ Σ

195

200

205

The empty nested word is denoted by ε and assumed to be the neutral element of the composition
operator ε · h = h = h · ε, which furthermore is assumed to be associative, i.e., h1 · (h2 · h3) =
(h1 · h2) · h3.

Nested words can be identiﬁed with hedges, i.e. words of trees and internal symbols. Seen as a
graph, the inner nodes are labeled by the tree constructor (cid:104)(cid:105) and the leaves by symbols in Σ or the tree
constructor. For instance (cid:104)a · (cid:104)b(cid:105) · ε(cid:105) · c · (cid:104)d · (cid:104)ε(cid:105)(cid:105) corresponds to the hedge in Figure 1. A nested word
of type tree has the form (cid:104)h(cid:105).
Variants. Our notion of nested words accepts only well-nested words without dangling opening or
closing parentheses in contrast to others [3,5]. This will lead to simpler notion of regular expressions,
avoiding the more complex operators as with visibly rational expressions [12,31]. A less important
difference is that we do not support labeled parentheses.

Version February 8, 2021 submitted to Algorithms

6 of 32

(cid:104)doc · ¬x·

(cid:104)elem · site · ¬x·

(cid:104)elem · closed_auctions · ¬x·

(cid:104)elem · closed_auction · ¬x·

(cid:104)elem · date · x · 0 · 1 · / · 0 · 1 · / · 2 · 0 · 0 · 0(cid:105)
(cid:104)elem · keyword · ¬x · w · i · n · e · (cid:105)

(cid:105)

(cid:105)

(cid:105)

(cid:105)

Figure 4. The nested word of the x-marked XML document from Figure 2.

Labeled unranked trees. Labeled parentheses can be simulated by using internal letters. For instance,
the labeled tree a(b(), c()) can be represented by the nested word of type tree (cid:104)a · (cid:104)b(cid:105) · (cid:104)c(cid:105)(cid:105). In this
way, the labeled tree a() is represented by the nested word (cid:104)a(cid:105) which is of type tree (while the internal
letter a alone is not). Unranked sequences of subtrees, often called hedges and sometimes forests, can
be composed by using the sequence operator.
XML Documents. Our notion of nested words is sufﬁciently powerful to express general XML
documents. An example of an XML document is given in Figure 2 and the representing nested
word in Figure 3.

We use the names of XML elements as labels of the nested word, as well as the letters of UTF8 for
the string data values. Further labels such as doc and elem are added to express the types of the XML
data model document and element respectively.

When it comes to querying for nodes in XML documents, we will be interested in nested words
encoding XML documents, in which a unique node is marked. We will use the label x to mark the
selected node and the label ¬x for all others. When marking the date in the XML document of Figure 2,
we obtain the nested word in Figure 4.

210

215

220

3. Nested Regular Expressions

We present nested regular expressions (NREs), that were introduced under the name regular
expression types in the context of XDuce [10] up to minor details. Note that similar nested regular
expressions for ranked trees are folklore in the context of tree automata [32].

225

3.1. Syntax and Semantics

Let the alphabet Σ be a set. An NRE over Σ is a term describing a language of nested words. It

has the following abstract syntax where a ∈ Σ:

E, E(cid:48) ::= ε | a | _ | ∅ | E · E(cid:48) | E + E(cid:48) | E&E(cid:48) | E∗ | E | (cid:104)E(cid:105) | µa.E

The µa.E expressions are the same as in µ-calculus [33], except that we restrict them such that all
occurrences of a in E are nested below parentheses. Otherwise nonregular languages could be deﬁned
such as with µa. (b · a · c + ε) whose language would be {bn · cn | n ∈ N}. We also forbid intersections
and complements in expression µa.E on all paths between the µa-operator and the occurrences of a
in E that are bound by this operator. The expressions µa.E allow for vertical recursion, while the
expressions with the Kleene star E∗ support horizontal recursion.

Our syntax allows for conjunctions E&E(cid:48) and negations E, which are well known to not add
expressiveness if Σ is ﬁnite. They are still relevant from the viewpoints of modeling, and for the
treatment of inﬁnite signatures. This comes at the price of increasing the complexity, as for the
well-known case of words [34].

230

235

Version February 8, 2021 submitted to Algorithms

7 of 32

For inﬁnite signatures, we can deﬁne for any ﬁnite subset Σ(cid:48) of labels the language of single-letter
words Σ \ Σ(cid:48) by some NRE. This can be seen as follows. If Σ(cid:48) = ∅, then the expression _ does the
job: it matches exactly the set of all labels in Σ. And if Σ(cid:48) is nonempty then we can use negation. For
instance if Σ(cid:48) = {a, b} then the expression a + b&_ describes the language Σ \ Σ(cid:48).

240

The sets of free and bound letters fn(E) and bn(E) are deﬁned as usual. The only binder µa.E

binds the symbol a with scope E. Note that f n(_) = ∅.

There are three differences with respect to the regular expression types from [10]. First, our
NREs treat labels as internal symbols instead of labels of parentheses. Second, they provide recursion
through the µ-operator instead of using recursive equation systems. Third, conjunctions and general
negations are not considered there.

245

Any NRE E describes a language L(E) of nested words that we deﬁne by induction on the

structure of E as follows: NΣ is the set of nested words over Σ, as deﬁned in Section 2.

L(a) = {a}

L(ε) = {ε}
L(E · E(cid:48)) = L(E) · L(E(cid:48))
L(E + E(cid:48)) = L(E) ∪ L(E(cid:48))
L((cid:104)E(cid:105)) = {(cid:104)h(cid:105) | h ∈ L(E)}
L(E∗) = L(E)∗

L(_) = Σ
L(E) = NΣ \ L(E)
L(E&E(cid:48)) = L(E) ∩ L(E(cid:48))
L(µa.E) = ∪n≥0L(µna.E)
L(∅) = ∅

For all expressions E, E1 and E2, the notation E[E1/E2] stands for the expression E where all the
occurrences of E1 have been replaced by E2. The semantics of a µ-operator is then deﬁned using the
shortcuts µ0a.E = E[a/∅] and µna.E = E[a/µn−1a.E] for all n ≥ 1. In particular L(µa._) = L(_) = Σ,
so that a ∈ L(µa._). The semantics of the complement expression L(E) is the complement of L(E) in
the set of all nested words, that is NΣ \ L(E).

3.2. XPATH Example

We now show how to express navigational XPATH queries by NREs that are restricted to forward
axis. The idea is to adapt the spirit of a generate-and-test algorithm for query answering. The
generation produces a nested word from XML documents by guessing a single node and marking it by
x. This node is a candidate for a query answer that is to be tested. The test is done by a NRE.

For expressing XPATH queries with child and descendant-or-self axes we will use the

following NREs where a (cid:54)∈ fn(E):

250

255

=df µa. ((cid:104)a(cid:105) + _)∗
=df T · (cid:104)E(cid:105) · T

T
ch(E)
ch∗(E) =df µa. (E + ch(a))
ch+(E) =df µa. (ch(E) + ch(a))

For instance, consider the XPATH query A5 from the XPathMark benchmark [17]:

/site/closed_auctions/closed_auction[descendant::keyword]/date

Applied to the above XML document, it selects all date children of closed_auctions nodes that
contain at least one keyword descendant. Query A5 can be compiled to the following NRE, which will
accept the nested word in Figure 4 in particular:

(cid:104)doc · _ · (cid:104)elem · site · _ · ch(elem · closed_auctions · _ · ch(

elem · closed_auction · _ · (ch+(elem · keyword · _ · T) & ch(elem · date · x · T))))(cid:105)(cid:105)

260

The only label that the expression _ may match on a document that is properly annotated with the
variable x will be the letter ¬x ∈ Σ. The label x is annotated to the marked node, which is tested for

Version February 8, 2021 submitted to Algorithms

8 of 32

A1: /site/closed_auctions/closed_auction/annotation/description/text

/keyword

A2: //closed_auction//keyword
A3: /site/closed_auctions/closed_auction//keyword
A4: /site/closed_auctions/closed_auction

[annotation/description/text/keyword]/date

A5: /site/closed_auctions/closed_auction[descendant::keyword]/date
A6: /site/people/person[profile/gender and profile/age]/name
A7: /site/people/person[phone or homepage]/name
A8: /site/people/person

[address and (phone or homepage) and (creditcard or profile)]
/name

B3: /site/open_auctions/open_auction/bidder[following-sibling::bidder]

Figure 5. XPath benchmark queries.

being selected by the query. The label ¬x is annotated to all other nodes beside of the unique x-marked
node.

Note also that the µ-operator of the ch+(. . .)-expression expresses the recursion of the descendant

265

axis. Furthermore, the conjunction permits us to connect the main path of A5 with its only ﬁlter.

3.3. XPath Benchmark

270

275

For testing NREs, we rely on the usual XPathMark benchmark [17]. We restrict ourselves to
navigational path queries with forward axis: child, descendant, and following-sibling. We notice
that the following axis is excluded in contrast to following-sibling, since following is not strictly
forwards. We can also admit path composition and ﬁlters with conjunction, disjunction and negation.
The XPATH queries of the benchmark satisfying these restrictions are the queries A1, . . . , A8 and
B3 given in Figure 5. We developed a more general compiler from navigational forward XPATH queries
to NREs, which yields the NREs in Figure A1 of the appendix for the benchmark XPATH queries. The
NREs for A1-A3 do have neither conjunctions nor negations, while the queries A4-A8 contain ﬁlters,
which are mapped to conjunctions in NREs. The compiler uses the µ-operator to capture the recursion
of descendant axis as in A2, A3, and A5. Furthermore, nondeterminism is introduced by disjunctions
in ﬁlters as in A7 and A8. Conjunction in ﬁlters appears in A6 which is mapped to conjunctions in
NREs too. A detailed description of this compiler is not in the scope of the present article though.

4. Nested Word Automata

280

Nested word automata (NWAs) are pushdown automata reading nested words, whose stacks
are visible: they push a single stack symbol when reading an opening parenthesis, pop a single stack
symbol when reading a closing parenthesis, and do not alter or inspect the stack otherwise.

Deﬁnition 1. An NWA is a tuple A = (Qh, Qt, Σ, Γ, ∆, I, F) consisting of a possibly inﬁnite set Σ of internal
symbols, ﬁnite sets Qh and Qt of states of type hedge and tree respectively, sets of initial and ﬁnal states
I, F ⊆ Qh, a ﬁnite set Γ of stack symbols, and a ﬁnite set ∆ of transition rules of the forms:

hedge rules
opening rules
tree rules
closing rules

∆ ⊆ Qh × Qh where a ∈ Σ
where γ ∈ Γ

∆

∆

a
, _
, ε
∆
(cid:104)
γ ⊆ Qh × Qh
T∆ ⊆ Qh × Qt
∆
γ ⊆ Qt × Qh
(cid:105)

Our NWAs are symbolic, in that they come with else rules, i.e elements of (q, q(cid:48)) ∈ _

denote by q

_−→ q(cid:48), for dealing with large or inﬁnite alphabets.

∆

that we will

Version February 8, 2021 submitted to Algorithms

9 of 32

Figure 6. Nested word automaton nwa(ch∗(a + b)).

An example for an NWA is given in a graphical syntax in Figure 6. Tree states are drawn in circles
that are ﬁlled in light gray q , while hedge states are in unﬁlled circles q . Initial states are drawn
where o ∈ Σ ∪ {_, ε} are
as → q and ﬁnal states as q . Hedge rules that have the form (q1, q2) ∈ o
∆
γ

is denoted q1 −→ q2. Opening rules (q1, q2) ∈ (cid:104)

o−→ q2, while any tree rule (q1, q2) ∈ T∆

denoted by q1

∆

are represented as q1

↓γ
−−−

q2 and closing rules (q1, q2) ∈ (cid:105)

∆
γ as q1

↑γ
−−−

q2.

(cid:17)

Our notion of NWAs supports factorization in the spirit of [35]. It is obtained by distinguishing
two types of states q ∈ Qh and p ∈ Qt, and adding explicit type coercion rules q −→ p. Semantically,
both kinds of states could be merged when replacing the type coercion rules by the epsilon rule
ε−→ p, but at the cost of introducing additional nondeterminism. This may lead to quadratically larger
q
deterministic automata, as we will illustrate at the NWA in Figure 20.

(cid:17)

285

290

295

The language of nested words between two states q1, q2 ∈ Qh is deﬁned as the least language

such that:

Lq1,q2 (∆) = {ε | if q1 = q2 or q1

ε−→ q2 ∈ ∆} ∪ (cid:83)
q3∈Qh
_−→ q2 ∈ ∆ and ¬∃q(cid:48)

Lq1,q3 (∆) · Lq3,q2 (∆)

∪ {a | if q1
∪ {(cid:104)h(cid:105) | ∃q(cid:48)

a−→ q2 ∈ ∆ or (q1
1, q(cid:48)

2 ∈ Qh.∃q3 ∈ Qt.∃γ ∈ Γ. q1

↓γ
−−−

a−→ q(cid:48)

2. q1
q(cid:48)
1, h ∈ Lq(cid:48)

2 ∈ ∆)}
(∆),

1,q(cid:48)

2

q(cid:48)
2 −→ q3 ∈ ∆ and q3

↑γ
−−−

q2 ∈ ∆}.

(cid:17)

The language of the NWA then is L(A) =

(cid:83)
q1∈I,q2∈F

(cid:17)
Lq1,q2 (∆).

4.1. Determinization of NWAs

300

305

Determinization for NWAs was ﬁrst studied by von Braunmühl and Verbeek [2] in the eighties,
where NWAs are named input driven pushdown automata. We notice that the determinization algorithm
was published only in the journal version of this paper, but not in the conference version. Later on, the
same algorithm was rediscovered in the context of visibly pushdown automata and republished for
nested word automata.

Deﬁnition 2. An NWA A is called deterministic or equivalently a dNWA if

∆

• I contains at most one element,
• there is no epsilon rule, i.e., ε
• a
• for all q ∈ Qh and γ ∈ Γ there exists a most one q(cid:48) ∈ Qh such that q(cid:48) ∈ (cid:104)
• (cid:105)

are partial functions from Qh to Qh for all a ∈ Σ, and T∆

∆
γ is a partial function from Qt to Qh for all γ ∈ Γ.

∆ = ∅,

and _

∆

∆
γ ,

is a partial function from Qh to Qt,

Version February 8, 2021 submitted to Algorithms

10 of 32

_

0

↑ γ0

↓ γ1
↑ γ1
_

↓ γ0

1

1(cid:48)

Figure 7. The NWA T maps top level positions to state 0 and nested positions to 1 or 1(cid:48).

310

Proposition 1 (von Braunmühl and Verbeek [2]). A NWA with n states can be determinized in time O(2n2 ).

Many of our results are based on the determinization algorithm going back to von Braunmühl
and Verbeek. For self-containedness, we recall the version of this algorithm that we will use in the
Appendix A. For illustrations, the determinization of the NWA in Figure 6 is also presented here too,
see Figure A2. It has size 271 while the nondeterministic NWA has size 39 (12 states + 2 letters + 3 stack
symbols + 22 rules). The blow-up is even worse in general as our experimental results will show and
as noticed earlier by [18].

4.2. Multi-module NWAs

Multi-module NWAs will play a prominent rôle for our NWA constructions and are relevant for
minimization [23]. For signatures with a single opening parenthesis, each multi-module NWAs has
exactly two modules, one for the top level and one for the nested level.

We can deﬁne multi-module NWAs based on the natural notion of homomorphisms for NWAs.
A homomorphism from an NWA A to an NWA A(cid:48) with the same signature is a triple of functions
t, β : Γ → Γ(cid:48)) that maps all concepts of A to the corresponding concepts of
(αh : Qh → Q(cid:48)
A(cid:48). These concepts are hedge initial states, ﬁnal states, opening, closing, internal, and tree transitions.
We do not enforce the preservation of epsilon rules by homomorphisms.

h, αt : Qt → Q(cid:48)

Deﬁnition 3. A multi-module NWA A is an NWA for which there exists a homomorphism from A to the
NWA T in Figure 7.

The NWA T evaluates all top level positions of a nested word to state 0, all those positions that
are not between parentheses. All nested positions are evaluated to state 1. The homomorphism of a
multi-module NWA A to T thus partitions the states of A between those that can be assigned to top
level positions, and the others that can be assigned to nested positions.

315

320

325

330

4.3. Compilation of NREs to NWAs

We next discuss a compiler from NREs E to NWAs nwa(E). This compiler extends on the
McNaughton-Yamada-Thompson algorithm [36] for regular expressions, which introduces epsilon
edges for constructing the automata of composition E · E(cid:48).

335

Theorem 1. For any NRE E we can construct an NWA A such that L(A) = L(E). If E contains neither
conjunctions nor negations, then the construction is in time O(|E|).

Proof sketch. Conjunctions E&E(cid:48) are compiled to products of automata, so repeated conjunctions
may lead to an exponential blow up. Negations E are computed by complementing automata based on
determinization. Each complementation may lead to an exponential blow-up, so when this is repeated,
the construction may become non-elementary.

340

For expressions without conjunction and negation, no such blow-up may arise. As stated by the

theorem, we have to show that expressions can be compiled in linear time.

Case E = E(cid:48) · E(cid:48)(cid:48): We use the McNaughton-Yamada-Thompson algorithm for composing the NWAs of

345

nwa(E(cid:48)) and nwa(E(cid:48)(cid:48)).

Version February 8, 2021 submitted to Algorithms

11 of 32

↓ γ

q0

a

q1

↑ γ

q2

q3

Figure 8. Automaton for the (cid:104)a∗(cid:105)
expression.

(q0 , 0)

↓ (γ, γ0 )

(q3 , 0)

↑ (γ, γ0 )

↓ (γ, γ1 )

(q0 , 1)

(q1 , 1)

(q2 , 1(cid:48) )

↑ (γ, γ1 )

(q3 , 1)

q0

↓ γ

ε

q1

↑ γ

q3

q2
ε

Figure 9. Wrong naive construction for µa.(cid:104)a∗(cid:105)

(q0 , 0)

↓ (γ, γ0 )

↓ (γ, γ1 )

(q0 , 1)

(q1 , 1)

ε

(q2, 1(cid:48) )

ε

(q3 , 0)

↑ (γ, γ0 )

↑ (γ, γ1 )

(q3 , 1)

a

Figure 10. The multi-module NWA for (cid:104)a∗(cid:105).

Figure 11.
construction for µa.(cid:104)a∗(cid:105)

The correctly adapted naive

Case E = (cid:104)E(cid:48)(cid:105): Let Q(cid:48)

h, Q(cid:48)

t and Γ(cid:48) be respectively the set of hedge states, tree states and stack symbols
h, a new tree state p not in Q(cid:48)
of nwa(E(cid:48)). We consider new hedge states qi and q f that are not in Q(cid:48)
t
and a new stack symbol γ not in Γ(cid:48). Then nwa(E) is constructed by adding to nwa(E(cid:48)) opening
q for all the initial states q of nwa(E(cid:48)), tree rules q(cid:48) −→ p for all the ﬁnal states q(cid:48) of

↓γ
−−−

↑γ
−−−

q f . Furthermore we set qi as the only initial state of nwa(E),

rules qi
nwa(E(cid:48)) and a closing rule p
and q f as its sole ﬁnal state.

(cid:17)

(cid:17)

Case E = µa.E(cid:48): Special care has to be given to repeat expression µa.E. First of all, the naive
compilation approach for these expression turns out to be wrong. And second, ﬁxing the
problem in the simplest possible manner does not lead to a linear time algorithm.

Note that we can assume w.l.o.g. that a occurs at most once in E by using the golden lemma
of the µ-calculus [37], stating for all names a1, . . . , an and expressions E(cid:48)(cid:48) in which a1, . . . , an
can appear free that µa1. . . . .µan. E(cid:48)(cid:48) ≡ µa.E(cid:48)(cid:48)[a1/a, . . . , an/a]. Our construction guarantees that
a−→ q(cid:48) in nwa(E) will start with the same state q. The wrong naive
all transitions of the form q
a−→ q(cid:48) from nwa(E) and add ε-rules from q to all the
construction would remove the transitions q
initial states of nwa(E), and from all ﬁnal states of nwa(E) to q(cid:48). Unfortunately, the construction
is not correct. For illustration, we consider the NRE E = µa.(cid:104)a∗(cid:105). The reader should be warned
that constructing an NWA for E is less trivial than it might seem at ﬁrst sight. One has to start
from the NWA for (cid:104)a∗(cid:105) which is given in Figure 10. Simply adding epsilon edges to capture
the operator µa will not work though. It will lead to the wrong automaton in Figure 9. This
automaton will wrongly accept the hedge (cid:104)(cid:105)(cid:104)(cid:105), since this hedge does not belong to L(E).

If the NWA for E is multi-module, then the naive construction of compiling µa.E can be made
correct. So the simplest ﬁx is to make the NWA multi-moduled, before applying the naive
construction. This can be achieved by typing the states of the automaton, by states of the NWA T
in Figure 7. The added types yield the homomorphism of the constructed automaton to T .

The naive algorithm is then adapted as follows. Let P be the multi-module NWA obtained from
the product of nwa(E) and T . Note that we keep only the accessible top level states (type 0),
but all nested states (type 1). In our example this yields the NWA in Figure 11. We then remove
transition (q, 1) a−→ (q(cid:48), 1) and add ε-rules from state (q, 1) to all states in I × {1}, and from all
states in F × {1} to (q(cid:48), 2), where I and F are respectively the set of initial and ﬁnal states of
nwa(E). Then P recognizes L(µa.E). The result obtained in the example is shown in Figure 11.

The algorithm described so far makes the NWA multi-moduled before compiling a µ-operator.
For this, two copies of all states are introduced. This, however, could lead to an exponential
construction, if multiple µ-operators are nested. This problem can be avoided by preserving
multi-moduledness as an invariant. Whenever a new state is created, it is created twice, once for
the top level and once for the nested level. This information is maintained by typing the states,
so that no further copies of the same state are produced later on.

350

355

360

365

370

375

380

Version February 8, 2021 submitted to Algorithms

12 of 32

nwa(.)

221 (68)

185 (49)

189 (54)

625 (193)

486 (135)

2170 (653)

434 (135)

10597 (3127)

253 (77)

A1

A2

A3

A4

A5

A6

A7

A8

B3

det(nwa(.))

step(nwa(.))

det(nwa(step(nwa(.))))

nwa(det(step(nwa(.))))

—

362600 (6782)

318704 (8216)

—

—

—

—

—

—

231 (88)

224 (81)

213 (79)

414 (159)

516 (190)

1005 (391)

378 (146)

21848 (7022)

239 (91)

398 (37)

4105 (148)

907 (62)

487 (42)

1192 (73)

548 (45)

468 (41)

—

423 (38)

409 (37)

1659 (127)

635 (56)

499 (42

868 (67)

561 (45)

480 (41)

—

407 (37)

Figure 12. The size (#states) of the NWAs for the benchmark NREs and the automata derived thereof.

We omit the correctness proof of this construction.

4.4. Experimental Results Starting with the NWA Compiler

385

390

395

400

405

410

In the ﬁrst two column of Figure 12, we report the sizes of the NWAs obtained from NREs by our
compiler, and the size of the deterministic NWAs produced thereof. For each automaton we give its
total size and in parentheses the number of states.

The sizes of the nondeterministic NWAs produced by the compiler for the NREs for A1-A8 and
B3 are given in column nwa(.) of Figure 12. Note that the NWAs are cleaned so that only accessible
and co-accessible states remain. The sizes of the nondeterministic NWAs are acceptable for all NREs,
except for A8 for which the NWA has more than 3000 states and an overall size greater than 10000.
This can be partially explained by the fact that the NRE for A8 contains 3 conjunctions (1 for the ﬁlter
and 2 for the conjunctions in the ﬁlter). But still, the number of states remains surprising.

The determinized NWAs are given in column det(nwa(.)). It turns out that only A2 and A3 could
be determinized successfully with some few hours of computation time on a standard laptop. But
even in the successful cases, the resulting deterministic NWAs are simply huge. This conﬁrms similar
problems ﬁrst noticed in [18] and not solved since then.

The remaining columns of Figure 12 based on the back-and-forth compiler from SHAs to NWAs
from the following Section 6. They show that better determinization algorithms can indeed be
obtained, yielding NWAs of acceptable size for all benchmark queries, with the exception of A8. The
idea of det(nwa(step(nwa(.))) is to compile the NWAs obtained from the NREs to stepwise hedge
automata and back before applying the above algorithm for NWAs. This might be surprising, since
this determinization algorithm failed for the original NWAs, while it now proves successful on the
forth-and-back transformed NWAs.

5. Stepwise Hedge Automata

We propose SHAs as an extension of stepwise tree automata [21] that allows to recognize not only
unranked trees but also hedges. We avoid more classical hedge automata from [9] that were already
introduced in 1967 by Thatcher [8], since their notion of determinism is problematic. For instance it
makes unique minimization fail [38] and universality hard.

Our notion of SHAs will be symbolic in using else rules, and factorized in the sense of [35]: there
are two types of states for hedges and trees and an operator for explicit type coercion. We also propose
a novel treatment of internal letters inspired by nested word automata, so that SHAs generalize both
on stepwise tree automata and on NFAs.

Deﬁnition 4. A SHA is a tuple A = (Qh, Qt, Σ, ∆, I, F) such that Qt and Qh are ﬁnite sets of states of two
types t for tree and respectively h for hedge, Σ an alphabet of internal letters (that may be inﬁnite), I, F ⊆ Qh

Version February 8, 2021 submitted to Algorithms

13 of 32

Figure 13. Stepwise hedge automaton step(ch∗(a + b)): the part with the stepwise tree automaton is
on the left and middle, and the NFA part on the right.

are subsets of hedge initial and ﬁnal states respectively, and ∆ is a ﬁnite set of transition rules such that for all
q ∈ Qt and a ∈ Σ:

hedge rules
tree ﬁnal rules
tree initial states

∆

∆

∆

, ε

, a

q
, _
T∆ ⊆ Qh × Qt
⊆ Qh
(cid:104)(cid:105)

∆

∆ ⊆ Qh × Qh

An example for a SHA is given in graphical syntax in Figure 13. It recognizes all hedges which
are either just a or b or contain some tree node that contains either just a or b. In the graphical syntax,
the states of type tree q ∈ Qt are drawn in circles ﬁlled in light gray q , while the states of type hedge
q(cid:48) ∈ Qh are drawn in unﬁlled circles q(cid:48) . The right part of the graph is an NFA which uses tree states as
additional edge labels, while the left part is a stepwise tree automaton, that deﬁnes the tree languages
of these tree states.

Let ∆

h be the restriction of ∆ to the hedge rules. Then, (Qh, Σ (cid:93) Qt, ∆

h, I, F) is a standard NFA
with ε-rules, which is symbolic [39] in providing else rules for dealing with large or inﬁnite alphabets
h−→ q and the ﬁnal states q ∈ F by
in addition. Therefore, we denote the hedge initial states q ∈ I by
a−→ q2 ∈ ∆ stating that a hedge in state
q . A rule with an internal letter (q1, q2) ∈ a
q1 can be extended by the internal letter a leading to a hedge in state q2. Similarly, an epsilon rule
_−→ q2. In the same
(q1, q2) ∈ ε
q2 ∈ ∆, stating that a
spirit, a hedge rule (q1, q2) ∈ q
hedge in state q1 can be extended by a tree in state q leading to a hedge in state q2.

ε−→ q2, and an else rule (q1, q2) ∈ _

– also called apply rule – is denoted by q1

is denoted by q1

is denoted by q1

is denoted by q1

q
−−−

∆

∆

∆

∆

A tree initial state q ∈ (cid:104)(cid:105)

by
q1 −→ q2. Intuitively, a tree (cid:104)h(cid:105) can be evaluated to state q if h can be evaluated starting with some
to some state q2 such that q2 −→ q ∈ ∆. More formally, the hedge languages
tree initial state q1 ∈ (cid:104)(cid:105)
Lq1,q2 (A) between any two hedge states q1, q2 ∈ Qh are deﬁned as follows:

is graphically denoted by

∆

(cid:17)
t−→ q and a tree ﬁnal rule (q1, q2) ∈ T∆

∆

Lq1,q2 (A) = {ε | if q1 = q2 or q1

∪ {a | if q1
∪

(cid:83)

q
−−−

q1

q2∈∆

a−→ q2 ∈ ∆ or (q1

Lq(A)

ε−→ q2 ∈ ∆} ∪ (cid:83)
q3∈Qh
_−→ q2 ∈ ∆ and ¬∃q(cid:48)

Lq1,q3 (A) · Lq3,q2 (A)

2. q1

a−→ q(cid:48)

2 ∈ ∆)}

This deﬁnition is mutually recursive with the deﬁnition of the tree languages Lq(A) of all tree states
q ∈ Qt:

(cid:17)

Lq(A) = {(cid:104)h(cid:105) |

t−→q1 ∈ ∆, h ∈ Lq1,q2 (A), q2 −→ q ∈ ∆}

The hedge language L(A) that is recognized by the automaton is

(cid:83)
q1∈I,q2∈F

Lq1,q2 (S). The rules of

standard bottom-up tree automata have the form a(q1, . . . , qn) → q where a is a symbol of arity n. With
q1−−−
t−→ p0
pn −→ q where the states
SHAs, this rule can be encoded by the sequence
q1, . . . , qn, q are all tree states, and p0, . . . , pn new hedge states.
(cid:17)

a−→ p1

qn
−−−

. . .

(cid:17)

415

420

425

430

Version February 8, 2021 submitted to Algorithms

14 of 32

Q1 ⊆ Qh P ⊆ Qt Q2 = {q2 | ∃q1 ∈ Q1, p ∈ P. q1
P
−−−

∆∗ (Q2) ∈ ∆det

Q1

ε

q2 ∈ ∆}

p
−−−

(cid:17)

(cid:17)

Q1 ⊆ Qh
Q(cid:48)
2 = {q2 | ∃q1 ∈ Q1. q1

a ∈ lab(Q1) Q2 = {q2 | ∃q1 ∈ Q1, q1
_−→ q2 ∈ ∆ and (cid:54) ∃q3 ∈ Q.q1
∆∗ (Q2 ∪ Q(cid:48)

2) ∈ ∆det

a−→ ε

Q1

a−→ q2 ∈ ∆}
a−→ q3 ∈ ∆}

Q1 ⊆ Qh Q2 = {q2 | ∃q1 ∈ Q1, q1 −→ q2 ∈ ∆}

Q1 −→ ε

∆∗ (Q2) ∈ ∆det

Q2 = {q2 | ∃q1 ∈ Q1, q1
_−→ ε

∆∗ (Q2) ∈ ∆det

Q1

_−→ q2 ∈ ∆}

Figure 14. Determinization of SHAs

5.1. Determinization of SHAs

We formalize the notion of determinism for stepwise hedge automata and show how

determinization works.

Deﬁnition 5. A SHA (Qh, Qt, Σ, ∆, I, F) is deterministic or equivalently a dSHA, if it satisﬁes the following
conditions:

435

∆

• I contains at most one element,
• (cid:104)(cid:105)
contains at most one element,
• there is no epsilon transition, i.e., ε
∆
• a
• T∆

, q
is a partial function from Qh to Qt.

, _

∆

∆

∆ = ∅,

are partial functions from Qh to Qh for all a ∈ Σ and q ∈ Qt, and

440

Proposition 2. A SHA of size n can be made deterministic in time O(2n) while preserving the hedge language.

Proof. The determinization procedure for SHAs combines the determinization algorithms of word
and tree automata in the natural manner, while eliminating epsilon transitions. Let ε
be the reﬂexive
∆∗ (q). Given a
∆∗ (Q) = (cid:83)
and transitive closure of ε
q∈Q

, and for any subset Q ⊆ Qh ∪ Qt let ε

∆∗

∆

ε

SHA A = (Qh, Qt, Σ, ∆, I, F), we deﬁne an equivalent deterministic SHA det(A) = (Qdet
∆det, Idet, Fdet) such that Qdet
t = 2Qt , Idet = {ε
h = 2Qh , Qdet
∆det
∆∗ ((cid:104)(cid:105)
There is a unique tree initial state in (cid:104)(cid:105)
rules in Figure 14 deﬁne the missing part of ∆det. We can show for all Q1, Q2 ⊆ Qh and P ⊆ Qt that

, Σ,
∆∗ (I)} and Fdet = {Q(cid:48) ⊆ Qh | Q(cid:48) ∩ F (cid:54)= ∅}.
∆det = ∅. The inference

)} and no ε-rule, that is ε

h , Qdet
t

= {ε

∆

LQ1,Q2

(det(S)) =

(cid:91)

Lq1,q2 (S)

q1∈Q1,q2∈Q2

Lq(cid:48) (S). Hence L(det(S)) = (cid:83)

Q(cid:48)∈Fdet

LI,Q(cid:48) (det(S)) and thus L(det(S)) =

so that LP(det(S)) = (cid:83)
q(cid:48)∈Q(cid:48)

(cid:83)
q1∈I,q2∈F

Lq1,q2 (S) = L(S).

For illustration, the deterministic SHA in Figure 15 is obtained by determinization of the SHA in

445

Figure 13.

5.2. Compilation of NREs to SHAs

As for NWAs, we introduce the notion of multi-module SHAs for which the sets of hedge states
are partitioned between those that can evaluate top level positions and those to which nested positions
are assigned. So multi-module SHAs will have exactly two modules too.

Version February 8, 2021 submitted to Algorithms

15 of 32

0 = {1, 3, 5, 6}
1 = {8, 10, 14, 16, 18, 19}
2 = {2, 5, 6}
3 = {4, 5, 6}
4 = {5, 6}
5 = {9, 10, 15, 18, 19}
6 = {9, 10, 17, 18, 19}
7 = {10, 18, 19}
8 = {(cid:104)T(cid:105)}
9 = {(cid:104)T(cid:105), (cid:104)x(cid:105)}
10 = {9, 10, 18, 19, 20}
11 = {5, 6, 12}

Figure 15. The determinized SHA det(step(ch∗(a + b))).

450

Deﬁnition 6. A SHA A = (Qh, Qt, Σ, ∆, I, F) is a multi-module SHA if there is a subset of states Q0
that we call top level states, such that:

h ⊆ Qh,

• I ⊆ Q0
h
• the states in Q0

h can reach only other states in Q0

h via ∆.

455

460

For instance, consider the multi-module SHA in Figure 13. The states of module for the top level

are Q0 = {1, 2, 3, 4, 5, 6, 12}. The others belong to the module for the nested level.

Any NRE E can be compiled to a multi-module SHA step(E) = (Qh, Qt, Σ, ∆, I, F) such that
| E(cid:48) = (cid:104)E(cid:48)(cid:48)(cid:105) subexpression of E} and Lt(E(cid:48)) = L(E(cid:48)) for all tree states E(cid:48) ∈ Qt. The
such that Atop =

Qt = {E(cid:48)
SHA step(E) can be partitioned into disjoint SHAs step(E) = Atop ∪ (cid:83)
E(cid:48)∈Qt
, ∅, ∅) for all E(cid:48) ∈ Qt and (cid:104)(cid:105)

(Qtop
= ∅. Note that the
transitions relation ∆ is decomposed thereby into independent connected components. The automaton
Atop can be identiﬁed with an NFA with signature Σ ∪ Qt given that it has no tree initial states. The
automata AE(cid:48)
are stepwise tree automata that recognize the tree language L(E(cid:48)) when taking E(cid:48) as
ﬁnal state. For this, they may have tree initial states, but will not have any initial nor ﬁnal states.

h , Qt, Σ, ∆top, I, F) and AE(cid:48) = (QE(cid:48)

h , Qt, Σ, ∆E(cid:48)

AE(cid:48)

∆top

Theorem 2. For any NRE E we can construct a SHA A such that L(A) = L(E). If E contains neither
conjunctions nor negations, then the construction is in time O(|E|).

465

Proof sketch. For the case of expressions with conjunctions or negations, the construction is analogous
to the way it is done for NWAs. We next sketch the construction of SHAs for expressions without
conjunction and negation.

Case E = E(cid:48) · E(cid:48)(cid:48): We use McNaughton-Yamada-Thompson algorithm [36] for composing the
multi-module NFAs of step(E(cid:48)) and step(E(cid:48)(cid:48)). The stepwise tree automata A(cid:104)E(cid:48)(cid:48)(cid:48)(cid:105) of the
subexpressions of type tree are preserved. For succinctness, if some subexpression (cid:104)E(cid:48)(cid:48)(cid:48)(cid:105) occurs
more than once, then only a single copy of A(cid:104)E(cid:48)(cid:48)(cid:48)(cid:105) is kept. References to states of the removed
copy should be renamed to their equivalent counterparts.

Case E = (cid:104)E(cid:48)(cid:105): We construct step(E) from step(E(cid:48)). The initial states of step(E(cid:48)) are turned into tree
initial states. We then add a new tree state (cid:104)E(cid:48)(cid:105) and connect it to all ﬁnal states of step(E(cid:48)) by a
tree ﬁnal rule q −→ (cid:104)E(cid:48)(cid:105). Furthermore, the previously ﬁnal state q becomes non ﬁnal. Finally

we add a new initial state qi, a new ﬁnal state q f and a transition rule

h−→qi

(cid:104)E(cid:48)(cid:105)
−−−

q f .

Case E = µa.E(cid:48): The main idea of the construction is similar to the case of NWAs. The correctness

(cid:17)

argument relies on the invariant that only multi-module SHAs are built.

Again by the golden lemma of the µ-calculus, we can assume w.l.o.g. that a occurs at most once
in E(cid:48). By using ε-rules, we can preserve the invariant that there will be at most one pair (q, q(cid:48))
a−→ q(cid:48) in step(E(cid:48)). Furthermore, these transitions cannot be on top level, given that
such that q
the occurrence of a in E(cid:48) must be nested below parentheses. The automaton step(E) is obtained
from step(E(cid:48)) by ﬁrst copying the top level NFA of step(E(cid:48)), as in Figure 16. We thus obtain two
versions for each state of the top level NFA of step(E(cid:48)): one referred to as the top level copy – q0,0

470

475

480

485

Version February 8, 2021 submitted to Algorithms

16 of 32

h

q0,0

q2,1

q3,0

h

q0,0

q2,1

q3,0

q0,1

a

q1,1

t

q2,1

q3,1

q2,1

q0,1

ε

t

q1,1

q2,1

ε

q3,1

q2,1

Figure 16. SHA for (cid:104)a∗(cid:105)

Figure 17. SHA for µa.(cid:104)a∗(cid:105)

step(.)

det(step(.))

nwa(det(step(.)))

nwa(step(.))

det(nwa(step(.)))

A1

A2

A3

A4

A5

A6

A7

A8

B3

154 (56)

120 (41)

128 (45)

187 (66)

211 (70)

284 (90)

188 (64)

145 (36)

427 (56)

305 (43)

167 (41)

411 (54)

189 (44)

170 (40)

417 (37)

899 (57)

622 (44)

510 (42)

897 (55)

587 (45)

502 (41)

210 (57)

177 (42)

181 (46)

256 (67)

298 (71)

394 (91)

260 (65)

398 (37)

4105 (148)

907 (62)

487 (42)

1192 (73)

548 (45)

468 (41)

1106 (267)

749 (123)

2831 (124)

1549 (268)

2520 (124)

156 (58)

157 (35)

419 (36)

214 (59)

423 (38)

Figure 18. The SHAs for the benchmark NREs and the automata derived thereof.

and q3,0 in Figure 16 –, and another one as the nested level – q0,1 and q3,1 in Figure 16. Only top
level states may be initial or ﬁnal. Then we add ε-rules from q to the nested states that correspond
to the initial states of step(E(cid:48)), and from the nested states corresponding to the ﬁnal states of
a−→ q(cid:48).
step(E(cid:48)) to q(cid:48). Finally we remove the rule q

Note that every transition added for a state – top level or nested – in a subsequent step of the
construction – except the ε-rules added for µ-expressions – must also be added for its copy.
The construction is correct since the µ-bound name a is nested below parenthesis in E(cid:48). Therefore,
it can be shown that the ε-edges introduced cannot be used to produce unwanted order in
successful runs. That this invariant can be maintained in polynomial time requires an additional
argument. Instead of copying the top level parts of subexpressions, each state is introduced twice
during the construction: one version for nesting, and another one for being part of top level parts.
This way the size of the automaton is not doubled at each step, but only once.

We omit the correctness proof of this construction.

Unlike NWAs, one cannot preserve the determinism of the expressions of nregexp(ch, T) in SHAs,
even with Glushkov-like constructions. For instance, for the deterministic NRE (cid:104)a1 · (cid:104)a2 · . . . · (cid:104)an(cid:105) . . . (cid:105)(cid:105),
one would have an SHA having a tree initial state for each of the (cid:104)ai . . . (cid:105) subtree, implying
nondeterminism.

490

495

500

5.3. Experimental Results Starting with the SHA Compiler

In the ﬁrst two column of Figure 18, we report the size of the SHAs obtained from NREs by our

505

compiler, and the size of the deterministic SHAs produced thereof.

The SHA compiler yields automata of acceptable size from the NREs of all benchmark queries.
These sizes are given in the ﬁrst column step(.) of Figure 18. This even holds for A8, in contrast to the
case where the produced SHA has overall size 1106 and 267 states.

The determinization of the SHAs in the second column det(step(.)) even yields smaller automata
in all cases. For A8 we obtain a deterministic stepwise automaton of overall size 749 and with 123

510

Version February 8, 2021 submitted to Algorithms

17 of 32

states. This might be surprising, in that the determinization algorithm may lead to an exponential
blow-up in the worst case. But it may also clean the automaton, keeping only accessible sets of states.
This is what seems to happen systematically on the benchmark with the exception of A2, where the
size goes up by a factor of four and A5 where the size doubles. For A2 the number of states grows by
one third, while for A5 it decreases by one third.

515

Based on the back-and-forth compiler from SHAs to NWAs from following Section 6, we can
obtain deterministic NWAs of acceptable size for all benchmark queries. The method nwa(det(step(.)))
yield for A a dNWA of size 2831 and with 124 states. The alternative method det(nwa(step(.))) yields a
dNWA of size 2520 which is even smaller, and the same number of states.

520

6. NWAs versus SHAs

We next show how to compile SHAs to NWAs such that determinism is preserved, and back while
introducing nondeterminism. Thereby we can obtain small NWAs for NREs such as E = ch∗(a + b) for
which det(nwa(E)) blew up in size in a surprising manner (see Figure 12).

6.1. SHAs to NWAs

525

As a ﬁrst step, we introduce a transformation on SHAs, so that for any SHA A:

• if A is deterministic, the transformation returns A,
• if A is nondeterministic with set of hedge states Qh and transition relation ∆, the transformation
h = Qh (cid:93) {qt-init} where qt-init is a new hedge state,
∆ ∪ {(qt-init, q) |

returns a new SHA A(cid:48) with set of hedge states Q(cid:48)
and set of transitions ∆(cid:48) which equals ∆ except that (cid:104)(cid:105)
q ∈ (cid:104)(cid:105)

= {qt-init} and ε

∆(cid:48) = ε

∆(cid:48)

∆

}.

Then we compile any SHA A = (Qh, Qt, Σ, ∆, I, F) obtained after the above transformation to
∆
,

an NWA nwa(A) = (Qh, Qt, Σ, Γ, ∆(cid:48), I, F) such that L(A) = L(nwa(A)). We set Γ = Qh, _
∆(cid:48) = a
a

for all a ∈ Σ, ε

, T∆(cid:48) = T∆

∆(cid:48) = _

∆(cid:48) = ε

∆

∆

:

q1

↓q2−−−
(cid:17)

∈ ∆ p ∈ (cid:104)(cid:105)
↑q1−−−
(cid:17)

p ∈ ∆(cid:48) and q

q1

↓q1−−−
(cid:17)

∆

q2 ∈ ∆(cid:48)

Clearly, if S is deterministic then so is nwa(S), since p is unique in this case in particular. One might be
tempted to skip the ﬁrst-step transformation and restrict the above construction rule to states p such
/{p}]) (cid:54)= ∅. However, this would lead to a huge blow-up when determinizing these
that Lq(S[(cid:104)(cid:105)
NWAs, basically since this change spoils the single-entry property discussed in Deﬁnition 7.

∆

The conversion of step(ch∗(a + b)) in Figure 13 yields the NWA in Figure 19. Note that the opening
rules are deterministic (but not the whole NWA), since for all tree states q there is at most one hedge
state p with (cid:104)(cid:105) → p such that q is accessible from p. The NWA has size 64, while its determinization
has size 159 (see Figure A4 of the appendix). The size increase raised by determinization is thus
95 = 159 − 64 for this NWA.

The size increase for determinization is considerably smaller for the NWA obtained from the
regular expressions by indirection via a SHA than for NWAs obtained by direct compilation. Indeed,
the determinization of nwa(ch∗(a + b)) blows the size from 39 to 271. The size increase for the
determinization of nwa(ch∗(a + b)) is thus 242 = 271 − 39 while for nwa(step(ch∗(a + b))) it is only
95 = 159 − 64.

The experiments will show that this is not an exception but the general rule. Intuitively, the reason
is that NWAs obtained from SHAs do all the work bottom-up, where NWAs obtained directly from the
regular expression do a considerable amount of work top-down. In terms of [22] this restriction can be
characterized syntactically by the single-entry property:

530

535

540

545

550

Version February 8, 2021 submitted to Algorithms

18 of 32

Figure 19. The single-entry NWA nwa(step(ch∗(a + b))) obtained from the SHA.

Figure 20. Deterministic NWA: nwa(det(step(ch∗(a + b)))).

Deﬁnition 7. A (weak) single-entry NWA A = (Qh, Qt, Σ, Γ, ∆, I, F) is a NWA for which there exists a single
state qentry ∈ Qh such that all opening rules in ∆ have the form q

qentry.

↓q
−−−

(cid:17)

Note that call driven automata (CDAs) discussed in [23] coincide with multi-module single-entry

555

dNWAs and also with (multi-module) single-entry visibly pushdown automata [22,24].

It can be shown that nwa(S) has the (weak) single-entry property for all SHAs S for which the p’s
are unique in the above construction rule, i.e. such that (cid:104)(cid:105)
= {p}. Note that this wasn’t the case for
step(ch∗(a + b)) in Figure 13 but could have been imposed w.l.o.g. leading to a slightly different NWA
than in Figure 19.

∆

The conversion of the determinization det(step(ch∗(a + b))) in Figure 15 yields the deterministic
NWA in Figure 20. The size goes up slightly from 53 to 73. It should be noticed that factorization avoids
a quadratic blow up in this case. This can be observed at state 14, which has 3 incoming tree-edges
and 10 outgoing closing edges. Without factorization, the 3 tree edges could be replaced by 3 ε-edges

560

Version February 8, 2021 submitted to Algorithms

19 of 32

Figure 21. A dSHA for hedges over Σ =
{x, y} with single occurrence of x.
It is
minimal in the class of multi-module dSHAs.

Figure 22. An equivalent dSHA to that
in Figure 21, that is minimal in the class
of dSHAs with equal tree and hedge initial
states.

whose elimination would produce 30 closing edges. This would increase the number 3 + 10 edges to
3 ∗ 10 edges.

565

6.2. NWAs to SHAs

570

Conversely, NWAs can be compiled to stepwise hedge automata, but at the cost of introducing
nondeterminism, since an NWA may traverse the branches of a tree top-down, while a stepwise must
traverse them bottom-up. For this, the stepwise guesses the state in which the NWA will arrive from
above and then evaluates the subtree starting with this state, while verifying the correctness of the guess
later on. Let A = (Qh, Qt, Σ, ∆(cid:48), I, F) be an NWA. We build a SHA step(A) = (Qs
t , Σ, ∆s, Is, Fs)
t = Qh × Qt, Is = {(q, q) | q ∈ I}, Fs = I × F and ∆s is the smallest satisfying
where Qs
the following rules:

h = Qh × Qh, Qs

h, Qs

o ∈ Σ ∪ {_, ε} q1

o−→ q2 ∈ ∆ q ∈ Qh

(q, q1) o−→ (q, q2) ∈ ∆s
q1

↓γ
−−−

↓γ
−−−

q1
(cid:17)
(q2, q2) ∈ (cid:104)(cid:105)

q2 ∈ ∆
∆s

q2 ∈ ∆ q3 ∈ Qt
(q2,q3)
−−−→ (q, q4) ∈ ∆s

(q, q1)

q3

(cid:17)

(cid:17)

↑γ
−−−

q4 ∈ ∆ q ∈ Qh

q1 −→ q2 ∈ ∆ q ∈ Qh
(q, q1) −→ (q, q2) ∈ ∆s

575

The construction is such that L(A) = L(step(A)).
For the NWA nwa(ch∗(a + b)) in Figure 6 we obtain the stepwise in Figure A3 up-to removing
useless states and separating the top level. Determinization yields det(step(nwa(ch∗(a + b)) =
det(step(ch∗(a + b))) in Figure 15.

7. Optimizations

We will use three optimization methods for constructing smaller dSHAs and thus smaller dNWAs:

580

minimization, symbolic representations of sets of transition rules, and schema-based cleaning.

7.1. Minimization

Our next objective is to reduce the size of deterministic SHAs by developing a minimization
algorithm for a subclass of dSHAs. Even though our implementation can deal with them, we consider
SHAs without symbolic rules q

−−→ q(cid:48) for simplicity in this section.

585

We start with an example that motivates the choice of our subclass. In Figures 21 and 22 two
dSHAs are given that both recognize the language of all hedges with signature Σ = {x, y} containing
exactly one occurrence of the letter x. The dSHA in Figure 22 is the dSHA recognizing this language
which has the minimal number of states. The dSHA in Figure 21 is the minimal multi-module dSHA
for this language. The question is how a minimization algorithm for dSHAs could convert the dSHA

Version February 8, 2021 submitted to Algorithms

20 of 32

590

595

600

605

610

in Figure 21 to this minimal one in Figure 22. In particular, why would it fusion the tree initial state
and the hedge initial state? We do not see how this could be done based on some Myhill-Nerode-like
equivalence relation. This motivates an a priori restriction to dSHAs imposing that the tree initial state
and hedge initial state must be equal.

Note that any SHA can be converted into a dSHA with equal tree and hedge initial states. For this
it is sufﬁcient to “fusion” these states and then to determinize the SHA obtained. When doing so for
the dSHA in Figure 21, we indeed obtain the minimal dSHA from Figure 24, so no further minimization
is needed in this case.

Given the close relationship between SHAs and weak single-entry NWAs; it is instrutive to
consider the existing results on minimization for dNWAs. It is known that the class of general dNWAs
does not allow for unique minimization [22] and that the minimization becomes NP-hard when
admitting general signatures with multiple parenthesis [24].

On the positive side, the best existing minimization algorithm is due to Chervet and Walukiewicz
[23]. It applies to the subclass of multi-module single-entry dNWAs, called there call driven automata
(CDA)1. They showed that the subclass of multi-module single-entry dNWAs enjoys unique
minimization in polynomial time.

In the case of dSHAs, we believe that unique minimization holds for the following two subclasses,

and will show it for the second:

• the subclass of multi-module dSHAs, and
• the subclass of dSHAs where the hedge and tree initial state are the same, i.e., (cid:104)(cid:105)

∆

= I.

The ﬁrst subclass of multi-module dSHAs is motivated by the subclass of multi-module single-entry
dNWAs. Note however, that the SHAs that are obtained by compilation from single-entry dNWAs need
not to be deterministic, so the analogy between both automata classes is not perfect. The dSHA in
Figure 21 is minimal for the class of multi-module dSHAs.

The second subclass of dSHAs corresponds to the subclass of single-entry dNWAs in which the
single-entry state is equal to the initial state. The dSHA in Figure 22 is minimal for the second subclass.
In the remainder of this section, we present a minimization algorithm for the second subclass. For this,
we identify dSHAs in which tree and hedge initial state coincide with two-sorted deterministic tree
automata, so that we can use a minimization algorithm for the latter. Our automaton translation is
based on a novel encoding of hedges into ranked well-sorted trees with monadic and binary function
xssymbols, which is inspired by the previous binary encoding of unranked trees known from stepwise
tree automata [21]. For any unranked signature Σ, as for the construction of hedges, we consider two
sort h for hedges and t for trees. We then consider the following ranked signature with these two sorts:

Σ

@ = {a(h) | a ∈ Σ} ∪ {@(h×t→h), ε(h), T(h→t)}

The well-sorted trees over Σ

@ of both sorts then have the following abstract syntax:

well-sorted trees of sort h:
well-sorted trees of sort t:

τ
τ(cid:48)

::= a(τ) | @(τ, τ(cid:48)) | ε
::= T(τ)

Any hedge over Σ can be encoded into a ranked well-sorted tree of sort h with signature Σ
instance, the hedge:

@. For

h = (cid:104)a · (cid:104)b · (cid:104)c · d · e(cid:105)(cid:105) · f (cid:105)

1 Chervet and Walukiewicz [23] permit signatures with multiple opening parenthesis. In the case of a single opening
parenthesis, the class of CDAs is equal to their subclass of expanded CDAs for which they develop their minimization
algorithm in the ﬁrst place.

Version February 8, 2021 submitted to Algorithms

step@_
133 (56)

104 (41)

111 (45)

160 (66)

179 (70)

237 (90)

159 (64)

894 (267)

139 (58)

A1

A2

A3

A4

A5

A6

A7

A8

B3

D(.)=det(step@_(.))
145 (36)

157 (30)

193 (32)

167 (41)

387 (53)

189 (44)

166 (40)

639 (117)

135 (33)

S(.)=schema-clean(D(.)) M(.)=mini(S(.))

106 (36)

101 (30)

123 (32)

123 (41)

274 (53)

144 (44)

125 (40)

527 (117)

102 (33)

106 (36)

55 (16)

95 (24)

123 (41)

274 (53)

144 (44)

115 (36)

487 (101)

96 (32)

21 of 32

nwa(M(.))

268 (37)

87 (17)

167 (25)

334 (42)

650 (54)

410 (45)

279 (37)

elim@_(M(.))
234 (36)

73 (16)

145 (24)

294 (41)

580 (53)

364 (44)

241 (36)

1257 (101)

1413 (102)

200 (32)

228 (33)

Figure 23. Optimized automata for derived stepwise automata compiled from NREs.

is encoded into the following ranked well-sorted tree of sort h over Σ

@:

[[h]] = ε@T( f (a(ε)@τ(cid:48))) where τ(cid:48) = T(b(ε)@τ(cid:48)(cid:48))

and τ(cid:48)(cid:48) = T(e(d(c(ε))))

Any SHA A = (Qh, Qt, Σ, ∆, I, F) with equal tree and hedge initial states, that is (cid:104)(cid:105)
encoded into a two sorted tree automaton [[A]] = (Qh, Qt, Σ
in ∆ to those in ∆(cid:48) as follows:

= I, can then be
@, ∆(cid:48), I, F) by mapping the transition rules

∆

∆
a−→ q(cid:48)
q
q −→ p
p
q(cid:48)
−−−
q
∆
= I
qi ∈ (cid:104)(cid:105)
(cid:17)

∆(cid:48)
a(q) → q(cid:48)
T(q) → p
q@p → q(cid:48)
ε → qi

615

620

625

630

We can ﬁrst note that [[L(A)]] = L([[A]]). Second, the translation function is a bijection between SHAs
over Σ and two-sorted tree automata over Σ
@. Furthermore, this translation preserves determinism.
It follows that if A is a dSHA with a minimal number of states recognizing L(A) then [[A]] is
a deterministic two-sorted tree automaton with a minimal number of states recognizing [[L(A)]].
Furthermore, the unique minimization of deterministic two-sorted tree automata implies the unique
minimization of the class of dSHAs with equal tree and hedge initial states.

Using this translation back and forth, we can thus lift the minimization algorithm of deterministic
two-sorted tree automata to a minimization algorithm for the subclass of dSHAs with equal tree and
hedge initial states. This is the minimization algorithm for dSHAs that we have implemented. We then
used it in our constructions to reduce the size of the dSHAs obtained by determinization.

7.2. Symbolic SHAs with Apply-Else Rules

The sizes of the dSHAs constructed so far are dominated by the number of transitions. We now
propose a class of symbolic dSHAs by adding apply-else rules, in order to represent large numbers of
apply rules in a more compact and symbolic manner.

p
−−−

An apply-else rule has the form q

q(cid:48) where q, q(cid:48) ∈ Qh. It represents the set of apply rules
q(cid:48), where p ∈ Qt can be chosen arbitrarily from a subset of tree states distinguished by the

q
automaton.
(cid:17)
We have also adapted our determinization for dSHAs so that it preserves apply-else rules. What
is missing so far is a concept for NWAs that corresponds to the apply-else rules of dSHAs. Therefore,
we have to eliminate apply-else rules before translating SHAs to NWAs.

(cid:17)

_
−−−

7.3. Schema-Based Cleaning

635

Automata for XPATH queries recognize nested words that can be obtained by encoding XML
documents with a single x-marked position. The class of such nested words is characterized by a

Version February 8, 2021 submitted to Algorithms

22 of 32

Figure 24. A single x-marked
position.

Figure 25. Nested words of x-marked XML documents.

640

645

650

655

schema that we can deﬁne as the intersection of the two dSHAs in Figure 24 and Figure 25. The ﬁrst
SHA tests whether there is exactly one occurrence of the internal letter x, and the second one tests that
the XML data model is satisﬁed, and the node annotations with x and ¬x are put at the right positions.
The automata constructed for the XPATH queries may accept some trees that do not satisfy
the schema (but will never be evaluated on such trees when answering the query). The idea of
schema-based cleaning is to remove all transition rules and states that are not used for recognizing
any nested word satisfying the schema. Schema-based cleaning of an automaton can be performed by
constructing the product of the automaton with the schema, which is in our case an intersection of two
dSHAs. We then only keep those states of the original SHA that are used in accessible and co-accessible
states of the product with the schema.

It should be noticed that schema-based cleaning typically changes the language of the automaton.
Different languages may be obtained when cleaning different automata for the same query with respect
to the schema. If one is interested in a unique language, then one can choose the intersection of the
automaton with the schema. This intersection, however, is usually larger than the automaton obtained
by schema-based cleaning.

7.4. Experimental Results for Optimizations

The sizes of optimized automata for the benchmark queries are reported in Figure 23. The function
step@_ used in the ﬁrst column compiles NREs to SHAs with apply-else rules. This does not change
the number of states, but reduces the number of automata transitions. In the case of A8 the size of the
stepwise automaton is reduced from 1106 to 894.

An optimized determinizer is applied by the function D(.) = det(step@_(.)) in the second column.
It preserves apply-else rules in particular. For A8, the size is reduced from 749 to 639 while the number
of states is preserved.

660

Schema-based cleaning is applied by the function S(.) = schema − clean(D(.)) in the third column.

For A8 the number of rules is reduced further from 639 to 527.

Minimization is applied by the function M(.) = mini(S(.)) in the fourth column. In the case of

A8 it reduces the number of states from 117 to 101 and the size from 527 to 487.

In order to come back to dNWAs, we have to eliminate the apply-else rules in column six. For A8

665

this increases the number of rules back from 527 to 1257.

In the ﬁnal column, we apply the compiler from SHAs to NWAs which preserves determinism.
For A8 this results in a dNWA of size 1413 and 102 states. This is better than the previous results, in
particular with respect to the number of states.

Version February 8, 2021 submitted to Algorithms

23 of 32

det(nwa(.))

—

362600 (6782)

318704 (8216)

—

—

—

—

—

—

A1

A2

A3

A4

A5

A6

A7

A8

B3

nwa(det(

step(.)))

268 (37)

87 (17)

167 (25)

334 (42)

650 (54)

410 (45)

279 (37)

det(nwa(

step(.)))

363 (37)

3781 (142)

837 (61)

447 (42)

1110 (72)

507 (45)

431 (41)

1413 (102)

2406 (124)

228 (33)

392 (38)

nwa(det(
step(nwa(.))))

det(nwa(
step(nwa(.))))

204 (37)

67 (17)

113 (25)

298 (42)

194 (34)

349 (45)

162 (30)

—

189 (33)

363 (37)

540 (51)

417 (43)

447 (42)

612 (54)

507 (45)

431(41)

—

392 (38)

Figure 26. Deterministic NWAs computed with optimizations for the XPath benchmark queries. Note
that different dNWAs for the same query may recognize different languages, due to schema-based
cleaning with respect to the XML data model. Furthermore, our implementation of the minimization
algorithm for the subclass of dSHAs worked successfully only for dSHAs with at most 200 states.

8. Summary of Experimental Results

670

We now plug the different compilers and optimization methods all together and compare the

675

680

685

690

695

sizes of deterministic NWAs that we can obtain thereby.

The overall sizes (#states) of the resulting dNWAs are given in Figure 26. We see that the
two methods starting with SHAs nwa(det(step(.))) and det(nwa(step(.))) yield reasonably small
deterministic NWAs for the NREs of all benchmark queries. The methods starting with NWAs
nwa(det(step(nwa(.)))) and det(nwa(step(nwa(.)))) provide reasonably small deterministic NWAs
for queries except for A8.

We also tested our algorithms on collections of XPath queries with a scalable parameter, such as
the queries chn(a) for increasing n. This series is known to require automaton with a number of states
exponential in n for deterministic bottom-up evaluation. The best methods to produce deterministic
NWAs in this case is nwa(det(step)). It works until n = 9, leading to an dNWA of size 134929 with 772
states. The number of states close to doubles when increasing n by 1. The second best method for
producing dNWAs for the series chn(a) works only until n = 6.

For explaining the different size of the dNWAs for the series chn(a), we ﬁrst note that no
schema-based cleaning was applied in this experiment. As a consequence unique minimal single-entry
dNWAs in which the single-entry state is the initial state should exist. The reason for the larger number
of states with the three other methods is that we have not implemented any minimization algorithm for
this subclass of single-entry dNWAs. Furthermore, our implementation of the minimization algorithm
for our subclass of dSHAs failed for too big dSHAs. In this case, the number of states reported in
Figure 27 could not be reduced to the minimum. In addition, the number of rules seems to be increased
further by the lack of any symbolic representation for rules of NWAs that could mimic the apply-else
rules for SHAs.

9. Deterministic Nested Regular Expressions

We ﬁnally show how to distinguish NREs that can be evaluated deterministically in polynomial
time, for instance by compilation to deterministic NWAs. For this, we consider the language of NREs
nregexp(ch, T) that extends the abstract syntax of NREs by a new constant T and a new unary operator
ch.

Deﬁnition 8. An expression of nregexp(ch, T) is deterministic if it does not contain a subexpression of any of
the forms: E1 + E2, E∗, T · E, µa.E.

Version February 8, 2021 submitted to Algorithms

24 of 32

det(nwa(.))

nwa(det(

step(.)))

det(nwa(

step(.)))

nwa(det(
step(nwa(.)))

det(nwa(
step(nwa(.))))

4 (2)

165 (33)

1530 (199)

19828 (1281)

ch0(a)
ch1(a)
ch2(a)
ch3(a)
ch4(a)
ch5(a)
ch6(a)
ch7(a)
ch8(a)
ch9(a)

4 (2)

34 (7)

55 (10)

109 (16)

265 (28)

769 (52)

2545 (100)

9169 (196)

34705 (388)

134929 (772)

4 (2)

55 (10)

112 (16)

352 (32)

2200 (88)

22792 (296)

4 (2)

34 (7)

55 (10)

109 (16)

265 (28)

769 (52)

303592 (1096)

80369 (2148)

4 (2)

55 (10)

112 (16)

352 (32)

2200 (88)

22792 (296)

Figure 27. Deterministic NWAs for the queries chn(a) where n = 0, . . . , 9: size (#states). There is no
schema-based cleaning. Our implementation of the minimization algorithm was applied to all dSHA
with at most 200 states, since it failed for larger dSHAs. No minimization algorithm for subclasses of
single-entry dNWAs was implemented.

700

705

710

715

720

Note in particular that ch(a) is a deterministic expression of nregexp(ch, T), since the child operator
is added as a primitive there. In contrast, the semantically equivalent expression T.(cid:104)a(cid:105).T is not
deterministic. Similarly, T is deterministic since it is a primitive expression of nregexp(ch, T), while
the equivalent expression µx.((cid:104)x(cid:105) + _)∗ is nondeterministic for 3 different reasons: the µ-operator, the
star ∗ and the disjunction +. The recursive expression ch∗(E) is nondeterministic: it is not primitive in
nregexp(ch, T), and its deﬁnition is based on the µ-operator and disjunction.

The only query of the benchmark for which we can provide a deterministic NRE is the query
A1. The NRE for query A1 in Figure A1 is nondeterministic nevertheless, since we replaced ch(E)
with T · (cid:104)E(cid:105) · T. This is not problematic, given that we can use a decent method for determinization
of NWAs. For this reason, it does no more seem worth the effort to maintain specialized compilation
methods for deterministic NREs. For the same reason, we will not present any experimental results for
our specialized compiler from deterministic NREs to deterministic NWAs. Instead we use the more
general compiler for general nondeterministic NREs.

The compiler from Theorem 1 introduces epsilon rules and thus, it does not preserve determinism:
some deterministic NREs will be compiled to nondeterministic NWAs. This introduction of
nondeterminism can be avoided by eliminating epsilon rules on the ﬂy, that is by using Glushkov’s
approach rather than that of Thompson.

Theorem 3. For any deterministic regular expression E of nregexp(ch, T) without conjunction and negation,
we can construct in time O(|E|2) a dNWA recognizing the same language.

Proof sketch. Theorem 3 uses Glushkov’s construction and thus eliminates ε-edges on the ﬂy
compared to the McNaughton-Yamada-Thompson algorithm. The Glushkov construction is
well-known to preserve determinism when compiling regular expressions without nesting to ﬁnite
state automata [20]. For the additional deterministic expressions ch(E), we adapt the deterministic
compilation from [18]. This quadratic time result generalizes a previous result for the Glushkov
construction [19] from regular expressions without conjunctions and negations to NREs without
conjunctions and negations.

725

Small deterministic NREs without conjunction and negation can thus be compiled to small dNWAs.
On the benchmark, however, this construction can be applied to the query A1 only, so only a few
queries can be covered in this manner.

Version February 8, 2021 submitted to Algorithms

25 of 32

10. Conclusion and Future Work

730

735

740

745

We presented SHAs and showed how they can be used to compile NREs to deterministic NWAs.
When applied to NREs for navigational XPATH queries in the usual XPathMark benchmark, we
obtained reasonably small deterministic NWAs, in contrast to all previous approaches.

The dNWAs that we obtain by compilation from SHAs all have the weak single-entry property.
This property means that the computation of the NWA is done in a purely bottom-up and left-to-right
manner, so in the same way as by an SHA. Our experiments show that the usual determinization
algorithm for NWAs is well-behaved when applied to weak single-entry NWAs, while it quickly fails
without the weak single-entry property.

We have also stated a unique minimization algorithm for dSHAs with the same tree and hedge
initial state. It is open whether unique minimization holds for general dSHAs. Neither do we know
whether dSHA minimization is NP-hard. The analogous questions remain open for the class of weak
single-entry dNWAs.

In future work, one needs to tackle the open questions on the minimization of dSHAs, weak
single-entry dNWAs, and dNWAs with ﬁxed general signatures. One has to understand, whether
and why unique minimization holds or not, and whether and why minimization is hard or not.
Independently, it is interesting to use SHAs in various questions in theory and practice. In particular,
we want to develop new algorithms for earliest query answering for dSHAs that are more efﬁcient
than the existing algorithms for dNWAs [16] and to see how they behave in practice.

Acknowledgments: It is a pleasure to thank Iovka Boneva for her contributions to the conference version [25]
onto which this journal article extends. We are equally grateful to Antonio Al Serhali for implementing the
determinization algorithm for SHAs with apply-else rules.

750

References

1.

755

2.

760

765

770

3.

4.

5.

6.

7.

8.

9.

10.

Mehlhorn, K. Pebbling Moutain Ranges and its Application of DCFL-Recognition. Automata, Languages
and Programming, 7th Colloquium, Noordweijkerhout, The Netherlands, July 14-18, 1980, Proceedings;
de Bakker, J.W.; van Leeuwen, J., Eds. Springer, 1980, Vol. 85, Lecture Notes in Computer Science, pp. 422–435.
doi:10.1007/3-540-10003-2\_89.
von Braunmühl, B.; Verbeek, R. Input Driven Languages are Recognized in log n Space. In Topics in the
Theory of Computation; Karplnski, M.; van Leeuwen, J., Eds.; North-Holland, 1985; Vol. 102, North-Holland
Mathematics Studies, pp. 1 – 19. doi:https://doi.org/10.1016/S0304-0208(08)73072-X.
Alur, R. Marrying Words and Trees. 26th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of
Database Systems. ACM-Press, 2007, pp. 233–242.
Okhotin, A.; Salomaa, K. Complexity of input-driven pushdown automata. SIGACT News 2014, 45, 47–67.
doi:10.1145/2636805.2636821.
Alur, R.; Madhusudan, P. Visibly pushdown languages. 36th ACM Symposium on Theory of Computing.
ACM-Press, 2004, pp. 202–211.
Neumann, A.; Seidl, H. Locating Matches of Tree Patterns in Forests. Foundations of Software Technology
and Theoretical Computer Science. Springer Verlag, 1998, Vol. 1530, Lecture Notes in Computer Science, pp.
134–145.
Gauwin, O.; Niehren, J.; Roos, Y. Streaming Tree Automata. Information Processing Letters 2008, 109, 13–17.
doi:10.1016/j.ipl.2008.08.002.
Thatcher, J.W. Characterizing derivation trees of context-free grammars through a generalization of
automata theory. Journal of Computer and System Science 1967, 1, 317–322.
Comon, H.; Dauchet, M.; Gilleron, R.; Löding, C.; Jacquemard, F.; Lugiez, D.; Tison, S.; Tommasi, M. Tree
Automata Techniques and Applications. Available online since 1997: http://tata.gforge.inria.fr, 2007.
Hosoya, H.; Pierce, B.C. XDuce: A statically typed XML processing language. ACM Trans. Internet Techn.
2003, 3, 117–148. doi:10.1145/767193.767195.

775

11. Mozafari, B.; Zeng, K.; Zaniolo, C.

Languages and Query Execution for Relational and XML Sequences.
doi:10.14778/1920841.1920865.

From Regular Expressions to Nested Words: Unifying
PVLDB 2010, 3, 150–161.

Version February 8, 2021 submitted to Algorithms

26 of 32

12.
13.

14.

780

785

15.

16.

790

17.

18.

19.

20.

21.

22.

23.

24.

25.

26.

27.

28.

795

800

805

810

815

820

825

830

Springer, 2011, Vol.

6807, Lecture Notes in Computer Science, pp.

Pitcher, C. Visibly Pushdown Expression Effects for XML Stream Processing. PlanX, 2005.
Olteanu, D. SPEX: Streamed and Progressive Evaluation of XPath. IEEE Trans. on Know. Data Eng. 2007,
19, 934–949. doi:10.1109/TKDE.2007.1063.
International Conference
Streamable Fragments of Forward XPath.
Gauwin, O.; Niehren, J.
on Implementation and Application of Automata; Markhoff, B.B.; Caron, P.; Champarnaud, J.M.;
Maurel, D., Eds.
3–15.
doi:10.1007/978-3-642-22256-6\_2.
Benedikt, M.; Jeffrey, A.; Ley-Wild, R. Stream Firewalling of XML Constraints. ACM SIGMOD International
Conference on Management of Data. ACM-Press, 2008, pp. 487–498.
Gauwin, O.; Niehren, J.; Tison, S. Earliest Query Answering for Deterministic Nested Word Automata.
17th International Symposium on Fundamentals of Computer Theory. Springer Verlag, 2009, Vol. 5699,
Lecture Notes in Computer Science, pp. 121–132.
Franceschet, M. XPathMark Performance Test. https://users.dimi.uniud.it/~massimo.franceschet/
xpathmark/PTbench.html. Accessed: 2020-10-25.
Debarbieux, D.; Gauwin, O.; Niehren, J.; Sebastian, T.; Zergaoui, M. Early nested word automata for XPath
query answering on XML streams. Theor. Comput. Sci. 2015, 578, 100–125. doi:10.1016/j.tcs.2015.01.017.
Brüggemann-Klein, A. Regular Expressions into Finite Automata. Theoretical Computer Science 1993,
120, 197–213. doi:10.1016/0304-3975(93)90287-4.
Brüggemann-Klein, A.; Wood, D. One-Unambiguous Regular Languages. Information and Computation
1998, 142, 182–206.
Carme, J.; Niehren, J.; Tommasi, M. Querying Unranked Trees with Stepwise Tree Automata. 19th
International Conference on Rewriting Techniques and Applications. Springer Verlag, 2004, Vol. 3091,
Lecture Notes in Computer Science, pp. 105–118.
Alur, R.; Kumar, V.; Madhusudan, P.; Viswanathan, M. Congruences for Visibly Pushdown Languages.
Automata, Languages and Programming, 32nd International Colloquium. Springer Verlag, 2005, Vol. 3580,
Lecture Notes in Computer Science, pp. 1102–1114. doi:10.1007/11523468\_89.
Chervet, P.; Walukiewicz, I. Minimizing Variants of Visibly Pushdown Automata. Mathematical
Foundations of Computer Science 2007; Kuˇcera, L.; Kuˇcera, A., Eds.; Springer Berlin Heidelberg: Berlin,
Heidelberg, 2007; pp. 135–146.
Gauwin, O.; Muscholl, A.; Raskin, M. Minimization of visibly pushdown automata is NP-complete. Log.
Methods Comput. Sci. 2020, 16. doi:10.23638/LMCS-16(1:14)2020.
Boneva, I.; Niehren, J.; Sakho, M. Nested Regular Expressions Can Be Compiled to Small Deterministic
Nested Word Automata. Computer Science - Theory and Applications - 15th International Computer
Science Symposium in Russia, CSR 2020, Yekaterinburg, Russia, June 29 - July 3, 2020, Proceedings;
169–183.
Fernau, H., Ed.
doi:10.1007/978-3-030-50026-9\_12.
Gottlob, G.; Koch, C.; Pichler, R.
SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, 2003, pp. 179–190.
Libkin, L.; Martens, W.; Vrgoˇc, D. Querying Graph Databases with XPath. Proceedings of the 16th
International Conference on Database Theory; Association for Computing Machinery: New York, NY, USA,
2013; ICDT ’13, p. 129–140. doi:10.1145/2448496.2448513.
Fischer, M.J.; Ladner, R.E. Propositional Dynamic Logic of Regular Programs. J. Comput. Syst. Sci. 1979,
18, 194–211. doi:10.1016/0022-0000(79)90046-1.

12159, Lecture Notes in Computer Science, pp.

The complexity of XPath query evaluation.

Springer, 2020, Vol.

22nd ACM

30.

29. Mozafari, B.; Zeng, K.; Zaniolo, C. High-performance complex event processing over XML streams.
SIGMOD Conference; Candan, K.S.; Chen, Y.; Snodgrass, R.T.; Gravano, L.; Fuxman, A.; Candan, K.S.; Chen,
Y.; Snodgrass, R.T.; Gravano, L.; Fuxman, A., Eds. ACM, 2012, pp. 253–264. doi:10.1145/2213836.2213866.
Grez, A.; Riveros, C.; Ugarte, M. A Formal Framework for Complex Event Processing. 22nd International
Conference on Database Theory, ICDT 2019, March 26-28, 2019, Lisbon, Portugal; Barceló, P.; Calautti,
M., Eds. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2019, Vol. 127, LIPIcs, pp. 5:1–5:18.
doi:10.4230/LIPIcs.ICDT.2019.5.
Bozzelli, L.; Sánchez, C.
doi:10.1007/s00236-013-0190-6.
Gécseg, F.; Steinby, M. Tree Automata; Akadémiai Kiadó: Budapest, 1984.

Visibly Rational Expressions.

2014, 51, 25–49.

Acta Inf.

31.

32.

Version February 8, 2021 submitted to Algorithms

27 of 32

33.
34.

35.

36.

37.

835

840

J.; Gilleron, R.; Lemay, A.; Niehren,

Scott, D.; de Bakker, J.W. A theory of programs. Unpublished manuscript, IBM, Vienna 1969.
Stockmeyer, L.J.; Meyer, A.R. Word Problems Requiring Exponential Time. Proc. 5th ACM Symp. on
Theory of Computing, 1973, pp. 1–9.
Champavère,
Deterministic Tree Automata and XML Schemas.
doi:10.1016/j.ic.2009.03.003.
Aho, A.V.; Lam, M.S.; Sethi, R.; Ullman, J.D. Compilers: Principles, Techniques, and Tools (2nd Edition);
Addison Wesley, 2006.
Arnold, A.; Niwi ´nski, D. Complete lattices and ﬁxed-point theorems.
North-Holland, 2001; Vol. 146, Studies in Logic and the Foundations of Mathematics, chapter 1, pp. 1–39.

Inclusion Checking for
Information and Computation 2009, 207, 1181–1208.

In Rudiments of µ-calculus;

Efﬁcient

J.

38. Martens, W.; Niehren, J. On the Minimization of XML-Schemas and Tree Automata for Unranked
Special issue of DBPL 05,

Journal of Computer and System Science 2007, 73, 550–583.

Trees.
doi:10.1016/j.jcss.2006.10.021.
D’Antoni, L.; Alur, R. Symbolic Visibly Pushdown Automata. Computer Aided Veriﬁcation - 26th
International Conference, CAV 2014, Held as Part of the Vienna Summer of Logic, VSL 2014, Vienna,
Austria, July 18-22, 2014. Proceedings; Biere, A.; Bloem, R., Eds. Springer, 2014, Vol. 8559, Lecture Notes in
Computer Science, pp. 209–225. doi:10.1007/978-3-319-08867-9\_14.

39.

845

Version February 8, 2021 submitted to Algorithms

28 of 32

Appendix A Determinization of NWAs

Let us ﬁrst introduce some notations. For a transition τ ∈ Qh × Qh, we write lab(τ) = {a ∈ Σ |
to denote the reﬂexive and transitive
. Finally, for any set Q, we write idQ to denote the binary relation that relates every

a−→ q(cid:48)(cid:48) ∈ ∆}. Furthermore we write ε

∃(q, q(cid:48)) ∈ τ, q(cid:48)(cid:48) ∈ Q.q(cid:48)
∆
closure of ε
element of Q to itself, that is idQ = {(q, q) ∈ Q2}.

∆∗

We adapt the usual determinization procedure for NWAs [3,18] so that they can account for
hedge ending and else rules. Given an NWA A = (Qh, Qt, Σ, Γ, ∆, I, F), the difﬁculty is to deal with
↓γ1−−−
q2 in ∆ during determinization without mixing up
concurrent opening rules q
the stack symbols γ1 and γ2. Therefore, we use transition relations as states of the determinized
(cid:17)
t = 2Qh×Qt . The
, Σ, Γdet, ∆det, Idet, Fdet), that is Qdet
h , Qdet
automaton det(A) = (Qdet
t
∆∗ }. The set of ﬁnal states is
∆∗
only initial state is the composition of idI with ε
| τ ∩ (I × F) (cid:54)= ∅}. Schemas generating the transition rules in ∆det are given below.
Fdet = {τ ∈ Qdet
h

h = 2Qh×Qh , Qdet

, i.e., Idet = {idI ◦ ε

↓γ2−−−
(cid:17)

q1 and q

850

855

τ ∈ Qdet
h
∆∗ ∈ ∆det
∆ ◦ ε

_−→ τ ◦ _

τ

τ ∈ Qdet
h
∆ ◦ ε

tree−−→ τ ◦ tree

τ

∆∗ ∈ ∆det

τ ∈ Qdet
h

Q(cid:48) = {q(cid:48) | ∃(_, q) ∈ τ. q

↓γ
−−−

q(cid:48) ∈ ∆}

↓τ
−−−

τ

idQ(cid:48) ◦ ε

∆∗ ∈ ∆det

(cid:17)

τ ∈ Qdet

t

(cid:17)
τ(cid:48) ∈ Qdet
h

τ(cid:48)(cid:48) = (cid:83)
γ∈Γ

(cid:104)

∆
γ ◦ ε

∆∗ ◦ τ ◦ (cid:105)

∆
γ

↑τ(cid:48)
−−−

τ

τ(cid:48) ◦ τ(cid:48)(cid:48) ◦ ε

∆∗ ∈ ∆det

τ ∈ Qdet
h

(cid:17)
∆ |(cid:54) ∃q(cid:48)(cid:48).q
a ∈ lab(τ) τ(cid:48) = {(q, q(cid:48)) ∈ _

a−→ q(cid:48)(cid:48) wrt∆}

a−→ τ ◦ (a

∆ ∪ τ(cid:48)) ◦ ε

∆∗ ∈ ∆det

τ

Version February 8, 2021 submitted to Algorithms

29 of 32

860

Appendix B NREs for the XPathMark Benchmark

We compiled navigational XPath queries of the XPathMark benchmark to the NREs given in

Figure A1.

A1 (cid:104)doc · _ · (cid:104)elem · site · _ · T · (cid:104)elem · closed_auctions · _ · T·
(cid:104)elem · closed_auction · _ · T · (cid:104)elem · annotation · _ · T·
(cid:104)elem · description · _ · T · (cid:104)elem · text · _ · T·
(cid:104)elem · keyword · x · T(cid:105) · T(cid:105) · T(cid:105) · T(cid:105) · T(cid:105) · T(cid:105) · T(cid:105) · T(cid:105)

A2 (cid:104)doc · _ · (µd1.((cid:104)elem · closed_auction · _ · T · (µd2.(

(cid:104)elem · keyword · x · T(cid:105) · T + (cid:104)T · d1 · T(cid:105) · T))(cid:105) · T + (cid:104)T · d1 · T(cid:105) · T))(cid:105)

A3 (cid:104)doc · _ · (cid:104)elem · site · _ · T · (cid:104)elem · closed_auctions · _ · T · (cid:104)elem · closed_auction · _ · T · (

µd.((cid:104)elem · keyword · x · T(cid:105) · T + (cid:104)T · d · T(cid:105) · T))(cid:105) · T(cid:105) · T(cid:105) · T(cid:105)

A4 (cid:104)doc · _ · (cid:104)elem · site · _ · T·

(cid:104)elem · closed_auctions · _ · T · (cid:104)elem · closed_auction · _·

(T · (cid:104)elem · annotation · _ · T · (cid:104)elem · description · _ · T·

(cid:104)elem · text · _ · T · (cid:104)elem · keyword · _ · T(cid:105) · T(cid:105) · T(cid:105) · T(cid:105) · T(cid:105) · T)

& (T · (cid:104)elem · date · x · T(cid:105) · T(cid:105) · T)(cid:105) · T(cid:105) · T(cid:105)

A5 (cid:104)doc · _ · (cid:104)elem · site · _ · T · (cid:104)elem · closed_auctions · _ · T · (

(cid:104)elem · closed_auction · _ · T · (

µd.((cid:104)elem · keyword · _ · T(cid:105) · T + (cid:104)T · d · T(cid:105) · T))(cid:105) · T)

&((cid:104)elem · closed_auction · _ · T · (cid:104)elem · date · x · T(cid:105) · T(cid:105) · T)(cid:105) · T(cid:105) · T(cid:105)
A6 (cid:104)doc · _ · (cid:104)elem · site · _ · T · (cid:104)elem · people · _ · T · (((cid:104)elem · person · _ · T·

(cid:104)elem · pro f ile · _ · T · (cid:104)elem · gender · _ · T(cid:105) · T(cid:105) · T(cid:105) · T)
&((cid:104)elem · person · _ · T · (cid:104)elem · pro f ile · _ · T · (cid:104)elem · age · _ · T(cid:105) · T(cid:105) · T(cid:105) · T))
&((cid:104)elem · person · _ · T · (cid:104)elem · name · x · T(cid:105) · T(cid:105) · T)(cid:105) · T(cid:105) · T(cid:105)
A7 (cid:104)doc · _ · (cid:104)elem · site · _ · T · (cid:104)elem · people · _ · T · (((cid:104)elem · person · _ · T·

(cid:104)elem · phone · _ · T(cid:105) · T(cid:105) · T+
(cid:104)elem · person · _ · T · (cid:104)elem · homepage · _ · T(cid:105) · T(cid:105) · T))
&((cid:104)elem · person · _ · T · (cid:104)elem · name · x · T(cid:105) · T(cid:105) · T)(cid:105) · T(cid:105) · T(cid:105)

A8 (cid:104)doc · _ · (cid:104)elem · site · _ · T · (cid:104)elem · people · _ · T·

((((cid:104)elem · person · _ · T · (cid:104)elem · address · _ · T(cid:105) · T(cid:105) · T)
& ((cid:104)elem · person · _ · T · (cid:104)elem · phone · _ · T(cid:105) · T(cid:105) · T +

(cid:104)elem · person · _ · T · (cid:104)elem · homepage · _ · T(cid:105) · T(cid:105) · T))
& (((cid:104)elem · person · _ · T · (cid:104)elem · creditcard · _ · T(cid:105) · T(cid:105) · T +
(cid:104)elem · person · _ · T · (cid:104)elem · pro f ile · _ · T(cid:105) · T(cid:105) · T)))

& ((cid:104)elem · person · _ · T · (cid:104)elem · name · x · T(cid:105) · T(cid:105) · T)(cid:105) · T(cid:105) · T(cid:105)

Figure A1. The NREs of the XPath benchmark queries.

Version February 8, 2021 submitted to Algorithms

30 of 32

Appendix C Some More Automata

Figure A2. Deterministic NWA: det(nwa(ch∗(a + b)).

Publisher’s Note: MDPI stays neutral with regard to jurisdictional claims in published maps and institutional
afﬁliations.

865

Version February 8, 2021 submitted to Algorithms

31 of 32

Figure A3. Stepwise hedge automaton from NWA for step(nwa(ch∗(a + b))).

c(cid:13) 2021 by the authors.

Submitted to Algorithms

the Creative Commons Attribution (CC BY)

for possible open access publication
license

the

under
(http://creativecommons.org/licenses/by/4.0/).

and conditions

terms

of

Version February 8, 2021 submitted to Algorithms

32 of 32

Figure A4. Determinization of NWA from stepwise hedge automaton: det(nwa(step(ch∗(a + b)))).

