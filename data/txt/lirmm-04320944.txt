Bounded Treewidth and the Infinite Core Chase:
Complications and Workarounds toward Decidable
Querying
Jean-François Baget, Marie-Laure Mugnier, Sebastian Rudolph

To cite this version:

Jean-François Baget, Marie-Laure Mugnier, Sebastian Rudolph. Bounded Treewidth and the Infinite
Core Chase: Complications and Workarounds toward Decidable Querying. SIGMOD/PODS 2023 -
International Conference on Management of Data, Jul 2023, Seattle, WA, United States. pp.291-302,
￿10.1145/3584372.3588659￿. ￿lirmm-04320944￿

HAL Id: lirmm-04320944

https://hal-lirmm.ccsd.cnrs.fr/lirmm-04320944

Submitted on 4 Dec 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Bounded Treewidth and the Infinite Core Chase
Complications and Workarounds toward Decidable Querying

Jean-François Baget
Marie-Laure Mugnier
jfbaget@inria.fr
mugnier@lirmm.fr
LIRMM, Inria, University of Montpellier, CNRS
Montpellier, France

ABSTRACT
The core chase, a popular algorithm for answering conjunctive
queries (CQs) over existential rules, is guaranteed to terminate and
compute a finite universal model whenever one exists, leading to
the equivalence of the universal-model-based and the chase-based
definitions of finite expansion sets (fes) – a class of rulesets featuring
decidable CQ entailment. In case of non-termination, however, it is
non-trivial to define a “result” of the core chase, due to its non-mo-
notonicity. This causes complications when dealing with advanced
decidability criteria based on the existence of (universal) models of
finite treewidth. For these, sufficient chase-based conditions have
only been established for weaker, monotonic chase variants.

This paper investigates the – prima facie plausible – hypothesis
that the existence of a treewidth-bounded universal model and the
existence of a treewidth-bounded core-chase sequence coincide –
which would conveniently entail decidable CQ entailment when-
ever the latter holds. Perhaps surprisingly, carefully crafted exam-
ples show that both directions of this hypothesized correspondence
fail. On a positive note, we are still able to define an aggregation
scheme for the infinite core chase that preserves treewidth bounds
and produces a finitely universal model, i.e., one that satisfies ex-
actly the entailed CQs. This allows us to prove that the existence of
a treewidth-bounded core-chase sequence does warrant decidability
of CQ entailment (yet, on other grounds than expected). Hence, for
the first time, we are able to define a chase-based notion of bounded
treewidth sets of rules that subsumes fes.

CCS CONCEPTS
• Theory of computation → Automated reasoning; • Comput-
ing methodologies → Knowledge representation and reason-
ing.

KEYWORDS
existential rules, tuple-generating dependencies, chase, treewidth,
universal models

Publication rights licensed to ACM. ACM acknowledges that this contribution was
authored or co-authored by an employee, contractor or affiliate of a national govern-
ment. As such, the Government retains a nonexclusive, royalty-free right to publish or
reproduce this article, or to allow others to do so, for Government purposes only.
PODS ’23, June 18–23, 2023, Seattle, WA, USA
© 2023 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0127-6/23/06. . . $15.00
https://doi.org/10.1145/3584372.3588659

Sebastian Rudolph
sebastian.rudolph@tu-dresden.de
Computational Logic Group, TU Dresden
Dresden, Germany

ACM Reference Format:
Jean-François Baget, Marie-Laure Mugnier, and Sebastian Rudolph. 2023.
Bounded Treewidth and the Infinite Core Chase: Complications and Work-
arounds toward Decidable Querying. In Proceedings of the 42nd ACM SIGMOD-
SIGACT-SIGAI Symposium on Principles of Database Systems (PODS ’23),
June 18–23, 2023, Seattle, WA, USA. ACM, New York, NY, USA, 12 pages.
https://doi.org/10.1145/3584372.3588659

1 INTRODUCTION
The chase is a fundamental tool for the popular formalism of exis-
tential rules, also known as tuple-generating dependencies. Given a
knowledge base (KB) composed of a finite set 𝐹 of facts (the data-
base) and a set Σ of (existential) rules, the chase repeatedly applies
rules, giving rise to a sequence 𝐹 =𝐹0, 𝐹1, 𝐹2, . . . If, in the course of
this, a fixpoint is reached after a finite number of steps, one speaks
of chase termination. Then, the final fact set obtained, seen as a
structure, constitutes a finite model of the given KB, which is also
universal, meaning that it can be homomorphically mapped to any
model of the KB. This pleasant property allows one to consider this
single model (instead of all models) to answer all queries preserved
under homomorphisms, ranging from conjunctive queries (CQs) to
datalog and other second-order queries.

In fact, there are different chase variants with differing behavior
regarding redundancy treatment and termination. The simplest,
most lavish, known as the oblivious chase, performs all possible
rule applications, without checking for any redundancies [6]. The
most frugal, known as the core chase, prunes all redundancies at
each step, retaining a minimal set of atoms, which is called a core [9].
Between these two extremes, the semi-oblivious (aka skolem) and
restricted (aka standard) chase avoid the creation of some redundan-
cies, but not all [10, 17]. The core chase is the only chase variant
that terminates exactly when the KB has a finite universal model,
and produces the unique (up to isomorphism) smallest such model.
Thus, the core chase is the best choice for a decision procedure that
aims at chase termination. This motivates the definition of the fes
(finite expansion sets) class containing all rule sets Σ for which the
core chase for K = (𝐹, Σ) terminates for all 𝐹 [3]. For such Σ, the
entailment K |= 𝑄 for any CQ 𝑄 can be decided by computing the
core chase and evaluating 𝑄 against the resulting structure.

Yet, finite universal models may not exist. In such cases, no chase
reaches a fixpoint, and there is no last chase sequence element to
pick as a result. As a remedy, one may define the “result” of the chase
as the infinite union over all the fact sets of the infinite sequence,
obtaining an infinite structure. This will still yield a universal model
for monotonic chase variants, where 𝐹𝑖 ⊆ 𝐹𝑖+1 holds for all 𝑖, such

PODS ’23, June 18–23, 2023, Seattle, WA, USA

Jean-François Baget, Marie-Laure Mugnier, and Sebastian Rudolph

Figure 1: Venn diagram displaying the (non-)inclusion of decidable classes of existential rule sets discussed in the paper. We
abbreviate treewidth by tw, and restricted and core chase by rc and cc, respectively. The rulesets entitled "steepening staircase"
and "inflating elevator" demonstrate that existence of treewidth-finite universal models and treewidth-bounded core-chase
sequences are independent properties. The tw-bounded cc class actually comes in two flavors, referred to as uniform and
recurring boundedness. The latter is more general, but the distinction is irrelevant for this overview.

as the oblivious, semi-oblivious and restricted chases. However, this
does not work well for non-monotonic chase variants such as the
core chase, where one cannot even be certain to obtain a model.

One could argue that these issues are of theoretical interest only,
given that the non-terminating chase cannot actually be computed
and cannot serve as a decision procedure. However, fortunately,
decidability of CQ entailment can be established by other means,
even when the chase does not terminate. In particular, it is ensured
whenever an infinite universal model exists that is still reasonably
“structurally well-behaved” by virtue of having a bounded treewidth
[1, 7]. This insight gave rise to many existential rule fragments of
high practical relevance, mostly based on varying notions of guard-
edness, which impose syntactic restrictions ensuring treewidth-
boundedness for all chase sequences [1, 2, 7, 16]. Yet, these classes
all have in common that the existence of a treewidth-bounded uni-
versal model can be established only via chase variants that are
necessarily monotonic: the union over all 𝐹𝑖 in a monotonic chase
sequence is known to inherit the treewidth bound. Regrettably, for
the core chase, which produces “smaller” intermediate structures
and hence ensures treewidth-boundedness of the produced facts
more often, no adequate model-producing “aggregation” strategy
is known, let alone a treewidth-preserving one.

To overcome this issue, we provide a decidability guarantee, but
also bring some unpleasant truths to light. We propose a treewidth-
preserving aggregation scheme for the core chase that produces
a model, but not a universal one. Luckily, we can still guarantee
that the resulting model is finitely universal (that is, any of its finite
substructures is universal) and thus sufficient for our purpose of
decidable CQ entailment. Also, we show that the failure to construct
a treewidth-bounded universal model out of a treewidth-bounded
chase sequence is not a flaw of our approach, but unavoidable, by
exhibiting the steepening staircase example: a uniformly treewidth-
bounded core-chase sequence for a KB whose every universal model
has infinite treewidth. Conversely, the inflating elevator example
presents a KB with a universal model of finite treewidth, yet each
of its core-chase sequences consists of structures of ever-growing
treewidth, refuting the plausible hypothesis that any universal
model of bounded treewidth can be obtained from a treewidth-
bounded core-chase sequence. Figure 1 summarizes our findings.

2 PRELIMINARIES
We use countably infinite disjoint sets Δ𝑉 of variables (denoted by
uppercase letters) and Δ𝐶 of constants (denoted by lowercase letters).
A schema S is a finite set of relation symbols (or predicates); each
p ∈ S is given an arity ar (p) ≥ 0. The set of terms is Δ𝑇 = Δ𝐶 ∪ Δ𝑉 .
A list 𝑡1, . . . , 𝑡𝑘 of terms is also denoted by (cid:174)𝑡 with |(cid:174)𝑡 | = 𝑘.

Atomsets and Homomorphisms. An atom over a schema S is an
expression of the form p((cid:174)𝑡), p ∈ S and (cid:174)𝑡 ∈ (Δ𝑇 )𝑘 with 𝑘 = ar (p).
An atomset over S is a countable set of atoms over S. For an atom
or atomset 𝐴, we let terms(𝐴) and vars(𝐴) denote the set of terms
and variables in 𝐴, respectively.

A substitution of a set of variables Y ⊆ Δ𝑉 is a mapping 𝜎
from Y to Δ𝑇 . For an atom at = p(𝑡1, . . . , 𝑡𝑘 ) and a substitution
𝜎 of Y, let 𝜎 (at) = p(𝜎+ (𝑡1), . . . , 𝜎+ (𝑡𝑘 )) where 𝜎+ (𝑡𝑖 ) = 𝜎 (𝑡𝑖 )
whenever 𝑡𝑖 ∈ Y and 𝜎+ (𝑡𝑖 ) = 𝑡𝑖 otherwise. If 𝐴 is an atomset, then
𝜎 (𝐴) = {𝜎 (at) | at ∈ 𝐴}. For two substitutions 𝜎 and 𝜎 ′ of variable
sets Y and Y′, respectively, we let 𝜎 ′ ◦ 𝜎 denote the substitution
of Y′ ∪ Y defined by 𝑌 ↦→ 𝜎 ′+ (𝜎+ (𝑌 )). Two substitutions are
compatible if they map the same variables to the same terms.

A homomorphism from an atomset 𝐴 to an atomset 𝐵 is a substi-
tution 𝜋 with 𝜋 (𝐴) ⊆ 𝐵. Given such a homomorphism 𝜋, we also
say that 𝜋 maps 𝐴 to 𝐵, or that 𝐴 maps to 𝐵 (via 𝜋). An isomorphism
from 𝐴 to 𝐵 is a bijective homomorphism 𝜋 such that 𝜋 −1 is a
homomorphism from 𝐵 to 𝐴 (then 𝐴 and 𝐵 are called isomorphic).
An endomorphism (automorphism) of 𝐴 is a homomorphism (iso-
morphism) from 𝐴 to itself. A retraction of 𝐴 is an endomorphism
𝜋 where the restriction of 𝜋 to terms(𝜋 (𝐴)) (the retract) is the id-
entity. Note that the classes of homomorphisms, endomorphisms,
isomorphisms, and retractions are all closed under composition.
A finite atomset 𝐴 is called a core if every retraction of 𝐴 is the
identity. Any finite atomset 𝐴 admits a retract that is a core; this
retract is unique up to isomorphism and called the core of 𝐴.

We identify an atomset with the (possibly infinite) formula ob-
tained from the existential closure of the conjunction of its atoms.
Finite or infinite atomsets also naturally correspond to first-order
interpretations;1 if we want to emphasize this aspect, we also re-
fer to them as instances. A (Boolean) conjunctive query (CQ) is a

1Note that we operate under the unique name assumption.

terminatingcc= finite universal modeltw-boundedrctw-finite universal modelinflatingelevatortw-boundedcctw-finite finitelyuniversal modelsteepeningstaircaseBounded Treewidth and the Infinite Core Chase

PODS ’23, June 18–23, 2023, Seattle, WA, USA

finite atomset. Note that we conflate labeled nulls usually used in
instances with variables usually used in queries, as they correspond
to the same logical notion. We rely on the standard notions of model
and semantic entailment, denoted by |=. An instance 𝐼 is a model
of a (possibly infinite) atomset 𝐴 iff 𝐴 maps to 𝐼 ; for 𝐴 and 𝐵 two
(possibly infinite) atomsets, 𝐴 |= 𝐵 iff 𝐵 maps to 𝐴.

Existential Rules. An (existential) rule 𝑅 is of the form 𝐵 → 𝐻 ,
where the body 𝐵 = body(𝑅) and the head 𝐻 = head (𝑅) are
nonempty finite atomsets. The variables in 𝐵 are called univer-
sal, those both in 𝐵 and 𝐻 are called frontier, and those only in 𝐻
are called existential. We identify a rule with the first-order sentence
∀ (cid:174)𝑋 (cid:174)𝑌.(cid:211)𝐵 [ (cid:174)𝑋, (cid:174)𝑌 ] → ∃ (cid:174)𝑍.(cid:211)𝐻 [ (cid:174)𝑋, (cid:174)𝑍 ] where (cid:174)𝑋, (cid:174)𝑌 , (cid:174)𝑍 are the frontier, non-
frontier universal, and existential variables of 𝑅, respectively. In
examples, we use the logical notation but omit universal quantifiers.
Given an instance 𝐼 and a rule 𝐵 → 𝐻 , a trigger for 𝐼 is a pair
tr = (𝐵 → 𝐻, 𝜋) such that 𝜋 maps 𝐵 to 𝐼 ; tr is satisfied in 𝐼 if 𝜋 can
be extended to a homomorphism from 𝐵 ∪ 𝐻 to 𝐼 . Note that an
instance 𝐼 is a model of a rule 𝑅 iff it satisfies every trigger for 𝐼 of
the form (𝑅, 𝜋). Given a rule 𝑅 = 𝐵 → 𝐻 , an instance 𝐼 and a trigger
tr = (𝑅, 𝜋) for 𝐼 , the application of tr on 𝐼 produces the instance
𝛼 (𝐼, tr) = 𝐼 ∪ 𝜋 safe (𝐻 ), where 𝜋 safe maps every frontier-variable
𝑋 of 𝑅 to 𝜋 (𝑋 ) and any existential variable in vars(𝐻 ) to a fresh
variable (usually called a labeled null).2

Universal Models. A knowledge base (KB) is a pair K = (𝐹, Σ),
where 𝐹 is a finite instance and Σ is a finite set of rules. An instance 𝐼
is a model of K if it is a model of 𝐹 and of each rule in Σ. An instance
𝐼 is universal for K if it (homomorphically) maps to every model
of K; note that this does not necessarily mean that 𝐼 is a model
of K. An instance 𝐼 is a universal model of K if it is a model of K
and is universal for K. We consider the following CQ entailment
problem: given a KB K and a Boolean CQ 𝑄, does K |= 𝑄 hold? For
any universal model 𝐼 of K, K |= 𝑄 holds iff 𝑄 (homomorphically)
maps to 𝐼 , hence, a universal model of K is sufficient to decide CQ
entailment.

3 DERIVATIONS AND THEIR RESULTS
In this paper, we focus on the restricted and the core chase variants.
We now introduce a convenient notion of derivation to define these
two variants. Actually, it would allow to define other variants that
fall between these two variants in terms of redundancy removal,
like e.g., the frugal chase [15]. Our type of derivation is not only
a sequence of rule applications, but also incorporates a retraction
that removes (some) redundancies after each rule application. In
the following, ℑ denotes either the set N of natural integers (for
infinite derivations) or the interval {0, . . . , 𝑘 } ⊆ N (for finite ones).

Definition 1 (Derivation). A derivation from a KB K = (𝐹, Σ)
is a (possibly infinite) sequence D = ((tr𝑖, 𝜎𝑖, 𝐹𝑖 ))𝑖 ∈ℑ, where the tr𝑖
are triggers (except tr0 = ∅), the 𝜎𝑖 are retractions called simplifica-
tions, and the 𝐹𝑖 are finite instances such that: 𝐹0 = 𝜎0 (𝐹 ); and, for
all 𝑖 ∈ ℑ\{0}, 𝐹𝑖 = 𝜎𝑖 (𝛼 (𝐹𝑖 −1, tr𝑖 )), where tr𝑖 = (𝑅𝑖, 𝜋𝑖 ) with 𝑅𝑖 ∈ Σ
is a trigger for 𝐹𝑖 −1 not satisfied in 𝐹𝑖 −1.

2The notion of fresh variable refers to the underlying assumption that the referred
variable is not already present in 𝐹 , but also, that it has not occurred at any potential
previous computation step (which is particularly relevant when rule applications are
iterated and/or intertwined with other operations).

For the sake of brevity, we often denote a derivation simply by
D = (𝐹𝑖 )𝑖 ∈ℑ, leaving the tr𝑖 and 𝜎𝑖 implicit. A derivation is called
monotonic if 𝐹𝑖 −1 ⊆ 𝐹𝑖 holds for all 𝑖 ∈ ℑ\{0}. In a monotonic
derivation, the restriction of 𝜎𝑖 to the terms of 𝐹𝑖 −1 is the identity.
When a derivation D = (𝐹𝑖 )0≤𝑖 ≤𝑘 is finite, its result can be
defined by just taking its last instance: D+ = 𝐹𝑘 . However, for
infinite derivations of the form D = (𝐹𝑖 )𝑖 ∈N, the “result” of D
is usually defined as the (infinite) union of all instances along D.
We denote this union by D∗ = (cid:208)𝑖 ∈ℑ 𝐹𝑖 and call it the natural
aggregation of D (to distinguish it from the robust aggregation
defined in Section 8). Note that if D is a finite monotonic derivation,
then D∗ = D+.

As stated in the next proposition, D∗ is universal for K. Yet, to
ensure that a model of K is obtained, we need to require fairness,
which intuitively means that every trigger for some 𝐹𝑖 has to be
satisfied in some 𝐹 𝑗 with 𝑗 ≥ 𝑖. To formalize this notion, a difficulty
with our derivation notion (which arises for any non-monotonic
type of chase) is that a trigger (𝑅, 𝜋) for some 𝐹𝑖 may not remain a
trigger for some 𝐹 𝑗 with 𝑗 > 𝑖: this is because 𝜋 (body(R)) may be
“transformed away” by successive simplifications. To address this
issue, we need to “trace” how a set of atoms is transformed along a
derivation.

𝑖 (𝑋 ) = 𝜎𝑗 ◦ · · · ◦ 𝜎𝑖+1 (𝑋 ) when 𝑗 > 𝑖.

Definition 2. Let D = (𝐹𝑖 )𝑖 ∈ℑ be a derivation, and 𝑋 be a
variable occurring in some 𝐹𝑖 . For any 𝑗 ∈ ℑ with 𝑗 ≥ 𝑖, we define
𝑖 (𝑋 ) = 𝑋 and ˜𝜎 𝑗
˜𝜎𝑖
It is immediate that ˜𝜎 𝑗

𝑖 (which is either the identity when 𝑖 = 𝑗
or 𝜎𝑗 ◦ · · · ◦ 𝜎𝑖+1 otherwise) is a homomorphism from 𝐹𝑖 to 𝐹 𝑗 . Note
also that for a monotonic derivation, ˜𝜎 𝑗
𝑖 is the identity for any 𝑗. In
the following, if tr = (𝑅, 𝜋) is a trigger for 𝐴 and 𝜎 is a substitution,
we note 𝜎 (tr) = (𝑅, 𝜎 ◦ 𝜋) the trigger for 𝜎 (𝐴).

Definition 3 (Fair derivation). A derivation D = (𝐹𝑖 )𝑖 ∈ℑ is
fair if, for any 𝑖 ∈ ℑ and trigger tr for 𝐹𝑖 , there is some 𝑗 ∈ ℑ with
𝑗 ≥ 𝑖, such that ˜𝜎 𝑗
𝑖 (tr) is a satisfied trigger for 𝐹 𝑗 .

In classical chase procedures, only active triggers (a notion spe-
cific to each chase variant) are applied. In the restricted chase, a
trigger for 𝐹𝑖 is active if it is not already satisfied in 𝐹𝑖 . The core
chase furthermore computes a retraction to a core after each (or
a finite number of) rule application. For both variants, the clas-
sical definition of a chase sequence coincides with our notion of
a fair derivation. A restricted chase sequence can be seen as a fair
derivation ((tr𝑖, 𝜎𝑖, 𝐹𝑖 ))𝑖 ∈ℑ in which 𝜎𝑖 is the identity. Since this
derivation is monotonic, it allows for a simpler expression of fair-
ness: any trigger for an 𝐹𝑖 has to be satisfied in some 𝐹 𝑗 , with
𝑖 ≤ 𝑗. A core chase sequence can be seen as a (non-monotonic) fair
derivation in which each 𝜎𝑖 produces a core.

Finally, we adapt to our general framework some well-known
properties of these chase variants [9, 10, 14]. Albeit D∗ is not always
a model, modelhood is guaranteed for monotonic derivations, as
already known for the restricted chase.

Proposition 1. Let D be a derivation from K. Then:

(1) D∗ is universal for K;
(2) if D is monotonic and fair, D∗ is a model of K;
(3) if D is fair, for all CQ 𝑄, K |= 𝑄 iff D∗ |= 𝑄.

PODS ’23, June 18–23, 2023, Seattle, WA, USA

Jean-François Baget, Marie-Laure Mugnier, and Sebastian Rudolph

4 ADDING TREEWIDTH TO THE PICTURE
We now recall the popular notion of the treewidth of an atomset as
well as some well-known facts about it, which will be useful later.

Definition 4. Given an atomset 𝐴, a tree decomposition of 𝐴 is
a (possibly infinite) tree 𝑇 = (𝑉, 𝐸), with vertices 𝑉 ⊆ 2terms (𝐴) and
edges 𝐸 ∈ 𝑉 × 𝑉 , where:
• for each at ∈ 𝐴 exists some 𝑣 ∈ 𝑉 with terms(at) ⊆ 𝑣;
• for each 𝑡 ∈ terms(𝐴), letting 𝑉𝑡 = {𝑣 ∈ 𝑉 | 𝑡 ∈ 𝑣 }, the subgraph

of 𝑇 induced by 𝑉𝑡 is connected.

The width of 𝑇 = (𝑉 , 𝐸) is the size of its largest vertex, minus 1. The
treewidth of an atomset 𝐴, denoted by 𝑡𝑤 (𝐴), is the minimal width
among all its tree decompositions.

Fact 1. 𝐴 ⊆ 𝐵 implies tw(𝐴) ≤ tw(𝐵).

Definition 5. Given a natural number 𝑛, we say that an atomset
𝐴 contains an 𝑛 × 𝑛-grid, if terms(𝐴) contains 𝑛2 distinct terms,
denoted 𝑡𝑖
𝑗 for 𝑖, 𝑗 ∈ {1, . . . , 𝑛}, such that for all 𝑘 ∈ {1, . . . , 𝑛 − 1}
and ℓ ∈ {1, . . . , 𝑛}:
ℓ , 𝑡𝑘+1
• there is some at ∈ 𝐴 with {𝑡𝑘
ℓ
, 𝑡 ℓ
• there is some at′ ∈ 𝐴 with {𝑡 ℓ
𝑘+1} ⊆ terms(at′).
𝑘

} ⊆ terms(at), and

Fact 2. If 𝐴 contains an 𝑛 × 𝑛-grid then tw(𝐴) ≥ 𝑛.

Treewidth is an important notion in the context of existential
rules, as the existence of universal models with finite treewidth im-
plies decidability of CQ entailment [3, 7]. In fact, many concrete and
practically relevant classes of existential rule sets enjoy this prop-
erty. One generic way to guarantee the existence of such models
is by imposing conditions on the corresponding derivations. This
approach underlies all definitions of so-called bounded treewidth
sets of rules from the literature, but there is a certain disagreement
and diversity as to certain details and the type of chase employed (cf.
Footnote 4). Here, we will provide the most general such definition
that is known to guarantee finite-treewidth universal models along
the lines of previously established proofs.

Definition 6. A ruleset Σ is called a bounded treewidth set (bts)
if for any finite instance 𝐹 , there exist some 𝑏 ∈ N and a restricted
chase sequence (𝐹𝑖 )𝑖 ∈ℑ such that tw(𝐹𝑖 ) ≤ 𝑏 for all 𝑖 ∈ ℑ.
Proposition 2. CQ entailment for bts is decidable.

5 CORE CHASE & STRUCTURAL MEASURES
In what follows, we will use the term structural measure to gener-
ically denote any function 𝜇 that maps instances to elements of
N ∪ {∞}. An easy example would be the size of an instance defined
by size : 𝐼 ↦→ |𝐼 |. An instance 𝐼 is then called 𝜇-finite, if 𝜇 (𝐼 ) ≠ ∞.
Moreover, we say that a sequence (𝐹𝑖 )𝑖 ∈ℑ of atomsets is uniformly 𝜇-
bounded, if there exists some 𝑘 ∈ N such that 𝜇 (𝐹𝑖 ) ≤ 𝑘 for all 𝑖 ∈ ℑ.
(𝐹𝑖 )𝑖 ∈ℑ will be called recurringly 𝜇-bounded if there exists some
𝑘 ∈ N such that for any 𝑗 ∈ ℑ there exists some 𝑖 ≥ 𝑗 from ℑ for
which 𝜇 (𝐹𝑖 ) ≤ 𝑘 holds. It is easy to see that uniform 𝜇-boundedness
implies recurring 𝜇-boundedness, but not vice versa.

Since – on an intuitive level – universal models can be seen as
“limits” of appropriate chase sequences, it is a natural question to
ask to what extent this limit process preserves structural measures.
More specifically, one may ask oneself, given a particular type of

chase and structural measure 𝜇, if the existence of a (uniformly
or recurringly) 𝜇-bounded chase sequence for a KB is a necessary
and/or sufficient condition for the existence of a 𝜇-finite universal
model. As mentioned before, for the structural measure of size, this
question can be answered positively: A knowledge base K has a
(size-)finite universal model iff it has a size-bounded core chase
sequence [9].

Turning to the structural measure of treewidth, however, we
found that, surprisingly, both directions fail, witnessed by coun-
terexamples for either direction: The “steepening staircase” KB
(Section 6) allows for a (even uniformly) treewidth-bounded chase
sequence while lacking a treewidth-finite universal model, whereas
the “inflating elevator” KB (Section 7) has a universal model of finite
treewidth while not exhibiting a (even just recurringly) treewidth-
bounded core-chase sequence.

Irrespective of the fact that our presentation focuses on treewidth
as the arguably most prominent structural measure, it should be
noted that our counterexamples are based on grid structures and
therefore also immediately work for other measures, such as clique-
width [11] or (generalized) hypertreewidth [13].

(𝐹 h, Σh) where Σh = {𝑅h

6 THE STEEPENING STAIRCASE
For the KB below, the core chase sequence is uniformly treewidth-
bounded by 2, but none of its universal models has finite treewidth.
Definition 7 (The Steepening Staircase KB). We let Kh =
3 , 𝑅h
We now describe the instance 𝐼 h, which is a universal model of
Kh that we can obtain via both the restricted and the core chase.
Definition 8. We define 𝐼 h as the infinite instance using the terms
𝑗 | (𝑖, 𝑗) ∈ N2, 𝑖 + 1 ≥ 𝑗 } and consisting of the atoms

4 }, as given in Figure 2.

terms(𝐼 h) = {𝑋 𝑖

2 , 𝑅h

1 , 𝑅h

𝑗+1)

𝑗 , 𝑋 𝑖

v(𝑋 𝑖

h(𝑋 𝑖
h(𝑋 𝑖

for 𝑖 ≥ 𝑗 ≥ 1

𝑘+1}. Let 𝑃 h

)
for 𝑖 ≤ 𝑗 .

𝑗 , 𝑋 𝑖+1
f(𝑋 𝑖
0)
𝑗
c(𝑋 𝑖
𝑗 , 𝑋 𝑖
𝑗 )
𝑗 )
The instance 𝐼 h is depicted in Figure 2; the names 𝑋 𝑖

𝑗 of the
variables of 𝐼 h are in correspondence to their cartesian coordi-
nates (𝑖, 𝑗) in the picture. We now consider some particular subsets
of terms(𝐼 h). For any 𝑘 ∈ N, let 𝑃𝑘 = {𝑋 𝑖
𝑗 }𝑖 ≤𝑘 , 𝐶𝑘 = {𝑋 𝑘
𝑗 } 𝑗 ≤𝑘 , and
𝑘 , 𝑆h
𝑘 (resp. 𝐶h
𝑆𝑘 = 𝐶𝑘 ∪ 𝐶𝑘+1 ∪ {𝑋 𝑘
𝑘 ) denote the subset of
𝐼 h induced by 𝑃𝑘 (resp. 𝐶𝑘 , 𝑆𝑘 ). Intuitively, 𝑃 h
𝑘 is the finite part until
𝑘 is the 𝑘th column of 𝐼 h (minus its top element) and
column 𝑘, 𝐶h
𝑘 is a step – a rectangle containing the two columns 𝐶h
𝑆h
𝑘+1.
We first point out that there is a sequence of rule applications
from any 𝐶h
1 on the top of
𝑘 to “complete” 𝐶h
𝐶h
𝑘 and obtain the two highest variables of 𝐶h
𝑘+1.
Then we apply 𝑅h
2 𝑘 times (from top to bottom) to obtain the other
variables of 𝐶h
𝑘+1. Once 𝑋 𝑘+1
has been generated, we can apply 𝑅h
3
to generate the h-loop on 𝑋 𝑘+1
, then 𝑘 successive applications of
0
4 propagate the loops on 𝐶h
𝑅h
𝑘+1, from bottom to top. There is thus
a monotonic infinite derivation Dr = (𝐹𝑖 )𝑖 ∈N from Kh, the natural
aggregation of which yields 𝐼 h. We successively apply 𝑅h
3 , and
𝑅h
4 on 𝐹 h to obtain 𝑆h
0 , we apply the rules
on 𝐶h
2 , and so on. The
r = 𝐼 h.
infinite union of all atomsets along this derivation is D∗
Proposition 3. 𝐼 h is a result of the restricted chase on Kh.

1 . Since 𝐶h
1 as seen previously to obtain 𝑅h

𝑘 . Indeed, we can apply 𝑅h

1 ⊆ 𝑆h
1 and thus 𝑆h

𝑘 producing 𝑆h

𝑘 and 𝐶h

0 = 𝑃 h

1 , 𝑅h

0

Bounded Treewidth and the Infinite Core Chase

PODS ’23, June 18–23, 2023, Seattle, WA, USA

(𝑅h
1 )
(𝑅h
2 )
(𝑅h
3 )
(𝑅h
4 )

(𝐹 h)

𝐹 h

]
×
[

h(𝑋 , 𝑋 ) → ∃𝑋 ′𝑌𝑌 ′.h(𝑋 , 𝑌 ) ∧ v(𝑋 , 𝑋 ′ ) ∧ h(𝑋 ′, 𝑌 ′ ) ∧ v(𝑌 , 𝑌 ′ ) ∧ c(𝑌 ′ )

h(𝑋 , 𝑋 ) ∧ v(𝑋 , 𝑋 ′ ) ∧ h(𝑋 ′, 𝑋 ′ ) ∧ h(𝑋 ′, 𝑌 ′ ) → ∃𝑌 .c(𝑌 ′ ) ∧ h(𝑋 , 𝑌 ) ∧ v(𝑌 , 𝑌 ′ )
f(𝑋 ) ∧ h(𝑋 , 𝑋 ) ∧ h(𝑋 , 𝑌 ) → f(𝑌 ) ∧ h(𝑌 , 𝑌 )

h(𝑋 , 𝑋 ) ∧ v(𝑋 , 𝑋 ′ ) ∧ c(𝑋 ′ ) → h(𝑋 ′, 𝑋 ′ )

{f(𝑋 0

0 ), h(𝑋 0

0 , 𝑋 0

0 ) }

𝑅h
1

𝑅h
2

𝑅h
3

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

𝑅h
4

]
×
[

]
×
[

]
×
[

]
]
×
×
[
[

]
]
]
×
×
×
[
[
[

]
×
[

]
]
]
×
×
×
[
[
[

𝐼 h

]
×
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
]
×
×
×
[
[
[

]
×
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
]
×
×
×
[
[
[

]
×
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
]
×
×
×
[
[
[

]
×
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
]
×
×
×
[
[
[

˜𝐼 h

]
×
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
]
×
×
×
[
[
[

]
×
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
×
×
[
[

]
]
]
×
×
×
[
[
[

Figure 2: Left: rules of Σh, fact set 𝐹 h, and a graphical representation thereof. Orange (grey) elements represent the rule body,
]
denotes v (“vertical”); we write[
denotes h (“horizontal”) and
black elements the rule head. Visualization of atoms:
×
] for f (“floor”). Right: Atomset 𝐼 h from Definition 8 – an infinite universal model of Kh. Atomset ˜𝐼 h at
for c (“ceiling”) and[
×
the very right is another infinite model of Kh, which is not universal but satisfies exactly the same CQs.

Sketch of proof. The derivation Dr given above is a restric-
ted chase sequence. Clearly, no 𝛼 (𝐹, 𝑅, 𝜋) in Dr retracts to 𝐹, so it
remains to check that Dr is fair. Indeed, if (𝑅, 𝜋) is a trigger for
some 𝐹𝑖 , then it is a trigger wrt some 𝑅h
𝑘 that is necessarily satisfied
(at most in 𝑃 h
□

). Thus (𝑅, 𝜋) is satisfied in some 𝐹 𝑗 ⊇ 𝑃 h

.

𝑘+2

𝑘+2

𝑘+1 is a retract of 𝑆h

As a result of the restricted chase, 𝐼 h is a universal model of Kh.
Now, we point out that for any 𝑘, 𝐶h
𝑘 that is
a core. Then we can use Dr to build a derivation Dc that relies
upon those retractions. Dc starts out like Dr, but as soon as 𝑆h
0 is
obtained, we retract it to its core 𝐶h
1 . Then, following Dr’s course,
Dc proceeds to build 𝑆h
2 . . . As for Dr,
we note that Dc is fair. Moreover, each retraction to a core is done
a finite number of rule applications after the previous one: Dc is
thus a core chase sequence. Finally, we point out that every atomset
in Dc is a subset of some 𝑆h

1 that retracts to its core 𝐶h

𝑘 , and has thus treewidth at most 2.

Proposition 4. There is a core chase sequence for Kh that is

uniformly treewidth-bounded by 2.

c = D∗

However, all the core computations done in Dc with the goal of
producing a “leaner” result turn out to be futile when it comes to
r = 𝐼 h contains an 𝑛 ×𝑛 grid for any 𝑛, and
the aggregation: D∗
has thus unbounded treewidth. The next proposition even shows
that Kh admits no universal model of finite treewidth. For instance,
the atomset ˜𝐼 h pictured in Figure 2 is a model of Kh but it is not
universal: it does not map to 𝐼 h, since it features an infinite v-path,
while all v-paths contained in 𝐼 h are of finite length.

Proposition 5. No universal model of Kh has finite treewidth.
Sketch of proof. Any universal model 𝑈 of Kh is homomor-
phically equivalent to 𝐼 h. This allows to show that, for any 𝑛 ≥ 1,
□
𝑈 contains an 𝑛 × 𝑛-grid, hence tw(𝑈 ) ≥ 𝑛.

7 THE INFLATING ELEVATOR
We now present a knowledge base Kv which does have a universal
model with a treewidth of 1, while any (fair) core chase sequence

for Kv contains atomsets whose associated treewidths grow mono-
tonically beyond any given bound.

Definition 9 (The Inflating Elevator KB). We let Kv =
7 } and 𝐹 v are as given
4, 𝑅v

6, 𝑅v

3, 𝑅v

5, 𝑅v

2, 𝑅v

(𝐹 v, Σv) where Σv = {𝑅v
1, 𝑅v
in the upper part of Figure 3.

We describe an atomset (shown on the left in Figure 4) repre-
senting a universal model that can be obtained via the natural
aggregation over the restricted chase or a core chase. We use the
same naming convention for nulls as before.

Definition 10. Let terms(𝐼 h) = {𝑋 𝑖

𝑗 | (𝑖, 𝑗) ∈ N, 𝑖 − 1 ≤ 𝑗 ≤ 2𝑖}.
Then 𝐼 v consists of the following atoms for all 𝑖, 𝑗 where all mentioned
nulls are in terms(𝐼 v):
d(𝑋 𝑖
𝑗 )
f(𝑋 𝑖
𝑗 )
c(𝑋 𝑖
2𝑖 )

𝑗 , 𝑋 𝑖+1
)
𝑗
2𝑖, 𝑋 𝑖+1
2𝑖+1)
2𝑖, 𝑋 𝑖+1
2𝑖+2)

𝑗 , 𝑋 𝑖
𝑗+1)
𝑗 , 𝑋 𝑖
𝑗 )

h(𝑋 𝑖
h(𝑋 𝑖
h(𝑋 𝑖

v(𝑋 𝑖
v(𝑋 𝑖

for 𝑖 ≤ 𝑗

Proposition 6. 𝐼 v is a result of the restricted chase on Kv.

Sketch of proof. The claim can be shown inductively by as-
suming that rules without existential variables are prioritized and
new nulls are created according to the following scheme:
• for every 𝑖 ≥ 1, 𝑋 𝑖

2𝑖 −1 and 𝑋 𝑖

2𝑖 are introduced as instances of 𝑌 ′
2𝑖 −2 and

1 with 𝑋 ↦→ 𝑋 𝑖 −1

and 𝑌 ′′ through an application of Rule 𝑅v
𝑌 ↦→ 𝑋 𝑖

2𝑖 −2.
• for every 𝑖 ≥ 1, 𝑋 𝑖+1
application of Rule 𝑅v

𝑖

• every remaining 𝑋 𝑖

is introduced as instance of 𝑌 ′ through an
𝑖 −1 and 𝑋 ′ ↦→ 𝑋 𝑖
2 with 𝑋 ↦→ 𝑋 𝑖
𝑖 .
𝑗 ∈ terms(𝐼 v) with 𝑖 ≥ 1 is introduced as
3 with 𝑋 ↦→ 𝑋 𝑖 −1
𝑗 −1,

instance of 𝑌 ′ through an application of Rule 𝑅v
𝑋 ′ ↦→ 𝑋 𝑖 −1

, and 𝑌 ↦→ 𝑋 𝑖

𝑗

𝑗 −1.

Fairness follows from the fact that 𝐼 v satisfies all its triggers, as can
□
be checked easily.

As a result of the restricted chase, 𝐼 v is a universal model of Kv.
As it turns out, it even contains another universal model of finite

PODS ’23, June 18–23, 2023, Seattle, WA, USA

Jean-François Baget, Marie-Laure Mugnier, and Sebastian Rudolph

(𝐹 v)
(𝑅v
1 )
(𝑅v
3 )
(𝑅v
2 )

0 ), d(𝑋 0

{c(𝑋 0
0 ), f(𝑋 1
c(𝑋 ) ∧ h(𝑋 , 𝑌 ) → ∃𝑌 ′𝑌 ′′.v(𝑌 , 𝑌 ′ ) ∧ v(𝑌 ′, 𝑌 ′′ ) ∧ c(𝑌 ′′ )

0 ), h(𝑋 0

0 , 𝑋 1

0 ) }

v(𝑋 , 𝑋 ′ ) ∧ h(𝑋 , 𝑌 ) → ∃𝑌 ′.v(𝑌 , 𝑌 ′ ) ∧ h(𝑋 ′, 𝑌 ′ )

d(𝑋 ) ∧ f(𝑋 ) ∧ v(𝑋 , 𝑋 ′ ) → ∃𝑌 ′.h(𝑋 ′, 𝑌 ′ ) ∧ f(𝑌 ′ )

𝐹 v

𝑅v
1

𝑅v
2

]
×
[

]
×
[

A

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

A

𝑅v
3

]
×
[

]
×
[

]
×
[

A

(𝑅v
4 )
(𝑅v
5 )
(𝑅v
6 )
(𝑅v
7 )

𝑅v
4

]
×
[

A

c(𝑋 ) → d(𝑋 )
v(𝑋 , 𝑋 ′ ) ∧ d(𝑋 ′ ) → d(𝑋 )

h(𝑋 , 𝑌 ) ∧ d(𝑌 ) ∧ f(𝑌 ) → f(𝑋 ) ∧ v(𝑋 , 𝑋 )

c(𝑋 ) ∧ h(𝑋 , 𝑌 ) ∧ v(𝑌 , 𝑌 ′ ) ∧ f(𝑌 ′ ) → h(𝑋 , 𝑌 ′ )

𝑅v
5

]
×
[

]
×
[

A

𝑅v
6

𝑅v
7

]
×
[

]
×
[

A

]
×
[

]
×
[

]
×
[

A

Figure 3: 𝐹 v and rules of Σv (top) and their graphical depictions (bottom). Orange (grey) elements represent the rule body and
denotes v (“vertical”); we
black elements the rule head. Atoms are encoded as follows:
] for f (“floor”), and[
] for d (“done”).
] for c (“ceiling”),[
write[
×
×
×

denotes h (“horizontal”) and

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
]
×
×
[
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
]
×
×
[
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
]
×
×
[
[

]
×
[

]
×
[

]
]
]
]
]
×
×
×
×
×
[
[
[
[
[

]
]
×
×
[
[

]
]
]
×
×
×
[
[
[

]
]
×
×
[
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
]
]
]
]
]
]
]
]
×
×
×
×
×
×
×
×
×
[
[
[
[
[
[
[
[
[

]
]
×
×
[
[

]
×
[

]
×
[

]
×
[

]
×
[

]
]
]
]
]
]
]
×
×
×
×
×
×
×
[
[
[
[
[
[
[

]
]
×
×
[
[

]
×
[

]
×
[

]
]
]
]
]
×
×
×
×
×
[
[
[
[
[

]
]
×
×
[
[

]
×
[

]
×
[

]
×
[

]
×
[

]
×
[

]
]
]
]
]
]
]
]
×
×
×
×
×
×
×
×
[
[
[
[
[
[
[
[

]
]
×
×
[
[

]
×
[

]
×
[

]
×
[

]
]
]
]
]
]
×
×
×
×
×
×
[
[
[
[
[
[

]
]
×
×
[
[

]
×
[

]
]
]
]
×
×
×
×
[
[
[
[

]
]
]
]
×
×
×
×
[
[
[
[

]
]
×
×
[
[

]
]
]
×
×
×
[
[
[

]
]
]
×
×
×
[
[
[

]
]
×
×
[
[

]
×
[

]
×
[

]
×
[

]
×
[

]
]
]
]
]
]
]
×
×
×
×
×
×
×
[
[
[
[
[
[
[

]
]
×
×
[
[

]
×
[

]
×
[

]
]
]
]
]
×
×
×
×
×
[
[
[
[
[

]
]
×
×
[
[

]
]
]
×
×
×
[
[
[

]
]
]
×
×
×
[
[
[

]
]
]
×
×
×
[
[
[

]
]
]
×
×
×
[
[
[

]
]
×
×
[
[

]
×
[

]
×
[

]
×
[

]
]
]
]
]
]
×
×
×
×
×
×
[
[
[
[
[
[

]
]
×
×
[
[

]
×
[

]
]
]
]
×
×
×
×
[
[
[
[

]
]
]
]
×
×
×
×
[
[
[
[

]
×
[

𝐼 v
∗

]
]
]
×
×
×
[
[
[

𝐼 v
1

]
]
]
×
×
×
[
[
[

𝐼 v
2

]
]
]
×
×
×
[
[
[

𝐼 v
3

]
]
]
×
×
×
[
[
[

𝐼 v
4

]
]
]
×
×
×
[
[
[

𝐼 v
5

]
]
×
×
[
[

]
×
[

]
×
[

]
×
[

]
×
[

]
]
×
×
[
[

]
×
[

]
×
[

]
×
[

𝐼 v

]
]
×
×
[
[

]
×
[

]
×
[

]
]
×
×
[
[

Figure 4: Two infinite universal models of Kv (𝐼 v from Definition 10 and 𝐼 v
the sequence (𝐼 v

𝑛 )𝑛∈N from Definition 12 (recall that 𝐼 v

0 = 𝐹 v).

∗ from Definition 11), and finite atomsets 𝐼 v

1 – 𝐼 v

5 of

treewidth. This second universal model 𝐼 v
is given in the next definition.

∗ , also shown in Figure 4,

Definition 11. We define the atomset 𝐼 v
from 𝐼 v only containing variables of the form 𝑋 𝑖
2𝑖 .
∗ is a universal model of Kv.

Proposition 7. 𝐼 v

∗ as the set of those atoms

Proof. 𝐼 v

∗ is a model of Kv: it receives a homomorphism from 𝐹 v
and satisfies all rules from Σv. It is universal, since the identity is a
∗ to 𝐼 v which is itself a universal model. □
homomorphism from 𝐼 v
This implies that no finite universal model of Kv can exist (as
any such model would receive a homomorphism from 𝐼 v
∗ and thus
contain a h-cycle, thus not be homomorphically equivalent to 𝐼 v
∗ ).
1 , . . . of subsets of 𝐼 v that ex-
hibit increasing treewidths and will later be shown to occur as
substructures in any core chase sequence of Kv. Figure 4 depicts
the first elements of that sequence.

We next describe a sequence 𝐼 v

0 , 𝐼 v

Definition 12. We define the sequence (𝐼 v
𝑛 )𝑛∈N of atomsets by
0 = 𝐹 v and, for any 𝑛 > 0, obtaining 𝐼 v
𝑛 as the substructure of
2 } ∪ {𝑋 𝑖
𝑛 ) = {𝑋 𝑖
𝑗 | 𝑖 ≤ 𝑛+1 and 𝑗 ≥ 𝑛}
𝑗 , 𝑋 𝑖
𝑗 ) with 𝑗 > 𝑛 as well as all

letting 𝐼 v
𝐼 v induced by terms(𝐼 v
removing all atoms v(𝑋 𝑖
𝑗 , 𝑋 𝑖+1
atoms h(𝑋 𝑖
𝑘

2𝑖 | 𝑖 ≤ 𝑛
𝑗 ) and f(𝑋 𝑖
) with 𝑘 > 𝑗 and 𝑘 > 𝑛.

Proposition 8. The following hold:

𝑛 is a core.

𝑛 has a treewidth of at least ⌈𝑛/3⌉ + 1.

(1) Every 𝐼 v
(2) 𝐼 v
(3) For every core chase sequence (𝐹𝑖 )𝑖 ∈N for Kv, there is an un-
: N → N such that, for every

bounded monotonic function 𝑓
𝑛 ∈ N, 𝐼 v

𝑓 (𝑛) is isomorphic to a subset of 𝐹𝑛.

(4) For every core chase sequence (𝐹𝑖 )𝑖 ∈N for Kv and any 𝑚 ∈ N

exists a 𝑘 ∈ N such that tw(𝐹𝑖 ) ≥ 𝑚 for all 𝑖 ≥ 𝑘.
From these technical insights, we obtain the strong guarantee

regarding the growth of the treewidth:

Corollary 1. No core chase sequence for Kv is recurringly or

uniformly treewidth-bounded.

Bounded Treewidth and the Infinite Core Chase

PODS ’23, June 18–23, 2023, Seattle, WA, USA

8 ROBUST AGGREGATIONS SAVE THE DAY
Recall that the steepening staircase example demonstrates that a
bounded-treewidth chase sequence does not warrant the existence
of a universal model of finite treewidth. This blocks the traditional
approach for showing decidability of CQ entailment. However, we
are still able to establish this desired result by other means, as
demonstrated in the course of the next two sections.

More specifically, we show that CQ entailment is decidable for
the class of KBs having a recurringly treewidth-bounded core chase
sequence (forthcoming Theorem 2). To do so, we go through the
following steps. Firstly, we resort to a weaker notion than universal-
ity, namely finite universality (Definition 13). We show that finitely
universal models can play the same role as universal models when it
comes to CQ entailment (Proposition 9). Secondly, we define a novel
way to compute the result of a derivation, namely the robust aggre-
gation of a derivation, and show that the robust aggregation of any
fair derivation is a finitely universal model (Proposition 11). Finally,
in Section 9, we show that the robust aggregation of a derivation
having recurringly bounded treewidth has finite treewidth (Propo-
sition 12), and conclude by adapting Courcelle’s theorem to show
that CQ entailment is decidable for KBs admitting a finitely uni-
versal model of finite treewidth (Theorem 1). In the following, we
detail the employed notions and arguments laid out above.

Definition 13 (Finite universality). An atomset 𝐼 is finitely

universal for K if each finite subset of 𝐼 is universal for K.

Proposition 9. Let 𝑀 be a finitely universal model of a KB K,

and let 𝑄 be a CQ. Then K |= 𝑄 iff 𝑀 |= 𝑄.

Proof. (⇐) Let 𝜎 be a homomorphism from 𝑄 to 𝑀. As 𝑀 is
finitely universal, the finite subset 𝜎 (𝑄) of 𝑀 maps to any model 𝐼
of K by some 𝜎 ′, thus 𝜎 ′ ◦ 𝜎 maps 𝑄 to 𝐼 . (⇒) Since K |= 𝑄 and
□
𝑀 is a model of K, 𝑀 |= 𝑄.

Defining Robust Aggregations. For non-monotonic derivations
D = (𝐹𝑖 )𝑖 ∈ℑ, it may happen that an atom at is in some 𝐹𝑖 , but
“disappears” at some later step 𝑗. Yet, at will still belong to the nat-
ural aggregation D∗. Intuitively, the natural aggregation generates
atomsets that are “too big” (this is why they may not be models). We
thus introduce a new type of aggregation, called robust aggregation,
that, instead of merely combining all atomsets 𝐹𝑖 along the deriva-
tion, combines their collapsed versions obtained via preemptive
applications of future simplifications 𝜎 𝑗 along the derivation. Defin-
ing this result is not immediate, however, since a variable could be
indefinitely re-mapped through simplifications along a derivation.
Observe that, in the staircase example, the core chase maps 𝑋 0
0 to
𝑋 1
0 to 𝑋 2
0 , then 𝑋 1
0 , etc., and there is no way we can define the ulti-
mate image of 𝑋 0
0 unless we can force the simplification to stabilize
at some point. This is the goal of the robust renaming, for which we
assume a bijection rank of the variables X with N, and use the total
ordering <X on X defined by 𝑋 <X 𝑌 iff rank(𝑋 ) < rank(𝑌 ).

Definition 14 (Robust renaming). Let 𝐴 be an atomset and let
𝜎 be a retraction of 𝐴. The robust renaming associated with 𝜎 is the
substitution 𝜌𝜎 of vars(𝜎 (𝐴)) that maps any variable 𝑋 of 𝜎 (𝐴) to
the <X-smallest variable of 𝜎 −1 (𝑋 ). We let 𝜏𝜎 = 𝜌𝜎 ◦ 𝜎.

𝐴𝑖 −1

𝜎𝑖 −1

𝐹𝑖 −1

homomorphism

isomorphism

rule application

𝜌𝑖 −1

𝐺𝑖 −1

𝐴𝑖
𝜌𝑖 −1

𝐴′
𝑖

𝜏𝑖

𝜎𝑖

𝜎 ′
𝑖

𝜏𝑖

𝜌𝑖 −1
𝐹 ′
𝑖
𝜌𝜎 ′
𝑖

𝐹𝑖

𝜌𝑖

𝐺𝑖

Figure 5: Building the robust sequence associated with D.

It is immediate that 𝜌𝜎 is an isomorphism from 𝜎 (𝐴) to 𝜏𝜎 (𝐴),
and, for any variable 𝑋 in 𝐴, 𝜏𝜎 (𝑋 ) is a constant or 𝜌𝜎 (𝑋 ) ≤X 𝑋 . Let
us now inductively apply those robust renamings along a derivation.

Definition 15 (Robust seqence). Let D = (𝐹𝑖 )𝑖 ∈ℑ be a deriva-
tion. The robust sequence associated with D is the sequence of atom-
sets (𝐺𝑖 )𝑖 ∈ℑ defined inductively by (see Figure 5 for induction step):
• With 𝐴0 = 𝐹 , 𝐹0 = 𝜎0 (𝐴0), and 𝜌0 = 𝜌𝜎0 , we define 𝐺0 = 𝜌0 (𝐹0);
• ∀𝑖 ∈ ℑ with 𝑖 > 0, if 𝐹𝑖 −1 = 𝜎𝑖 −1 (𝐴𝑖 −1), 𝐴𝑖 = 𝛼 (𝐹𝑖 −1, tr), 𝐹𝑖 =
𝜎𝑖 (𝐴𝑖 ) and 𝐺𝑖 −1 = 𝜌𝑖 −1 (𝐹𝑖 −1) (𝐹𝑖 −1 and 𝐺𝑖 −1 being isomorphic),
we build 𝐺𝑖 and an isomorphism 𝜌𝑖 from 𝐹𝑖 to 𝐺𝑖 as follows:
– let 𝐴′

𝑖 = 𝛼 (𝐺𝑖 −1, 𝜌𝑖 −1 (tr))), with the

𝑖 = 𝜌𝑖 −1 (𝐴𝑖 ) (see that 𝐴′

same fresh variables as in 𝛼 (𝐹𝑖 −1, tr)) and 𝐹 ′

𝑖 = 𝜌𝑖 −1 ◦ 𝜎𝑖 ◦ 𝜌 −1

– then 𝜎 ′
– we define 𝐺𝑖 = 𝜌𝜎 ′

(𝐹 ′
𝑖 and 𝜌𝑖 = 𝜌𝜎 ′

with 𝜎 ′

𝑖

𝑖

𝑖 −1 is a retraction such that 𝜎 ′

𝑖 ) = 𝐹 ′
𝑖 ;
𝑖 the robust renaming associated

𝑖 ), with 𝜌𝜎 ′
◦ 𝜌𝑖 −1 an isomorphism from 𝐹𝑖 to 𝐺𝑖 ;
◦𝜎 ′

𝑖 the homomorphism

= 𝜌𝜎 ′
𝑖

𝑖

– furthermore, we denote by 𝜏𝑖 = 𝜏𝜎 ′

from 𝐴′

𝑖 to 𝐺𝑖 . See that 𝜏𝑖 also maps 𝐺𝑖 −1 ⊆ 𝐴′
𝑖 to 𝐺𝑖 .
Note that (𝐺𝑖 ) is not a derivation, since the 𝜏𝑖 from 𝐴′

𝑖 to 𝐺𝑖 are
not endomorphisms. However, every 𝐺𝑖 is isomorphic to 𝐹𝑖 , and
we show that variables are finitely renamed along this sequence.

𝑖 = 𝜌𝑖 −1 (𝐹𝑖 );
𝑖 (𝐴′

Proposition 10. Let (𝐺𝑖 )𝑖 ∈ℑ be an associated robust sequence.
For 𝑖, 𝑗 ∈ ℑ with 𝑖 < 𝑗, let ¯𝜏 𝑗
𝑖 = 𝜏 𝑗 ◦ · · · ◦ 𝜏𝑖+1 denote the composition
of all 𝜏ℓ between 𝐺𝑖 and 𝐺 𝑗 . Then, for any 𝑋 ∈ vars(𝐺𝑖 ), there is 𝑗 ∈ ℑ
with 𝑗 > 𝑖 such that ¯𝜏 𝑗
𝑖 (𝑋 ) = 𝑌 ∈ terms(𝐺 𝑗 ) and for all 𝑘 ∈ ℑ with
𝑘 > 𝑗, ¯𝜏𝑘

𝑗 (𝑌 ) = 𝑌 (i.e., 𝑌 is stable from 𝐺 𝑗 on). We let ¯𝜏 (𝑋 ) = 𝑌 .

Proof. Let 𝑋 ∈ vars(𝐺𝑖 ), then 𝜏𝑖+1 (𝑋 ) = 𝜏𝜎 ′
𝑖+1

(𝑋 ) ≤X 𝑋. Con-
sider some arbitrary 𝑗 ∈ ℑ with 𝑗 > 𝑖. Among the homomorphisms 𝜏ℓ
that ¯𝜏 𝑗
𝑖 is composed of, there can be at most rank X (𝑋 ) many of them
that are effectively decreasing (causing ¯𝜏 ℓ −1
□

(𝑋 ) <X ¯𝜏 ℓ

𝑖 (𝑋 )).

𝑖

We now use the ¯𝜏 (𝐺𝑖 ) to define the robust aggregation. Note that,

contrary to (𝐹𝑖 ) or (𝐺𝑖 ), the sequence ( ¯𝜏 (𝐺𝑖 )) is monotonic.

Definition 16 (Robust aggregation). Given a derivation D =
(𝐹𝑖 )𝑖 ∈ℑ and its associated robust sequence (𝐺𝑖 )𝑖 ∈ℑ, the robust aggre-
gation of D is the (possibly infinite) atomset D ⊛ = (cid:208)𝑖 ∈ℑ ¯𝜏 (𝐺𝑖 ).

Semantic Properties of Robust Aggregations. The steepening stair-
case shows that the robust aggregation of a derivation is not always
universal. Indeed, consider the KB Kh (from Definition 7) and let
<X be an order on the variables with 𝑗 < 𝑘 ⇒ 𝑋 𝑖
𝑘 . The core
chase on Kh begins building the first step 𝑆h
0 of 𝐼 h, and all simplifi-
cations are the identity until done. Now, the first proper retraction
maps 𝑋 0
1 , so the robust renaming generates
𝐺𝑖1 , which is isomorphic to the column 𝐶h
1 , but its variables are

0 and 𝑋 0

𝑗 <X 𝑋 𝑖

1 to 𝑋 1

0 to 𝑋 1

PODS ’23, June 18–23, 2023, Seattle, WA, USA

Jean-François Baget, Marie-Laure Mugnier, and Sebastian Rudolph

1 , 𝑋 1

0 , 𝑋 0

0 and 𝑋 0

named (from bottom to top) 𝑋 0
1 . Likewise, from successive
proper retraction steps, we obtain 𝐺𝑖 𝑗 isomorphic to 𝐶h
𝑗 but with
variables named 𝑋 0
2 , . . . , 𝑋 𝑗
𝑗+1. Note that ¯𝜏 (𝐺𝑖 𝑗 ) = 𝐺𝑖 𝑗 holds:
every variable is stable since subsequent re-mappings would have
to be within the same row, yet all variables therein are <X-greater.
Then, the robust aggregation D ⊛ is isomorphic to the infinite col-
umn ˜𝐼 h, with variables named 𝑋 0
𝑗+1, . . . , which is
not universal, but is a finitely universal model, as stated below.

2 , . . . , 𝑋 𝑗

1 , 𝑋 1

0 , 𝑋 0

Proposition 11. Let D be a derivation from K. Then (1) D ⊛
is a model of K.

finitely universal for K; and (2) if D is fair, D ⊛

is

To prove this proposition, we rely on the next lemma, which
states that any finite part of D ⊛ is “stably present” from a certain
element on in the robust sequence associated with D.

Lemma 1. Let D be a derivation and let (𝐺𝑖 )𝑖 ∈ℑ be the robust
, there is

sequence associated with D. For any finite subset 𝐴 of D ⊛
some 𝑘 ∈ ℑ such that 𝐴 ⊆ 𝐺𝑟 for every 𝑟 ∈ ℑ with 𝑟 ≥ 𝑘.

Sketch of proof. See that (i) the ¯𝜏 (𝐺𝑖 ) form a monotonic se-
quence and then, thanks to Proposition 10, that (ii) for every ¯𝜏 (𝐺𝑖 ),
there exists 𝑘 ∈ ℑ such that ¯𝜏 (𝐺𝑖 ) ⊆ 𝐺𝑟 for every 𝑟 ≥ 𝑘. Thanks to
(i), there is some 𝑖 with 𝐴 ⊆ ¯𝜏 (𝐺𝑖 ) and we conclude with (ii).
□

Proof of Proposition 11. (1) Let 𝑀 be an arbitrary model of
K, and let 𝐼 be be any finite subset of D ⊛. By Lemma 1, there is
some 𝑘 such that 𝐼 ⊆ 𝐺𝑘 . Now 𝐺𝑘 is isomorphic to 𝐹𝑘 , which is
universal (from Proposition 1), so 𝐺𝑘 (hence also 𝐼 ) maps to 𝑀.

(2) Let D = (𝐹𝑖 )𝑖 ∈ℑ be a fair derivation from (𝐹, Σ) and (𝐺𝑖 )𝑖 ∈ℑ
be its associated robust sequence. Since 𝜏0 maps 𝐹 to 𝐺0, ¯𝜏 ◦𝜏0 maps
𝐹 to D ⊛, thus D ⊛ is a model of 𝐹 . Consider now any trigger tr for
D ⊛. By Lemma 1, there exists some 𝑗 ∈ ℑ such that tr is a trigger for
𝐺𝑟 for any 𝑟 ∈ ℑ with 𝑟 ≥ 𝑗. Since 𝜌𝑟 is an isomorphism from 𝐹𝑟 to
𝐺𝑟 , we obtain that 𝜌 −1
(tr) is a trigger for 𝐹𝑟 . Since D is fair, there
exists some 𝑠 ∈ ℑ with 𝑠 ≥ 𝑟 such that the trigger ˜𝜎𝑠
(tr) for 𝐹𝑠
is satisfied in 𝐹𝑠 . Now since 𝜌𝑠 is an isomorphism from 𝐹𝑠 to 𝐺𝑠 , it
follows that 𝜌𝑠 ◦ ˜𝜎𝑠
(tr) is a satisfied trigger for 𝐺𝑠 . We first see
that 𝜎𝑟 +1 ◦ 𝜌 −1
𝑟 +1 ◦ 𝜏𝑟 +1. By applying this property iteratively,
𝑟 ◦𝜌 −1
we show that 𝜌𝑠 ◦ ˜𝜎𝑠
(tr) = ¯𝜏𝑠
𝑟 (tr) = tr
is a trigger for 𝐺𝑠 satisfied in 𝐺𝑠 , and thus satisfied in D ⊛.
□

𝑟 ◦𝜌 −1
𝑟
𝑟 = 𝜌 −1

𝑟 . Then 𝜌𝑠 ◦ ˜𝜎𝑠

𝑟 = ¯𝜏𝑠

𝑟 ◦ 𝜌 −1
𝑟

𝑟 ◦𝜌 −1
𝑟

𝑟

Hence, both natural and robust aggregations indicate whether a
CQ is entailed by a KB. Yet, natural aggregation provides an instance
that is universal but not always a model, while the more complex
robust aggregation provides a model which might be only finitely
universal. We show next how the latter case can still be utilized
towards proving Theorem 2.

9 DECIDABILITY THROUGH TREEWIDTH
The steepening staircase example shows that the natural aggre-
gation of the core chase may have infinite treewidth even if the
chase sequence is uniformly treewidth-bounded. The next proposi-
tion provides two results: Firstly, the natural aggregation is indeed
treewidth-preserving for monotonic derivations, generalizing a re-
sult by Baget et al. [3] for the restricted chase. Secondly (and more
importantly), robust aggregation is superior to natural aggrega-
tion in that treewidth preservation can be shown to hold even for
non-monotonic chases. Both results rely upon the compactness of

treewidth [18]: if 𝐹 is an atomset where tw(𝐹 ′) ≤ 𝑘 holds for every
finite subset 𝐹 ′ ⊆ 𝐹 , then tw(𝐹 ) ≤ 𝑘.

Proposition 12. For any derivation D that is recurringly tree-

width-bounded by some integer 𝑘, the following hold:
(1) D’s natural aggregation D∗ has treewidth ≤𝑘, if D is monotonic.
(2) D’s robust aggregation D ⊛

has treewidth ≤𝑘.

Proof. Let 𝐼 be a finite subset of D∗ (for proof of (1)) or D ⊛
(for proof of (2)). There is some 𝑝 ∈ ℑ such that, ∀𝑟 ≥ 𝑝 ∈ ℑ,
we can exhibit some 𝐼𝑟 isomorphic to 𝐹𝑟 with 𝐼 ⊆ 𝐼𝑟 . To prove
(1), D being monotonic, we can define 𝐼𝑟 = 𝐹𝑟 . To prove (2), we
rely upon Lemma 1 and define 𝐼𝑟 = 𝐺𝑟 . Since D is recurrently
treewidth-bounded, there is some 𝑠 ≥ 𝑝 ∈ ℑ such that tw(𝐹𝑠 ) ≤ 𝑘.
Thus tw(𝐼 ) ≤ tw(𝐼𝑠 ) = tw(𝐹𝑠 ) ≤ 𝑘, and we conclude, thanks to
compactness of treewidth, that D∗ or D ⊛ has treewidth ≤ 𝑘. □

The last missing insight is that the existence of treewidth-bounded
finitely universal models suffices to establish decidability of CQ
entailment.3 We obtain this result via a mild generalization of re-
spective statements for universal models [3, 7, 11].

Theorem 1. Let ℭ be a class of knowledge bases for which every
K = (𝐹, Σ) ∈ ℭ has a model 𝐼 that is finitely universal for K and
that satisfies 𝑡𝑤 (𝐼 ) ∈ N. Then CQ entailment for ℭ is decidable.

Sketch of proof. K |= 𝑄 can be detected in finite time due to
the completeness of first-order logic. K ̸|= 𝑄 can be detected by
incrementing 𝑘 stepwise and checking if K ∧ (¬𝑄) has a model of
□
treewidth 𝑘, which is decidable.

We finally obtain our main result, which follows from Proposi-

tions 11 and 12, and Theorem 1:

Theorem 2. CQ entailment is decidable for the class of KBs having

a recurringly treewidth-bounded core chase sequence.

We end this section by using this decidability result to define a
new class of rulesets and discussing its relationship with existing
abstract decidable classes. As usual in the existential rule setting,
the considered property can be abstracted from the underlying
database, obtaining a new fragment of existential rules that – thanks
to Theorem 2 – warrants decidable CQ entailment and properly
subsumes and reconciles other classes with that property.4

Definition 17. A ruleset Σ is called core-bts, if for every finite
atomset 𝐹 , there exists a core chase sequence for the KB (𝐹, Σ), whose
treewidth is recurringly bounded by some 𝑘 ∈ N.

Proposition 13. CQ entailment is decidable for any ruleset that
is core-bts. Moreover, core-bts subsumes both finite expansion sets (fes)
and bounded treewidth sets (bts), which are mutually incomparable.

3However, no upper complexity bounds are entailed. This holds even for the more
restricted class of KBs with finite, “properly” universal models [5].
4Notably, this corrects inaccurate statements in prior work by Baget et al. [3], where
bts was claimed to subsume fes. The reason for this misconception was a definition
of bts using cores, whereas the proof of decidability of CQ entailment for this class
was flawed, as it erroneously assumed that the natural aggregation over a (treewidth-
bounded) core chase sequence produces a (treewidth-bounded) universal model. The
current paper also corrects this earlier work, showing that the decidability claim made
therein can be salvaged by other means.

Bounded Treewidth and the Infinite Core Chase

PODS ’23, June 18–23, 2023, Seattle, WA, USA

10 CONCLUSION AND FUTURE WORK
In this paper, we have investigated ways of exploiting properties of
the core chase in non-terminating settings, with the main goal of en-
suring decidability of CQ entailment based on treewidth guarantees
for the atomsets occurring in chase sequence.

On the negative side, we found that, contrary to plausible expec-
tations, the existence of a treewidth-bounded core-chase sequence
does not coincide with the existence of a treewidth-bounded univer-
sal model, nor is there a subsumption in one of the two directions:
On one hand, we exhibited a KB Kh admitting a core-chase se-
quence the treewidth of which is uniformly bounded by 2, while
all its universal models are of unbounded treewidth. On the other
hand, we described a KB Kv admitting an infinite universal model
of treewidth 1, while all corresponding core chase sequences consist
of structures of ever increasing treewidth.

On the positive side, we showed how a given core chase sequence
can be robustly aggregated into a (potentially infinite) atomset that
is a model of the underlying knowledge base, while satisfying ex-
actly those CQs entailed by it. We also showed that for any such
core chase sequence that is recurringly treewidth-bounded, the
aggregated atomset will be of finite treewidth. Together, these find-
ings establish decidability of CQ entailment for all knowledge bases
with a recurringly treewidth-bounded core chase. Abstracting from
concrete databases, this yields a novel, very general abstract class
of recurringly treewidth-bounded rulesets, ensuring decidability of
CQ entailment and subsuming the two previously known incompa-
rable classes fes and bts.

Future work on the topic will clarify under what circumstances
the robust aggregation produces cores (according to some of the
many existing non-equivalent definitions of cores in the infinite [4]).
Also, we will investigate the relationship of our approach to the
stable chase introduced by Carral et al. [8], which also produces
(not necessarily universal) models satisfying exactly the entailed
CQs. Note that the stable chase is quite elaborate and not subsumed
by our current generic definition of derivation: the computation
occasionally “jumps back” to earlier sequence elements and starts
rebuilding the sequence from there.

ACKNOWLEDGMENTS
The authors thank the anonymous reviewers for their helpful com-
ments. Jean-François Baget and Marie-Laure Mugnier were partially
supported by the ANR project CQFD (ANR-18-CE23-0003). Sebas-
tian Rudolph has received funding from the European Research
Council (Consolidator Grant Agreement no. 771779, DeciGUT).

REFERENCES
[1] Jean-François Baget, Michel Leclère, and Marie-Laure Mugnier. 2010. Walking the
Decidability Line for Rules with Existential Variables. In Proceedings of the 12th
International Conference on Principles of Knowledge Representation and Reasoning
(KR’10), Fangzhen Lin, Ulrike Sattler, and Miroslaw Truszczynski (Eds.). AAAI
Press. http://aaai.org/ocs/index.php/KR/KR2010/paper/view/1216

[2] Jean-François Baget, Marie-Laure Mugnier, Sebastian Rudolph, and Michaël
Thomazo. 2011. Walking the Complexity Lines for Generalized Guarded Ex-
istential Rules. In Proceedings of the 22nd International Joint Conference on Ar-
tificial Intelligence (IJCAI’11), Toby Walsh (Ed.). IJCAI/AAAI, 712–717. https:
//doi.org/10.5591/978-1-57735-516-8/IJCAI11-126

[3] Jean-François Baget, Michel Leclère, Marie-Laure Mugnier, and Eric Salvat. 2011.
On rules with existential variables: Walking the decidability line. Artificial
Intelligence 175, 9 (2011), 1620–1654. https://doi.org/10.1016/j.artint.2011.03.002
[4] Bruce L. Bauslaugh. 1995. Core-like properties of infinite graphs and structures.

Discrete Mathematics 138, 1-3 (1995), 101–111.

[5] Camille Bourgaux, David Carral, Markus Krötzsch, Sebastian Rudolph, and
Michaël Thomazo. 2021. Capturing Homomorphism-Closed Decidable Queries
with Existential Rules. In Proceedings of the 18th International Conference on Prin-
ciples of Knowledge Representation and Reasoning, KR 2021, Meghyn Bienvenu,
Gerhard Lakemeyer, and Esra Erdem (Eds.). 141–150. https://doi.org/10.24963/kr.
2021/14

[6] A. Calì, G. Gottlob, and M. Kifer. 2008. Taming the Infinite Chase: Query An-
swering under Expressive Relational Constraints. In Proceedings of the 11th In-
ternational Conference on Principles of Knowledge Representation and Reasoning
(KR’08). AAAI Press, 70–80.

[7] Andrea Calì, Georg Gottlob, and Michael Kifer. 2013. Taming the Infinite Chase:
Query Answering under Expressive Relational Constraints. Journal of Artificial
Intelligence Research 48 (2013), 115–174. https://doi.org/10.1613/jair.3873
[8] David Carral, Markus Krötzsch, Maximilian Marx, Ana Ozaki, and Sebastian
Rudolph. 2018. Preserving Constraints with the Stable Chase. In Proceedings of the
21st International Conference on Database Theory (ICDT’18) (LIPIcs, Vol. 98), Benny
Kimelfeld and Yael Amsterdamer (Eds.). Schloss Dagstuhl - Leibniz-Zentrum für
Informatik, 12:1–12:19. https://doi.org/10.4230/LIPIcs.ICDT.2018.12

[9] Alin Deutsch, Alan Nash, and Jeffrey B. Remmel. 2008. The chase revisited. In
Proceedings of the 27th ACM SIGMOD-SIGACT-SIGART Symposium on Principles
of Database Systems (PODS’08), Maurizio Lenzerini and Domenico Lembo (Eds.).
ACM, 149–158. https://doi.org/10.1145/1376916.1376938

[10] R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa. 2005. Data Exchange: Semantics
and Query Answering. Theoretical Computer Science 336, 1 (2005), 89–124.
[11] Thomas Feller, Tim S. Lyon, Piotr Ostropolski-Nalewaja, and Sebastian Rudolph.
2023. Finite-Cliquewidth Sets of Existential Rules: Toward a General Criterion for
Decidable yet Highly Expressive Querying. In Proceedings of the 26th International
Conference on Database Theory (ICDT 2023) (LIPIcs). Schloss Dagstuhl - Leibniz-
Zentrum für Informatik. To appear. Preprint available via https://arxiv.org/abs/
2209.02464.

[12] Kurt Gödel. 1929. Über die Vollständigkeit des Logikkalküls. Ph. D. Dissertation.

Universität Wien.

[13] Georg Gottlob, Nicola Leone, and Francesco Scarcello. 2003. Robbers, Marshals,
and Guards: Game Theoretic and Logical Characterizations of Hypertree Width.
J. Comput. Syst. Sci. 66, 4 (jun 2003), 775–808. https://doi.org/10.1016/S0022-
0000(03)00030-8

[14] Gösta Grahne and Adrian Onet. 2018. Anatomy of the Chase. Fundamenta
Informaticae 157, 3 (2018), 221–270. https://doi.org/10.3233/FI-2018-1627
[15] George Konstantinidis and José Luis Ambite. 2014. Optimizing the Chase: Scalable
Data Integration under Constraints. Proc. VLDB Endow. 7, 14 (2014), 1869–1880.
https://doi.org/10.14778/2733085.2733093

[16] Markus Krötzsch and Sebastian Rudolph. 2011. Extending Decidable Existential
Rules by Joining Acyclicity and Guardedness. In Proceedings of the 22nd Inter-
national Joint Conference on Artificial Intelligence (IJCAI’11), Toby Walsh (Ed.).
IJCAI/AAAI, 963–968. https://doi.org/10.5591/978-1-57735-516-8/IJCAI11-166
[17] B. Marnette. 2009. Generalized schema-mappings: from termination to tractability.
In Proceedings of the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles
of Database Systems (PODS’09), J. Paredaens and J. Su (Eds.). ACM, 13–22.
[18] Robin Thomas. 1988. The Tree-Width Compactness Theorem for Hypergraphs.

Available via https://people.math.gatech.edu/~thomas/PAP/twcpt.pdf.

A PROOFS OF SECTION 3
The following appendices are devoted to the complete proofs that
are missing or only sketched in the paper.

Fact 3. If tr is a trigger for 𝐹 , 𝜇 maps 𝐹 to 𝐼 and 𝐼 satisfies 𝜇 (tr),

then there is 𝜇′ (compatible with 𝜇) that maps 𝛼 (𝐹, tr) to 𝐼 .

Lemma 2. For every fair derivation D = (𝐹𝑖 )𝑖 ∈ℑ, there exists a
fair monotonic derivation D𝑚𝑜𝑛 = (𝐺𝑖 )𝑖 ∈ℑ such that for every 𝑖 ∈ ℑ,
there is a retraction from 𝐺𝑖 to 𝐹𝑖 .

Proof. From D = (𝐹𝑖 )𝑖 ∈ℑ, let us first build inductively a deriva-
tion D𝑚𝑜𝑛 = (𝐺𝑖 )𝑖 ∈ℑ such that 𝐺0 = 𝐴0 = 𝐹 , 𝐹0 = 𝜎0 (𝐹0) and
∀𝑖 > 0 ∈ ℑ, 𝐹𝑖 = 𝜎𝑖 (𝐴𝑖 ) with 𝐴𝑖 = 𝛼 (𝐹𝑖 −1, tr𝑖 ), we can define
𝐺𝑖 = 𝛼 (𝐺𝑖 −1, tr𝑖 ). See that 𝜎0 is a retraction from 𝐺0 to 𝐹0, and so
the trigger tr1 is also a trigger in 𝐺0, allowing us to build 𝐺1. Now
we claim that 𝜎0 is a retraction from 𝐺1 to 𝐴1, and thus 𝜎1 ◦ 𝜎0 is a
retraction from 𝐺1 to 𝐹1. An induction based upon these remarks
shows that for 𝑖 ∈ ℑ, ˜𝜎𝑖 = 𝜎𝑖 ◦ · · · ◦ 𝜎0 is a retraction from 𝐺𝑖 to
𝐹𝑖 that allows us to build 𝐺𝑖+1. The derivation D𝑚𝑜𝑛 we obtain is

PODS ’23, June 18–23, 2023, Seattle, WA, USA

Jean-François Baget, Marie-Laure Mugnier, and Sebastian Rudolph

𝑘+1, 𝑋 𝑘+1

𝑘+1 ), c(𝑋 𝑘+1

𝑘 , 𝑋 𝑘+1
,

𝑘), v(𝑋 𝑘+1

𝑘

, 𝑋 𝑘+1
𝑘+1 )

𝑘 −1), v(𝑋 𝑘+1

𝑘 −1, 𝑋 𝑘+1
𝑘

𝑘+1 ), h(𝑋 𝑘
)

), c(𝑋 𝑘+1
𝑘

Rule
𝑅ℎ
1
𝑅ℎ
2
...
𝑅ℎ
2
𝑅ℎ
3
𝑅ℎ
4
...
𝑅ℎ
4

Homomorphism
𝑋 ↦→ 𝑋 𝑘
𝑘
𝑘 , 𝑌 ′ ↦→ 𝑋 𝑘+1
𝑘 −1, 𝑋 ′ ↦→ 𝑋 𝑘

𝑘

𝑋 ↦→ 𝑋 𝑘

...

1 , 𝑌 ′ ↦→ 𝑋 𝑘+1

1

𝑋 ↦→ 𝑋 𝑘

0 , 𝑋 ′ ↦→ 𝑋 𝑘
𝑋 ↦→ 𝑋 𝑘
𝑋 ↦→ 𝑋 𝑘+1

0

1

0 𝑌 ↦→ 𝑋 𝑘+1
0
, 𝑋 ′ ↦→ 𝑋 𝑘+1
...
, 𝑋 ′ ↦→ 𝑋 𝑘+1
𝑘+1

𝑋 ↦→ 𝑋 𝑘+1

𝑘

𝑘 , 𝑋 𝑘
𝑘 −1, 𝑋 𝑘+1

Atoms produced
v(𝑋 𝑘
𝑘+1), h(𝑋 𝑘
h(𝑋 𝑘
...
h(𝑋 𝑘
c(𝑋 𝑘+1
0
h(𝑋 𝑘+1
1
...
h(𝑋 𝑘+1

0 , 𝑋 𝑘+1
0
), h(𝑋 𝑘+1
0
, 𝑋 𝑘+1
1

𝑘+1 , 𝑋 𝑘+1
𝑘+1 )

)

, 𝑋 𝑘+1
1

), c(𝑋 𝑘+1
1

)

), v(𝑋 𝑘+1
0
, 𝑋 𝑘+1
0

)

Table 1: Steepening staircase: from column to step.

monotonic, but it remains to check that it is fair. Given any trigger
tr for some 𝐺𝑖 , ˜𝜎𝑖 (tr) is a trigger for 𝐹𝑖 and thus (fairness of D)
there exists 𝑗 ∈ ℑ such that ˜𝜎 𝑗 (tr) is a trigger for 𝐹 𝑗 satisfied in
𝐹 𝑗 , and the trigger tr for 𝐺 𝑗 for which ˜𝜎 𝑗 is a retraction into 𝐹 𝑗 is
□
satisfied in 𝐺 𝑗 .

Proposition 1 (Extended version) Let D be a derivation from K.

Then:
(1) D∗ is universal for K;
(2) if D is finite, D+ is universal for K;
(3) if D is monotonic and fair, D∗ is a model of K;
(4) if D is finite and fair, D+ is a model of K;
(5) if D is fair and 𝑄 is a CQ, K |= 𝑄 iff D∗ |= 𝑄.

Proof. Let 𝑀 be an arbitrary model of K. We first prove the
existence of homomorphisms 𝐹𝑖 → 𝑀 by induction over 𝑖. The
existence of some homomorphism 𝐹0 → 𝑀 is immediate by as-
sumption. Then, if there is a homomorphism 𝜇 𝑗 from some 𝐹 𝑗 of D
to 𝑀, then there is a homomorphism 𝜇 𝑗+1 of 𝐹 𝑗+1 to 𝑀 such that
𝜇 𝑗+1 is compatible with 𝜇 𝑗 . We have 𝐹 𝑗+1 = 𝜎 𝑗+1 (𝛼 (𝐹 𝑗 , tr𝑖+1)). See
that 𝜇 𝑗 (tr𝑖+1) is a trigger for 𝑀, satisfied in 𝑀 since it is a model
of K. Then (Fact 3) there is a homomorphism 𝜇 from 𝛼 (𝐹 𝑗 , tr 𝑗+1)
to 𝑀 compatible with 𝜇 𝑗 and its restriction 𝜇 𝑗+1 to the variables of
𝜎 𝑗+1 (𝛼 (𝐹 𝑗 , tr 𝑗+1)) is a homomorphism from 𝐹 𝑗+1 to 𝑀 compatible
with 𝜇 𝑗 .
(2) Hence, 𝑀 is a model of every 𝐹𝑖 in D: each instance 𝐹𝑖 is univer-
sal and, if D is finite, then the final result D+ = 𝐹𝑘 is universal. □
(1) Now we claim that since a variable present both in 𝐹𝑖 and 𝐹 𝑗
must appear in all atomsets between 𝐹𝑖 and 𝐹 𝑗 (a consequence of
the usage of fresh variables), the pairwise compatibility of the 𝜇𝑖
between succsessive atomsets implies global compatibility of all
𝜇𝑖 . We conclude by pointing out that (cid:208)𝑖 ∈ℑ 𝜇𝑖 is a homomorphism
from D∗ to 𝑀, and thus that D∗ is universal.
□
(4) The final result D+ = 𝐹𝑘 of a finite derivation is a model of 𝐹
( ˜𝜎 𝑗
0 ◦ 𝜎0 is a homomorphism from 𝐹 to any 𝐹 𝑗 in the derivation)
and, by Definition 3, for any trigger tr for 𝐹𝑘 , there is some 𝑗 ≥ 𝑘
(thus 𝑗 = 𝑘) such that ˜𝜎𝑘
□
(3) In the case of an infinite fair derivation, we first point out that
D∗ contains 𝐹0 = 𝜎0 (𝐹 ), so it is a model of 𝐹 . Then consider any

𝑘 (tr) = tr is a satisfied trigger for 𝐹𝑘 .

trigger tr for D∗: it is also a trigger for some 𝐹𝑖 in D. By Definition 3,
there exists some 𝑗 ∈ ℑ with 𝑗 ≥ 𝑖 such that ˜𝜎 𝑗
𝑖 (tr) is a satisfied
trigger for 𝐹 𝑗 . Since D is monotonic, 𝜎 𝑗
is the identity and thus
𝑖
˜𝜎 𝑗
𝑖 (tr) = tr is satisfied in D∗.
□
(5, ⇐) Let 𝜋 be a homomorphism from 𝑄 to D∗. Since D∗ is uni-
versal (by (1)), it maps to any model 𝑀 of K. Let 𝜏𝑀 be a homo-
morphism from D∗ to 𝑀, then 𝜏𝑀 ◦ 𝜋 maps 𝑄 to 𝑀.
□
(5, ⇒) Let us now consider the fair monotonic derivation D𝑚𝑜𝑛
from Lemma 2. We now that D∗
𝑚𝑜𝑛 is a model of K, and then
if K |= 𝑄, then there is a homomorphism 𝜋 from 𝑄 to D∗
𝑚𝑜𝑛.
Since 𝜋 (𝑄) is finite, there is some atomset 𝐺𝑖 in D𝑚𝑜𝑛 such that
𝜋 (𝑄) ⊆ 𝐺𝑖 . We know there is a retract ˜𝜎𝑖 from 𝐺𝑖 to 𝐹𝑖 , so ˜𝜎𝑖 ◦ 𝜋
is a homomorphism from 𝑄 to 𝐹𝑖 and so from 𝑄 to D∗.
□

B PROOFS OF SECTION 6
We first prove the following claim (see the explanations before
Proposition 5.).

Claim. There is a sequence of rule applications from any column
𝑘 producing step 𝑆h
𝐶h
𝑘 .
Proof. Let us consider 𝐶ℎ
𝑘

1 , . . . , 𝑋 𝑘
from bottom to top. Let us apply rules as shown in Table 1. The
obtained result is indeed 𝑆ℎ
□
𝑘

with variables named (𝑋 𝑘

0 , 𝑋 𝑘

.

𝑘 ),

Proposition 5. No universal model of Kh has finite treewidth.
Proof. We call v-path (resp. h-path) in an atomset a non-empty
sequence of nulls such that, for any two consecutive nulls 𝑋𝑖 and
𝑋𝑖+1, the atomset contains the atom v(𝑋𝑖, 𝑋𝑖+1) (resp. h(𝑋𝑖, 𝑋𝑖+1)).
By analogy to graphs, the length of a path is 𝑛 − 1 if it is a sequence
of 𝑛 nulls.

Let 𝑈 be an arbitrary universal model of Kh. We first point out
that 𝐼 h and 𝑈 being both universal models, they homomorphically
map to each other. We let ℎ1 denote the homomorphism from 𝐼 h
to 𝑈 and let ℎ2 denote the homomorphism from 𝑈 to 𝐼 h. Then
ℎ = ℎ2 ◦ ℎ1 is an endomorphism on 𝐼 h, the properties of which we
will now inspect further. We make use of the following notation: for
ℎ(𝑋 𝑖
ℓ , we denote 𝑘 by ℎ𝑥 (𝑖, 𝑗) and ℓ by ℎ𝑦 (𝑖, 𝑗), that is, we

𝑗 ) = 𝑋 𝑘

Bounded Treewidth and the Infinite Core Chase

PODS ’23, June 18–23, 2023, Seattle, WA, USA

𝑗 ) = 𝑋 ℎ𝑥 (𝑖,𝑗 )

ℎ𝑦 (𝑖,𝑗 ) . We make the following observations (which

let ℎ(𝑋 𝑖
hold for all endomorphisms on 𝐼 h):
(1) ℎ𝑦 (𝑖, 0) = 0 since f holds precisely for all nulls 𝑋 𝑖
0.
(2) ℎ𝑦 (𝑖, 𝑗) = 𝑗, inductively with (1) as base case and the observa-
tion that ℎ must preserve the length of incoming v-paths rooted
in some f.

(3) ℎ𝑥 (𝑖, 𝑗) = ℎ𝑥 (𝑖, 𝑗 +1), since this is the only way for ℎ to preserve

the v-atoms.

(4) ℎ𝑥 (𝑖, 𝑗) = ℎ𝑥 (𝑖, 𝑘), via iteration of (3).
(5) ℎ𝑥 (𝑖, 𝑗) ≥ 𝑖, due to (2) and the fact that 𝑋 𝑖

𝑗 does not exist for

𝑗 > 𝑖 + 1.

(6) ℎ𝑥 (𝑖 + 1, 𝑗) = ℎ𝑥 (𝑖, 𝑗) or ℎ𝑥 (𝑖 + 1, 𝑗) = ℎ𝑥 (𝑖, 𝑗) + 1, since this is

the only way for ℎ to preserve the h-atoms.

(7) ℎ𝑦 (𝑖 + 1, 𝑗) = ℎ𝑦 (𝑖, 𝑗) since this is the only way for ℎ to preserve

the h-atoms.

(8) There are 𝑘, ℓ ∈ N such that ℎ𝑥 (𝑖, 𝑗) = 𝑖 + ℓ for all 𝑖 > 𝑘. This is

a consequence of (5) and (6).

(9) There is a 𝑘 ∈ N such that the restriction of ℎ to the 𝑋 𝑖

𝑗 with

− to ℎ(𝐼 h

−), i.e., 𝐼 h

− be 𝐼 h restricted to terms 𝑋 𝑖

𝑖 > 𝑘 is injective. Follows from (8), for the same 𝑘, and (2).
If we now let 𝐼 h

−) and ℎ2 must be an isomorphism from ℎ1 (𝐼 h
−). Therefore, 𝑡𝑤 (𝐼 h

𝑗 with 𝑖 > 𝑘, we obtain
− (cid:27) ℎ(𝐼 h
that ℎ is an isomorphism from 𝐼 h
−). Since
ℎ = ℎ2 ◦ ℎ1, this means that ℎ1 must be an isomorphism from 𝐼 h
− to
ℎ1 (𝐼 h
−) to ℎ2 (ℎ1 (𝐼 h
−)) =
ℎ(𝐼 h
−))) (*). Now,
for any given 𝑛 ∈ N with 𝑛 > 𝑘, take T𝑛×𝑛 = {𝑋 𝑖
| 𝑛 + 1 ≤ 𝑖 ≤
𝑗
2𝑛 and 0 ≤ 𝑖 ≤ 𝑛 − 1} ⊆ terms(𝐼 h). Consequently, T𝑛×𝑛 witnesses
that 𝐼 h
− contains a 𝑛 × 𝑛 grid. Yet, as 𝑛 can be chosen arbitrarily
large, 𝐼 h
− contains grids of arbitrary size and thus cannot have
finite treewidth, i.e., 𝑡𝑤 (𝐼 h
−) ∉ N (**). From these insights, we can
conclude

−)) = 𝑡𝑤 (ℎ2 (ℎ1 (𝐼 h

−) = 𝑡𝑤 (ℎ1 (𝐼 h

𝐼 h
− ⊆ 𝐼 h =⇒ ℎ1 (𝐼 h

−) ⊆ ℎ1 (𝐼 h) ⊆ 𝑈

−)) ≤ 𝑡𝑤 (𝑈 )

(*)
=⇒ 𝑡𝑤 (𝐼 h

−) ≤ 𝑡𝑤 (𝑈 )

Fact 1
=⇒ 𝑡𝑤 (ℎ1 (𝐼 h
(**)
=⇒ 𝑡𝑤 (𝑈 ) ∉ N.

□

C PROOFS OF SECTION 7
Proposition 8. The following hold:
(1) Every 𝐼 v
(2) 𝐼 v
(3) For every core chase sequence (𝐹𝑖 )𝑖 ∈N for Kv, there is an un-
: N → N such that, for every

𝑛 has a treewidth of at least ⌈𝑛/3⌉ + 1.

𝑛 is a core.

bounded monotonic function 𝑓
𝑛 ∈ N, 𝐼 v

𝑓 (𝑛) is isomorphic to a subset of 𝐹𝑛.

(4) For every core chase sequence (𝐹𝑖 )𝑖 ∈N for Kv and any 𝑚 ∈ N

exists a 𝑘 ∈ N such that tw(𝐹𝑖 ) ≥ 𝑚 for all 𝑖 ≥ 𝑘.

Proof. We show these claims consecutively.

(1) It is straightforward to check that 𝐼 v

0 is a core. To show that 𝐼 v
𝑛
is a core for every 𝑛 > 0, pick an arbitrary retraction 𝜎 of 𝐼 v
𝑛 .
Toward showing that 𝜎 is the identity, first note that it must be
column-preserving (i.e., satisfy 𝜎 (𝑋 𝑖
ℓ ′ ), since for any two
𝑋 𝑖
𝑘, 𝑋 𝑗
• they are connected by a v-path exactly if 𝑖 = 𝑗,
• if there is an h connection from the former to the latter, then

ℓ ) = 𝑋 𝑖

ℓ ∈ Δv

𝑛 hold:

𝑖 + 1 = 𝑗,

𝑘 ′, 𝑋 𝑗

ℓ ′ ) ∈ 𝐼 v
• if 𝑖 + 1 = 𝑗, then there are 𝑘′ and ℓ ′ satisfying h(𝑋 𝑖
𝑛 .
𝑘 ∈ Δv
Yet then, for every 𝑋 𝑖
𝑛, the corresponding column (the
substructure of 𝐼 v
𝑛 induced by all 𝑋 𝑗
ℓ with 𝑗 = 𝑖) has an retrac-
tion obtained by restricting 𝜎 accordingly. Yet, each of these
column-wise retractions must map the unique elements carry-
ing f and c to themselves, which also forces all other elements
(on the intermediate directed v-path) to be identically mapped.
Consequently, every row-wise retraction must be the identity
function. Yet then, 𝜎 as a whole must be the identity as well.
(2) This claim is a consequence of Fact 2, since, for every 𝑛, the
𝑘 with ⌊2𝑛/3⌋ + 1 ≤ 𝑖 ≤ 𝑛 + 1 and 𝑛 ≤ 𝑘 ≤ ⌈4𝑛/3⌉
𝑛 contains a (⌊𝑛/3⌋ + 1) × (⌊𝑛/3⌋ + 1)-grid.

elements 𝑋 𝑖
witness that 𝐼 v

𝑗 ) = 𝑋 𝑖

2⌊ 𝑗/2⌋, 𝑋 𝑖

𝑗+1) ∈ 𝐼 v

(3) Without loss of generality, we assume the considered core chase
employs the same naming scheme as 𝐼 v. Therefore, any inter-
mediate atomset of the considered chase can be described by
a subset of 𝐼 v. We first observe that 𝐼 v
0 = 𝐹 v, thus the claim
is satisfied for 𝑛 = 0 once we set 𝑓 (0) = 0. We proceed itera-
tively for larger 𝑛. For any subsequent 𝑛, we can assume that
𝐹𝑛−1 contains some 𝐼 v
𝑚. Therefore, the only interesting case is
if, upon producing 𝐹𝑛, nulls of 𝐹𝑛−1 are removed through the
non-trivial retraction 𝜎𝑛. Among the nulls removed, let 𝑋 𝑖
𝑗 be
the one with maximal 𝑗 and (among all these) the one with
minimal 𝑖. By construction (observing 𝐼 v), removal of nulls will
always simultaneously affect all nulls in a row, leaving behind
only those of the form 𝑋 𝑘
2𝑘 . Therefore, we obtain 𝑖 = ⌊ 𝑗/2⌋ + 1.
Also, by maximality of 𝑗 and the fact that there are no row-
decreasing v-atoms, we know that 𝜎𝑛 (𝑋 𝑖
𝑗+1 (note that
retractions must be column-preserving, as argued before). Then,
for 𝜎𝑛 to be a retraction, we require h(𝑋 𝑖 −1
𝑛−1.
Yet, as row-increasing h-edges can only be the consequence of a
(potentially iterated) prior application of 𝑅v
7 , the atom f(𝑋 𝑖
𝑗+1)
must occur in some atomset preceding 𝐼 v
𝑛 . Yet, this can only be
the consequence of the iterated application of 𝑅v
7 propagating f
from “right to left”, starting from f(𝑋 𝑗+2
𝑗+1 ). The latter
atom must, in turn have been created through iterated appli-
5 , propagating d “top-down” starting from d(𝑋 𝑗+2
cation of 𝑅v
2𝑗+4)
which must have been created through application of 𝑅v
4 to
2𝑗+4). Yet, the only way to produce the latter is through 𝑅v
c(𝑋 𝑗+2
1
following iterated application of 𝑅v
2 preceded by an application
of 𝑅v
), and v(𝑋 𝑗+1
𝑗+1 ). This argument
can then be repeated for columns further left, leading to the
insight that removal of 𝑋 𝑖
𝑗+1 must
have previously existed in the derivation. Among those, the
facts involving nulls 𝑋 𝑘
ℓ with ℓ > 𝑗, cannot have been removed
by our maximality assumption. The remaining facts of 𝐼 v
𝑗+1 are
indefinitely exempt from removal because the participating
nulls are column-wise unique wrt carrying c. We can therefore
conclude that upon removal of 𝑋 𝑖
𝑗 toward the creation of 𝐹𝑛,
the latter must contain 𝐼 v
Finally, we observe that, as an indirect consequence of fairness,
every 𝑋 𝑖
𝑗 with 𝑗 ≠ 2𝑖 will be removed in some derivation step,
leading to the consequence that ever growing elements 𝐼 v
𝑗+1 will
come into operation.

𝑗 requires that all facts from 𝐼 v

𝑗+1 ), d(𝑋 𝑗+2

3 to d(𝑋 𝑗+1

), f(𝑋 𝑗+1

, 𝑋 𝑗+1

𝑗+1.

𝑗

𝑗

𝑗

(4) This claim is a direct consequence of Item 2 and Item 3, given
□

monotonicity of treewidth (Fact 1).

PODS ’23, June 18–23, 2023, Seattle, WA, USA

Jean-François Baget, Marie-Laure Mugnier, and Sebastian Rudolph

𝜎0

𝐹

𝐹0

𝜌0

𝐺0

𝐴1
𝜌0

𝐴′
1

𝜏1

𝜎1

𝜎 ′
1

𝜏1

𝜌0
𝐹 ′
1
𝜌𝜎 ′
1

𝐹1

𝜌1

𝐺1

𝐴2
𝜌1

𝐴′
2

𝜏2

𝜎2

𝜎 ′
2

𝜏2

𝜌1
𝐹 ′
2
𝜌𝜎 ′
2

𝐹2

𝜌2

𝐺2

𝐴2
𝜌2

𝐴′
3

𝜏3

𝜎3

𝜎 ′
3

𝜏3

𝜌2
𝐹 ′
3
𝜌𝜎 ′
3

𝐹2

𝜌3

𝐺3

Figure 6: Depiction of the inductive definition of the robust sequence (Definition 15). Also useful to follow proof of Proposition 11.

D PROOFS OF SECTION 8
Lemma 1. Let (𝐺𝑖 )𝑖 ∈ℑ be the robust sequence associated with a deriva-
tion D. If 𝐴 is a finite subset of D ⊛
, then there exists some 𝑘 ∈ ℑ
such that, for every 𝑟 ≥ 𝑘 ⊆ ℑ, 𝐴 ⊆ 𝐺𝑟 .

Proof. We first prove (i) for every 𝑖 > 0 ∈ ℑ, ¯𝜏 (𝐺𝑖 −1) ⊆
¯𝜏 (𝐺𝑖 ). Indeed, since 𝜏𝑖 is a homomorphism from 𝐺𝑖 −1 to 𝐺𝑖 , then
𝜏𝑖 (𝐺𝑖 −1) ⊆ 𝐺𝑖 and thus for any 𝑗 > 𝑖 ∈ ℑ, ¯𝜏 𝑗
𝑖 (𝐺𝑖 ),
meaning ¯𝜏 (𝐺𝑖 −1) ⊆ ¯𝜏 (𝐺𝑖 ).

𝑖 (𝜏𝑖 (𝐺 𝑗 −1)) ⊆ ¯𝜏 𝑗

Then we prove (ii) for every ¯𝜏 (𝐺 𝑗 ), there exists some 𝑘 ≥ 𝑗 such
that for every 𝑟 ≥ 𝑘, ¯𝜏 (𝐺 𝑗 ) ⊆ 𝐺𝑟 . For every variable 𝑋 in 𝐺 𝑗 , there
is some 𝑘𝑋 ∈ ℑ such that ¯𝜏 (𝑋 ) = 𝜏𝑘𝑋
(𝑋 ) is stable in all atomsets
𝑗
(Proposition 10). If we take 𝑘 = max𝑋 ∈vars (𝐺 𝑗 )𝑘𝑋 , then
after 𝐺𝑘𝑋
for every 𝑟 ≥ 𝑘, 𝜏𝑟
𝑗 = 𝜏𝑟
𝑗 = ¯𝜏 is a homomorphism from 𝐺 𝑗 to
𝐺𝑟 , and thus ¯𝜏 (𝐺 𝑗 ) ⊆ 𝐺𝑟 .

𝑘 ◦ 𝜏𝑘

Finally, since 𝐴 is finite and the successive ¯𝜏 (𝐺𝑖 ) form a mono-
tonic sequence (see (i)), there exists 𝑗 ∈ ℑ such that 𝐴 ⊆ ¯𝜏 (𝐺 𝑗 ).
Then (ii) there exists 𝑘 ≥ 𝑗 such that for every 𝑟 ≥ 𝑘, ¯𝜏 (𝐺 𝑗 ) ⊆ 𝐺𝑟
□
and thus 𝐴 ⊆ 𝐺𝑟 .

E PROOFS OF SECTION 9
Theorem 1. CQ entailment is decidable for the class of KBs having a
recurringly treewidth-bounded core chase sequence.

Proof. Let ℭ be the class of KBs having a recurringly treewidth-
bounded core chase sequence. The proof closely follows arguments
from previous work [3, 7]. An algorithm deciding K |= 𝑄 for a
given K ∈ ℭ and conjunctive query 𝑄 can be devised from two
semi-decision procedures (which, when executed in parallel give
rise to a decision algorithm): one guaranteed to detect K |= 𝑄
after finite time and another detecting K ̸|= 𝑄. For the former, we
can evoke the fact that thanks to the completeness of first-order
logic [12], the consequences of a first-order theory are recursively
enumerable. So, the first part of the algorithm can just enumerate
the consequences of K and terminate answering “yes” as soon as 𝑄
is found among the consequences. It remains to be shown that there
is a semi-decision procedure detecting K ̸|= 𝑄. By assumption, K
has a finitely universal model 𝐼 with 𝑡𝑤 (𝐼 ) ∈ N. From 𝐼 being finitely
universal for K and K ̸|= 𝑄, we can conclude 𝐼 ̸|= 𝑄. But then we
obtain 𝐼 |= 𝐹 ∧ ((cid:211) Σ) ∧ (¬𝑄) (assuming that 𝐹 and 𝑄 are represented
as first-order sentences and Σ as a set of first-order sentences). This
means, whenever K ̸|= 𝑄, then there exists some 𝑘 (namely 𝑡𝑤 (𝐼 ))
such that the first-order sentence 𝐹 ∧((cid:211) Σ)∧(¬𝑄) is satisfiable over

the class of structures of treewidth 𝑘. Fortunately, as previously
observed [3, 7], satisfiability of monadic second-order logic – and
thus also of first-order logic – over classes of structures with a
treewidth bounded by a given 𝑘 is decidable. This allows to design
a semi-decision procedure that increases 𝑘 stepwise and in each
step applies the decision procedure that checks if 𝐹 ∧ ((cid:211) Σ) ∧ (¬𝑄)
has a model of treewidth 𝑘. If so, the procedure terminates with the
output “no”, since we have shown that 𝑄 cannot be a consequence
of K. If not, we increment 𝑘 and repeat. Clearly, thanks to the
above assumption, this semi-decision procedure will output “no”
□
and terminate exactly if K ̸|= 𝑄.

Proposition 13. CQ entailment is decidable for any ruleset that is
core-bts. Moreover, core-bts subsumes both finite expansion sets (fes)
and bounded treewidth sets (bts), which are mutually incomparable.

Proof. Decidability follows from Theorem 2. We sucessively

prove the following items:
• fes and bts are incomparable,
• fes is subsumed by core-bts.
• bts is subsumed by core-bts.

For the first bullet point, note that the singleton ruleset {r(𝑋, 𝑌 ) →
∃𝑍 .r(𝑌, 𝑍 )} is bts but not fes, whereas the singleton ruleset {r(𝑋, 𝑌 )∧
r(𝑌, 𝑍 ) → ∃𝑉 .r(𝑋, 𝑋 ) ∧ r(𝑋, 𝑍 ) ∧ r(𝑍, 𝑉 )} is fes but not bts.

For the second bullet point, recall that finite extension sets guar-
antee core-chase termination. Yet, for any finite sequence of finite
structures one can find a uniform finite bound on the treewidth, it
suffices to pick max𝑖 ∈ℑ |T (𝐹𝑖 )|.

𝑖 )𝑖 ∈ℑ as follows: Let 𝜎 ′

𝑖 where 𝜎 ′
𝑖+1 (𝐹𝑖+1) = 𝐹 ′

0 (𝐹0) = 𝜎 ′
𝑖 , and 𝜎 ′
𝑖+1 such that 𝜎 ′

For the third bullet point, we observe that any treewidth-bounded
restricted chase sequence (𝐹𝑖 )𝑖 ∈ℑ can be transformed into a core-
chase sequence (𝐹 ′
0 be an endomorphism
turning 𝐹0 into a core and let 𝐹 ′
0 = 𝜎 ′
0 (𝐹 ). From this
starting point, we can always use 𝐹𝑖 , 𝐹 ′
𝑖 (𝐹𝑖 ) = 𝐹 ′
𝑖
is a core, to define 𝜎 ′
𝑖+1 and 𝐹 ′
𝑖+1 is a
𝜎𝑖+1 be an
core as follows: assuming 𝐹𝑖+1 = 𝛼 (𝐹𝑖, (𝑅, 𝜋)), we let
(cid:101)
endomorphism of 𝛼 (𝜎 ′
𝑖 (𝐹𝑖 ), (𝑅, 𝜎 ′
𝑖 ◦ 𝜋)) producing a core, which we
choose as 𝐹 ′
𝑖+1 is also a core of 𝐹𝑖+1 = 𝛼 (𝐹𝑖, (𝑅, 𝜋))
witnessed by the endomorphism 𝜎 ′
𝑖 )𝑖 ∈ℑ
is indeed a core chase sequence, except for some elements being
repeated, which can be removed. Now given that there exists a
bound 𝑏 greater than the treewidth of each element of (𝐹𝑖 )𝑖 ∈ℑ, the
same must hold for (𝐹 ′
𝑖 )𝑖 ∈ℑ, given that 𝐹 ′
𝑖 ⊆ 𝐹𝑖 for all 𝑖 ∈ ℑ. Thus
(𝐹 ′
𝑖 )𝑖 ∈ℑ (and any pruned subsequence of it) is uniformly (and hence
□
also recurrently) treewidth-bounded.

𝑖+1. Clearly then 𝐹 ′

𝑖 . Note that (𝐹 ′

𝜎𝑖+1 ◦ 𝜎 ′

𝑖+1 = (cid:101)

