Linear Programs with Conjunctive Queries
Florent Capelli, Nicolas Crosetti, Joachim Niehren, Jan Ramon

To cite this version:

Florent Capelli, Nicolas Crosetti, Joachim Niehren, Jan Ramon. Linear Programs with Conjunctive
ICDT 2022 - 25th International Conference on Database Theory, Mar 2022, Edinburgh,
Queries.
United Kingdom. ￿hal-01981553￿

HAL Id: hal-01981553

https://hal.science/hal-01981553

Submitted on 21 Sep 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

Linear Programs with Conjunctive Queries

Florent Capelli, Nicolas Crosetti, Joachim Niehren, Jan Ramon
Univ. Lille, Inria, CNRS, UMR 9189 - CRIStAL, F-59000 Lille, France

Abstract

In this paper, we study the problem of optimizing a linear program whose variables are answers
to a conjunctive query. For this we propose the language LP(CQ) for specifying linear programs
whose constraints and objective functions depend on the answer sets of conjunctive queries. We
contribute an eﬃcient algorithm for solving programs in a fragment of LP(CQ). The naive approach
constructs a linear program having as many variables as elements in the answer set of the queries.
Our approach constructs a linear program having the same optimal value but fewer variables. This
is done by exploiting the structure of the conjunctive queries using hypertree decompositions of
small width to group elements of the answer set together. We illustrate the various applications
of LP(CQ) programs on three examples: optimizing deliveries of resources, minimizing noise for
diﬀerential privacy, and computing the s-measure of patterns in graphs as needed for data mining.

2012 ACM Subject Classiﬁcation Computer Science, Logic, Databases.

Keywords and phrases Database queries, linear programming, hypergraph decomposition.

Digital Object Identiﬁer 10.4230/LIPIcs...

1

Introduction

When modeling optimization problems it often seems natural to separate the logical con-
straints from the relational data. This holds for linear programming with AMPL [7] and
for constraint programming in MiniZinc [17]. It was also noticed in the context of database
research, when using integer linear programming for ﬁnding optimal database repairs as
proposed by Kolaitis, Pema and Tan [14], or when using linear optimization to explain the
result of a database query to the user as proposed by Meliou and Suciu [16]. Moreover, tools
like SolveDB [21] have been developed to better integrate mixed integer programming and
thus linear programming into relational databases.

We also ﬁnd it natural to deﬁne the relational data of linear optimization problems
by database queries. For this reason, we propose the language of linear programs with
conjunctive queries LP(CQ) in the present paper. The objective is to become able to specify
weightings of answer sets of database queries, that optimize a linear objective function subject
to linear constraints. The optimal weightings of LP(CQ) programs can be computed in a
naive manner, by ﬁrst answering the database queries, and then solving a linear program
parametrized by the answer sets. We then approach the question – to our knowledge for the
ﬁrst time – of whether this can be done with lower complexity for subclasses of conjunctive
queries such as the class of acyclic conjunctive queries.

As our main contribution we present a more eﬃcient algorithm for computing the optimal
value of a program in the fragment of so-called projecting LP(CQ) programs for which we
also bound the hypertree width of the queries. The particular case of width 1 covers the class
of acyclic conjunctive queries. By using hypertree decompositions, our algorithm is based on
a factorized interpretation of any projecting LP(CQ) program over a database to a linear
program without conjunctive queries. The factorized interpretation uses other linear program
variables, that represent sums of the linear program variables in the naive interpretation.
The number of linear program variables in the factorized interpretation depends only on the
widths of the hypertree decompositions of the queries in the LP(CQ) program, rather than
on the number of query variables. In this manner, our more eﬃcient algorithm can decrease

© Author: Please provide a copyright holder;
licensed under Creative Commons License CC-BY 4.0

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

XX:2

Linear Programs with Conjunctive Queries

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

67

68

69

70

71

72

73

74

75

76

77

78

79

80

81

82

83

84

85

86

87

88

89

the data complexity, i.e., the degree of the polynomial in the upper bound of the run time of
the naive algorithm. With respect to the combined complexity, the special case of projecting
LP(CQ) programs with bounded quantiﬁer depth becomes tractable for acyclic conjunctive
queries, while it is NP-complete in general.

We prove the correctness of the factorized interpretation with respect to the naive
interpretation. For this we have to show a correspondence between weightings of answer sets
on the naive interpretation, and weightings of answer sets on the factorized interpretation.
This correspondence can be seen as an independent contribution as it shows that one can
reconstruct a relevant weighting of the answer set of a quantiﬁer free conjunctive query by
only knowing the value of the projected weighting on the bags of the tree decomposition.
Conjunctive queries with existential quantiﬁer are dealt with by showing that one can ﬁnd
an equivalent projecting LP(CQ) program using only quantiﬁer free conjunctive queries.

1.1 Applications

A wide range of applications of linear programs can beneﬁt from conjunctive queries.

Resource Delivery Optimization.
We consider a situation in logistics where a
company received orders for speciﬁc quantities of resource objects. The objects must be
produced at a factory then transported to a warehouse before being delivered to the buyer.
The objective is to fulﬁll every order while minimizing the overall delivery costs and respecting
the production capacities of the factories as well as the storing capacities of the warehouses.
Let F be the set of factories, O the set of objects, W the set of warehouses and B the set
of buyers. We consider a database D with elements in the domain D = F ] O ] W ] B ] R+.
The elements d ∈ D encoding a positive real number can be decoded back by applying the
database’s functions numD, yielding the positive real number numD(d) ∈ R+. The database
D has four tables. The ﬁrst table prod D ⊆ F × O × R+ contains triples (f, o, q) stating that
the factory f can produce up to q units of object o. The second table order D : B × O × R+
contains triples (b, o, q) stating that the buyer b orders q units of object o. The third table
storeD ⊆ W × R+ contains pairs (w, l) stating that the warehouse w has a storing limit of
l. The fourth table routeD : (F × W × R+) ∪ (W × B × R+) contains triples (f, w, c) stating
that the transport from factory f to warehouse w costs c, and triples (w, b, c) stating that
the transport from warehouse w to buyer b costs c. The query:

dlr(f, w, b, o) = ∃q.∃q0.∃c∃c0. prod(f, o, q) ∧ order(b, o, q0) ∧ route(f, w, c) ∧ route(w, b, c0)

selects from the database D all tuples (f, w, b, o) such that the factory f can produce some
objects o to be delivered to buyer b through the warehouse w. Let Q = dlr(f 0, w0, b0, o0). The
questions is to determine for each of these possible deliveries the quantity of the object that
should actually be sent. These quantities are modelled by the unknown weights θα
Q of the query
answers α ∈ sol D(Q). For any factory f and warehouse w the sum P
=f ) θα
Q
is described by the expression weight(f 0,w0,b0,o0):f 0

=w(Q) when interpreted over D.

α∈solD(Q∧w0

.
=w∧f 0

.
=f ∧w0

.

.

We use the LP(CQ) program in Figure 1 to describe the optimal weights that minimize
the overall delivery costs. The weights depend on the interpretation of the program over the
database, since D speciﬁes the production capacities of the factories, the stocking limits of
the warehouses, etc. The program has the following constraints:
-
-
-

for each (f, o, q) ∈ prod D the overall quantity of object o produced by f is at most q.
for each (b, o, q) ∈ order D the overall quantity of objects o delivered to b is at least q.
for each (w, l) ∈ storeD the overall quantity of objects stored in w is at most l.

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:3

minimize
P
+ P
subject to

(f,w,c):route(f,w,c) num(c) weight(f 0,w0,b0,o0):f 0
(w,b,c):route(w,b,c) num(c) weight(f 0,w0,b0,o0):w0

.
=f ∧w0

.
=w∧b0

.

=w(Q)
=b(Q)

.

∀(f, o, q):prod(f, o, q). weight(f 0,w0,b0,o0):f 0
∀(b, o, q):order(b, o, q). weight(f 0,w0,b0,o0):b0
∀(w, l):store(w, l). weight(f 0,w0,b0,o0):w0

.

.
=f ∧o0
.
=b∧o0

.

=o(Q) ≤ num(q)
=o(Q) ≥ num(q)

.

=w(Q) ≤ num(l)

Figure 1 A LP(CQ) program for the resource delivery optimization where Q = dlr(f 0, w0, b0, o0).

90

91

92

93

94

95

96

97

98

99

100

101

102

103

104

105

106

107

108

109

110

111

112

113

114

115

116

117

118

119

120

121

By answering the query Q on the database D and introducing a linear program variable
θα
Q for each of the query answers α, we can interpret the LP(CQ) program in Figure 1 as
a linear program. However the number of answers of Q and thus the number of variables
in this program could be cubic in the size of the database, which quickly grows too big.
Our factorized interpretation for the projecting LP(CQ) program in Figure 1 produces a
linear program that only has a quadratic number of variables, since query Q has a hypertree
decomposition of width 2 as well as the whole LP(CQ) program.

Minimizing Noise for ε-Diﬀerential Privacy. The strategy of diﬀerential privacy is to
add noise to the relational data before publication. Roughly speaking, the general objective
of ε-diﬀerential privacy [5] is to add as little noise as possible, without disclosing more
than an ε amount of information. We illustrate this with the example of a set of hospitals
which publish medical studies aggregating results of tests on patients, which are to be kept
conﬁdential. We consider the problem of how to compute the optimal amount of noise to
be added to each separate piece of sensitive information (in terms of total utility of the
studies) while guaranteeing ε-diﬀerential privacy. We show that this question can be solved
(approximately) by computing the optimal solution of a projecting program in LP(CQ)
with a single conjunctive query that is acyclic, i.e., of hypertree with 1. While the naive
interpretation yields a linear program with a quadratic number of variables in the size of
the database, the factorized interpretation requires only a linear number. The example is
worked out in Appendix A.

Computing the s-Measure for Graph Pattern Matching. A matching of a subgraph
pattern in a graph is a graph homomorphism from the pattern to the graph. The s-measure
of Wang et al.
[23] is used in data mining to measure the frequency of matchings of subgraph
patterns, while accounting for overlaps of diﬀerent matchings. The idea is to ﬁnd a maximal
weighting for the set of matchings, such that for any node of the subgraph pattern, the set of
matchings mapping it on the same graph node must have a overall weight less then 1. This
optimization problem can be expressed by a projecting LP(CQ) program over a database
storing the graph. The conjunctive query of this program expresses the matching of the
subgraph pattern. The hypertree width of this conjunctive query is bounded by the hypertree
width of the subgraph pattern. Our factorized interpretation therefore reduces the size of
the linear program for subgraph patterns with small hypertree width. More information on
the LP(CQ) program can be found in Appendix B.

XX:4

Linear Programs with Conjunctive Queries

122

123

124

125

126

127

128

129

130

131

132

133

134

135

136

137

138

139

140

141

142

143

144

145

146

147

148

149

150

151

152

153

154

155

156

157

158

159

160

161

162

163

164

165

1.2 Related Work

Our result builds on well-known techniques using dynamic programming on tree decompos-
itions of the hypergraph of conjunctive queries. This techniques were ﬁrst introduced by
Yannkakis [24] who observed that so-called acyclic conjunctive queries could be answered
in linear time using dynamic programming on a tree whose nodes are in correspondence
with the atoms of the query. Generalizations have followed in two directions: on the one
hand, generalizations of acyclicity such as notions of hypertree width [9, 10, 11] have been
introduced and on the other hand enumeration and aggregation problems have been shown
to be tractable on these families of queries such as ﬁnding the size of the answer set [19]
or enumerating it with small delay [1]. More recently, these tractability results have been
explained by the mean of factorized databases [18], observing that the answer set of bounded
width conjunctive queries could be succinctly represented by circuits enjoying interesting
syntactic properties allowing to eﬃciently solve numerous aggregation problems on it in
polynomial time in the size of the representation. While the complexity of several aggregation
problems in databases have been studied on such structures [2, 20], our result is, to the best
of our knowledge, the ﬁrst one to exploit the structure of conjunctive queries to solve linear
programs more eﬃciently. While our result could be made to work on factorized representa-
tions of queries answer sets, we choose to directly work on tree decompositions because the
semantic of the query is clearer in its conjunctive form than its factorized representation.
Since one of our contribution is to oﬀer a language to describe linear programs parametrized
by the answer set of queries, this aspect is important to write intelligible linear programs.

Organization of the paper. Section 2 contains the necessary deﬁnitions to understand
the paper. Section 3 presents the language LP(CQ) of linear programs parametrized by
conjunctive queries and gives its semantics. Section 4 deﬁnes a fragment of LP(CQ) for
which we propose a more eﬃcient algorithm. Finally, Section 5 presents encouraging practical
results on solving the delivery optimization problem using this algorithm. Due to space limit,
most proofs and full details on applications to diﬀerential privacy and s-measure computation
have been moved to the appendix.

2

Preliminaries

Sets, Functions and Relations. Let B = {0, 1} be the set of Booleans, N the set of natural
numbers including 0, R+ be the set of positive reals subsuming N, and R the set of all reals.
Given any set S and n ∈ N we denote by Sn the set all n-tuples over S and by S∗ = ∪n∈NSn

the set of all words over S. A weighting on S is a (total) function f : S → R+.

Given a set of (total) functions A ⊆ DS = {f | f : S → D} and a subset S0 ⊆ S, we
deﬁne the set of restrictions A|S0 = {f|S0 | f ∈ A}. For any binary relation R ⊆ S × S,
we denote its transitive closure by R+ ⊆ S × S and the reﬂexive transitive closure by
R∗ = R+ ∪ {(s, s) | s ∈ S}.

Variable assignments. We ﬁx a countably inﬁnite set of (query) variables X . For any
set D of database elements, an assignment of (query) variables to database elements is a
function α : X → D that maps elements of a ﬁnite subset of variables X ⊆ X to values of
D. For any two sets of variable assignments A1 ⊆ DX1 and A2 ⊆ DX2 we deﬁne their join
A1 ./ A2 = {α1 ∪ α2 | α1 ∈ A1, α2 ∈ A2, α1|I = α2|I } where I = X1 ∩ X2.

We also use a few vector notations. Given a vector of variables x = (x1, . . . , xn) ∈ X n we
denote by set(x) = {x1, . . . , xn} the set of the elements of x. For any variable assignment

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:5

Linear sums
Linear constraints C, C 0 ∈ Lc ::= S ≤ S0 | C ∧ C 0 | true
Linear programs

S, S0 ∈ Sum ::= c | ξ | cS | S + S0

::= maximize S subject to C

L ∈ Lp

Figure 2 The set of linear programs Lp with variables ξ ∈ Ξ and constants c ∈ R.

Expressions
Conjunctive queries Q, Q0 ∈ C qΣ

E1, . . . , En ∈ Ex C

::= x | a
::= E1

.=E2 | r(E1, . . . , En) | Q ∧ Q0 | ∃x.Q | true

Figure 3 The set of conjunctive queries C qΣ with schema Σ = ((R(n))n∈N, C) where x ∈ X ,

a ∈ C, and r ∈ R(n).

α : X → D with set(x) ⊆ X we denote the application of the assignment α on x by
α(x) = (α(x1), . . . , α(xn)).

Linear programs. Let Ξ be a set of linear program variables. In Figure 2, we recall the
deﬁnition of the sets of linear sums Sum, linear constraints Lc, and linear programs Lp
with variables in Ξ. We consider the usual linear equations S .=S0 as syntactic sugar for the
constraints S ≤ S0 ∧S0 ≤ S. For any linear program L = maximize S subject to C we call
S the objective function of L and C the constraint of L. Note that minimize S subject to C
can be expressed by maximize − 1 S subject to C up to negation.

The formal semantics of linear programs is recalled in Figure 10. Since we will only be
interested in variables for positive real numbers – and do not want to impose positivity
constraints all over – we restrict variables of linear programs to always be positive real
numbers. For any weightings ω : Ξ → R+, the value of a sum S ∈ Sum is the real number
ω ∈ B. The optimal
ω ∈ R, and the value of a constraint C ∈ Lc is the truth value
S
(cid:74)
(cid:75)
∈ R of a linear program L with objective function S and constraint C is
solution
ω = 1}. It is well-known that the optimal solution of a
S
L
(cid:74)
(cid:75)
linear program can be computed in polynomial time [12].

L
(cid:75)
= max{
(cid:74)

ω | ω : Ξ → R+,

C

C

(cid:75)

(cid:74)

(cid:75)

(cid:74)

(cid:75)

(cid:74)

Rooted trees. A digraph is a pair (V, E) with node set V and edge sets E ⊆ V × V. A
digraph is acyclic if there is no v ∈ V for which (v, v) ∈ E +. For any node u ∈ V, we denote
by ↓ u = {v ∈ V | (u, v) ∈ E ∗} the set of nodes in V reachable over some downwards path
from u, and by ↑u = {v ∈ V | (v, u) ∈ E ∗} the set of nodes that are in the context of or equal
to u. A rooted tree is an acyclic digraph where (u, v), (u0, v) ∈ E implies u = u0, and there
exists a node r ∈ V such that V = ↓ (r). In this case, r is unique and called the root of the
tree. Observe that in this tree, the paths are oriented from the root to the leaves of the tree.

Relational Databases. A database schema is a pair Σ = (R, C) where C a ﬁnite set of
constants ranged over by a, b and R = ∪n∈NR(n) is a ﬁnite set of relation symbols. The
elements r ∈ R(n) are called relation symbols of arity n ∈ N.

A database D ∈ dbΣ is a tuple D = (Σ, D, ·D), where Σ is a schema, D a ﬁnite set of
database elements, and rD ⊆ Dn a relation for any relation symbol r ∈ R(n) and aD ∈ D a
database element for any constant a ∈ C. We also deﬁne the database’s domain dom(D) = D.
A database with real numbers is a tuple D = (Σ, D, ·D, numD) such that D = (Σ, D, ·D) is

a relational database and numD a partial function from D to R.

Conjunctive Queries. In Figure 3 we recall the notion of conjunctive queries on relational
databases. An expression E ∈ Ex C is either a (query) variable x ∈ X or a constant a ∈ C.

166

167

168

169

170

171

172

173

174

175

176

177

178

179

180

181

182

183

184

185

186

187

188

189

190

191

192

193

194

195

196

197

198

XX:6

Linear Programs with Conjunctive Queries

.=E2, atoms r(E1, . . . , En),
The set of conjunctive queries Q ∈ C qΣ is built from equations E1
the logical operators of conjunction Q ∧ Q0 and existential quantiﬁcation ∃x.Q. Given a
vector x = (x1, . . . , xn) ∈ X n and a query Q, we write ∃x.Q instead of ∃x1. . . . .∃xn.Q.

The set of free variables fv(Q) ⊆ X are those variables that occur in Q outside the scope
of an existential quantiﬁer. A conjunctive query Q is said to be quantiﬁer free if it does not
contain any existential quantiﬁer.

For any conjunctive query Q ∈ C qΣ, set X ⊇ fv(Q) and database D ∈ dbΣ we deﬁne
X (Q) in Figure 11. It contains all those assignments α : X → dom(D) for
fv(Q)(Q). Observe that

the answer set sol D
which Q becomes true on D. We also write sol D(Q) instead of sol D
sol D(∃x.Q) = sol D(Q)|fv(Q)\set(x).
Hypertree Decompositions. Hypertree decompositions of conjunctive queries are a
way of laying out the structure of a conjunctive query in a tree. It allows to solve many
aggregation problems (such as checking the existence of a solution, counting or enumerating
the solutions etc.) on quantiﬁer free conjunctive queries in polynomial time where the degree
of the polynomial is given by the width of the decomposition.

(cid:73) Deﬁnition 1. Let X ⊆ X be a ﬁnite set of variables. A decomposition tree T of X is a
tuple (V, E, B) such that:
-
-
-
- each variable of X appears in some bag, that is S

(V, E) is a ﬁnite directed rooted tree with edges from the root to the leaves,
the bag function B : V → 2X maps nodes to subsets of variables in X,
for all x ∈ X the subset of nodes {u ∈ V | x ∈ B(u)} is connected in the tree (V, E),

u∈V B(u) = X.

Now a hypertree decomposition of a quantiﬁer free conjunctive query is a decomposition

tree where the variables of each atom of the query is covered by at least one bag:
(cid:73) Deﬁnition 2 (Hypertree width of quantiﬁer free conjunctive queries). Let Q ∈ C qΣ be a
quantiﬁer free conjunctive query. A generalized hypertree decomposition of Q is a decompos-
ition tree T = (V, E, B) of fv(Q) such that for each atom r(x) of Q there is a vertex u ∈ V
such that set(x) ⊆ B(u). The width of T with respect to Q is the minimal number k such that
every bag of T can be covered by the variables of k atoms of Q. The generalized hypertree
width of a query Q is the minimal width of a tree decomposition of Q.

We call a conjunctive query α-acyclic if it has general hypertree width 1. The query
r(x, y) ∧ r(y, z) has the generalized hypertree decomposition (V, E, B) with V = {1, 2, 3},
E = {(1, 2), (1, 3)}, and B = [1/{x}, 2/{x, y}, 3/{y, z}] of width 1, so it is α-acyclic.

Many problems can be solved eﬃciently on conjunctive queries having a small hypertree

width. We will mainly be interested in the problem of eﬃciently computing sol D(Q).
(cid:73) Lemma 3 (Folklore). Given a tree decomposition T = (V, E, B) of a quantiﬁer free
conjunctive query Q ∈ C qΣ of width k and a database D ∈ dbΣ, one can compute the
collection of bag projections (sol D(Q)|B(u))u∈V in time O((|D|k log(|D|)) · |T |).

Lemma 3 is folklore and can be proven by computing the semi-join of every bag in a
subtree in a bottom-up fashion, as it is done in [15, Theorem 6.25]. It gives a superset Su of
sol D(Q)|B(u) for every u. Then, with a second top-down phase, one can remove tuples from
Su that cannot be extended to a solution of sol D(Q).

Note that if Q contains n atoms, sol D(Q) may be of size O(|D|n) whereas (sol D(Q)|B(u))u∈V ,
that has size O(|D|k · |T |) where k is the width of T . In the particular case of α-acyclic
conjunctive queries, where n = 1, the overall size of the projections is linear. It gives a
succinct way of describing the set of solutions of Q that we exploit in this paper.

Parts of our result will be easier to describe on so-called normalized decomposition trees:

199

200

201

202

203

204

205

206

207

208

209

210

211

212

213

214

215

216

217

218

219

220

221

222

223

224

225

226

227

228

229

230

231

232

233

234

235

236

237

238

239

240

241

242

243

244

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:7

Constant numbers N ∈ NumC
Linear sums
Linear constraints
Linear programs

S, S0 ∈ SumΣ ::= weightx:Q0(Q) | P
C, C 0 ∈ LcΣ
L ∈ LpΣ

::= S ≤ S0 | C ∧ C 0 | true | ∀x:Q.C
::= maximize S subject to C

::= c | num(E)

x:Q S | N S | S + S0 | N

where fv(S) = fv(C) = ∅.

Figure 4 LP(CQ) programs L ∈ LpΣ where c ∈ R, E ∈ Ex C, x ∈ X ∗ and Q, Q0 ∈ C qΣ.

245

246

247

248

249

250

251

252

253

254

255

256

257

258

259

260

261

262

263

264

265

266

267

268

269

270

271

272

273

274

275

276

(cid:73) Deﬁnition 4. Let T = (V, E, B) be a decomposition tree. We call a node u ∈ V of T :
- an extend node if it has a single child u0 and B(u) = B(u0) ∪ {x} for some x ∈ X \ B(u0),
- a project node if it has a single child u0 and B(u) = B(u0) \ {x} for some x ∈ X \ B(u),
- a join node if it has k ≥ 1 children u1, ..., uk with B(u) = B(u1) = ... = B(uk).
We call T normalized if all its nodes in V are either extend nodes, project nodes, join nodes,
or leaves.1

It is well-known that tree decompositions can always be normalized without changing the

width. Thus normalization does not change the asymptotic complexity of the algorithms.

(cid:73) Lemma 5 (Lemma of 13.1.2 of [13]). For every tree decomposition of T = (V, E, B) of
Q of width k, there exists a normalized tree decomposition T 0 = (V 0, E 0, B0) having width k.
Moreover, one can compute T 0 from T in polynomial time.

3

Linear Programs with Conjunctive Queries

3.1 Syntax

We want to assign weights to the answers of a conjunctive query on a database, such that
they maximize a linear objective function subject to linear constraints. For this, we introduce
the language LP(CQ) of linear programs with conjunctive queries that we also call linear
C q-programs. Its syntax is given in Figure 4. Note that an example of an LP(CQ) program
for optimal warehouse selection was already given in Figure 1.

LP(CQ) programs are interpreted as linear programs whose variables describe the solutions
of conjunctive queries. As a consequence, they do not contain any explicit linear program
variables. Instead, they may contain weight expressions weightx:Q0(Q) over conjunctive
queries Q, Q0 ∈ C qΣ. Intuitively, this expressions is interpreted as a linear sum over linear
program variables representing a solution of Q ∧ Q0. Variables of Q and Q0 however may be
bound in the context, for example through universal quantiﬁers or Σ-operators. The query
variables in x are bound by the expression taking scope over Q and Q0. The free (query)
variable of weight expressions must however be bound by the context, so that they will be
instantiated to some database values before evaluation. Weight expressions without free
variables reason about an unknown weighting of the answer set of query Q on the given
database D with the variables in set(x). Its value is then the sum over the weights of tuples
in answer set of Q ∧ Q0 on the database D with variables in set(x).

Beside weight expressions, linear sums in SumΣ may also contain expression N ∈ NumC
or N S where S ∈ SumΣ and N is a constant number expression, which is either a real number

1 In the literature this property is referred to as “nice” tree decompositions.

XX:8

Linear Programs with Conjunctive Queries

fv(c) = ∅
fv(weightx:Q0(Q)) = fv(Q) ∪ fv(Q0) \ set(x)
fv(N S) = fv(N ) ∪ fv(S)
fv(S + S0) = fv(S) ∪ fv(S0)
fv(∀x:Q. C) = fv(Q) ∪ fv(C) \ {x}
fv(maximize S subject to C) = ∅

x:Q S) = fv(S) ∪ fv(Q) \ set(x)

fv(num(E)) = fv(E)
fv(P
fv(S ≤ S0) = fv(S) ∪ fv(S0)
fv(C ∧ C 0) = fv(C) ∪ fv(C 0)
fv(true) = ∅

Figure 5 Free variables of linear sums, constraints, and linear C q-programs.

c ∈ R or a number expression num(E) with E ∈ X ∪ C. An expression num(a) denotes the
real number numD(aD) if this value is deﬁned. Note that the real value of num(a) over D is
constant from the perspective of the linear program once the database D is ﬁxed.

Linear constrains C ∈ LcΣ are conjunctions of inequalities S ≤ S0 between linear sums
S, S0 ∈ SumΣ, and universally quantiﬁed constraints ∀x:Q. C 0 requiring that C 0 must be
valid for all possible values of x in the solution of Q over the database (after instantiation of
the free variables of the ∀x:Q. C 0). The bound variables in x have scope over Q and C.

LP(CQ) programs or equivalently linear C q-programs L ∈ LpΣ are build from linear
sums in SumΣ and linear constraints in LpΣ as one might expect. Note, however, that free
query variables are ruled out at this level, while being permitted in nested linear constraints
in LcΣ and linear sums in SumΣ.

The sets of free variables of linear sums, constraints, and programs are formally deﬁned
in Figure 5. For instance, the following linear constraint C from the warehouse example has
three free variables in fv(C) = {f, o, q}:

weight(f 0,w0,b0,o0):f 0

.
=f ∧o0

.

=o(dlr(f 0, w0, b0, o0)) ≤ num(q)

The variables f 0, w0, b0, o0 are bound by the weight expression. The free variables f, o, q
are bound by a quantiﬁer in the context, which in the resource delivery example is the
universal quantiﬁer ∀(f, o, q):prod(f, o, q).

3.2 Semantics

We next deﬁne the semantics of a LP(CQ) program L ∈ LpΣ with respect to a database
D ∈ dbΣ with real numbers by an interpretation to a linear program hLiD ∈ Lp, that we will
refer to as the naïve interpretation from now on.

For doing so, one step is to replace the free query variables of the LP(CQ) programs by
elements from the database. For this we assume that we have constants for all elements of the
database domain, that is dom(D) ⊆ C and deﬁne for any conjunctive query Q and variable
assignment γ : Y → D where fv(Q) ⊆ Y a conjunctive query sbsγ(Q), by replacing in Q all
free occurrences of variables y ∈ Y by γ(y). The formal deﬁnition is given in Figure 12.

In order to deﬁne the semantics of a linear program L over a database D we consider the

following set of linear program variables:

ΘD

L = {θα

sbsγ (Q) | S = weightx:Q0(Q) in L, α : set(x) → dom(D), γ : fv(S) → dom(D)}

Let S = weightx:Q0(Q) be a weight expression and γ : Y → dom(D) a variable assignment
for the free variables fv(S) ⊆ Y such that set(x) ∩ Y = ∅. The interpretation of the weight

277

278

279

280

281

282

283

284

285

286

287

288

289

290

291

292

293

294

295

296

297

298

299

300

301

302

303

304

305

306

307

308

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:9

hweightx:Q0(Q)iD,γ = P
h∀x:Q. CiD,γ = V
hP
x:Q SiD,γ = P
γ0∈solD
hN SiD,γ = hN iD,γhSiD,γ
hnum(a)iD,γ = numD(aD)

γ0∈solD

set(x)

set(x)

α∈solD

set(x)

(sbs˜γ (Q∧Q0)) θα

sbs˜γ (Q)

(sbs˜γ (Q))hCiD,˜γ∪γ0
(sbs˜γ (Q))hSiD,˜γ∪γ0

(may be undeﬁned)

hS1 + S2iD,γ = hS1iD,γ + hS2iD,γ
hS1 ≤ S2iD,γ = hS1iD,γ ≤ hS2iD,γ
hC1 ∧ C2iD,γ = hC1iD,γ ∧ hC2iD,γ
htrueiD,γ = true
hciD,γ = c

hmaximize S subject to CiD = maximize hSiD,∅ subject to hCiD,∅

Figure 6 Naïve interpretation of linear expressions (sums, constraints, programs) with conjunctive
queries F over database D as standard linear expression (sums, constraints, and respectively programs)
F D,γ, where γ : Y → dom(D) and fv(F ) ⊆ Y ⊆ X and ˜γ = γ|Y \set(x).

expression hSiD,γ is the overall weight of the solutions α ∈ sol D
˜γ = γ|Y \set(x) in the table sol D

set(x)(sbs ˜γ(Q)). It is described by the following linear sum:

set(x)(sbs ˜γ(Q0 ∧ Q)) where

hSiD,γ =

X

θα
sbs˜γ (Q)

α∈solD

set(x)

(sbs˜γ (Q∧Q0))

The (naive) interpretations hSiD,γ and hCiD,γ of other kinds of linear sums S ∈ SumΣ and
constraints C ∈ LcΣ over a database D and an environment γ are rather obvious. Note that
LP(CQ) program L can be interpreted as linear program hLiD ∈ Lp without any environment
as they do not have free variables. The deﬁnitions are summarized in Figure 6.

We note that α-renaming the bound variables in weight expressions does not always
preserve the semantics of LP(CQ) programs. It may make previously equal queries diﬀerent,
so that diﬀerent weights may be assigned to their answer sets.

3.3 Example from Resource Delivery Optimization

Reconsider the LP(CQ) program L from Figure 1 with the following database D:

prod D = {(F, O1, 1.5), (F, O2, 2.2)}
routeD = {(F, W1, 0.5), (F, W2, 0.4),
(W1, B, 0.6), (W2, B, 0.8)}

storeD = {(W1, 0.9), (W2, 2.5)}
order D = {(B, O1, 0.8), (B, O2, 1.4)}

The answer set of query Q = dlr(f 0, w0, b0, o0) on D is to be weighted. We denote every

answer α : {f 0, w0, b0, o0} → dom(D) by (α(f 0), α(w0), α(b0), α(o0)). Then:

sol D(dlr) = {(F, W1, B, O1), (F, W2, B, O1), (F, W1, B, O2), (F, W2, B, O2)}

The naive interpretation hLiD is the following linear program with variables in ΘD
L:

minimize

subject to

Q

Q

0.5 (θ(F,W1,B,O1)
+0.6 (θ(F,W1,B,O1)
Q
θ(F,W1,B,O1)
Q
∧ θ(F,W1,B,O1)
∧ θ(F,W1,B,O1)

Q

Q

+ θ(F,W2,B,O1)
+ θ(F,W2,B,O1)
+ θ(F,W1,B,O2)

Q

Q

Q

Q

+ θ(F,W1,B,O2)

) + 0.4 (θ(F,W2,B,O1)
Q

+ θ(F,W1,B,O2)

) + 0.8 (θ(F,W2,B,O1)
Q

≤ 1.5 ∧ θ(F,W1,B,O2)
≥ 0.8 ∧ θ(F,W1,B,O2)
≤ 0.9 ∧ θ(F,W2,B,O1)

Q

Q

Q

+ θ(F,W2,B,O2)

)
+ θ(F,W2,B,O2)

Q

Q

Q
+ θ(F,W2,B,O2)
+ θ(F,W2,B,O2)
+ θ(F,W2,B,O2)

Q

Q

)
≤ 2.2
≥ 1.4
≤ 2.5

The term (θ(F,W1,B,O1)
obtained by computing the value of the expression weight(f 0,w0,b0,o0):f 0

) in the objective function of this linear program is
=e(Q) with

+ θ(F,W1,B,O2)

.
=s∧w0

Q

Q

.

309

310

311

312

313

314

315

316

317

318

319

320

321

322

323

324

325

326

327

328

XX:10 Linear Programs with Conjunctive Queries

329

330

331

332

333

334

335

336

337

338

339

340

341

342

343

344

345

346

347

348

349

350

351

352

353

354

355

356

357

358

359

360

361

362

363

364

365

366

367

368

369

370

the environment [f 0/F, w0/W1]. Similarly the term θ(F,W1,B,O1)
in the ﬁrst
Q
constraint is obtained by computing the value of weight(f 0,w0,b0,o0):f 0
=o(Q) with the
environment [r/O1, f /F ]. Observe that both weight expressions share the same linear
program variable θ(F,W1,B,O1)
so they are related semantically.

+ θ(F,W2,B,O1)

.
=f ∧o0

Q

.

Q

4

An Eﬃciently Solvable Fragment

We introduce a class of projecting LP(CQ) programs and deﬁne a notion of width of linear
C q-program in this fragment through a collection of hypertree decompositions of the queries
they contain. We then show one can ﬁnd the optimal solution of such programs L more
eﬃciently than by explicitly computing the interpretation over a database D as a linear
program hLiD. For this we will present an alternative factorized interpretation of L to a
linear program having fewer variables, while preserving the optimal solution.

4.1 Projecting LP(CQ) Programs

We start with the deﬁnition of projecting LP(CQ) programs, whose main restriction resides
on how they can use conjunctive queries.

(cid:73) Deﬁnition 6. The fragment LP(CQ)proj is the set of LP(CQ) programs L such that:
-

for any subexpression weightx:Q0(Q) of L, we have that set(x) = fv(Q) and Q0 is a
projecting query of the form x0 .=y with set(x0) ⊆ set(x) and set(x) ∩ set(y) = ∅.
for any sum P
x:Q S and any universal quantiﬁer ∀x:Q. C of L, the query Q is of the
form ∃z.r(y) for some relation symbol r ∈ R(n), vector y ∈ X n and vector z ∈ X ∗ such
that set(x) ⊆ fv(Q).

-

We denote by LP(CQqf )proj the subset of LP(CQ)proj where every conjunctive query Q
appearing in a weight expression quantiﬁer free.

Any expression weightx:Q0(Q) of a projecting LP(CQ) program is restricted to projection
in Q0. Furthermore Q may not have any variables that are free in the weight expression.
This condition ensures that the interpretation in environment γ of Q does not substitute any
variables, that is sbsγ(Q) = Q. Thus, it is interpreted as a sum over θα
Q variables where α
are solutions of Q taking the same value γ(y) on variables x0. Our algorithm will exploit
this fact by utilizing tree decompositions of Q to interpreter weightx:Q0(Q) of LP(CQqf )proj
with one variable instead of |sol D(Q ∧ Q0)| needed in the naive interpretation.

Another restriction of LP(CQ)proj is that universal quantiﬁers and sums are guarded by
a database relation. Our algorithm does not exploit the structure of conjunctive queries in
universal quantiﬁers and sums so we interpret these expressions in the same way as in Figure 6.
To avoid a blow up in the number of constraints, we chose to guard these constructions.

Hypertree Width of Projecting LP(CQ) Programs. We next lift the concept of generalized
hypertree width from quantiﬁer free conjunctive queries to LP(CQqf )proj programs. The
complexity of our algorithm will depend thereof.

For any program L in LP(CQ)proj, we deﬁne the set of queries cqs(L) that are weighted
when interpreting L as cqs(L) = {Q | weightx:Q0(Q) is a subexpression of L}. Observe that
the resource delivery problem L is in LP(CQ)proj with cqs(L) = {dlr(f 0, w0, b0, o0)}.
(cid:73) Deﬁnition 7. Let L be an LP(CQqf )proj program and T = (TQ)Q∈cqs(L) a collection of
decomposition trees. We call T a tree decomposition of L if for any expression weightx:x0
=y(Q)
in L, TQ = (VQ, EQ, BQ) is a tree decomposition of Q and there is a node u of TQ such that

.

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:11

ρT,D,γ(∀x:r(x).C) = V
x:r(x) S) = P
ρT,D,γ(P
ρT,D,γ(N S) = ρT,D,γ(N )ρT,D,γ(S)
ρT,D,γ(num(a)) = numD(aD)

γ0∈solD(r(x)) ρT,D,γ∪γ0
γ0∈solD(r(x)) ρT,D,γ∪γ0

(C)
(S)

(may be undeﬁned)

ρT,D,γ(S1 + S2) = ρT,D,γ(S1) + ρT,D,γ(S2)
ρT,D,γ(S1 ≤ S2) = ρT,D,γ(S1) ≤ ρT,D,γ(S2)
ρT,D,γ(C1 ∧ C2) = ρT,D,γ(C1) ∧ ρT,D,γ(C2)
ρT,D,γ(true) = true
ρT,D,γ(c) = c

ρT,D,γ(weightx:x0

(cid:26) ξQ,u,β
0
where u is a node of TQ such that set(x0) = BQ(u).

if β = [x0/γ(y)] ∈ sol D(Q)|BQ(u)
else

=y(Q)) =

.

ρT,D(maximize S subject to C)

= maximize ρT,D,∅(S) subject to ρT,D,∅(C) ∧ V

Q∈cqs(L) lscT,D(Q)

Figure 7 T-factorized interpretation of LP(CQqf )proj programs L with respect to a database D.

371

372

373

374

375

376

377

378

379

380

381

382

383

384

385

386

387

388

389

390

391

392

393

394

395

396

397

BQ(u) = set(x0). We deﬁne the width of T to be the maximal width of TQ for Q ∈ cqs(L).
The size of T is deﬁned to be |T| = P

Q∈cqs(L) |VQ|.

The rest of the section is dedicated to proving the following theorem:

(cid:73) Theorem 8 (Main). Let L be a LP(CQqf )proj program, T a decomposition of L of width
k and D a database. There exists an interpretation ρT,D(L) of L having the same value as
hLiD and O(|T||D|k) variables.

Observe that the number of variables of hLiD is roughly the total number of solutions
of the conjunctive queries in cqs(L), which may be up to O(|D|n), where n is the number
of atoms in the conjunctive queries. In Theorem 8, the degree of the polynomial now only
depends on the width of the queries, which may be much smaller, resulting in a more succinct
linear program that is easier to solve. In the resource optimization example, this allows to
go from a cubic number of variables to a quadratic one, but the improvement may be much
better on queries having many atoms and small width.

4.2 Factorized Interpretation

Based on hypertree decompositions we present an alternative factorized interpretation to
smaller linear program having the same optimal value.

In this section, we explain how we can exploit tree decompositions of projecting LP(CQ)
programs with quantiﬁer free conjunctive queries to ﬁnd a smaller interpretation. We ﬁx a
program L of LP(CQqf )proj. Let T = (TQ)Q∈cqs(L) be a tree decomposition of L of width k
where TQ = (VQ, EQ, BQ). The T-factorized interpretation ρT,D(L) of L is formally deﬁned
in Figure 7. It mainly mirrors the naïve interpretation of Figure 6 but signiﬁcantly diﬀers in
=y(Q) is interpreted and one can observe the
two places: the ﬁrst one is the way weightx:x0
addition local soundness constraints lscT,D(Q) to the program.

.

The set of linear program variables for the factorized interpretation ρT,D(L) is deﬁned by:

ΞT,D
L = {ξQ,u,β | Q ∈ cqs(L), u ∈ VQ, β ∈ sol D(Q)|BQ(u)}.

Observe that since TQ is a tree decomposition of Q of width at most k, sol D(Q)|BQ(u) is of
size at most |D|k. Thus we have at most |T||D|k variables in ρT,D(L), as stated in Theorem 8.

XX:12 Linear Programs with Conjunctive Queries

398

399

400

401

402

403

404

405

406

407

408

409

410

411

412

413

414

415

416

417

418

419

420

421

422

423

424

425

426

427

428

429

430

431

432

433

434

435

436

437

438

439

One can see that given a context γ such that ρT,D,γ(weightx:x0
α∈solD

=y(Q)iD,γ = P
usual interpretation would have been hweightx:x0
is, intuitively, ξQ,u,β represents the linear sum of variables θα
with α compatible with β.

=y(Q)) = ξQ,u,β, the
(Q):α|x0 =β θα
Q, that
Q in the naive interpretation

set(x)

.

.

To prove that ρT,D(L) has the same optimal value as hLiD, we will reconstruct a solution
to hLiD from a solution to ρT,D(L) such that the value of ξQ,u,β indeed corresponds to the sum
of the values of variables θα
Q with α compatible with β and vice-versa. To ensure that this is
always possible, we have to be careful that variables ξQ,u,β and ξQ,v,β0 are compatible with
one another because they may correspond to two sums on θα
Q variables having a non-empty
intersection. We ensure this through local soundness constraints lscT,D(Q) for every query
Q ∈ cqs(L) (where A = sol D(Q)):

lscT,D(Q) =

^

^

X

ξQ,u,β

.=

X

ξQ,v,β0.

(u,v)∈EQ

γ∈A|BQ (u)∩BQ (v)

β∈A|BQ (u),β|BQ (u)=γ

β0∈A|BQ (v),β0

|BQ (v)=γ

Observe we added at most |D|k|EQ| constraints for each Q ∈ Q. Moreover constructing
ρT,D(L) from L and D mainly relies on being able to compute sol D(Q)|B(u) for every node u
of TQ. This is possible in polynomial time by dynamic programming on TQ, see Lemma 3.

4.3 Correctness

Weightings on Tree Decompositions. One can observe that the key idea in the deﬁnition
of ρT,D(L) is to introduce linear program variables that will intuitively encode the sum of
several linear program variables in the naive interpretation hLiD. A solution to hLiD maps a
Q to a non-negative real number where α ∈ sol D(Q). In other words, it assigns a
variable θα
weight ω(α) ∈ R+ to every α ∈ sol D(Q) for every Q ∈ cqs(L). A solution to ρT,D(L) maps a
variable ξQ,u,β to a non-negative real number where β ∈ sol D(Q)|BQ(u). In other words, it
assigns a weight Wu to every β that is in sol D(Q)|B(u) for every node u of TQ.

To reconstruct a solution of hLiD from a solution W of ρT,D(L), we need to be able to
reconstruct a weighting ω of sol D(Q) such that P
α|BQ (u)=β ω(α) = Wu(β). In this section,
we explain that this is always possible as long as the Wu are compatible with one another,
which is ensured by local soundness constraints lscT,D(Q) in ρT,D(L).

The technique is not speciﬁcally tied to the fact that the weights are assigned to the
solutions of a quantiﬁer free conjunctive query, thus we formulate our result in a more general
setting by considering weightings on a set A ⊆ DX = {α | α : X → D} for a ﬁnite set
of variables X. Intuitively however, one can think of A as sol D(Q) for a quantiﬁer-free
conjunctive query Q.

We start by introducing a few notations. Let X 0 ⊆ X ⊆ X . For any α0 : X 0 → D we
deﬁne the set of its extensions into A by A[α0] = {α ∈ A | α|X 0 = α0}. Moreover, given a
weighting ω : A → R+ of A, we deﬁne the projection πX 0(ω) : A|X 0 → R+ such that for all
α0 ∈ A|X 0: πX 0(ω)(α0) = P

α∈A[α0] ω(α).

We now ﬁx T = (V, E, B) a decomposition tree for X. Given two nodes u, v ∈ V we

denote the intersection of their bags by Buv = B(u) ∩ B(v).

(cid:73) Deﬁnition 9. A family W = (Wv)v ∈V is a weighting collection on T for A if it satisﬁes
the following conditions for any two nodes u, v ∈ V:
- Wu is a weighting of A|B(u), i.e., Wu : A|B(u) → R+.
- Wu is sound for T at {u, v}, i.e., πBuv (Wu) = πBuv (Wv).

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:13

Intuitively, the soundness of a weighting collection on T is a minimal requirement for the
existence of a weighting ω of A such that Wu is the projection of ω on the bag B(u) of T ,
that is Wu = πB(u)(ω) since we have the following:

(cid:73) Proposition 10. For any weighting ω : A → R+, the family (πB(v)(ω))v∈V is a weighting
collection on T for A.

What is more interesting is the other way around, that is, given (Wu)u∈V a weighting
collection on T , whether we can ﬁnd a weighting ω of A such that Wu = πB(u)(ω) for every
u. It turns out that soundness is not enough to ensure the existence of such a weighting.
However it becomes possible when A is conjunctively decomposed:

(cid:73) Deﬁnition 11. Let T = (V, E, B) be a decomposition tree of X ⊆ X . We call a subset
of variable assignments A ⊆ DX conjunctively decomposed by T if for all u ∈ V and
β ∈ A|B(u): {α1 ∪ α2 | α1 ∈ A|B(↑u)[β], α2 ∈ A|B(↓u)[β]} ⊆ A[β] where B(V ) = S
v∈V B(v)
for any V ⊆ V.

Note that the inverse inclusion holds in general. Of course, this property holds if A is the

answer set of a conjunctive queries and the tree is a tree decompositions of Q:

(cid:73) Proposition 12. For any tree decomposition T of a quantiﬁer free conjunctive query
Q ∈ C qΣ and database D ∈ dbΣ, the answer set sol D(Q) is conjunctively decomposed by T .

Proposition 12 does not hold when Q is not quantiﬁer free. It explains why the technique
only works for the fragment LP(CQqf )proj. We however explain how one can use the same
technique on LP(CQ)proj in Section 4.4.

Soundness and conjunctive decomposition are enough to prove this correspondence
theorem that allows us to transform solutions of ρT,D(L) to solutions of hLiD and vice-versa.

(cid:73) Theorem 13 (Correspondence). Let T = (V, E, B) be a normalized decomposition tree of
X ⊆ X and A ⊆ DX be a set of variable assignment that is conjunctively decomposed by T .
1. For every weighting ω of A, (πB(u)(ω))u∈V is a weighting collection on T for A.
2. For any weighting collection W on T for A there exists a weighting ω of A such that

∀u : Wu = πB(u)(ω).

While the ﬁrst item of Theorem 13 follows by Proposition 10 and can be proven by a simple
calculation, the second item is harder to prove. We present here one way of constructing ω
from (Wu)u∈V . The proof of correctness of this construction can be found Appendix C.

Let T = (V, E, B) be a normalized decomposition tree of X and W = (Wu)u∈V a weighting
collection on T for A ⊆ DX . For any node u ∈ V, we inductively construct ωu : A|B(↓u) → R+.

If u is a leaf of T , we deﬁne ωu such that for all α ∈ A|B(↓u), ωu(α) := Wu(α).
Now, assume ωu0 is deﬁned for all children u0 of u. Let α ∈ A|B(↓u) and denote by

β = α|B(u). We deﬁne ωu(α) as follows:

If u is an extend node with a child v then ωu(α) := Wu(β)

Wv(α|B(v)) ωv(α|B(↓v)) if Wv(α|B(v)) >

0 and ωu(α) := 0 otherwise.

If u is a project node with a child v then ωu(α) := ωv(α|B(↓v)).

If u is a join node with children v1, . . . , vk then ωu(α) :=

and ωu(α) := 0 otherwise.

Qk

ωvi (α|B(↓vi))

i=1

Wu(β)k−1

if Wu(β) > 0

Finally, we let ω be ωr where r is the root of T . The proof that ∀u : Wu = πB(u)(ω) is
done via two inductions. The ﬁrst one is a bottom-up induction to prove that Wu = πB(u)(ω)
for every node u in the tree decomposition. Then, by top-down induction, one can prove that

440

441

442

443

444

445

446

447

448

449

450

451

452

453

454

455

456

457

458

459

460

461

462

463

464

465

466

467

468

469

470

471

472

473

474

475

476

477

478

479

480

481

482

XX:14 Linear Programs with Conjunctive Queries

483

484

485

486

487

488

489

490

491

492

493

494

495

496

497

498

499

500

501

502

503

504

505

506

507

508

509

510

511

512

513

514

515

516

517

518

519

520

521

522

523

524

ωu = πB(↓u)(ωr). The proof is tedious and mainly rely on calculations and careful analysis
on how A is decomposed along T .

Correctness Proof. We are now ready to prove that, given a tree decomposition T of a
linear C q-program L of LP(CQqf )proj, ρT,D(L) and hLiD have the same optimal value.

For any weighting

.
ω: ΘL → R+ we deﬁne a weighting Π(

.
ω) : ΞT,D

L → R+ such that for all

.

ξQ,u,β ∈ ΞT,D

L : Π(
Observe that

ω)(ξQ,u,β) = P
.
ω can be seen as a collection of weightings of sol D(Q) for Q ∈ cqs(L). It
.
ω returns the same value
.
ω):

turns out that evaluating linear sums and constraints of hLiD with
as the evaluation of linear sums and constraints of ρT,D(L) with Π(

α∈solD(Q)[β]

Q).

.
ω (θα

(cid:73) Lemma 14. For any T−projecting sum S ∈ SumΣ and environment γ : X → dom(D)
where fv(S) ⊆ X it holds that

hSiD,γ

.

.

ω =

(cid:75)

ρT,D,γ(S)
(cid:75)

(cid:74)

ω).

Π(

(cid:74)

(cid:73) Lemma 15. For any constraint C ∈ LcΣ that is T−projecting and environment γ : X →
ρT,D,γ(C)
dom(D) where fv(C) ⊆ X:

.

.

hCiD,γ
(cid:74)

(cid:75)

ω =

(cid:74)

ω).

Π(

(cid:75)

Lemma 14 and Lemma 15 rely on Proposition 10. It is easy to see that they imply that if
.
ω is a solution of hLiD (the fact that it respects the local soundness constraints follows from
.
ω) is a solution of ρT,D(L) with the same value. Thus, the optimal
Proposition 10), then Π(
value of ρT,D(L) is greater or equal than the optimal value of hLiD.

.

W of ΞT,D

To prove the equality, it remains to prove that the optimal value of hLiD is greater or
equal than the optimal value of ρT,D(L). To this end, consider a solution of ρT,D(L). It is a
L which respects the local soundness constraints. By Theorem 13, we
weighting
.
ω of ΘL which respects the constraint of hLiD. It is
will be able to reconstruct a weighting
formalized in the following lemma whose proof can be found in the appendix.
W of ΞT,D
L
.
ω).

(cid:73) Lemma 16. For any weighting
.
W = Π(
a weighting

.
ω of ΘQ such that

Q∈Q lscT,D(Q)

= 1, there exists

such that

.
W
(cid:75)

V

(cid:74)

.

(cid:73) Proposition 17. Let D be a database and T a collection of decomposition tree. Any
T−projecting LP(CQ) program L = (maximize S subject to C) ∈ LpΣ satisﬁes that:
ρT,D(S)
1. For any solution
ρT,D(S)

.
ω of hLiD there is a solution
.
W of ρT,D(L) there is a solution

.
W of ρT,D(L) s.t.
.
ω of hLiD s.t.

2. For any solution

.
W

(cid:74)

(cid:75)

(cid:75)

.

.

hSiD,∅
(cid:74)
hSiD,∅
(cid:74)

(cid:75)

.

ω =
ω =

.

(cid:74)

.
W

(cid:75)

4.4 Treatment of Existential Quantiﬁers

The previous method of factorized interpretation only works for the LP(CQqf )proj fragment,
where conjunctive queries are supposed to be quantiﬁer free. It turns out that one can
similarly solve linear programs of LP(CQ)proj programs by applying a simple transformation.
For any LP(CQ)proj program L we can move the existential quantiﬁers of the con-
junctive query into the weight expression as follows, yielding an LP(CQqf )proj program
mvq(L): we replace every subexpression weightx:Q0(∃z.Q) of L, where Q is quantiﬁer free,
by weightxz:Q0(Q) where xz is the concatenation of vectors x and z. We have:

(cid:73) Theorem 18 (Removing Existential Quantiﬁers). For any projecting LP(CQ) program, the
LP(CQqf )proj program mvq(L) has the same optimal value as L.

Observe that we can use this technique for the resource delivery problem L. In mvq(L),
there is only one query on variables (f 0, o0, q, q0, b0, w0, c, c0). It is easy to see that it has
hypertree width 2 since we can construct a tree decomposition having two connected bags
B(u) = {f 0, o0, b0, q, q0} and B(v) = {f 0, w0, b0, c, c0}. B(u) is covered by the ﬁrst two atoms

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:15

Figure 8 Number of variables and performances of GLPK for naive (blue) and factorized (red)

interpretation of the resource delivery problem with respect to table size.

525

526

527

528

529

530

531

532

533

534

535

536

537

538

539

540

541

542

543

544

545

546

547

548

549

550

551

552

553

554

555

556

and B(v) by the last two. Now, because of the weight expressions, we also need to add a
bag for {f 0, w0}, {w0} and {w0, b0} which can safely be connected to v, and for {f 0, o0} and
{b0, o0} which can safely be connected to u. It gives a decomposition of L of width 2, showing
that factorized interpretation will have less variables than the naive interpretation.

5

Preliminary Experimental Results

The practical performances of our idea heavily depends on how linear solvers perform on
factorized interpretation. We compared the performances of GLPK on both the naive
interpretation and the factorized interpretation of the resource delivery problem from the
introduction using some synthetic data. We used Python and the Pulp library to build the
linear programs. The tree-decomposition of the dlr query is hard-coded. The tests were run
on an oﬃce laptop by making the number of tuples in the randomly ﬁlled prod, order and
route tables vary. A summary of our experiments is displayed on Figure 8.

As expected when comparing both linear programs we observed a larger number of
constraints (due to the soundness constraints) and a smaller number of variables in the
factorized interpretation. While building the naive interpretation quickly became slower
than building the factorized interpretation, we do not analyze this aspect further since we
are not using a database engine to build the naive interpretation and solve it directly from
the tree decomposition, which may not be the fastest method without further optimizations.
Most interestingly solving the factorized interpretation was faster than solving the naive
interpretation in spite of the increased number of constraints thanks to the decrease in the
number of variables. In particular for an instance with an input size of 2000 lines per table,
the naive interpretation had roughly 1.5 million variables while the factorized interpretation
had only roughly 150000. The solving time was also noticeably improved at 22s for the
factorized case against 106s for the naive one.

Conclusion and Future Work Our preliminary experiments seem to conﬁrm the eﬃciency
of factorized interpretation, in accordance with our complexity results. More thorough
benchmarking is needed to evaluate the practical relevance though. Another direction to
explore would be to better integrate our approach into a database engine, in the way it is
done by SolveDB for example. Finally, other optimization problems may beneﬁt from this
approach such as convex optimization or integer linear programming. It would be interesting
to deﬁne languages analogous to LP(CQ) for these optimization problems and study how
conjunctive query decompositions could help to improve the eﬃciency.

XX:16 Linear Programs with Conjunctive Queries

557

558

559

560

561

562

563

564

565

566

567

568

569

570

571

572

573

574

575

576

577

578

579

580

581

582

583

584

585

586

587

588

589

590

591

592

593

594

595

596

597

598

599

600

601

602

603

604

605

606

607

References

1 Guillaume Bagan, Arnaud Durand, and Etienne Grandjean. On acyclic conjunctive queries
and constant delay enumeration. In International Workshop on Computer Science Logic, pages
208–222. Springer, 2007.

3

2 Nurzhan Bakibayev, Tomáš Kočisk`y, Dan Olteanu, and Jakub Závodn`y. Aggregation and
ordering in factorised databases. Proceedings of the VLDB Endowment, 6(14):1990–2001, 2013.
Björn Bringmann and Siegfried Nijssen. What is frequent in a single graph? In Paciﬁc-Asia
Conference on Knowledge Discovery and Data Mining, pages 858–863. Springer, 2008.
Toon Calders, Jan Ramon, and Dries Van Dyck. All normalized anti-monotonic overlap graph
measures are bounded. Data Mining and Knowledge Discovery, 23(3):503–548, 2011.

4

5 Cynthia Dwork and Aaron Roth. The Algorithmic Foundations of Diﬀerential Privacy.

Foundations and Trends in Theoretical Computer Science, 9(3–4):211–407, 2014.

6 Mathias Fiedler and Christian Borgelt. Support computation for mining frequent subgraphs

in a single graph. In MLG. Citeseer, 2007.

7 Robert Fourer, David M Gay, and Brian W Kernighan. A modeling language for mathematical

programming. Management Science, 36(5):519–554, 1990.

8 Michael R Garey and David S Johnson. Computers and intractability, volume 29. wh freeman

New York, 2002.

9 G. Gottlob, N. Leone, and F. Scarcello. Hypertree Decompositions and Tractable Queries.
Journal of Computer and System Sciences, 64(3):579–627, May 2002. arXiv: cs/9812022.
10 Georg Gottlob, Nicola Leone, and Francesco Scarcello. On tractable queries and constraints. In
International Conference on Database and Expert Systems Applications, pages 1–15. Springer,
1999.

11 Martin Grohe. The structure of tractable constraint satisfaction problems. In International
Symposium on Mathematical Foundations of Computer Science, pages 58–72. Springer, 2006.
12 Narendra Karmarkar. A new polynomial-time algorithm for linear programming. Comb.,

4(4):373–396, 1984. doi:10.1007/BF02579150.

13 Ton Kloks. Treewidth: computations and approximations, volume 842. Springer Science &

14

Business Media, 1994.
Phokion G. Kolaitis, Enela Pema, and Wang-Chiew Tan. Eﬃcient querying of inconsistent
databases with binary integer programming. Proceedings of the VLDB Endowment, 6(6):397–
408, April 2013. URL: http://dl.acm.org/citation.cfm?doid=2536336.2536341, doi:10.
14778/2536336.2536341.
Leonid Libkin. Elements of ﬁnite model theory. Springer Science & Business Media, 2013.

15
16 Alexandra Meliou and Dan Suciu. Tiresias: The database oracle for how-to queries.

In
Proceedings of the 2012 ACM SIGMOD International Conference on Management of Data,
SIGMOD ’12, pages 337–348, New York, NY, USA, 2012. ACM. URL: http://doi.acm.org/
10.1145/2213836.2213875, doi:10.1145/2213836.2213875.

17 Nicholas Nethercote, Peter J Stuckey, Ralph Becket, Sebastian Brand, Gregory J Duck, and
Guido Tack. Minizinc: Towards a standard cp modelling language. In International Conference
on Principles and Practice of Constraint Programming, pages 529–543. Springer, 2007.
18 Dan Olteanu and Jakub Závodn`y. Size bounds for factorised representations of query results.

ACM Transactions on Database Systems (TODS), 40(1):1–44, 2015.

19 Reinhard Pichler and Sebastian Skritek. Tractable counting of the answers to conjunctive

queries. Journal of Computer and System Sciences, 79:984–1001, September 2013.

20 Maximilian Schleich, Dan Olteanu, and Radu Ciucanu. Learning linear regression models over
factorized joins. In Proceedings of the 2016 International Conference on Management of Data,
pages 3–18. ACM, 2016.
Laurynas Šikšnys and Torben Bach Pedersen. SolveDB: Integrating optimization problem
solvers into SQL databases. In Proceedings of the 28th International Conference on Scientiﬁc
and Statistical Database Management, page 14. ACM, 2016.

21

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:17

608

609

610

611

612

613

614

615

616

22 Natalia Vanetik, Ehud Gudes, and Solomon Eyal Shimony. Computing frequent graph patterns
In Data Mining, 2002. ICDM 2003. Proceedings. 2002 IEEE

from semistructured data.
International Conference on, pages 458–465. IEEE, 2002.

23 Yuyi Wang, Jan Ramon, and Thomas Fannes. An eﬃciently computable subgraph pattern
support measure: counting independent observations. Data Mining and Knowledge Discovery,
27(3):444–477, November 2013.

24 Mihalis Yannakakis. Algorithms for acyclic database schemes. In Proceedings of the Seventh
International Conference on Very Large Data Bases - Volume 7, VLDB ’81, pages 82–94.
VLDB Endowment, 1981.

XX:18 Linear Programs with Conjunctive Queries

617

618

619

620

621

622

623

624

625

626

627

628

629

630

631

632

633

634

635

636

A Minimizing Noise in (cid:15)-Diﬀerential Privacy

The strategy of diﬀerental privacy is to add noise to the relational data before publication.
Roughly speaking, the general objective of ε-diﬀerential privacy [5] is to add as few noise as
possible, without disclosing more than an ε amount of information. We illustrate this with
the example of a set of hospitals which publish medical studies aggregating results of tests on
patients, which are to be kept conﬁdential. We consider the problem of how to compute the
optimal amount of noise to be added to each separate piece of sensitive information (in terms
of total utility of the studies) while guaranteeing ε-diﬀerential privacy. We show that this
question can be solved (approximately) by computing the optimal solution of a projecting
LP(CQ) program with an acyclic conjunctive query.

A.1 Hospital Database about Medical Studies on Patient Tests

We consider a database D with signature Σ = {H, Test, St, Priv, Sens} whose domain provides
patients, hospitals, studies, and positive real numbers. The relations of D are the following:

(pat, hosp) ∈ H D: the patient pat is in the hospital hosp.
(pat, st) ∈ TestD: the patient pat participates in the study st.
(test, st) ∈ StD: the test test is used in the study st.
(obj, ε) ∈ PrivD: the object obj is either a patient or a hospital. The positive real number
ε indicates the privacy budget for obj.
(st, test, val) ∈ SensD: the value (in terms of study results) of a patient participating in
a study and contributing a unit of information on their result on test test.

The following query deﬁnes the sensitive information that will be revealed to the research-
ers performing the medical studies. It selects all pairs of patients pat and tests test, such pat
did the test which was then used by some study st.

InStudy(pat, test) = ∃st. Test(pat, test) ∧ St(test, st)

More precisely, the sensitive information is the answer set of this query over the database
D. We want to assign a weight to all the pairs in the answer set. The weight of a sensitive
pair states the amout of information that may be disclosed about the pair after the addition
of the noise. The needed amount of noise for the pair is then inversely proportional to the
amount of information that may be disclosed, i.e, the weight of the pair, which is also called
its privacy budget. The weight of a patient pat and a test test is speciﬁed by the weight
expression:

weight(pat0,test0):test0

.
=test∧pat0

.

=pat(InStudy(pat0, test0))

In an environment γ for the global variables pat and test this weight expression is interpreted
as the linear program variable:

θ[pat0/γ(pat),test0/γ(test)]
InStudy(pat0,test0)

The overall weight of all sensitive tests of the same patient pat is described by the weight
expression:

weight(pat0,test0):pat0

.

=pat(InStudy(pat0, test0))

In an environment γ for the global variable pat this weight expression is interpreted as the
following sum of linear program variables:

X

θ[pat0/γ(pat),test0/α(test0)]
InStudy(pat0,test0)

α∈solD(InStudy(pat0,test0)∧pat0=γ(pat))

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:19

Queries

Constraints

Program

InStudy(pat, test) = ∃st. Test(pat, test) ∧ St(st, test)

CPat = ∀(pat, ε):P riv(pat, ε).
weight(pat0,test0):pat0

CHosp = ∀(hosp, ε):P riv(hosp, ε). P

.

=pat(Q(pat0, test0)) ≤ num(ε)

weight(pat0,test0):pat0

(pat):H(pat,hosp)
=pat(InStudy(pat0, test0)) ≤ num(ε)

.

maximize P

(st,test,val):Sens(st,test,val)
num(val) weight(pat0,test0):test0

subject to CPat ∧ CHosp

.

=test(InStudy(pat0, test0))

Figure 9 An LP(CQ)proj program for diﬀerential privacy when publishing medical studies

aggregating patient tests in hospitals.

637

638

639

640

641

642

643

644

645

646

647

648

649

650

651

652

653

654

655

656

657

658

659

660

661

662

663

664

This sum may be represented more compactly in factorized interpretation avoiding the
enumeration of the answer set for the database D.

The LP(CQ) program for this example is given in Figure 9. The linear privacy constraints
that are to be satisﬁed are CPat and CHosp. Constraint CPat states that for all patients pat
with privacy requirement ε, i.e., ∀(pat, ε) : Priv(pat, ε), the sum of all weights of all sensitive
pairs (pat, test0) in InStudy must be bounded by ε. This constraint is motivated by the
composition rule of diﬀerential privacy (DP). Suppose we have sensitive pairs pi = (pati, testi).
If pi is εi-DP for 1 ≤ i ≤ n, then {p1 . . . pn} is (Pn

i=1 εi)-DP.

Similarly, constraint CHosp states that for all hospitals hosp with privacy requirement
ε, i.e., ∀(hosp, ε) : Priv(hosp, ε), the sum of all weights of all sensitive pairs (pat, test) in
InStudy where pat is a patient of hosp must be bounded by ε. Finally, the objective function
is to maximize the sum over all triples (st, test, val) in Sens of the weights of pairs (pat0, test)
in InStudy but multiplied with num(val), the utility of the information for the study.

This program is projecting, so it is a member of LP(CQ)proj. Furthermore, a hypertree
decomposition of width 1 is available. While the naive interpretation over a database yields
a linear program with a quadratic number of variables (in the size of the database), the
factorized interpretation yields a linear program with a linear number of variables.

Please note that the approach presented above is only approximate. For example, summing
over noise variance in the objective function would be more accurate but would only lead
to a convex program, which motivates us to extend beyond linear programs in future work.
Also, the composition rule for DP is only approximate, more advanced composition rules
have been studied but they are more complex and still approximate.

B

Computing the s-Measure for Graph Pattern Matching

The s-measure has been introduced by Wang et al. [23] to evaluate the frequency of matchings
of a subgraph pattern in a larger graph. Here, we consider pattern matches as graph
homomorphism, but we could also restrict them to graph isomorphisms.

A naive way of evaluating this frequency is to use the number of pattern matches as the
frequency measure. Using this value as a frequency measure is problematic since diﬀerent

XX:20 Linear Programs with Conjunctive Queries

665

666

667

668

669

670

671

672

pattern maches may overlap, and as such they share some kind of dependencies that is
relevant from a statistical point of view. More importantly, due to the overlaps, this measure
fails to be anti-monotone, meaning that a subpattern may be counter-intuitively matched less
frequently than the pattern itself. Therefore, the ﬁnding of better anti-monotonic frequency
measures – also known as support measures – has received a lot of attention in the data
mining community [3, 4, 6]. A ﬁrst idea is to count the maximal number of non-overlapping
patterns [22]. However, ﬁnding such a maximal subset of patterns essentially boils down to
ﬁnding a maximal independent set in a graph, a notorious NP-complete problem [8].

The s-measure is a relaxation of this idea where the frequency of pattern matches is
computed as the maximum of the sum of the weights that can be assigned to each pattern
match, under the constraint that for any node v of the graph and node v0 in the subgraph
pattern that the sum of the weights of the matchings mapping v0 to v is at most 1. More
formally, given two digraphs G = (VG, EG) and P = (VP , EP ), we deﬁne a matching of
the pattern P in graph G as a graph homomorphism h : VP → VG. Recall that a graph
homomorphism requires for all (v, v0) ∈ Ep that (h(v), h(v0)) ∈ EG. We denote by hom(P, G)
the set of matchings of P in G. The s-measure of P in G is then deﬁnes as the optimal
value of the following linear program with variables in {θh | h ∈ hom(P, G)} for positive real
numbers:

maximize P
subject to

h∈hom(P,G) θh
∀v ∈ VG.∀v0 ∈ VP . P

h∈hom(P,G)
h(v0)=v

θh ≤ 1

673

674

675

676

677

678

679

680

681

682

683

684

685

686

687

688

689

We can consider each graph G as a database D with signature Σ = {node, edge}, domain
dom(DG) = VG and relations nodeD = VG and edgeD = EG. Since the names of the nodes
of the pattern do not care for pattern matching, we can assume without loss of generality
that VP = {1, . . . , ‘} for some ‘ ∈ N. We can then deﬁne a matching of a pattern P by a
conjunctive query matchP (x1, . . . , x‘):

matchP (x1, . . . , x‘) =

^

(i,j)∈EP

edge(xi, xj)

It is clear that α ∈ sol D(matchP (x1, . . . , x‘) if and only if α ◦ [1/x1, . . . , ‘/x‘] is a pattern
matching in hom(P, Q). One can thus rewrite the previous linear program as LP(CQ)
program as follows:

maximize P
subject to

(x):node(x) weight(x1,...,xn):x1

.

=x(matchP (x1, . . . , xn))

∀(x) : node(x): ∧‘

i=1 weight(x1,...,xn):xi

.

=x(matchP (x1, . . . , xn)) ≤ 1.

Moreover, the hypertree width of the conjunctive query matchP (x1, . . . , x‘) is at most
the (hyper)tree width of the pattern graph P . By our main Theorem 8, the factorized
interpretation yields a linear program with at most (|VG| + |EG])k variables, where k is
the (hyper)tree width of pattern P . The original linear program could have been of size
(cid:18) |VG|
‘

which is bounded by |VG|‘. So the factorized interpretation will pay oﬀ if the

(cid:19)

(hyper)tree width k of the pattern is considerably smaller than the number ‘ of its nodes.

C Weightings

C.1 Projections of weightings

Let X 0 ⊆ X ⊆ X and A ⊆ DX = {α | α : X → D} be a set of variable assignments. For any
α0 : X 0 → D we deﬁne the set of its extensions into A by A[α0] = {α ∈ A | α|X 0 = α0}.

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:21

(cid:73) Lemma 19. For any two α1, α2 ∈ A|X 0, if α1 6= α2 then A[α1] ∩ A[α2] = ∅.

Proof. If α1 6= α2 ∈ A|X 0, then there exists x0 ∈ X 0 such that α1(x0) 6= α2(x0), so if
(cid:74)
γ1 ∈ A[α1] and γ2 ∈ A[α2] then γ1(x0) = α1(x0) 6= α2(x0) = γ2(x0).
(cid:73) Lemma 20. For A ⊆ DX , X 00 ⊆ X 0 ⊆ X, α00 ∈ A|X 00: A[α00] = U

α0∈A|X0 [α00] A[α0].

Proof. First note that the union on the right is disjoint by Lemma 19.

For the inclusion from the left to the right, let α ∈ A[α00] and α0 = α|X 0. By deﬁnition,

α0 ∈ A|X 0 so α ∈ A[α0]. Furthermore, α0 ∈ A|X 0[α00] so α ∈ U

For the inclusion from the right to the left, let α ∈ U

be such that α ∈ A[α0]. By deﬁnition, α|X 0 = α0 and α0
α|X 00 = α0

|X 00 = α00. Thus α ∈ A[α00].

˜α0∈A|X0 [α00] A[ ˜α0].

α0∈A|X0 [α00] A[α0] and let α0 ∈ A|X 0[α00]
|X 00 = α00. Since X 00 ⊆ X 0,
(cid:74)

For any weighting ω of A and subset of variables X 0 ⊆ X, we deﬁne the projection

πX 0(ω) : A|X 0 → R+ such that for all α0 ∈ A|X 0:

πX 0(ω)(α0) =

X

ω(α)

α∈A[α0]

(cid:73) Proposition 21. For A ∈ DX , ω : A → R+, X 00 ⊆ X 0 ⊆ X: πX 00(ω) = πX 00 (πX 0(ω)).

Proof sketch. This is a consequence of the disjoint decomposition of Lemma 20.

(cid:74)

Proof. Indeed, let α00 ∈ A|X 00. We have:

πX 00 (ω)(α00) =

X

ω(α)

=

=

α∈A[α00]
X

α0∈A|X0 [α00]
X

α0∈A|X0 [α00]

X

ω(α)

α∈A[α0]

πX 0(ω)(α0)

by deﬁnition

by Lemma 20

by deﬁnition of πX 0(ω)

= πX 00(πX 0(ω))(α00)

by deﬁnition of πX 00(πX 0(ω)).

The last equality is well deﬁned since α00 ∈ A|X 00 = (A|X 0)|X 00.

(cid:74)

690

691

692

693

694

695

696

697

698

699

700

701

702

703

704

705

706
707

708

709

C.2 Weighting collections on decomposition trees

Let X ⊆ X be a ﬁnite set of variables and T = (V, E, B) a decomposition tree of X. Given
two nodes u, v ∈ V we denote the intersection of their bags by:

Buv = B(u) ∩ B(v)

710

711

712

713

714

715

716

(cid:73) Deﬁnition 22. Let A ⊆ DX and let T = (V, E, B) be a decomposition tree for X. We call
a family W = (Wv)v ∈V a weighting collection on T for A if it satisﬁes the following two
conditions for any two nodes u, v ∈ V:
- Wu is a weighting of A|B(u), i.e., Wu : A|B(u) → R+.
- Wu is sound for T at {u, v}, i.e., πBuv (Wu) = πBuv (Wv).

(cid:73) Proposition 23. Let A ⊆ DX and let T = (V, E, B) be a decomposition tree for X. For
any weigthing ω : A → R+, the family (πB(v)(ω))v∈V is a weighting collection on T for A.

XX:22 Linear Programs with Conjunctive Queries

717

718

719

720

721

722

723

724

725

726

727

728

729

730

731

732

733

Proof. For any u ∈ V let Wu = πB(u)(ω). The ﬁrst condition on weighting projections holds
trivially so we only have to show that the soundness constraint holds. By deﬁnition of Wu,
πBuv (Wu) = πBuv (πB(u)(ω)). Observe that Buv ⊆ B(u) so by Proposition 21 πBuv (Wu) =
(cid:74)
πBuv (ω). Similarly πBuv (Wv) = πBuv (ω).

We next show that the global soundness at any subset of nodes {u, v} ⊆ V follows from

the local soundness at all subsets {u, v} such that (u, v) ∈ E.

(cid:73) Lemma 24. If W is sound for T at {u, v} for all edges (u, v) ∈ E then W is sound for T
at all subsets {u, v} ⊆ V.

Proof. We show by induction on k ≥ 0 for all pairs of nodes (u, v) ∈ (E ∪ E −1)k that
πBuv (Wu) = πBuv (Wv).

The base case where k = 0 is obvious. We now show the induction step from k to k + 1.
Let (u, v) ∈ (E ∪ E −1)k+1 be arbitrary. Then there exists w ∈ V such that (u, w) ∈ (E ∪ E −1)k
and (v, w) ∈ E ∪ E −1. By induction hypothesis, we have πBuw (Wu) = πBuw (Ww). We need
to show that πBuv (Wu) = πBuv (Wv). We ﬁrst observe that Buv ⊆ B(w) by connectedness of
T which implies that Buv ⊆ Buw and Buv ⊆ Bvw. Therefore, we can conclude as follows:

πBuv (Wu) = πBuv (πBuw (Wu))

by Proposition 21 and Buv ⊆ Buw

= πBuv (πBuw (Ww)) by induction hypothesis
by Proposition 21 and Buv ⊆ Buw
= πBuv (Ww)
= πBuv (πBvw (Ww)) by Proposition 21 and Buv ⊆ Bvw
= πBuv (πBvw (Wv))
= πBuv (Wv)

by local soundness at {v, w}
by Proposition 21 and Buv ⊆ Bvw

If T is normalized then the local soundness constraint (22) of W at (u, v) ∈ E can be

rewritten equivalently into a simpler form as follows:

(cid:74)

if u is an extend node with unique child v then: ∀β ∈ A|B(v) : P
Wv(β),
if u is a project node with unique child v then ∀β ∈ A|B(u) : Wu(β) = P
if u is a join node with child v then ∀β ∈ A|B(u) : Wu(β) = Wv(β).

β0∈A|B(u)[β] Wu(β0) =

β0∈A|B(v)[β] Wv(β0),

734

C.3 Conjunctive decomposition

We need to restrict ourselves to particular subsets of variable assignments, including answer
sets of acyclic conjunctive queries. More generally, we deﬁne what it means for a subset
of variable assignments to be conjunctively decomposed by a decomposition tree. For any
decomposition tree T = (V, E, B) and subset V ⊆ V we deﬁne the set of variables:

B(V ) =

B(v)

[

v∈V

735

736

737

738

739

740

In particular, this deﬁnes for any v ∈ V the union B(↑v) of bags of vertices in-the-context-
or-equal-to v, and the union B(↓ v) of bags of vertices that are descendants-or-equal-to
v.

(cid:73) Deﬁnition 25. Let T = (V, E, B) be a decomposition tree of X ⊆ X . We call a subset of
variable assignments A ⊆ DX conjunctively decomposed by T if for all u ∈ V and β ∈ A|B(u):

{α1 ∪ α2 | α1 ∈ A|B(↑u)[β], α2 ∈ A|B(↓u)[β]} ⊆ A[β]

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:23

741

742

743

744

745

746

747

748

749

750

751

752

753

754

755

756

757

758

759

760

761

762

763

764

765

766

767

768

769

770

771

772

773

Note that the inverse inclusion holds in general. To see this let β ∈ A|B(u). If α ∈ A[β]
then α ∈ A and β = α|B(u). Hence, α = α|B(↑u) ∪ α|B(↓u), so we can deﬁne α1 = α|B(↑u) and
α2 = α|B(↓u).

(cid:73) Proposition 26. For any tree decomposition T of a quantiﬁer free conjunctive query
Q ∈ C qΣ and database D ∈ dbΣ, the answer set sol D(Q) is conjunctively decomposed by T .

Proof. Let u be a node of T . The proof is based on the following observation: given an atom
R(x) of Q, either x ⊆ B(↓ u) or x ⊆ B(↑u). Thus Q can be written as Q1 ∧ Q2 with the
variables of Q1 included in B(↓ u) and the variables of Q2 includes in B(↑u). Moreover, recall
that B(u) = B(↓ u) ∩ B(↑u). Thus, given an assignment β of B(u) and α|1 ∈ sol D(Q1)[β] and
α|2 ∈ sol D(Q2)[β], we have that α = α1 ∪ α2 ∈ sol D(Q)[β]. That is, sol D(Q) is conjunctively
(cid:74)
decomposed by T .

(cid:73) Lemma 27. Let T be a decomposition tree of X, u an extend node of T with child v, and
A ⊆ DX a subset of variable assignments. If A is conjunctively decomposed by T then any
assignment β ∈ A|B(u) satisﬁes:

A|B(↓u)[β]|B(↓v) = A|B(↓v)[β|B(v)]

Proof. For the inclusion from the left to the right let α ∈ A|B(↓u)[β]|B(↓v). Since α ∈ A|B(↓v)
and α|B(v) = β|B(v) it follows that α ∈ A|B(↓v)[β|B(v)].

For the inclusion from the right to the left let α ∈ A|B(↓v)[β|B(v)]. Let γ ∈ A|B(↑v)[β] be

arbitrary and τ = γ ∪ α.

Note that (τ|B(↓u))|B(↓v) = α, so it is suﬃcient to show τ|B(↓u) ∈ A|B(↓u)[β].
Since u is an extend node with child v it follows that B(↑u) = B(↑v), and thus γ ∈
A|B(↑v)[β]. By conjunctive decomposition of A by T it follows that τ ∈ A[β]. Hence,
(cid:74)
τ|B(↓u) ∈ A|B(↓u)[β] as required.

(cid:73) Lemma 28. Let T be a decomposition tree of X, u a join node of T with children v1, . . . , vk
where k ≥ 1, and A ⊆ DX a subset of variable assignments. If A is conjunctively decomposed
by T then any β ∈ A|B(u) satisﬁes:

A|B(↓u)[β] = A|B(↓v1)[β] ./ . . . ./ A|B(↓vk)[β]

Proof. The inclusion from the left to the right is obvious by projecting an element of
A|B(↓u)[β] to B(↓ v1) . . . B(↓ vk).

For the inclusion from the right to the left let α1 ∈ A|B(↓v1)[β], . . . αk ∈ A|B(↓vk)[β]. We
i=1 B(↓ vi).

show by induction that ∀p ∈ [1, k], τp = α1 ./ . . . ./ αp ∈ A|Yp [β] where Yp = Sp

Base case p = 1: Obvious.
Inductive case: Recall that by induction τp ∈ A|Yp [β] and observe that Yp ⊆ B(↑vp+1) so

there exists γ ∈ B(↑vp+1)[β] such that γ|Yp = τp.
By conjunctive decomposition on vp+1, α = γ ./ αp+1 ∈ A. Finally we have α|Yp+1 =
(γ ./ αp+1)|Yp∪B(↓vp+1) = γ|Yp ./ αp+1|B(↓vp+1) = τp ./ αp+1 = τp+1 so τp+1 ∈ A|Yp+1.
Thus τp+1 ∈ Yp[β] because τp+1|B(u) = β.

(cid:74)

XX:24 Linear Programs with Conjunctive Queries

774

775

776

777

778

779

780

781

782

783

784

785

786

787

788

789

790

791

792

793

794

795

796

797

798

799

800

801

802

C.4 Weightings correspondence

We are now ready to prove the main correspondence between weightings of A and weighting
collection on T :

(cid:73) Theorem 29. Let T = (V, E, B) be a normalized decomposition tree of X ⊆ X and A ⊆ DX
be a set of variable assignment that is conjunctively decomposed by T .
1. For every weighting ω of A, (πB(u)(ω))u∈V is a weighting collection on T for A.
2. For any weighting collection W on T for A there exists a weighting ω of A such that

∀u : Wu = πB(u)(ω).

(cid:73) Deﬁnition 30. Let T = (V, E, B) be a normalized decomposition tree of X and W =
(Wu)u∈V a weighting collection on T for A ⊆ DX .

For any node u ∈ V, ωu : A|B(↓u) → R+ is a weighting deﬁned by induction on well-

founded order on the nodes of tree T .

For the base case where u is a leaf of T , we deﬁne ωu such that for all α ∈ A|B(↓u):

ωu(α) = Wu(α)

For the induction step we suppose that ωu0 is deﬁned for all children u0 of u. With

β = α|B(u) we deﬁne ωu(α) for all α ∈ A|B(↓u).
If u is an extend node with a child v then:

ωu(α) =

( Wu(β)

Wv(α|B(v)) ωv(α|B(↓v))
0

if Wv(α|B(v)) > 0

otherwise.

If u is a project node with a child v then

ωu(α) = ωv(α|B(↓v)).

Observe that B(u) = B(v) so B(↓ u) = B(↓ v) thus ωv(α|B(↓v)) = ωv(α).
If u is a join node with children v1, . . . , vk then

ωu(α) =

Qk




ωvi (α|B(↓vi))

i=1

Wu(β)k−1



0

if Wu(β) > 0
otherwise.

(cid:73) Proposition 31. For all u ∈ V, Wu = πB(u)(ωu).

Proof. We show by bottom-up induction on the nodes of T that for all u ∈ V and β ∈ A|B(u),
P

α∈A|B(↓u)[β] ωu(α) = Wu(β).
The base case is clearly true by the deﬁnition of ωu when u is a leaf.

Case 1 u is an extend node with v its only child.

Let β ∈ A|B(u) and β0 = β|B(v).

Case 1.1 Wv(β0) = 0.

By deﬁnition ∀α ∈ A|B(↓u)[β], ωu(α) = 0.
Recall that by soundness P
A|B(u)[β0] so Wu(β) = 0 = P

β00∈A|B(u)[β0] Wu(β00) = Wv(β0) = 0. Observe that β ∈
α∈A|B(↓u)[β] ωu(α).

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:25

803

Case 1.2 Wv(β0) > 0.

P

α∈A|B(↓u)[β]
P

α∈A|B(↓u)[β] ωu(α)
= P
= Wu(β)
Wv(β0)
= Wu(β)
Wv(β0)
= Wu(β)
Wv(β0) Wv(β0)
= Wu(β)

P

Wu(β)
Wv(β0) ωv(α|B(↓v))
α∈A|B(↓u)[β] ωv(α|B(↓v))
α0∈A|B(↓v)[β0] ωv(α0)

by deﬁnition

by Lemma 27

by induction

804

Case 2 u is a project node with only child v.

P

α∈A|B(↓u)[β] ωu(α)
= P
= P
= P
= Wu(β)

α∈A|B(↓u)[β] ωu(α)
β0∈A|B(v)[β]
β0∈A|B(v)[β] Wv(β0)

P

α0∈A|B(↓u)[β0] ωv(α)

Case 3 u is a join node with children v1, . . . , vk.

Let β ∈ A|B(u).
Case 3.1 Wu(β) = 0.

By deﬁnition ∀α ∈ A|B(↓u)[β], ωu(α) = 0.
Thus P
α∈A|B(↓u)[β] ωu(α) = 0 = Wu(β).

Case 3.2 Wu(β) > 0.

P

α∈A|B(↓u)[β] ωu(α)
= P

α∈A|B(↓u)[β]

Qk

ωvi (α|B(↓vi))

i=1

Wu(β)k−1

αk∈A|B(↓vk )[β]

ωvi (αi)

= P
Qk

P

α1∈A|B(↓v1 )[β] · · · P

αi∈A|B(↓vi)[β]
Wu(β)k−1

i=1

Qk

=

=

Wvi (β)

i=1
Wu(β)k−1
Wu(β)k
Wu(β)k−1

=
= Wu(β)

by deﬁnition
by Proposition 21 and B(v) ⊆ B(↓ u)
by induction and B(↓ u) = B(↓ v)
by soundness at (u, v)

Qk

ωvi (αi)

i=1
Wu(β)k−1

by deﬁnition

by Lemma 28

by induction

by soundness at (u, vi)

(cid:74)

(cid:73) Lemma 32. Let v be the child of an extend node u, ∀α ∈ A|B(↓v) with β = α|B(v):

A[α] =

]

A[α ∪ β0]

β0∈A|B(u)[β]

Proof. For the inclusion from the left to the right, let τ ∈ A[α] and β0 = τ|B(u). Observe
that β0 ∈ A|B(u)[β]. Moreover B(↓ u) = B(↓ v) ∪ B(u) so τ|B(↓u) = α ∪ β0 so τ ∈ A[α ∪ β0].
β0∈A|B(u)[β] A[α ∪ β0]. By deﬁnition
(cid:74)

For the inclusion from the right to the left, let τ ∈ U

τ ∈ A and τ|B(↓v) = α so τ ∈ A[α].

(cid:73) Lemma 33. Given a join node u and its children v1, . . . , vk, let α ∈ A|B(↓v1) and β = α|B(u).

A|B(↓u)[α] = {α} ./ A|B(↓v2)[β] ./ . . . ./ A|B(↓vk)[β]

805

806

807

808

809

810

811

812

813

814

815

816

XX:26 Linear Programs with Conjunctive Queries

817

818

819

820

821

822

823

824

825

826

827

828

829

830

831

832

833

834

835

836

837

838

839

840

841

842

843

844

845

846

847

848

849

850

851

852

Proof. Clearly A|B(↓u)[α] = {τ ∈ A|B(↓u)[β] | τ|B(↓v1) = α} because β = α|B(u).

Thus by Lemma 28, A|B(↓u)[α] = {τ ∈ A|B(↓v1)[β] ./ . . . ./ A|B(↓vk)[β] | τ|B(↓u) = α} =
(cid:74)

{α} ./ A|B(↓v2)[β] ./ . . . ./ A|B(↓vk)[β]

(cid:73) Proposition 34. For all u ∈ V, ωu = πB(↓u)(ωr).

Proof. We show by top-down induction on the nodes of T that for all v ∈ V and α ∈ A|B(↓v),
P

τ ∈A[α] ωr(τ ) = ωv(α).
The base case is clearly true when v is the root r of T .
In the following we consider a given α ∈ A|B(↓v). and we let β = α|B(v)

Case 1 v is the only child of an extend node u.

By Lemma 32, P
equal to P

β0∈A|B(u)[β] ωu(α ./ β0).

τ ∈A[α] ωr(τ ) = P

β0∈A|B(u)[β]

P

τ ∈A[α∪β0] ωr(τ ). By induction this is

Case 1.1 Wv(β) = 0.

By deﬁnition of ωu, P
Observe that by Proposition 31, P
non-negative so ωv(α) = 0 = P

β0∈A|B(u)[β] ωu(α ./ β0) = 0.

τ ∈A[α] ωr(τ ).

α0∈A|B(↓u)[β] ωv(α0) = Wv(β) = 0. However ωv is

Case 1.2 Wv(β) > 0.

P

β0∈A|B(u)[β] ωu(α ./ β0)
= P
P

β0∈A|B(u)[β]

β0 ∈A|B(u)[β]
Wv(β)

=
= ωv(α)

Wu(β0)
Wv(β) ωv((α ./ β0)|B(↓v)) by deﬁnition
Wu(β0)

ωv(α)

by soundness at (u, v)

Case 2 v is the only child of a project node u.

Observe that B(↓ u) = B(↓ v) because u is a project node so by induction P
ωu(α) = ωv(α).

τ ∈A[α] ωr(τ ) =

Case 3 v is the child of a join node u.

Let v1, . . . , vn be the children of u, we assume wlog that v is v1.
By Proposition 21, P
τ ∈A[α] ωr(τ ) = P
By induction we obtain P

α0∈A|B(↓u)[α]

τ ∈A[α0] ωr(τ ).

α0∈A|B(↓u)[α] ωu(α0).

P

Case 3.1 Wu(β) = 0.

By deﬁnition of ωu, P
Recall that because u is a join node, Wv(β) = Wu(β) = 0 so similarly to Case 1.2,
ωv(α) = 0 = P
Case 3.2 Wv(β) > 0.

α0∈A|B(↓u)[α] ωu(α0) = 0.

τ ∈A[α] ωr(τ ).

ωvi (α0
By deﬁnition of ωu, P
α0∈A|B(↓u)[α] ωu(α0) = P
Wu(β)k−1
by Lemma 33 we can split α0 into α × α2 × · · · × αk and the sum into
Qk
P

ωvi (α0
. Observe that each term in the
Wu(β)k−1
product only depends on αi (or α for i = 1) and that the denominator only de-
pends on the ﬁxed β so we can rewrite the formula into the following ωv(α) ·
Qk

α2∈A|B(↓v2)[β] · · · P

αk∈A|B(↓vk )[β]

. Moreover

α0∈A|B(↓u)[α]

|B(↓vi))

|B(↓vi))

P

i=1

i=1

Qk

i=2

αi∈A|B(↓vi)[β]
Wu(β)k−1

ωvi (αi)

Finally observe that by soundness, Qk
Thus P
τ ∈A[α] ωr(τ ) = ωv(α).

Qk

Wvi (β)

i=2
Wu(β)k−1

i=2 Wvi(β) = Wu(β)k−1.

which is equal to ωv(α) ·

by Proposition 31.

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:27

853

854

855

856

of Theorem 29. The ﬁrst item follows directly from Proposition 23.

For the second item we know by Proposition 31 that Wu = πB(u)(ωu) which is equal to
(cid:74)

πB(u)(πB(↓u)(ωr)) by Proposition 34. Thus Wu = πB(u)(ωr) by Proposition 21.

(cid:74)

XX:28 Linear Programs with Conjunctive Queries

ω

c
(cid:75)
ξ
ω
(cid:75)
cS
ω
(cid:75)
S + S0

ω

(cid:75)

true

ω
(cid:75)
S ≤ S0

C ∧ C 0

ω

(cid:75)

ω

(cid:75)

(cid:74)
(cid:74)
(cid:74)
(cid:74)

(cid:74)

(cid:74)

(cid:74)

(cid:74)

= c
= ω(ξ)
S
= c ·
ω
(cid:74)
(cid:75)
ω +
S
=
(cid:75)

(cid:74)

S0

(cid:74)

ω

(cid:75)

= 1
(

1

=

=

(cid:74)

if

S

S0
ω ≤
(cid:75)
(cid:74)
otherwise.
C 0
(cid:74)

ω ∧

0
C

(cid:75)

(cid:74)

ω
(cid:75)

maximize S subject to C

= max({

S
(cid:74)

(cid:75)

ω
(cid:75)
ω | ω : Ξ → R+,
(cid:75)

.=1})

C

(cid:74)

ω

(cid:75)

Figure 10 Evaluation of linear sums, constraints and programs.

eval D,α(x) = α(x)
eval D,α(a) = aD
X (E1

sol D

.=E2) = {α : X → D | eval D,α(E1) = eval D,α(E2)}
X (r(E1, . . . , En)) = {α : X → D | (eval D,α(E1), . . . , eval D,α(En)) ∈ rD}

sol D

sol D

X (Q1 ∧ Q2) = sol D
sol D
sol D

X (Q1) ∩ sol D
X (∃x.Q) = {α|X | α ∈ sol D
X (true) = X dom(D)

X (Q2)
X∪{x}(Q)}

if x 6∈ X

Figure 11 Answer sets of conjunctive queries.

Proofs for Section 2 (Preliminaries)

Proofs for Section 3 (Linear Programs with Conjunctive Queries)

A

B

B.1 α-Renaming may change the semantics of linear C q-programs.

To illustrate this let x = (x1, x2) and L be the following linear C q-program:

maximize weightx:x2

.

=a(r(x)) subject to weightx(r(x)) ≤ 1.

Let D be a database with signature Σ = {r(2)} and interpretation rD = {(0, 0), (0, 1)}. If Q
is the query r(x) then the semantics of this linear C q-program hLiD is the linear program:

maximize θ(0,1)

Q

subject to θ(0,0)

Q + θ(0,1)

Q ≤ 1

Q + θ(0,1)
The optimal value hLiD is
hLiD
α-rename the second occurrence of x in L apart to x0 = (x0
C q-program L0:

= 1 since θ(0,0)

(cid:74)

(cid:75)

Q ≤ 1 and θ(0,0)

Q ≥ 0. Now let us
2) yielding the following linear

1, x0

maximize weightx:x2

.

=a(r(x)) subject to weightx0(r(x0)) ≤ 1.

The semantics hLiD is the following linear program where Q0 is r(x0) and Q is r(x):

maximize θ(0,1)

Q

subject to θ(0,0)

Q0 + θ(0,1)

Q0 ≤ 1

The optimal value of hL0iD is ∞ since θ(0,1)

is no more constrained: the renaming made
the variables of Q and Q0 diﬀerent, so that the variable assignments answering these queries

Q

857

858

859

860

861

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:29

sbsγ(Q ∧ Q0) = sbsγ(Q) ∧ sbsγ(Q0)

sbsγ(∃x.Q) = ∃x.sbsγ|dom(γ)\{x} (Q)

sbsγ(r(t1, . . . , tn)) = r(sbsγ(t1), . . . , sbsγ(tn))
if x ∈ dom(γ)
otherwise

(cid:26) γ(x)
x

sbsγ(x) =

sbsγ(a) = a

Figure 12 Lifting substitutions γ : fv(Q) → C to queries Q.

become diﬀerent too. Therefore, diﬀerent weights may be assigned to them. In other word
the tables of answers of Q and Q0 are diﬀerent, since their columns are named by diﬀerently,
by x and respectively x0.

C

Proofs for Section 4 (An Eﬃciently Solvable Fragment)

(cid:73) Lemma 14. For any T−projecting sum S ∈ SumΣ and environment γ : X → dom(D)
where fv(S) ⊆ X it holds that

hSiD,γ

.

.

ω =

ρT,D,γ(S)
(cid:75)

ω).

Π(

(cid:74)
Proof. By induction on the structure of S.

(cid:75)

(cid:74)

Case S = weightx:x0

.

=y(Q) where set(x0) ⊆ set(x) = fv(Q), set(y) ∩ set(x) = ∅ and

set(x0) = BQ(u) for some node u of TQ.
Let β = [x0/γ(y)].

hSiD,γ
(cid:74)

.

ω =
=

(cid:75)

P

P

P

(cid:74)

(cid:74)

α∈solD

set(x)

α∈solD

set(x)

Q

(Q∧sbsγ (Q0)) θα
(Q∧Vm
θα
Q

.
ω
(cid:75)
i=γ(yi)) θα

j=1

x0

.
ω

Q

=

(cid:74)
= P

= P

α∈solD

set(x)(Q)

α|B(u)=β

α∈solD

set(x)(Q)

α|B(u)=β

α∈solD(Q)[β]

(cid:75)
.
ω (θα
Q)

.
ω (θα
Q)

.
ω

(cid:75)

since set(x0) = BQ(u)

862

863

864

865

866

867

868

869

870

871

872

We distinguish two cases depending on whether β ∈ sol D(Q)|B(u):

If β /∈ sol D(Q)|B(u) then by deﬁnition of ρT,D,γ(S):

hSiD,α
(cid:74)

(cid:75)

.

ω =

X

.
ω (θα

Q) =

α∈solD(Q)[β]

X

α∈∅

.
ω (θα

Q) = 0 = ρT,D,γ(S)

873

.
If β ∈ sol D(Q)|B(u) then ξQ,u,β ∈ ΞT,D

L and thus by deﬁnition of ρT,D,γ(S):

hSiD,γ

(cid:74)

874

875

Case S = N .

Straightforward.

.
ω (θγ

Q)

by deﬁnition of Π

.

ω = P
(cid:75)
= Π(
=
=

γ∈solD(Q)[β]
.
ω)(ξQ,u,β)

.
ω)

ξQ,u,β
Π(
ρT,D,γ(S)
(cid:75)

(cid:75)

(cid:74)
(cid:74)

.
ω)

Π(

XX:30 Linear Programs with Conjunctive Queries

876

Case S = P

x:Q S0.

hSiD,γ
(cid:74)

(cid:75)

.

ω =

=

=

=

=

X

hS0iD,γ∪γ0

(cid:74)
γ0∈solD

(sbsγ (Q))

.
ω

(cid:75)

.
ω

(cid:75)

hS0iD,γ∪γ0

set(x)
X

set(x)
X

γ0∈solD

(sbsγ (Q))(cid:74)

γ0∈solD

set(x)

(sbsγ (Q))(cid:74)
X

(sbsγ (Q))

(cid:74)
γ0∈solD
ρT,D,γ(S)

set(x)

(cid:74)

.
ω)

Π(

(cid:75)

ρT,D,γ∪γ0

(S0)

.
ω)

Π(
(cid:75)

ρT,D,γ∪γ0

(S0)
(cid:75)

.

ω) by induction hyp.

Π(

Case S = N S. Straightforward.
Case S = S0 + S00.
Straightforward.

(cid:74)

(cid:73) Lemma 15. For any constraint C ∈ LcΣ that is T−projecting and environment γ : X →
ρT,D,γ(C)
dom(D) where fv(C) ⊆ X:

.

.

hCiD,γ
(cid:74)

(cid:75)

ω =

(cid:74)

ω).

Π(

(cid:75)

Proof. By induction on the structure of C.

Base case 1 C = true Obvious.
Base case 2 C = S ≤ S0 Straightforward using Lemma 14.
Induction step 1 C = C 0 ∧ C 00

Straightforward.

Induction step 2 C = ∀x:r(x).C

hCiD,γ
(cid:74)

(cid:75)

.

ω =
=

(cid:74)

(cid:74)

h∀x:r(x). C 0iD,γ
^

.
ω
(cid:75)
hC 0iD,γ∪γ0

.
ω
(cid:75)

.
ω

(cid:75)

hC 0iD,γ∪γ0

γ0∈solD

set(x)
^

(r(x))

(r(x))(cid:74)

γ0∈solD

set(x)
X

γ0∈solD

set(x)
^

ρT,D,γ∪γ0

(C 0)

(cid:74)

(cid:74)

(cid:74)

γ0∈solD(r(x))
ρT,D,γ(∀x:r(x).C 0)
ρT,D,γ(C)

.
ω)

Π(
(cid:75)

.
ω)

Π(
(cid:75)

=

=

=

=

=

(cid:73) Lemma 16. For any weighting
.
W = Π(
a weighting

.
ω of ΘQ such that

W of ΞT,D
L
.
ω).

.

ρT,D,γ∪γ0

(C 0)
(cid:75)

(r(x))(cid:74)

.

ω) by induction

Π(

.
ω)

Π(

(cid:75)

such that

(cid:74)

V

Q∈Q lscT,D(Q)

.
W
(cid:75)

= 1, there exists

(cid:74)

877

878

879

880

881
882

883

884

885

886

887

888

889

890

891

892

893

894

895

896

897

898

899

900

901
902

903

904

905

F. Capelli, N. Crosetti, J. Niehren and J. Ramon

XX:31

906

907

908

909

910

911

912

913

914

915

916

917

918

919

920

921

922

923

924

925

926

927

928

929

930

931

932

933

934

935

936

937

938

939

940

941

942

943

944

945

Proof. For each Q ∈ Q, let W Q = (W Q
ΞT,D
L .

u )u∈TQ where W Q

u (β) =

.
W (ξQ,u,β) for each ξQ,u,β ∈

Observe that it follows from the hypothesis that

= 1 so given a pair of nodes
(u, v) in TQ and a γ ∈ sol D(Q)|Buv then
β0∈A|B(v)[γ] ξQ,v,β0
.
.
W
By deﬁnition of W Q we then have P
u (β0). By deﬁnition
v ) so W Q is a weighting
of the projection of weightings it follows that πBuv (W Q
collection on TQ. Thus by Theorem 13 for each Q ∈ Q, there is a weighting ωQ : sol D(Q) → R+
.
ω: ΘQ → R+ such that
such that WQ = (πB(u)(ωQ))u∈V . Finally we deﬁne a weighting
.
ω (θα

lscT,D(Q)
.
W
(cid:75)
(cid:74)
β∈A|B(u)[γ] ξQ,u,β
.
W
u (β) = P

P
(cid:74)
β∈A|B(u)[γ] W Q

=
β0∈A|B(v)[γ] W Q

u ) = πBuv (W Q

Q) = ωQ(α) for each θα
We ﬁx a ξQ,u,β ∈ ΞT,D
α∈solD(Q)[β] ωQ(α). Thus W (ξQ,u,β) = Π(

Q ∈ ΘQ.
L . By deﬁnition W (ξQ,u,β) = W Q
.
ω)(ξQ,u,β) by deﬁnition of Π.

u (β) = (πB(u)(ωQ))(β) =
(cid:74)

P

P

(cid:75)

(cid:75)

(cid:74)

(cid:73) Proposition 17. Let D be a database and T a collection of decomposition tree. Any
T−projecting LP(CQ) program L = (maximize S subject to C) ∈ LpΣ satisﬁes that:
ρT,D(S)
1. For any solution
ρT,D(S)

.
ω of hLiD there is a solution
.
W of ρT,D(L) there is a solution

.
W of ρT,D(L) s.t.
.
ω of hLiD s.t.

2. For any solution

hSiD,∅
hSiD,∅

(cid:74)

(cid:74)

(cid:75)

.

.

.

ω =
ω =

.

(cid:74)

(cid:75)

(cid:74)

.
W
(cid:75)
.
W
(cid:75)

Proof. Let Q = cqs(L).
Case 1 Consider a solution

.
ω of hLiD.

Let
ρT,D(C)
.
W
(cid:75)
(cid:74)
ρT,D(S)
.
W
(cid:75)
(cid:74)
Case 2 Fixed solution

= 1 by Lemma 15. Thus
by Lemma 14.

.
W of ρT,D(L)

.
W be a weighting of ΘQ such that

.
W = Π(

.
ω). By hypothesis

hCiD,∅

.
W is a solution of ρT,D(L). Moreover

(cid:74)

.

ω = 1 so
(cid:75)
hSiD,∅
ω =
(cid:74)

(cid:75)

.

By Lemma 16 there is a weighting
ρT,D(C)
(cid:75)
(cid:74)
Moreover

.
ω of ΘQ such that
ω = 1 by Lemma 15. Thus
(cid:75)

by Lemma 14.

= 1 so

.

.
W
hSiD,∅
(cid:74)

(cid:75)

(cid:74)
ω =

.

hCiD,∅
ρT,D(S)
(cid:75)
(cid:74)

.
W

.
.
ω) By hypothesis
W = Π(
.
W is a solution of ρT,D(L).

(cid:74)

(cid:73) Theorem 18 (Removing Existential Quantiﬁers). For any projecting LP(CQ) program, the
LP(CQqf )proj program mvq(L) has the same optimal value as L.

Proof. It is clear that every Q appearing in a subexpression weightxz:Q0(Q) of mvq(L) is
quantiﬁer free by deﬁnition. Now, since L is in LP(CQ)proj, Q0 is of the form x0 = y where
x0 only contains free variables of ∃z.Q. Since fv(∃z.Q) ⊆ fv(Q), we have that x0 only contains
free variables of Q. Moreover, the other condition of LP(CQ)proj concerning the sum and
universal quantiﬁcation are still respected in mvq(L), thus L is in LP(CQqf )proj.
L → R+ be a solution of L. We deﬁne
mvq(L) → R+ as follows:
∃z.Q) where U = fv(∃z.Q) and N = #{β : z → dom | α ∪ β ∈ sol D(Q)}. It

: ΘD

.
ω0

Now, let
Q) = 1
(θα
N

.
ω: ΘD
.
.
ω0
ω (θα|U
is readily veriﬁed that the value
.
ω0
and thus that

is a solution of mvq(L) and
: ΘD

.
ω0

For the other way around, given
.
L → R+ as
ω (θα

∃z.Q) = P

β|α∪β∈solD(Q)

weightx:Q0(∃z.Q)
(cid:75)
mvq(L)
ω =
(cid:75)
(cid:75)

L
(cid:74)

(cid:74)

.

.

0.

.
ω

ω is the same as

.
ω: ΘD
value
of L and

(cid:74)

(cid:74)

ω is the same as
weightx:Q0(∃z.Q)
(cid:75)
mvq(L)
ω =
(cid:74)

L
(cid:75)

.
ω
(cid:75)

0.

(cid:74)

.

.

weightx,z:Q0(Q)

0

.
ω

(cid:75)

(cid:74)

mvq(L) → R+ a solution of mvq(L), we construct
Q ). Again, it is readily veriﬁed that the
.
ω is a solution
0 and thus that
(cid:74)

.
ω0
(θα∪β
weightx,z:Q0(Q)

.
ω

(cid:75)

(cid:74)

