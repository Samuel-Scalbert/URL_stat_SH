General Acyclicity and Cyclicity Notions for the
Disjunctive Skolem Chase
Lukas Gerlach, David Carral

To cite this version:

Lukas Gerlach, David Carral. General Acyclicity and Cyclicity Notions for the Disjunctive Skolem
Chase. AAAI 2023 - 37th Conference on Artificial Intelligence, Feb 2023, Washington, United States.
pp.6372-6379, ￿10.1609/aaai.v37i5.25784￿. ￿hal-04212112￿

HAL Id: hal-04212112

https://hal.science/hal-04212112

Submitted on 21 Sep 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

General Acyclicity and Cyclicity Notions for the Disjunctive Skolem Chase
(Extended Technical Report)

Lukas Gerlach,1 David Carral2
1 Knowledge-Based Systems Group, TU Dresden, Dresden, Germany
2 LIRMM, Inria, University of Montpellier, CNRS, Montpellier, France
lukas.gerlach@tu-dresden.de, david.carral@inria.fr

Abstract

The disjunctive skolem chase is a sound, complete, and po-
tentially non-terminating procedure for solving boolean con-
junctive query entailment over knowledge bases of disjunc-
tive existential rules. We develop novel acyclicity and cyclic-
ity notions for this procedure; that is, we develop suffi-
cient conditions to determine chase termination and non-
termination. Our empirical evaluation shows that our novel
notions are significantly more general than existing criteria.

1

Introduction

Solving query entailment over knowledge bases (KBs) of
disjunctive existential rules is a relevant decision problem,
which is readily defined as follows:

• Input: a set R of disjunctive existential rules, a set F of

facts, and a boolean conjunctive query (BCQ) γ.

• Output: yes iff γ is a logical consequence of the KB

⟨R, F⟩ under standard first-order semantics.1
One approach to solve BCQ entailment in practice is to
apply the disjunctive skolem chase (?), which is a materi-
alization procedure that aims to compute a finite universal
model set for an input KB. If fully computed, this model
set can then be used to solve query entailment: a BCQ γ is
a logical consequence of a KB K iff γ is satisfied by every
model in a universal model set of K iff γ is satisfied by every
model in the output of the chase on input K.

Because the chase is sound and complete for BCQ entail-
ment, and this problem is undecidable (?); the chase does
not terminate on all inputs. Even worse, we cannot decide if
this procedure terminates on a given input (??). Hence, the
best one can do is to study acyclicity notions; that is, suffi-
cient conditions that confirm chase termination. In our con-
text, acyclicity notions are sufficient conditions that charac-
terize terminating rule sets: A rule set R is terminating if the
chase terminates on every KB of the form ⟨R, F⟩. To know
if our acyclicity notions are as general as they can be, we
also study cyclicity notions; that is, sufficient conditions for
non-termination. In this paper, we focus on the skolem chase

Copyright © 2023, Association for the Advancement of Artificial
Intelligence (www.aaai.org). All rights reserved.

1Rules, facts, and BCQs are first-order logic formulas, which

we formally define in the following section.

variant (?), which makes use of skolem terms that are used
to satisfy existential restrictions when computing a universal
model set.

While acyclicity notions for rule sets without disjunctions
have been around for a while (??????), the first acyclic-
ity notions for disjunctive rule sets were proposed fairly re-
cently (?). In their work, ? extended model-faithful acyclic-
ity (MFA)2 for the disjunctive setting and developed the first
cyclicity notion for the (disjunctive) skolem chase, named
model-faithful cyclicity (MFC). To the best of our knowl-
edge, these are the only existing (a)cyclicity notions for non-
deterministic rule sets.

We have empirically verified that MFA and MFC are quite
effective at determining (non-)termination of rule sets with-
out disjunctions: Using both notions, we are able to estab-
lish (non-)termination of around 99% of the deterministic
rule sets in our evaluation; see Section C.1. However, in the
presence of disjunctions, we could only establish the termi-
nation status of around 67% of the considered rule sets using
MFA and MFC; see Section 5.

Our main goal is thus clear: We aim to develop gen-
eral (a)cyclicity notions that can be used to determine chase
(non-)termination of most real-world rule sets with disjunc-
tions. More precisely, our contributions are as follows:
• In Sections 3 and 4, we present our novel (a)cyclicity no-
tions, respectively. Moreover, we study the complexity of
checking if a rule set is (a)cyclic and the complexity of
solving BCQ entailment over KBs with acyclic rule sets.
• In Section 5, we empirically show that MFA and MFC
are significantly less general than our novel conditions,
which allow us to establish (non-)termination of many of
the (non-deterministic) rule sets in our test suite.

• In Sections 6 and 7, we discuss related research and elab-

orate on possible follow-up work, respectively.
This extended report features complete proofs (Sections A
and B) and additional empirical results (Section C), which
we do not include in the 7-page submission.

2 Preliminaries
We define Cons, Vars, Funs, and Preds to be mutually dis-
joint, finite (albeit large enough) sets of constants, variables,

2MFA was originally introduced in (?) as a very general skolem

acyclicity notion for deterministic rule sets.

function symbols, and predicates, respectively, such that ev-
ery s ∈ Funs ∪ Preds has an arity ar(s) ≥ 1. For every
i ≥ 1, let Funsi = {f | ar(f ) = i} and Predsi = {P |
ar(P ) = i}. The set Terms of terms includes Cons ∪ Vars
and contains f (t1, . . . , tn) for every n ≥ 1, f ∈ Funsn,
and t1, . . . , tn ∈ Terms. A term t is functional if t /∈
Cons ∪ Vars. Given a first-order formula or a term υ, and a
set X ∈ {Cons, Vars, Funs(i), Terms, Preds(i) | i ≥ 1}; let
X(υ) be the set of all elements in X that occur in υ.

We write lists t1, . . . , tn of terms as ⃗t, which we often
treat as sets. For a term t, let depth(t) = 1 if t is not func-
tional and depth(t) = 1 + max(depth(s1), . . . , depth(sn))
if t is of the form f (s1, . . . , sn). A term s is a subterm of
another term t if t = s, or t is of the form f (⃗s) and s is
a subterm of some term in ⃗s. For a term t, let subterms(t)
be the set of all subterms of t. A term is cyclic if it has a
subterm of the form f (⃗s) such that f ∈ Funs(⃗s).

An atom is a first-order formula of the form P (⃗t) where P
is a |⃗t|-ary predicate and ⃗t is a term list. A fact is a variable-
free atom. For a first-order formula υ, we write υ[⃗x] to indi-
cate that ⃗x is the set of all free variables that occur in υ; that
is, those variables that are not explicitly quantified in υ.
Definition 1. A (disjunctive existential) rule is a constant-
and function-free first-order formula of the form
∃⃗yi.ηi[⃗xi, ⃗yi](cid:1)

∀ ⃗w, ⃗x.(cid:0)β[ ⃗w, ⃗x] →

(cid:95)n

(1)

i=1

where n ≥ 1; ⃗w, ⃗x, ⃗y1, . . . , ⃗yn are pairwise disjoint lists of
variables; (cid:83)n
i=1 ⃗xi = ⃗x; ⃗x1, . . . , ⃗xn are non-empty; and β,
η1, . . . , ηn are non-empty conjunctions of atoms.

A rule ρ as in (1) is deterministic if n = 1, generating if it
features at least one existential variable, and datalog if it is
deterministic and not generating. We call ⃗x the frontier of ρ
and denote it as frontier(ρ). Moreover, let body(ρ) = β and
headi(ρ) = ηi for every 1 ≤ i ≤ n. Often, we omit univer-
sal quantifiers when writing rules and treat conjunctions of
atoms, such as body(ρ), as sets.

A (boolean conjunctive) query γ is a first-order formula
of the form ∃⃗y.β[⃗y] with β a non-empty atom conjunction. A
knowledge base (KB) K is a pair ⟨R, I⟩ with R a rule set and
I an instance; that is, a function-free fact set. We write K |=
γ to denote that (the first-order formula) (cid:86)
φ∈I φ
entails γ under standard first-order semantics. In the follow-
ing, we provide a procedural definition of query entailment
via the chase algorithm; see Proposition 1. Without loss of
generality, we assume that (†) y /∈ Vars(R \ {ρ}) for every
rule set R, every rule ρ = β → (cid:87)n
i=1 ∃⃗yi.ηi in R, and every
y ∈ (cid:83)n
i=1 ⃗yi; that is, existentially quantified variables do not
reoccur across different rules in the same rule set.

ρ∈R ρ ∧ (cid:86)

A (ground) substitution σ is a partial function that maps
variables to terms without occurrences of variables. We use
[x1/t1, . . . , xn/tn] to denote the substitution that maps the
variable xi to the term ti for every 1 ≤ i ≤ n. For a first-
order formula υ, let υσ be the formula that results from re-
placing every occurrence of every variable x in the domain
of σ in υ with σ(x).

(cid:83)n

Consider a rule ρ as in (1) in a rule set R. For every y ∈
i=1 ⃗yi, let fy ∈ Funs be a fresh |⃗x|-ary function symbol,

which is unique for ρ within R due to (†). For every 1 ≤
i ≤ n, let sk(ηi) be the conjunction obtained by replacing
every occurrence of every variable y ∈ ⃗yi in ηi by fy(⃗x). Let
sk(ρ) = β → (cid:87)n

i=1 sk(ηi) and sk(R) = {sk(ρ) | ρ ∈ R}.

A trigger λ is a pair ⟨ρ, σ⟩ with ρ a rule as in (1) and σ a
substitution with domain ⃗w ∪ ⃗x. The trigger λ is loaded for
a fact set F if βσ ⊆ F; it is active for F if sk(ηi)σ ⊈ F
for all 1 ≤ i ≤ n. Let outi(λ) = sk(ηi)σ for 1 ≤ i ≤ n;
out(λ) = {outi(λ) | 1 ≤ i ≤ n}. A fact set F is closed
under a rule ρ if no trigger with ρ is loaded and active for F.
Consider a rule set R. An R-term is a term defined using
the function symbols that occur in sk(R), some constants,
and some variables. A substitution is an R-substitution if its
range is a set of R-terms. An R-trigger is a trigger with a
rule from R and an R-substitution.

Definition 2. A (skolem) chase tree of a KB ⟨R, I⟩ is a di-
rected tree T = ⟨V, E, fct, trg⟩ such that:

1. Let V be a set of vertices, E a set of edges, fct a labeling
function that maps the vertices in V to fact sets (fact la-
bels), and trg a labeling function that maps the vertices
in V to R-triggers (trigger labels) or ϵ.

2. For the root r of T , we have fct(r) = I and trg(r) = ϵ.
3. Consider some non-leaf vertex v ∈ V with children U =
{u | ⟨v, u⟩ ∈ E}. There is an R-trigger λ that is loaded
and active for fct(v), {fct(u) | u ∈ U } = {F ∪ fct(v) |
F ∈ out(λ)}, |U | = |out(λ)|, and trg(u) = λ for each
u ∈ U . Moreover, if ρ is not datalog, then fct(v) is closed
under every datalog rule in R (that is, datalog-first).
4. Every leaf fact label is closed under all rules in R. More-
over, for every R-trigger λ, there is some k ≥ 1 such that
λ is not loaded or not active for fct(v) for every v ∈ V
of depth at least k (that is, fairness).

Consider a chase tree T = ⟨V, E, fct, trg⟩ for a KB
⟨R, I⟩. A branch B of a chase tree T is a sequence
v1, v2, . . . ∈ V such that v1 is the root of T , ⟨vi, vi+1⟩ ∈ E
for every 1 ≤ i < |B|, and if B is finite then its last element
is a leaf in T . That is, a branch is a maximal path in T .

A KB terminates if it only admits finite chase trees. A rule
set R terminates if every KB of the form ⟨R, I⟩ terminates.
It is undecidable to determine if R terminates already for
deterministic rule sets (?).

The result of a chase tree T is the set of all fact sets that
can be constructed by taking the union of all fact labels in a
branch of T . Hence, the result of a finite chase tree T is the
set of fact labels of its leaves. In the presence of disjunctions,
chase trees for the same KB may yield different results:

Example 1. Consider the KB ⟨{P (x, y) → ∃z.H(y) ∧
S(y, z), P (x, y) → H(y) ∨ ∃w.P (y, w)}, {P (a, b)}⟩. We
can produce a finite chase tree by prioritizing the applica-
tion of the first rule and an infinite one by delaying it. The
former results in: {{P (a, b), H(b), S(b, fz(b))}}

Finite chase results can be used to solve query entailment:

Proposition 1. Consider the result R of some (arbitrarily
chosen) chase tree of a K. Then, K entails a query γ = ∃⃗y.β
iff F |= γ for every F ∈ R iff for every F ∈ R there is a
substitution σ with βσ ⊆ F.

3 Acyclicity Notions
In Section 3.1, we recall MFA (?). In Section 3.2, we present
disjunctive model-faithful acyclity, based on ideas from (?).

3.1 Model-Faithful Acyclicity (MFA)
To determine if a deterministic rule set R is MFA we check
the fact set MFA(R), which contains all facts that may oc-
cur in a chase tree of a KB with R modulo replacement of
constants with ⋆; we formalize this intuition in Lemma 1.
Definition 3. The critical instance I⋆ is the set of all facts
with any predicate in (the finite set) Preds and the special
constant ⋆; that is, I⋆ = {P (⋆, . . . , ⋆) | P ∈ Preds}.

For a deterministic rule set R, let MFA(R) ⊇ I⋆ be the
minimal fact set that includes out1(λ) for every (determin-
istic) R-trigger λ that is loaded for MFA(R).

Definition 4. A constant mapping g is a partial function
from Cons to Terms. For a term t, let g(t) be the term that
results from replacing every occurrence of every c in the do-
main of g in t with g(c).

We can prove the following via induction on a chase tree:

Lemma 1. For a fact label F in a chase tree of a KB with a
deterministic rule set R, we have g⋆(F) ⊆ MFA(R) where
g⋆ is the constant mapping that maps every constant to ⋆.

Consider a chase tree T for a KB ⟨R, I⟩. By Lemma 1, the
depth of the terms that occur in T is bounded by the depth
of the terms in MFA(R) since depth(t) = depth(g⋆(t)) for
every term t. Since only a finite number of terms of bounded
depth can be defined with the constants that occur in I,
finiteness of MFA(R) implies finiteness of T . Therefore:

Lemma 2. If MFA(R) is finite for some deterministic rule
set R, then R terminates.

Consider a deterministic rule set R. Then, MFA(R) is fi-
nite iff ⟨R, I⋆⟩ terminates. ? have shown that we cannot de-
cide the latter; hence, we cannot decide if MFA(R) is finite
either. However, we can compute this set up to the occur-
rence of a cyclic term.

Definition 5. A deterministic rule set R is MFA if no cyclic
term occurs in MFA(R).

The occurrence of a cyclic term indicates that a rule ρ is
applied in a chase tree to produce a descendant of a term in-
troduced to satisfy ρ. In many real-world cases, this implies
that infinitely many applications of ρ may follow.

The following theorem is a corollary of Lemma 2 and the
fact that, for a deterministic rule set R, the fact set MFA(R)
is finite if it does not feature cyclic terms:

Theorem 3. Deterministic MFA rule sets terminate.

MFA was originally defined for rule sets without disjunc-
tions (?). ? came up with a straightforward way to extend
this acyclicity notion for the disjunctive setting; see Theo-
rem 4.

Definition 6. For a rule ρ as in (1) and a rule set R, let
ρ∧ = β → ∃⃗y1, . . . , ⃗yn. (cid:86)n
i=1 ηi and R∧ = {ρ∧ | ρ ∈ R}.
Theorem 4. A rule set R terminates if R∧ terminates.

Applying Theorems 3 and 4, we can extend MFA (and
any other deterministic skolem acyclicity notion) so it can
be applied rule sets with disjunctions:
Definition 7. A rule set R is MFA if R∧ is MFA.
Corollary 5. MFA rule sets terminate.

3.2 Disjunctive MFA (DMFA)
To determine if a (possibly non-deterministic) rule set R is
DMFA, we look for cyclic terms in the fact set DMFA(R),
which has the same property as MFA(R∧). Namely, this
fact set contains all facts that may occur in a chase tree
of a KB with R modulo replacement of all constants with
⋆; see Lemma 9. However, DMFA(R) is a tighter over-
approximation than MFA(R∧); in fact, later on we show that
DMFA(R) is a subset of MFA(R∧) for every rule set R; see
the proof of Theorem 11.

In order to minimize DMFA(R), we adjust the notion of
blockedness,3 which we use to characterize harmless trig-
gers that are never applied in any chase tree:
Example 2. Consider R = {(2–5)}, which is a slightly
simplified subset of rule set 00007.owl in the Oxford On-
tology Repository (see Section 5):

evidence(x) → ∃w.Confidence(x, w)

Confidence(x, y) → confidence(y)
Confidence(x, y) → ∃z.XRef(y, z)

(2)
(3)
(4)
XRef(x, y) → evidence(x) ∨ confidence(x) (5)

Consider a chase tree T = ⟨V, E, fct, trg⟩ for a KB of the
form ⟨R, I⟩ and suppose for a contradiction that trg(v) =
⟨(5), [x/fw(t), y/fz(fw(t))]⟩ for some v ∈ V and a term t.
Then, Confidence(t, fw(t)) ∈ fct(p) with p the parent of v
since fw(t) may only be introduced in T via the application
of (2). Moreover, confidence(fw(t)) ∈ fct(p) since fct(p)
is closed under (3); see Item 3 in Definition 2. But then, the
trigger trg(v) is not active for fct(p)! In fact, we can use
blockedness to show that triggers such as trg(v) may never
occur as a trigger labels in a chase tree of a KB with R.

To define blockedness, we introduce the fact set U(R, λ)
for a given rule set R and a trigger λ. Intuitively, this fact set
can be “homomorphically embedded” into the fact label of
a vertex v in a chase tree T of a KB with R if λ is applied to
v in T ; see Lemma 6.
Definition 8. Let R be a rule set and t an R-term.
• If t is not functional, then U(R, t) = ∅.
• Otherwise, t is of the form fy(⃗s) and there is exactly one
rule ρ = β[ ⃗w, ⃗x] → (cid:87)n
i=1 ∃⃗yi.ηi[⃗xi, ⃗yi] ∈ R and exactly
one 1 ≤ ℓ ≤ n with y ∈ ⃗yℓ. Then, U(R, t) = βσ ∪
outℓ(⟨ρ, σ⟩) ∪ (cid:83)
s∈⃗s U(R, s) where σ is a substitution
with ⃗xσ = ⃗s and ⃗wσ = ⃗c for fresh constants ⃗c.
Consider an R-trigger λ = ⟨ρ, σ⟩. Then, let U(R, λ) be
the minimal fact set that includes body(ρ)σ and U(R, t) for
every t in the range of σ, and that is closed under every
datalog rule in R if ρ is not datalog.

3(?) have introduced a very similar notion for the restricted

chase.

An R-trigger λ is blocked for a rule set R if its rule is not

datalog and λ is not active for U(R, λ).
Lemma 6. Consider a chase tree T = ⟨V, E, fct, trg⟩ of
a KB ⟨R, I⟩. Then, for every v ∈ V , there is a constant
mapping g that is the identity on Cons(fct(v)) such that
A. g(U(R, t)) ⊆ fct(v) for every t ∈ Terms(fct(v)) and
B. g(U(R, trg(u))) ⊆ fct(v) for every ⟨v, u⟩ ∈ E.

Consider some trigger λ (with a non-datalog rule) that is
blocked for R and suppose for a contradiction that λ is the
trigger label of a vertex u in a chase tree T of a KB with R.
Then, λ is not active for the fact label of the parent v of u in
T by Lemma 6, which contradicts Definition 2. Therefore:
Lemma 7. If a trigger λ is blocked for R, then λ does not
occur as a trigger label in any chase tree of a KB with R.

Relying on blockedness, we can safely ignore many facts

when we define the over-approximation DMFA(R):
Definition 9. For a rule set R, let DMFA(R) ⊇ I⋆ be the
fact set that includes all sets in out(⟨ρ, σ⟩) for every R-
trigger ⟨ρ, σ⟩ such that (i) ⟨ρ, σ⟩ is loaded for DMFA(R)
and (ii) ⟨ρ, σr⟩ is not blocked for R.

In the above, let σr be a substitution such that, for every
x ∈ domain(σ), the term σr(x) is obtained by replacing ev-
ery occurrence of a constant in σ(x) with a fresh constant.4
We need σr to generalize over all possible KBs with R.

All “less general” triggers will also be blocked:
Lemma 8. For a trigger ⟨ρ, σ⟩, a rule set R, and a constant
mapping g; if ⟨ρ, σr⟩ is blocked for R, then so is ⟨ρ, g ◦ σr⟩.
Armed with Lemmas 7 and 8, we can readily show the fol-
lowing result via induction on the structure of a chase tree:
Lemma 9. For a fact label F in a chase tree of a KB ⟨R, I⟩,
we have that g⋆(F) ⊆ DMFA(R) where g⋆ is the constant
mapping that maps every constant to ⋆.

As for MFA, we simply compute DMFA(R) up to the oc-
currence of a cyclic term to check if a rule set R is DMFA:
Definition 10. A rule set R is DMFA if no cyclic term oc-
curs in DMFA(R).
Theorem 10. DMFA rule sets terminate.

A rule set R is DMFA if it is MFA since DMFA(R) is a
subset of MFA(R) by Definitions 3 and 9. Furthermore, the
rule set in Example 2 is DMFA but not MFA. Therefore:
Theorem 11. If a rule set R is MFA, then it is DMFA. More-
over, the converse of this implication does not hold.

The number of acyclic terms that one can define with the
functions in Funs(sk(R)) and ⋆ is double-exponential in R;
hence, so is |DMFA(R)|. Moreover, for an instance I, we
have that |Terms(DMFA(R))| · |Cons(I)| is an upper bound
for the number of terms in any chase tree of ⟨R, I⟩. Once we
realise these claims, we can readily show that:
Theorem 12. DMFA-membership is 2EXPTIME-complete.
Theorem 13. Deciding query entailment for a KB with an
DMFA rule set is coN2EXPTIME-complete.

4 Cyclicity Notions
Cyclicity notions are sufficient conditions that characterize
non-terminating rule sets. In fact, the conditions we consider
in this section imply a stronger form of non-termination:
Definition 11. A rule set R never terminates if there is a KB
⟨R, I⟩ that does not admit any finite chase tree.

In Section 4.1, we recall MFC (?). In Section 4.2, we
present disjunctive model-faithful cyclicity (DMFC), which
is based on ideas from the same authors.

4.1 Model Faithful Cyclicity (MFC)
Intuitively speaking, the idea behind MFC (?) is to check if
a generating rule is reapplied when starting on a minimal in-
stance that mimics a fact label where the rule has just been
applied. If the rule is indeed reapplied and yields a cyclic
term, then it can be applied infinitely many times; see Theo-
rem 14.
Definition 12. For a rule ρ as in (1) and some 1 ≤ k ≤
n, let Iρ,k = body(ρ)σuc ∪ outk(⟨ρ, σuc⟩) where σuc is a
substitution that maps every variable x to a fresh constant
cx. If ρ is deterministic, we define Iρ = Iρ,1.

Given a rule set R and a deterministic rule ρ ∈ R, we first
define the fact set MFC(R, ρ), which consists of facts that
appear on all branches of all chase trees of ⟨R, body(ρ)σuc⟩.
Note that we use body(ρ)σuc instead Iρ in the previous KB
because the latter may feature function symbols and hence,
it may not be an instance.
Definition 13. For a rule set R and a deterministic rule ρ ∈
R, let MFC(R, ρ) ⊇ Iρ be the minimal fact set that includes
out1(λ) for every R-trigger λ such that (i) λ is loaded for
MFC(R, ρ), (ii) the rule in λ is deterministic, and (iii) the
substitution in λ does not feature cyclic terms in its range.
Condition (iii) ensures that MFC(R, ρ) is always finite.
Definition 14. A rule set R is MFC if a ρ-cyclic term occurs
in MFC(R, ρ) for a deterministic rule ρ ∈ R. That is, a term
of the form f (⃗s) with f ∈ Funs(sk(ρ)) and f ∈ Funs(⃗s).
If R is MFC, then ⟨R, body(ρ)σuc⟩ does not terminate:

Theorem 14. MFC rule sets are never terminating.

Sketch. If a rule set R is MFC, then MFC(R, ρ) features
a ρ-cyclic term t for a deterministic rule ρ ∈ R. Hence,
there is a list of R-triggers applied during the construction
of MFC(R, ρ) that leads to t. More precisely, there is a list
λ1, . . . , λn such that, for every 1 ≤ i ≤ n: (i) λi = ⟨ρi, σi⟩,
(ii) out1(λi) ⊆ MFC(R, ρ), (iii) ρi is deterministic, (iv) λi
is loaded for Iρ ∪ (cid:83)i−1
j=1 out1(λj), (v) out1(λn) features a ρ-
cyclic term, and (vi) (cid:83)n−1
j=1 out1(λj) does not. This list can
be extended into an infinite sequence: For every 1 ≤ i ≤ n
and j ≥ 1, let λj
i be the R-trigger ⟨ρi, g◦j−1 ◦ σi⟩ where g
is the constant mapping with σn = g ◦ σuc.5

Consider a chase tree T = ⟨V, E, fct, trg⟩ of the KB K =
⟨R, body(ρ)σuc⟩. Then, for every branch v1, v2, . . . ∈ V of
T , we can show via structural induction that the following

4For example, σr = [x/f (b, c), y/d] if σ = [x/f (a, a), y/a].

5Note that g◦0 = idTerms, g◦1 = g, g◦2 = g ◦ g, and so on.

holds: For every 1 ≤ i ≤ n and j ≥ 1, the trigger λj
i is
loaded for fct(vk) for some k ≥ 1 and out1(λj
i ) ⊆ fct(vℓ)
for some ℓ ≥ k. Hence, every branch of T is infinite by (v)
and (vi) and hence, K does not admit finite chase trees.

The induction step at the end of the previous sketch is easy

to show once one realizes that:
Lemma 15. Consider a vertex v in a branch B of a chase
tree T = ⟨V, E, fct, trg⟩ of a KB ⟨R, I⟩, and an R-trigger
λ. If λ features a deterministic rule and is loaded for fct(v),
then fct(v) ∪ out1(λ) ⊆ fct(u) for some u ∈ B.

Intuitively, this means that, once a deterministic trigger is
loaded for a vertex v in a chase tree, every branch with v
includes the output of this trigger. Note that such a result
does not hold for non-deterministic triggers; see Example 2.

4.2 Disjunctive Model-Faithful Cyclicity (DMFC)
We ignore non-deterministic rules when deciding MFC
membership (see Definition 13). Hence, this notion fails to
characterise non-terminating rule sets such as:
Example 3. Consider the rule set R = {R(x, y) → A(y) ∨
B(y), A(x) → ∃y.R(x, y)}, which never terminates since
every chase tree for ⟨R, {A(c)}⟩ features (exactly) one infi-
nite branch. However, R is not MFC; to establish never ter-
mination we need to take the disjunctive rule into account.
We consider head-choices to deal with disjunctive rules:
Definition 15. A head-choice is a function hc that maps ev-
ery rule β → (cid:87)n
i=1 ∃⃗yi.ηi to some 1 ≤ j ≤ n. For a trigger
λ = ⟨ρ, σ⟩, let outhc(λ) = outhc(ρ)(λ).

Later on, we show that some rule sets are not terminating
by focusing on the branch in a tree induced by a head-choice:
Definition 16. For a chase tree T = ⟨V, E, fct, trg⟩ and
a head-choice hc, let branch(T, hc) = v1, v2, . . . be the
branch of T such that fct(vi+1) = outhc(trg(vi+1))∪fct(vi)
for every 1 ≤ i < |branch(T, hc)|.

To use disjunctive rules to witness non-termination, we
identify triggers that need to be applied once they are loaded.
To do so, we define unblockable triggers6 ⟨ρ, σ⟩ for a rule
set R and a head-choice hc, which satisfy the following:

I. Consider a chase tree T of a KB with R. If λ becomes
loaded in branch(T, hc), then outhc(λ) is eventually in-
cluded in branch(T, hc); that is, Lemma 16.

II. Unblockability propagates across an infinite family of
triggers. Namely, if a constant mapping g is reversible
(see Definition 18), then the trigger ⟨ρ, g ◦ σ⟩ is also
unblockable; that is Lemma 17.

Definition 17. Let R be a rule set and t an R-term.
• If t is not functional, then H(R, t) = ∅.
• Otherwise, t is of the form fy(⃗s) and there is exactly one
rule ρ = β[ ⃗w, ⃗x] → (cid:87)n
i=1 ∃⃗yi.ηi[⃗xi, ⃗yi] ∈ R and ex-
actly one 1 ≤ ℓ ≤ n with y ∈ ⃗yℓ. Then, H(R, t) =
outℓ(⟨ρ, σ⟩) ∪ (cid:83)
s∈⃗s H(R, s) where σ is a substitution
with ⃗xσ = ⃗s.

6Again, (?) introduced a very similar notion for the restricted

chase.

Consider an R-trigger λ = ⟨ρ, σ⟩. Then, let H(R, λ)
be the minimal fact set that includes H(R, t) for every t
in the range of σ restricted to variables in frontier(ρ). Ad-
ditionally, let the term-skeleton of λ be skeletonR(λ) =
Terms(H(R, λ)) ∪ Cons({σ(x) | x ∈ frontier(ρ)}).

For a rule ρ = β → (cid:87)n
i=1 η′

i=1 ∃⃗yi.ηi, let star(ρ) = β →
(cid:87)n
i is the con-
junction that results from replacing every occurrence of ev-
ery y ∈ ⃗yi in ηi with ⋆.

i be the (non-generating) rule where η′

For a rule set R, a head-choice hc, and an R-trigger λ,

let O(R, hc, λ) be the minimal fact set that includes:
• The set H(R, λ).
• The set of all facts that can be defined using any predicate

and constants in Cons(skeletonR(λ)) ∪ {⋆}.

• The set outhc(⟨star(ρ), σ⟩) for every R-trigger ⟨ρ, σ⟩
loaded for O(R, hc, λ) with outhc(λ) ̸= outhc(⟨ρ, σ⟩).
The trigger λ is unblockable for R and hc if it features a

deterministic rule or if it is active for O(R, hc, λ).
Lemma 16. Consider a chase tree T = ⟨V, E, fct, trg⟩ of a
KB ⟨R, I⟩, a head-choice hc, some v ∈ branch(T, hc), and
an R-trigger λ. If λ is loaded for fct(v), and it is unblock-
able for R and hc; then fct(v) ∪ outhc(λ) ⊆ fct(u) for some
u ∈ branch(T, hc).

Sketch. For a term t, let hλ(t) = t if t ∈ skeletonR(λ) and
hλ(t) = ⋆ otherwise. We have that, if outhc(λ) ⊈ fct(w) for
some w ∈ branch(T, hc), then hλ(fct(w)) ⊆ O(R, hc, λ)
(see Lemma 21). That is, O(R, hc, λ) “over-approximates”
fact labels in branch(T, hc) that do not include outhc(λ).

Assume that the premise of the lemma holds. If ρ is de-
terministic, the claim holds by Lemma 15. Otherwise, λ is
active for the “over-approximation” O(R, hc, λ). Hence, λ
remains active for the fact labels in branch(T, hc) up until
its output is included in the branch by Lemma 21.

Definition 18. Consider a set T of terms that includes
subterms(t) for every t ∈ T . A constant mapping g is re-
versible for T if (i) the domain of g is Cons(T ), (ii) t ̸= s
implies g(t) ̸= g(s) for every t, s ∈ T , and (iii) for every
c ∈ Cons(T ) and every s ∈ subterms(g(c)), there is no
functional term u ∈ T with g(u) = s.
Lemma 17. Consider a rule set R, a head-choice hc, an
R-trigger ⟨ρ, σ⟩, and a constant mapping g that is re-
versible for skeletonR(⟨ρ, σ⟩). If ⟨ρ, g ◦ σ⟩ is an R-trigger
and ⟨ρ, σ⟩ is unblockable for R and hc, then so is ⟨ρ, g ◦ σ⟩.

Sketch. Assume that
the premise of the lemma holds.
If ρ is deterministic, the claim holds by Definition 17.
Otherwise, ⟨ρ, σ⟩ is active for O(R, hc, ⟨ρ, σ⟩). Hence,
⟨ρ, g ◦ σ⟩ is also active for O(R, hc, ⟨ρ, g ◦ σ⟩) since
h(O(R, hc, ⟨ρ, g ◦ σ⟩)) ⊆ O(R, hc, ⟨ρ, σ⟩) with h the func-
tion defined as follows: For a term t, let h(t) = s if there is
a term s that occurs in skeletonR(⟨ρ, σ⟩) with g(s) = t,
and h(t) = ⋆ otherwise. Note that h is well-defined because
g is reversible (see (ii) in Definition 18), and the inclusion
holds because O(R, hc, ⟨ρ, σ⟩) contains all facts that can be
defined with constants in skeletonR(⟨ρ, σ⟩) and ⋆.

We are ready to define DMFC and prove it sound:

Definition 19. Consider a rule set R, a head-choice hc,
and a rule ρ ∈ R. Then, let DMFC(R, hc, ρ) ⊇ Iρ,hc(ρ)
be the fact set that includes outhc(λ) for every R-trigger
λ = ⟨ψ, σ⟩ such that (i) λ is loaded for DMFC(R, hc, ρ),
(ii) λ is unblockable for R and hc, (iii) there are no cyclic
terms in the range of σ, (iv) there is a frontier variable
x ∈ frontier(ψ) with σ(x) being functional if ψ is non-
datalog, and (v) σ is injective if ψ = ρ.
Definition 20. A rule set R is DMFC if DMFC(R, hc, ρ)
features a ρ-cyclic term for a ρ ∈ R and a head-choice hc.
Theorem 18. DMFC rule sets are never terminating.

Sketch. If a rule set R is DMFC, then DMFC(R, hc, ρ) fea-
tures a ρ-cyclic term t for some head-choice hc and some
ρ ∈ R. Then, there is a list λ1, . . . , λn of unblockable R-
triggers applied during the construction of DMFC(R, hc, ρ)
that yields t. More precisely; for every 1 ≤ i ≤ n; let
λi = ⟨ρi, σi⟩; outhc(λi) ⊆ DMFC(R, hc, ρ); the trigger
λi is unblockable for R and hc, and is loaded for Iρ ∪
(cid:83)i−1
j=1 outhc(λj); the function σn is injective; and outhc(λn)
features a ρ-cyclic term and (cid:83)n−1
j=1 outhc(λj) does not. As in
Theorem 14, we extend this list into an infinite sequence: For
every 1 ≤ i ≤ n and every j ≥ 1, let λj
i = ⟨ρi, g◦j−1 ◦ σi⟩
where g is the constant mapping with σn = g ◦ σuc.

i=1 outhc(λj

Let F = Iρ,hc(ρ) ∪ (cid:83)

i ) and as-
sume (for now) that g is reversible for Terms(F). We
show that branch(T, hc) is infinite for every tree T of
⟨R, body(ρ)σuc⟩. First, Iρ,hc(ρ) occurs in some fact label
in branch(T, hc); otherwise, λn would not be unblockable.
Then, by induction, for every 1 ≤ i ≤ n and j ≥ 1, the
trigger λj
i is loaded for some fact label in branch(T, hc) and
hence, some fact label in the branch includes outhc(λj
i ) by
Lemma 16. We can apply this lemma here because g is re-
versible and hence, λj

i is unblockable by Lemma 17.

It remains to show that g is reversible for Terms(F) to

(cid:83)n

j≥1

complete our proof. First, we show the claims below:
a. There are no ρ-cyclic terms in (cid:83)n−1

j=1 outhc(λj). There-
fore, for every constant c in F, the term g(c) does not
feature nested function symbols from sk(ρ).7

b. By (iv) in Definition 19: For every functional term t oc-
curring in DMFC(R, hc, ρ), there is some subterm s of t
that is also functional and that occurs in Iρ,hc(ρ); that is, s
is of the form f (⃗c) with f ∈ Funs(sk(ρ)) and ⃗c a list con-
taining every constant in σuc(frontier(ρ)). We can extend
this claim to all functional terms in F via induction.
c. There is some constant c ∈ σuc(frontier(ρ)) such that
g(c) features a function symbol from sk(ρ). Otherwise
outhc(λn) would not feature a ρ-cyclic term.

d. By (b) and (c): For every functional term t in F, the term

g(t) features nested function symbols from sk(ρ).

To verify that g is reversible for the terms in F we sep-
arately prove (i), (ii), and (iii) from Definition 18. The first
one holds since the domain of g is Cons(Iρ,hc(ρ)).

7The term fy(fz(c)) features nested function symbols from

sk(A(x) → ∃y, z.R(x, y, z)) while fw(fy(c), fz(d)) does not.

To show (ii), we check that g(t) ̸= g(s) for every t, s ∈
Terms(F) with t ̸= s via structural induction on t. Regard-
ing the base case, we consider two cases: If t and s are con-
stants, then g(t) ̸= g(s) since (σn and) g are injections. If
t is a constant and s is functional, then g(s) features nested
function symbols from sk(ρ) by (d) and g(t) does not by
(a). Regarding the induction step, we again consider two
cases: If t and s are functional terms of the form f (⃗t) and
h(⃗s), respectively, with f ̸= h; then g(t) ̸= g(s) since
g(t) = f (g(⃗t)) and g(s) = h(g(⃗s)). If t and s are func-
tional terms of the form f (t1, . . . , tn) and f (s1, . . . , sn), re-
spectively; then ti ̸= si for some 1 ≤ i ≤ n since t ̸= s,
g(ti) ̸= g(si) by induction hypothesis, and g(t) ̸= g(s).

Finally, we show that (iii) holds by contradiction. Con-
sider a functional term t ∈ Terms(F) with g(c) = t for
some constant c and assume that there is a functional term u
and a subterm s of t such that g(u) = s. By (a), the term t
does not feature nested function symbols from sk(ρ); hence,
s does not feature them either. However, s features nested
functional symbols from sk(ρ) by (d)!

Because of (iv) and (v) in Definition 19, DMFC is not
more general than MFC. However, in our experiments, we
did not find a single rule set that is MFC but not DMFC.

Regarding complexity, checking MFC and DMFC is dom-
inated by the number of acyclic terms, which is double-
exponential in the size of the given rule set (??).

Theorem 19. (D)MFC-membership is 2EXPTIME-comp.

5 Evaluation
We present experiments to show the generality of our no-
tions in practice. We describe our implementation, the rule
sets we use, and the results of our experiments. The tools,
rule sets, and results of the evaluation are available online.8
Further information on the concrete steps to reproduce the
evaluation steps is also provided there.

To avoid an exponential number of checks, we consider a

simplified version of DMFC in our implementation:
Definition 21. For a rule ρ = β → (cid:87)n
j=1 ∃⃗zj.ηj and some
i ≥ 1, let hci(ρ) = n if i > n and hci(ρ) = i if i ≤ n. A
rule set R is DMFCs if, for some ρ ∈ R and some i ≥ 1,
the fact set DMFC(R, ρ, hci) features a ρ-cyclic term.

By definition, DMFCs implies DMFC so it ensures never
termination. We consider an improvement of DMFA in our
implementation, which guarantees termination by Lemma 9:
Definition 22. A rule set R is DMFAk for some k ≥ 1 if
DMFA (R) does not feature any k-cyclic term; that is, a term
with k + 1 nested occurrences of the same function symbol.

We obtain the rule sets in the evaluation from OWL on-
tologies via normalization and translation into rules; see
Section 6 in (?). We drop OWL axioms with “at-most re-
strictions” and “nominals” because their translation requires
the use of equality; one can incorporate this feature via
axiomatisation (?). The ontologies come from the Oxford

8https://doi.org/10.5281/zenodo.7375461 ?

#∃

# tot.

# fin.

MFA

DMFA

D
F
X
O

1–19
20–99
100+
1+

5 1–19
20–99
1
E
100–999
R
O
1–999
L 1–19
20–99
W
O
100–299
M
1–299

37
18
82
137

103
119
278
500

36
17
26
79

98
105
219
422

21
3
4
28 (35%)

51
32
5
88 (20%)

1361
894
448
2703

1283
740
254
2277

676
104
25
805 (35%)

28
3
6
37 (46%)

66
33
6
105 (24%)

725
114
25
864 (37%)

DMFA2

28
3
6
37 (46%)

66
35
119
220 (52%)

732
121
111
964 (42%)

MFC

4
10
14
28 (35%)

18
54
89
161 (38%)

173
301
103
577 (25%)

DMFCs
8
14
19
41 (51%)

31
69
100
200 (47%)

515
610
143
1268 (55%)

Table 1: Skolem Chase Termination: Non-Deterministic Rule Sets

Ontology Repository (OXFD),9 the dataset of the OWL
Reasoner Evaluation 2015 (ORE15),10 and the Manchester
OWL Corpus (MOWL).11 Here, we only consider rule sets
with at least one disjunctive and one generating rule. De-
terministic rule sets are covered largely by MFA and MFC
already; see Section C for results about these rule sets.

We count the number of rule sets that are MFA, DMFA(2),
MFC, and DMFCs and present our results in Table 1. We set
a timeout of 30 minutes for each check and only consider
rule sets for which all checks finished; we indicate the num-
ber of attempted vs finished rule sets by # tot. and # fin.,
respectively. We group results by the number of generating
rules, indicated by #∃. For instance, in the second row in
Table 1 we indicate: There are 18 rule sets in the OXFD
corpus with at least 20 but at most 99 generating rules; all
checks finished for 17 of these; 3 of these are MFA; etc.

If we use MFA and MFC, the percentage of finished rule
sets that are fully classified (i.e., sets that are MFA or MFC)
for OXFD, ORE15, and MOWL are 70%, 58%, and 60%,
respectively. Our improved notions are significantly more
general; if we apply them, we can now classify 97%, 99%,
and 97% of the finished rule sets in these repositories. More-
over, the use of DMFA2 allows us to detect that many (hith-
erto unclassified) rule sets terminate for the skolem chase!

6 Related Work
? and ? showed that checking chase termination for linear
and guarded deterministic rule sets, respectively, is decid-
able.

Definition 23. A rule ρ is linear if it features a single atom
in its body; it is guarded if it features an atom in its body that
contains all of the universally quantified variables in ρ.

Note that all linear rules are guarded, and that over half
of the rule sets in Table 1 are not guarded since they con-
tain rules of the form (cid:86)n
i=1 Ri(xi−1, xi) → R(x0, xn) with

9https://www.cs.ox.ac.uk/isg/ontologies/
10https://doi.org/10.5281/zenodo.18578 ?
11https://doi.org/10.5281/zenodo.16708 ?

n ≥ 2. In Section C.2, we present separate results for non-
guarded rule sets; these are rather similar percentage-wise to
those presented in Table 1.

Theorem 4 allows us to extend any deterministic skolem
acyclicity notions for non-deterministic rule sets. Instead of
MFA, we could consider the following:

Definition 24. For a computable function δ over the nat-
urals, a rule set R is δ-bounded if the depth of terms in
MFA(R) is bounded by δ(|R|).

For a computable function δ over the naturals, we can
decide δ-bounded membership and this property implies
instead of considering δ-
termination (?). Alternatively,
boundedness, one can simply increase the number k in Def-
inition 22 to achieve a similar effect. In fact, we ran some
tests and only found 2 rule sets that are DMFA5 but not
DMFA2. Hence, we have decided to not publish results for
k > 2 and believe that using δ-boundedness would not result
in a big increase in performance in practice.

7 Conclusions and Future Work

We present novel (a)cyclicity notions that allow us to estab-
lish the termination status of most rule sets in our test suite.
As for immediate future work, we plan to extend our no-
tions to the restricted chase and investigate why some rule
sets are not classified as (non)-terminating. Potentially, we
fail to capture these because they are “sometimes” non-
terminating; that is, they may occur in KBs that admit fi-
nite and infinite chase trees. We would also like to develop
a normalisation procedure that preserves both query entail-
ment and chase termination.

As a long term goal, we would like to adapt our notions so
they can be applied in other areas of knowledge representa-
tion and reasoning. For instance, we believe that we can use
our ideas to (i) show if an ASP program with function sym-
bols does or does not admit a finite solution or (ii) determine
if DPLL(T) algorithms used in automated theorem proving
will terminate or not for many real-world inputs.

Acknowledgments
Lukas is funded by Deutsche Forschungsgemeinschaft
(DFG, German Research Foundation) in project 389792660
(TRR 248, Center for Perspicuous Systems), by the Bun-
desministerium f¨ur Bildung und Forschung (BMBF, Federal
Ministry of Education and Research) under European ITEA
project 01IS21084 (InnoSale, Innovating Sales and Planning
of Complex Industrial Products Exploiting Artificial Intelli-
gence), by BMBF and DAAD (German Academic Exchange
Service) in project 57616814 (SECAI, School of Embedded
and Composite AI), and by the Center for Advancing Elec-
tronics Dresden (cfaed).

David is funded by the ANR project CQFD (ANR-18-

CE23-0003).

References
Baget, J.; Garreau, F.; Mugnier, M.; and Rocher, S. 2014.
Extending Acyclicity Notions for Existential Rules.
In
Schaub, T.; Friedrich, G.; and O’Sullivan, B., eds., ECAI
2014 - 21st European Conference on Artificial Intelligence,
2014, Czech Republic - Including Prestigious Applications
of Intelligent Systems (PAIS 2014), volume 263 of Frontiers
in Artificial Intelligence and Applications, 39–44. IOS Press.
Beeri, C.; and Vardi, M. Y. 1981. The Implication Problem
for Data Dependencies.
In Even, S.; and Kariv, O., eds.,
Automata, Languages and Programming, 8th Colloquium,
Israel, 1981, Proceedings, volume 115 of Lecture Notes in
Computer Science, 73–85. Springer.
Bourhis, P.; Manna, M.; Morak, M.; and Pieris, A. 2016.
Guarded-Based Disjunctive Tuple-Generating Dependen-
cies. ACM Trans. Database Syst., 41(4): 27:1–27:45.
Calautti, M.; Gottlob, G.; and Pieris, A. 2015. Chase Termi-
nation for Guarded Existential Rules. In Milo, T.; and Cal-
vanese, D., eds., Proceedings of the 34th ACM Symposium
on Principles of Database Systems, PODS 2015, Australia,
2015, 91–103. ACM. ISBN 978-1-4503-2757-2.
Cal`ı, A.; Gottlob, G.; and Pieris, A. 2010. Query Answer-
ing under Non-guarded Rules in Datalog+/-. In Hitzler, P.;
and Lukasiewicz, T., eds., Web Reasoning and Rule Systems
- 4th International Conference, RR 2010, Italy, 2010. Pro-
ceedings, volume 6333 of Lecture Notes in Computer Sci-
ence, 1–17. Springer.
Carral, D.; Dragoste, I.; and Kr¨otzsch, M. 2017. Restricted
Chase (Non)Termination for Existential Rules with Disjunc-
In Sierra, C., ed., Proceedings of the 26th Inter-
tions.
national Joint Conference on Artificial Intelligence, IJCAI
2017, Australia, 2017, 922–928. ijcai.org.
Carral, D.; and Urbani, J. 2020. Checking Chase Termina-
tion over Ontologies of Existential Rules with Equality. In
The 34th AAAI Conference on Artificial Intelligence, AAAI
2020, The Thirty-Second Innovative Applications of Artifi-
cial Intelligence Conference, IAAI 2020, The Tenth AAAI
Symposium on Educational Advances in Artificial Intelli-
gence, EAAI 2020, USA, 2020, 2758–2765. AAAI Press.
Cuenca Grau, B.; Horrocks, I.; Kr¨otzsch, M.; Kupke, C.;
Magka, D.; Motik, B.; and Wang, Z. 2013. Acyclicity No-

tions for Existential Rules and Their Application to Query
Answering in Ontologies. J. Artif. Intell. Res., 47: 741–808.
Fagin, R.; Kolaitis, P. G.; Miller, R. J.; and Popa, L. 2005.
Data exchange: semantics and query answering. Theor.
Comput. Sci., 336(1): 89–124.
Gerlach, L.; and Carral, D. 2022. General Acyclicity and
Cyclicity Notions for the Disjunctive Skolem Chase - Eval-
uation Material. https://doi.org/10.5281/zenodo.7375461.
Gogacz, T.; and Marcinkowski, J. 2014. All-Instances
Termination of Chase is Undecidable.
In Esparza, J.;
Fraigniaud, P.; Husfeldt, T.; and Koutsoupias, E., eds., Au-
tomata, Languages, and Programming - 41st Int. Collo-
quium, ICALP 2014, Denmark, 2014, Proc., Part II, vol-
ume 8573 of Lecture Notes in Computer Science, 293–304.
Springer.
Grahne, G.; and Onet, A. 2018. Anatomy of the Chase. Fun-
dam. Informaticae, 157(3): 221–270.
Karimi, A.; Zhang, H.; and You, J. 2021. Restricted Chase
Termination for Existential Rules: A Hierarchical Approach
and Experimentation. Th. Pract. Log. Program., 21(1): 4–
50.
Kr¨otzsch, M.; and Rudolph, S. 2011. Extending Decidable
Existential Rules by Joining Acyclicity and Guardedness. In
Walsh, T., ed., IJCAI 2011, Proceedings of the 22nd Inter-
national Joint Conference on Artificial Intelligence, Spain,
2011, 963–968. IJCAI/AAAI.
Lecl`ere, M.; Mugnier, M.; Thomazo, M.; and Ulliana, F.
2019. A Single Approach to Decide Chase Termination on
In Barcel´o, P.; and Calautti, M.,
Linear Existential Rules.
eds., 22nd International Conference on Database Theory,
ICDT 2019, 2019, Portugal, volume 127 of LIPIcs, 18:1–
18:19. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik.
Marnette, B. 2009. Generalized schema-mappings: from ter-
mination to tractability.
In Paredaens, J.; and Su, J., eds.,
Proceedings of the 28th ACM SIGMOD-SIGACT-SIGART
Symposium on Principles of Database Systems, PODS 2009,
2009, USA, 13–22. ACM.
Matentzoglu, N.; Tang, D.; Parsia, B.; and Sattler, U. 2014.
The Manchester OWL Repository: System Description. In
Horridge, M.; Rospocher, M.; and van Ossenbruggen, J.,
eds., Proceedings of the ISWC 2014 Posters & Demonstra-
tions Track a track within the 13th International Semantic
Web Conference, ISWC 2014, Italy, 2014, volume 1272 of
CEUR Workshop Proceedings, 285–288. CEUR-WS.org.
Parsia, B.; Matentzoglu, N.; Gonc¸alves, R. S.; Glimm, B.;
and Steigmiller, A. 2016. The OWL Reasoner Evaluation
(ORE) 2015 Resources. In Groth, P.; Simperl, E.; Gray, A.
J. G.; Sabou, M.; Kr¨otzsch, M.; L´ecu´e, F.; Fl¨ock, F.; and Gil,
Y., eds., The Semantic Web - ISWC 2016 - 15th International
Semantic Web Conference, Japan, 2016, Proc, Part II, vol-
ume 9982 of Lecture Notes in Computer Science, 159–167.
Zhang, H.; Zhang, Y.; and You, J. 2015. Existential Rule
Languages with Finite Chase: Complexity and Expressive-
ness. In Bonet, B.; and Koenig, S., eds., Proceedings of the
Twenty-Ninth AAAI Conference on Artificial Intelligence,
2015, USA, 1678–1685. AAAI Press.

A Proofs for Section 3
Since many of the proofs regarding our newly defined no-
tions rely heavily on existing ideas from (?), we prove again
all previous results again to be self-contained.

A.1 Model-Faithful Acyclicity
Lemma 1. For a fact label F in a chase tree of a KB with a
deterministic rule set R, we have g⋆(F) ⊆ MFA(R) where
g⋆ is the constant mapping that maps every constant to ⋆.

Proof. Consider a chase tree T = ⟨V, E, fct, trg⟩ of a KB
⟨R, I⟩ with a deterministic rule set. We verify via structural
induction on T that g⋆(fct(v)) ⊆ MFA(R) for every v ∈ V .

• We have that g⋆(fct(r)) ⊆ I⋆ with r the root vertex of T
since fct(r) is an instance. Therefore, the base case holds
since I⋆ ⊆ MFA(R).

• Regarding the induction step, consider some non-root

vertex c and its parent p in T .
1. By induction hypothesis: g⋆(fct(p)) ⊆ MFA(R).
2. Since ⟨p, c⟩ ∈ E: the trigger trg(c) = ⟨ρ, σ⟩ is loaded
for fct(p) and fct(c) = fct(p)∪out1(trg(c)). Note that
ρ is a deterministic rule.

3. By (1) and (2): ⟨ρ, g⋆ ◦ σ⟩ is loaded for MFA (R).
4. By (3): out1(⟨ρ, g⋆ ◦ σ⟩) ⊆ MFA(R).
5. By (1), (2), and (4): g⋆(fct(c)) ⊆ MFA(R) and the

induction step holds.

Lemma 2. If MFA(R) is finite for some deterministic rule
set R, then R terminates.

Proof. We show the contrapositive of the lemma.

1. Assume that R is not terminating.
2. By (1): there is a KB of the form ⟨R, I⟩ that admits an
infinite chase tree T = ⟨V, E, fct, trg⟩. Hence, there is a
branch B of T that is infinite.

3. By (2): the fact set F = (cid:83)

v∈B fct(v) is infinite. There-

fore, the set Terms(F) is also infinite.

4. By (2) and (3): Cons(F) = Cons(I) and Funs(F) ⊆

Funs(sk(R)). Hence, these sets are finite.

5. By (3) and (4): the depth of the terms in Terms(F) is
unbounded. That it, for every i ≥ 1, there is a term t ∈
Terms(F) with depth(t) ≥ i.

6. By (3) and Lemma 1: g⋆(F) ⊆ MFA(R).
7. By (5) and (6): Terms(MFA(R)) is infinite since g⋆ pre-
serves the depth of the terms. Hence, MFA(R) is infinite.

Theorem 3. Deterministic MFA rule sets terminate.

Proof. If a deterministic rule set R is MFA, then MFA(R)
does not feature cyclic terms. Hence, MFA(R) is finite since
there is only a finite number of non-cyclic terms that can be
defined using a single constant (that is, ⋆) and finitely many
function symbols (that is, Funs(sk(R))). By Lemma 2, the
rule set R terminates.

Theorem 4. A rule set R terminates if R∧ terminates.

Proof. For an instance I, there is exactly one fact set F in
chase(⟨R∧, I⟩) since R∧ is deterministic. To show the the-
orem, we verify the following claim via induction: Given
some chase tree T = ⟨V, E, fct, trg⟩ for ⟨R, I⟩, we have
that fct(v) ⊆ F for every v ∈ V . The base case holds since
the fact label of the root vertex of T is I, which is a subset of
F. Regarding the induction step, consider a non-root vertex
c and its parent p in T :

1. By induction hypothesis: fct(p) ⊆ F.
2. Since ⟨p, c⟩ ∈ E: trg(c) = ⟨ρ, σ⟩ is loaded for fct(p) and

fct(c) = outℓ(⟨ρ, σ⟩) ∪ fct(p) for some ℓ ≥ 1.

3. By (1) and (2): ⟨ρ∧, σ⟩ is loaded for F.
4. By (3) and since F is in the result of a (fair) chase tree of

⟨R∧, I⟩: out1(⟨ρ∧, σ⟩) ⊆ F.

5. By the definition of ρ∧: out1(⟨ρ∧, σ⟩) includes all fact
sets in out(⟨ρ, σ⟩). In particular, note that out1(⟨ρ∧, σ⟩)
includes outℓ(⟨ρ, σ⟩).

6. By (1), (2), (4), and (5): the fact set F includes fct(c) and

the induction step holds.

Corollary 5. MFA rule sets terminate.

Proof. This follows directly from Theorems 3 and 4.

A.2 Disjunctive Model-Faithful Acyclicity
We first introduce an auxiliary result, which we later use in
the proof of Lemma 7:

Lemma 6. Consider a chase tree T = ⟨V, E, fct, trg⟩ of
a KB ⟨R, I⟩. Then, for every v ∈ V , there is a constant
mapping g that is the identity on Cons(fct(v)) such that

A. g(U(R, t)) ⊆ fct(v) for every t ∈ Terms(fct(v)) and
B. g(U(R, trg(u))) ⊆ fct(v) for every ⟨v, u⟩ ∈ E.

Proof. We first focus on Claim A. Namely, we define the
constant mapping g via induction on the structure of the
terms that occur in fct(v) and at the same time show that it
satisfies Claim A. Regarding the base case, we set g(c) = c
for every c ∈ Cons(fct(v)). Note that Claim A holds since
U(R, c) = ∅ for every c ∈ Cons. Regarding the induction
step, we describe how to define g(t) when t is an R-term of
the form fy(⃗s):

1. By induction hypothesis: we have that g(U(R, s)) ⊆

fct(v) for every R-term s ∈ ⃗s.

2. Since t occurs in fct(v), there is some vertex u ∈ V with

trg(u) = ⟨ρ, σ⟩ such that:
a. Either u = v or u is an ancestor of v in T .
b. The term t does not occur in the range of σ, and t

occurs in outℓ(trg(u)) for some ℓ ≥ 1.

Put differently, u is the (non-root) vertex in T such that t
occurs in fct(u), t does not occur in the fact label of the
parent of u, and u is in some branch that contains v.

3. Consider the rule ρ = β[ ⃗w, ⃗x] → (cid:87)n

i=1 ∃⃗yi.ηi[⃗xi, ⃗yi] ∈
R. By (2) and Assumption (†) in Section 2, this is the
only rule in R that features the variable y. More pre-
cisely, y ∈ ⃗yℓ and y /∈ ⃗yi for every i ∈ {1, . . . , n} \ {ℓ}.

4. By (2) and (3): σ(⃗x) = ⃗s
5. Consider the substitution τ such that U(R, t) = βτ ∪
outℓ(⟨ρ, τ ⟩) ∪ (cid:83)
s∈⃗s U(R, s) and the list ⃗c of (fresh) con-
stants such that τ ( ⃗w) = ⃗c. We extend g so that g(⃗c) =
σ( ⃗w). Note that we can extend the function g in this man-
ner without breaking its “functionality” because the con-
stants in ⃗c are fresh.

6. By (2), (4), and (5): g(βτ ) = βσ, g(outℓ(⟨ρ, τ ⟩)) =

outℓ(⟨ρ, σ⟩), and βσ ∪ outℓ(⟨ρ, σ⟩) ⊆ fct(u).

7. By (2.a): βσ ∪ outℓ(⟨ρ, σ⟩) ⊆ fct(v).
8. By (1), (6), and (7): g(U(R, t)) ⊆ fct(v).

Regarding Claim B, consider some ⟨v, u⟩ ∈ E and the
trigger trg(u) = ⟨ψ, τ ⟩. Then, every term in the range of
τ also occurs in Terms(fct(v)), the trigger trg(u) is loaded
for fct(v) (that is, body(ψ)τ ⊆ fct(v)), and fct(v) is closed
under all of the datalog rules in R if trg(u) features a non-
datalog rule by Definition 2. Therefore, g(U(R, trg(u))) ⊆
fct(v) by Definition 8 and Claim A.

Lemma 7. If a trigger λ is blocked for R, then λ does not
occur as a trigger label in any chase tree of a KB with R.

Proof. Let T = ⟨V, E, fct, trg⟩ be a tree of a KB ⟨R, I⟩.

1. Assume that λ is blocked for R.
2. Suppose for a contradiction that there is some (non-root)
vertex c ∈ V with trg(c) = λ. Furthermore, let p be the
parent of c in T .

3. By (2): λ is active for fct(p).
4. By (2) and Lemma 6: there is a constant mapping g such
that g(U(R, λ)) is a subset of fct(p) and g is the identity
over Cons(fct(p)).

5. By (1) and Definition 8: λ is not active for U(R, λ).
6. By (4) and (5): λ is not active for g(U(R, λ)) and hence,

it is not active for fct(p).
7. By (3) and (6): contradiction!

Lemma 8. For a trigger ⟨ρ, σ⟩, a rule set R, and a constant
mapping g; if ⟨ρ, σr⟩ is blocked for R, then so is ⟨ρ, g ◦ σr⟩.

Proof. 1. Assume that ⟨ρ, σr⟩ is blocked for R.
2. By (1) and Definition 8: ⟨ρ, σr⟩ is not active for

U(R, ⟨ρ, σr⟩).

3. By (2): ⟨ρ, g ◦ σr⟩ is not active for g(U(R, ⟨ρ, σr⟩)).
4. By Definition 8: g(U(R, ⟨ρ, σr⟩)) ⊆ U(R, ⟨ρ, g ◦ σr⟩).
for
5. By (3)

and (4):

⟨ρ, g ◦ σr⟩

is not

active

U(R, ⟨ρ, g ◦ σr⟩) and hence it is blocked for R.

The proof of the following result is similar to that of
Lemma 1. The main difference is the application of Lem-
mas 7 and 8 to verify that, for every trigger label in a chase
tree of a KB ⟨R, I⟩, we have a corresponding trigger in the
DMFA(R) construction that is not blocked.

Lemma 9. For a fact label F in a chase tree of a KB ⟨R, I⟩,
we have that g⋆(F) ⊆ DMFA(R) where g⋆ is the constant
mapping that maps every constant to ⋆.

Proof. Consider some chase tree T = ⟨V, E, fct, trg⟩ for
the KB ⟨R, I⟩. We verify via structural induction on T that
g⋆(fct(v)) ⊆ DMFA(R) for every vertex v ∈ V .

• For r the root vertex of T , we have that g⋆(fct(r)) ⊆ I⋆
since fct(r) is an instance. Therefore, the base case holds
since I⋆ ⊆ DMFA(R).

• Regarding the induction step, consider some non-root

vertex c and its parent p in T .
1. By induction hypothesis: g⋆(fct(p)) ⊆ MFA(R).
2. Since ⟨p, c⟩ ∈ E: trg(c) = ⟨ρ, σ⟩ is loaded for fct(p)
and fct(c) = outℓ(⟨ρ, σ⟩) ∪ fct(p) for some ℓ ≥ 1.
3. By (1) and (2): ⟨ρ, g⋆ ◦ σ⟩ is loaded for DMFA(R).
4. By (2) and the contrapositive of Lemma 7: ⟨ρ, σ⟩ is not

blocked.

5. Since all constants are renamed apart in (g⋆◦σ)r, there
exists a constant mapping h with σ = h ◦ (g⋆ ◦ σ)r.
6. By (4), (5), and the contrapositive of Lemma 8:

⟨ρ, (g⋆ ◦ σ)r⟩ is not blocked.

7. By (3), (6), and Definition 9: the set DMFA (R) con-

tains outℓ(⟨ρ, g⋆ ◦ σ⟩).

8. By (1), (2), and (7): g⋆(fct(c)) ⊆ DMFA(R). Note

that g⋆(outℓ(⟨ρ, σ⟩)) = outℓ(⟨ρ, g⋆ ◦ σ⟩).

The proof of the following lemma is analogous to that of

Lemma 2; simply plug in Lemma 9 instead of Lemma 1.

Lemma 20. If DMFA(R) is finite for some deterministic
rule set R, then R terminates.

Proof. We show the contrapositive of the claim. If R is not
terminating, then there is a KB of the form ⟨R, I⟩ that ad-
mits an infinite skolem chase tree T = ⟨V, E, fct, trg⟩. Since
T is infinite and since there is only a finite number of con-
stants in I, the set {g⋆(fct(v)) | v ∈ V } is infinite. By
Lemma 9, DMFA (R) is infinite as well.

The proof of the following theorem is analogous to that of
Theorem 3; simply plug in Lemma 20 instead of Lemma 2.

Theorem 10. DMFA rule sets terminate.

Proof. If a rule set R is DMFA, DMFA(R) does not feature
cyclic terms. Hence, DMFA(R) is finite since there is only
a finite number of non-cyclic terms that one can construct
using a single constant and finitely many function symbols.
By Lemma 20, R terminates.

We only include sketches for Theorems 12 and 13 because
their proofs are extremely similar to those of Theorem 5 and
7, respectively, in (?).

Theorem 12. DMFA-membership is 2EXPTIME-complete.

Sketch. Membership. The number of terms and facts in
DMFA(R) is double-exponentially bounded in the size of
R. Hence, for the construction of DMFA(R) at most double-
exponentially many steps are necessary of which each one
takes at most double-exponential time.

Hardness. A deterministic rule set R is MFA iff it is
DMFA, since MFA(R) = DMFA(R) because triggers with
deterministic rules are never blocked. Therefore, DMFA
membership is as hard as MFA membership, which is 2EXP-
TIME-hard (?).

Theorem 13. Deciding query entailment for a KB with an
DMFA rule set is coN2EXPTIME-complete.

Sketch. Membership. Non-entailment of a query can be de-
cided by non-deterministically guissing a branch in a chase
tree that yields a model that does not entail the query. Since
the rule set in question is DMFA, there are at most doubly
exponentially many terms and facts and hence, query entail-
ment can be decided in coN2EXPTIME.

Hardness. Hardness is established based on the simula-
tion of a 2EXPTIME Turing machine with weakly acyclic
rules by ? (?). We can modify the construction so that non-
determinism is simulated by disjunctive rules. Note that
weakly acylic rule sets are DMFA.

B Proofs for Section 4
In Section B.1, we show that MFC implies never termination
(Theorem 14). This result was originally shown by (?); we
show it here again to be self-contained. Then, in Section B.2,
we show that DMFC also implies never termination (Theo-
rem 18).

B.1 Model-Faithful Cyclicity
Lemma 15. Consider a vertex v in a branch B of a chase
tree T = ⟨V, E, fct, trg⟩ of a KB ⟨R, I⟩, and an R-trigger
λ. If λ features a deterministic rule and is loaded for fct(v),
then fct(v) ∪ out1(λ) ⊆ fct(u) for some u ∈ B.

Proof. 1. Assume that λ = ⟨ρ, σ⟩ features a deterministic

rule and that it is loaded for fct(v).

2. We can show via induction on B that fct(v) ⊆ fct(u) for

every vertex u that comes after v in B.

3. By (2): the trigger λ is loaded for the fact label of every

vertex that comes after v in B.

4. By Definition 2: the trigger λ is not active for the fact

label of some vertex that comes after v in B.

5. By (3) and (4): fct(v) ∪ out1(λ) ⊆ fct(u) for some u that

comes after v in B.

a. For every 1 ≤ i ≤ n; we have that out1(⟨ρi, σi⟩) ⊆
MFC(R), the rule ρi is a deterministic, and ⟨ρi, σi⟩ is
loaded for Iρ ∪ (cid:83)i−1
j=1 out1(⟨ρj, σj⟩).

b. A ρ-cyclic term occurs in out1(⟨ρn, σn⟩).
c. No ρ-cyclic term occurs in (cid:83)n−1

j=1 out1(⟨ρj, σj⟩).

n

3. Consider the constant mapping g with g ◦ σuc = σn,
where σuc is the substitution that maps every variable x
to a fresh constant cx; that is, the substitution such that
Iρ = body(ρ)σuc ∪ out1(⟨ρ, σuc⟩).
n⟩, ⟨ρ1, σ2
1⟩, . . . , ⟨ρn, σ1

1⟩, . . . , ⟨ρn, σ2

4. Let ⟨ρ1, σ1

for every 1 ≤ i ≤ n and every j ≥ 2.
n, F 2
1 = Iρ, F j

the (infinite) sequence of triggers such that σ1
i = g ◦ σj−1
σj
i
1 , . . . , F 1
5. Let F 1
i−1⟩)∪F j
sets such that F 1
for every 2 ≤ i ≤ n and every j ≥ 1, and F j
out1(⟨ρn, σj−1
6. We show that ⟨ρi, σj

i = out1(⟨ρi−1, σj

n ⟩) ∪ F j−1

for every j ≥ 2.

n, . . . be the sequence of fact

i for every 1 ≤ i ≤

1 , . . . , F 2

n⟩, . . . be
i = σi and

i ⟩ is loaded for F j
n and every j ≥ 1 via induction over j.
a. By (2) and (4): the trigger ⟨ρi, σ1

i ⟩ is loaded for F 1
i

i−1
1 =

i by (5).

i since σj

for every 1 ≤ i ≤ n. Hence, the base case holds.
b. Regarding the induction step, assume that ⟨ρi, σj−1
⟩
for some 1 ≤ i ≤ n and some
i ⟩ is loaded for F j
i =
) ⊆ F j

is loaded for F j−1
j ≥ 2. Hence, ⟨ρi, σj
g ◦ σj−1
i

by (4) and g(F j−1

i
7. Consider a branch B in a chase tree T = ⟨V, E, fct, trg⟩
of the KB ⟨R, body(ρ)σuc⟩. We show via structural in-
duction on B that, for every 1 ≤ i ≤ n and every j ≥ 1,
there is some v ∈ B with F j
a. For the root vertex r of T (i.e., the first element of
B), we have that fct(r) = body(ρ)σuc and ⟨ρ, σuc⟩
is loaded for fct(r). Since ρ is deterministic, there is
some v ∈ B such that fct(r)∪out1(⟨ρ, σuc⟩) ⊆ fct(v)
by Lemma 15. Therefore, the base case holds.
b. Assume that there is some u ∈ B such that F j

i ⊆
fct(u) for some 1 ≤ i ≤ n and some j ≥ 1. Then,
⟨ρi, σj
i by (6) and hence, there is
some v ∈ B such that fct(u)∪out1(⟨ρi, σj
i ⟩) ⊆ fct(v)
by Lemma 15. Therefore, the induction step holds.

i ⟩ is loaded for F j

i ⊆ fct(v).

i

i

8. Every branch of every chase tree T of

the KB
⟨R, body(ρ)σuc⟩ features an infinite number of terms by
(2), (4), (5), and (7). Note that, for every j ≥ 1, we have
that |Terms(F j

)| by (2.b) and (2.c).

1 )| < |Terms(F j+1

1

9. By (8), the rule set R never terminates.

Theorem 14. MFC rule sets are never terminating.

Proof. Consider a rule set R that is MFC.

1. There is some deterministic rule ρ ∈ R such that
MFC(R, ρ) features a ρ-cyclic term. Therefore, the rule
ρ is generating.

2. By (1): there is a sequence ⟨ρ1, σ1⟩, . . . , ⟨ρn, σn⟩ of R-

triggers such that:

B.2 Disjunctive Model-Faithful Cyclicity
Definition 25. For a rule set R, an R-trigger λ, and a term
t; let hλ(t) be the R-term defined as follows:
• If t occurs in skeletonR(λ), then hλ(t) = t.
• Otherwise, hλ(t) = ⋆.
Lemma 21. Consider a chase tree T = ⟨V, E, fct, trg⟩ of a
KB ⟨R, I⟩, a head-choice hc, an R-trigger λ = ⟨ρ, σ⟩, and

some vertex v ∈ branch(T, hc). If outhc(λ) ⊈ fct(v), then
hλ(fct(v)) ⊆ O(R, hc, λ).

Proof. Consider the branch branch(T, hc) = u1, u2, . . . and
the number n ≥ 1 with un = v. We show the lemma by
proving the following claim via induction: If outhc(λ) ̸⊆
fct(v), then hλ(fct(ui)) ⊆ O(R, hc, λ) for every 1 ≤ i ≤ n.
We first verify the base case:

a. Every term in fct(u1) is a constant since fct(u1) = I.
b. By (a) and Definition 25: hλ(t) ∈ Cons(skeletonR(λ))∪

{⋆} for every t ∈ Terms(fct(u1)).

c. By Definition 17: the set O(R, hc, λ) contains every fact
that can be defined using any predicate and constants in
Cons(skeletonR(λ)) ∪ {⋆}.

d. By (b) and (c): hλ(fct(u1)) ⊆ O(R, hc, λ) and the base

case holds.

Regarding the induction step, consider some i ≥ 2:

a. By induction hypothesis: hλ(fct(ui−1)) ⊆ O(R, hc, λ).
b. By (a): ⟨star(ψ), hλ ◦ τ ⟩ is loaded for O(R, hc, λ) where

trg(ui) = ⟨ψ, τ ⟩.

c. Since outhc(λ) ⊈ fct(v): outhc(trg(ui)) ̸= outhc(λ).
d. By (b), (c), and Definition 17: outhc(⟨star(ψ), hλ ◦ τ ⟩) is

a subset of O(R, hc, λ).

e. Consider some fact φ that is in hλ(outhc(⟨ψ, τ ⟩)) but not
in outhc(⟨star(ψ), hλ ◦ τ ⟩). Then, there is a functional
term fy(⃗s) in φ with y ∈ headj(ψ) for some j ≥ 1 such
that hλ(fy(⃗s)) = fy(⃗s).

f. By (e): fy(⃗s) ∈ skeletonR(λ). Therefore, φ is in
H(R, λ) and hence in O(R, hc, λ) by Definition 17.
g. By (a), (d), (e), and (f): hλ(fct(ui)) ⊆ O(R, hc, λ) and

the induction step holds.

Lemma 16. Consider a chase tree T = ⟨V, E, fct, trg⟩ of a
KB ⟨R, I⟩, a head-choice hc, some v ∈ branch(T, hc), and
an R-trigger λ. If λ is loaded for fct(v), and it is unblock-
able for R and hc; then fct(v) ∪ outhc(λ) ⊆ fct(u) for some
u ∈ branch(T, hc).

Proof. 1. Assume that λ = ⟨ρ, σ⟩ is loaded for fct(v), and

unblockable for R and hc.

2. Without loss of generality, we assume that ρ is non-
deterministic. Note that, if ρ is deterministic, then the
lemma follows from Lemma 15.

3. Suppose for a contradiction that outhc(λ) ⊈ fct(u) for

every u ∈ branch(T, hc).

4. By (1): the trigger λ is loaded for the fact label of every

vertex that comes after v in branch(T, hc).

5. By (4) and Definition 2: there is some vertex w that
comes after v in branch(T, hc) such that λ is not active
for fct(w). Therefore, outℓ(λ) ⊆ fct(w) for some ℓ ≥ 1.
6. By (3), (5), and Lemma 21: hλ(fct(w)) ⊆ O(R, hc, λ).

Hence, hλ(outℓ(λ)) ⊆ O(R, hc, λ).

7. We show that hλ(outℓ(λ)) = outℓ(λ); that is, that

headℓ(ρ) does not feature existential variables:
a. Suppose for a contradiction that there is a term t in

outℓ(λ) with hλ(t) ̸= t.

b. By Definition 25: hλ(s) = s for every term s that

occurs in skeletonR(λ).

c. By (a) and (b): there is a term of the form fy(⃗s) in
Terms(outℓ(λ)) such that y ∈ Vars(headℓ(ρ)) and
hλ(fy(⃗s)) ̸= fy(⃗s).

d. By (c) and (†): ρ is the only rule in R that features y

and ℓ = hc(ρ).

e. By (5) and (d): outhc(λ) ⊆ fct(w).
f. By (3) and (e): we obtain the desired contradiction.

8. By (6) and (7): outℓ(λ) ⊆ O(R, hc, λ).
9. By (2) and (8): λ is not active for O(R, hc, λ) and hence,
λ is not unblockable for R and hc, which contradicts (1).
10. By (1), (3) and (9): there is a vertex u in branch(T, hc)

with fct(v) ∪ outhc(λ) ⊆ fct(u).

Lemma 17. Consider a rule set R, a head-choice hc, an
R-trigger ⟨ρ, σ⟩, and a constant mapping g that is re-
versible for skeletonR(⟨ρ, σ⟩). If ⟨ρ, g ◦ σ⟩ is an R-trigger
and ⟨ρ, σ⟩ is unblockable for R and hc, then so is ⟨ρ, g ◦ σ⟩.

Proof. 1. Assume that ⟨ρ, g ◦ σ⟩ is an R-trigger and λ =

⟨ρ, σ⟩ is unblockable for R and hc.

2. For a term t, let h(t) = s if there is a term s that occurs
in skeletonR(λ) with g(s) = t, and h(t) = ⋆ otherwise.
The function h is well-defined because g is reversible for
the set of all terms in skeletonR(λ).
the sets F ′

that
can be defined using any predicate and the con-
stants occurring in Cons(skeletonR(λ)) ∪ {⋆} and
Cons(skeletonR(⟨ρ, g ◦ σ⟩)) ∪ {⋆}, respectively. More-
over, consider the following fact sets:

and G′ of all

3. Consider

facts

F = H(R, λ) ∪ F ′
G = H(R, ⟨ρ, g ◦ σ⟩) ∪ G′

4. We proceed to verify that h(G) ⊆ F. First, note that
h(G′) ⊆ F since h(c) ∈ Cons(skeletonR(λ)) ∪ {⋆} for
every constant c . To show that h(H(R, ⟨ρ, g ◦ σ⟩)) ⊆ F
we prove that h(H(R, t)) ⊆ F for every t ∈ Terms(G)
via induction over the structure of terms. If t is a con-
stant, then h(H(R, t)) = ∅; hence, the base case trivially
holds. Regarding the induction step, consider an R-term
t that is of the form fy(⃗s):
a. By ind.-hypothesis: h(H(R, s)) ⊆ F for every s ∈ ⃗s.
b. By (†): there is a unique rule ψ ∈ R and a unique
number ℓ such that y occurs in headℓ(ψ). Let ⃗z be the
list of existentially quantified variables in headℓ(ψ).
c. Let τ be some substitution with frontier(ψ)τ = ⃗s.

Moreover, let H = headℓ(ψ)τ .
d. By Definition 17: H(R, t) = H ∪ (cid:83)
e. By (a) and (d): we only need to show that h(H) ⊆ F
to verify the induction step. In fact, h(H) ⊆ F fol-
lows from (g), (h), (i), and (j), which amount to a com-
prehensive case-by-case analysis. Hence, the proof is
complete after showing these.

s∈⃗s H(R, s).

f. We observe that, if h(fz(⃗s)) is functional for some
z ∈ ⃗z, then h(fz(⃗s)) = fz(h(⃗s)) by (2). Thus, for ev-
ery z′ ∈ ⃗z, the term fz′(h(⃗s)) occurs in headℓ(ψ)(h ◦
τ ) which is contained in H(R, λ). Therefore, we
find g(fz′(h(⃗s))) = fz′(⃗s) and, by (2), h(fz′(⃗s)) =
fz′(h(⃗s′)).
In short: If h(fz(⃗s)) is a functional term for some z ∈
⃗z, then h(fz′(⃗s)) = fz′(h(⃗s)) for every z′ ∈ ⃗z.

g. We show that h(H) ⊆ F if h(t) is a functional term.
In this case, h(H) = h(headℓ(ψ)τ ) = headℓ(ψ)(h ◦
τ ) ⊆ F follows directly from (f).

h. We show that h(H) ⊆ F if h(t) ∈ Cons \ {⋆}.

• If h(t) ∈ Cons \ {⋆}, then h(fz(⃗s)) is a constant
for every z ∈ ⃗z. Note that otherwise h(t) would be
functional by (f).

• Furthermore, h(s) is also a constant (possibly ⋆) for
every s ∈ ⃗s by the definition of h and since g is
reversible for skeletonR(λ).

• Then, h(H) ⊆ F ′ and hence h(H) ⊆ F. Note that

Terms(H) ⊆ ⃗s ∪ {fz(⃗s) | z ∈ ⃗z}.

i. If h(t) = ⋆ and h(u) is a constant (or ⋆) for every

u ∈ Terms(H), then h(H) ⊆ F ′ ⊆ F.

j. We show that assuming h(t) = ⋆ and h(t′) /∈ Cons
for some t′ ∈ Terms(H) results in a contradiction.
• Note that t′ = g(h(t′)) is necessarily functional.
• By (f), t′ can only occur in ⃗s since otherwise h(t)
would be a functional term. Summing up, t′ ̸= t is a
subterm of t such that h(t′) is functional.
time,

in
to
skeletonR(⟨ρ, g ◦ σ⟩),
there needs to be a con-
stant c that occurs in the range of σ restricted
to frontier variables of ρ such that t occurs in
Terms(H(R, g(c))).

occur

same

• At

the

for

t

• Suppose for a contradiction that no such constant ex-
ists, i.e. there exists a functional term u that occurs
in the range of σ restricted to frontier variables of ρ
such that t occurs in Terms(H(R, g(u))) but t does
not occur in Terms(H(R, g(u′))) for any subterm u′
of u with u′ ̸= u.
• Since h(t) is not

in
Terms(H(R, q)) for a subterm q of g(u) with q ̸=
g(u) by (f).

functional, t must occur

We show that h(G ∪(cid:83)i
j=1 outhc(⟨star(ψj), τj⟩)) is a sub-
set of O(R, hc, λ) via induction over 0 ≤ i ≤ m. For
the base case with i = 0, h(G) ⊆ F ⊆ O(R, hc, λ)
follows immediately from (4). Assume for the induc-
tion hypothesis that h(G ∪ (cid:83)i
j=1 outhc(⟨star(ψj), τj⟩))
is a subset of O(R, hc, λ) for some i ≥ 1. To ver-
ify the induction step we only need to show that
h(outhc(⟨star(ψi+1), τi+1⟩)) ⊆ O(R, hc, λ).
a. We have that h(outhc(⟨star(ψi+1), τi+1⟩)) equals

outhc(⟨star(ψi+1), h ◦ τi+1⟩).

b. By ind.-hypothesis, the trigger ⟨star(ψi+1), h ◦ τi+1⟩

is loaded for O(R, hc, λ).

c. We show that assuming outhc(⟨ψi+1, h ◦ τi+1⟩) =
outhc(λ) results in a contradiction. In fact, if this were
the case, then:

g(outhc(⟨ψi+1, h ◦ τi+1⟩)) = g(outhc(λ))
= outhc(⟨ψi+1, g ◦ h ◦ τi+1⟩) = outhc(⟨ρ, g ◦ σ⟩)
= outhc(⟨ψi+1, τi+1⟩) = outhc(⟨ρ, g ◦ σ⟩)

Note that the last equality statement above contra-
dicts the definition of the list ⟨ψ1, τ1⟩, . . . , ⟨ψm, τm⟩.
Moreover, g ◦ h can be regarded as the identity
mapping in the last step since ⋆ does not occur in
outhc(⟨ψi+1, h ◦ τi+1⟩).

d. By (a), (b), and (c): the induction step holds.

6. If ρ is deterministic; then ⟨ρ, g ◦ σ⟩ is unblockable for
R and hc by Definition 17 and the lemma holds. Hence-
forth, we assume that ρ is of the form β → (cid:87)n
i=1 ∃⃗yi.ηi
with n ≥ 2.

7. Suppose for a contradiction that ⟨ρ, g ◦ σ⟩ is not unblock-

able for R and hc.

8. By (6) and (7): the trigger ⟨ρ, g ◦ σ⟩ is not active for
O(R, hc, ⟨ρ, g ◦ σ⟩). That is, there is some 1 ≤ ℓ ≤ n
such that outℓ(⟨ρ, g ◦ σ⟩) ⊆ O(R, hc, ⟨ρ, g ◦ σ⟩).

9. By (5) and (8): we have that h(outℓ(⟨ρ, g ◦ σ⟩)) ⊆
O(R, hc, λ). Therefore, outℓ(⟨ρ, σ⟩) ⊆ O(R, hc, λ) by
(2) and ⟨ρ, σ⟩ is not active for O(R, hc, λ).
10. By (9): ⟨ρ, σ⟩ is not unblockable for R and hc.
11. We obtain a contradiction from (1) and (10) so our suppo-
sition in (7) does not hold and ⟨ρ, g ◦ σ⟩ is unblockable.

• But then, there exists a subterm u′ of u with u′ ̸= u
that occurs in the range of σ restricted to frontier
variables of ρ with g(u′) = q since u is functional.
Since t occurs in Terms(H(R, g(u′))), we obtain
the desired contradiction.

• Let g(c) be of the form fx( ⃗w). We have that ⃗s is
contained in the subterms of ⃗w. But then, t′ occurs
in ⃗w, which contradicts the reversibility of g.
5. We show that h(O(R, hc, ⟨ρ, g ◦ σ⟩)) ⊆ O(R, hc, λ).
Consider a list ⟨ψ1, τ1⟩, . . . , ⟨ψm, τm⟩ of triggers such
that all of the following hold:
• O(R, hc, ⟨ρ, g ◦ σ⟩) = G∪(cid:83)m
i=1 outhc(⟨star(ψi), τi⟩).
• ⟨ψi, τi⟩ is loaded for G ∪ (cid:83)i−1
j=1 outhc(⟨star(ψj), τj⟩).
• outhc(⟨ψi, τi⟩) ̸= outhc(⟨ρ, g ◦ σ⟩) for all 1 ≤ i ≤ m.

Theorem 18. DMFC rule sets are never terminating.

Proof. Consider a rule set R that is DMFC.

1. There is some ρ ∈ R, some head-choice hc, and some
ρ-cyclic term t such that t ∈ Terms(DMFC(R, hc, ρ)).

2. By (1) and Definitions 19:

there is a (finite)

list

⟨ρ1, σ1⟩, . . . , ⟨ρn, σn⟩ of triggers such that:
a. For every 1 ≤ i ≤ n, we have that outhc(⟨ρi, σi⟩) ⊆
DMFC(R, hc, ρ), ⟨ρi, σi⟩ is loaded for Iρ,hc(ρ) ∪
(cid:83)i−1
j=1 out(⟨ρj, σj⟩), ⟨ρi, σi⟩ is unblockable for R and
hc, and σi(x) is functional for some x ∈ frontier(ρi).
b. A ρ-cyclic term occurs in outhc(⟨ρn, σn⟩). Hence, σn

is injective (since ρn = ρ)

c. No ρ-cyclic term occurs in (cid:83)n−1

i=1 outhc(⟨ρi, σi⟩).

3. Consider the constant mapping g such that g ◦ σuc = σn,
where σuc is the substitution introduced in Definition 12
which maps every variable x to a fresh constant cx. By
(2.b) and Definition 19, the mapping g is injective.

4. Let ⟨ρ1, σ1

1⟩, . . . , ⟨ρn, σ1

n⟩, ⟨ρ1, σ2

1⟩, . . . , ⟨ρn, σ2

i = σi and σj

the sequence of triggers such that σ1
g ◦ σj−1
i
5. Let F 1

for every 1 ≤ i ≤ n and every j ≥ 2.

n, F 2
1 , . . . , F 2
1 = Iρ,hc(ρ), F j

1 , . . . , F 1
sets such that F 1
i−1 for every 2 ≤ i ≤ n and every j ≥ 1, and F j
F j
outhc(⟨ρn, σj−1

n, . . . be the sequence of fact
i = outhc(⟨ρi−1, σj
i−1⟩)∪
1 =

n⟩, . . . be
i =

n ⟩) ∪ F j−1
6. One can show that ⟨ρi, σj

n

i for every
1 ≤ i ≤ n and every j ≥ 1 with an analogous argument
to the one used to prove (6) in the proof of Theorem 14.
7. By (7.c) and (7.d): we show that the mapping g is re-
j≥1 F j
n). Hence, g is reversible for

versible for Terms((cid:83)
skeletonR(⟨ρi, σj
a. By (2.c): for every constant c that occurs in (cid:83)

j≥1 F j
n,
the term g(c) does not feature nested function sym-
bols from sk(ρ).12

i ⟩) for every 1 ≤ i ≤ n and j ≥ 1.

for every j ≥ 2.
i ⟩ is loaded for F j

b. We show that, for any functional term t occurring in
n, the term g(t) features nested function sym-

j≥1 F j

(cid:83)

bols from sk(ρ).

i. By (iv) in Definition 19, one can show that ev-
ery functional term t occurring in (cid:83)
n has
a subterm of the form f (⃗c) such that f occurs
in sk(ρ) and ⃗c = σuc(frontier(ρ)). In fact, one
can prove this claim via induction on the sequence
F 1
n, . . .

1 , . . . , F 2

1 , . . . , F 1

j≥1 F j

n, F 2

ii. By (2.b): g(c) features a function symbol from sk(ρ)
for some c ∈ σuc(frontier(ρ)). Otherwise, there
would not be a ρ-cyclic term in outhc(⟨ρn, σn⟩).
iii. By (i) and (ii): for every functional term t oc-
curring in (cid:83)
n, there is a term of the form
f (g(⃗c)) ∈ subterms(g(t)) with f ∈ sk(ρ) and ⃗c =
σuc(frontier(ρ)). Note that f (g(⃗c)) features nested
function symbols from sk(ρ).

j≥1 F j

c. We show that g(t) ̸= g(s) for every t, s ∈ Terms(F)

with t ̸= s via structural induction on t.
• Regarding the base case, we consider two cases: If t
and s are constants, then g(t) ̸= g(s) since g is injec-
tive by (3). If t is a constant and s is functional, then
g(s) features nested function symbols from sk(ρ) by
(b) and g(t) does not by (a).

• Regarding the induction step, if s is a constant, the
argument is analogous to the second base case. We
distinguish two remaining cases: If t and s are func-
tional terms of the form f (⃗t) and h(⃗s), respectively,
with f ̸= h; then g(t) ̸= g(s) since g(t) = f (g(⃗t))
and g(s) = h(g(⃗s)). If t and s are functional terms
of the form f (t1, . . . , tn) and f (s1, . . . , sn), respec-
̸= si for some 1 ≤ i ≤ n since
tively; then ti

12Consider a rule ρ = A(x) → ∃y, z.R(x, y) ∧ S(x, z). Then,
the term fy(fz(c)) features nested function symbols from sk(ρ)
while fw(fy(d), fz(c)) does not.

t ̸= s, g(ti) ̸= g(si) by induction hypothesis, and
g(t) ̸= g(s) since g(t) = f (g(t1), . . . , g(tn)) and
g(s) = f (g(s1), . . . , g(sn)).
d. Consider a constant c occurring in (cid:83)

n and some
s ∈ subterms(g(c)). We show that there is no func-
tional term u occurring in (cid:83)
i. Suppose for a contradiction that there is a functional
n with g(u) = s.

n with g(u) = s.

term u in (cid:83)

j≥1 F j

j≥1 F j

j≥1 F j

ii. By (a): g(c) does not feature nested function sym-
bols from sk(ρ). Hence, s does not feature them ei-
ther since s ∈ subterms(g(c)).

iii. By (i) and (b): the term g(u) features nested function

symbols from sk(ρ).
iv. By (i-iii): contradiction!

8. We show that ⟨ρi, σj

i ⟩ is unblockable for R and hc for

every 1 ≤ i ≤ n and every j ≥ 1 via induction over j.
• By (2) and (4): ⟨ρi, σ1

i ⟩ is unblockable for R and hc

for every 1 ≤ i ≤ n. Hence, the base case holds.

• Regarding the induction step, consider some 1 ≤ i ≤
n, some j ≥ 2, and the trigger ⟨ρi, σj
i ⟩. By induction
hypothesis, the trigger ⟨ρi, σj−1
⟩ is unblockable for R
i
and hc. Hence, ⟨ρi, g ◦ σj−1
⟩ is also unblockable by
i
(7) and Lemma 17, and the induction step holds since
⟨ρi, g ◦ σj−1
i ⟩ by (4).

⟩ = ⟨ρi, σj

i

i ⊆ fct(v).

9. Consider some chase tree T = ⟨V, E, fct, trg⟩ of the KB
⟨R, body(ρ)σuc⟩. We show via induction on the structure
of T that, for every 1 ≤ i ≤ n and every j ≥ 1, there is
some v ∈ branch(T, hc) with F j
• For the root vertex r of T , we have that fct(r) =
body(ρ)σuc and ⟨ρ, σuc⟩ is loaded for fct(r). We show
that fct(r) ∪ outhc(⟨ρ, σuc⟩) ⊆ fct(u) for some vertex
u in branch(T, hc) by a similar argument as for Lem-
mas 16 and 21.
Suppose for a contradiction that
there is a ver-
tex u in branch(T, hc) such that outhc(⟨ρ, σuc⟩) ⊈
fct(u) and ⟨ρ, σuc⟩ is not active for fct(u). That
is, outℓ(⟨ρ, σuc⟩) ⊆ fct(u) for some ℓ (such that
outhc(⟨ρ, σuc⟩) ⊈ outℓ(⟨ρ, σuc⟩)). Consider the trig-
ger λ = ⟨ρ, g ◦ σuc⟩ = ⟨ρn, σn⟩. Assume for now
that hλ(body(ρ)(g ◦ σuc)) ⊆ O(R, hc, λ) (‡). We
show outℓ(⟨ρ, g ◦ σuc⟩) ⊆ O(R, hc, λ), i.e. that λ =
⟨ρ, g ◦ σuc⟩ is not unblockable; contradicting (2):

a. Consider the path w0, . . . , wm in T with w0 = r
and wm = u. We have that outhc(⟨ψi, τi⟩)
̸=
outhc(⟨ρ, σuc⟩) where ⟨ψi, τi⟩ = trg(wi) for every
1 ≤ i ≤ m.

b. Consider

the

triggers

⟨ψi, hλ ◦ g ◦ τi⟩

all
1 ≤ i ≤ m. By (a): For each 1 ≤ i ≤ m,
loaded for hλ(body(ρ)(g ◦
⟨ψi, hλ ◦ g ◦ τi⟩
σuc)) ∪ (cid:83)i−1
and
outhc(⟨ψi, hλ ◦ g ◦ τi⟩) ̸= outhc(λ).

j=1 hλ(outhc(⟨ψj, hλ ◦ g ◦ τj⟩));

for

is

c. By (b), Definition 17,

and assumption (‡):
hλ(outhc(⟨ψi, hλ ◦ g ◦ τi⟩)) ⊆ O(R, hc, λ) for
all 1 ≤ i ≤ m.

d. By (a), (c), and since outℓ(⟨ρ, σuc⟩)) ⊆ fct(u):

hλ(outℓ(⟨ρ, hλ ◦ g ◦ σuc⟩)) ⊆ O(R, hc, λ)

e. We have that headℓ(ρ) does not feature existentially
quantified variables. Otherwise, we would necessar-
ily obtain hc(ρ) = ℓ since existentially quanti-
fied variables are unique per rule and head-disjunct
by (†). Then, we would obtain a contradiction
since we would get outhc(⟨ρ, σuc⟩) ⊈ fct(u) and
outhc(⟨ρ, σuc⟩) ⊆ fct(u) at the same time. (Also see
(7) in the proof of Lemma 16).

f. By (e): We have that hλ(outℓ(⟨ρ, hλ ◦ g ◦ σuc⟩)) =

outℓ(⟨ρ, hλ ◦ g ◦ σuc⟩).

g. By hλ(g(σuc(frontier(ρ)))) = g(σuc(frontier(ρ))),
we get outℓ(⟨ρ, hλ ◦ g ◦ σuc⟩) = outℓ(⟨ρ, g ◦ σuc⟩).
h. By (d), (f), and (g), outℓ(⟨ρ, g ◦ σuc⟩) ⊆ O(R, hc, λ),
i.e. λ is not active for O(R, hc, λ) and thus λ is not
unblockable for R and hc.
It remains to show (‡), i.e. that hλ(body(ρ)(g◦σuc)) ⊆
O(R, hc, λ). For this, we use the triggers from (2):
a. By Definition 17, we have that hλ(Iρ,hc(ρ)) ⊆
O(R, hc, λ). More precicely, hλ(outhc(⟨ρ, σuc⟩)) ⊆
H(R, λ) and hλ(body(ρ)σuc) is contained in the set
of all facts that can be defined using any predicate
and constants from Cons(skeletonR(λ)) ∪ {⋆}.

b. By (2.a),

hλ(Iρ,hc(ρ)) ∪ (cid:83)i−1
ery 1 ≤ i ≤ n.

the trigger ⟨ρi, hλ ◦ σi⟩ is loaded for
j=1 hλ(outhc(⟨ρj, hλ ◦ σj⟩)) for ev-

c. By (2.b) and (2.c), outhc(⟨ρi, hλ ◦ σi⟩) ̸= outhc(λ)

for every 1 ≤ i ≤ n − 1.

d. We have outhc(⟨star(ρi), hλ ◦ σi⟩) ⊆ O(R, hc, λ)
for every 1 ≤ i ≤ n − 1 by (a), (b), (c), and Defi-
nition 17.

e. For every 1 ≤ i ≤ n − 1, every fact φ that occurs in
hλ(outhc(⟨ρi, hλ ◦ σi⟩)) \ outhc(⟨star(ρi), hλ ◦ σi⟩)
features a functional term t in skeletonR(λ) that does
not occur in the range of hλ ◦ σi. But then, φ ∈
H(R, t) ⊆ H(R, λ) ⊆ O(R, hc, λ).

f. By (d) and (e), for every 1 ≤ i ≤ n − 1, we obtain:

hλ(outhc(⟨ρi, hλ ◦ σi⟩)) ⊆ O(R, hc, λ)

g. Recall that the trigger λ = ⟨ρn, hλ ◦ σn⟩ is loaded
for hλ(Iρ,hc(ρ)) ∪ (cid:83)n−1
j=1 hλ(outhc(⟨ρj, hλ ◦ σj⟩)) by
(b). By (f), we conclude that body(ρn)(hλ ◦ σn) =
hλ(body(ρ)(g ◦ σuc)) ⊆ O(R, hc, λ).

• Regarding the induction step, we assume that there
is some u ∈ V such that F j
i ⊆ fct(u) for some
1 ≤ i ≤ n and some j ≥ 1 by induction hypothe-
sis. Then, ⟨ρi, σj
i ⟩ is loaded for F j
i by (6), and it is
unblockable for R and hc by (8). Hence, there is some
v ∈ branch(T, hc) such that fct(u)∪outhc(⟨ρi, σj
i ⟩) ⊆
fct(v) by Lemma 16 and the induction step holds. Note
1 , . . . , F 1
n, F 2
that the element in F 1
n, . . . right
i ∪ outhc(⟨ρi, σj
i is the set F j
after F j
n, F 2
1 , . . . , F 1

n, . . . fea-
tures an infinite number of terms. Note that, for every
j ≥ 2, we have that |Terms(F j
n)| is (strictly) greater than
|Terms(F j−1

i ⟩) by (5).
1 , . . . , F 2

)| by (2.b) and (2.c).

1 , . . . , F 2

n

10. By (2–5): the sequence F 1

11. By (9) and (10): any given chase tree ⟨V, E, fct, trg⟩
of the KB ⟨R, body(ρ)σuc⟩ features an infinite num-
terms
ber of terms. More precisely,

the set of all

in (cid:83)
v∈branch(T,hc) fct(v) is infinite. Therefore, the KB
⟨R, body(ρ)σuc⟩ does not admit finite chase trees and
hence, the rule set R never terminates.

Theorem 19. (D)MFC-membership is 2EXPTIME-comp.

Sketch. Membership. The number of terms and facts in
DMFC(R, hc, ρ) is double-exponentially bounded in the
size of R. Hence, for the construction of DMFC(R) at most
double-exponentially many steps are necessary of which
each one takes at most double-exponential time (including
the unblockability check).

Hardness. Following the hardness result for MFA (?, The-
orem 8), we use a reduction from the problem of conjunc-
tive query entailment over weakly acyclic rule set R (which
is called Σ in the original proof). Let R′ be the weakly-
acyclic rule set that results from R such that R′′ = R′ ∪
{ρ = R(w, x) ∧ B(x) → ∃y.R(x, y) ∧ A(y)} is MFA iff
⟨R′, {A(a)}⟩ ̸|= B(a) according to the construction by ? In
the original proof R′ corresponds to Σ3 (?, Theorem 8). In
turn, the rule set R′′ corresponds to Ω (?, Lemma 7). Note
that R′ is weakly-acyclic and thus also MFA and that no
atom with R occurs in R′.

For

consider MFC(R′′, ρ).

the MFC check,

that are not ρ-cyclic. Therefore,

In
MFC(R′′, ρ), Iρ
already includes R(cx, fy(cx)) and
A(fy(cx)). Since R′ is MFA, there are no cyclic terms
in MFC(R′′, ρ)
if
⟨R′, {A(a)}⟩ |= B(a), then B(fy(cx)) ∈ MFC(R′′, ρ) by
Definiton 14. Hence, ⟨ρ, [w/cx, x/fy(cx)]⟩ yields a ρ-cyclic
term in A(fy(fy(cx))) and thus, R′′ is MFC. Otherwise, if
⟨R′, {A(a)}⟩ ̸|= B(a), then no other trigger for ρ is loaded
and thus, MFC(R′′, ρ) contains no ρ-cyclic term. For any
other rule ψ ∈ R′, MFC(R′′, ψ) does not contain a ψ-cyclic
term because R′ is MFA and ρ can never be applied during
the contruction of MFC(R′′, ψ) because the predicate R
only occurs in ρ. Hence, R′′ is not MFC.

For the DMFC check, the proof is almost the same as for
MFC. If ⟨R′, {A(a)}⟩ ̸|= B(a), then R′′ is not DMFC by
the same argument as for MFC. If ⟨R′, {A(a)}⟩ |= B(a),
we show that all triggers that are applied in the construc-
tion of MFC(R′′, ρ) can also be applied in the construc-
tion of DMFC(R′′, hc, ρ) with the head-choice that maps
every rule to 1 (since R′′ is deterministic). That is, we show
that conditions (ii), (iv), and (v) from Definition 19 hold.
(Condition (iii) has already been shown for MFC.) Since all
rules in R′′ are deterministic, every R′′-trigger is unblock-
able (i.e. (ii)). Since R does not occur in R′ and B only
occurs in a rule head in R′, A(fy(cx)) is the only usable
fact when starting to compute MFC(R′′, hc, ρ). Thus, every
trigger used to build MFC(R′′, hc, ρ) necessarily features a
functional term (that includes fy(cx)) for a frontier variable
(i.e. (iv)). By that, we already obtain, if ⟨R′, {A(a)}⟩ |=
B(a), then B(fy(cx)) ∈ DMFC(R′′, hc, ρ). The trigger
⟨ρ, [w/cx, x/fy(cx)]⟩ has an injective substitution (i.e. (v)).
Therefore we obtain a ρ-cyclic term in A(fy(fy(cx))) and
thus, R′′ is DMFC.

C Additional Evaluation Results
We include some tables with additional evaluation results.
See Section 5 to understand how to read these tables.

C.1 Deterministic Rule Sets
We present results to verify one of our empirical claims from
the introduction. Namely, we aim to show that, using MFA
and MFC, one can establish the termination status of most
deterministic rule sets. We include the results of our experi-
ments in Table 2. Note the following:

• Around 99% of the considered rule sets were classified
as terminating or non-terminating using MFA and MFC.

• Table 2 only features results for deterministic rule sets.
• We include separate results for MFC and DMFCs be-
cause this notions do not coincide in theory. However, for
every rule set R considered in this evaluation, we have
that R is MFC if and only if it is DMFCs.

C.2 Non-Guarded Rule Sets
As stated in Section 6, we can decide termination for
guarded deterministic rule sets (?). It is possible that this
results also extends to guarded rule sets with disjunctions.
Therefore, we include separate results for non-guarded rule
sets in Table 3 and observe that these results are rather simi-
lar percentage-wise to those from Table 1.

D
F
X
O

1–19
20–99
100+
1+

5 1–19
20–99
1
E
100–999
R
O
1-999
L 1–19
20–99
W
O
100–299
M
1-299

#∃

# tot.

# fin. MFA/DMFA

58
27
251
336

86
109
230
425

58
27
89
174

86
109
176
371

51
23
73
147 (84%)

80
88
143
311 (83%)

DMFA2

51
23
73
147 (84%)

80
88
143
311 (83%)

MFC

3
4
16
23 (13%)

6
21
33
60 (16%)

DMFCs
3
4
16
23 (13%)

6
21
33
60 (16%)

1139
269
185
1593

1125
266
149
1540

790
216
114
1120 (72%)

794
217
114
1125 (73%)

330
49
35
414 (26%)

330
49
35
414 (26%)

Table 2: Skolem Chase Termination: Deterministic Rule Sets

#∃

# tot.

# fin.

MFA

DMFA

D
F
X
O

1–19
20–99
100+
1+

5 1–19
20–99
1
E
100–999
R
O
1-999
L 1–19
20–99
W
O
100–299
M
1-299

12
13
70
95

62
71
261
394

12
12
19
43

59
63
209
331

4
2
4
10 (23%)

32
22
4
58 (17%)

6
2
4
12 (27%)

40
23
4
67 (20%)

592
584
389
1565

546
498
221
1265

306
57
11
374 (29%)

343
62
11
416 (32%)

DMFA2

6
2
4
12 (27%)

40
25
117
182 (54%)

345
68
97
510 (40%)

MFC

4
8
10
22 (51%)

10
34
83
127 (38%)

87
206
88
381 (30%)

DMFCs
6
10
15
31 (72%)

18
38
92
148 (44%)

192
428
124
744 (58%)

Table 3: Skolem Chase Termination: Non-Guarded Non-Deterministic Rule Sets

