Provenance-Based Algorithms for Rich Queries over
Graph Databases
Yann Ramusat, Silviu Maniu, Pierre Senellart

To cite this version:

Yann Ramusat, Silviu Maniu, Pierre Senellart. Provenance-Based Algorithms for Rich Queries over
Graph Databases. EDBT 2021 - 24th International Conference on Extending Database Technology,
Mar 2021, Nicosia / Virtual, Cyprus. Ôøøhal-03140067Ôøø

HAL Id: hal-03140067

https://inria.hal.science/hal-03140067

Submitted on 12 Feb 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L‚Äôarchive ouverte pluridisciplinaire HAL, est
destin√©e au d√©p√¥t et √† la diffusion de documents
scientifiques de niveau recherche, publi√©s ou non,
√©manant des √©tablissements d‚Äôenseignement et de
recherche fran√ßais ou √©trangers, des laboratoires
publics ou priv√©s.

Distributed under a Creative Commons Attribution - NonCommercial - NoDerivatives 4.0
International License

Provenance-Based Algorithms for Rich Queries
over Graph Databases

Yann Ramusat
DI ENS, ENS, CNRS, PSL University
& Inria
Paris, France
yann.ramusat@ens.fr

Silviu Maniu
Universit√© Paris-Saclay, LRI, CNRS
Gif-sur-Yvette, France

silviu.maniu@lri.fr

Pierre Senellart
DI ENS, ENS, CNRS, PSL University
& Inria & IUF
Paris, France
pierre@senellart.com

ABSTRACT
In this paper, we investigate the efficient computation of the
provenance of rich queries over graph databases. We show that
semiring-based provenance annotations enrich the expressive-
ness of routing queries over graphs. Several algorithms have pre-
viously been proposed for provenance computation over graphs,
each yielding a trade-off between time complexity and gener-
ality. Here, we address the limitations of these algorithms and
propose a new one, partially bridging a complexity and expres-
siveness gap and adding to the algorithmic toolkit for solving this
problem. Importantly, we provide a comprehensive taxonomy
of semirings and corresponding algorithms, establishing which
practical approaches are needed in different cases. We implement
and comprehensively evaluate several practical applications of
the problem (e.g., shortest distances, top-ùëò shortest distances,
Boolean or integer path features), each corresponding to a spe-
cific semiring and algorithm, that depends on the properties of
the semiring. On several real-world and synthetic graph datasets,
we show that the algorithms we propose exhibit large practical
benefits for processing rich graph queries.

1 INTRODUCTION
Graph databases [32] are part of the so-called NoSQL DBMS
ecosystem, in which the information is not organized by strictly
following the relational model. The structure of graph databases
is well-suited to representing some types of relationships within
the data, and their potential for distribution makes them ap-
pealing for applications requiring large-scale data storage and
massively parallel data processing. Natural example applications
of such database systems are social network analysis [13] or the
storage and querying of the Semantic Web [5].

Graph databases can be queried using several general-purpose
navigational query languages, an abstraction of which is regu-
lar path queries (RPQs) [6] (or generalizations thereof, such as
C2RPQs) on paths in the graph. Recently, based on existing solu-
tions to querying property graphs ‚Äì such as Neo4j‚Äôs Cypher [17]
query language or Oracle‚Äôs PGQL [38] ‚Äì an upcoming interna-
tional standard language for property graph querying, GQL [22],
is being designed as a standalone language complementing SQL.
GQL will notably incorporate support for RPQs.

In parallel with these recent developments, the notion of
provenance of a query result [34], a familiar notion in relational
databases, has recently been adapted to the context of graph
databases [31], using the framework of provenance semirings [18].
In this framework, edges of a graph are annotated, in addition to
usual properties, with elements of a semiring; when evaluating

¬© 2021 Copyright held by the owner/author(s). Published in Proceedings of the
24th International Conference on Extending Database Technology (EDBT), March
23-26, 2021, ISBN 978-3-89318-084-4 on OpenProceedings.org.
Distribution of this paper is permitted under the terms of the Creative Commons
license CC-by-nc-nd 4.0.

‚Ñé ‚©Ω 4

ùë†

‚Ñé ‚©Ω 2.10

ùë¢

ùë£

‚Ñé ‚©Ω 2.10, charging station

ùë°

Figure 1: Example road network represented by a graph
with provenance annotations along two dimensions: max-
imum height ‚Ñé (as a positive number) a vehicle must have
to use the road segment, and a Boolean indicating the pres-
ence of an electrical charging station. When a dimension
is not mentioned, the annotations are assumed to be, re-
spectively, ‚Ñé ‚©Ω ‚àû and ¬¨(charging station).

a query, traversing the paths on the graph can generate new
annotations depending on the semiring operators, resulting in
a semiring value associated with every query result, called the
provenance of the query result. By choosing different semirings,
different information on the query result can be computed. For
example, when edges are annotated with elements of the tropical
semiring (nonnegative real numbers) expressing the distance be-
tween vertices, the provenance of the query result computes the
shortest distance of paths that produce this result; when edges
are annotated with elements of the counting semiring (natural
integers) interpreted as multiplicity, the provenance of the query
result computes the (possibly infinite in case of cycles) number
of ways each query result can be obtained. Underlying properties
of the semiring directly control how the information on graph
edges is encoded, and also how efficient algorithms for query
processing are.

Beyond these simple examples of semirings, the framework of
semiring provenance also allows modeling of intricate issues, e.g.,
when the problem of interest can be decomposed into several sub-
problems and when the resulting provenance does not necessarily
correspond to a particular path in the graph.

Example 1.1. Consider the example of a road transportation
network modeled as a directed graph with provenance anno-
tations on edges. We can for example encode the presence of
points of interests (such as gas stations, restaurants, or electrical
charging stations) as Boolean features on edges, and road prop-
erties (e.g., maximal height or weight for a bridge or tunnel) as
real-valued features.

We will show that, using semiring provenance, we can deal
with graph queries that take into account multiple such features:
a pair of vertices is valid for the queries if there exists at least
one valid path for each restriction between the two locations.
An application of this would be to ensure that different vehicle
categories (say, a high-clearance truck and an electric car that
requires charging on the way) can properly reach a common
destination from the same origin.

Another possible semantics for semiring provenance is to
check that all paths between two vertices verify (or exclude) some
properties (e.g., absence of tolls, or presence of gas stations on
the route) thus providing road administrators crucial information
on the global state of the roads between two points.

This is illustrated in Figure 1, a road network where some road
segments have restrictions on the height on vehicles; this is a
first dimension of provenance. The second dimension records
whether there exists an electrical charging station on the road
segment ‚Äì in our example, this is the case for only one edge.

In our previous preliminary research [31], we generalized
three existing algorithms from a broad range of the computer
science literature to compute the provenance of regular path
queries over graph databases, in the framework of provenance
semirings. Together, these three generalizations cover a large
class of semirings used for provenance, each yielding a trade-
off between time complexity and generality. We also performed
experiments suggesting these approaches are complementary
and practical for various kinds of provenance indications, even
on a relatively large transport network.
In this paper, we extend this work by:

‚Ä¢ Introducing a novel algorithm, MultiDijkstra, for com-
mutative 0-closed (or absorptive) semirings. This algorithm,
generalizing Dijkstra‚Äôs algorithm and leveraging prop-
erties of distributive lattices, partially bridges a strong
computational gap between two classes of semirings left
untreated in our previous research. The complexity of the
queries exemplified here belongs in this gap, and strongly
motivated our interest to develop the algorithms in this pa-
per. The experiments we performed demonstrate that our
new algorithm can scale up to very large networks with
dozens of millions of nodes, bringing a notable improve-
ment with respect to the state of the art of provenance
computation in graph databases.

‚Ä¢ Establishing a precise summary, in the form of a taxonomy,
of the algorithms used in our context, along with their
complexities and expected properties of the underlying
semirings used for the provenance annotations. We also
analyze similarities with classes of semirings which are
used either for computing provenance of relational algebra
queries [19] or of Datalog programs [11].

‚Ä¢ Performing a comprehensive set of experiments on real-
world data demonstrating the running time of provenance
computation over graphs, over a wide variety of semirings
and covering different use cases. We also observe that pa-
rameters depending on the topology of the graph, such as
treewidth [27] seem to have a higher impact on the effi-
ciency of the algorithm than distance-based parameters
such as the highway dimension [4]. The implementation of
all algorithms we use for these experiments is freely avail-
able at https://bitbucket.org/smaniu/graph-provenance/
src/master/.

The paper is organized as follows. We start by introducing
in Section 2 some preliminaries: graph databases enhanced by
provenance annotations, a short overview of the algebraic theory
of semirings, and an explanation on which semiring can be used
for provenance annotations in a few selected practical applica-
tions. We revisit in Section 3 the algorithms we proposed in [31]
and discuss their limitations. Section 4 is a taxonomy summa-
rizing classes of semirings and associated algorithms for graph
provenance. In Section 5, we introduce MultiDijkstra and the

mathematical theory behind distributive lattices, which Multi-
Dijkstra relies on. We present experimental results comparing
all algorithms in practice in Section 6 before discussing related
work in Section 7.

2 PRELIMINARIES
The framework we are considering is that of graph databases
enriched with semiring-based provenance annotations. We detail
here the notation and definitions we previously introduced in [31]
and extend it with some additional concepts. We also introduce
a large number of example semirings, to illustrate the generality
of the problem considered.

2.1 Semirings
The framework for provenance in relational databases introduced
by [18] uses the algebraic structure of semirings to encode meta-
information about tuples and query results. In what follows,
we present the basic notions needed for this paper; for further
details about the theory and applications of semirings, see [20]
and [18, 34] for their applications to provenance.

Definition 2.1 (Semiring). A semiring is an algebraic structure
(K, ‚äï, ‚äó, 0, 1) where K is some set, ‚äï and ‚äó are binary operators
over K, and 0 and 1 are elements of K, satisfying the following
axioms:

‚Ä¢ (K, ‚äï, 0) is a commutative monoid: (ùëé ‚äïùëè) ‚äïùëê = ùëé ‚äï (ùëè ‚äïùëê),

ùëé ‚äï ùëè = ùëè ‚äï ùëé, ùëé ‚äï 0 = 0 ‚äï ùëé = ùëé;

‚Ä¢ (K, ‚äó, 1) is a monoid: (ùëé ‚äó ùëè) ‚äó ùëê = ùëé ‚äó (ùëè ‚äó ùëê), 1 ‚äó ùëé =

ùëé ‚äó 1 = ùëé;

‚Ä¢ ‚äó distributes over ‚äï: ùëé ‚äó (ùëè ‚äï ùëê) = (ùëé ‚äó ùëè) ‚äï (ùëé ‚äó ùëê);
‚Ä¢ 0 is annihilator for ‚äó: 0 ‚äó ùëé = ùëé ‚äó 0 = 0.

Example 2.2. It is easy to check that the following structures

are all semirings:

Tropical semiring. (R+ ‚à™ {‚àû}, min, +, ‚àû, 0).
Top-ùëò semiring. For ùëò ‚©æ 1 some integer,

((R+ ‚à™ {‚àû})ùëò, minùëò, +ùëò, (‚àû, . . . , ‚àû), (0, ‚àû, . . . , ‚àû)),
where

minùëò ((ùëé1, . . . , ùëéùëò ), (ùëè1, . . . , ùëèùëò )) = minùëò {ùëé1, . . . , ùëéùëò, ùëè1, . . . , ùëèùëò }
returns the ùëò smallest entries (with duplicates) among
those in ùëé and ùëè, in increasing order, and

(ùëé1, . . . , ùëéùëò ) +ùëò (ùëè1, . . . , ùëèùëò ) = minùëò {ùëéùëñ + ùëè ùëó | 1 ‚©Ω ùëñ, ùëó ‚©Ω ùëò }.

We further impose that only tuples that are in increasing
order are valid elements of the semiring. Note that the
top-1 semiring is the same as the tropical semiring.
Example: For ùëò = 2, (1, 2) ‚äï (1, 3) = min2{1, 1, 2, 3} = (1, 1)
and (1, 2) ‚äó (1, 3) = min2{1 + 1, 1 + 3, 2 + 1, 2 + 3} = (2, 3).

Counting semiring. (N ‚à™ {‚àû}, +, √ó, 0, 1), where

‚àÄùëé ‚àà N‚àó

ùëé + ‚àû = ùëé √ó ‚àû = ‚àû √ó ùëé = ‚àû

and 0 + ‚àû = ‚àû, but 0 √ó ‚àû = ‚àû √ó 0 = 0.

Boolean semiring. ({‚ä•, ‚ä§}, ‚à®, ‚àß, ‚ä•, ‚ä§), where ‚ä• (resp, ‚ä§)
is interpreted as the Boolean false (resp., true) value.

ùëò-feature semiring. For ùëò ‚©æ 1 some integer,

((R+)ùëò, min, max, (‚àû, ‚àû, ‚àû), (0, 0, 0))

where min and max are applied pointwise; it also exists
in dual form, with min and max exchanged.

Integer polynomial semiring. (N[ùëã ], +, √ó, 0, 1) where ùëã
is a finite set of variables, and +, √ó, 0, 1 have their standard
interpretations as polynomial operators and polynomial
values.

Shortest-path semiring.

((R+ ‚à™ {‚àû}) √ó Œ£‚àó, ‚äï, ‚äó, (‚àû, ùúÄ), (0, ùúÄ))

with the following operators ‚äï and ‚äó:
‚Ä¢ (ùëë, ùúã) ‚äï (ùëë ‚Ä≤, ùúã ‚Ä≤) = (min(ùëë, ùëë ‚Ä≤), ùúã ‚Ä≤‚Ä≤) where ùúã ‚Ä≤‚Ä≤ is ùúã if
ùëë < ùëë ‚Ä≤, ùúã ‚Ä≤ if ùëë > ùëë ‚Ä≤, and min(ùúã, ùúã ‚Ä≤) (in lexicographic
order, assuming some order on Œ£) if ùëë = ùëë ‚Ä≤;

‚Ä¢ (ùëë, ùúã) ‚äó (ùëë ‚Ä≤, ùúã ‚Ä≤) = (ùëë +ùëë ‚Ä≤, ùúã ¬∑ ùúã ‚Ä≤) if neither ùëë nor ùëë ‚Ä≤ is ‚àû;
and (ùëë, ùúã) ‚äó (ùëë ‚Ä≤, ùúã ‚Ä≤) = (‚àû, ùúÄ) if either ùëë or ùëë ‚Ä≤ is ‚àû.
As we shall see further, these examples all yield useful appli-

cations for provenance over graphs.

We now consider properties of semirings that will be of interest
to develop specific algorithms ‚Äì we will illustrate these properties
on the example semirings of Example 2.2. Some of the properties
are summarized in Figure 2; ignore annotations for algorithms
in blue for now.

A semiring is commutative if for all ùëé, ùëè ‚àà K, ùëé ‚äó ùëè = ùëè ‚äó ùëé.
A semiring is idempotent if for all ùëé ‚àà K, ùëé ‚äï ùëé = ùëé. In an
idempotent semiring we can introduce a natural order defined by
ùëé ‚äë ùëè iff it exists ùëê ‚àà K such that ùëé ‚äï ùëê = ùëè.1 Note that this order
is compatible with the two binary operations of the semiring: for
all ùëé, ùëè, ùëê ‚àà K, ùëé ‚äë ùëè implies ùëé ‚äï ùëê ‚äë ùëè ‚äï ùëê and ùëé ‚äó ùëê ‚äë ùëè ‚äó ùëê. An
important property that we wish to use in our setting is that of
k-closedness [29], i.e., a semiring is ùëò-closed if:

‚àÄùëé ‚àà K,

ùëò+1
(cid:202)

ùëñ=0

ùëéùëñ =

ùëò
(cid:202)

ùëñ=0

ùëéùëñ .

(cid:124)

(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)

Here, by ùëéùëñ we denote the repeated application of the ‚äó operation
ùëñ times, i.e., ùëéùëñ = ùëé ‚äó ùëé ‚äó ¬∑ ¬∑ ¬∑ ‚äó ùëé
. 0-closed semirings (i.e., those
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:125)
in which ‚àÄùëé ‚àà K, 1 ‚äï ùëé = 1) have also been called absorptive,
bounded, or simple depending on the literature. Note that any
0-closed semiring is idempotent (indeed, ùëé ‚äï ùëé = ùëé ‚äó (1 ‚äï 1) =
ùëé ‚äó 1 = ùëé) and therefore admits a natural order.

(cid:123)(cid:122)
ùëñ

Example 2.3. All semirings in Example 2.2 are commutative
except for the shortest-path semiring (indeed, concatenation is
not a commutative operation).

All of them are idempotent, except for the top-ùëò, counting,

and integer polynomial semirings.

The natural order of the tropical semiring is the total order ‚©æ
(note that this is the reverse of the standard order on R+ ‚à™ {‚àû}).
The tropical, Boolean, ùëò-feature, and shortest-path semirings
are 0-closed. The top-ùëò semiring is (ùëò ‚àí 1)-closed. The counting
and integer polynomial semirings are not ùëò-closed for any ùëò.

Star semirings [14], also known as closed semirings, extend
semirings with a unary ‚àó operator, having the following property:
ùëé‚àó = 1 ‚äï (ùëé ‚äó ùëé‚àó) = 1 ‚äï (ùëé‚àó ‚äó ùëé). Note that, in 0-closed semirings,
we necessarily have ùëé‚àó = 1. Similarly, in ùëò-closed semirings, we
can define ùëé‚àó = (cid:201)ùëò

ùëñ=0 ùëéùëñ .

Example 2.4. As just mentioned, since the tropical, Boolean,
ùëò-feature, and shortest-path semirings are all 0-closed, we can
simply define in all of them ùëé‚àó = 1. Since the top-ùëò semiring is
(ùëò ‚àí 1)-closed, we can define ùëé‚àó with the formula ùëé‚àó = (cid:201)ùëò
ùëñ=0 ùëéùëñ .
1In general semirings, this defines a preorder; antisymmetry of this relation can be
shown when the semiring is idempotent.

In the counting semiring we can introduce a star operator

with: 0‚àó = 1 and ùëé‚àó = ‚àû for ùëé ‚â† 0.

It is not possible to simply add a star operator to the integer
polynomial semiring (indeed, if the equation ùë• ‚àó = 1+ (ùë• √óùë• ‚àó) had
a solution ùë• ‚àó as a polynomial in ùë•, its degree would be different
on the left- and right-hand sides of the equation). However, one
can define a more general semiring, that of formal power series, in
which a star operator can be defined. See [18] for details on the
semiring of formal power series, which are not important here.

We will later use the fact that a 0-closed semiring which is
also multiplicatively idempotent (i.e., in which ùëé ‚äó ùëé = ùëé for every
ùëé) turns out to satisfy the axioms of bounded distributive lattices
[8, Theorem 10].

Example 2.5. The only 0-closed semirings that are multiplica-
tively idempotent from Example 2.2 are the Boolean and ùëò-feature
semirings.

2.2 Graph databases with provenance
We now introduce the notion of provenance in graph databases.

Definition 2.6 (Graph Database). A graph database with prove-
nance indication (ùëâ , ùê∏, ùúÜ, ùë§) over some semiring (K, ‚äï, ‚äó, 0, 1) is
an edge-labeled directed graph (ùëâ , ùê∏, ùúÜ) together with a weight
function ùë§ : ùê∏ ‚Üí K.

Given an edge ùëí = (ùë¢, ùë£) ‚àà ùê∏, we denote ùëõ[ùëí] = ùë¢ its destina-
tion (or next) vertex, and ùëù [ùëí] = ùë£ its origin (or previous vertex).
By analogy we write its weight ùë§ [ùëí] instead of ùë§ (ùëí). Given a
vertex ùë£ ‚àà ùëâ , we denote by ùê∏ [ùë£] the set of edges having ùë£ as
origin.

A path ùúã = ùëí1ùëí2 ¬∑ ¬∑ ¬∑ ùëíùëò in ùê∫ is an element of ùê∏‚àó with consecu-
tive edges: ùëõ[ùëíùëñ ] = ùëù [ùëíùëñ+1] for ùëñ = 1, . . . , ùëò ‚àí 1. We extend ùëõ and ùëù
to paths by setting ùëù [ùúã] (cid:66) ùëù [ùëí1], and ùëõ[ùúã] (cid:66) ùëõ[ùëíùëò ]. A cycle
is a path starting and ending at the same vertex: ùëõ[ùëê] = ùëù [ùëê].
The weight function ùë§ can also be extended to paths by defining
the weight of a path as the result of the ‚äó-multiplication of the

weights of its constituent edges: ùë§ [ùúã] (cid:66)

ùë§ [ùëíùëñ ]; this can in

fact be extended to any finite set of paths by ùë§ [{ùúã1, . . . , ùúãùëõ }] (cid:66)
(cid:201)ùëõ
ùëñ=1 ùë§ [ùúãùëñ ]. For any two vertices ùë• and ùë¶ of a graph ùê∫, we denote
by ùëÉùë• ùë¶ (ùê∫) the set of paths from ùë• to ùë¶.

ùëò
(cid:203)
ùëñ=1

Definition 2.7 (Path Provenance). Let ùê∫ be a graph database
with provenance indication over some semiring K. The prove-
nance between ùë• and ùë¶, for ùë• and ùë¶ two vertices of ùê∫ is defined
as the (possibly infinite) sum:

provK (ùê∫)(ùë•, ùë¶) (cid:66) ùë§ (cid:2)ùëÉùë• ùë¶ (ùê∫)(cid:3) =

(cid:202)

ùë§ [ùúã].

ùúã ‚ààùëÉùë• ùë¶ (ùê∫)

Several problems can be defined based on this. Given two
vertices ùë† and ùë°, the single-pair provenance problem computes
the provenance between ùë† and ùë°. Given a vertex ùë†, the single-
source provenance problem computes the provenance between
ùë† and each vertex of the graph. Finally, the all-pairs provenance
problem computes the provenance for all pairs of vertices.

A regular path query (RPQ) [6] defines a set of admissible paths
from some vertex ùë† through a regular language over edge labels.
The notion of single-source provenance can be generalized to that
of RPQ provenance in a straightforward manner, as we did in [31].
We also showed in [31] that computing such a provenance could
be reduced in polynomial time to the single-source provenance
problem; this works by constructing a product of the graph with

the automaton describing the language of the query. Note that
this construction can be done on-the-fly (avoiding generation of
inaccessible vertices) and that the size of the automaton is usually
quite small; thus, the overhead is usually affordable oven for large
graphs as showed experimentally in [31]. We will implicitly use
this reduction throughout the paper, meaning that we only need
to consider the single-source provenance problem in the rest of
the paper. Consequently, we will also ignore edge labels and see
a graph database as defined by its vertices, edges, and semiring
weights.

2.3 Semantics of path provenance
As defined, the provenance between two vertices in a graph data-
base is in fact a (possibly infinite) sum over the provenances of all
paths from the source vertex leading to the target vertex. As we
observed in [30], the only possible source of non-finiteness in the
sum is due to cycles in the graph, so that we only need to be able
to sum all the powers of a given semiring value. For this to be se-
mantically meaningful we need the semiring to be a star semiring,
and we additionally need the star operator to verify for all semir-
ing element ùëé: ùëé‚àó = (cid:201)‚àû
ùëõ=0 ùëéùëõ for some well-behaved infinitary
sum operation (cid:201) (namely, associativity, and distributivity of ‚äó
over this infinitary sum operator). This class of semirings is com-
monly known as countably complete star semirings, c-complete
star semirings [24], or ùúî-complete star semirings.

Example 2.8. All star semirings identified in Example 2.4 are,
indeed, c-complete star semirings. Note that, for ùëò-closed semir-
ings, the infinitary sum (cid:201)‚àû
ùëõ=0 ùëéùëõ, and the
condition of being a c-complete star semiring is trivially satisfied
by our choice of star operator. In the remaining cases (counting
semiring, formal power series, formal language semiring) one
can verify that a well-behaved infinitary sum operation can be
introduced, and that it verifies ùëé‚àó = (cid:201)‚àû

ùëõ=0 ùëéùëõ is simply (cid:201)ùëò

ùëõ=0 ùëéùëõ.

We also pointed out in [30] that all-pairs graph provenance
is equivalent to the computation of the asteration of the matrix
corresponding to the graph representation with provenance tags
as cell-values. With all these definitions in place, we observe
that the semantics of provenance over specific semirings actually
corresponds to a various number of problems of interest. Remem-
ber that using the construction of [31] we can extend this to the
provenance of arbitrary RPQs.

Example 2.9. Let ùê∫ be a graph database over some c-complete
star semiring K, and ùë† and ùë° fixed source and target vertices in ùê∫.
The provenance between ùë† and ùë° corresponds to the following
notions, depending on the semiring K:

Tropical semiring: length of shortest path between ùë† and ùë°.
Top-ùëò semiring: lengths of ùëò shortest paths between ùë† and ùë°.
Counting semiring: total number of paths between ùë† and ùë°,
edge weights being interpreted as number of edges be-
tween two vertices.

Boolean semiring: existence of a path between ùë† and ùë°,
depending on the existence of edges denoted by their
Boolean weights.

ùëò-feature semiring: minimum feature value along each di-
mension of all paths between ùë† and ùë°; if min and max are
exchanged, maximum feature value along some path from
ùë† to ùë°.

Formal power series: how-provenance, see [18].
Shortest-path semiring: pair formed of a length ùëô and path
label ùúã such that ùúã is the shortest path from ùë† to ùë°, of

length ùëô (if there are multiple shortest paths, ùúã is the first
in lexicographic order).

Example 2.10. Let us return to the example in Figure 1. We
model the charging station Boolean feature as an integer feature
by simply setting ‚ä§ = 1 and ‚ä• = 0. We take the (max, min) defi-
nition of the ùëò-feature semiring where we compute the maximum
value of each feature among some path from origin to destination,
and we order heights in decreasing order (e.g., by taking their
inverse) so that a higher feature value means a (more restrictive)
lower height.

Consider two types of vehicles of interest that want to reach
the vertex ùë° from the vertex ùë†: one has height between 3 and 4
meters, the second is a small (‚Ñé ‚©Ω 1.5) electric car that needs
at least one charging station on the road to ùë°. In the presence
of the edge from ùë¢ to ùë£, both of them can reach ùë° from ùë†; with-
out that edge, only the electric car is able to. This is reflected
in the provenance: prov(ùê∫)(ùë†, ùë°) = (4, charging station) while
prov(ùê∫\{(ùë¢, ùë£)})(ùë†, ùë°) = (2.10, charging station).

3 EXISTING ALGORITHMS
We now provide a review of three algorithms to solve the single-
source provenance problem, also previously described in [31].
Each of these algorithms yields a different trade-off between time
complexity and applicability to various types of semirings, as
summarized in Table 1.

Algorithm 1 Dijkstra ‚Äì single-source

Input: (ùê∫ = (ùëâ , ùê∏, ùë§), ùë†) a graph database with provenance in-

dication over K and the source ùë†.

Output: Array w representing the single-source provenance

from ùë† of the reachability query.

1: ùëÜ ‚Üê ‚àÖ
2: w[ùëé] ‚Üê 0, ‚àÄùëé ‚àà ùëâ
3: w[ùë†] ‚Üê 1
4: while ùëÜ ‚â† ùëâ do
5:

Select ùëé ‚àâ ùëÜ with minimal w[ùëé]
ùëÜ ‚Üê ùëÜ ‚à™ {ùëé}
for each neighbor ùëè of ùëé not in ùëÜ do
w[ùëè] = w[ùëè] ‚äï (w[ùëé] ‚äó ùë§ [ùëéùëè])

6:

7:

8:

end for
9:
10: end while
11: return w

Dijkstra. Dijskstra‚Äôs algorithm is generally used to solve
shortest-distance problems in directed graphs. However, as shown
also in [31], the algorithm readily generalizes to our semiring
context, by placing some restrictions on the semirings used. For
instance, the tropical semiring is exactly the semiring that allows
to compute the shortest distance, as in the original algorithm.
The general flow of the algorithm ‚Äì using general semiring op-
erations ‚Äì is outlined in Algorithm 1, and Table 1 indicates its
running time (in terms of the graph size and the costs of the
semiring operations ‚äï and ‚äó). Dijkstra‚Äôs algorithm is known to
be a very efficient algorithm. However, this efficiency comes from
the fact that it uses a priority queue: once a value is extracted
from it, we know that it is the correct one ‚Äì this allows us to only
visit each vertex in the graph once. This only works if we apply
Dijkstra to semirings which are 0-closed (or absorptive) and in
which an additional condition is satisfied: the natural order is a
total order [31].

As we shall discuss later, there is a large complexity gap be-
tween Dijkstra on the one hand and the other two algorithms

Table 1: Required semiring properties and asymptotic complexity for each studied algorithm, where T‚Ä¢ is the complexity
of the elementary semiring operation ‚Ä¢. The last column assumes constant cost for all semiring operations.

Name

MatrixAsteration star
NodeElimination
Mohri
MultiDijkstra
Dijkstra

Semiring property

Time complexity (with semiring op.)
O (|ùëâ |T‚àó + |ùëâ |3 (T‚äï + T‚äó))
O (|ùëâ |T‚àó + |ùëâ |3 (T‚äï + T‚äó))
c-complete star
ùëò-closed
Exponential
0-closed ‚äó-idempotent O (‚Ñì √ó (T‚äï |ùëâ | log |ùëâ | + |ùê∏| (T‚äï + T‚äó)))
0-closed total ordered

O (T‚äï |ùëâ | log |ùëâ | + |ùê∏|(T‚äï + T‚äó))

Time complexity
O (|ùëâ |3)
O (|ùëâ |3)
Exponential
O (‚Ñì √ó (|ùëâ | log |ùëâ | + |ùê∏|))
O (|ùëâ | log |ùëâ | + |ùê∏|)

we discuss in this section ‚Äì NodeElimination and Mohri ‚Äì
on the other. This is the main motivation to introduce the new
algorithm we present in Section 5.

Algorithm 2 Mohri ‚Äì single-source [29]

Input: (ùê∫ = (ùëâ , ùê∏, ùë§), ùë†) a graph database with provenance in-

dication over K and the source ùë†.

Output: Array w representing the single-source provenance

from ùë† of the reachability query.

1: for ùëñ ‚àà {1, . . . , |ùëÑ |} do
2: w[ùëñ] ‚Üê ùëü [ùëñ] ‚Üê 0
3: end for
4: w[ùë†] ‚Üê ùëü [ùë†] ‚Üê 1
5: ùëÜ ‚Üê {ùë†}
6: while ùëÜ ‚â† ‚àÖ do
ùëû ‚Üê head(ùëÜ)
7:
dequeue(ùëÜ)
ùëü ‚Ä≤ ‚Üê ùëü [ùëû]
ùëü [ùëû] ‚Üê 0
for each ùëí ‚àà ùê∏ [ùëû] do

9:

8:

10:

11:

12:

13:

14:

15:

16:

17:

if w[ùëõ[ùëí]] ‚â† w[ùëõ[ùëí]] ‚äï (ùëü ‚Ä≤ ‚äó ùë§ [ùëí]) then
w[ùëõ[ùëí]] ‚Üê w[ùëõ[ùëí]] ‚äï (ùëü ‚Ä≤ ‚äó ùë§ [ùëí])
ùëü [ùëõ[ùëí]] ‚Üê ùëü [ùëõ[ùëí]] ‚äï (ùëü ‚Ä≤ ‚äó ùë§ [ùëí])
if ùëõ[ùëí] ‚àâ ùëÜ then

enqueue(ùëÜ, ùëõ[ùëí])

end if

18:

end if
end for
19:
20: end while
21: w[ùë†] ‚Üê 1
22: return w

Mohri. Mohri [29] introduced an algorithm for computing
single-source provenance for reachability queries over ùëò-closed
semirings. Outlined in Algorithm 2, it performs, in a manner
similar to the Bellman‚ÄìFord algorithm, step-by-step relaxations
over the edges of the graph (lines 13‚Äì14), maintaining a queue to
decide in which order the elements are inspected. The queue can
be chosen in different ways: based on the topology of the graph,
e.g., if the graph is acyclic; or a queue prioritized by weight when,
e.g., one wishes to compute top-ùëò shortest paths using the top-ùëò
semiring.

In the worst case, the theoretical complexity of this approach
is exponential in the size of the graph [29], mainly due to the fact
that the algorithm may have to visit the same cycle in the graph
multiple times. However, the complexity heavily depends on the
implementation of the queue. For instance, for top-ùëò shortest
paths, implementing a priority queue allows for an efficient algo-
rithm, having polynomial complexity. Indeed, as we shall detail
later, for road transportation networks and top-ùëò shortest paths,
experiments show an almost linear-time behavior in ùëò and the
size of the graph.

In contrast, the algorithm may be much more inefficient in
practice for other types of networks (such as social networks). As
we conjecture in Section 6, this may be due to the fact that trans-
port networks have relatively low treewidth [27]. The treewidth
is a parameter measuring how much a graph (or more gener-
ally any relational instance) resembles a tree. Many intractable
problems over graphs have tractable solutions on instances of
fixed treewidth. We confirm in Section 6 that many of the algo-
rithms for provenance computation strongly benefit ‚Äì in terms
of running time ‚Äì from low treewidth.

Another important graph parameter ‚Äì stemming from the
active research community around computing routing for, e.g,
driving directions ‚Äì the highway dimension [4] has been intro-
duced to provide a theoretical basis for the efficiency observed
in practice in state-of-the-art heuristics for computing optimal
transport paths. This parameter relies heavily on weights on the
edges of the graphs and the distribution of shortest distances in
the graph. In our experiments in Section 6, we evaluate whether
this parameter also explains the practical efficiency of our algo-
rithms for computing the provenance of routing queries.

Algorithm 3 NodeElimination ‚Äì single-pair

Input: (ùê∫ = (ùëâ , ùê∏, ùë§), ùë†, ùë°) a graph database with provenance

indication over K, the source ùë†, and the target ùë°.

Output: Single value wùë†‚Ä≤ùë° ‚Ä≤ representing the single-pair prove-

nance between ùë† and ùë° of the reachability query.

1: ùëâ ‚Ä≤ ‚Üê ùëâ ‚à™ {ùë† ‚Ä≤, ùë° ‚Ä≤}
2: ùê∏ ‚Ä≤ ‚Üê ùê∏ ‚à™ {(ùë† ‚Ä≤, ùë†), (ùë°, ùë° ‚Ä≤)}
3: for ùëñ ‚àà ùëâ ‚Ä≤ do
4:

for ùëó ‚àà ùëâ ‚Ä≤ do

5:

w(0)

ùëñ ùëó ‚Üê

end for

6:
7: end for
8: for ùëò in ùëâ do
9:

(cid:26) ùë§ [ùëñ ùëó]

1 ‚äï ùë§ [ùëñ ùëó]

if ùëñ ‚â† ùëó,
if ùëñ = ùëó

for each (ùëù, ùëû) s.t. (ùëù, ùëò), (ùëò, ùëû) ‚àà ùê∏ ‚Ä≤ do
(cid:17)
ùëòùëò ‚äó wùëòùëû

(cid:16)wùëùùëò ‚äó w‚àó

wùëùùëû ‚Üê wùëùùëû ‚äï

10:

end for

11:
12: end for
13: return wùë†‚Ä≤ùë° ‚Ä≤

NodeElimination. The most general algorithm available is
based on the idea of Brzozowski and McCluskey for obtaining a
formal language expression (i.e., a regular expression) equivalent
to the language of an automaton [9]. The algorithm is outlined
in Algorithm 3. The algorithm works by eliminating vertices one
by one and computing the ‚Äúshortcut‚Äù values for each vertex pair,
until only the source and target vertices remain. This algorithm
works for any ùëê-complete semiring over which a star operation
is defined ‚Äì this is necessary for the shortcuts computed in the
algorithm to be correct.

semirings

star semirings
MatrixAsteration

c-complete star semirings
NodeElimination

ùëò-closed
Mohri

0-closed

0-closed
total order
Dijkstra

0-closed
(cid:203)-idemp.
MultiDijkstra

Figure 2: Taxonomy of the semirings used for graph provenance along with algorithms that work on them

In general, the complexity of the algorithm is at least cubic in
the number of vertices in the graph, which makes it practically
unusable on large graphs. Importantly, however, it also can be
shown that its complexity is closely related to the treewidth pa-
rameter of the graph. Following a simplicial elimination order
(unfortunately not tractable to compute) one can rephrase the
complexity shown in Table 1 in terms of the treewidth parame-
ter ùë§ by O (|ùëâ |T‚àó + |ùëâ |ùë§ 2 (T‚äï + T‚äó)). Thus, if the treewidth is
small over, e.g., transportation networks, one can benefit from
heuristics for finding a suitable elimination order to optimize this
algorithm. We dedicate a part of our experiments demonstrating
the impact of some heuristics (for instance, focusing on vertices
of higher degrees) on the running time of this algorithm.

Related algorithms. Star semirings are also known as closed
semirings [2] and the star operation is known as the closure
operation. In this sense, all-pair computations correspond to
matrix asteration. For instance, the NodeElimination algorithm
can be used to compute the asteration [2] of a matrix ‚Äì but, if the
semiring is not c-complete, there is no guarantee of a semantics
compatible with the intuitive semantics of provenance over graph
databases. Matrix asteration allows for a high degree of parallel
computation [1].

4 TAXONOMY
We present in Figure 2 a high-level view linking the properties
and classes of semiring we presented in Section 2 and their as-
sociated algorithms, presented in Sections 3 and 5. The figure
shows a clear hierarchy of classes of semirings, both in terms of
the complexity of the algorithm and the expressive power of the
semirings.

An important practical application that is similar to our setting
is the provenance for Datalog queries introduced in [18] and
further optimized using circuits [11]. Datalog [3] is a language
derived from Prolog, useful for infering new knowledge given
existing facts and a set of inference rules. In the papers above, the
semiring classes for which optimization of queries is possible are
strikingly similar: PosBool(ùëã ) and Sorp(ùëã ) discussed in [11, 18]
correspond respectively to the positive fragment of the Boolean
function semiring, and to the free (i.e., most general) 0-closed
semiring. In that sense, algorithm optimizations discussed here
apply directly to applications such as Datalog query optimization.

5 ALGORITHM FOR 0-CLOSED SEMIRINGS
As explained in Section 3, Dijkstra requires a total natural order
on the elements of a 0-closed semiring. This is quite a restrictive
setting (among the examples from Example 2.2, only the tropical
semiring fits), while using a more generally available algorithm
such as Mohri can lead to practical inefficiency. The question
we are addressing in this section is whether we can bridge this
complexity gap and still obtain practical algorithms for 0-closed
semiring without total orders.

First, we present an example semiring setting, with non-total

natural order, where Dijkstra cannot be readily applied.

Example 5.1. Let us consider the 3-feature semiring

({0, 1}3, min, max, (1, 1, 1), (0, 0, 0)).
In the example graph below, the provenance between ùë† and ùë°
is: min (max ((0, 0, 1), (0, 1, 0)) , (1, 0, 0)) = (0, 0, 0) and that be-
tween ùë† and ùëü is: min (max ((1, 0, 0), (0, 1, 0)) , (0, 0, 1)) = (0, 0, 0)

(0, 0, 1)

s

(1, 0, 0)

r

t

(0, 1, 0)

Assume there would be an order for which Dijkstra computes
this provenance. Then, starting from ùë†, Dijkstra would select
either ùëü and assign it provenance (0, 0, 1), which is wrong, or ùë°
and assign it provenance (1, 0, 0), which is also wrong.

In the following, we address this problem and design a new
algorithm, MultiDijkstra (for Multidimensional Dijkstra) that
applies to the more general case of 0-closed semirings for which
multiplication is idempotent (such as the ùëò-feature semiring, but
also the Boolean function semiring used in probabilistic databases,
see [34]). As it turns out, such semirings satisfy the axioms of
bounded distributive lattices [8, Theorem 10]; this allows us to
design an efficient algorithm for answering queries using these
types of semirings.

5.1 Mathematical Background
In the following we introduce basic notions about finite distribu-
tive lattices. We assume the lattices we use are finite because

we are only ever using the subsemiring generated by edge an-
notations. As we shall see, this subsemiring is finite when both
operations of the semiring are idempotent.

We refer the reader to [36] for more details regarding the

theory behind distributive lattices.

5.1.1 Definitions and Notation. A lattice (ùêø, <) is a partially
ordered set (poset) where every two elements have a unique
infimum (their meet, ‚àß) and supremum (their join, ‚à®). A lattice
embedding of a lattice ùêø into a lattice ùêæ is a one-to-one join
and meet homomorphism from ùêø to ùêæ. In a poset, an element ùë¶
covers ùë• (denoted ùë• ‚ãñ ùë¶) if ùë• < ùë¶ and there are no such ùëß such
that ùë• < ùëß < ùë¶. A lattice embedding ‚Ñì is tight if ùë• ‚ãñ ùë¶ implies
‚Ñì (ùë•) ‚ãñ ‚Ñì (ùë¶).2

An element ùë• of a lattice ùêø is join-irreducible if ùë• = ùëé ‚à® ùëè
implies that ùë• = ùëé or ùë• = ùëè. The set of non-zero join-irreducible
elements of ùêø is denoted ùêΩ (ùêø). It induces a subposet of ùêø which
is also denoted by ùêΩ (ùêø).

For a subset ùëÜ of a lattice ùêø, we let (cid:212) ùëÜ = (cid:212)ùë• ‚ààùëÜ ùë• be the join
of the elements of ùëÜ. We often write (cid:212)ùêø ùëÜ to specify that the join
takes place in ùêø. A subset ùëÜ of a poset is a downset or ideal if
ùë• ‚àà ùëÜ and ùë¶ ‚©Ω ùë• implies ùë¶ ‚àà ùëÜ. The minimum downset containing
an element ùë• is denoted id ùë•. We note D (ùëÉ), for a poset ùëÉ, the
family of downsets of ùëÉ ordered by inclusion.

A chain ùê∂ of length ùëõ in a poset ùëÉ is a subposet isomorphic to
the linear order Zùëõ on the ùëõ elements {0, 1, . . . , ùëõ ‚àí 1}. A chain
decomposition of a poset ùëÉ is a partition of its elements into a
family C of chains ùê∂1, . . . , ùê∂ùëë . For a family C = {ùê∂1, . . . , ùê∂ùëë }
of disjoint chains, the product (cid:206) C :=
tuples ùë• = (ùë•1, . . . , ùë•ùëë ) where ùë•ùëñ ‚àà ùê∂ùëñ for each ùëñ ‚àà {1, . . . , ùëë }. It is
ordered by ùë• ‚©Ω ùë¶ if ùë•ùëñ ‚©Ω ùë¶ùëñ for each ùëñ.

ùê∂ùëñ consists of all ùëë-

ùëë
(cid:206)
ùëñ=1

5.1.2 Results. A classical result from Birkhoff [7] establishes

an isomorphism between ùêø and D (ùêΩ (ùêø)):

Theorem 5.2 ([7]). The map S : ùë• ‚Ü¶‚Üí id ùë• ‚à© ùêΩ (ùêø) is an isomor-

phism of ùêø to D (ùêΩ (ùêø)). Its inverse is ùëÜ ‚Ü¶‚Üí (cid:212)ùêø ùëÜ .

For a chain decomposition C of a poset, let C0 be the family of
chains we get from the chains in C by adding a new minimum el-
ement to each. In [12], Dilworth proved the following embedding
theorem:

Theorem 5.3 ([12]). For any chain decomposition C of a poset ùëÉ

the map ùëÜ ‚Ü¶‚Üí (cid:212)ùëÉ ùëÜ is an embedding of D (ùëÉ) into ùëÉ = (cid:206) C0.
Then, we obtain the following corollary we will use later:

Corollary 5.4. Given a chain decomposition C of a distributive

lattice ùêø, there is a tight embedding of ùêø into (cid:206) C0.

5.2 Application to Provenance Computation
Corollary 5.4 provides us with a way to compute provenance
over distributive lattices using a multidimensional version of
Dijkstra‚Äôs algorithm. Because an embedding is a homomorphism,
we can compute each component of (cid:206) C0 independently. And
because the homomorphism is one-to-one, we can easily recover
the provenance at the end of the computation.

Example 5.5. If we take a look at distributive lattice of the
divisors of 60 with greatest common divisor (gcd) and least
common multiple (lcm) as join and meet operators, we notice
that the divisors of 60 are either powers of 2, 3, 5 or an lcm

2Implicitly from lattice notation to poset notation: ùë• ‚à® ùë¶ = ùë¶ means ùë• ‚©Ω ùë¶.

of these integers. Thus, they can be represented using three di-
mensions representing the factorization of 60 along these prime
numbers: decompose(4) = (2, 0, 0), recompose(0, 1, 0) = 3, and
recompose(2, 1, 0) = 12. We can then compute independently each
dimension of the result using Dijkstra‚Äôs algorithm since each
component is totally ordered; then, partial results are combined.

In other words, we can run separately, ‚Ñì times, Dijkstra‚Äôs algo-
rithm for each dimension of this product, where ‚Ñì is the number
of chains in the chain decomposition. This gives us a parameter-
ized algorithm, where ‚Ñì depends on the semiring. For example, for
the semiring used in Example 5.1, ‚Ñì = 3. We outline the algorithm
in pseudo-code in Algorithm 4. We need the following routines
that are highly specific to the semiring: decompose(ùëí) takes as
parameter an element ùëí of ùêø and returns its image ùë£ (ùëí) ‚àà P. For
the opposite direction recompose(ùëë1, . . . , ùëëùëõ) = (cid:212)0‚©Ωùëñ ‚©Ωùëõ ùëëùëñ returns
as expected an element of ùêø.

We use as a subroutine a slightly modified version of Dijk-
stra, parameterized by the semiring dimension and working
with semirings having elements in vector form, corresponding
to the decomposition. Dijkstra(s,t,i) ‚àà ùêΩ (ùêø) computes the prove-
nance between ùë† and ùë° corresponding to the ùëñth dimension of the
decomposition.

Example 5.6. We describe the working of Algorithm 4 in the
example presented in Example 5.1: first, each edge value is de-
composed; this step is easy to follow as the 3-feature values
are already presented in decomposed form. A second step con-
sists in calculating values along each dimensions. Algorithm 1
is launched a first time over the graph with edge values corre-
sponding to the first dimension: 0 for (ùë†, ùëü ) and (ùëü, ùë°), 1 for (ùë†, ùë°).
The result is 0. Algorithm 1 is launched a second time over the
graph with edge values corresponding to the second dimension:
0 for (ùë†, ùëü ) and (ùë†, ùë°), 1 for (ùëü, ùë°). The result is, again, 0. Finally,
Algorithm 1 is launched a third time over the graph with edge
values corresponding to the third dimension: 0 for (ùë†, ùë°), 1 for
(ùë†, ùëü ) and (ùëü, ùë°). The result is 0. This ends the second step. The
third step consists in recomposing partial values obtained by
successive applications of Dijkstra‚Äôs algorithm. This ends up to
the final provenance value of (0, 0, 0).

Algorithm 4 MultiDijkstra ‚Äì single-pair

Input: (ùê∫ = (ùëâ , ùê∏, ùë§), ùë†, ùë°) a graph database with provenance

indication over K, the source ùë†, and the target ùë°.

Output: Single-pair provenance of the reachability query from ùë†

to ùë°.

1: for each edge ùëí ‚àà ùê∏ do
decompose(ùë§ (ùëí))
2:
3: end for
4: for each dimension ùëñ do
ùëëùëñ ‚Üê Dijkstra(ùë†, ùë°, ùëñ)
5:
6: end for
7: return recompose(ùëë1, . . . , ùëëùëõ)

For the sake of simplicity, we presented the single-pair version
of our algorithm. To extend it to the single-source version one
only needs to perform the recompose subroutine for each vertex
in the graph.

To minimize accesses to the decompose subroutine ‚Äì which
can be very costly ‚Äì we optimize MultiDijkstra by adopting
a lazy approach, where the Dijkstra subroutine calls decompose
only when needed, storing the decomposition across calls. This
avoids scanning the whole graph when ùë† and ùë° are close.

)
s
(

e
m

i
t

1 000

100

10

1

0.1

0.01

0.001

Rome99, original

Rome99, random

Rome99, same USPowerGrid, random Yeast, random

Stif, random

BFS

Dijkstra (Tropical)

Mohri (Tropical)

Mohri (Top-k)

NodeElimination-Degree (Tropical)

Figure 3: Comparison between algorithms for shortest distances

Table 2: Graph datasets: size and treewidth lower and up-
per estimates from [27]

type

name

# of vertices

# of edges

tw

infrastructure

social
biology

Paris
Stif
USPowerGrid
Rome99
Facebook
Yeast

4 325 486
17 720
4 941
3 353
4 039
2 284

5 395 531
31 799
6 594
4 831
88 234
6 646

55‚Äì521
28‚Äì86
10‚Äì18
5‚Äì50
142‚Äì237
54‚Äì255

Two other optimizations implemented are a stopping condi-
tion that ends the Dijkstra subroutine when a visited vertex has
value 0, and lazy initialization of the priority queue. These two
optimizations led to vastly improved computation times over the
naive implementation.

5.3 Practical Use Case
As exemplified in the Introduction, ùëò-feature semirings can be
used to ensure that all paths from ùë† to ùë° verify a combination of
features (they all go through a specific set of points of interests,
or verify some road properties) or either ensure the existence
of valid paths up to some collection of restrictions. We show in
the experimental section that this is tractable for practical use
cases (continental-sized areas, around 107 vertices). To the best
of our knowledge, no solution for this that scales even to graphs
of thousands of vertices has been previously proposed.

6 EXPERIMENTS
We performed experiments on real-world graph data, using an
Inria computing cluster running the OAR task manager. The
individual vertices of the cluster have a minimum of 48 GB of
RAM, and run Intel Xeon X5650 or E5-26xx CPUs.

We used datasets3 from a variety of domains, mostly repre-
senting infrastructure networks: the OpenStreetMaps network
of Paris (Paris), the Paris public transport network (Stif), and

the power grid of the continental US (USPowerGrid). For com-
parison, we have also evaluated on other types of datasets: a
small subset of the Facebook social network (Facebook) and
the yeast protein-to-protein interaction network (Yeast). All
these datasets come without provenance annotations, that we
add in different ways depending on experiments. We also used
a real weighted road transportation network dataset Rome99,
with tropical semiring annotations, from the 9th DIMACS Imple-
mentation Challenge4. This dataset consists of a large portion of
the directed road network of the city of Rome, Italy, from 1999.
Basic information about the resulting graphs are summarized in
Table 2.

For datasets without provenance annotations, unless speci-
fied differently, we randomly generate weights in the tropical
semiring for benchmarks, uniformly between 1 and 3 000. To be
able to compare the impact of the weights on the performance
of the algorithms, we also use a constant-weight setting, where
all weights equal to 1. Each experiment generally represents the
average over 10 runs (random choices of origin and destination
vertices).

Our experimental study is focused on comparing the four algo-
rithms presented in this paper, over several semirings. We provide
a comparison of all of our algorithms for the computation over
the tropical semiring (shortest distance), since all algorithms can
be used in this setting. We investigate the running time and the
number of relaxation steps performed by Mohri and MultiDi-
jkstra algorithm, using initial weights provided by the dataset
Rome99, as well as custom weights (all identical and all random);
we then study over all datasets the impact of the elimination or-
der heuristic on the overall performance for NodeElimination.
We then finish with the comparison between our new algorithm
and previous solutions to demonstrate its efficiency.

Evaluating shortest distances. We start by evaluating how the
algorithms deal with the shortest distance semiring, i.e., the trop-
ical and top-ùëò semiring (by setting ùëò = 1). The properties of this
semiring allow their implementation for the first three algorithms:

3These datasets were used in [27] for treewidth computation experiments, and are
downloadable from https://github.com/smaniu/treewidth/; some of them originate
from http://snap.stanford.edu/data/index.html.

4http://users.diag.uniroma1.it/challenge9/download.shtml

)
s
(

e
m

i
t

4.5

4

3.5

3

2.5

2

1.5

1

0.5

0

0

Mohri, original
Mohri, random
Mohri, same

5

10

15

20

25

30

35

40

45

50
k

55

60

65

70

75

80

85

90

95

100

Figure 4: Computation time for Mohri over the top-ùëò distances semiring, for varying values of ùëò and varying weight
assignments (Rome99)

)
4
0
1
√ó

(
d
e
m
r
o
f
r
e
p
s
n
o
i
t
a
x
a
l
e
r

f
o
b
n

17
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
0

Mohri, original
Mohri, random
Mohri, same

0

5

10

15

20

25

30

35

40

45

50
k

55

60

65

70

75

80

85

90

95

100

Figure 5: Number of relaxations performed by Mohri over the top-ùëò distances semiring, for varying values of ùëò and varying
weight assignments (Rome99)

)
s
(

e
m

i
t

1.4 ¬∑ 103

1.2 ¬∑ 103

1 ¬∑ 103

4.2 ¬∑ 102

9.3 ¬∑ 103

6.8 ¬∑ 101

6.8 ¬∑ 101

6.8 ¬∑ 101

3.1 ¬∑ 101

3 ¬∑ 101

3.1 ¬∑ 101

1.2 ¬∑ 101

2 ¬∑ 101

100 000

10 000

1 000

100

10

Rome99, original

Rome99, random

Rome99, same USPowerGrid, random Yeast, random Facebook, random Stif, random

Paris, random

NodeElimination (Id)

NodeElimination (Degree)

Figure 6: Comparison between elimination orders for NodeElimination algorithm (tropical semiring). Values greater
than 100 000 s are timeouts.

Dijkstra, Mohri, and NodeElimination, whereas MultiDijk-
stra reduces to Dijkstra in that case. We also implemented a
breadth-first-search traversal for computing accessibility with

no provenance information (BFS). This also allows us to com-
pare the performance of algorithms against non-annotated graph
databases.

4.2 ¬∑ 101

1.4 ¬∑ 101

)
s
(

e
m

i
t

2.2 ¬∑ 10‚àí3

6.3 ¬∑ 10‚àí4

1.1 ¬∑ 10‚àí3

7.2 ¬∑ 10‚àí4

1.5 ¬∑ 103

3.9 ¬∑ 10‚àí2

2.9 ¬∑ 10‚àí2

1 000

100

10

1

0.1

0.01

0.001

Rome99, random

USPowerGrid, random

Stif, random

NodeElimination (Degree)

Mohri

MultiDijkstra

Figure 7: Comparison between NodeElimination, Mohri, and MultiDijkstra (3-feature semiring)

)
s
(

e
m

i
t

103

101

10‚àí1

10‚àí3

1

Mohri, 5 values
Mohri, 4 values
Mohri, 3 values
MultiDijkstra, 5 values
MultiDijkstra, 4 values
MultiDijkstra, 3 values

2

3

number of features

4

5

6

Figure 8: Computation time for Mohri and MultiDijkstra depending on the number of dimensions (Rome99)

Mohri
MultiDijkstra

)
s
(

e
m

i
t

101

100

10‚àí1

10‚àí2

10‚àí3

104

105

number of nodes

106

107

Figure 9: Average computation time for Mohri and MultiDijkstra over random graphs depending on the number of
nodes; shaded areas indicate minimum and maximum computation times observed (3-feature semiring)

Figure 3 shows, on a logarithmic scale, the result for our graphs,
and for some settings of weights (original, random, or same
weights). It is immediately clear from the figure that the choice
of algorithm is crucial: we need the most specialized algorithm
for the semiring we use: Dijkstra is more efficient than Mohri
which is more efficient than NodeElimination. Even for Mohri,

we notice that using it configured for the top-ùëò semiring with
ùëò = 1 does introduce an overhead in execution; when using the
tropical semiring directly the overhead is smaller. We also show
the overhead introduced when using provenance annotations
is quite limited, as the difference between Dijkstra and BFS is
less than an order of magnitude for each dataset, and Dijkstra

sometimes even outperforms BFS. Finally, NodeElimination is
always several orders of magnitude slower than Dijkstra. Another
encouraging result is that Mohri ‚Äì which allows more classes
of semirings than Dijkstra ‚Äì has a reasonable running time in
practice, despite the stated exponential complexity bound in the
original paper. We turn to evaluating its performance next.

Mohri in practice. In Figure 4 and in Figure 5 we respectively
study the impact of the factor ùëò on the running time and on the
number of computations performed by the algorithm. Our results
show that the computational time is linear in ùëò, though this is
not the case for the number of relaxations, which increases sub-
linearly in ùëò. This means that for large values of ùëò the algorithm
spends most of its time maintaining the queue.

We also compare the performance of the algorithm depending
on weight assignment (original, random, same). It seems that
considering random values instead of ‚Äúreal‚Äù values has almost no
significant impact over the efficiency of the algorithm. This is a
somewhat disappointing result because it rules out the possibility
to parametrize the complexity of the algorithm through network
parameters, for instance, in terms of the highway dimension [4] ‚Äì
a graph parameter that has been successfully applied for under-
standing the efficiency of state-of-the-art shortest-distance algo-
rithms in road networks. However, the performance increases sig-
nificantly when all weights are uniform, which may be expected
since computation of shortest distances become far simpler, and
far more paths have equal distance.

As pointed out in Section 3 this algorithm performs extremely
well over transportation networks. We wanted to provide a com-
parison of its working time for different kinds of graphs (es-
pecially graphs whose treewidth is large relative to their size).
For this purpose we used a social network dataset: who-trusts-
whom network of people who trade using Bitcoin on a platform
called Bitcoin Alpha [25, 26] (3 783 vertices and 24 186 edges).
The algorithm times out after 48 hours.

What we can learn from this is that the key property making
Mohri so efficient over transportation networks is not due to
distance properties (e.g., highway dimension) ‚Äì impacted by the
weights of the connections ‚Äì but rather by topological properties
of the underlying graph (e.g., treewidth).

Ordering for NodeElimination. NodeElimination‚Äôs perfo-
mance, due to its main loop of creating ‚Äúshortcuts‚Äù in the graph,
is heavily dependent on the order in which the vertices are
eliminated. This elimination ordering is strongly linked to the
treewidth parameter of the graph. For instance, following a degree
based elimination order gives an upper bound on this parameter.
Hence, we have compared different elimination orders for
NodeElimination and found out that the minimum degree based
elimination order (Degree) greatly improves the efficiency of
this algorithm compared to having no such heuristic (Id). This
improvement can be dramatic, as for the Yeast dataset where the
algorithm is two orders of magnitude faster. As expected, weights
over the edges doesn‚Äôt impact the running time, as shown in
Figure 6.

This is important in practice: running NodeElimination on
low-treewidth graphs (e.g., infrastructure and transport networks)
can be the difference between the algorithm being unusable and
allowing reasonable running times. Taking into account that
NodeElimination allows for a large class of semirings, this can
have a significant real-world application impact.

MultiDijkstra. We now evaluate MultiDijkstra, our con-
tribution to bridging the gap between absorptive semirings and
more general ones. We compare it to Mohri and NodeElimina-
tion in the case of the ùëò-feature semiring, which is kind of the
canonical semiring that is 0-closed and multiplicatively idem-
potent. Figure 7 showcases this on 3 datasets. In all cases, our
new algorithm is between 3 and 4 orders of magnitude faster
than NodeElimination, depending on the network we use, and
significantly faster than Mohri.

We then performed an additional experiment (Figure 8), exam-
ining the impact of the number of features and values actually
used in each feature on the running time of both algorithms. We
found out that when either one of the two criteria reaches 4,
Mohri times out while MultiDijkstra keeps scaling.

Finally, Figure 9 presents a comparison between Mohri and
MultiDijkstra on large Erd≈ës‚ÄìR√©nyi random generated graphs
(generated using Python networkx‚Äôs fast_gnp_generation method,
using an average of 1.7 edges per vertex) show that our new
algorithm is still tractable for continental-sized graphs of millions
of vertices. Interestingly, MultiDijkstra also exhibits a much
smaller variance than that of Mohri, whose performance varies
by more than one order of magnitude between runs.

7 RELATED WORK
The idea of encapsulating operations carried along by graph algo-
rithms in terms of semirings has been really common for decades.
In [10, Chapter 25] the authors presented two of the classical
graph algorithms, Floyd‚ÄìWarshall and transitive closure algo-
rithm in terms of closed semirings. The APSP (All-Pairs Shortest-
Path problem) is elegantly expressible using star semirings; hence,
research focused on the links to linear algebra through matrix
computations [1], allowing to speed up the response time using
parallel computations. Recent work on semiring-based graph
processing has provided to the community some tools such as
GraphBLAS [23], a library of kernel functions dedicated to opti-
mize linear algebra computations over sparse matrices. Unfortu-
nately, this tool focuses essentially on matrix and vector products
and is not amenable to express priority queue management such
as those needed for Mohri, Dijkstra, MultiDijkstra. Only
NodeElimination and the matrix asteration algorithms could
benefit of a GraphBLAS implementation: this might increase
their performance, even when retaining their higher asymptotic
complexity with respect to other algorithms.

Amongst many other fields, semirings have been successfully
applied in constraint-solving programming [8], linguistic struc-
ture prediction [37] and formal language theory [33]. This alge-
braic structure is also perfectly suited to the modeling of dynamic
programming [21].

The notion of provenance has also been initially developed
using semirings [18], either for relational databases and Datalog
programs, leading to practical systems such as [35], an exten-
sion to PostgreSQL adding the support for provenance. Many
representation frameworks have been successfully applied to
speed up the computation of the provenance for Datalog pro-
grams, most notably a circuit-based provenance approaches [11]
and the solving of fixed-point equations using derivation tree
analysis [15]. The latter approach led to a proof-of-concept im-
plementation [16] of the resolution of fixed-point equations over
c-continuous semirings using the Newton method.

Compared to our work, relational databases lack the effective
support for navigational queries (recursion is an issue) and Data-
log programs are much more expressive than graphs (they are
closely related to hypergraphs), so we suspect query answering
in Datalog would be highly inefficient for the continental-sized
road-network datasets we target, though we leave this investiga-
tion for future work.

Numerous notions of provenance co-exist in the literature and
each target different usages. The notion we use in this paper
considers the provenance to be computational rather than just in-
formational: we can apply operations over our provenance values
with different semantics depending on the underlying semiring.
Some practical systems, such as [28] rely on property graphs to
represent provenance annotations, that are of an informational
rather than computational nature. Those systems focus on the
further querying of obtained provenance to derive additional
information about the process.

8 CONCLUSIONS
We presented in this paper a study on evaluating the provenance
of rich graph queries using the semiring provenance framework.
We established a taxonomy of semiring classes, based on their
properties. This in turn allows us to find, for a set of impor-
tant semiring classes, the most appropriate algorithm, enabling
real-world applicability. We introduce a new algorithm, MultiDi-
jkstra, which bridges the gap between algorithms for absorptive
semirings and ones for more general classes.

Experimentally, on graph datasets from various domains, we
showed that making sure that the appropriate algorithm is chosen
for the semiring specialization is crucial; gains of several orders of
magnitude are observed between algorithms on the same graph
datasets. Moreover, we notice that algorithms for which their
theoretical complexity is high perform well in practice, especially
on graphs having relatively low treewidth.

We believe the link with classes of semiring for which an
optimization for the computation of the provenance for Datalog
queries exists is a key observation for optimizing computations
in our framework. Investigating this further will allows us to
benefit from the rich literature around Datalog provenance (in
particular, [11]) and to compare to our solutions.

ACKNOWLEDGMENTS
This work has been funded by the French government under
management of Agence Nationale de la Recherche as part of the
‚ÄúInvestissements d‚Äôavenir‚Äù program, reference ANR-19-P3IA-0001
(PRAIRIE 3IA Institute).

REFERENCES
[1] S. Kamal Abdali. 1994. Parallel Computations in *-Semirings. In Computational
Algebra, Klaus G. Fischer, Philippe Loustaunau, Jay Shapiro, Edward L. Green,
and Daniel Farkas (Eds.). Taylor & Francis, Chapter 1, 1‚Äì16.

[2] S. Kamal Abdali and David Saunders. 1985. Transitive closure and related
semiring properties via eliminants. Theoretical Computer Science 40 (1985),
257‚Äì274. https://doi.org/10.1016/0304-3975(85)90170-7
[3] Serge Abiteboul, Richard Hull, and Victor Vianu. 1995.

Foundations of

Databases. Addison Wesley.

[4] Ittai Abraham, Amos Fiat, Andrew V. Goldberg, and Renato Fonseca F. Wer-
neck. 2010. Highway Dimension, Shortest Paths, and Provably Efficient Algo-
rithms. In SODA. Society for Industrial and Applied Mathematics, Philadelphia,
PA, USA, 782‚Äì793. http://dl.acm.org/citation.cfm?id=1873601.1873665
[5] Marcelo Arenas and Jorge P√©rez. 2011. Querying semantic web data with

SPARQL. In PODS. New York, 305‚Äì316.

[6] Pablo Barcel√≥. 2013. Querying Graph Databases. In PODS. ACM, New York,

175‚Äì188.

[7] Garrett Birkhoff. 1937. Rings of sets. Duke Math. J. 3, 3 (1937), 443‚Äì454.

https://doi.org/10.1215/S0012-7094-37-00334-X

[8] Stefano Bistarelli, Ugo Montanari, and Francesca Rossi. 1997. Semiring-based
constraint satisfaction and optimization. J. ACM 44, 2 (1997), 201‚Äì236. https:
//doi.org/10.1145/256303.256306

[9] Janusz A. Brzozowski and Edward J. McCluskey. 1963. Signal Flow Graph
Techniques for Sequential Circuit State Diagrams. IEEE Trans. Electr. Comp.
EC-12, 2 (1963), 67‚Äì76.

[10] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.

2001. Introduction to Algorithms (2nd ed.). The MIT Press.

[11] Daniel Deutch, Tova Milo, Sudeepa Roy, and Val Tannen. 2014. Circuits for

Datalog Provenance. In ICDT. 201‚Äì212.

[12] Robert P. Dilworth. 1950. A Decomposition Theorem for Partially Ordered
Sets. Annals of Mathematics 51, 1 (1950), 161‚Äì166. http://www.jstor.org/
stable/1969503

[13] Pedro Domingos and Matthew Richardson. 2001. Mining the network value

of customers. In KDD. ACM, New York, 57‚Äì66.

[14] Manfred Droste, Werner Kuich, and Heiko Vogler. 2009. Handbook of Weighted

Automata. Springer, Berlin.

[15] Javier Esparza and Michael Luttenberger. 2011. Solving fixed-point equa-
tions by derivation tree analysis. In International Conference on Algebra and
Coalgebra in Computer Science. Springer, 19‚Äì35.

[16] Javier Esparza, Michael Luttenberger, and Maximilian Schlund. 2014. FP-
soLvE: A Generic Solver for Fixpoint Equations Over Semirings.
Interna-
tional Journal of Foundations of Computer Science 26. https://doi.org/10.1007/
978-3-319-08846-4_1

[17] Nadime Francis, Andr√©s Taylor, Alastair Green, Paolo Guagliardo, Leonid
Libkin, Tobias Lindaaker, Victor Marsault, Stefan Plantikow, Mats Rydberg,
and Petra Selmer. 2018. Cypher: An Evolving Query Language for Property
Graphs. In SIGMOD. 1433‚Äì1445. https://doi.org/10.1145/3183713.3190657
[18] Todd J. Green, Grigoris Karvounarakis, and Val Tannen. 2007. Provenance

Semirings. In PODS. ACM, New York, 31‚Äì40.

[19] Todd J. Green and Val Tannen. 2017. The Semiring Framework for Database
Provenance. In PODS. Association for Computing Machinery, New York, NY,
USA, 93‚Äì99. https://doi.org/10.1145/3034786.3056125

[20] Udo Hebisch and Hanns J. Weinert. 1998. Semirings: Algebraic Theory and

Applications in Computer Science. World Scientific, Singapore.

[21] Liang Huang. 2008. Advanced Dynamic Programming in Semiring and Hy-

pergraph Frameworks. (2008), 18.

[22] ISO SC32 / WG3. [n.d.]. Graph Query Language GQL.

https://www.

gqlstandards.org/.

[23] J. Kepner, P. Aaltonen, D. Bader, A. Bulu√ß, F. Franchetti, J. Gilbert, D. Hutchison,
M. Kumar, A. Lumsdaine, H. Meyerhenke, S. McMillan, C. Yang, J. D. Owens,
M. Zalewski, T. Mattson, and J. Moreira. 2016. Mathematical foundations of
the GraphBLAS. In 2016 IEEE High Performance Extreme Computing Conference
(HPEC). 1‚Äì9. https://doi.org/10.1109/HPEC.2016.7761646

[24] Daniel Krob. 1987. Monoides et semi-anneaux complets. Semigroup Forum 36

(1987), 323‚Äì339.

[25] Srijan Kumar, Bryan Hooi, Disha Makhija, Mohit Kumar, Christos Faloutsos,
and V. S. Subrahmanian. 2018. Rev2: Fraudulent user prediction in rating
platforms. In WSDM. 333‚Äì341.

[26] Srijan Kumar, Francesca Spezzano, V. S. Subrahmanian, and Christos Faloutsos.
2016. Edge weight prediction in weighted signed networks. In ICDM. 221‚Äì230.
[27] Silviu Maniu, Pierre Senellart, and Suraj Jog. 2019. An Experimental Study
of the Treewidth of Real-World Graph Data. In ICDT. Lisbon, Portugal, 18.
https://doi.org/10.4230/LIPIcs.ICDT.2019.12

[28] Hui Miao, Amit Chavan, and Amol Deshpande. 2016. ProvDB: A System
for Lifecycle Management of Collaborative Analysis Workflows. CoRR
abs/1610.04963 (2016). arXiv:1610.04963 http://arxiv.org/abs/1610.04963
[29] Mehryar Mohri. 2002. Semiring Frameworks and Algorithms for Shortest-

distance Problems. J. Autom. Lang. Comb. 7, 3 (2002), 321‚Äì350.

[30] Yann Ramusat. 2019. Provenance-Based Routing in Probabilistic Graph
Databases. In VLDB 2019 PhD Workshop. http://ceur-ws.org/Vol-2399/paper08.
pdf

[31] Yann Ramusat, Silviu Maniu, and Pierre Senellart. 2018. Semiring Provenance
over Graph Databases. In TaPP. https://www.usenix.org/conference/tapp2018/
presentation/ramusat

[32] Ian Robinson, Jim Webber, and Emil Eifrem. 2013. Graph Databases. O‚ÄôReilly

Media.

[33] Arto Rozenberg, Grzegorz; Salomaa. 1997. Handbook of Formal Languages ||
Semirings and Formal Power Series: Their Relevance to Formal Languages
and Automata. Vol. 10.1007/978-3-642-59136-5.
https://doi.org/10.1007/
978-3-642-59136-5_9

[34] Pierre Senellart. 2017. Provenance and Probabilities in Relational Databases:

From Theory to Practice. SIGMOD Record 46, 4 (2017).

[35] Pierre Senellart, Louis Jachiet, Silviu Maniu, and Yann Ramusat. 2018. ProvSQL:
Provenance and Probability Management in PostgreSQL. Proceedings of the
VLDB Endowment (PVLDB) 11, 12 (Aug. 2018), 2034‚Äì2037. https://doi.org/10.
14778/3229863.3236253

[36] Mark Siggers. 2014. On the representation of finite distributive lattices. arXiv

1412.0011 [math] (2014), 16. http://arxiv.org/abs/1412.0011

[37] Noah A. Smith. 2011. Linguistic Structure Prediction. Synthesis Lectures on
Human Language Technologies 4, 2 (May 2011), 1‚Äì274. https://doi.org/10.2200/
S00361ED1V01Y201105HLT013

[38] Oskar van Rest, Sungpack Hong, Jinha Kim, Xuming Meng, and Hassan Chafi.
2016. PGQL: A Property Graph Query Language. In GRADES. ACM, New
York, NY, USA, Article 7, 6 pages. https://doi.org/10.1145/2960414.2960421

