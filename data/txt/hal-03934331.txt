Propositional and predicate logics of incomplete
information
Marco Console, Paolo Guagliardo, Leonid Libkin

To cite this version:

Marco Console, Paolo Guagliardo, Leonid Libkin. Propositional and predicate logics of incomplete in-
formation. Artificial Intelligence, 2022, 302, pp.103603. ￿10.1016/j.artint.2021.103603￿. ￿hal-03934331￿

HAL Id: hal-03934331

https://inria.hal.science/hal-03934331

Submitted on 5 Dec 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Propositional and Predicate Logics of Incomplete Information
Citation for published version:
Console, M, Guagliardo, P & Libkin, L 2018, Propositional and Predicate Logics of Incomplete Information.
in Proceedings of the Sixteenth International Conference on Principles of Knowledge Representation and
Reasoning (KR-18). Principles of Knowledge Representation and Reasoning, AAAI Press, Tempe, Arizona,
USA, pp. 592-601, 16th International Conference on Principles of Knowledge Representation and
Reasoning, Tempe, Arizona, United States, 30/10/18.
<https://www.aaai.org/ocs/index.php/KR/KR18/paper/view/18068>

Link:
Link to publication record in Edinburgh Research Explorer

Document Version:
Peer reviewed version

Published In:
Proceedings of the Sixteenth International Conference on Principles of Knowledge Representation and
Reasoning (KR-18)

General rights
Copyright for the publications made accessible via the Edinburgh Research Explorer is retained by the author(s)
and / or other copyright owners and it is a condition of accessing these publications that users recognise and
abide by the legal requirements associated with these rights.

Take down policy
The University of Edinburgh has made every reasonable effort to ensure that Edinburgh Research Explorer
content complies with UK legislation. If you believe that the public display of this file breaches copyright please
contact openaccess@ed.ac.uk providing details, and we will remove access to the work immediately and
investigate your claim.

Download date: 05. Dec. 2023

     Edinburgh Research Explorer                                      Propositional and Predicate Logics of Incomplete Information

Marco Console and Paolo Guagliardo and Leonid Libkin
School of Informatics, University of Edinburgh

Abstract

One of the most common scenarios of handling incomplete
information occurs in relational databases. They describe in-
complete knowledge with three truth values, using Kleene’s
logic for propositional formulae and a rather peculiar exten-
sion to predicate calculus. This design by a committee from
several decades ago is now part of the standard adopted by
vendors of database management systems. But is it really the
right way to handle incompleteness in propositional and pred-
icate logics?
Our goal is to answer this question. Using an epistemic ap-
proach, we ﬁrst characterize possible levels of partial knowl-
edge about propositions, which leads to six truth values. We
impose rationality conditions on the semantics of the connec-
tives of the propositional logic, and prove that Kleene’s logic
is the maximal sublogic to which the standard optimization
rules apply, thereby justifying this design choice. For exten-
sions to predicate logic, however, we show that the additional
truth values are not necessary: every many-valued extension
of ﬁrst-order logic over databases with incomplete informa-
tion represented by null values is no more powerful than the
usual two-valued logic with the standard Boolean interpreta-
tion of the connectives. We use this observation to analyze the
logic underlying SQL query evaluation, and conclude that the
many-valued extension for handling incompleteness does not
add any expressiveness to it.

Introduction
Incomplete information is ubiquitous in applications that in-
volve querying and reasoning about data. It is one of the
oldest topics in database research (Codd 1975), and is es-
sential in many applications such as data integration (Lenz-
erini 2002), data exchange (Arenas et al. 2014), inconsistent
databases (Bertossi 2011), and ontology-based data access
(Bienvenu and Ortiz 2015).

When it comes to querying incomplete data, practical so-
lutions, such as relational databases, rely on many-valued
logics to properly account for the lack of certainty. In fact,
every database management system (DBMS) uses a three-
valued logic for handling incomplete information, namely
Kleene’s logic (Bolc and Borowik 1992). This was the de-
sign choice of SQL, the language of relational DBMSs,

which is now written into the SQL Standard (ISO/IEC
2016), presented in all database textbooks, and implemented
in all database products. However, this is far from the only
logic to have been considered for representing incomplete
information. The use of Kleene’s logic was ﬁrst proposed by
Codd (1975), but many other variants appeared afterward.
Codd (1987) looked at a four-valued logic, but in the end
argued against it due to the additional complexity. Nonethe-
less, well-documented problems with incomplete informa-
tion (Date and Darwen 1996; Date 2005) led to the search
of more appropriate logics for handling incompleteness. For
example, Gessert (1990) revisited four-valued logics, while
Yue (1991) considered logics with four, ﬁve, and seven val-
ues, and showed how to encode them with three. A different
kind of four-valued logics for missing data was studied by
Console, Guagliardo, and Libkin (2016), while Darwen and
Date (1995) suggested dropping nulls altogether and go back
to the usual Boolean two-valued logic.

There is also no shortage of many-valued logics that have
been proposed in closely related contexts. For example, a
variety of many-valued logics were used in the study of de-
fault reasoning (Reiter 1980) or in reasoning about incon-
sistency (Zamansky and Avron 2006). Those are typically
based on the notion of bilattices, providing truth and knowl-
edge orderings on the truth values (Arieli and Avron 1996;
Ginsberg 1988). A common one is Belnap’s bilattice with
four truth values (Belnap 1977; Arieli and Avron 1998),
which also found database applications (Grahne, Moallemi,
and Onet 2015); but others exist as well, e.g., many general-
izations of Kleene’s logic based on numerical intervals de-
scribing the degree of being true (Fitting 1991). A many-
valued propositional logic must also provide an interpreta-
tion of propositional connectives. To make the general pic-
ture even muddier, for different sets of truth values, differ-
ent semantics of propositional connectives exist, sometimes
even non-deterministic ones (Arieli, Avron, and Zamansky
2010).

Thus, we are far from having a clear picture of what to use
as a logic of incomplete information in data management
applications. Choices are numerous, and there is no ﬁnal ar-
gument as to why the approach of DBMSs that use Kleene’s
logic is the right one. Hence, the ﬁrst question we address is:

Copyright c(cid:13) 2018, Association for the Advancement of Artiﬁcial
Intelligence (www.aaai.org). All rights reserved.

1) What is the right many-valued propositional logic for

handling incomplete information?

Now suppose we have a propositional logic that correctly
accounts for truth values of statements about incomplete in-
formation, and for operations on them. In querying data,
however, we use predicate logics. Indeed, the core of SQL
is essentially a programming syntax for relational calculus,
which is another name for ﬁrst-order (FO) predicate logic.

Of course we know how to lift the semantics of propo-
sitional logic to the full predicate calculus by treating ex-
istential and universal quantiﬁers as disjunctions and con-
junctions over all elements of the universe. What we do not
know is how different choices of propositional logic for in-
complete information affect the power of predicate calculus.
As one example, consider the version of FO that underlies
SQL and is based on Kleene’s logic. What extra power does
it possess over FO under the usual two-valued Boolean in-
terpretation of the connectives? It was recently argued, by
means of rewriting SQL queries, that FO based on Kleene’s
logic can be encoded in the usual Boolean FO (Guagliardo
and Libkin 2017). But is there a general result in logic that
underlies such a translation, and what is so special about
Kleene’s logic that makes it work?

Even more generally, the second question we would like

to address is:

2) How does the choice of a propositional logic for incom-

plete information affect predicate logic?

Finally, we would like to understand how these theoretical
considerations relate to the practice of incomplete data in
relational databases. A rough approximation of the core of
SQL – the way it is presented in many database textbooks
– is ﬁrst-order logic. But as soon as incomplete information
enters the picture, this becomes a many-valued FO. And yet
there is even more to it: in SQL queries, answer tuples are
split into true ones that need to be returned, and others that
are not returned, thus collapsing a three-valued logic to two-
valued. This leads to our last question:

3) What is the logic that underlies real-life handling of in-
complete information in relational databases (i.e., SQL’s
logic), and how much more power than the usual two-
valued FO does it possess?

The goal of this paper is to address these three questions.

Below we outline our main contributions.

Propositional logic To understand what a proper proposi-
tional logic for reasoning about incomplete information is,
we need to deﬁne its truth values, and truth tables for its
connectives (we shall concentrate on the standard ones, i.e.,
∧, ∨, and ¬, although we shall see others as well). We follow
the approach of Ginsberg (1988) to turn partial knowledge
about the truth of a proposition into truth values. If we have
a set W of worlds, and two of its subsets T and F in which
a proposition is true and false, respectively, this produces a
description (T, F, W ). It is possible that T ∪ F (cid:54)= W , i.e.,
we may have partial knowledge about the truth or falsity of
a proposition. We require however that T ∩ F = ∅, as here
we do not consider inconsistent descriptions.

Taking those descriptions (T, F, W ) directly as truth val-
ues, however, is not satisfactory: we shall have too many of

them. Instead, we want to take as truth values what we know
about such descriptions.

We abstract this knowledge as epistemic theories of such
descriptions: they say what is known about a proposition be-
ing possibly or certainly true or false. Then, as truth values
we take maximally consistent epistemic theories. We show
that there are only six such theories, resulting in a six-valued
logic L6v. Its truth tables are again very naturally derived
from epistemic theories of partial knowledge about truth of
propositions.

As a ﬁnal step, we then look at what makes a many-valued
logic database friendly. It needs to be a sublogic of L6v and
yet satisfy some basic equivalences we expect to hold to be
able to perform query evaluation and optimization. We then
show that the maximal sublogic of L6v that satisﬁes those
equivalences is L3v, the three-valued logic of Kleene used
in all commercial DBMSs. Thus, we justify the choice that
was made by SQL designers and standards committees in
choosing L3v as the logic to be implemented in all database
products.

Predicate logic We have justiﬁed Kleene’s logic L3v as the
right choice for handling incompleteness in database con-
texts. But database languages are not propositional: they are
based on FO instead. Thus, we next look at variants of FO
based on propositional many-valued logics such as L3v and
L6v, and compare their power with that of the usual Boolean
FO (denoted by BFO from now on), based on just two val-
ues t and f. Our main result is that when added to FO, these
many-valued propositional logics add no power: FO based
on L3v, or on L6v, or on any other many-valued logic (un-
der some mild restrictions on the connectives) has no more
power than BFO.

The logic of SQL We ﬁnally apply the above observation
to SQL’s logic. We explain that it corresponds to a L3v-based
FO with an extra connectives that allows one to collapse
truth values f and u into one, but it still has no more power
than BFO. Thus, even though SQL designers were justiﬁed
in choosing Kleene’s logic as the propositional logic for rea-
soning about incomplete information, they overlooked the
fact that, when considered within FO, such a logic does not
add any expressive power.

To sum up, our investigation validates the choice of Klee-
ne’s logic by the designers of SQL, but at the same time asks
whether it was really necessary and opens up a possibility
for future languages that handle incomplete information to
avoid the recourse to many-valued logics. Notice that much
of the criticism of SQL concentrated on its propositional
logic. However we showed that it was very reasonable: a six-
valued logic would have been better justiﬁed but the three-
valued logic is better at handling computational aspects. For
predicate logics, our results say that these many-valued log-
ics could have been avoided altogether. However, the price
for this is a different way of expressing logical queries, and
thus this result is of more interest for future language design
rather than changing the current choices.

Organization The paper is structured around three main
themes: propositional logics, predicate logics, and the logic
of SQL, followed by conclusions and future work.

Propositional Logics
Our study of logics for incomplete information starts at the
propositional level. The goal of this section is to deﬁne a
propositional logic for handling incompleteness, with a spe-
cial regard to applications that deal with incomplete data,
including relational databases query languages.

To this end, we ﬁrst need to formally deﬁne propositional
formulae. We assume a countably inﬁnite set of symbols, re-
ferred to as propositional atoms. For a set Ω of connectives
with associated (positive) arities, the propositional language
L over Ω is deﬁned inductively as follows: every proposi-
tional atom is a formula of L; if ω is an n-ary connective in Ω
and α1, . . . , αn are formulae of L, then so is ω(α1, . . . , αn);
nothing else is in L. We assume that the binary connectives
∧ and ∨, for which we use the inﬁx notation, and the unary
connective ¬ are always present. As will be relevant in the
next section, this general deﬁnition allows for the inclusion
of additional connectives in the language.

The standard way of evaluating propositional formulae is
to associate atoms with truth values, which are then propa-
gated through the connectives by means of truth tables. We
deﬁne a (propositional) logic L as a pair (T, Ω), where T is
the set of truth values and Ω is the set of truth tables, which
are functions ω : Tn → T, of appropriate arities, associated
with the connectives. We say that L is a logic for a language
L if L deﬁnes truth tables for every connective of L. With a
deliberate abuse of notation, we denoted by Ω both the con-
nectives of L and the truth tables associated with them in L.
When it is not clear from the context, we use ωL to explicitly
denote the truth table of L for the connective ω.

Given a logic L = (T, Ω) for a language L, and a map-
ping µ from propositional atoms to the truth values in T, the
evaluation of a formula α ∈ L under µ in L is the truth value
tvL(α, µ) in T deﬁned inductively as follows:

tvL

tvL(α, µ) = µ(α) if α is a propositional atom,
(cid:0)ω(α1, . . . , αn), µ(cid:1) = ωL(cid:0)tvL(α1, µ), . . . , tvL(αn, µ)(cid:1),
for every α, α1, . . . , αn ∈ L and every n-ary connective ω.
For Ω = {∧, ∨, ¬}, the standard Boolean logic LBool has
truth values {t, f} and truth tables as in Figure 1, while SQL
uses Kleene’s three-valued logic, denoted by L3v, with truth
values {t, f, u} and truth tables as in Figure 2. But is L3v
the right propositional logic to deal with incomplete infor-
mation in relational databases? To answer this question, we
ﬁrst need an appropriate model of incompleteness; then, we
must deﬁne what kind of information truth values represent
in this model, and how many of them are needed; ﬁnally,
we need to deﬁne truth tables for ∧, ∨ and ¬ that propagate
information in a consistent way.

Model of Incompleteness
In many data management applications, especially those in-
volving knowledge representation and reasoning, the verac-
ity of data is a common problem. This results in dealing with

∧ t
t
t
f
f

f
f
f

∨ t
t
t
f
t

f
t
f

¬
f
t

t
f

Figure 1: The truth tables of LBool.

∧ t
t
t
f
f
u
u

f
f
f
f

u
u
f
u

∨ t
t
t
f
t
t
u

f
t
f
u

u
t
u
u

¬
f
t
u

t
f
u

Figure 2: The truth tables of L3v.

two main sources of incomplete information: ﬁrst, queries
must be answered over sets of possible worlds and, second,
the answer to a query may not be well deﬁned, or known,
in some of them. In the literature on many-valued logics, the
approach of (Ginsberg 1988) accounts for both these sources
of incomplete information, and we follow it here as a basis
for our model. However, as we shall discuss later on in this
section, we deviate from Ginsberg’s approach with respect
to what truth values are and represent.

A propositional interpretation I is a triple (t, f, W ),
where W is a non-empty set of worlds, and t and f are
functions from L to the powerset of W such that, for every
α, β ∈ L, all of the following hold:

t(α) ∩ f (α) = ∅ ;
f (¬α) = t(α) ;
t(¬α) = f (α) ;

t(α ∧ β) = t(α) ∩ t(β) ;
t(α ∨ β) = t(α) ∪ t(β) ;
f (α ∧ β) = f (α) ∪ f (β) ;
f (α ∨ β) = f (α) ∩ f (β) .

Intuitively, t tells us on which worlds a given formula is true,
while f indicates where it is false. When a world w is neither
in f (α) nor in t(α), the formula α is said to be undeﬁned in
w.

In (Ginsberg 1988), objects similar to propositional inter-
pretations deﬁned above are used as truth values for formu-
lae. This is incompatible with the standard evaluation of for-
mulae we deﬁned earlier. Instead, we want to collate the in-
formation provided by propositional interpretations and ab-
stract it as truth values. In a sense, a truth value should repre-
sent what we know about formulae with respect to interpre-
tations. To formalize this intuition, it is natural to make use
of some form of epistemic logic.

Given a propositional language L, the language LKP of

epistemic formulae is deﬁned inductively as follows:
• every propositional formula in L is in LKP;
• if ϕ and ψ are in LKP, then so are ϕ ∧ ψ, ϕ ∨ ψ, and ¬ϕ;
• if ϕ is in LKP, then so are Kϕ and Pϕ;
• nothing else is in LKP.
An epistemic formula is said to be subjective if every propo-
sitional atom appears in the scope of K or P.

The semantics of epistemic formulae is given with respect
to a propositional interpretation I = (t, f, W ) and an ap-
pointed world w ∈ W . Whether I and w satisfy ϕ ∈ LKP,
written I, w |= ϕ, is inductively deﬁned as follows:

• I, w |= α if w ∈ t(α), for α ∈ L ;
• I, w |= Kϕ if I, w(cid:48) |= ϕ for every w(cid:48) ∈ W ;
• I, w |= Pϕ if I, w(cid:48) |= ϕ for some w(cid:48) ∈ W ;

• I, w |= ¬ϕ if I, w (cid:54)|= ϕ ;

• I, w |= ϕ ∧ ψ if I, w |= ϕ and I, w |= ψ ;

• I, w |= ϕ ∨ ψ if I, w |= ϕ or I, w |= ψ.

Observe that whether a subjective formula ϕ is satisﬁed in a
propositional interpretation I does not depend on the choice
of the appointed world, hence we simply say that I satisﬁes
ϕ, and write I |= ϕ. Moreover, we denote by Mod(ϕ) the
set of all models of ϕ, i.e., propositional interpretations that
satisfy ϕ. We say that ϕ is satisﬁable whenever Mod(ϕ) is
non-empty.

We also remark that, unlike the standard operators (cid:3) and
♦ in classical modal logic, K and P here are not dual: while
Kϕ implies ¬P¬ϕ, the converse is not necessarily true. To
see this, consider a propositional formula α and the inter-
pretation I = (t, f, {w1, w2}) such that t(α) = {w1} and
f (α) = ∅; then, it is easy to verify that I satisﬁes ¬P¬α
but not Kα, because w2 (cid:54)∈ t(α).

Truth Values

We need to understand what it means for a propositional for-
mula to be true or false in a propositional interpretation. To
do that, we resort to the notion of modalities.

Given a propositional formula α, the modalities of α are
the modal formulae Kα, Pα, and their negation. Intuitively,
the modalities of α describe the way α is true on a given
propositional interpretation. To deﬁne truth values, then, we
will look at the modalities of propositional formulae and
their negations.

More formally, for a propositional formula α, we denote
by M(α) the set consisting of all modalities of α and ¬α. A
subset M of M(α) is called consistent if there exists at least
one propositional interpretation I for which every formula
in M is satisﬁed. A subset of M(α) is maximally consistent
if, in addition, none of its proper supersets is a consistent
subset of M(α).

Intuitively, every maximally consistent subset of M(α)
deﬁnes a possible way in which a propositional formula can
be evaluated on a propositional interpretation. Thus, to cap-
ture all possibilities, we need as many truth values as there
are maximally consistent subsets of M(α). The following
shows that our propositional logic must be six-valued.

Theorem 1. For every propositional formula α, there are at
most 6 maximally consistent subsets of M(α). These are:
(cid:8) Kα, Pα,¬K¬α,¬P¬α (cid:9)
(cid:8)¬Kα,¬Pα, K¬α, P¬α (cid:9)
(cid:8)¬Kα, Pα,¬K¬α, P¬α (cid:9)
(cid:8)¬Kα, Pα,¬K¬α,¬P¬α (cid:9)
(cid:8)¬Kα,¬Pα,¬K¬α, P¬α (cid:9)
(cid:8)¬Kα,¬Pα,¬K¬α,¬P¬α (cid:9)

(1)

(2)

(3)

(4)

(5)

(6)

Proof. Let I = (t, f, W ) be a propositional interpretation.
If I satisﬁes Kα, then by the assumption that W (cid:54)= ∅ it also
satisﬁes Pα, ¬K¬α and ¬P¬α. Thus, we get (1).

Otherwise, when I (cid:54)|= Kα, I may or may not satisfy Pα.
If it does, then I (cid:54)|= K¬α. Under this assumption, we have
two possibilities: either I satisﬁes P¬α, in which case we
get the set (3), or not, and we get (4).

Suppose now I (cid:54)|= Kα and I (cid:54)|= Pα. If I satisﬁes K¬α,
then by the assumption that W (cid:54)= ∅ it also satisﬁes P¬α.
Thus, we get the set (2).

Finally, if I (cid:54)|= K¬α, then I may or may not satisfy P¬α.

Thus, we get the sets (5) and (6), respectively.

We now analyze the information each of the above sets
gives us for an arbitrary propositional formula α, and ab-
stract it as a truth value, referring to the six maximally con-
sistent sets in Theorem 1.
(1) We know that α is true in all worlds (Kα). We abstract

this as the truth value t (always true).

(2) We know that ¬α is true in all worlds (K¬α), hence α
is false in all worlds. We abstract this as the truth value
f (always false).

(3) We know that there exists a world w in which α is true
(Pα) and there exists a world w(cid:48) in which its negation
is true (P¬α). Since α cannot be both true and false in
the same world, we have w (cid:54)= w(cid:48). We abstract this as
the truth value s (sometimes true and sometimes false).
(4) We know that there is a world in which α is true (Pα)
but we do not know whether there is a (distinct) world
in which its negation is true (¬P¬α). Thus, α could be
true in all worlds, but we do not know that (¬Kα). We
abstract this as the truth value st (sometimes true).
(5) We know that there is a world in which the negation of
α is true (P¬α) and where α is then false, but we do not
know whether there is a (distinct) world in which α is
true (¬Pα). Thus, α could be false in all worlds, but we
do not know that (¬K¬α). We abstract this as the truth
value sf (sometimes false).

(6) We do not know whether there exists a world in which
α is true (¬Pα) nor whether there is one where its nega-
tion is true (¬P¬α). That is, we have no information at
all, and we abstract this as the truth value u (unknown).

Thus, our set of truth values is T6v = {t, f, s, st, sf, u}.

With each truth value τ and each propositional formula α,
we associate the (subjective) epistemic formula χτ
α given by
the conjunction of all formulae in the maximally consistent
subset of M(α) corresponding to τ . So, for example, χs
α is
the conjunction of all formulae in (3), that is, ¬Kα ∧ Pα ∧
¬K¬α ∧ P¬α. Intuitively, the satisﬁability of χτ
α tells us
whether it is possible for α to evaluate to the truth value τ .

Truth Tables
With the set of truth values in place, we now look at how the
truth tables for the connectives are deﬁned. Starting from the
fact that truth values correspond to maximally consistent sets
of modalities, we will argue that the truth tables must satisfy
two reasonable requirements: consistency and generality.

Consistency Let us ﬁrst consider the unary connective ¬;
given a truth value τ , which truth value should ¬τ denote? If
τ is t, intuition tells us that ¬τ should not be t. Indeed, such
a situation cannot occur, in the sense that for every proposi-
tional formula α there exists no interpretation I that satisﬁes
both χt

α and χt

¬α.

For binary connectives, the situation is similar; for exam-
ple, t∧t should not be f, as it cannot happen that for proposi-
tional formulae α and β there exists an interpretation I that
satisﬁes χt

α, χt

β and χf

α∧β.

Finally, we can use generality to deﬁne a preference crite-
rion for choosing a truth value over another when more than
one are consistent with a connective.
Deﬁnition 2. Let τ and τ (cid:48) be truth values that are consistent
with ω on τ1 and τ2. Then, τ (cid:48) is preferable to τ with respect
to ω(τ1, τ2) if

α ∧ χτ2
χτ1

β ∧ χτ
for all propositional formulae α and β.

ω(α,β) (cid:22) χτ1

α ∧ χτ2

β ∧ χτ (cid:48)

ω(α,β)

Thus, we require that each entry in a truth table be consis-

tent in the following sense.
Deﬁnition 1. Let τ1, τ2, and τ be truth values in T6v, and
let ω be a binary connective. We say that τ is consistent with
ω on τ1 and τ2 if there exist propositional formulae α and
β such that χτ1
ω(α,β) is satisﬁable. Similarly, τ
is consistent with ¬ on τ1 if there exists a propositional for-
mula α such that χτ1

α ∧ χτ2

β ∧ χτ

¬α is satisﬁable.

α ∧ χτ

The notion of consistency directly yields the truth table of

¬ shown in Figure 3c, due to the following:
Proposition 1. For every τ ∈ T6v there exists one and only
one truth value in T6v that is consistent with ¬ on τ .

However, this is not the case for binary connectives: there
are combinations of truth values that admit more than one
consistent truth value, so consistency alone does not sufﬁce
to univocally deﬁne the truth tables for ∧ and ∨. For exam-
ple, both f and sf are consistent with sf ∧ sf, and both t and st
are consistent with st ∨ st. In such cases, how do we choose
a suitable truth value? This is what we answer next.

Generality When there is more than one truth value that is
consistent with a binary connective, we should pick the most
general among them. To illustrate this point, let us consider
the case of sf ∧ sf, which admits two consistent truth values:
sf and f. Choosing f would preclude the existence of inter-
pretations where the formula is true in some world. On the
other hand, sf allows for this possibility without precluding
the existence of interpretations where the formula is false in
all worlds. We will make this intuition more precise in what
follows.

For propositional interpretations I = (t, f, W ) and I (cid:48) =
(t(cid:48), f (cid:48), W (cid:48)), we say that I is more general than I (cid:48) (and write
I (cid:48) (cid:22) I), if there exists a surjective mapping h : W → W (cid:48)
such that, for every propositional formula α and every w ∈
W , all of the following hold:
• w ∈ t(α) implies h(w) ∈ t(cid:48)(α), and
• w ∈ f (α) implies h(w) ∈ f (cid:48)(α).
Intuitively, I is more general than I (cid:48) if, for every proposi-
tional formula α, it has more worlds where α is not known
to be true or false – that is, worlds that do not belong to ei-
ther t(α) nor f (α) – but I agrees with I (cid:48) on all the worlds
for which this information is present.

Using this notion, we can deﬁne a partial ordering on sub-
jective epistemic formulae as follows: we say that ϕ is more
general than ψ (and write ψ (cid:22) ϕ) if for every model I of ψ
there exists a model I (cid:48) of ϕ such that I (cid:22) I (cid:48).

Of course, the above still leaves open the possibility that,
among the truth values that are consistent with a binary con-
nective, there might not be one that is preferable to all others.
Below, we show that this is not the case.
Theorem 2. Let ω ∈ {∧, ∨}, let τ1, τ2 ∈ T6v, and let C be
the subset of truth values in T6v that are consistent with ω on
τ1 and τ2. Then, there exists a unique τ ∈ C such that, for
every τ (cid:48) ∈ C, τ is preferable to τ (cid:48) with respect to ω(τ1, τ2).
Thus, to deﬁne the truth table of a binary connective ω, for
each combination of truth values τ1 and τ2 in T6v we assign
to ω(τ1, τ2) the most preferable truth value that is consistent
with ω on τ1 and τ2. This yields the truth tables for ∧ and ∨
shown in Figure 3a and 3b, respectively. Finally, we call L6v
the propositional logic consisting of the truth values in T6v
and the truth tables in Figure 3.

Coming back to the example of sf ∧ sf mentioned earlier,
we now illustrate intuitively why the requirement of gener-
ality is indeed reasonable. Suppose that two non-equivalent
propositional formulae α and β are both assigned the truth
value sf. If the evaluation is correct, then for every proposi-
tional interpretation there exists a world in which α is false
and a world (not necessarily the same) in which β is false.
Both sf and f are consistent with sf ∧ sf, so what truth value
should α ∧ β evaluate to? The truth value f would indicate
that α ∧ β is false in all worlds of every interpretation for
which both α and β result in sf. Clearly, there are interpre-
tations for which this happens, for example (t, f, {w1, w2})
with f (α) = {w1}, f (β) = {w2} and t(α) = t(β) = ∅.
However, there are also interpretations where this is not the
case, for instance (t(cid:48), f (cid:48), {w1, w2) with t(cid:48)(α) = t(cid:48)(β) = ∅
and f (cid:48)(α) = f (cid:48)(β) = {w1}. The truth value sf is general
enough to correctly capture the outcome of sf ∧ sf in all sit-
uations, including those mentioned above, while f may be
incorrect in some cases.

SQL’s Propositional Logic
The propositional logic L6v = (cid:0)T6v, {∧, ∨, ¬}(cid:1) can express
many nuances of the truth value of a propositional formula
in the case of incomplete information. But can this logic be
used in practice?

The query optimization engines of modern relational data-
base management systems are based on decades of research
that relies on a well established set of assumptions on the
logic underlying the evaluation. Among these assumptions,
there are two crucial properties of the binary connectives:
idempotency and distributivity, see (Jarke and Koch 1984;
Graefe 1993). These are used to transform redundant expres-
sions into equivalent non-redundant ones, in order to reduce

∧
t
f
s
st
sf
u

t
t
f
s
st
sf
u

f
f
f
f
f
f
f

st
st
f
sf
u
sf
u

sf
sf
f
sf
sf
sf
sf

u
u
f
sf
u
sf
u

s
s
f
sf
sf
sf
sf

(a)

∨ t
t
t
f
t
t
s
t
st
sf
t
t
u

f
t
f
s
st
sf
u

sf
t
sf
st
st
u
u

u
t
u
st
st
u
u

st
t
st
st
st
st
st

s
t
s
st
st
st
st

(b)

t
f
s
st
sf
u

¬
f
t
s
sf
st
u

(c)

Figure 3: The truth tables of L6v for ∧, ∨ and ¬.

the number of superﬂuous operations to be executed during
query evaluation.

The binary connectives in L6v are weakly idempotent, i.e.,
for every truth value τ ∈ T6v we have τ ∧ τ ∧ τ = τ ∧ τ , and
likewise for ∨. However, they are not idempotent: s ∧ s and
s ∨ s give sf and st, respectively, rather than s. Moreover, ∧
does not distribute over ∨:

st
(cid:122) (cid:125)(cid:124) (cid:123)
(s ∨ s)
(cid:123)(cid:122)
(cid:125)
sf

s ∧
(cid:124)

(cid:54)=

sf
(cid:122) (cid:125)(cid:124) (cid:123)
(s ∧ s) ∨
(cid:123)(cid:122)
(cid:124)
u

sf
(cid:122) (cid:125)(cid:124) (cid:123)
(s ∧ s)
(cid:125)

and ∨ does not distribute over ∧:

sf
(cid:122) (cid:125)(cid:124) (cid:123)
(s ∧ s)
(cid:123)(cid:122)
(cid:125)
st

s ∨
(cid:124)

(cid:54)=

st
(cid:122) (cid:125)(cid:124) (cid:123)
(s ∨ s) ∧
(cid:123)(cid:122)
(cid:124)
u

st
(cid:122) (cid:125)(cid:124) (cid:123)
(s ∨ s)
(cid:125)

Due to the lack of idempotency and distributivity, L6v is
unlikely to be implemented in real systems for query eval-
uation. However, we can look for sublogics of L6v with the
desired properties.

To this end, we say that L = (T, Ω) is a sublogic of L(cid:48) =
(T(cid:48), Ω(cid:48)) if T ⊆ T(cid:48) and for every ω ∈ Ω there exists ω(cid:48) ∈ Ω(cid:48)
such that ω(¯τ ) = ω(cid:48)(¯τ ) for every tuple of truth values in T.
A sublogic L of L(cid:48) is maximal with respect to a property P
if it has P and there is no sublogic L(cid:48)(cid:48) of L(cid:48) with property P
such that L is a sublogic of L(cid:48)(cid:48).

For practical purposes, we want a sublogic of L6v that has
the truth value t and it is maximal with respect to distribu-
tivity and idempotency.
Theorem 3. L3v is the only sublogic of L6v that includes the
truth value t and that is maximal with respect to distributiv-
ity and idempotency of the binary connectives (∧ and ∨).

Therefore, when it comes to balancing expressiveness and
practicality, the much criticized three-valued logic used by
SQL is in fact a good choice for dealing with incomplete
information in relational databases, at least for the proposi-
tional case.

We next examine extensions of propositional logics such

as L6v and L3v to predicate logics.

Predicate Logics
As already explained, the need to consider predicate logics
of incomplete information arises most commonly in query-
ing incomplete databases, where special values – commonly
referred to as nulls – indicate incompleteness of some sort.

When atomic formulae may involve nulls – e.g., comparing
a null with another value, or checking whether a tuple with
nulls belongs to a relation – the standard approach is not to
follow the Boolean semantics of FO, but instead to look for a
many-valued semantics that will properly lift a propositional
logic to all of FO. Such a semantics is by no means unique;
we shall see three common versions later in this section.

We now deﬁne incomplete relational databases (which are
in fact two-sorted relational structures), and consider many-
valued FO logics on them, based on particular propositional
logic. While propagating truth values through connectives
and quantiﬁers is completely standard, assigning them to
atoms is not unique. We consider three commonly occurring
ways:
• one uses the Boolean semantics (Bolc and Borowik 1992),
• one adopts the approach of SQL (Date and Darwen 1996),
• and yet another is based on tuple uniﬁcation, to achieve
query answers with certainty guarantees (Libkin 2016).

As our main result, we show that in the context of many-
valued FO, the exact choice of semantics of atoms, or truth
values, or propositional connectives, does not matter: what-
ever combination of these one chooses, the resulting logic
can be encoded in Boolean FO.

Incomplete Relational Structures (Databases)
As is standard in the database ﬁeld and many applications of
incomplete information, elements of relational structures (or
relational databases; these terms are used interchangeably)
come from two disjoint sets. One is the set Const of con-
stants, i.e., known values that are stored in databases. The
other is the set Null of nulls that represent unknown values.
We always assume that Const is countably inﬁnite. For the
set Null, some options exist, of which the most common are
the following.
• Null too is a countably inﬁnite set. This corresponds to the
model of marked nulls used both in relational databases
and their many applications, such data exchange (Arenas
et al. 2014), data integration (Lenzerini 2002) and OBDA
(Bienvenu and Ortiz 2015).

• Null is a singleton set containing one element denoted by
NNN. This is the approach of SQL and implementations of re-
lational DBMSs, where there is just one single null value.
A relational vocabulary σ (which is usually called schema
in the database context) is a set {R1, . . . , Rn, =} consisting

of relation names R1, . . . , Rn, each with an associated arity,
plus a binary relation symbol “=” for equality. A structure A
n , =A(cid:105), where:
of this vocabulary is a tuple (cid:104)A, RA
• A is a ﬁnite subset of Const ∪ Null,
• RA
• =A is the binary relation deﬁned as {(a, a) | a ∈ A}.

i ⊆ Ak for every i ∈ {1, . . . , n}, and

1 , . . . , RA

Many-valued Predicate Logics
A many-valued predicate logic is based on a many-valued
propositional logic L with a set T of truth values and Ω of
propositional connectives. Such a logic is a pair (cid:104)FO(L),
(cid:105)
(cid:74) (cid:75)
of FO formulae based on the propositional logic (to be de-
ﬁned shortly) and the semantics
of its formulae. We as-
sume throughout that L has connectives ∨, ∧ which are com-
mutative and associative. This is necessary to deﬁne quanti-
ﬁers. Other connectives are arbitrary. We assume that truth
values t and f are always included in T.

(cid:74) (cid:75)

Syntax and semantics of FO(L) Given a propositional
logic L with truth values T and connectives Ω, formulae of
FO(L) are deﬁned by the following rules.
• Atomic formulae:

– if R is a k-ary vocabulary symbol, and x1, . . . , xk are
variables, then R(x1, . . . , xk) is an atomic formula; we
shall also write the more common x1 = x2 in place of
=(x1, x2);

– const(x) and null(x) are atomic formulae.

• If ω ∈ Ω is a k-ary connective, and ϕ1, . . . , ϕk are for-

mulae, then ω(ϕ1, . . . , ϕk) is a formula.

• If ϕ is a formula and x is a variable, then ∃x ϕ and ∀x ϕ

are formulae.

The notion of free variables is deﬁned in the usual way.

The semantics of a formula ϕ is given with respect to a
structure A with universe A and an assignment ν of values
in A to free variables of ϕ (i.e., ν is a partial function that
is deﬁned on all free variables of ϕ and takes values in A).
This semantics will be denoted by
A,ν, and it is a value
assigns a truth value in T to ϕ in a
in T. In other words,
structure A under assignment ν.

ϕ
(cid:75)

(cid:74) (cid:75)

(cid:74)

const(x)

The semantics of atoms const and null is as follows:
(cid:26)t
f
(cid:26)t
f

if ν(x) ∈ Const,
if ν(x) ∈ Null.

if ν(x) ∈ Null,
if ν(x) ∈ Const.

A,ν =

A,ν =

null(x)
(cid:75)

(cid:74)

(cid:75)

(cid:74)

For propositional connectives and quantiﬁers, the seman-

tics is deﬁned with the standard lifting rules:

ω(ϕ1, . . . , ϕk)
(cid:75)
(cid:74)
∃x ϕ
(cid:75)

(cid:74)

∀x ϕ
(cid:75)

(cid:74)

ϕ

A,ν =

A,ν = ω(
ϕ1
(cid:74)
(cid:95)
a∈A(cid:74)
(cid:94)
a∈A(cid:74)

A,ν =

ϕ

A,ν, . . . ,

(cid:75)
A,ν[a/x] ,
(cid:75)

A,ν[a/x] ,
(cid:75)

ϕk

A,ν) ,
(cid:75)

(cid:74)

where ν[a/x] is the same as ν except that it assigns a to x.
The last two rules rely on the fact that ∨ and ∧ are commu-
tative and associative.

For atomic formulae R(¯x), with R ∈ σ, there are several
options, which we now consider, when the underlying logic
is either Lbool or L3v.

(cid:74)

R(¯x)

bool
A,ν =
(cid:75)

if ν(¯x) ∈ RA,
if ν(¯x) (cid:54)∈ RA,

Boolean semantics This is the standard two-valued FO se-
mantics, with only t and f as truth values, and it is given by
(cid:26)t
f
for every R in the vocabulary σ (which, recall, includes =).
It is then extended to all of FO with the above rules, resulting
bool deﬁned for all FO formulae. When
in the semantics
bool
A,ν = t we also write the more customary A, ν |= ϕ.
ϕ
(cid:75)
The logic BFO, or Boolean FO, is now formally deﬁned
bool; it is the standard FO

(cid:74)
as FO(Lbool) interpreted under
with only t and f as truth values.

(cid:74) (cid:75)

(cid:74) (cid:75)

Null-free semantics A tuple ¯a is null-free if all of its val-
ues are from Const. The null-free semantics of FO(L3v) is
the same as the Boolean semantics for tuples of constants; if
any nulls are present, it produces the truth value u:

R(¯x)
(cid:74)

nf
A,ν =
(cid:75)






if ν(¯x) ∈ RA and ν(¯x) is null-free,
if ν(¯x) (cid:54)∈ RA and ν(¯x) is null-free,

t
f
u if ν(¯x) contains a null,

for every R in the vocabulary σ (which, recall, includes =).
In particular, for the equality predicate =, this is exactly the
semantics used by SQL (Date and Darwen 1996).

Uniﬁcation semantics A semantics based on the notion of
tuple uniﬁcation was proposed by Libkin (2016) to enforce
certainty guarantees for query answers. We say that two tu-
ples ¯a and ¯b unify if there is a map h : Const ∪ Null → Const
that is the identity on constants and such that h(¯a) = h(¯b).
Then, for every relation symbol R in the vocabulary σ, the
uniﬁcation semantics is deﬁned by

R(¯x)
(cid:75)

(cid:74)

⇑
A,ν =






if ν(¯x) ∈ RA,
if (cid:64)¯a ∈ RA s.t. ν(¯x) and ¯a unify,

t
f
u otherwise.

The semantics
lifting rules.

⇑ is then lifted to all of FO by the standard

(cid:74) (cid:75)

The reason this semantics was introduced is that it ensures
⇑
A,ν = t, then
certainty of answers to FO queries: if
the tuple ¯u = ν(¯x) is what is known as a certain answer to
ϕ, i.e., h(A) |= ϕ(cid:0)h(¯u)(cid:1) for every map h : Const ∪ Null →
Const that is the identity on constants.

ϕ(¯x)
(cid:75)

(cid:74)

Mixed semantics There is a priori no reason to apply the
same semantics on each relation symbol R ∈ σ; instead we
s is then given
can freely mix them. A mixed semantics
(cid:74) (cid:75)
s
A,ν =
by a function s : σ → {bool, ⇑, nf} so that
s(R)
A,ν . This generalizes Boolean, uniﬁcation, and null-

R(¯x)
(cid:75)

(cid:74)

R(¯x)
(cid:74)
(cid:75)
free semantics.

Boolean FO Captures Many-valued FO
We now show that in most cases, many-valued predicate log-
ics do not give any extra power compared to BFO, i.e., the
usual FO under the standard Boolean interpretation of con-
nectives and the Boolean semantics of atomic formulae. The
notion of capturing a many-valued FO logic by BFO is de-
ﬁned as follows.
Deﬁnition 3. A formula ϕ of FO(L) over a many-valued
propositional logic L with truth values T is captured by BFO
under semantics
if there exist BFO formulae ϕτ for each
τ ∈ T such that for every structure A and assignment ν of
free variables of ϕ we have

(cid:74) (cid:75)

A,ν = τ ⇔ A, ν |= ϕτ .

ϕ
(cid:75)

(cid:74)

FO(L) is captured by BFO if each of its formulae is.

Usually we are interested in formulae that are true in a
A,ν = t. If a formula is captured by
given structure, i.e.,
(cid:75)
BFO, this tells us that we do not need many-valued seman-
tics, and instead can simply check whether A, ν |= ϕt under
the usual Boolean semantics.

ϕ
(cid:74)

To capture a many-valued FO by BFO we need very few
assumptions. Recall that L = (cid:104)T, Ω(cid:105) is given by a set of
truth values and truth tables for connectives in Ω, which we
assume to contain at least ∨, ∧ to deﬁne quantiﬁers. In logics
such as Lbool and L3v, these connectives are idempotent, i.e.,
τ ∧ τ = τ ∨ τ = τ for every τ ∈ T. In L6v, they are
weakly idempotent: τ ∧ τ ∧ τ = τ ∧ τ and likewise for
∨. Notice that idempotency implies weak idempotency. This
is the only condition we need to impose to be able to lift
capturing formulae by Boolean FO from atoms to arbitrary
formulae.
Theorem 4. Let L be a propositional many-valued logic in
which connectives ∧ and ∨ are weakly idempotent. Assume
that every relational atom R(¯x), for R ∈ σ, is captured by
. Then every FO(L) formula over vocabulary
BFO under
(cid:74) (cid:75)
σ is captured by BFO under

.
(cid:74) (cid:75)
To apply this result to the previously considered seman-
tics, we need to capture atomic formulae, under different se-
mantics, in BFO. This is possible for all of them.
Proposition 2. Relational atoms are captured by BFO un-
der Boolean, uniﬁcation, and null-free semantics.

Finally, this tells us that any mixed semantics (including
its pure versions, i.e., Boolean, uniﬁcation, null-free) cou-
pled with any propositional many-valued logic like L3v or
L6v (as long as it has weakly idempotent conjunction and
disjunction) is no more powerful than the standard seman-
tics over two truth values t and f.
Corollary 1. Let L be a propositional many-valued logic
whose truth values include {t, f, u}, with an arbitrary set of
connectives where ∨ and ∧ are (weakly) idempotent. Then
for every vocabulary σ, every function s deﬁning a mixed
semantics, and every formula ϕ of FO(L) there is a formula
ϕ(cid:48) of BFO such that

A,ν = t iff A, ν |= ϕ(cid:48).
s

Using this result, we can clarify, in the next section, the
question of the power of the logic that underlies real-life
database applications that use incomplete information.

ϕ
(cid:75)

(cid:74)

The Logic of SQL
Most database texts will claim that the core of SQL, the main
relational database query language, is ﬁrst-order logic FO.
This was certainly true in the early stages of SQL design,
as it grew out of relational calculus, which is just another
name for FO. But then the language gained many features, in
particular null values, leading to more complex underlying
logics.

These logics are still not well understood, as the for-
malization of SQL mainly took a different route via rela-
tional algebra, which is the procedural counterpart of FO.
Several attempts to provide a theoretical language behind
SQL looked at relational algebra translations of the language
(Ceri and Gottlob 1985; Van den Bussche and Vansummeren
2009) or presented semantics of various fragments of the
language, often under the simplifying assumption that no
nulls are present and no three-valued logic is used (Chu et
al. 2017; Negri, Pelagatti, and Sbattella 1991). An attempt to
ﬁnd a logic underlying SQL concentrated on its features that
go beyond FO (i.e., aggregation) rather than nulls (Hella et
al. 2001). More recent work (Guagliardo and Libkin 2017),
while providing a direct semantics of SQL, accounted for
null values and three-valued logic, and even gave a transla-
tion of SQL queries that, similarly in spirit to the results in
the previous section, showed how to evaluate them without
ever producing the unknown truth value u. This was done,
however, at the level of SQL queries. We now analyze the
power of SQL and the need for three truth values at a purely
logical level.

We start with the basic fragment of relational languages
that has the power of FO, or – equivalently – the basic op-
erations of relational algebra, or SQL’s select-from-where
queries without aggregation. These operate on databases
whose values come from Const. Recall that SQL uses a sin-
gle null denoted here by NNN. Now we add it; how should the
logic change to capture this extension? It depends on who is
asked to produce such an extension.

A logician’s approach If the domain is extended by a sin-
gle constant, we simply consider FO over Const ∪ {NNN} with
a unary predicate null( ) that is only true in NNN (to keep the
vocabulary relational; alternatively a constant symbol could
be added). The interpretation of = is simply {(c, c) | c ∈
Const} ∪ {(NNN, NNN)}, i.e., syntactic equality: NNN is equal to it-
self, and not equal to any element of Const. In other words,
the logic is the usual BFO, with all the atoms interpreted
under the Boolean semantics

bool.

(cid:74) (cid:75)
It would thus be seen, by a logician, as an overkill to intro-
duce a many-valued logic to deal with just one extra element
of the domain. Nonetheless, this is what SQL did.

SQL approach: a textbook version The usual explana-
tion of the logic behind SQL is that it adds a new truth
value u to account for any comparisons involving nulls. In
other words, the logic is FO(L3v), and the semantics
sql is
mixed, combining Boolean and null-free semantics:

(cid:74) (cid:75)

• for relational atoms,

R(¯x)
(cid:75)

(cid:74)

sql
A,ν =

R(¯x)
(cid:75)

(cid:74)

bool
A,ν;

• for equality,

x = y
(cid:74)

sql
A,ν =
(cid:75)

(cid:74)

x = y

nf
A,ν.

(cid:75)

SQL approach: what really happens While the textbook
approach comes close to describing the logic of SQL, it
misses one important feature of such logic. In essence, we
can think of SQL queries as expressions

select
from
where

¯x
Q1, . . . , Qn
θ(¯x1, . . . , ¯xn)

where Q1, . . . , Qn are either queries or relations, ¯xi is a tu-
ple of variables returned by Qi, and θ is a condition com-
posed of equalities of variables and constants, or statements
(cid:54)= ∅,
Q(cid:48)(¯y), where Q(cid:48) is another query, or statements Q(cid:48)
combined using ∧, ∨, and ¬.

Note that in SQL query evaluation, it is the conditions θ
that are evaluated in L3v; once the evaluation of the where θ
clause is ﬁnished, only tuples that evaluated to t are kept. To
capture this in logic, we need a propositional operator that
collapses f and u into f. Such an operator does exist in propo-
sitional many-valued logics (Bochvar 1981) and is known as
an assertion operator: ↑p for a proposition p evaluates to t if
p evaluates to t, and to f otherwise. Let L↑
3v be the extension
of L3v with this operator.

The basic SQL query can then be expressed in FO(L↑

3v):

Q(¯x) = ∃¯y

n
(cid:94)

i=1

Qi(¯xi) ∧ ↑θ(¯x1, . . . , ¯xn) ,

where ¯y lists the variables present in ¯x1, . . . , ¯xn but not in
¯x. Thus, the many-valued predicate logic capturing SQL’s
behavior is FO(L↑

sql.

3v) under

(cid:74) (cid:75)

To sum up, there are three choices of a logic capturing

SQL’s behavior:
1) Boolean predicate logic BFO;
2) FO based on Kleene’s logic under the
3) FO based on Kleene’s logic with the assertion operator

sql semantics;

(cid:74) (cid:75)

(cid:74) (cid:75)

sql semantics.

under the
These logics use different sets of truth values. However,
it only matters when formulae evaluate to true, as this de-
termines the output of queries. Thus, to compare logics with
different sets of truth values, we say that two logics, FO(L1)
2, are true-equivalent if the
under
models of t are the same in both. That is, for every formula
ϕ1 of FO(L1) there is a formula ϕ2 of FO(L2) such that

1, and FO(L2) under

(cid:74) (cid:75)

(cid:74) (cid:75)

ϕ1

1
A,ν = t ⇔

ϕ2

2
A,ν = t

(cid:74)

(cid:75)

(cid:74)

(cid:75)

for every A, ν, and vice versa, for each ϕ2 of FO(L2) there
is a formula ϕ1 of FO(L1) such that the above condition
holds.

Then, with respect to the truth value t, there is no differ-
ence between the logics that attempt to model SQL’s behav-
ior.
Theorem 5. The logics FO(L3v) and FO(L↑

3v), both under

sql, and BFO, are all true-equivalent.

(cid:74) (cid:75)

Thus, the most natural logical approach to adding a null
value to the language does not miss any expressiveness of
the more complex solutions based on many-valued logics.

Conclusions
To conclude, let us revisit history. Handling incomplete in-
formation by logical languages is an important topic, espe-
cially in data management. All commercial database sys-
tems that speak SQL offer a solution based on a three-valued
propositional logic that is lifted then to full predicate logic.
This solution was heavily criticized in the literature, but at
the level of the chosen propositional logic.

We proposed a principled approach to justifying a proper
logic for handling incomplete information, which resulted
in a six-valued logic L6v. However, taking into account the
needs of SQL query evaluation (e.g., distributivity laws), the
largest fragment of L6v that does not break traditional evalu-
ation and optimization strategies is Kleene’s logic L3v, pre-
cisely the one chosen by SQL.

However, even though the SQL designers were justiﬁed in
their choice of Kleene’s logic, they neglected to consider the
impact that lifting it to full predicate logic would have. We
showed that it leads to no increase in expressive power; had
this been known to the SQL designers, perhaps other choices
would have been considered too.

But does this mean that we should abandon many-valued
logics of incomplete information? Most likely not: while the
theoretical complexity of formulae that result from eliminat-
ing many-valuedness is the same as that of original many-
valued formulae, their practical complexity (i.e., if imple-
mented as real life database queries) is likely to be different.
This is mainly due to the fact that 40 years of research on
query evaluation and optimization had one particular model
in mind, and that model used a many-valued logic. However,
the observations we made here might have an impact on the
design of new languages, since avoiding many-valued logics
for handling incompleteness is now an option.

Regarding future directions, we would like to extend the
propositional setup with bilattice orderings as is often done
(Arieli and Avron 1996; Ginsberg 1988), and understand the
right orderings for logics like L6v. Yet another direction is to
drop the restriction t(α) ∩ f (α) = ∅ for every propositional
formula α. Such restrictions have been lifted in the study of
paraconsistent logics (Arieli, Avron, and Zamansky 2010;
Zamansky and Avron 2006), and in fact the question of look-
ing for the right many-valued logic for reasoning about in-
consistency has been raised (Arieli, Avron, and Zamansky
2011). Our focus would be slightly different, as we want to
extend the current study to handle the most common case
of inconsistency in data management, namely inconsistency
with respect to integrity constraints (Arenas, Bertossi, and
Chomicki 1999; Bertossi 2011).

Acknowledgments
The authors would like to thank the anonymous referees for
their helpful comments. This work was partly supported by
EPSRC grants M025268 and N023056.

1990. Four valued logic for relational

Gessert, G. H.
database systems. SIGMOD Record 19(1):29–35.
Ginsberg, M. L. 1988. Multivalued logics: a uniform ap-
proach to reasoning in artiﬁcial intelligence. Computational
Intelligence 4:265–316.
Graefe, G. 1993. Query evaluation techniques for large
databases. ACM Comput. Surv. 25(2):73–170.
Grahne, G.; Moallemi, A.; and Onet, A. 2015. Intuitionis-
tic data exchange. In 9th Alberto Mendelzon International
Workshop on Foundations of Data Management.
Guagliardo, P., and Libkin, L. 2017. A formal semantics
of SQL queries, its validation, and applications. PVLDB
11(1):27–39.
Hella, L.; Libkin, L.; Nurmonen, J.; and Wong, L. 2001.
Journal of the ACM
Logics with aggregate operators.
48(4):880–907.
ISO/IEC. 2016. ISO/IEC 9075:2016: Information technol-
ogy – Database languages – SQL. International Organiza-
tion for Standardization.
Jarke, M., and Koch, J.
database systems. ACM Comput. Surv. 16(2):111–152.
Lenzerini, M. 2002. Data integration: a theoretical perspec-
tive. In ACM Symposium on Principles of Database Systems
(PODS), 233–246.
Libkin, L. 2016. SQL’s three-valued logic and certain an-
swers. ACM Trans. Database Syst. 41(1):1:1–1:28.
Negri, M.; Pelagatti, G.; and Sbattella, L. 1991. Formal
semantics of SQL queries. ACM Trans. Database Syst.
16(3):513–534.
Reiter, R. 1980. A logic for default reasoning. Artif. Intell.
13(1-2):81–132.
Van den Bussche, J., and Vansummeren, S. 2009. Translat-
ing SQL into the relational algebra. Course notes, Hasselt
University and Universit´e Libre de Bruxelles.
Yue, K. 1991. A more general model for handling missing
information in relational databases using a 3-valued logic.
SIGMOD Record 20(3):43–49.
Zamansky, A., and Avron, A. 2006. Non-deterministic se-
In KR, 431–
mantics for ﬁrst-order paraconsistent logics.
439.

1984. Query optimization in

References
Arenas, M.; Bertossi, L.; and Chomicki, J. 1999. Consistent
In ACM Sympo-
query answers in inconsistent databases.
sium on Principles of Database Systems (PODS), 68–79.
Arenas, M.; Barcel´o, P.; Libkin, L.; and Murlak, F. 2014.
Foundations of Data Exchange. Cambridge University
Press.
Arieli, O., and Avron, A. 1996. Reasoning with logical bilat-
tices. Journal of Logic, Language and Information 5(1):25–
63.
Arieli, O., and Avron, A. 1998. The logical role of the four-
valued bilattice. In LICS, 118–126.
Arieli, O.; Avron, A.; and Zamansky, A. 2010. Maximally
paraconsistent three-valued logics. In KR.
Arieli, O.; Avron, A.; and Zamansky, A. 2011. What is
an ideal logic for reasoning with inconsistency? In IJCAI,
706–711.
Belnap, N. D. 1977. A useful four-valued logic. In Dunn,
J. M., and Epstein, G., eds., Modern Uses of Multiple-Valued
Logic. D. Reidel. 8–37.
Bertossi, L. 2011. Database Repairing and Consistent
Query Answering. Morgan&Claypool Publishers.
Bienvenu, M., and Ortiz, M. 2015. Ontology-mediated
query answering with data-tractable description logics.
In
Reasoning Web, 218–307.
Bochvar, D. A. 1981. On a three-valued logical calculus and
its application to the analysis of the paradoxes of the classi-
cal extended functional calculus. History and Philosophy of
Logic 2:87–112. Translated from Matematicheskij Sbornik,
4 (46): 287-308, 1938.
Bolc, L., and Borowik, P. 1992. Many-Valued Logics: The-
oretical Foundations. Springer.
Ceri, S., and Gottlob, G. 1985. Translating SQL into rela-
tional algebra: Optimization, semantics, and equivalence of
SQL queries. IEEE Trans. Software Eng. 11(4):324–345.
Chu, S.; Weitz, K.; Cheung, A.; and Suciu, D.
2017.
HoTTSQL: Proving query rewrites with univalent SQL se-
mantics. In PLDI, 510–524. ACM.
Codd, E. F. 1975. Understanding relations (installment #7).
FDT - Bulletin of ACM SIGMOD 7(3):23–28.
Codd, E. F. 1987. More commentary on missing information
in relational databases. SIGMOD Record 16(1):42–50.
Console, M.; Guagliardo, P.; and Libkin, L. 2016. Approxi-
mations and reﬁnements of certain answers via many-valued
logics. In KR, 349–358.
Darwen, H., and Date, C. J. 1995. The third manifesto.
SIGMOD Record 24(1):39–49.
Date, C. J., and Darwen, H. 1996. A Guide to the SQL
Standard. Addison-Wesley.
Date, C. J. 2005. Database in Depth - Relational Theory for
Practitioners. O’Reilly.
Fitting, M. 1991. Kleene’s logic, generalized. J. Log. Com-
put. 1(6):797–810.

