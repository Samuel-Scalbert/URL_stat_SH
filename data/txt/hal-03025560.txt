Declarative mining of negative sequential patterns
Philippe Besnard, Thomas Guyet

To cite this version:

Philippe Besnard, Thomas Guyet. Declarative mining of negative sequential patterns. 1st Declarative
Problem Solving Workshop (DPSW 2020) @ ECAI 2020, Pedro Cabalar (CITIC-Univ. A Coruña,
Spain); Andreas Herzig (Tolouse Univ, France); David Pearce (Univ. Politécnica Madrid, Spain);
Torsten Schaub (Univ. Potsdam, Germany); Stefan Woltran (Vienna Univ. Tech. Austria), Aug
2020, Santiago de Compostela, Spain. pp.1-8. ￿hal-03025560￿

HAL Id: hal-03025560

https://inria.hal.science/hal-03025560

Submitted on 26 Nov 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Declarative mining of negative sequential patterns

Philippe Besnard 1 and Thomas Guyet 2

Abstract. Declarative pattern mining consists in using declarative
frameworks to solve pattern mining tasks. In this article, we address
the task of mining negative sequential patterns in Answer Set Pro-
gramming (ASP). A negative sequential pattern is speciﬁed by means
of a sequence consisting of events to occur and of other events, called
negative events, to be absent. For instance, containment of the pattern
(cid:104)a ¬b c(cid:105) arises with an occurrence of a and a subsequent occurrence
of c but no occurrence of b in between. Recent results shed light on
the ambiguity of such a seemingly intuitive notation, exhibited three
semantics of the negative events and proposed alternative notations
for them. In this article, we propose Answer Set Programming en-
codings of these three semantics in order to extract frequent negative
sequential patterns from a set of sequences. It relies on previous en-
codings of frequent sequential pattern mining. We experiment with
our encoding on synthetic data and compare the numbers of extracted
patterns and the computing time obtained for each kind of negation.
Surprisingly, the semantics that has the best algorithmic properties
for pattern mining is not associated to an encoding that is the most
efﬁcient.

1

Introduction

Pattern mining [11] is a data mining task that consists in extract-
ing interesting structured patterns from a set of structured examples.
The standard pattern mining tasks are itemset mining, sequence min-
ing and graph mining. The interestingness measure of a pattern is, in
most of the algorithms, the number of its occurrences in the set of ex-
amples. Given a threshold k, interesting patterns are those that occur
at least in k examples. In this case, the task is known as frequent pat-
tern mining for which many algorithms have been proposed. Most of
the efﬁcient algorithmic solutions rely on an antimonotonicity prop-
erty of the support: the larger the pattern, the fewer it occurs.

Declarative pattern mining aims at encoding pattern tasks in a
declarative framework, and more speciﬁcally the frequent pattern
mining tasks. Declarative pattern mining addressed the tasks of
frequent itemset mining [5, 13, 12], frequent sequential patterns
[15, 2, 1] or frequent graph mining [6]. Different declarative frame-
works have been explored: Constraint Programming (CP) [5, 15, 6],
SAT [12, 1] and Answer Set Programming (ASP) [13, 2]. Declarative
pattern mining does not expect to be competitive with dedicated algo-
rithms, but to take advantage of the versatility of declarative frame-
works to propose pattern mining tools that could exploit background
knowledge during the mining process to extract less but meaningful
patterns.

In this work, we explore negative sequential patterns [8, 10, 17].
Standard sequential pattern mining algorithms [14] extract sequen-
tial patterns that frequently occur in a set of sequences. A sequential

1 CNRS / IRIT, France, email: besnard@irit.fr
2 Institut Agro / IRISA UMR6074, France, email: thomas.guyet@irisa.fr

pattern is a sequence of events or items. For example, the sequential
pattern (cid:104)a c d(cid:105) is read as “a occurs and then c occurs and ﬁnally d
occurs”. Negative sequential patterns are sequential patterns that also
specify non-occurring events. Intuitively, the syntax of a simple neg-
ative sequential pattern is as follows: (cid:104)a ¬b c(cid:105). This pattern is read
as “a occurs and then c occurs, but b does not occur in between”. A
negative sequential pattern can also be the premise of a rule. Guyet
and Besnard [8] highlighted that ¬ symbol has several semantics but
only few of them have good properties for pattern mining.

In this article, we propose an ASP encoding of the mining of fre-
quent negative sequential patterns. Our encoding relies on previous
work on frequent sequential pattern mining in ASP [9]. The objective
of this article is also to illustrate the semantics of negative sequential
patterns through declarative encodings.

2 Background

2.1 Sequential pattern mining

Our terminology on sequence mining follows the one in [15].
Throughout this article, [n] = {1, . . . , n} denotes the set of the ﬁrst
n positive integers.

Let Σ be the set of

items (alphabet). An itemset A =
{a1, a2, · · · , am} ⊆ Σ is a ﬁnite set of items. The size of A, de-
noted |A|, is m. A sequence s is of the form s = (cid:104)s1 s2 · · · sn(cid:105)
where each si is an itemset. n is the length of the sequence.

A database D is a multiset of sequences over Σ.A sequence s =
(cid:104)s1 . . . sm(cid:105) with si ∈ Σ is contained in a sequence t = (cid:104)t1 . . . tn(cid:105)
with m ≤ n, written s (cid:118) t, if si ⊆ tei for 1 ≤ i ≤ m and an
increasing sequence (e1 . . . em) of positive integers ei ∈ [n], called
an embedding of s in t. For example, we have (cid:104)a (cd)(cid:105) (cid:118) (cid:104)a b (cde)(cid:105)
relative to embedding (1, 3). (cd) denotes the itemset made of items
c and d.

Given a database D, the cover of a sequence p is the set of se-
quences in D that contain p: cover (p, D) = {t ∈ D | p (cid:118) t}.
The number of sequences in D containing p is called its support,
that is, support(p, D) = |cover (p, D)|. For an integer k, fre-
quent sequence mining is about discovering all sequences p such that
support(p, D) ≥ k. We often call p a (sequential) pattern, and k is
also referred to as the (minimum) frequency threshold.

2.2 Answer set programming

A logic program is a set of rules of the form

a0 :- a1; . . . ; am; not am+1; . . . ; not an.

(1)

where each ai is a propositional atom for 0 ≤ i ≤ n and not
stands for default negation. If n = 0, rule (1) is called a fact. If
a0 is omitted, (1) represents an integrity constraint. Semantically, a

seq(1,1,d). seq(1,2,a). seq(1,2,b). seq(1,3,c).
seq(2,1,a). seq(2,2,c). seq(2,3,b). seq(2,4,c).
seq(3,1,a). seq(3,2,b). seq(3,2,c). seq(3,3,a).
seq(4,1,a). seq(4,1,b). seq(4,2,c).
seq(5,1,a). seq(5,2,c).
seq(6,1,b).
seq(7,1,c).

Listing 1. Facts specifying a database of sequences

logic program induces a collection of so-called answer sets, which
are distinguished models of the program determined by answer sets
semantics; see [4] for details. To facilitate the use of ASP in practice,
several extensions have been developed. First of all, rules with vari-
ables are viewed as shorthands for the set of their ground instances.
Further language constructs include conditional literals and cardi-
nality constraints [16]. The former are of the form a : b1, . . . , bm, the
latter can be written as s {c1, . . . , cn} t, where a and bi are possibly
default negated literals and each cj is a conditional literal; s and t
provide lower and upper bounds on the number of satisﬁed literals
in a cardinality constraint. The practical value of both constructs be-
comes more apparent when used in conjunction with variables. For
instance, a conditional literal like a(X) : b(X) in a rule’s antecedent
expands to the conjunction of all instances of a(X) for which the
corresponding instance of b(X) holds. Similarly, 2 {a(X) : b(X)} 4
holds whenever between two and four instances of a(X) (subject to
b(X)) are true. Speciﬁcally, we rely in the sequel on the input lan-
guage of the ASP system clingo [3].

3 ASP-based Sequence Mining

In this section, we introduce the sequential pattern mining tasks in
ASP. The following programs correspond to the notion of skip-gaps
encodings in [2, 7]. Gebser et al. [2] uses a different encoding strat-
egy for frequent sequential pattern that is not suitable for negative
patterns.

3.1 Fact format

We represent a database D in terms of facts seq(t,p,e), saying
that item e occurs at position p in a sequence t. For instance, Listing 1
speciﬁes a database of seven sequences:

Term
Seq.

1

5 6 7
3
(cid:104)d (ab) c(cid:105) (cid:104)a c b c(cid:105) (cid:104)a (bc) a(cid:105) (cid:104)(ab) c(cid:105) (cid:104)a c(cid:105) (cid:104)b(cid:105) (cid:104)c(cid:105)

4

2

Considering the minimal frequency threshold k = 2, one can
check that (cid:104)a(cid:105), (cid:104)b(cid:105), (cid:104)c(cid:105), (cid:104)a b(cid:105), (cid:104)(ab)(cid:105), (cid:104)a c(cid:105), (cid:104)b c(cid:105), and (cid:104)(ab) c(cid:105) are
the frequent patterns of the database.

3.2 Mining frequent sequences: basic encoding

The encoding principle for frequent sequence mining follows the one
of [13], that is, each answer set comprises a single pattern of interest.
In contrast to itemset mining, however, we need to take the order of
items in a pattern into account to determine its support and check its
frequency.

Listing 2 provides our basic encoding of frequent sequence min-
ing borrowed from [9]. It relies on two parameters: max determines a
maximum length for patterns of interest, and k speciﬁes the minimal
frequency threshold. An answer set then represents a frequent pat-
tern p = (cid:104)p1 . . . pm(cid:105) such that m ∈ [max] by atoms pat(m,p1),

1 item(I) :- seq(T,P,I).

3 slot(1).
4 { slot(X+1) } :- slot(X); X<max.
5 1{ pat(X,E) : item(E) } :- slot(X).

7 patlen(L) :- pat(L,_); not pat(L+1,E):item(E).

9 emb(T,P,1) :- seq(T,P,E):pat(1,E); seq(T,P,_).
10 emb(T,P,X+1) :- emb(T,Q,X); seq(T,P,_); Q<P;
11
12

seq(T,P,E):pat(X+1,E);
patlen(L); X<L.

14 cover(T) :- patlen(L); emb(T,_,L).

16 :- not k { cover(T) }.

Listing 2. Basic encoding of frequent sequence mining

. . . , pat(1,pm). That is, the ﬁrst argument expresses the posi-
tions of items. For instance, the atoms pat(1,a), pat(2,b), and
pat(2,c) stand for the (frequent) pattern (cid:104)a (bc)(cid:105) of the database
given in Listing 1.

A complete speciﬁcation of atoms used in our ASP encodings
along with their meanings is given in Table 1. In more detail, the rule
in Line 1 of Listing 2 provides items occurring in a given database D.
Lines 3 and 4 provides the slots for the itemset of a pattern with a
varying length m ∈ [max]. Line 7 evaluates the concrete length of
the candidate pattern. The (choice) rule in line 5 allows for picking
a subset of Σ per slot to build a pattern. As a result, the rules from
lines 1 to 5 establish a unique representation for a candidate pattern
whose frequency remains to be checked.

To this end, the rules from Line 9 to 12 traverse each sequence
t = (cid:104)t1 . . . tn(cid:105) in D to derive atoms of the form emb(t,p,x)
which represent all the embeddings of the pattern in a sequence. As
noted in Table 1, for p ∈ [n] and x ∈ [max], such an atom ex-
presses that it exists ((cid:15)i)i∈[p−1] such that pi ⊆ t(cid:15)i for all i ∈ [p − 1]
and px ⊆ tp, where p ∈ [n] and x ∈ [m]. Thus, it also means that
(cid:104)p1 . . . px(cid:105) (cid:118) (cid:104)t1 . . . tp(cid:105). Line 9 locates the occurrences of the ﬁrst
itemset in the sequence. The expression seq(t,p,e):pat(1,e)
ensures that every e ∈ p1 must hold at position p of the sequence
t. Line 10 ﬁnds out locations for px, the x-th itemset of the pat-
tern, from a position q such that q ≥ (cid:15)i for all i ∈ [p − 1],
where ((cid:15)i)i∈[p−1] is an embedding of (cid:104)p1 . . . px−1. The atoms
emb(t,p,x) are further inspected, line 14, to determine the cover
of a candidate pattern p. In these lines, the sequence is covered when
a complete embedding has been built, i.e. up to the length of the
pattern. The frequency of p is then checked in Line 16, where the
cardinality constraint “k { cover(t) }” over atoms cover(t),
signaling s (cid:118) t, expresses that at least the frequency threshold k
many sequences t must include s.

Example 1. For the database in Listing 1, the pattern (cid:104)a (bc)(cid:105) leads
to atoms emb(3,1,1), emb(3,1,3) and emb(3,2,2) among
which emb(3,2,2) in turn yields cover(3) for the sequence
(cid:104)a (bc) a(cid:105) denoted by 3. There is not any sequence for which a
complete embedding can be built, and (cid:104)a (bc)(cid:105) turns out to not be
frequent, given the threshold k = 2.

4 Negative sequential patterns

In this section, we introduce the notion of negative sequential pattern
by giving their syntax and semantics borrowed from [8].

Table 1. Atoms representing a pattern p = (cid:104)pi(cid:105)1≤i≤m, where 1 ≤ m ≤ max, and a given multiset D of sequences t = (cid:104)tj (cid:105)1≤j≤n

Atom
slot(x)
pat(x,e)
item(e)
cover(t)
emb(t,p,x)

Meaning
1 ≤ x ≤ m refers to the position x of an item sx in p
px = e is the item at position x in p, where x ∈ [m]
item e belongs to some t ∈ D
(cid:104)p1 . . . pm(cid:105) (cid:118) (cid:104)t1 . . . tn(cid:105), that is, p (cid:118) t
∃(ei)i∈[p−1] such that pi ⊆ tei for all i ∈ [p − 1] and px ⊆ tp, where p ∈ [n] and x ∈ [m].

Deﬁnition 1 (Negative sequential patterns (NSP)). A negative se-
quential pattern p = (cid:104)p1 ¬q1 p2 ¬q2 · · · pn−1 ¬qn−1 pn(cid:105) is a
ﬁnite sequence where pi ∈ 2Σ \ {∅} for all i ∈ [n] and qi ∈ 2Σ for
all i ∈ [n − 1].

p+ = (cid:104)p1 . . . pn(cid:105) is called the positive part of the NSP.

It can be noticed that Deﬁnition 1 introduces syntactic limitations
on negative sequential patterns that are commonly encountered in the
state of the art [17]: 1) a pattern can neither start or ﬁnish by a neg-
ative itemset, 2) a pattern cannot have two successive negative item-
sets. But a pattern can have successive positive itemsets considering
that a negative itemsets can be empty.

Example 2. This example illustrates the notations introduced
in Deﬁnition 1. Consider Σ = {a, b, c, d} and p =
(cid:104)a ¬(bc) (ad) d ¬(ab) d(cid:105). Let p1 = {a}, p2 = {ad}, p3 = {d},
p4 = {d} and q1 = {bc}, q2 = ∅, q3 = {ab}. p+ = (cid:104)a (ad) d d(cid:105).

4.1 Semantics of negative sequential patterns

The semantics of negative sequential patterns relies upon negative
containment: a sequence s contains pattern p iff s contains a sub-
sequence s(cid:48) such that every positive itemset of p is included in some
itemset of s(cid:48) in the same order and for any negative itemset ¬qi of
p, qi is not included in any itemset occurring in the sub-sequence of
s(cid:48) located between the occurrence of the positive itemset preceding
¬qi in p and the occurrence of the positive itemset following ¬qi in
p.

It turns out that the notion of negative containment has different
semantics depending on the deﬁnition of “not included” itemsets and
on the itemsets of the sequence to consider.

We introduce two relations comparing two itemsets P ∈ 2Σ \ {∅}

and I ∈ 2Σ:

• partial non inclusion: P (cid:54)⊆G I ⇔ ∃e ∈ P , e /∈ I
• total non inclusion: P (cid:54)⊆D I ⇔ ∀e ∈ P, e /∈ I

Partial non-inclusion means that P \ I is non-empty while total non-
inclusion means that P and I are disjoint. By convention, ∅ (cid:54)⊆D I
and ∅ (cid:54)⊆G I for all I ⊆ Σ.

In the sequel, we denote the general form of itemset non-inclusion

by the symbol (cid:54)⊆∗, meaning either (cid:54)⊆G or (cid:54)⊆D.

Intuitively, partial non-inclusion identiﬁes the itemset P with a
disjunction of negative constraints, i.e. at least one of the items (of P )
has to be absent from I, and total non-inclusion consider the itemset
P as a conjunction of negative constraints: all items (of P ) have to
be absent from I.

Choosing one non-inclusion interpretation or the other has con-
sequences on extracted patterns as well as on pattern search. Let us
illustrate this with the following dataset of sequences:

D =





s1 = (cid:104)(bc) f a(cid:105)
s2 = (cid:104)(bc) (cf ) a(cid:105)
s3 = (cid:104)(bc) (df ) a(cid:105)
s4 = (cid:104)(bc) (ef ) a(cid:105)
s5 = (cid:104)(bc) (cdef ) a(cid:105)





.

Table 2 compares the support of patterns under the two semantics
of itemset non-inclusion. Since the positive part of p2 is in s2, p2
occurs in the sequence iff (cd) (cid:54)⊆∗ (cf ). As for total non-inclusion,
it is false that (cd) (cid:54)⊆D (cf ) because c occurs in (cf ), and thus
p2 does not occur in s2. As for partial non-inclusion, it is true that
(cd) (cid:54)⊆G (cf ), because d does not occur in (cf ), and thus p2 occurs
in s2.

Table 2. Lists of sequences in D supported by negative patterns (pi)i=1..4
under the total and partial non-inclusion relations. Each pattern has the form
(cid:104)b ¬qi a(cid:105) where qi are itemsets such that qi ⊂ qi+1.

partial
non-inclusion
(cid:54)⊆G

p1 = (cid:104)b ¬c a(cid:105)
p2 = (cid:104)b ¬(cd) a(cid:105)
p3 = (cid:104)b ¬(cde) a(cid:105)
p4 = (cid:104)b ¬(cdeg) a(cid:105)

{s1, s3, s4}
{s1, s2, s3, s4}
{s1, s2, s3, s4}
{s1, s2, s3, s4, s5}

total
non-inclusion
(cid:54)⊆D

{s1, s3, s4}
{s1, s4}
{s1}
{s1}

Now, we formulate the notions of sub-sequence, non-inclusion and
absence by extending the concept of embedding (see Section 2.1) to
negative patterns.

Deﬁnition 2 (Strict and soft embeddings of negative patterns). Let
s = (cid:104)s1 . . . sn(cid:105) be a sequence and p = (cid:104)p1 ¬q1 . . . ¬qm−1 pm(cid:105)
be a negative sequential pattern.

An increasing3 tuple (cid:15) = ((cid:15)i)i∈[m] ∈ [n]m is a soft-embedding of

pattern p in sequence s iff:

• pi ⊆ sei for all i ∈ [m]
• qi (cid:54)⊆∗ sj, for all j ∈ [ei + 1, ei+1 − 1] and for all i ∈ [m − 1]

An increasing3 tuple e = (ei)i∈[m] ∈ [n]m is a strict-embedding

of pattern p in sequence s iff:

• pi ⊆ sei for all i ∈ [m]
• qi (cid:54)⊆∗ (cid:83)

j∈[ei+1,ei+1−1] sj for all i ∈ [m − 1]

Intuitively, the constraint of a negative itemset qi is checked on
the sequence’s itemsets at positions in interval [ei + 1, ei+1 − 1],
i.e. between occurrences of the two positive itemsets surrounding the
negative itemset in the pattern. A soft embedding considers individ-
ually each of the sequence’s itemsets of [ei + 1, ei+1 − 1] while a
strict embedding consider them as a whole.

Example 3 (Itemset absence semantics). Let p = (cid:104)a ¬(bc) d(cid:105) be a
pattern and consider four sequences as follows:

3 By an increasing tuple e, we mean a tuple such that (cid:15)i < (cid:15)i+1 (in particular,

repetitions are not allowed).

Sequence

(cid:54)⊆D
strict

(cid:54)⊆D
soft

(cid:54)⊆G
strict

(cid:54)⊆G
soft

s1 = (cid:104)a c b e d(cid:105)
s2 = (cid:104)a (bc) e d(cid:105)
s3 = (cid:104)a b e d(cid:105)
s4 = (cid:104)a e d(cid:105)

(cid:51)

(cid:51)

(cid:51)
(cid:51)

(cid:51)

(cid:51)
(cid:51)

Notice that each sequence contains a unique occurrence of p+ =
(cid:104)a d(cid:105), the positive part of pattern p. Considering soft-embedding and
partial non-inclusion ((cid:54)⊆∗:=(cid:54)⊆G), p occurs in s1, s3 and s4 but not
in s2. Considering strict-embedding and partial non-inclusion, p oc-
curs in s3 and s4. Indeed, items b and c occur between occurrences
of a and d in s1 and s2. Considering total non-inclusion ((cid:54)⊆∗:=(cid:54)⊆D)
and either type of embeddings, the absence of an itemset is satisﬁed
if any of its items is absent. Hence, p occurs only in s4.

Let us now give some lemmata about the relations between the

different types of embedding.4

Lemma 1. In the case that (cid:54)⊆∗ is (cid:54)⊆D, e is a soft-embedding iff e is
a strict-embedding

Lemma 2. Let p = (cid:104)p1 ¬q1 . . . ¬qn−1 pn(cid:105) ∈ N such that |qi| ≤
1 for all i ∈ [n − 1], then e is a soft-embedding iff e is a strict-
embedding.

At this point, we have exhibited four semantics for negative pat-
tern embeddings. Lemmata 1 and 2 concluded to the equivalence of
soft and strict-embeddings when the itemset non-inclusion relation is
(cid:54)⊆D.

In [8], we proposed notations to disambiguate syntactically the
different types of negation (¬(a1, . . . , ali ) or ¬{a1, . . . , ali } or
¬|a1, . . . , ali |). ]l, u[ denotes the interval of integers [l + 1, u − 1].

• ¬(a1, . . . , ali ) is evaluated as

{a1, . . . , ali } (cid:54)⊆G sj, ∀j ∈]ei, ei+1[ for all i ∈ [m − 1]
(2)
Intuitively, you check that, in between sei (i.e., a match for pi)
and sei+1 (i.e., a match for pi+1), none of these sj include all of
a1, . . . , ali .

• ¬{a1, . . . , ali } is evaluated as

(cid:91)

{a1, . . . , ali } (cid:54)⊆G

sj for all i ∈ [m − 1]

(3)

j∈]ei,ei+1[

Intuitively, we check that there exists some item in a1, . . . , ali that
does not occur at all in between sei (i.e., a match for pi) and sei+1
(i.e., a match for pi+1).

• ¬|a1, . . . , ali | is evaluated as

{a1, . . . , ali } (cid:54)⊆D sj, ∀j ∈]ei, ei+1[ for all i ∈ [m − 1]
(4)
Intuitively, we check that every item in a1, . . . , ali fails to occur
in between sei (i.e., a match for pi) and sei+1 (i.e., a match for
pi+1).

4.2 Multiple occurrences

Another point that determines the semantics of negative containment
concerns the multiple occurrences of some pattern in a sequence:
should at least one or should all occurrences of the pattern positive
part in the sequence satisfy the non-inclusion constraints?

4 Proofs of these Lemmata can be found in the extended version of [8].

The strong containment relation states that a negative pattern p oc-
curs in a sequence s iff there exists at least one occurrence of the pos-
itive part of pattern p in sequence s and every such occurrence sat-
isﬁes the negative constraints; the strong containment relation states
p occurs in a sequence s iff there exists at least one occurrence of
the positive part of pattern p in sequence s and at least one of these
occurrences satisﬁes the negative constraints.

Example 4 (Strong vs weak occurrence semantics). Let p =
(cid:104)a b ¬c d(cid:105) be a pattern, s1 = (cid:104)a b e d(cid:105) and s2 = (cid:104)a b c a d e b d(cid:105)
be two sequences. Thus, p+ = (cid:104)a b d(cid:105) occurs once in s1 hence there
is no difference for occurrences of p in s1 under the two semantics.
However, p+ occurs four times in s2 through embeddings (1, 2, 5),
(1, 2, 8), (1, 7, 8) and (4, 7, 8). The ﬁrst two occurrences do not sat-
isfy the negative constraint (¬c) but the last two occurrences do. Un-
der the weak occurrence semantics, pattern p occurs in sequence s2
whereas it fails to do so under the strong occurrence semantics.

5 ASP encodings of negative sequential patterns

In the following, we introduce new facts to encode negations in neg-
ative sequential patterns. The pat(x,e) atom now represents the
positive part of a negative sequential pattern. The negated itemsets
are encoded by terms of three predicates: negpat/2 (for ¬| · |),
cnegpat/2 (for ¬{·}) and csnegpat/2 (for ¬(·)). For instance,
the pattern (cid:104)a¬|b|a¬(bd)c(cid:105) is encoded by the facts pat(1,a),
pat(2,a), pat(3,c), negpat(1,b), csnegpat(2,b) and
csnegpat(2,d).

The following choice rule illustrates the generation of negative
itemsets of kind ¬| · |. Similar rules yield the negative part of a can-
didate pattern for the two other kinds of negations.

{ negpat(X,E): item(E), not pat(X,E) } :-

slot(X), X<L, patlen(L).

Note that we assume that it is not possible to have several different
kinds of negated itemsets at the same position. For instance, pattern
(cid:104)a¬|b|¬{c}d(cid:105) is not possible.

In the next section, we give the rules for negative constraints. A
negative constraint denotes a constraint upon an embedding ((cid:15)i)i∈[n]
of the positive part that is expressed by a negated itemset in the can-
didate negative pattern. If all negative constraints are satisﬁed, then
((cid:15)i)i∈[n] is an embedding of the negative pattern. Then, it is further
used to evaluate the containment of the candidate pattern p in a se-
quence t.

The core of the encoding relies on the construction of an embed-
ding. We adapt the deﬁnition of the predicate emb/3 to negative
sequential patterns as follow: let p = (cid:104)p1 ¬q1 . . . pm(cid:105) be a neg-
ative sequential pattern, t = (cid:104)t1 . . . tn(cid:105) be a sequence, and ν a
Boolean value, then emb(t,ρ,x,ν) means that ∃(ei)i∈[x−1] such
that x ∈ [m], ρ ∈ [n] and

1. pi ⊆ tei for all i ∈ [x − 1],
2. px ⊆ tρ,
3. ∃y ∈ [x − 1] s.t. qy is not satisﬁed for the partial embedding

(ei)i∈[p−1] if ν is true,

4. ∀y ∈ [x − 1] s.t. qy is satisﬁed for the partial embedding

(ei)i∈[p−1] if ν is false,

Note that “qy is not satisﬁed for the partial embedding (ei)i∈[p−1]”
refers to the semantics of negation (see previous section) whatever
the kind of occurrence (weak or strong).

1 emb(T,P,1,0)

:- seq(T,P,E):pat(1,E); seq(T,P,_).

3 emb(T,P,X+1,1) :- emb(T,Q,X,1); Q<P;
4
5

seq(T,P,E):pat(X+1,E); seq(T,P,_);
patlen(L); X<L.

7 emb(T,P,X+1,0) :- emb(T,Q,X,0);
8
9
10

seq(T,P,E):pat(X+1,E); seq(T,P,_); P>Q;
#count{ R : not seq(T,R,Ep), csnegpat(X,Ep), R=(Q+1)..(P-1)}=(P-Q-1);
patlen(L); X<L.

12 emb(T,P,X+1,1) :- emb(T,Q,X,0);
13
14
15

seq(T,P,E):pat(X+1,E); seq(T,P,_); P>Q;
#count{ R : not seq(T,R,Ep), csnegpat(X,Ep), R=(Q+1)..(P-1)}!=(P-Q-1);
patlen(L); X<L.

Listing 3. Encoding for embedding with ¬(·)/csnegpat/2 negative itemsets

1 emb(T,P,X+1,1) :- emb(T,Q,X,0); Q<P;
2
3
4

seq(T,P,E):pat(X+1,E); seq(T,P,_);
#count{ R : seq(T,R,Ep), negpat(X,Ep), Q<R, R<P}!=0;
patlen(L); X<L.

6 emb(T,P,X+1,0) :- emb(T,Q,X,0); Q<P;
7
8
9

seq(T,P,E):pat(X+1,E); seq(T,P,_);
#count{ R : seq(T,R,Ep), negpat(X,Ep), Q<R, R<P}=0;
patlen(L); X<L.

Listing 4. Encoding for embedding with ¬| · |/negpat/2 negative itemsets

ν is a Boolean value that stores the information for an embedding
of the positive part that these embedding satisﬁes or not the negative
constraints.

With this deﬁnition it happens that if there is an atom of the em-
bedding emb(t,p,l,ν) where l is the size of the positive part of
the pattern whatever the ν value, then the positive part occurs in the
sequence t. If ν is false, this means that there exists an embedding for
the negative sequential pattern, thus p weakly occurs in t. If there is
no embedding such that ν is true, then it means that no embedding of
the positive part is an embedding of the negative sequential pattern.
Thus p strongly occurs in t if it is not the case. The following rules
encode the rules of pattern covering for the two different deﬁnitions
of weak and strong occurrences of a candidate pattern.

weakcover(T) :- patlen(L); emb(T,_,L,0).
strongcover(T) :- patlen(L); emb(T,_,L,_);

#count{ T : emb(T,_,L,1) }=0.

Then, depending on the kind of covering considered, line 16 of

Listing 2 is adapted to the minimal occurrence number constraint.

The remainder of this section details the encoding for each seman-

tics of negative itemsets.

5.1 Encoding of ¬(·) negative constraints

Listing 3 gives the encoding yielding the emb/4 atoms considering
patterns with ¬(·)/csnegpat/2 negative itemsets.

In this encoding, the Line 1 states that (cid:15)1 of an embedding is a po-
sition p in the sequence t such p1 ⊆ tp. For the ﬁrst pattern itemset,
there are no negative constraints at previous position. Thus, ν is false
(0).

The rule in lines 3-5 is similar to the rule in lines 10-12 of List-
ing 2. They yield the (cid:15)x+1 of an embedding of the positive part of
the pattern where ((cid:15)i)i∈[x] is an embedding of (cid:104)p1 ¬q1 . . . px(cid:105) s.t.

there exists y ∈ [x − 1] s.t. qy is not satisﬁed (ν is true). In this
case, ((cid:15)i)i∈[x+1] is an embedding of (cid:104)p1 ¬q1 . . . px+1(cid:105) that nei-
ther satisﬁes all the negative constraints. Thus, the truth value of ν is
propagated.

The rules in lines 7-15 consider the case of an embedding ((cid:15)i)i∈[x]
of the negative pattern (cid:104)p1 ¬q1 . . . px(cid:105) such that all the negative
constraints are satisﬁed. Then, there are two cases for the embedding
((cid:15)i)i∈[x+1]. If there exists a position p in the sequence t such that
px+1 ⊆ tp and the negative constraint qx is satisﬁed, then the atom
emb(t,p,l,ν) is yielded with ν set to false (0). That is, the rule in
lines 7-10. But, if there exists a position p, p > (cid:15)x in the sequence
t such that px+1 ⊆ tp and the negative constraint qx is not satis-
ﬁed, then the atom emb(t,p,l,ν) is yielded with ν set to true (1).
That is, the rule in lines 12-15. Note that these two rules could be
factorised to avoid redundancies. For sake of readability, we prefer
to present this redundant syntax.

Let us now detail how to evaluate the negative constraint qx (i.e.,
the set of atoms csnegpat(x,e)). According to Equation 2, the
negative constraint qx is satisﬁed iff ∀r ∈](cid:15)i, (cid:15)i+1[, ∃e ∈ qx, s.t. e (cid:54)∈
tr. It is equivalent to evaluate whether |{r ∈](cid:15)i, (cid:15)i+1[|∃e ∈ qx, e (cid:54)∈
tr}| is equal to (cid:15)i+1 − (cid:15)i + 1. This latter constraint is encoded line 9
and its opposite is encoded line 14. The #count is an aggregate to
compute the number of different R values satisfying conditions after
the colon.

5.2 Encoding of ¬| · | negative constraints

The negative constraints qx with ¬| · |/negpat/2 is satisﬁed iff
∀r ∈](cid:15)i, (cid:15)i+1[, ∀e ∈ qx, e (cid:54)∈ tr (see Equation 4). This means that it
is not satisﬁed iff {r ∈](cid:15)i, (cid:15)i+1[|e ∈ qx ∧ e ∈ tr} is empty.

Listing 4 yields atoms of predicate emb/4 with the same principle
of Listing 3. The lines 3 or 8 evaluate |{r ∈](cid:15)i, (cid:15)i+1[|e ∈ qx∧ ∈

1 negislen(X,N) :- X=1..(L-1); patlen(L); N=#count{E : cnegpat(X,E)}.

3 emb(T,P,X+1,1) :- emb(T,Q,X,0); Q<P;
4
5
6
7

seq(T,P,E):pat(X+1,E); seq(T,P,_);
negislen(X,N);
N=#count{ Ep : seq(T,R,Ep), cnegpat(X,Ep), Q<R, R<P};
patlen(L); X<L.

9 emb(T,P,X+1,0) :- emb(T,Q,X,0); Q<P;
10
11
12
13

seq(T,P,E):pat(X+1,E); seq(T,P,_);
negislen(X,N);
N!=#count{ Ep : seq(T,R,Ep), cnegpat(X,Ep), Q<R, R<P};
patlen(L); X<L.

Listing 5. Encoding for embedding with ¬{·}/cnegpat/2 negative itemsets

tr}|. It is compared to 0 to assign the truth value to ν for (cid:15)x+1 (if
exists, i.e., px+1 ⊆ t(cid:15)x+1 ).

5.3 Encoding of ¬{·} negative constraints

Finally, the negative constraint qx with ¬{·}/cnegpat/2 is satis-
ﬁed iff ∃e ∈ qx, e (cid:54)∈ (cid:83)
r∈](cid:15)i,(cid:15)i+1[ tr (see Equation 3). This means
that it is not satisﬁed iff ∀e ∈ qx, e ∈ (cid:83)
r∈](cid:15)i,(cid:15)i+1[ tr or in other
words that |{e ∈ qx|e ∈ (cid:83)

r∈](cid:15)i,(cid:15)i+1[ tr}| = |qx−1|.

Listing 5 yields atoms of predicate emb/4 with the same prin-
ciple of Listing 3. Line 1 evaluates the size of negative itemsets.
negislen(x,n) states that |qx| = n. Lines 6 and 12 evaluate
|{e ∈ qx|e ∈ (cid:83)
r∈](cid:15)i,(cid:15)i+1[ tr}|. It is compared to |qx| to assign the
truth value to ν for (cid:15)x+1 (if exists, i.e., px+1 ⊆ t(cid:15)x+1 ).

6 Experiments and results

The previous section exhibited the ease of modeling of the different
semantics of negative sequential patterns in order to extract the fre-
quent ones. It is worth noticing that only few of these semantics have
properties to design algorithms that are both efﬁcient and complete
[8]. More precisely, the anti-monotonicity property holds with weak
occurrences of ¬| · |, and weaker versions of anti-monotonicity hold
with the strong occurrences of ¬| · |.

The question investigated in these experiments is whether the
solver takes advantage of these properties to achieve the mining task
within a lower computation time.

6.1 Experimental setting

We conducted experiments on synthetic sets of sequences generated
with the generator of [2], without hidden patterns (pure random se-
quences).

The usage of synthetic sets of sequences allows us to control and
analyze the most important characteristics of data wrt the computing
time. To be more precise, we randomly generated sets of 100 se-
quences. Each sequence contains 10 itemsets. Each itemset is of size
2. Items are randomly generated according to a Gaussian law (some
items are more frequent than others) over a vocabulary of 20 items.
For each data point, we then give average computing times over ﬁve
similar sets of sequences.

All the experiments have been using the clingo solver5 on a desk-
top computer with enough memory to prevent from using cache

5 clingo version 5.3.1

memory and ran with a single thread. A timeout was set up to 5 min-
utes.

For sake of better interpretability of the results and of computa-
tion time, the negative sequential patterns contain only one kind of
negated itemset (¬| · |, ¬(·) or ¬{·}), the length of the positive part
of a pattern is at most 3, and the size of negated itemsets is limited to
2 items.

Note that we do not compare our approach with dedicated algo-
rithms, e.g. [10, 17] that are undoubtly signiﬁcantly more efﬁcient for
this task. We remind that declarative pattern mining aims at achieving
reasonable computation time for mid-sized set of examples. Thus, it
can be used to inject some expert knowledge in the mining process
to reduce the number of patterns.

6.2 Results

Figure 1 compares the number of patterns that are extracted through
the different semantics of negative patterns. Note that it is very inter-
esting to have this study as no algorithm can extract a complete set
of frequent negative sequential patterns for all negation semantics.

The ﬁgures take into account only the number of patterns for runs
ended before timeout (5 minutes). It explains that there are only few
results for ¬{·} which is often out of the timeout.

The results illustrated in Figure 1 are consistent with theoretical
results [8]. First, we notice that there are more patterns extracted
with weak-occurrences than with strong-occurrences. For identical
settings, there are in average 2.80 ± 2.13 times more patterns with
weak-occurrences than with strong-occurrences. Second, ¬| · | is the
strongest negative constraint after ¬{·} and ﬁnally ¬(·) is the weak-
est. As a consequence, there are more extracted patterns for ¬(·),
than for ¬| · |. The number of patterns for ¬{·} is in-between when
available.

Figure 2 compares computing times of ASP-based negative se-
quential pattern mining with different semantics of negative patterns.
We can ﬁrst notice that extracting negative sequential patterns with
¬{·} lacks efﬁciency and the mining tasks does not ﬁnish before
timeout in most cases.

Then, despite the larger number of occurrences of weak-
occurrences, evaluating weak occurrences is more efﬁcient that eval-
uating the strong ones. It is unsurprising. Indeed, as soon as a weak-
occurrence has been found, the atom cover(t) is proved to be true
without necessarily exploring the other embeddings of the positive
part of the pattern. For strong occurrences, it is mandatory to evalu-
ate negative patterns for every embedding of the positive part of the
candidate pattern.

Figure 1. Boxplots of the numbers of patterns for computing all frequent negative sequential patterns wrt different thresholds (24, 27 and 30) using ASP. Each
plot corresponds to one speciﬁc semantic, from left to right ¬{·}, ¬| · | and ¬(·). Blue (resp. red) boxplots correspond to weak (resp. strong) occurrences).

Figure 2. Boxplots of times for computing all frequent negative sequential patterns wrt different thresholds (24, 27 and 30) using ASP. Each plot corresponds
to one speciﬁc semantic, from left to right ¬{·}, ¬| · | and ¬(·). Blue (resp. red) boxplots correspond to weak (resp. strong) occurrences).

The surprising result of this experiment is in the comparison be-
tween ¬(·) and ¬| · |. It turns out that mining negative sequential
patterns with ¬(·) is signiﬁcantly more efﬁcient than with ¬| · |. This
result is enhanced by the fact that there are many more patterns to
extract with ¬(·) than with ¬| · |. So there are more patterns but more
efﬁciently extracted. The opposite outcome was expected due to our
theoretical results that exhibited anti-monotonicity for ¬| · |, but not
for ¬(·).

7 Conclusion

This article extends the framework of mining sequential patterns
with Answer Set Programming to negative sequential patterns. We
encoded the three different semantics of absent events proposed in
[8]. The ﬁrst interest of the approach is to evaluate the impact of the
choice of one of the semantics on the set of extracted patterns. In
this article, we focused on the size of this set. Deeper experiments on
real datasets would be interesting to identify the differences between
these sets of patterns.

Our experiments on synthetic data show that the kind of negated
itemset for which the encoding is the most efﬁcient is not the ex-
pected one. Indeed, we expected to have better efﬁciency with ¬| · |.
A possible explanation of this observation may be that there are also
anti-monotonicity properties of ¬(·) for partial orders that are not
usually investigated for pattern mining algorithms [10]. More inves-

tigation is required to conﬁrm this intuition. But it encourages us to
think that there are potentially better encodings for ¬| · |. One of our
perspectives is to investigate saturation programming techniques that
may be suitable and efﬁcient to encode weak-occurrences of negative
sequential patterns.

In addition, these encodings may be used to characterize what pat-
terns can still be mined by incomplete mining heuristics. Wang et al.
[17] reviewed such algorithms but they do not characterise the ex-
tracted patterns among the complete set of patterns. Comparing their
outputs with the outputs of our encodings makes it possible to inves-
tigate this question.

REFERENCES

[1] Emmanuel Coquery, Said Jabbour, Lakhdar Sais, and Yakoub Salhi,
‘A SAT-based approach for discovering frequent, closed and maximal
patterns in a sequence’, in Proceedings of the European Conference on
Artiﬁcial Intelligence, volume 242, pp. 258–263, (2012).

[2] Martin Gebser, Thomas Guyet, Ren´e Quiniou, Javier Romero, and
Torsten Schaub, ‘Knowledge-based sequence mining with ASP’, in
Proceedings of International Join Conference on Artiﬁcial Intelligence,
pp. 1497–1504, (2016).

[3] Martin Gebser, Roland Kaminski, Benjamin Kaufmann, and Torsten
Schaub, ‘Clingo = ASP + Control: Preliminary report’, in Technical
Communications of the Thirtieth International Conference on Logic
Programming, (2014).

[4] Mickael Gelfond and Vladimir Lifschitz, ‘Classical negation in logic

lllllllllll−{.}−|.|−(.)24273024273024273001000020000300004000050000Minimal frequency threshold ( k )#patternsstrongweaklllllllll−{.}−|.|−(.)2427302427302427300100200300Minimal frequency threshold ( k )Time (s)strongweakprograms and disjunctive databases’, New Generation Computing, 9,
365–385, (1991).

[5] Tias Guns, Anton Dries, Siegfried Nijssen, Guido Tack, and Luc
De Raedt, ‘Miningzinc: A declarative framework for constraint-based
mining’, Artiﬁcial Intelligence, 244, 6–29, (2017).

[6] Tias Guns, Sergey Paramonov, and Benjamin Negrevergne, ‘On declar-
ative modeling of structured pattern mining’, in Workshops at the Thir-
tieth AAAI Conference on Artiﬁcial Intelligence, (2016).

[7] Thomas Guyet, Enhancing sequential pattern mining with time and rea-
soning, Habilitation `a diriger des recherches, Universit´e de Rennes 1,
2020.

[8] Thomas Guyet and Philippe Besnard, ‘Semantics of negative sequential
patterns’, in Proceedings of European Conference on Artiﬁcial Intelli-
gence (ECAI), p. to appear, Santiago de Compostela, Spain, (2020).
[9] Thomas Guyet, Yves Moinard, Ren´e Quiniou, and Torsten Schaub, ‘Ef-
ﬁciency analysis of ASP encodings for sequential pattern mining tasks’,
in Advances in Knowledge Discovery and Management, eds., Bruno
Pinaud, Fabrice Guillet, Bruno Cremilleux, and Cyril de Runz, vol-
ume 7, 41–81, Springer, (2017).

[10] Thomas Guyet and Ren´e Quiniou, ‘NegPSpan: efﬁcient extraction of
negative sequential patterns with embedding constraints’, Data Mining
and Knowledge Discovery, 34(2), 563–609, (2020).
Jiawei Han, Hong Cheng, Dong Xin, and Xifeng Yan, ‘Frequent pattern
mining: current status and future directions’, Data Mining and Knowl-
edge Discovery, 15(1), 55–86, (2007).

[11]

[12] Sa¨ıd Jabbour, Lakhdar Sais, and Yakoub Salhi, ‘Decomposition based
SAT encodings for itemset mining problems’, in Paciﬁc-Asia Con-
ference on Knowledge Discovery and Data Mining, pp. 662–674.
Springer, (2015).

[13] Matti J¨arvisalo, ‘Itemset mining as a challenge application for answer
set enumeration’, in Proceedings of the conference on Logic Program-
ming and Nonmonotonic Reasoning, pp. 304–310, (2011).

[14] Carl H. Mooney and John F. Roddick, ‘Sequential pattern mining –
approaches and algorithms’, ACM Computing Survey, 45(2), 1–39,
(2013).

[15] Benjamin Negrevergne and Tias Guns, ‘Constraint-based sequence
mining using constraint programming’, in Proceedings of International
Conference on Integration of AI and OR Techniques in Constraint Pro-
gramming, CPAIOR, pp. 288–305, (2015).

[16] Patrik Simons, Ilkka Niemel´a, and Timo Soininen, ‘Extending and im-
plementing the stable model semantics’, Journal of Artiﬁcial Intelli-
gence, 138(1-2), 181–234, (2002).

[17] Wei Wang and Longbing Cao, ‘Negative sequence analysis: A review’,

ACM Computing Survey, 52(2), 32:1–32:39, (2019).

