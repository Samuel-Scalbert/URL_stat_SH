Backward Type Inference for XML Queries
Hyeonseung Im, Pierre Genevès, Nils Gesbert, Nabil Layaïda

To cite this version:

Hyeonseung Im, Pierre Genevès, Nils Gesbert, Nabil Layaïda. Backward Type Inference for XML
Queries. Theoretical Computer Science, 2020, Theoretical Computer Science, 823, pp.69 - 99.
￿10.1016/j.tcs.2020.03.020￿. ￿hal-01497857v3￿

HAL Id: hal-01497857

https://inria.hal.science/hal-01497857v3

Submitted on 4 May 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Theoretical Computer Science 823 (2020) 69–99

Contents lists available at ScienceDirect

Theoretical  Computer  Science

www.elsevier.com/locate/tcs

Backward  type  inference  for  XML  queries
Hyeonseung Im a,∗
a Kangwon National University, 1 Gangwondaehak-gil, Chuncheon-si, 24341 Republic of Korea
b Univ. Grenoble Alpes, CNRS, Inria, Grenoble INP, LIG, 38000 Grenoble, France

,  Pierre Genevès b,  Nils Gesbert b,  Nabil Layaïda b

a  r  t  i  c  l  e 

i  n  f  o

a  b  s  t  r  a  c  t

Although  XQuery  is  a  statically  typed,  functional  query  language  for  XML  data,  some  of 
its  features  such  as  upward  and  horizontal  XPath  axes  are  typed  imprecisely.  The  main 
reason is that while the XQuery data model allows us to navigate upwards and between 
siblings  from  a  given  XML  node,  the  type  model,  e.g.,  regular  tree  types,  can  describe 
only the subtree structure of the given node. To alleviate this limitation, precise forward 
type inference systems for XQuery were recently proposed using an extended regular type 
language that can describe not only a given XML node but also its context. In this paper, 
as a different approach, we propose a novel backward type inference system for XQuery, 
based  on  a  type  language  extended  with  logical  formulas.  Our  backward  type  inference 
system provides an exact typing result for XPath axes and a sound typing result for XQuery 
expressions.

© 2020 Elsevier B.V. All rights reserved.

Article history:
Received 1 October 2018
Received in revised form 17 February 2020
Accepted 25 March 2020
Available online 27 March 2020
Communicated by W. Fan

Keywords:
XPath
XQuery
Static type system
Type inference
Regular tree types
Mu-calculus

1.  Introduction

XQuery [1] is a statically typed, functional, World Wide Web Consortium (W3C) standard query language for XML data. 
Its type language is based on regular tree types (i.e., regular tree languages) [2] and its static and dynamic semantics are 
formally deﬁned [3]. One of the key features of XQuery is its use of XPath [4,5] to navigate and extract XML data. Although 
XPath  navigational  expressions  greatly  facilitate  XML  manipulation,  they  are  also  a  main  source  of  undesired,  imprecise 
type  inference  in  the  XQuery  formal  semantics.  Speciﬁcally,  when  upward  or  horizontal  XPath  axes  such  as parent and
following-sibling are  used,  the  formal  semantics  simply  deduces  the  most  general  type  (e.g., AnyElt for parent
and AnyElt∗ for following-sibling where AnyElt denotes the type of all XML elements), which essentially conveys no 
information, regardless of the type of the initial XML document. In the end, in the recent recommendations of XPath 3.0 [6]
and XQuery 3.0 [7], static typing became “implementation deﬁned” and hence optional.

The over-approximation in type inference is in particular due to the discrepancy between the XQuery data model and the 
type model. Speciﬁcally, in XQuery, values are sequences of pointers to XML tree nodes and each pointer can point anywhere 
in the corresponding tree. Moreover, given such a pointer, it is always possible to obtain a pointer to its parent or sibling 
node,  thus  allowing  us  to  navigate  upwards  and  between  siblings.  In  clear  contrast,  given  a  pointer  value,  its  type  (e.g., 
a regular tree type) can describe only the subtree structure to which the pointer points, but not its context, i.e., part of the 

* Corresponding author.

E-mail addresses: hsim@kangwon.ac.kr (H. Im), pierre.geneves@cnrs.fr (P. Genevès), nils.gesbert@grenoble-inp.fr (N. Gesbert), nabil.layaida@inria.fr

(N. Layaïda).

https://doi.org/10.1016/j.tcs.2020.03.020
0304-3975/© 2020 Elsevier B.V. All rights reserved.

70

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

whole tree except the subtree pointed by the pointer value. Therefore, with this type language, only downward axes such 
as child and desc can be precisely typed at best (e.g., [8]).

There are two different approaches to alleviate this limitation. The ﬁrst approach is to develop a typechecking algorithm 
based  on  backward  type  inference  (also  known  as  inverse  type  inference) [9–14].  Given  an  XQuery  expression  e and  an 
expected output type ρo, backward type inference computes the pre-image ρi of ρo with respect to e such that it is guar-
anteed that for any XML document of type ρi , e always produces a document of type ρo . Since the pre-image of a regular 
tree language with respect to a macro tree transducer (MTT) is also regular [15], MTTs and their variants have often been 
used as a model of XML transformations in the context of backward type inference [11,12,14]. Although exact typechecking 
can be done with backward type inference, its complexity is hyper-exponential (i.e., a stack of exponentials) [10,12,16]. To 
our knowledge, both practical and exact backward type inference for general XML transformations exploiting backward axes 
such as parent and anc has not been reported yet.

In  contrast,  the  second  approach  is  to  develop  an  approximate  but  practical  forward  type  inference  system  by  using 
a  reﬁned  type  language  that  can  describe  not  only  XML  nodes  but  also  their  contexts.  For  example,  Castagna  et  al. [17]
extend regular tree types with zipper data structures [18] and propose a precise type system for XQuery 3.0 (which is not 
exact  but  deduces  a  more  precise  type  than  the  most  general  type  such  as  AnyElt whenever  possible).  Their  type  system 
supports all navigational XQuery expressions including type and value case analysis and higher-order functions. Genevès and 
Gesbert [19] also develop a precise type system for XQuery by combining regular tree types with modal logic formulas [20]. 
By  encoding  context  information  using  modal  formulas,  their  type  system  also  deduces  precise  types  for  backward  axes 
as well as forward axes. However, none of [17] and [19] provide exact typing for XPath axes. Moreover, although practical 
implementation  is  feasible,  forward  type  inference  cannot  be  exact  if  it  infers  a  regular  tree  type  for  admissible  outputs 
since  a  general  transformation  does  not  preserve  regularity.  (Typechecking  based  on  forward  type  inference  can  be  exact 
though if it infers a more expressive type such as a context-free tree grammar [21] or a higher-order recursion scheme [22]
and checks inclusion against the output type speciﬁed by a regular tree grammar.)

In this paper, we revisit a problem of backward type inference for XML queries. In particular, we develop a novel XQuery 
source  language  type  system  using  the  reﬁned  type  language  proposed  in  [19].  While  tree  transducers  can  be  used  as 
an  intermediate  language  for  XQuery,  having  a  source  language  type  system  in  itself  is  useful  as  it  is  usually  easier  to 
understand. Moreover, by building a backward type inference system on the XQuery syntax and the existing type language, 
it would be possible to combine it with forward type inference, for example, in order to develop a more precise and practical 
bidirectional typechecking algorithm. Thus, this work can be considered as a stepping stone towards such bidirectional type 
systems.

To develop a backward type inference system, we ﬁrst deﬁne the syntax and semantics of an XQuery core by representing 
XML nodes as focused trees [20] (Section 2). A focused tree is a variant of zipper data structures [18], which describes a whole 
tree “seen” from a given internal node, that is, a subtree and its context. As focused trees support functional navigation in 
any direction from a given tree node, we can simplify the semantics of the XQuery core, without resorting to an external 
store for node pointers as in the XQuery formal semantics. With focused trees, our semantics is a straightforward extension 
of the one given in [8] with non-downward XPath axes.

As for our type language, we use formula-enriched sequence types [19], which combine the usual regular tree types with 
tree  logic  formulas  [20] to  describe  both  a  tree  node  and  its  context  (Section 3).  Then,  using  formula-enriched  sequence 
types, we deﬁne an exact backward type inference system for XPath axes (Section 4). That is, given an XPath axis and an 
output type ρ, if our inference system infers an input type ρ(cid:3)
, the result of evaluating the axis is of type ρ if and only if 
an input focused tree is of type ρ(cid:3)
. Then, building on the inference rules for XPath axes, we deﬁne a sound backward type 
inference system for the XQuery core (Section 5). In the presence of an arbitrary for-expression with a formula-enriched 
sequence type as an output type, both practical and exact typing is nontrivial or even may be infeasible, and therefore we 
introduce an approximation.

We summarize the main contributions as follows:

• We  formulate  a  novel  backward  type  inference  system  for  a  large  fragment  of  XQuery,  including  all  the  XPath  axis 
expressions.  In  particular,  we  show  that  our  backward  type  inference  for  XPath  axes  is  exact  and  its  complexity  is 
simple exponential.

• We  prove  soundness  of  our  backward  type  inference  system  for  the  XQuery  core,  from  which  we  can  obtain  a  type-
checking algorithm. We also formally analyze the complexity of our inference system, and show that its complexity is 
double exponential in terms of the given expression.

2.  Syntax and semantics of an XQuery core

In this section, we introduce an XQuery core, a minimal XQuery fragment supporting all the navigational XPath axes. Our 

XQuery core is an extension of miniXQuery proposed in [8] with non-downward axes.

2.1.  Focused trees

We ﬁrst deﬁne XML trees as focused trees, inspired by Huet’s zipper data structure [18]. A focused tree is an XML node 
with  its  context:  the  siblings  and  the  parent  of  the  node,  including  the  parent’s  context  recursively.  Intuitively  a  context 

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

71

Fig. 1. An example XML tree structure and its corresponding binary representation.

records the path covered when traversing an XML tree from its root to a certain node. Thus focused trees allow us to easily 
navigate XML trees in any direction: both forward and backward navigation.

Below we formally deﬁne the syntax of our data model. We assume an alphabet (cid:3) of labels, ranged over by σ .

Trees
Tree lists
Contexts
Focused trees

t
tl
c
f

::= σ [tl]
::= (cid:5) | t :: tl
::= Top | (tl; c[σ ]; tl)
::= (t, c)

A focused tree (t, c) is a pair consisting of a focused node (or a tree) t and its context c. A context c is Top if the focused 
node  is  at  the  root.  Otherwise  it  is  a  triple  (tll; c[σ ]; tlr):  tll is  a  list  of  the  left  siblings  of  the  current  focused  node  in 
reverse order (the ﬁrst element of the list is the tree immediately to the left of the current node), c[σ ] the context above 
the current node where σ is the label of the parent, and tlr a list of the right siblings.

We now describe how to navigate a focused tree in a binary fashion. Given a focused tree  f , forward navigation  f (cid:4)1(cid:5)
and  f (cid:4)2(cid:5) respectively  change  the  focus  to  the  leftmost  child  and  to  the  next  right  sibling  of  the  current  focused  node. 
respectively change the focus to the parent and the preceding left sibling of 
Conversely backward navigation  f
(cid:2)
the current node. In particular,  f
is deﬁned if and only if the current node is the leftmost node, i.e., it has no left sibling. 
Deﬁnition 2.1 formally deﬁnes the navigation of focused trees.

(cid:3)
(cid:2)
¯1
(cid:3)
¯1

and  f

(cid:3)
¯2

(cid:2)

Deﬁnition 2.1 (Navigation of focused trees).

(t, (tll; c[σ ]; t

(σ [t :: tl], c) (cid:4)1(cid:5)
(cid:3) :: tlr)) (cid:4)2(cid:5)
(cid:3)
¯1
¯2

(t, ((cid:5); c[σ ]; tl))
(cid:3), (t :: tll; c[σ ]; tlr))

(t

(cid:2)

(cid:3)

(cid:2)

(cid:3), (t :: tll; c[σ ]; tlr))

def= (t, ((cid:5); c[σ ]; tl))
def= (t
def= (σ [t :: tl], c)
def= (t, (tll; c[σ ]; t

(cid:3) :: tlr))

If the focused tree does not have the required shape, these operations are undeﬁned.

Example 2.2. Consider the example XML tree in Fig. 1. If the node labeled  B is a focus, then the focused tree  f B and its 
navigation is deﬁned as follows. Below, for simplicity, for each leaf node, we write only its label. For instance, we write  E
instead of  E[(cid:5)].

f B = (B[E :: F :: G :: (cid:5)], ((cid:5); Top[ A]; C :: D[E :: F :: (cid:5)] :: (cid:5)))

f B (cid:4)1(cid:5) = (E, ((cid:5); c[B]; F :: G :: (cid:5))) where c = ((cid:5); Top[ A]; C :: D[E :: F :: (cid:5)] :: (cid:5))

f C = f B (cid:4)2(cid:5) = (C, (B[E :: F :: G :: (cid:5)] :: (cid:5); Top[ A]; D[E :: F :: (cid:5)] :: (cid:5)))

(cid:3)
(cid:3)

(cid:2)
¯1
(cid:2)
¯2

f B
f B

= ( A[B[E :: F :: G :: (cid:5)] :: C :: D[E :: F :: (cid:5)] :: (cid:5)], Top)
= undeﬁned

f D = f C (cid:4)2(cid:5) = f B (cid:4)2(cid:5) (cid:4)2(cid:5) = (D[E :: F :: (cid:5)], (C :: B[E :: F :: G :: (cid:5)] :: (cid:5); Top[ A]; (cid:5)))

Note that the focused trees  f C and  f D focusing on the nodes labeled C and  D, respectively, can be obtained by navigating 
f B in a forward direction.

2.2.  XQuery core

Fig. 2 deﬁnes the abstract syntax of a simpliﬁed navigational fragment of the XQuery core. In the XQuery core, which 
is  deﬁned  in  the  XQuery  1.0  and  XPath  2.0  Formal  Semantics [3],  navigational  (i.e.,  structural)  expressions  are  well  sepa-
rated from data value expressions (e.g., ordering and node identity testing) which make typechecking undecidable (see for 

72

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

Expressions

e

Variables
Axis names

$var
axis

let $v := e return e | if nempty(e) then e else e
$v/axis::n | $var

::= (cid:5) | <σ >{e}</σ > : u | e, e | for $v in e return e
|
|
::= $v | $v | $doc
::= self | child | desc | fsibl | parent | anc | psibl

Name tests

Values

n ::= σ | ∗
s

::= (cid:5) | f :: s

Fig. 2. Syntax of a navigational fragment of the XQuery core.

instance [23]). Since the full language of XQuery can be compiled into the XQuery core [3] and we are mainly interested in 
typechecking, we consider only navigational expressions in this paper.

First of all, we assume that an XML element constructor <σ >{e}</σ > is always annotated with a type u (the precise 
deﬁnition  of  u is  given  in  Section 3.1).  In  other  words,  <σ >{e}</σ > : u in  Fig. 2 can  be  considered  as  a  combination 
of  XQuery’s  untyped  element  constructor  and validate expressions.  In  XQuery,  the  result  of  a  construction  expression 
<σ >{e}</σ > is considered untyped (both statically and dynamically) unless it is validated using a validate expression. 
The validate expression checks if the constructed XML element conforms to the expected type at runtime, and if not, it 
raises a dynamic type error. Our element constructor <σ >{e}</σ > : u differs from XQuery’s validate expression in that 
its typechecking is done not dynamically but statically. For XQuery’s untyped element constructors, i.e., without validate, 
we simply assume that they are annotated with AnyElt which is the type of all XML elements.

As for other expressions, $doc is a special variable for reading the input document, and (cid:5) denotes an empty sequence, 
i.e., e, (cid:5) = (cid:5), e = e. In a for-loop expression, an item variable $v is bound to a single element node (or a single “item” in the 
XQuery terminology), whereas in a let-binding expression, a sequence variable $v is bound to a possibly empty sequence of 
nodes. In a conditional expression if nempty(e) then e1 else e2, if the condition e evaluates to a non-empty sequence 
of nodes, then e1 is evaluated; otherwise, e2 is evaluated. An axis expression $v/axis::n extracts the nodes that are reachable 
from the current node $v through axis and that also satisfy the name test n. Path navigation can start only from an item 
variable.  A  name  test  n is  either  a  node  label σ or  a  wildcard  pattern  ∗ that  matches  any  label.  For  path  navigation,  we 
consider only self, child, desc, fsibl, parent, anc, and psibl axes because other axes can easily be encoded. (We 
use abbreviated names instead of the full name of the XPath axes.) We use the following syntactic sugar:

$v/desc-or-self::n ≡ $v/self::n, $v/desc::n

An XQuery expression e evaluates to a value s, which is deﬁned as a sequence of focused trees. This deﬁnition of values 
allows us to deﬁne the semantics in a compositional way. We write [ f 1, . . . , fn] for  f 1 :: . . . :: fn :: (cid:5) and s1, s2 for a sequence 
concatenation of s1 and s2. In XQuery, all values are sequences and a single item (or tree) is considered a singleton sequence 
that contains only that item (or tree). Hence in the rest of the paper we use  f and [ f ] interchangeably.

2.3.  Semantics

Fig. 3 shows the semantics of the XQuery core, which is deﬁned using the following denotation function:

(cid:2)_(cid:3) : Expression → Substitution → Value

where a substitution η is a mapping from variables to values.

While  most  of  the  rules  are  straightforward  and  compositional,  we  took  special  care  for  an  element  constructor 
(<σ >{e}</σ > : u). First, suppose that the inner expression  e evaluates to a sequence  [ f 1, . . . , fn] of focused trees, where 
f i = (ti, ci). Then, we embed them into a new tree structure, namely σ [ f 1 :: . . . :: fn :: (cid:5)], whose context is Top. When nav-
igating it, we need to update the context with respect to the new tree node. Therefore, we remove the old context from 
each focused tree  f i and obtain  f = (σ [t1 :: . . . :: tn :: (cid:5)], Top).

To evaluate a for-loop expression for $v in e1 return e2 with substitution η, we ﬁrst evaluate (cid:2)e1(cid:3)η. If the result is 
not an empty sequence, say [ f 1, . . . , fn], then for each focused tree  f i , we evaluate the for-loop body e2 with an extended 
substitution η, $v (cid:8)→ f i . Finally, we concatenate the results of evaluating (cid:2)e2(cid:3)η,$v (cid:8)→ f i for i = 1, . . . , n in order. In contrast, if 
(cid:2)e1(cid:3)η evaluates to an empty sequence, then the for-loop expression also evaluates to an empty sequence.

To evaluate an axis expression  $v/axis::n, we analyze the shape of the focused tree bound to the for-loop variable  $v. 
The  deﬁnition  of  (cid:2) f /axis::n(cid:3) follows  from  the  intuition  behind  the  axis  axis.  For  example,  (cid:2) f /self::n(cid:3) evaluates  to  a 
singleton  sequence  [ f ] if  and  only  if  the  label  of  f matches  the  name  test  n.  The  semantics  of  child is  deﬁned  using 
self and fsibl applied to the left-most child node. Note that  f
are never both deﬁned for the same  f and 
thus the deﬁnitions for the semantics of parent are mutually exclusive (the same is true for anc). (cid:2) f /fsibl::n(cid:3) and 
(cid:2) f /psibl::n(cid:3) recursively  apply  fsibl and  psibl to  the  following  and  preceding  siblings  of  f ,  respectively,  if  there 
exists such a node. (cid:2) f /desc::n(cid:3) applies self and desc recursively to each child node of  f and concatenates the results 
into a sequence.

and  f

(cid:2)
¯2

¯1

(cid:2)

(cid:3)

(cid:3)

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

73

(cid:2)(cid:5)(cid:3)η = (cid:5)

(cid:2)<σ >{e}</σ > : u(cid:3)η = (σ [t1 :: . . . :: tn :: (cid:5)], Top)
(cid:2)e1, e2(cid:3)η = (cid:2)e1(cid:3)η, (cid:2)e2(cid:3)η
(cid:2)$var(cid:3)η = η($var)
(cid:2)for $v in e1 return e2(cid:3)η = (cid:7) f1,..., fn
(cid:2)for $v in e1 return e2(cid:3)η = (cid:5)
(cid:2)let $v := e1 return e2(cid:3)η = (cid:2)e2(cid:3)η,$v (cid:8)→ (cid:2)e1(cid:3)η

(cid:2)e2(cid:3)η,$v (cid:8)→ f i

(cid:2)if nempty(e) then e1 else e2(cid:3)η = (cid:2)e1(cid:3)η
(cid:2)if nempty(e) then e1 else e2(cid:3)η = (cid:2)e2(cid:3)η

(cid:2)$v/axis::n(cid:3)η = (cid:2)η($v)/axis::n(cid:3)

(cid:2) f /self::n(cid:3) = [ f ]
(cid:2) f /self::n(cid:3) = (cid:5)
(cid:2) f /child::n(cid:3) = (cid:2) f
(cid:2) f /child::n(cid:3) = (cid:5)
(cid:2) f /parent::n(cid:3) = (cid:2) f
(cid:2) f /parent::n(cid:3) = (cid:2) f
(cid:2) f /parent::n(cid:3) = (cid:5)
(cid:2) f /fsibl::n(cid:3) = (cid:2) f
(cid:2) f /fsibl::n(cid:3) = (cid:5)
(cid:2) f /psibl::n(cid:3) = (cid:2) f
(cid:2) f /psibl::n(cid:3) = (cid:5)
(cid:2) f /anc::n(cid:3) = (cid:2) f
(cid:2) f /anc::n(cid:3) = (cid:2) f
(cid:2) f /anc::n(cid:3) = (cid:5)
(cid:2) f /desc::n(cid:3) = (cid:7) f1,..., fm
(cid:2) f /desc::n(cid:3) = (cid:5)

(cid:3)/self::n(cid:3), (cid:2) f

(cid:3)/self::n(cid:3)
(cid:3)/parent::n(cid:3)

(cid:3)/self::n(cid:3), (cid:2) f

(cid:3)/fsibl::n(cid:3)

(cid:3)/fsibl::n(cid:3)

(cid:3)/psibl::n(cid:3), (cid:2) f

(cid:3)/self::n(cid:3)

(cid:3)/anc::n(cid:3), (cid:2) f
(cid:3)/anc::n(cid:3)

(cid:3)/self::n(cid:3)

(cid:2) f i /self::n(cid:3), (cid:2) f i /desc::n(cid:3)

if (cid:2)e(cid:3)η = [(t1, c1), . . . , (tn, cn)]

if (cid:2)e1(cid:3)η = [ f 1, . . . , fn]
if (cid:2)e1(cid:3)η = (cid:5)

if (cid:2)e(cid:3)η = f , s
if (cid:2)e(cid:3)η = (cid:5)

if name( f ) = n or n = ∗
if name( f ) (cid:9)= n and n (cid:9)= ∗
(cid:3) = f (cid:4)1(cid:5)
if f
if f = (σ [(cid:5)], c)
(cid:3)
(cid:2)
¯1
(cid:3) = f
if f
(cid:3)
(cid:2)
¯2
(cid:3) = f
if f
if f = (t, Top)
(cid:3) = f (cid:4)2(cid:5)
if f
if f = (t, (tl; σ [c]; (cid:5)))
(cid:3)
(cid:2)
¯2
if f
if f = (t, ((cid:5); σ [c]; tl))
(cid:3)
(cid:2)
¯1
(cid:3) = f
if f
(cid:3)
(cid:2)
¯2
(cid:3) = f
if f
if f = (t, Top)
if (cid:2) f /child::∗(cid:3) = [ f 1, . . . , fm]
if (cid:2) f /child::∗(cid:3) = (cid:5)

(cid:3) = f

Auxiliary deﬁnitions: name((σ [tl], c)) = σ

Fig. 3. Semantics of the XQuery core.

3.  Type language

Our type language is based on regular tree types [2] and a tree logic, which is a sub-logic of the alternation free modal 
μ-calculus with converse [20]. In this section, we ﬁrst brieﬂy introduce regular tree types and the tree logic, together with 
their  semantics  in  terms  of  sets  of  focused  trees.  Then  we  introduce  our  type  language,  regular  tree  types  enriched  with 
tree logic formulas [19].

3.1.  Regular tree types

We use a slight variant of XDuce’s regular expression type language [24] to type sequences of XML trees (or elements), 
which  is  expressive  enough  to  capture  standard  XML  types  such  as  DTD  and  XML  Schema [25].  Formally  we  deﬁne  our 
regular tree types as follows.

Deﬁnition 3.1 (Regular tree types).

Unit types
Name tests
Sequence types

u ::= element n {τ }
n ::= σ | ∗
τ

::= u | () | τ , τ | (τ | τ ) | τ ∗ | x

A  sequence  type  τ is  a  regular  expression  over  unit  types,  where  a  unit  type  u,  or  a  “prime  type”  in  the  XQuery 
terminology, corresponds to an XML element. (In general, u may also include primitive types such as Int or String, but for 
simplicity, we consider only element types.) As usual, we use the following abbreviations: τ + ≡ τ , τ ∗
and τ ? ≡ () | τ . (We 
use ≡ both for syntactic equivalence and syntactic sugar.)

While the Kleene star ∗

operator supports horizontal recursion, we use a type environment and type variables to support 
vertical  recursion.  A  type  environment  E is  a  ﬁnite  mapping  from  type  variables  x to  types  τ .  For  example,  we  assume 
∗}, which is the type of 
that every  E that we consider in this paper maps a type variable AnyElt into element ∗ {AnyElt
all elements. The variables bound in  E may be deﬁned in a mutually recursive way, but recursion must be guarded by an 
element type to ensure well-formedness of types, i.e., contractiveness of recursive types [26]. We also assume that regular 
expressions  deﬁned  by  E are  composed  of  mutually  exclusive  unit  types  and  1-unambiguous [27],  which  is  standard  and 
comes from XML Schema.

As usual, the semantics of regular tree types is deﬁned as sets of forests, i.e., sets of sequences of trees, and the subtyping 

relation is semantically deﬁned as the set inclusion relation.

Deﬁnition 3.2. Given a type environment  E, the semantics of types is deﬁned by the smallest function (cid:2) (cid:3)E that satisﬁes 
the following set of equations:

74

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

(cid:2)x(cid:3)E = (cid:2)E(x)(cid:3)E

(cid:2)()(cid:3)E = {(cid:5)}
(cid:4)

(cid:2)τ | τ (cid:3)(cid:3)E = (cid:2)τ (cid:3)E ∪ (cid:2)τ (cid:3)(cid:3)E
(cid:2)τ n(cid:3)E
(cid:2)τ , τ (cid:3)(cid:3)E = {[t1, . . . , tn, t

(cid:2)τ ∗(cid:3)E =

n∈N

(cid:2)τ 0(cid:3)E = {(cid:5)}
(cid:2)τ n+1(cid:3)E = (cid:2)τ , τ n(cid:3)E
(cid:2)element σ {τ }(cid:3)E = {[σ [tl]] | tl ∈ (cid:2)τ (cid:3)E }
(cid:2)element ∗ {τ }(cid:3)E = {[σ [tl]] | σ ∈ (cid:3) and tl ∈ (cid:2)τ (cid:3)E }

(cid:3)
1, . . . , t

(cid:3)
m

] | [t1, . . . , tn] ∈ (cid:2)τ (cid:3)E and [t

(cid:3)
1, . . . , t

(cid:3)
m

] ∈ (cid:2)τ (cid:3)(cid:3)E }

Then, a type τ1 is a subtype of τ2, denoted by τ1 <: τ2, if and only if (cid:2)τ1(cid:3)E ⊆ (cid:2)τ2(cid:3)E .

In  the  following,  we  assume  that  E is  always  well-formed  and  contains  bindings  for  all  variable  references  appearing 
in  the  types,  and  write  (cid:2)τ (cid:3) as  a  shorthand  for  (cid:2)τ (cid:3)E .  We  also  assume  that  references  x are  implicitly  replaced  with  their 
bindings at top level, so that a type τ is really a regular expression of unit types.

The  regular  tree  type  language  we  gave  above  is  standard  and  used  to  deﬁne  the  static  type  system  in  the  XQuery 
standard and its various improvements in the literature. In such a type system, an XQuery expression is associated with a 
regular tree type, and the notion of a value (i.e., a sequence of tree nodes) matching a type can be deﬁned as follows when 
nodes are represented as focused trees.

Deﬁnition 3.3. The focused-tree interpretation (cid:2)τ (cid:3)↑ of a type τ is deﬁned as the set:

{[(t1, c1) . . . (tn, cn)] | [t1 . . . tn] ∈ (cid:2)τ (cid:3)}

A value s is said to match a type τ if s ∈ (cid:2)τ (cid:3)↑.

Example 3.4. Consider the example XML tree in Fig. 1 again. The focused trees  f B ,  f C , and  f D focusing on the nodes labeled 
B, C , and  D, respectively, deﬁned in Example 2.2, match the following regular tree types τB , τC , and τD .

τB = element B {element E {()}, element F {()}, element G {()}}
τC = element C {()}
τD = element D {element E {()}, element F {()}}

They also match a more general type such as AnyElt or τNode which is deﬁned as follows:

τNode = element B {x
x = (element E {x

∗}
∗} | element C {()} | element D {x
∗} | ()
∗}, element F {()}) | element G {x

Note however that we cannot describe the context information using Deﬁnition 3.1.

(cid:3)

(cid:2)

,  f

(cid:2)
¯1

(cid:3)
¯2

As shown in the above deﬁnition and example, regular tree types denote sequences of trees, and their interpretation is 
lifted to sequences of focused trees by simply ignoring the context part. In other words, using regular tree types, the type 
system cannot properly address expressions that analyze the shape of the context of a given focused tree: given  f of type 
, and  f (cid:4)2(cid:5) because when  f = (t, c), τ only contains information about 
τ , we cannot deduce a precise type for  f
the subtree t, but those expressions require information about the context c.

More speciﬁcally, consider an expression for $v in e return $v/psibl::∗. Let us consider forward type inference; 
reasoning  with  backward  type  inference  is  similar.  Suppose  that  e is  of  type  τNode and  reduces  to  f D .  Then,  we  need  to 
compute  f D /psibl::∗,  which  reduces  to  [ f B , f C ].  The  type  of  this  result,  however,  should  be  determined  by  analyzing 
τNode only, without evaluating the given expression. Since τNode does not contain any useful information about its preceding 
siblings,  we  cannot  deduce  a  meaningful  type  for  f D /psibl::∗,  and  thus  for  the  entire  for-loop  expression.  Therefore, 
every type system for XQuery built solely on the type language given in Deﬁnition 3.1 simply gives to this expression the 
most general type AnyElt
. To describe contexts and type navigational expressions precisely, we propose to use a tree logic 
in the next section.

∗

3.2.  A tree logic

To describe sets, i.e., types, of focused trees rather than just sets of trees, we use a variant of the logic language deﬁned 
in [20]. The tree logic, deﬁned below, is expressive enough to support all XQuery types, and the satisﬁability problem for a 
logical formula of size n can eﬃciently be decided with an optimal 2

O(n) worst-case time complexity bound [28].

Deﬁnition 3.5 (Logic formulas).

ϕ, ψ ::= (cid:14) | σ | ¬σ | α | ¬α | ϕ ∨ ψ | ϕ ∧ ψ | (cid:4)a(cid:5) ϕ | ¬ (cid:4)a(cid:5) (cid:14) | X | μ(Xi = ϕi)i∈I in ψ

a ∈ {1, 2, ¯1, ¯2} are  called  programs,  corresponding  to  the  four  directions  where  trees  can  be  navigated.  A  pro-
gram  is  used  in  an  existential  formula  (cid:4)a(cid:5) ϕ,  denoting  the  existence  of  a  subtree  at  the  direction  of  a that  satis-
ﬁes  the  subformula  ϕ.  Other  formulas  include  the  truth  predicate  (cid:14),  atomic  propositions  σ (denoting  the  label  of 

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

75

the  focused  tree),  node  identiﬁers  (a.k.a.  nominals)  α,  disjunction  and  conjunction  of  formulas,  and  least  n-ary  ﬁxed 
points.  In  particular,  an  n-ary  ﬁxed  point  μ( Xi = ϕi)i∈{1,...,n} in ψ represents  possibly  mutually  recursive  deﬁnitions 
let rec X1 = ϕ1 and X2 = ϕ2 and · · · and Xn = ϕn in ψ (written  in  OCaml  syntax)  where  ϕi and  ψ may 
contain  X j for  any  i, j ∈ {1, · · · , n}.  We  also  use  the  following  abbreviations:  ⊥ to  mean  ¬(cid:14),  [a] ϕ for  ¬ (cid:4)a(cid:5) (cid:14) ∨ (cid:4)a(cid:5) ϕ, 
and μ X.ϕ for μ( X = ϕ) in ϕ. The universal modality  [a] ϕ encodes that a subtree at the direction of a does not exist, or 
else it satisﬁes ϕ. In this work, we consider only cycle-free formulas (for example, μ( X = (cid:4)1(cid:5) (ϕ ∨
X)) in X is not cycle 
free) and thus the logic is closed under negation [28].

(cid:3)
¯1

(cid:2)

The semantics of a logical formula is deﬁned as the set of focused trees such that the formula is satisﬁed at the current 

node. We use the following interpretation function:

(cid:4)(cid:4)−(cid:5)(cid:5) : Formula → Substitution → FocusedTreeSet

where  a  substitution  V is  a  ﬁnite  map  from  recursion  variables  to  sets  of  focused  trees.  In  the  deﬁnition  below,  we  use 
F to denote the set of all focused trees and name( f ) to denote the label at the current node of  f . Moreover, to support 
nominals, we extend the syntax of focused trees so as to annotate a focused tree  f with a set  L of nominals. We write  f L
to  mean  (t L, c) = (σ L[tl], c) when  f = (t, c) and  t = σ [tl].  In  this  work,  nominals  are  purely  a  semantic  notion  and  used 
only for typing descendants (see Section 4.2.6). Hence, for simplicity, we omit  L whenever it is irrelevant to the discussion 
at hand, which is almost always the case.

Deﬁnition 3.6 (Interpretation of formulas).

(cid:4)(cid:4)(cid:14)(cid:5)(cid:5)V
(cid:4)(cid:4)σ (cid:5)(cid:5)V
(cid:4)(cid:4)¬σ (cid:5)(cid:5)V
(cid:4)(cid:4)α(cid:5)(cid:5)V
(cid:4)(cid:4)¬α(cid:5)(cid:5)V

def= F
def= { f | name( f ) = σ }
def= { f | name( f ) (cid:9)= σ }
def=
f L | α ∈ L
def=
f L | α /∈ L

(cid:5)

(cid:5)

(cid:6)

(cid:6)

(cid:4)(cid:4)X(cid:5)(cid:5)V
(cid:4)(cid:4)(cid:4)a(cid:5) ϕ(cid:5)(cid:5)V
(cid:4)(cid:4)¬ (cid:4)a(cid:5) (cid:14)(cid:5)(cid:5)V
(cid:4)(cid:4)ϕ ∨ ψ(cid:5)(cid:5)V
(cid:4)(cid:4)ϕ ∧ ψ(cid:5)(cid:5)V

(cid:6)

| f ∈ (cid:4)(cid:4)ϕ(cid:5)(cid:5)V

def= V (X)
(cid:3)
(cid:2)
(cid:5)
def=
a
f
def= { f | f (cid:4)a(cid:5) undeﬁned}
def= (cid:4)(cid:4)ϕ(cid:5)(cid:5)V ∪ (cid:4)(cid:4)ψ(cid:5)(cid:5)V
def= (cid:4)(cid:4)ϕ(cid:5)(cid:5)V ∩ (cid:4)(cid:4)ψ(cid:5)(cid:5)V

(cid:4)(cid:4)μ(Xi = ϕi)i∈I in ψ(cid:5)(cid:5)V
(cid:7)

let S = {(T i)i∈I ∈ P(F)I | ∀ j ∈ I, (cid:4)(cid:4)ϕ j(cid:5)(cid:5)
let ∀i ∈ I, U i =

def=

V [T i / Xi ] ⊆ T j} in

where V [T i/ Xi](X) def=

(cid:8)

(T j )∈S T i in (cid:4)(cid:4)ψ(cid:5)(cid:5)
V (X)
T i

V [U i / Xi ]
if X /∈ { Xi}i∈I
if X = Xi

In  the  rest  of  the  paper,  we  consider  only  closed  formulas  and  write  (cid:4) (cid:4)ψ(cid:5) (cid:5) for  (cid:4) (cid:4)ψ(cid:5) (cid:5)∅.  We  say  that  a  focused  tree  f

matches a formula ψ if  f ∈ (cid:4) (cid:4)ψ(cid:5) (cid:5).

Example 3.7. Consider the focused trees  f B ,  f C , and  f D given in Example 2.2.  f D matches a formula ψD where the under-
lined part describes the subtree rooted at  D and the other part describes its context.
(cid:2)
¯2

(B ∧ (cid:4)1(cid:5) (E ∧ (cid:4)2(cid:5) (F ∧ (cid:4)2(cid:5) G)) ∧

ψD = D ∧ (cid:4)1(cid:5) (E ∧ (cid:4)2(cid:5) F ) ∧

(C ∧

(cid:2)
¯1

(cid:2)
¯2

A))

(cid:3)

(cid:3)

(cid:3)

From ψD , we can now infer formulas ψC and ψB for  f C and  f B which are the preceding siblings of  f D .

(cid:3)
¯1
(B ∧ (cid:4)1(cid:5) (E ∧ (cid:4)2(cid:5) (F ∧ (cid:4)2(cid:5) G)) ∧
ψC = (cid:4)2(cid:5) ψD
A)
(cid:3)
(cid:2)
¯1
ψB = (cid:4)2(cid:5) (cid:4)2(cid:5) ψD = (cid:4)2(cid:5) ((cid:4)2(cid:5) (D ∧ (cid:4)1(cid:5) (E ∧ (cid:4)2(cid:5) F )) ∧ C) ∧ B ∧ (cid:4)1(cid:5) (E ∧ (cid:4)2(cid:5) (F ∧ (cid:4)2(cid:5) G)) ∧
A

= (cid:4)2(cid:5) (D ∧ (cid:4)1(cid:5) (E ∧ (cid:4)2(cid:5) F )) ∧ C ∧

(cid:2)
¯2

(cid:2)

(cid:3)

3.3.  Formula-enriched sequence types

In order to type sequences of focused trees, which are values of our XQuery core, we simply enrich the type language in 
Deﬁnition 3.1 by associating a formula to each unit type. The enriched types, which we call formula types, are thus regular 
expressions of pairs of unit types and formulas, as deﬁned below.

Deﬁnition 3.8 (Formula types).

ρ ::= (ϕ, u) | () | ρ, ρ | (ρ | ρ) | ρ+

A formula type (ϕ, u) describes a focused tree (t, c) where u describes only t while ϕ may describe both t and c. The 

interpretation of a pair (ϕ, u) is deﬁned as a set of singleton sequences of focused trees which match both ϕ and u:

76

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

(cid:2)(ϕ, u)(cid:3) = {[(t, c)] | t ∈ (cid:2)u(cid:3) and (t, c) ∈ (cid:4)(cid:4)ϕ(cid:5)(cid:5)}

From this, the semantics of formula types in terms of sets of sequences of focused trees is deﬁned in the obvious manner. 
Then, the subtyping relation ρ1 <: ρ2 is semantically deﬁned as the set inclusion relation (cid:2)ρ1(cid:3) ⊆ (cid:2)ρ2(cid:3).

Example 3.9. Consider a for-loop expression for $v in f D return $v/psibl::∗. If the type of  f D is given as (ψD , τD ), 
then  the  type  of  the  whole  expression  may  be  deduced  as  (μ X. (cid:4)2(cid:5) (ψD ∨ X), AnyElt)∗
.  The  type  states  that  the  for-loop 
expression will reduce to a possibly empty sequence of focused trees, each of which is of type AnyElt and has a following 
sibling that satisﬁes ψD . As discussed in Section 3.1, we cannot deduce any meaningful information in the unit type part, 
and thus simply use AnyElt.

The rationale behind the use of formula types is that it provides more ﬂexibility. From the above example, one might 
think  that  regular  expressions  of  formulas  would  be  suﬃcient,  which  is  true  for  backward  type  inference  for  XPath  axes. 
However,  sometimes,  we  may  want  to  ignore  context  information,  for  example,  to  construct  a  new  XML  tree  node  using 
existing  focused  trees.  In  this  case,  we  need  to  eliminate  the  context  information  from  the  formula  matched  with  each 
focused tree. Unfortunately, it is nontrivial to eliminate only context information in the presence of recursive formulas. Thus, 
by combining formulas with unit types, we can make use of the usual unit type part to eliminate the context information, 
ignoring  the  formula  part,  if  necessary.  Moreover,  although  we  do  not  investigate  in  this  paper,  by  using  the  same  type 
language as in [19], it would be easier to integrate our backward type inference with their forward type inference.

In Section 2.2, we assumed that every XML element constructor was annotated not with a formula type (ϕ, u) but with 
a unit type  u. The reason is that an element constructor always reduces to a single tree node whose context is  Top, and 
thus there is no need to use a formula type for the annotation. We simply consider u to be ((cid:14), u).

4.  Inference for XPath axes

In this section, we present a sound and complete backward type inference system for XPath axes, and based on this we 
will develop a backward type inference system for the XQuery core in Section 5. In backward type inference, we are given 
an expression e and an output type ρo for a sequence of focused trees that e may produce. Then we infer an input type ρi
such that for any focused tree  f , the following conditions hold.

• (Soundness) If  f
• (Completeness) If e( f ) produces a sequence of nodes of type ρo , then  f

is of type ρi , then e( f ) produces a sequence of nodes of type ρo .

is of type ρi .

When  considering  XPath  axes,  from  the  soundness  perspective,  we  infer  a  type  describing  a  set  of  input  trees  such  that 
when applied to an axis, each input tree produces a sequence of nodes that has the output type ρo. Moreover, since XPath 
axes  can  only  be  applied  to  a  for-loop  variable  in  our  XQuery  core,  from  the  completeness  perspective,  we  infer  from  a 
given axis axis and an output type ρ, a single formula type (ϕ, u) (possibly their union) that the input tree, i.e., the for-loop 
variable, must satisfy. In particular, we design the inference rules in such a way that the following invariant holds.

Invariant 4.1. In our backward type inference system for XPath axes, if (ϕ1, u1) | . . . | (ϕn, un) is an inferred input type, a subtype 
relation ϕi <: ui holds for all i’s, that is, for any t and c, if (t, c) ∈ (cid:4) (cid:4)ϕi(cid:5) (cid:5), then [t] ∈ (cid:2)ui(cid:3), or equivalently, (cid:4) (cid:4)ϕi(cid:5) (cid:5) ⊆ (cid:2)ui(cid:3)↑ by identifying 
a focused tree  f with a singleton sequence [ f ].

The implication of this invariant is that for type inference for XPath axes, we can safely ignore the unit type part because 
it is always less precise than the formula part. Still, the unit type part is useful when typing XQuery expressions such as 
element constructors and thus we infer a useful unit type for XPath axes whenever possible.

Formally, the subtype relation ϕ <: u between formula ϕ and unit type u can be checked in two steps. First, we translate 
u into a downward-only formula which is true at any tree node matching this unit type, regardless of its context. In other 
words, we translate  u into a formula which holds at any node of an XML tree if and only if the tree rooted at that node 
satisﬁes u. Technically, this translation can be done using an auxiliary function form(u), which is deﬁned and proved correct 
in [19]. (For its precise deﬁnition, we refer the reader to Figure 10 in [19].) Next, we test the satisﬁability of the formula 
ϕ ∧ ¬form(u), for example, using the decision procedure presented in [28]; in fact, (cid:4) (cid:4)ϕ ∧ ¬form(u)(cid:5) (cid:5) = ∅ if and only if any 
focused tree matching ϕ also satisﬁes u, i.e., (cid:4) (cid:4)ϕ(cid:5) (cid:5) ⊆ (cid:2)u(cid:3)↑.

Below we present inference rules using a judgment of the form ρi ← axis::n, ρo where input type ρi is always of the 

form (ϕ1, u1) | . . . | (ϕn, un). We ﬁrst look into the inference rules for self and parent.

4.1.  Inference rules for self and parent

4.1.1.  Self

Fig. 4 shows  inference  rules  for self.  Basically  self::n returns  a  singleton  sequence  containing  the  input  tree  if  it 
satisﬁes  the  name  test  n;  otherwise  it  returns  an  empty  sequence.  Conversely,  if  the  output  type  is  (),  it  means  that 

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

77

Self-Empty

Self-Formula

(¬k(n), AnyElt) ← self::n, ()

(ϕ ∧ k(n) ∧ form(u), u) ← self::n, (ϕ, u)

nullable(ρ j )

ρ(cid:3) ← self::n, ρi

ρ(cid:3) ← self::n, (ρ1, ρ2)

(i, j = 1, 2, i (cid:9)= j)

Self-Seq2
nullable(ρ1)
ρ(cid:3)

1

| ρ(cid:3)

2

ρ(cid:3)

i

← self::n, ρi

Self-Seq1
¬nullable(ρi )

nullable(ρ2)

← self::n, (ρ1, ρ2)

Self-Plus
ρ(cid:3) ← self::n, ρ
ρ(cid:3) ← self::n, ρ+

(i = 1, 2)

Parent

Self-Or
ρ(cid:3)
| ρ(cid:3)

ρ(cid:3)

i

1

2

← self::n, ρi
← self::n, (ρ1 | ρ2)

(i = 1, 2)

ρ(cid:3) ← self::n, ρ

child-type(ρ(cid:3)

) ← parent::n, ρ

Auxiliary deﬁnitions:

k(∗) = (cid:14)

k(σ ) = σ

nullable(()) = true
nullable((ϕ, u)) = false

nullable(ρ+) = nullable(ρ)

Prime(()) = ()
Prime(u) = u

Prime(τ +) = Prime(τ )

distrib(χ , ()) = ()

distrib(χ , u) = (χ ∧ form(u), u)

distrib(χ , τ +) = distrib(χ , τ )+

nullable(ρ1, ρ2) = nullable(ρ1) ∧ nullable(ρ2)
nullable(ρ1 | ρ2) = nullable(ρ1) ∨ nullable(ρ2)

Prime(τ1, τ2) = Prime(τ1) | Prime(τ2)
Prime(τ1 | τ2) = Prime(τ1) | Prime(τ2)

distrib(χ , (τ1, τ2)) = (distrib(χ , τ1), distrib(χ , τ2))
distrib(χ , τ1 | τ2) = (distrib(χ , τ1) | distrib(χ , τ2))

child-type(ρ1 | ρ2) = child-type(ρ1) | child-type(ρ2)
child-type((¬k(n), AnyElt)) = (has-parent(¬k(n)) ∨ ϕroot, AnyElt)

child-type((ϕ, element n {τ })) = distrib(has-parent(ϕ), Prime(τ ))

(cid:2)
has-parent(χ ) = μZ .
(cid:2)
(cid:3)
¯1

ϕroot = ¬

(cid:3)

¯1
χ ∨
(cid:14) ∧ ¬

(cid:2)
(cid:3)
¯2
(cid:3)
(cid:2)
¯2

Z
(cid:14) ∧ ¬ (cid:4)2(cid:5) (cid:14)

Fig. 4. Inference rules for self and parent.

the  input  tree  fails  the  name  test  and  thus  has  type  ¬k(n) (rule Self-Empty).  Here  k(n) is  the  translation  of  n into  a 
corresponding formula, i.e., k(∗) = (cid:14) and k(σ ) = σ .

If the output type is a single formula type (ϕ, u), it means that the input tree has that type: more precisely, the input 
tree should satisfy both ϕ and k(n), and at the same time should have type u (rule Self-Formula). All these constraints are 
encoded in the formula ϕ ∧ k(n) ∧ form(u) where we translate the unit type u into a formula using the function form(u). 
In the rule Self-Formula, since ϕ ∧ k(n) ∧ form(u) <: u holds, i.e., (cid:4) (cid:4)ϕ ∧ k(n) ∧ form(u) ∧ ¬form(u)(cid:5) (cid:5) = ∅, Invariant 4.1 holds. 
In addition, when  u = element σ {τ }, the inferred input formula is unsatisﬁable if n = σ (cid:3)
. In other words, 
there exist no tree nodes that produce a tree of type element σ {τ } when applied to self::σ (cid:3)
, because no tree nodes 
can have different labels at the same time.

and σ (cid:9)= σ (cid:3)

If the output type is a sequence type (ρ1, ρ2), at least one type needs to be nullable (i.e., the interpretation of the type 
includes an empty sequence (cid:5)) since self::n returns at most one tree as output. The type of the input tree is then the 
type inferred from the non-nullable part of the output type (rule Self-Seq1). If both ρ1 and ρ2 are nullable, we take the 
union of the input types inferred from them (rule Self-Seq2). When the output type is a union type, the input tree may 
also have a union type of the two, each of which is inferred from one summand of the output type (rule Self-Or). Lastly, 
if the output type is a plus type ρ+
, the input type should be inferred from ρ since self::n returns at most one node 
(rule Self-Plus).

Proof of Invariant 4.1 for self. By induction on a derivation of ρ(cid:3) ← self::n, ρ. (cid:2)

4.1.2.  Parent

The intuition behind type inference for parent is simple. Given an output type ρ, it is the type of the parent of the 
using the inference rules for self with ρ, then the parent node is also of type 
. Therefore, for the input node, we extract a child type 

. In other words, the input node is a child of the node of type ρ(cid:3)

input context node. Moreover, if we infer ρ(cid:3)
ρ(cid:3)
from ρ(cid:3)

using an auxiliary function child-type().

To illustrate, assume that the output type ρ is given as ( A, τ A)+

where τ A = element A {τB , τC , τD } and τB , τC , and 
τD are deﬁned in Example 3.4. Note that ρ can be used as a type for the focused tree  f A rooted at the node labeled  A in 
Fig. 1. By applying the inference rules for self::n, we obtain ρ(cid:3) = (ϕ A, τ A) where ϕ A = A ∧ k(n) ∧ form(τ A). Note that ρ(cid:3)
is also a type for  f A . Suppose that given an input node  f ,  f /parent::n reduces to  f A . This means that  f must be one 

78

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

(cid:3)

(cid:3)

¯1

of  f B ,  f C , and  f D , which are the child nodes of  f A . To deduce the type of  f , ﬁrst consider the formula part. Any child of 
(cid:2)
(cid:2)
¯2
f A matches a formula ϕi = has-parent(ϕ A) = μZ . 
Z which simply states that the context node has a parent 
matching  ϕ A .  For  the  regular  expression  type  part,  we  can  deduce  from  τ A that  any  child  of  f A matches  a  regular  tree 
type τB | τC | τD .  Finally,  by  distributing ϕi over τB | τC | τD using  an  auxiliary  function  distrib(),  we  obtain  an  input  type 
(ϕi ∧ form(τB ), τB ) | (ϕi ∧ form(τC ), τC ) | (ϕi ∧ form(τD ), τD ).

ϕ A ∨

In general, given an output type ρ, when we infer a parent type (ϕ, element n {τ }) using the inference rules for self, 
τ may be an arbitrary regular expression. Therefore, for the regular expression type part, we compute a child type using an 
auxiliary function Prime(τ ) [8] which extracts all unit types at the top level of τ and constructs their disjunction. Moreover, 
if  the  output  type ρ is  nullable,  then  the  input  node  may  be  a  root.  In  other  words,  if  (¬k(n), AnyElt) is  inferred  for  the 
parent node using the inference rules for self, then the input context node satisﬁes the formula has-parent(¬k(n)) ∨
(cid:2)
(cid:14) ∧ ¬ (cid:4)2(cid:5) (cid:14) and speciﬁes that a given node is a root. That is, the input context 
ϕroot, where ϕroot is deﬁned as ¬ 
node has a parent whose label is different from n, or else it does not have a parent. Note that we cannot specify the fact 
that the input node may be a root in the regular tree type part.

(cid:2)
(cid:14) ∧ ¬ 

(cid:3)
¯2

¯1

(cid:3)

Proof of Invariant 4.1 for parent. Suppose (ϕ1, u1) | · · · | (ϕk, uk) ← self::n, ρ. Then ϕi <: ui for all i’s. For each i, we 
need to show that if child-type((ϕi, ui)) = (ϕ(cid:3)
(cid:3)
j for all  j’s. If ϕi = ¬k(n) and ui = AnyElt, 
(cid:3)
then the proof is straightforward since u
l . Then, 
for each  j, ϕ(cid:3)
j

= AnyElt. Thus, suppose ui = element ni {τi} and Prime(τi) = u

= has-parent(ϕi) ∧ form(u

j) and therefore ϕ(cid:3)

1) | · · · | (ϕ(cid:3)

l), then ϕ(cid:3)

(cid:3)
j . (cid:2)

j <: u

| · · · | u

j <: u

1, u

l , u

(cid:3)
1

(cid:3)
j

(cid:3)

(cid:3)

(cid:3)

4.2.  Inference rules for other axes

Unlike self and parent, for other axes, given an output type (ϕ, u), we cannot specify the exact shape of the input 
tree  in  the  unit  type  part  of  the  inferred  input  type  since  the  output  unit  type  u does  not  contain  information  about 
the  context.  Hence,  for  other  axes,  we  approximate  the  unit  type  part  in  the  inferred  input  type.  Still,  we  do  not  lose 
any precision since the formula part of the input type is exact. In other words, for type inference for XPath axes, we can 
safely ignore the unit type part of the inferred input type (Invariant 4.1). Nevertheless, we try to infer a more precise type 
than AnyElt for the unit type part if possible. More precisely, we simply infer AnyElt for psibl, fsibl, and desc, while 
inferring a more precise type for child and anc. As studied in [8,19], in forward type inference systems using only regular 
tree types as its type language, one can infer precise types only for self, child, and desc. In contrast, in our backward 
type inference system, we infer precise regular tree types only for self, parent, child, and anc (the formula part is 
still exact for all XPath axes).

Another important difference between self and parent and other axes is that while the former requires us to inspect 
only a single node in the input tree, the rest of the axes requires us to inspect a sequence of nodes reached by navigating 
the axis from the input node and combine the constraints for all these nodes. In order to combine a set of constraints on 
a sequence of nodes, we use an additional judgment of the form ϕ ← axis::n, ρ with ψ , for which we develop inference 
rules in such a way that the following property holds (the proof is given in Lemmas 4.5 and 4.6 in Section 4.3).

Proposition 4.2. Suppose ϕ ← axis::n, ρ with ψ and (cid:2) f /axis::n(cid:3) = f 1, . . . , fn for some input node  f .

• For backward axes, let  f = fn+1. Then  f ∈ (cid:4) (cid:4)ϕ(cid:5) (cid:5) if and only if ∃ 1 ≤ i ≤ n + 1 such that  f i ∈ (cid:4) (cid:4)ψ(cid:5) (cid:5) and  f i, . . . fn ∈ (cid:2)ρ(cid:3).
• For forward axes, let  f = f 0. Then  f ∈ (cid:4) (cid:4)ϕ(cid:5) (cid:5) if and only if ∃ 0 ≤ i ≤ n such that  f i ∈ (cid:4) (cid:4)ψ(cid:5) (cid:5) and  f 1, . . . f i ∈ (cid:2)ρ(cid:3).

Speciﬁcally, given a backward (resp. forward) axis, the judgment ϕ ← axis::n, ρ with ψ means that an input context 
node  f satisﬁes the inferred input formula ϕ if and only if  f /axis::n produces a sequence of nodes  f 1, . . . , fn such that 
there exists some node  f i satisfying ψ and the node sequence  f i, . . . , fn (resp.  f 1, . . . , f i ) is of type ρ. In particular, for a 
backward (resp. forward) axis,  fn (resp.  f 1) is the closest node satisfying the name test n at the direction of axis from the 
context node  f . Moreover,  f /axis::n produces an empty sequence if and only if  f satisfying ϕ also satisﬁes ψ and ρ is 
nullable. Note that using this judgment, we only infer a formula. We infer a unit type for the input node using auxiliary 
functions.

To illustrate the meaning of the judgment ϕ ← axis::n, ρ with ψ , consider an example input tree node represented as 
a  binary  tree  in  Fig. 5.  Suppose  that  axis is psibl and  C is  the  context  node.  Then,  there  exists  some  node  A reachable 
by navigating psibl from C that satisﬁes both the with parameter ψ and the name test n. Moreover, by analyzing ψ , we 
can obtain the constraints on the nodes reached by further navigating psibl from A. That is, ψ should contain the context 
information for  A as its subformulas, for example, information on  A’s preceding siblings. In addition, the sequence of the 
nodes from A to B that consists only of the nodes satisfying the name test n has type ρ, where B is the rightmost preceding 
sibling of C in document order (i.e., pre-order). Lastly, the context node C has the inferred type ϕ. In the subsection below, 
we give a more precise interpretation of the judgment when the output type is a sequence type of the form (ρ1, ρ2).

With  this  interpretation,  given  axis::n and  an  output  type  ρ,  we  ﬁrst  infer  a  formula  ϕ using  the  judgment 
ϕ ← axis::n, ρ with ψinit, where the initial formula ψinit is determined by axis. For example, if axis is psibl, then ψinit is 
(cid:10)
(cid:9)
¯2
(¬k(n) ∧ X) which means that there exist no preceding siblings satisfying the name test n. Then, we compute 
set to μ X. 

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

79

Fig. 5. Interpretation of ϕ ← psibl::n, ρ with ψ when the context node is C: A and B are some nodes reached by navigating psibl from C.

Psibl
ϕ ← psibl::n, ρ with μ X.

(cid:10)
(cid:9)
¯2

(¬k(n) ∧ X)

(ϕ, AnyElt) ← psibl::n, ρ

Psibl-Formula
(cid:3)
(cid:2)
¯2
ϕ(cid:3) =

(μ X.(ϕ ∧ k(n) ∧ form(u) ∧ ψ) ∨ (¬k(n) ∧
ϕ(cid:3) ← psibl::n, (ϕ, u) with ψ

(cid:2)

(cid:3)
¯2

X))

Fig. 6. Inference rules for psibl.

Axis-Empty

Axis-Or

ϕi ← axis::n, ρi with ψ
ϕ1 ∨ ϕ2 ← axis::n, (ρ1 | ρ2) with ψ

(i = 1, 2)

ψ ← axis::n, () with ψ

Axis-Backward-Seq
ϕ1 ← axis::n, ρ1 with ψ

ϕ2 ← axis::n, (ρ1, ρ2) with ψ

ϕ2 ← axis::n, ρ2 with ϕ1

(axis is psibl or anc)

Axis-Forward-Seq
ϕ2 ← axis::n, ρ2 with ψ

ϕ1 ← axis::n, ρ1 with ϕ2

ϕ1 ← axis::n, (ρ1, ρ2) with ψ

(axis is fsibl or desc)

Axis-Plus
ϕ ← axis::n, ρ with X ∨ ψ
μ X.ϕ ← axis::n, ρ+
with ψ

( X fresh)

Fig. 7. Common inference rules for psibl, anc, fsibl, and desc.

a unit type u using an appropriate auxiliary function depending on axis. When computing u, we ensure a subtype relation 
ϕ <: u. Finally, the input type is determined as a pair (ϕ, u) as shown below:

ϕ ← axis::n, ρ with ψinit

u = aux_func(ρ)

(ϕ, u) ← axis::n, ρ

4.2.1.  Preceding siblings and generic inference rules

psibl::n returns in document order the preceding siblings of the context node, say  f , that satisfy the name test  n. 
In other words, given an output type ρ, it denotes the type of the preceding siblings of  f . Thus, the inferred formula for 
f obtained by analyzing ρ should accumulate the constraints (i.e., types) on its preceding siblings. The rest of the nodes 
reachable from  f may have an arbitrary structure if they are not described by (the context part of) the output type ρ.

Fig. 6 shows the inference rules for psibl. In the rule Psibl, we initially assume that there are no preceding siblings 
(cid:9)
¯2
(¬k(n) ∧ X). Then, we analyze the output type ρ using the judgment of the form 
satisfying the name test n, that is, μ X. 
ϕ ← psibl::n, ρ with ψ . In this judgment, ψ is true at the leftmost preceding sibling returned by psibl::n when the 
output type is ρ (e.g., the node A in Fig. 5). When the inferred input formula is ϕ, the ﬁnal input type is a pair (ϕ, AnyElt). 
Since  we  cannot  extract  any  meaningful  information  about  the  context  node  from  the  regular  tree  types  of  its  preceding 
siblings, we simply use AnyElt. Thus, for psibl, Invariant 4.1 trivially holds.

(cid:10)

When  the  output  type  is  a  single  formula  type  (ϕ, u) and  the  with parameter  is  ψ ,  it  means  that  there  should  be  a 
preceding sibling satisfying the name test n such that both ϕ and ψ are true. Moreover, that sibling node should also have 
type u. All these constraints are encoded in the inferred formula ϕ(cid:3)
in the rule Psibl-Formula. As in the rule Self-Formula, 
we use function form(u) to translate the unit type u to a corresponding formula. In addition, since the initial with parameter 
given in the rule Psibl guarantees that there are no preceding siblings satisfying the name test n, the two rules guarantee 
that if psibl::n returns a single node, then the context node has only one preceding sibling satisfying n.

The rest of the inference rules for empty, sequence, union, and repetition types are generic and are also used for other 
axes—anc, fsibl, and desc. (When the output type is a sequence type, we distinguish backward axes from forward axes, 
and thus present two inference rules.) The common rules are given in Fig. 7. The ﬁrst two rules are easy. If the output type 
is an empty type, the inferred input type is simply the formula ψ given as the with parameter (rule Axis-Empty). Therefore, 
in combination with the rule Psibl, the inferred formula in the rule Axis-Empty speciﬁes that no preceding sibling of the 

80

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

Fig. 8. Interpretation of ϕ ← axis::n, (ρ1, ρ2) with ψ when axis is a backward axis psibl or anc: we analyze the sequence type from left to right. We 
ﬁrst infer ϕ1 and then ϕ2.

Fig. 9. Interpretation of ϕ ← axis::n, (ρ1, ρ2) with ψ when axis is a forward axis fsibl or desc: we analyze the sequence type from right to left. We 
ﬁrst infer ϕ2 and then ϕ1.

Fig. 10. Interpretation of ϕ ← axis::n, ρ+

with ψ when axis is a backward axis. A similar illustration can be applied to forward axes.

input node should satisfy the name test. If the output type is a union type of two, we infer a formula from each and return 
the union of the two inferred formulas (rule Axis-Or).

(cid:3)

When  the  output  type  is  a  sequence  type  (ρ1, ρ2),  our  analysis  begins  with  the  farthest  node  from  the  input  context 
node among the nodes reached by navigating the given axis and proceeds towards the context node. Therefore, if the given 
axis is a backward axis such as psibl and anc, we analyze the output type from left to right (rule Axis-Backward-Seq). 
More precisely, as depicted in Fig. 8, given a judgment ϕ ← axis::n, (ρ1, ρ2) with ψ , we can conceptually divide the nodes 
reached  by  navigating  axis from  the  context  node  C into  two  parts:  the  nodes  from  A to  A
that 
produce a sequence of nodes of type ρ1 and ρ2, respectively, where the ﬁrst part precedes the second part in document 
order. In particular, ψ is true at node A which is the ﬁrst node in the ﬁrst part. We ﬁrst infer a formula ϕ1 from ρ1 and ψ
using the judgment ϕ1 ← axis::n, ρ1 with ψ . Then ϕ1 is true at node B which is next to A
in document order and also the 
ﬁrst node in the second part. Next, we infer a formula ϕ2 from ρ2 and ϕ1 using the judgment ϕ2 ← psibl::n, ρ2 with ϕ1. 
Finally, ϕ2 is true at the context node and is returned as the input type.

(cid:3)
and  those  from  B to  B

The interpretation of the judgment ϕ ← axis::n, (ρ1, ρ2) with ψ is dual if axis is a forward axis such as fsibl and
desc.  In  this  case,  we  analyze  the  output  type  from  right  to  left,  i.e.,  ρ2 ﬁrst  (rule Axis-Forward-Seq).  For  example,  as 
(cid:3)
at  which  ψ is  true,  among  the  nodes 
depicted  in  Fig. 9,  with  ρ2 and  ψ ,  we  start  from  a  constraint  on  the  last  node  B
reached by navigating axis from the context node C, and subsequently infer constraints on the nodes appearing before B
in 
reverse order, e.g., from B through A

to A, until ﬁnally inferring the constraint on the context node.

When the output type is a repetition type ρ+

, we introduce a fresh recursion variable  X (rule Axis-Plus). Then, we infer 
a formula ϕ from the output type ρ and the with parameter  X ∨ ψ using the judgment ϕ ← axis::n, ρ with X ∨ ψ . More 
precisely, as depicted in Fig. 10, there exists a block of nodes reached by navigating axis from the context node C, e.g., the 
nodes from An to the node before C, that produce a sequence of nodes of type ρ, each of which satisﬁes the name test n. 
Moreover, the lastly reached node An should satisfy  X ∨ ψ , while C should satisfy the inferred formula ϕ (where ϕ contains 
X ∨ ψ as a subformula, for example, see the rule Psibl-Formula). If An satisﬁed  X , that is, [μ X.ϕ/ X]ϕ, there would be more 
blocks of nodes reached by further navigating axis from An that would produce nodes of type ρ, where the lastly reached 
node in each block, e.g., A1, would also satisfy  X . This recursion terminates when some node satisﬁes ψ rather than  X , e.g., 
A0 (where the block of nodes containing A0 should also produce a sequence of nodes of type ρ). Lastly, the closed recursive 
formula μ X.ϕ is returned as the input type of the context node C.

(cid:3)

(cid:3)

(cid:3)

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

81

Anc
ϕ ← anc::n, ρ with ¬ has-anc(k(n))
distrib(ϕ, desc-type(ρ)) ← anc::n, ρ

Anc-Formula
ϕ(cid:3) = μ X.

(cid:2)
(cid:3)
¯1

((ϕ ∧ k(n) ∧ form(u) ∧ ψ) ∨ (¬k(n) ∧ X)) ∨

(cid:2)

(cid:3)
¯2

X

ϕ(cid:3) ← anc::n, (ϕ, u) with ψ

has-anc(χ ) = μZ .
desc-type(()) = ()

(cid:3)

(cid:2)

¯1

(χ ∨ Z ) ∨

(cid:2)

(cid:3)
¯2

Z

desc-type((ϕ, element n {τ })) = desc-type(τ )

desc-type(ρ1, ρ2) = desc-type(ρ1) | desc-type(ρ2)
desc-type(ρ1 | ρ2) = desc-type(ρ1) | desc-type(ρ2)

desc-type(ρ+) = desc-type(ρ)

desc-type(element n {τ }) = element n {τ } | desc-type(τ )
desc-type(τ1, τ2) = desc-type(τ1) | desc-type(τ2)
desc-type(τ1 | τ2) = desc-type(τ1) | desc-type(τ2)

desc-type(τ +) = desc-type(τ )

4.2.2.  Ancestors

Fig. 11. Inference rules for anc.

Inference rules for anc::n are the same as those for psibl::n with two exceptions (they are both backward axes and 
use the same set of rules in Fig. 7): ﬁrst the interpretation of the judgment and the initial value of the with parameter, and 
second the input type inferred when the output type is a single formula type (ϕ, u). We brieﬂy explain them in turn.

First,  the  interpretation  of  a  judgment  ϕ ← anc::n, ρ with ψ is  as  follows:  there  is  a  block  of  nodes  reached  by 
navigating anc from  the  context  node  such  that  it  produces  a  sequence  of  nodes  of  type  ρ,  each  of  which  satisﬁes  the 
name test n. Moreover, ψ is true at the lastly reached node, or equivalently, the ﬁrst node in document order, in that block. 
followed by a possibly empty 
(We may reuse the example in Fig. 5 for anc by interpreting the left arrow in the ﬁgure as 
s.) In the rule Anc in Fig. 11, we thus set the with parameter to ¬ has-anc(k(n)) to mean that there are no 
sequence of 
(more) ancestors satisfying the name test n. has-anc(χ ) is a formula that describes any tree node such that it has at least 
one ancestor at which χ is true and ¬ has-anc(χ ) is its negation.1 Note that 
denotes the left sibling of the context 
node if any, and 

its parent if the context node has no left sibling and is not a root.

(cid:3)
¯2

(cid:3)
¯1

(cid:3)
¯1

¯2

(cid:2)

(cid:2)

(cid:2)

(cid:3)

(cid:2)

When the output type is (ϕ, u) and the with parameter is ψ , it means that the context node has an ancestor  f that sat-
isﬁes the name test n and is of type (ϕ, u) (rule Anc-Formula). Moreover,  f should also satisfy ψ , which should contain as 
its subformulas the context information on the structure of  f ’s ancestors. The inferred input formula ϕ(cid:3)
is thus a recursive 
formula that denotes a tree node having an ancestor  f satisfying all these constraints, i.e., ϕ ∧ k(n) ∧ form(u) ∧ ψ . Further-
more,  the  ancestors  between  f and  the  context  node  should  not  satisfy  the  name  test  n and  thus  have  type  ¬k(n) ∧ X , 
which is also encoded in the inferred input formula ϕ(cid:3)
. Combined with the rule Anc, the rule Anc-Formula speciﬁes that if 
the output type is a single formula type, then the context node has only one ancestor satisfying n.

As  for  the  regular  tree  type  part,  we  use  an  auxiliary  function  desc-type() which  is  a  recursive  version  of  Prime()
and computes the type of all possible descendants. Note that for anc, the output type is the type of the ancestors of the 
input context node. In other words, the context node is one of their descendants. Hence, in the rule Anc, we distribute the 
inferred input formula over the union of all possible descendant types using the function distrib() deﬁned in Fig. 4.

Proof of Invariant 4.1 for anc. In the rule Anc, suppose distrib(ϕ, desc-type(ρ)) = (ϕ1, u1) | · · · | (ϕk, uk) for some k. We 
need to show ϕi <: ui for all i’s. This is easy because ϕi = ϕ ∧ form(ui) by the deﬁnition of distrib(). (cid:2)

4.2.3.  Following siblings

(cid:2)

(cid:3)

¯2

(cid:9)

(cid:10)
¯2

fsibl is  the  converse  of psibl.  To  obtain  the  inference  rules  for fsibl in  Fig. 12,  we  just  replace 

in 
the  rules Psibl and Psibl-Formula with  (cid:4)2(cid:5) and  [2],  respectively,  and  use  the  rule Axis-Forward-Seq instead  of  the  rule
Axis-Backward-Seq.  More  precisely,  the  interpretation  of  a  judgment  ϕ ← fsibl::n, ρ with ψ is  as  follows:  there  is 
an initial subsequence of the nodes reached by navigating fsibl from the context node that has type ρ, each of which 
satisﬁes  the  name  test  n.  Moreover,  the  lastly  reached  node  in  that  subsequence  and  the  context  node  satisfy  ψ and  ϕ, 
respectively. Since our analysis always starts with the lastly reached node, i.e., the rightmost sibling in the case of fsibl, 
in the rule Fsibl, we set the initial with parameter to μ X. [2] (¬k(n) ∧ X) which means that there are no (more) following 
siblings satisfying the name test n. For the regular tree type part, we simply use AnyElt because of the lack of information 
about the context in the regular tree types of the following sibling nodes. Thus, for fsibl, Invariant 4.1 trivially holds.

and 

If the output type is a single formula type (ϕ, u) and the with parameter is ψ , it means that one of the following siblings 
of the context node, say  f , satisﬁes the name test n and is of type (ϕ, u) (rule Fsibl-Formula). Moreover, ψ should also be 
true at  f . As with other axes, ψ should contain as its subformulas the context information on the structure of  f ’s following 
siblings. In addition, the following siblings between the context node and  f , if any, should not satisfy the name test n and 
thus have type ¬k(n) ∧ (cid:4)2(cid:5) X . All these constraints are encoded in the inferred input formula ϕ(cid:3)
. Note that in combination 

1 Technically this encoding allows the presence of hedges satisfying the formula (we do not impose the invariant that there is only a single root), but 
our semantics ensures that a formula accepts trees only.

82

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

Fsibl
ϕ ← fsibl::n, ρ with μ X. [2] (¬k(n) ∧ X)
(ϕ, AnyElt) ← fsibl::n, ρ

Fsibl-Formula
ϕ(cid:3) = (cid:4)2(cid:5) (μ X.(ϕ ∧ k(n) ∧ form(u) ∧ ψ) ∨ (¬k(n) ∧ (cid:4)2(cid:5) X))
ϕ(cid:3) ← fsibl::n, (ϕ, u) with ψ

Fig. 12. Inference rules for fsibl.

Fig. 13. child deﬁned  in  terms  of self-fsibl:  the  nodes  in  the  box  are  C’s  children  and  A is  its  leftmost  child.  Therefore,  (cid:2)C/child::n(cid:3) =
(cid:2)A/self-fsibl::n(cid:3). If ϕ ← self-fsibl::n, ρ and ϕ is true at node A, then (cid:4)1(cid:5) ϕ is true at node C.

Child-Nullable

ϕ ← self-fsibl::n, ρ

nullable(ρ)
([1] ϕ, parent-type(ρ)) ← child::n, ρ

Child-NotNull
ϕ ← self-fsibl::n, ρ
¬nullable(ρ)
((cid:4)1(cid:5) ϕ, parent-type(ρ)) ← child::n, ρ

parent-type(ρ) = element ∗ { AnyElt
add-anyelt(()) = ()

∗, add-anyelt(ρ), AnyElt

∗ }

add-anyelt((ϕ, u)) = u
add-anyelt(ρ1 | ρ2) = add-anyelt(ρ1) | add-anyelt(ρ2)
add-anyelt(ρ1, ρ2) = add-anyelt(ρ1), AnyElt

∗, add-anyelt(ρ2)

add-anyelt(ρ+) = (AnyElt

∗, add-anyelt(ρ))+

Fig. 14. Inference rules for child.

with the rule Fsibl, the rule Fsibl-Formula ensures that if the output type is a single formula type, then the context node 
has only one following sibling satisfying n.

4.2.4.  Child nodes

As the inference rules for parent are deﬁned in terms of those for self, rules for child can be deﬁned in terms of 
those for self-fsibl (self or following siblings, a variant of fsibl, deﬁned in the next subsection). As shown in Fig. 13, 
we ﬁrst infer a formula ϕ for self-fsibl and then use it as a constraint for the leftmost child of the context node by 
adding either [1] or (cid:4)1(cid:5) to ϕ. Speciﬁcally, if the output type is nullable, which means that the context node may not have a 
child, then we use universal modality (rule Child-Nullable in Fig. 14). Otherwise, the context node always has a child and 
therefore we use existential modality instead (rule Child-NotNull in Fig. 14).

∗

In addition, to infer a unit type for the context node, we use an auxiliary function parent-type(ρ), deﬁned in Fig. 14, 
which computes the type of any node that has some children of type ρ and possibly more of arbitrary types. To this end, it 
exploits another auxiliary function add-anyelt(ρ) which extracts all unit types at top level of ρ, while maintaining their 
order, and adds AnyElt
between unit types, indicating that there may be more child nodes. Note that parent-type(ρ)
approximates the type of the context node. For example, consider the tree in Fig. 13. If only nodes  A and  Y are returned 
by C/child::n, then other nodes such as W, X, and Z must not satisfy the name test n. This constraint is encoded in the 
inferred input formula, as discussed in the next subsection, but not in the inferred unit type. If we add negation of a name 
test, i.e., ¬n, we could infer a more precise unit type. However, since all the constraints are already encoded in the inferred 
input formula, we do not add ¬n in the deﬁnition of regular tree types. Still, the more precise we infer a unit type, more 
precise we can develop an inference system for XQuery in Section 5, and thus we do not simply use AnyElt in the regular 
tree type part of the input type.

4.2.5.  Self or following siblings

While inference rules for self-fsibl are similar to those for fsibl, there is a key difference. Suppose fsibl::n
returns nothing (i.e., the output type is ()). Then it means that there are no following siblings satisfying the name test n, 
and thus the input context node should have type μ X. [2] (¬k(n) ∧ X) (either there are no following siblings or if any, they 
do not satisfy n). In contrast, if self-fsibl::n returns nothing, it means that the context node does not satisfy n and 
neither do its following siblings, i.e., μ X.(¬k(n) ∧ [2] X).

This difference leads to two interpretations of the output type depending on whether it is nullable or not. To illustrate, 
assume that the output type is (ϕ, u), ρ. As in the inference rules for fsibl, we examine the output sequence type from 
right to left. Suppose that a formula ψ is inferred from ρ and that there exists a node  f satisfying (ϕ, u) ( f can be either 
the context node or one of its following siblings). Then, ψ is a constraint on  f ’s right next sibling. For example, in Fig. 13, 

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

83

optional ::= true | false

Self-Fsibl
ϕ ← self-fsibl::n, ρ with μ X.(¬k(n) ∧ [2] X), true
ϕ ← self-fsibl::n, ρ

SFsibl-True
ϕ(cid:3) = μ X.(ϕ ∧ k(n) ∧ form(u) ∧ [2] ψ) ∨ (¬k(n) ∧ (cid:4)2(cid:5) X)

ϕ(cid:3) ← self-fsibl::n, (ϕ, u) with ψ, true

SFsibl-False
ϕ(cid:3) = μ X.(ϕ ∧ k(n) ∧ form(u) ∧ (cid:4)2(cid:5) ψ) ∨ (¬k(n) ∧ (cid:4)2(cid:5) X)

ϕ(cid:3) ← self-fsibl::n, (ϕ, u) with ψ, false

SFsibl-Seq
ϕ2 ← self-fsibl::n, ρ2 with ψ, optional

ϕ1 ← self-fsibl::n, ρ1 with ϕ2, optional ∧ nullable(ρ2)

ϕ1 ← self-fsibl::n, (ρ1, ρ2) with ψ, optional

Fig. 15. Inference rules for self-fsibl.

is X, then ψ should 
if A is the context node for self-fsibl, then  f should be one of the nodes between A and Z. If  f
is ϕ ∧ [2] ψ indicating that  f
be true at X’s right next sibling Y. Moreover, if ρ is nullable, then the exact constraint on  f
may not have following siblings. This is the case when  f
is Z in Fig. 13. If ρ is not nullable, then the exact constraint on  f
is ϕ ∧ (cid:4)2(cid:5) ψ indicating that  f has at least one following sibling and its ﬁrst following sibling is of type ψ . Therefore, given 
an output type (ρ1, ρ2), when examining ρ1, we need to exploit the nullability of ρ2.

To  this  end,  we  introduce  a  new  judgment  ϕ ← self-fsibl::n, ρ with ψ, optional where  optional denotes  either 
true or  false.  In  this  judgment,  the  meaning  of  ψ is  twofold:  it  may  denote  the  constraint  on  either  the  context  node, 
i.e., self,  or  one  of  its  following  siblings  i.e., fsibl.  The  former  is  when ρ is  ().  For  the  latter  case,  ψ does  not  refer 
to  the  last  node  in  the  sequence  returned  by  the  axis  unlike  previous  with judgments,  but  to  the  one  that  immediately 
follows it, which may not exist (thus we use the  optional parameter). Suppose that self-fsibl::n returns a sequence 
of  nodes  f 1, . . . , fn of  type ρ.  Then  ψ is  true  at  the  right  next  sibling  of  fn where  fn is  the  rightmost  following  sibling 
returned by self-fsibl::n given the output type ρ. For example, in Fig. 13, if A/self-fsibl::n returns A, W, X and 
ϕ ← self-fsibl::n, ρ with ψ, optional, then ψ is true at  Y. This is in clear contrast to the interpretations for other 
axes where the with parameter is true at the lastly reached node among the nodes returned by navigating the given axis. 
For example, if A/fsibl::n returns W, X and ϕ ← fsibl::n, ρ with ψ , then ψ is true at X. In the rule Self-Fsibl in 
Fig. 15, therefore, the initial with parameter is set to μ X.(¬k(n) ∧ [2] X) which means that all the following siblings of the 
current context node (including the context node itself if the output type is ()) do not satisfy the name test n. In addition, 
the initial optional parameter is set to true.

The nullability parameter is examined only when the output type is a single formula type (ϕ, u). Consider a judgment 
ϕ(cid:3) ← self-fsibl::n, (ϕ, u) with ψ, optional. Then, there should be a node  f 1 that satisﬁes the name test n and is of 
type  (ϕ, u) (it  can  be  either  the  context  node  or  one  of  its  following  siblings).  Moreover,  f 1’s  right  next  sibling  f 2 must 
satisfy  ψ .  If  optional is  true,  then  f 2 may  not  exist  and  thus  f 1 has  type  ϕ ∧ k(n) ∧ form(u) ∧ [2] ψ (rule SFsibl-True). 
Otherwise,  f 2 must exist and thus  f 1 has type ϕ ∧ k(n) ∧ form(u) ∧ (cid:4)2(cid:5) ψ (rule SFsibl-False).

For the rest of the cases, we reuse the inference rules in Fig. 7 with minor modiﬁcations. For the rules Axis-Empty, Axis-
Or, and Axis-Plus, we add one more parameter optional in each judgment. Given a sequence type (ρ1, ρ2), the nullability is 
updated when examining ρ1 as shown in the rule SFsibl-Seq in Fig. 15. Precisely, the last node  f among the nodes returned 
by  self-fsibl::n with  the  output  type  ρ1 may  not  have  following  siblings  if  ρ2 is  nullable  and  the  given  optional
parameter is true. In this case, we use [2] ϕ2 as a constraint on  f (in combination with the rule SFsibl-True). Otherwise,  f
must have a following sibling and we use (cid:4)2(cid:5) ϕ2 as a constraint on  f (in combination with the rule SFsibl-False).

To  show  that  Invariant 4.1 holds  for child,  we  need  to  show  that  if  ϕ ← self-fsibl::n, ρ then  either  [1] ϕ <:
parent-type(ρ) or  (cid:4)1(cid:5) ϕ <: parent-type(ρ) depending  on  the  nullability  of  ρ,  which  is  proved  by  the  following 
lemma.

Lemma 4.3. Suppose ϕ ← self-fsibl::n, ρ with ψ, optional. If optional is true, then [1] ϕ <: parent-type(ρ). Otherwise,
(cid:4)1(cid:5) ϕ <: parent-type(ρ).

Proof. By induction on a derivation of ϕ ← self-fsibl::n, ρ with ψ, optional. Below we only sketch the proof ideas 
for the cases where optional = false; the proof for the other cases is similar.
Case 1) ρ = (): trivial since parent-type(ρ) = AnyElt.
Case 2) ρ = ρ1 | ρ2:

(1) ϕi ← self-fsibl::n, ρi with ψ, false for i = 1, 2
(2) (cid:4)1(cid:5) ϕi <: parent-type(ρi) for i = 1, 2

from the rule Axis-Or
by I.H.

84

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

(3) Then, (cid:4)1(cid:5) (ϕ1 ∨ ϕ2) <: parent-type(ρ1) | parent-type(ρ2) = parent-type(ρ1 | ρ2).

Case 3) ρ = (ϕ, u):

(1) ϕ(cid:3) = μ X.(ϕ ∧ k(n) ∧ form(u) ∧ (cid:4)2(cid:5) ψ) ∨ (¬k(n) ∧ (cid:4)2(cid:5) X)
(2) parent-type((ϕ, u)) = element ∗ { AnyElt
(3) ϕ(cid:3)

from the rule Sfsibl-False
by deﬁnition
can be thought of as a sequence type ((¬k(n))∗, ϕ ∧ k(n) ∧ form(u) ∧ (cid:4)2(cid:5) ψ) using the regular expression notation. 

∗, u, AnyElt

∗ }

Moreover, (¬k(n))∗ <: AnyElt

∗

and (ϕ ∧ k(n) ∧ form(u) ∧ (cid:4)2(cid:5) ψ) <: u, AnyElt

∗

.

(4) Therefore, (cid:4)1(cid:5) ϕ(cid:3) <: parent-type((ϕ, u)).

Case 4) ρ = ρ1, ρ2:

(1) ϕ2 ← self-fsibl::n, ρ2 with ψ, false
from the rule SFsibl-Seq
(2) ϕ1 ← self-fsibl::n, ρ1 with ϕ2, false
from the rule SFsibl-Seq
(3) (cid:4)1(cid:5) ϕi <: parent-type(ρi) for i = 1, 2
by I.H.
(4) By  interpreting  ϕ1 as  a  type  of  a  sequence  of  nodes  (the  context  node  and  its  following  siblings),  we  have  ϕ1 <:

AnyElt

∗, add-anyelt(ρ1), AnyElt

∗

. Similarly, ϕ2 <: AnyElt

∗, add-anyelt(ρ2), AnyElt

∗

.

(5) Moreover, since ϕ1 contains ϕ2 as the rightmost subformula (the one that the most (cid:4)2(cid:5)s precede directly or indirectly 

through recursion), we have ϕ1 <: AnyElt
(6) Therefore, (cid:4)1(cid:5) ϕ1 <: parent-type(ρ1, ρ2).

∗, add-anyelt(ρ1), AnyElt

∗, add-anyelt(ρ2), AnyElt

∗

.

Case 5) ρ = ρ+
1 :

(1) ϕ ← self-fsibl::n, ρ1 with X ∨ ψ, false
(2) (cid:4)1(cid:5) ϕ <: parent-type(ρ1)
(3) By interpreting ϕ as a type of a sequence of nodes, we have ϕ <: AnyElt
most subformula of ϕ, i.e.,  X ∨ ψ , is subsumed by the second AnyElt

∗

.

(4) Therefore, μ X.ϕ <: (AnyElt

∗, add-anyelt(ρ1))+, AnyElt

∗

∗, add-anyelt(ρ1), AnyElt

from the rule Axis-Plus
by I.H.
, where the right-

∗

and thus (cid:4)1(cid:5) μ X.ϕ <: parent-type(ρ+

1 ). (cid:2)

4.2.6.  Descendants

desc is more complicated than other axes because its semantics does not have a “closure property” with respect to the 
document order. Formally, we say that axis is “forward-closed” if (cid:2) f /axis::n(cid:3) = f 1, . . . , fn implies (cid:2) f i/axis::n(cid:3) = f i+1, . . . , fn
for any  i. Similarly, axis is “backward-closed” if (cid:2) f /axis::n(cid:3) = f 1, . . . , fn implies (cid:2) f i/axis::n(cid:3) = f 1, . . . , f i−1 for any  i. Note 
that fsibl is forward-closed while psibl and anc are backward-closed. Although desc itself is not forward-closed, it 
can be deﬁned in terms of another forward-closed, parameterized axis desc-or-foll( f ) which returns the descendants 
and following nodes of the context node that appear in document order before the ﬁrst following node of  f . We remark 
here  that  in  the  XML  terminology  the  following  nodes  of  f mean  the  nodes  that  appear  after  f
in  document  order  but 
are not a descendant of  f . More precisely, if (cid:2) f /desc::n(cid:3) = f 1, . . . , fn, then (cid:2) f i/desc-or-foll( f ) :: n(cid:3) = f i+1, . . . , fn
for  any  i.  Note  that  f i+1 is  f i ’s  descendant  or  one  of  its  following  nodes.  Below,  based  on  this  observation,  we  develop 
inference rules for desc using a judgment of the form ϕ ← desc::n, ρ with ψ where the with parameter ψ now denotes 
a constraint on the last node in document order among the descendants and following nodes of the context node returned 
by desc-or-foll when the output type is ρ.

In  the  rule Desc in  Fig. 16,  the  initial  with parameter  is  much  more  complicated  than  other  axes  because  we  need  to 
specify  constraints  only  on  the  descendants  of  the  context  node,  but  not  on  others.  More  precisely,  if  the  output  type  is 
a  sequence  type  of  the  form  (ϕ1, u1), . . . , (ϕn, un),  then  f /desc::n for  any  input  node  f returns  a  sequence  f 1, . . . , fn
of descendants in document order, each of which has type (ϕi , ui). Now, to infer an exact input type, we need to specify 
that all the nodes that follow  fn but precede  f ’s ﬁrst following node must not satisfy the name test n. This constraint is 
encoded in noNextUpTo(k(n), α) which exploits a nominal denoted by α. A nominal is simply an atomic proposition like 
node labels σ but it holds at exactly one node of any given tree [28]. Speciﬁcally, in the rule Desc, the nominal α is true 
only at the context node on which desc is applied, which is guaranteed by noWhereElse(α) in the ﬁnal input type. This 
nominal α is used as a search bound for descendants during the inference process, i.e., noNextUpTo(k(n), α).

If  the  output  type  is  a  single  formula  type  (ϕ, u) and  the  with parameter  is  ψ ,  it  means  that  the  context  node  has  a 
descendant  f of  type  (ϕ, u) that  satisﬁes  the  name  test  n and  at  which  ψ is  true  (rule Desc-Formula).  Moreover, any 
in  document  order  should  not  satisfy  the  name  test  n.  All  these  constraints  are 
node  between  the  context  node  and  f
encoded  in  fstDescFoll(ϕ ∧ k(n) ∧ form(u) ∧ ψ, k(n)),  deﬁned  in  Fig. 16,  which  speciﬁes  the  ﬁrst  node  satisfying  n
among the descendants and following nodes of the context node. As for other cases, we simply use the inference rules in 
Fig. 7.  In  particular,  the  rule Axis-Forward-Seq can  be  used  as  it  is  since  each  descendant  is  connected  to  the  next  de-
scendant in document order by fstDescFoll() (rule Desc-Formula) and the last descendant in document order satisﬁes 
noNextUpTo() for the input node on which desc is initially applied (rule Desc).

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

85

Desc
ϕ ← desc::n, ρ with noNextUpTo(k(n), α)
(ϕ ∧ noWhereElse(α), AnyElt) ← desc::n, ρ

(α fresh)

Desc-Formula
ϕ(cid:3) = fstDescFoll(ϕ ∧ k(n) ∧ form(u) ∧ ψ, k(n))
ϕ(cid:3) ← desc::n, (ϕ, u) with ψ

Auxiliary deﬁnitions:

χ ? ψ1 : ψ2 ≡ (χ ∧ ψ1) ∨ (¬χ ∧ ψ2)
has-desc(χ ) = (cid:4)1(cid:5) (μZ .χ ∨ (cid:4)1(cid:5) Z ∨ (cid:4)2(cid:5) Z )
has-fsdesc(χ ) = (cid:4)2(cid:5) (μZ .χ ∨ (cid:4)1(cid:5) Z ∨ (cid:4)2(cid:5) Z )

(cid:2)
¯2
has-prec(χ ) = μZ .
has-foll(χ ) = μZ . has-fsdesc(χ ) ∨ has-parent(Z )

(χ ∨ has-desc(χ ) ∨ Z )

Z ∨

¯1

(cid:3)

(cid:3)

(cid:2)

noNextUpTo(χ , α) = ¬ has-desc(χ ) ∧ μZ . α ? (cid:14) : (¬has-fsdesc(χ ) ∧ has-parent(Z ))
noWhereElse(χ ) = χ ∧ ¬ (has-anc(χ ) ∨ has-prec(χ ) ∨ has-desc(χ ) ∨ has-foll(χ ))

fstSelfFsDesc(χ1, χ2) = μZ . χ1 ∨ (¬χ2 ∧ (has-desc(χ2) ? (cid:4)1(cid:5) Z : (cid:4)2(cid:5) Z ))

fstFoll(χ1, χ2) = μZ . (cid:4)2(cid:5) fstSelfFsDesc(χ1, χ2) ∨ (¬has-fsdesc(χ2) ∧ has-parent(Z ))

fstDescFoll(χ1, χ2) = (cid:4)1(cid:5) fstSelfFsDesc(χ1, χ2) ∨ (¬has-desc(χ2) ∧ fstFoll(χ1, χ2))

• has-desc(χ ): there is a descendant satisfying χ .
• has-fsdesc(χ ): there is a node satisfying χ among the following siblings and their descendants.
• has-prec(χ ): there is a node satisfying χ which precedes the context node in document order and is not 

• has-foll(χ ): there is a node satisfying χ which follows the context node in document order and is not a 

an ancestor.

descendant.

• noNextUpTo(χ , α): there is no node satisfying χ which appears strictly after the context node in document 

order and before a node satisfying α (invariant: α should denote a nominal).

• noWhereElse(χ ): only the context node satisﬁes χ .
• fstSelfFsDesc(χ1, χ2): the ﬁrst node  f

their descendants} that satisﬁes χ1. Any node preceding  f

in document order of the set {self, all following siblings, and all 

in the set does not satisfy χ2.

• fstFoll(χ1, χ2): the ﬁrst node  f satisfying χ1 among the nodes reachable by navigating following. Any 

node between the context node and  f reached by navigating following does not satisfy χ2.

• fstDescFoll(χ1, χ2): the ﬁrst node  f satisfying χ1 that appears strictly after the context node in docu-

ment order. Any node between the context node and  f does not satisfy χ2.

• Note.  In  fstSelfFsDesc(χ1, χ2),  fstFoll(χ1, χ2),  and  fstDescFoll(χ1, χ2),  we  assume  (cid:4) (cid:4)χ1(cid:5) (cid:5) ⊆
(cid:4) (cid:4)χ2(cid:5) (cid:5). This is always ensured by the rule Desc-Formula which is the only rule that uses these auxiliary 
functions.

Fig. 16. Inference rules for desc.

Fig. 17. ϕ ← desc::n, ((ϕ1, u1), (ϕ2, u2)) with noNextUpTo(k(n), α) where C is the context node and D1 and D2 are the only nodes satisfying the name 
test n, each of which has type (ϕ1, u1) and (ϕ2, u2), respectively. D1 precedes D2 in document order and D2 is the ﬁrst node satisfying n among D1’s 
descendants and following nodes.

86

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

To  illustrate,  consider  an  example  tree  in  Fig. 17.  Suppose  that  the  output  type  is  (ϕ1, u1), (ϕ2, u2).  Then  there  exist 
only  two  descendants  satisfying  the  name  test  n,  namely,  D1 and  D2.  According  to  the  rule Axis-Forward-Seq,  we  ﬁrst 
analyze  the  rightmost  output  type  (ϕ2, u2).  In  other  words,  we  ﬁrst  infer  a  constraint  on  the  node  D2.  Since  D2 is  the 
last  node  returned  by  desc::n,  noNextUpTo(k(n), α) should  be  true  at  D2 which  means  that  k(n) is  not  true  at  D2’s 
descendants, its following siblings and their descendants, its parent’s following siblings and their descendants, its parent’s 
parent’s following siblings and their descendants, and so on until the initial context node C, marked with a nominal α, is 
reached (rule Desc). Moreover, when locally analyzing D2 with the output type (ϕ2, u2), the context node is D1. From D1’s 
perspective, D2 is the ﬁrst node satisfying the name test n among D1’s descendants and following nodes. This constraint is 
expressed by using the function fstDescFoll() (rule Desc-Formula).

4.3.  Properties of backward type inference for XPath axes

In  this  section,  we  brieﬂy  discuss  the  soundness  and  completeness  of  our  backward  type  inference  system  for  XPath 

axes. In other words, our backward inference is exact.

Theorem 4.4 (Exact type inference). Suppose ρi ← axis::n, ρo. Then,  f ∈ (cid:2)ρi(cid:3) if and only if (cid:2) f /axis::n(cid:3) ∈ (cid:2)ρo(cid:3).

In Theorem 4.4, the only-if-direction states the soundness and the if-direction states the completeness. More precisely, 
the soundness states that given an axis axis::n and an output type ρo , if our inference system infers an input type ρi and 
some  focused  tree  is  of  type  ρi ,  then  it  always  produces  a  sequence  of  nodes  of  type  ρo.  In  contrast,  the  completeness 
states the opposite, that is, given an axis  axis::n, if some focused tree  f produces a sequence of nodes of type ρo , then 
is of type ρi . In particular, our inference system fails only if 
our inference system can infer an input type ρi from ρo and  f
the axis is self::n or parent::n and the output type is a sequence type ρ1, ρ2 where both ρ1 and ρ2 are not nullable. 
Note  that  this  case  never  happens  though  since  there  is  only  one  self  and  parent,  if  any.  To  prove  Theorem 4.4,  we  use 
Proposition 4.2 which is proved by Lemmas 4.5 and 4.6 for the auxiliary judgment ϕ ← axis::n, ρ with ψ .

Lemma 4.5 (Soundness). Suppose ϕ ← axis::n, ρ with ψ ,  f ∈ (cid:4) (cid:4)ϕ(cid:5) (cid:5), and (cid:2) f /axis::n(cid:3) = f 1, . . . , fn.

• For backward axes, let  f = fn+1. Then, ∃ 1 ≤ i ≤ n + 1 such that  f i ∈ (cid:4) (cid:4)ψ(cid:5) (cid:5) and  f i, . . . fn ∈ (cid:2)ρ(cid:3).
• For forward axes, let  f = f 0. Then, ∃ 0 ≤ i ≤ n such that  f i ∈ (cid:4) (cid:4)ψ(cid:5) (cid:5) and  f 1, . . . f i ∈ (cid:2)ρ(cid:3).

Lemma 4.5 is  a  one-way  formalization  of  the  interpretation  of  the  judgment  ϕ ← axis::n, ρ with ψ .  To  illustrate, 
consider Fig. 5 again. In the ﬁgure,  fn+1 = C and  f i = A where  C ∈ (cid:4) (cid:4)ϕ(cid:5) (cid:5) and  A ∈ (cid:4) (cid:4)ψ(cid:5) (cid:5). Moreover, the sequence  f i, . . . , fn
of nodes selected from the node  A to the node  B by  psibl::n has type ρ. Below we show some cases of the proof of 
Lemma 4.5.

Proof of Lemma 4.5. By induction on a derivation of ϕ ← axis::n, ρ with ψ . Here, we show some cases where axis is a 
backward axis.
Case 1) ρ = ():

(1) ϕ = ψ
(2) Let i = n + 1.
(3) Then,  f i ∈ (cid:4) (cid:4)ψ(cid:5) (cid:5) and  f i, . . . , fn = (cid:5) ∈ (cid:2)()(cid:3). 

Case 2) ρ = ρ1, ρ2:

(1) ϕ1 ← axis::n, ρ1 with ψ
(2) ϕ ← axis::n, ρ2 with ϕ1
(3) ∃ 1 ≤ j ≤ n + 1 s.t. f j ∈ (cid:4) (cid:4)ϕ1(cid:5) (cid:5) and  f j, . . . , fn ∈ (cid:2)ρ2(cid:3)
(4) (cid:2) f j/axis::n(cid:3) = f 1, . . . , f j−1
(5) ∃ 1 ≤ k ≤ j s.t. fk ∈ (cid:4) (cid:4)ψ(cid:5) (cid:5) and  fk, . . . , f j−1 ∈ (cid:2)ρ1(cid:3)
(6) Let i = k.
(7) Then,  f i ∈ (cid:4) (cid:4)ψ(cid:5) (cid:5) and  f i, . . . , f j−1, f j, . . . , fn ∈ (cid:2)(ρ1, ρ2)(cid:3). (cid:2)

from the rule Axis-Empty

from assumptions

from the rule Axis-Backward-Axis
from the rule Axis-Backward-Axis
by I.H. on (2)

by I.H. on (1) and (4)

Below we state the completeness lemma for the auxiliary judgment. In particular, given an axis axis::n and an output 
type  ρ,  we  assume  that  our  inference  system  always  infers  some  input  formula  ϕ since  the  inference  never  fails.  (The 
inferred formula may be unsatisﬁable though, indicating a contradiction.)

Lemma 4.6 (Completeness). Suppose (cid:2) f /axis::n(cid:3) = f 1, . . . , fn and ϕ ← axis::n, ρ with ψ .

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

87

• For backward axes, let  f = fn+1. If ∃ 1 ≤ i ≤ n + 1 such that  f i ∈ (cid:4) (cid:4)ψ(cid:5) (cid:5) and  f i, . . . fn ∈ (cid:2)ρ(cid:3), then  f ∈ (cid:4) (cid:4)ϕ(cid:5) (cid:5).
• For forward axes, let  f = f 0. If ∃ 0 ≤ i ≤ n such that  f i ∈ (cid:4) (cid:4)ψ(cid:5) (cid:5) and  f 1, . . . f i ∈ (cid:2)ρ(cid:3), then  f ∈ (cid:4) (cid:4)ϕ(cid:5) (cid:5).

Proof. By induction on a derivation of ϕ ← axis::n, ρ with ψ . Here, we only show the case where ρ = ρ1, ρ2 and axis is 
a backward axis.

(1) ϕ1 ← axis::n, ρ1 with ψ
(2) ϕ ← axis::n, ρ2 with ϕ1
(3) ∃ i ≤ j ≤ n s.t. f i, . . . , f j−1 ∈ (cid:2)ρ1(cid:3) and  f j, . . . , fn ∈ (cid:2)ρ2(cid:3)
(4) (cid:2) f j/axis::n(cid:3) = f 1, . . . , f j−1
(5) 1 ≤ i ≤ j and  f i ∈ (cid:4) (cid:4)ψ(cid:5) (cid:5)
(6)
(7)

f j ∈ (cid:4) (cid:4)ϕ1(cid:5) (cid:5)
fn+1 ∈ (cid:4) (cid:4)ϕ(cid:5) (cid:5)

5.  Inference for the XQuery core

from the rule Axis-Backward-Axis
from the rule Axis-Backward-Axis
from  f i, . . . fn ∈ (cid:2)(ρ1, ρ2)(cid:3)

from (3) and assumptions
by I.H. on (1), (3), (4), (5)
by I.H. on (2), (3), (6) (cid:2)

In  this  section,  we  present  our  backward  type  inference  system  for  the  XQuery  core  in  the  style  of  constraint  solving 
systems [29–31], building on the results of the previous section. We ﬁrst clarify what we infer from the given expression e
and output type ρ. Precisely, we use a judgment of the form S ← e : ρ which means that given an expression e and an 
output  type ρ,  it  generates  a  set  S of  constraint-sets  for  free  variables  in  e where  free  and  bound  variables  are  deﬁned 
in the usual way. Our goal is then to design inference rules that ensure that if we substitute those free variables with any 
sequences of focused trees satisfying one of the constraint-sets in S , e evaluates to a value, i.e., a sequence of focused trees, 
that has the type ρ. By convention, if S is an empty set, it is unsatisﬁable, and we denote it by 0. In contrast, a singleton 
set consisting of an empty set is always satisﬁable, and we denote it by 1.

Formally, a constraint-set C is a set of bindings of variables with formula-enriched sequence types, where each binding 
is denoted by ($var : ρ). Given a constraint-set C , we consider any for-loop and let-bound variables not appearing in C to 
be implicitly bound to ((cid:14), AnyElt) and ((cid:14), AnyElt)∗
, respectively. Moreover, a constraint-set C is unsolvable if it contains a 
constraint specifying that a variable should satisfy ⊥, for example, ($var : (⊥, u)) or ($var : (ϕ, u)) where ϕ is unsatisﬁable. 
We simply write {⊥} to denote such an unsolvable constraint-set. If S contains {⊥}, we can safely remove it from S . We 
often consider a constraint-set C to be a mapping from variables to their types and thus use the usual notations such as:

dom(C)

C($var)

C($v)

C($v)

def= {$var | ($var : ρ) ∈ C}
def= ρ
def= ((cid:14), AnyElt)
def= ((cid:14), AnyElt)∗

if ($var : ρ) ∈ C
if $v /∈ dom(C)
if $v /∈ dom(C)

We also introduce the following operations.

Deﬁnition 5.1. Let  C1 and  C2 be  constraint-sets,  which  are  not  {⊥},  and  S ,  S1,  and  S2 be  sets  of  constraint-sets.  We 
deﬁne:

C1 (cid:24) C2

def= {($var : ρ) ∈ C1 | $var /∈ dom(C2)} ∪
{($var : ρ) ∈ C2 | $var /∈ dom(C1)} ∪
{($var : ρ1 ∧ ρ2) | ($var : ρ1) ∈ C1 and ($var : ρ2) ∈ C2}

C\$var0
S1 (cid:24) S2
S1 (cid:25) S2
S \$var

def= {($var : ρ) ∈ C | $var (cid:9)= $var0}
def= {C1 (cid:24) C2 | C1 ∈ S1, C2 ∈ S2}
def= S1 ∪ S2
def= {C\$var | C ∈ S }

For any constraint-set C , C (cid:24) {⊥} = {⊥} (cid:24) C = {⊥}.

In  the  deﬁnition  above,  we  use ρ1 ∧ ρ2 to  denote  the  intersection  of ρ1 and ρ2 whose  semantics  (cid:2)ρ1 ∧ ρ2(cid:3) is  induc-
tively deﬁned as (cid:2)ρ1(cid:3) ∩ (cid:2)ρ2(cid:3). In other words, for any focused tree  f ,  f ∈ (cid:2)ρ1 ∧ ρ2(cid:3) if and only if  f ∈ (cid:2)ρ1(cid:3) and  f ∈ (cid:2)ρ2(cid:3). 
Although we use intersection types only internally during type inference, they can seamlessly be added into the external 
language [32].

88

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

I-Or

I-And

Si ← e : ρi
S1 (cid:25) S2 ← e : ρ1 | ρ2

(i = 1, 2)

Si ← e : ρi
S1 (cid:24) S2 ← e : ρ1 ∧ ρ2

(i = 1, 2)

I-Emp
nullable(ρ)
1 ← (cid:5) : ρ

I-FVar
ρ(cid:3) ← self::∗, ρ
{{($v : ρ(cid:3)
)}} ← $v : ρ

I-LVar

I-Axis

ρ(cid:3) ← axis::n, ρ

{{($v : ρ)}} ← $v : ρ

{{($v : ρ(cid:3)

)}} ← $v/axis::n : ρ

I-Element
(ϕroot, u) <: ρ

I-IfNonEmpty

u = element n {τ }

σ = n or σ = ∗ S ← e : form-enriched(τ )

S ← (<σ >{e}</σ > : u) : ρ

S1 ← e1 : ((cid:14), AnyElt)

+ S2 ← e2 : ρ

S1 (cid:24) S2 ← if nempty(e1) then e2 else e3 : ρ

I-IfEmpty

S1 ← e1 : () S3 ← e3 : ρ
S1 (cid:24) S3 ← if nempty(e1) then e2 else e3 : ρ

I-IfAny

S1 ← e1 : ((cid:14), AnyElt)

∗ S2 ← e2 : ρ S3 ← e3 : ρ

S1 (cid:24) S2 (cid:24) S3 ← if nempty(e1) then e2 else e3 : ρ

I-Let
S2 ← e2 : ρ S = {S1 (cid:24) {C\$v} | S1 ← e1 : C($v), C ∈ S2}

(cid:25) S ∈S S ← let $v := e1 return e2 : ρ

Auxiliary deﬁnitions:

form-enriched(()) = ()

form-enriched(u) = (form(u), u)

form-enriched(τ1, τ2) = form-enriched(τ1), form-enriched(τ2)
form-enriched(τ1 | τ2) = form-enriched(τ1) | form-enriched(τ2)

form-enriched(τ +) = form-enriched(τ )+

single((ϕ, u)) = ϕ ∧ form(u)

single(()) = ⊥
⎧
⎪⎪⎨

⊥
single(ρ1)
single(ρ2)
single(ρ1) ∨ single(ρ2)

single(ρ1, ρ2) =

⎪⎪⎩
single(ρ1 | ρ2) = single(ρ1) ∨ single(ρ2)
single(ρ1 ∧ ρ2) = single(ρ1) ∧ single(ρ2)

single(ρ+) = single(ρ)

if ¬nullable(ρ1) and ¬nullable(ρ2)
if ¬nullable(ρ1) and nullable(ρ2)
if nullable(ρ1) and ¬nullable(ρ2)
if nullable(ρ1) and nullable(ρ2)

Fig. 18. Backward type inference rules for the XQuery core.

5.1.  Inference rules

Figs. 18 and 19 show our backward type inference rules for the XQuery core. We ﬁrst describe the case where the output 
type is a union type ρ1 | ρ2 (rule I-Or). In this case, the input constraint is a union of S1 and S2, which are inferred from 
ρ1 and ρ2, respectively. If one of Si is unsatisﬁable, i.e., 0, it is simply ignored since S (cid:25) 0 = S for any S . If both S1
and S2 are unsatisﬁable, the input constraint is 0 which means that expression e can never have the output type ρ1 | ρ2
in the ﬁrst place. Similarly, if the output type is an intersection type ρ1 ∧ ρ2, the input constraint is an intersection of S1
and S2, each of which is inferred from ρi (rule I-And). In this case, if one of Si is unsatisﬁable, then the input type is also 
unsatisﬁable. During the inference, either the rule I-Or or the rule I-And should ﬁrst be tried.

The I-Emp, I-FVar, I-LVar, and I-Axis rules are relatively easy. First, in the rule I-Emp, if the output type ρ is nullable, 
then the input constraint is 1 which means that (cid:5) is of type ρ without further constraints. In the rule I-FVar, we use the 
inference rules for the self axis since a for-loop variable is bound only to an XML element, not a sequence. In contrast, 
the rule I-LVar just binds a let-bound variable to the given sequence type since it can be bound to an arbitrary sequence. 
The rule I-Axis uses the inference rules for the axis expression, and binds the for-loop variable to the inferred type.

In  the  rule I-Element,  we  consider  only  a  type-annotated  element  constructor  (<σ >{e}</σ > : u).  The  annotated  type 
u should be a subtype of the output type ρ since we are using a backward type inference. Speciﬁcally, since an element 
(cid:2)
(cid:14) ∧
constructor always reduces to a root element, we check the subtype relation (ϕroot, u) <: ρ where ϕroot = ¬ 
¬ (cid:4)2(cid:5) (cid:14) speciﬁes  that  the  given  node  is  a  root  (the  subtype  relation  is  explained  shortly).  Let  u be  element n {τ }. 
Then,  the  node  label  σ should  match  the  name  test n.  Finally,  we  infer  input  constraints  from  the  body  expression  e, 
which reduces to a sequence of child nodes, and the output type form-enriched(τ ), which is the type of the child nodes. 
form-enriched(τ ) enriches the given regular tree type τ by simply associating each unit type u that appears in τ with an 
equivalent downward-only formula form(u), i.e., without context information.

(cid:2)
(cid:14) ∧ ¬ 

(cid:3)
¯2

(cid:3)
¯1

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

89

I-Seq
S = {S1 (cid:24) S2 | Si ← ei : ρi , (ρ1, ρ2) ∈ split(ρ)}

(cid:25) S ∈S S ← (e1, e2) : ρ

I-Err
(if no other rule applies)
0 ← e : ρ

I-ForEmpty
S2 ← e2 : ()

(cid:5)

S =

∗
S1 (cid:24) {C\$v} | S1 ← e1 : C($v)

((cid:25) S ∈S S ) (cid:25) S0 ← for $v in e1 return e2 : ()

, C ∈ S2

(cid:6)

S0 ← e1 : ()

I-For

(cid:5)

(cid:3) =

S

S =
S (cid:3)(cid:3) (cid:24) {C\$v (cid:24) C

S ← e2 : ρ S (cid:3) ← e2 : ()
(cid:5)
S (cid:3)(cid:3) (cid:24) {C\$v} | S (cid:3)(cid:3) ← e1 : C($v).Quant(ρ), C ∈ S

¬nullable(ρ)

(cid:3)\$v} | S (cid:3)(cid:3) ← e1 : (C

(cid:25) S ∈S∪S(cid:3) S ← for $v in e1 return e2 : ρ

, C($v), C

∗
($v)

∗
($v)

(cid:3)

(cid:3)

(cid:6)

).Quant(ρ), (C, C

(cid:3)

) ∈ S × S (cid:3)

(cid:6)

(ρ (cid:9)= ())

I-ForNullable

(cid:5)

(cid:3) =

S

S (cid:3)(cid:3) (cid:24) {C\$v (cid:24) C

S ← e2 : ρ S (cid:3) ← e2 : ()

(cid:5)

nullable(ρ) S0 ← e1 : ()

(cid:6)

S =
(cid:3)\$v} | S (cid:3)(cid:3) ← e1 : (C

S (cid:3)(cid:3) (cid:24) {C\$v} | S (cid:3)(cid:3) ← e1 : C($v).Quant(ρ), C ∈ S

((cid:25) S ∈S∪S(cid:3) S ) (cid:25) S0 ← for $v in e1 return e2 : ρ

(cid:3)($v)∗).Quant(ρ), (C, C

(cid:3)($v)∗, C($v), C

(cid:3)) ∈ S × S (cid:3)

(cid:6)

(ρ (cid:9)= ())

Auxiliary deﬁnitions:

split(()) = {((), ())}

split((ϕ, u)) = {((), (ϕ, u)), ((ϕ, u), ())}
split(ρ1 | ρ2) = split(ρ1) ∪ split(ρ2)

split(ρ+) = {((), ρ+), (ρ+, ()), (ρ+, ρ+)} ∪ {((ρ∗, ρ1), (ρ2, ρ∗)) | (ρ1, ρ2) ∈ split(ρ)}

split(ρ1, ρ2) = {(ρ1, ρ2)} ∪ {(ρ11, (ρ12, ρ2)) | (ρ11, ρ12) ∈ split(ρ1)} ∪

{((ρ1, ρ21), ρ22) | (ρ21, ρ22) ∈ split(ρ2)}

Quant(ρ) = + if ρ is of the form ρ(cid:3) +
Quant(ρ) = 1

otherwise

ρ.+ = ρ+
ρ.1 = ρ

Fig. 19. Backward type inference rules for the XQuery core, continued.

To check the subtype relation (ϕroot, u) <: ρ, we ﬁrst compute the type ρ(cid:3)

for the set of all single focused tree nodes that 
are contained in (cid:2)ρ(cid:3). Then (ϕroot, u) <: ρ if (ϕroot, u) <: ρ(cid:3)
because (ϕroot, u) denotes a set of focused tree nodes. Next, we 
translate u and ρ(cid:3)
into equivalent formulas ϕ and ψ , respectively, and then test the satisﬁability of ϕroot ∧ ϕ ∧ ¬ψ . To this 
end, we use an auxiliary function single(ρ) which computes a formula whose denotation includes only singleton sequences 
of focused tree nodes contained in (cid:2)ρ(cid:3). That is, (ϕroot, u) <: ρ if and only if (cid:4)(cid:4)ϕroot ∧ form(u) ∧ ¬single(ρ)(cid:5)(cid:5) = ∅ which can 
be tested in 2O (|u|+|ρ|) time by the decision procedure in [28].

and  S (cid:3) ← e1 : ().  Then,  if  S (cid:3)

As for an if-expression if nempty(e1) then e2 else e3, we ﬁrst check if the condition expression e1 always reduces 
to  a  non-empty  sequence  or  an  empty  sequence,  regardless  of  the  input  trees.  In  other  words,  we  ﬁrst  compute  S ←
e1 : ((cid:14), AnyElt)+
(or  S )  is  unsatisﬁable,  then  we  use  the  rule I-IfNonEmpty (or  the  rule
I-IfEmpty). If both S and S (cid:3)
are satisﬁable, that is, e1 can reduce to both a non-empty sequence and an empty sequence, 
depending on the input trees, then we use the rule I-IfAny. It simply assumes that e1 reduces to any sequence and infers a 
constraint Si from each subexpression ei . If all of S1, S2, and S3 are satisﬁable, then the if-expression has the speciﬁed 
output type ρ.

For  a  let-binding  let $v := e1 return e2,  the  rule I-Let ﬁrst  infers  a  constraint  S2 from  e2 and  the  given  output 
type ρ. Then, for each constraint-set C ∈ S2 such that (cid:2)C($v)(cid:3) (cid:9)= ∅, we infer a constraint S1 from e1 and C($v). Note that 
if (cid:2)C($v)(cid:3) = ∅, then  C is unsatisﬁable. In order for the whole let-expression to have type ρ, both S1 and  C\$v should be 
satisﬁable, i.e., S1 (cid:24) {C\$v}, where C\$v removes the constraint for $v from C because it is bound only in e2.

For a sequence concatenation, the rule I-Seq divides the output type ρ into two parts using an auxiliary function split(), 
deﬁned in Fig. 19. Then, we infer an input constraint for each case in split(ρ), and returns a union of all inferred constraints 
as a ﬁnal result. Note that for any ρ, if (ρ1, ρ2) ∈ split(ρ) then ρ1, ρ2 <: ρ.

Finally, let us consider for-loop expressions, which are the most challenging with respect to deﬁning precise inference 
rules.  Indeed,  they  are  the  main  source  of  the  approximation  introduced  in  our  backward  type  inference.  To  illustrate, 
consider the following expression:

for $v in $doc/desc::D return $v/child::∗

where  $doc is  bound  to  an  input  tree.  If  $doc/desc::D reduces  to  [ f 1, . . . , fn] for  some  n,  then  the  whole  expression 
reduces to  f 1/child::∗, . . . , fn/child::∗. Suppose that an output type ρo is given as follows:

ρo ≡ < A/><B/><C/>< A/><B/><C/>< A/><B/><C/>

where for simplicity we use < A/> to denote a formula type ((cid:14), element A {()}) and juxtaposition to denote a sequence 
concatenation. To infer the exact type of $doc, we need to infer the exact type of each  f i . Since the output sequence type 

90

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

Fig. 20. An example XML tree bound to the variable $doc: a for-loop expression for $v in $doc/desc::D return $v/child::∗ reduces to a sequence 
of focused tree nodes [ A[(cid:5)], B[(cid:5)], C[(cid:5)], A[(cid:5)], B[(cid:5)], C[(cid:5)], A[(cid:5)], B[(cid:5)], C[(cid:5)]] where we omit the context of each node for simplicity. In addition, the for-loop 
expression may have type (< A/><B/><C/>)+

, or less precisely (< A/> | <B/> | <C/>)∗

.

ρo is  ﬁnite,  it  suﬃces  to  compute  all  possible  (weak)  compositions  of ρo ,  infer  an  input  constraint  for  each  composition, 
and  take  a  union  of  all  inferred  constraints [33].  We  say  that  (ρ1; . . . ; ρn) is  a  composition  of  ρ if  (ρ1, . . . , ρn) <: ρ.  A 
composition is said to be weak if it contains an empty sequence type as an element. For example, we can infer the exact 
type of the example input tree given in Fig. 20 from the following weak composition:

((); < A/><B/>; <C/>; < A/><B/><C/>< A/>; (); <B/><C/>)

For this input tree, $doc/desc::D reduces to [ f 1, . . . , f 6] where each  f i is a focused tree rooted at the node labeled  D i
(here,  the  subscript  i is  not  part  of  the  node  label;  it  is  used  solely  to  distinguish  the  nodes  with  the  same  label).  Note 
that the composition above consists of the exact type of each  f i/child::∗, given the output type ρo. Assume that ρi is 
inferred from  f i/child::∗ and the corresponding type in the composition given above. Then, our backward type inference 
infers the following exact input type for the whole for-loop expression (with some simpliﬁcation):

(cid:15)

fstDescFoll(ρ1 ∧ fstDescFoll(ρ2 ∧ fstDescFoll(ρ3 ∧ fstDescFoll(ρ4 ∧ fstDescFoll(ρ5 ∧

fstDescFoll(ρ6 ∧ noNextUpTo(D, α), D), D), D), D), D), D) ∧ noWhereElse(α), AnyElt

(cid:16)

which states that the input node has six descendants with label  D and the ﬁrst descendant in document order is of type 
ρ1, the second is of type ρ2, and so on.

The situation becomes more complex if we consider repetition types. In the presence of repetition operators, the number 

of possible compositions is inﬁnite in general.2 To illustrate, consider an output type ρ(cid:3)

o deﬁned as follows:

ρ(cid:3)
o

≡ (< A/><B/><C/>)+

To infer the exact type of the input tree in Fig. 20 again, we need to unfold ρ(cid:3)
o three times to obtain ρo, which is deﬁned 
above, and compute its weak compositions. The problem is that in general we do not know statically how many times we 
need to unfold the given output repetition type to infer the exact input type for a for-loop expression. One possible solution 
is  to  unfold  repetition  types  up  to  some  arbitrary  ﬁxed  number  of  times,  giving  up  exact  typing.  Then  the  problem  is  to 
ﬁnd such an unfolding number that allows practical and precise type inference.

or ρ∗

In this paper, we adopt a simpler but more approximate approach. More precisely, we do not analyze output types of the 
form ρ+
across the boundary of ρ, that is, we do not unfold repetition types. We also do not compute compositions 
even for simple output sequence types containing no repetition operators. Instead, given a for-loop expression, we simply 
consider only those cases where each execution of the return expression evaluates to a sequence of focused trees whose 
type  is  a  subtype  of  the  given  output  type.  Consequently,  the  input  tree  in  Fig. 20 is  not  accepted  by  our  type  system  if 
the output type is given as (< A/><B/><C/>)+
. Our system accepts only those input trees whose descendants labeled  D
have no child or children of type (< A/><B/><C/>)+
. Nevertheless, the input tree in Fig. 20 is accepted if a more general 
output type is given such as (< A/> | <B/> | <C/>)∗
.

Our approximation is similar in spirit to the approximation used in forward type inference systems [8,17]. To illustrate, 
consider a regular tree type T deﬁned recursively as follows, where we use < A/> to denote a unit type element A {()}:

T ≡ element C {< A/>, T , <B/>} | ()

2 Even in the absence of repetition operators, the number of naive weak compositions is inﬁnite. For the purpose of typing for-loop expressions, however, 
it suﬃces to consider only strong compositions and assume that any number of empty sequence types may exist between every two adjacent single 
formula types used in each strong composition. For example, the following compositions can all be treated equally for type inference: (<A/>; <B/>), 
(< A/>; (); <B/>), (< A/>; (); (); <B/>), and so on.

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

91

In most forward type inference systems, if  f has type T , then the type of  f /desc-or-self::∗ is deduced as (T | < A/> |
<B/>)∗
. The exact type, however, is the union of (T , < A/>)n, (<B/>)n for n ∈ N, which is not regular. In general, in forward 
type inference systems, a sequence type (u1, . . . , un)∗
, losing 
the information on the order of elements. Similarly, in our backward type inference system, in order to accept more input 
trees, the output type should be given such that the order of elements does not matter.

is often approximated into a less precise type (u1 | . . . | un)∗

To further clarify the consequence of our approximation, consider the following examples:

(1) for $v in < A/>, < A/> return $v : < A/>< A/>
(2) for $v in < A>{<B/>, <C/>, <D/>}</ A> return $v/child::∗ : <B/><C/><D/>

Our  backward  type  inference  rejects  the  ﬁrst  example  while  accepts  the  second  one.  More  speciﬁcally,  the  ﬁrst  exam-
ple  is  rejected  because  the  for-loop  variable  $v can  be  bound  only  to  a  singleton  sequence,  i.e.,  $v cannot  have  type 
< A/>< A/>.  (If  the  composition-based  approach  is  used,  then  the  ﬁrst  example  is  also  accepted.)  The  second  example 
is accepted because $v/child::∗ can have type <B/><C/><D/>. More speciﬁcally, our inference system infers an input 
∗} for  $v using  the  rule I-Axis (with  some  simpli-
∗, <D/>, AnyElt
type  element ∗ {AnyElt
ﬁcation)  which  matches  with  < A>{<B/>, <C/>, <D/>}</ A>.  However,  the  following  similar  examples  are  not  accepted 
because the result of each execution of the return expression does not have the speciﬁed output type <B/><C/><D/>
or (<B/><C/><D/>)+

∗, <B/>, AnyElt

∗, <C/>, AnyElt

.

(3) for $v in < A>{<B/>}</ A>, < A/>, < A>{<C/><D/>}</ A> return $v/child::∗ : <B/><C/><D/>
(4) for $v in < A>{<B/>}</ A>, < A/>, < A>{<C/><D/>}</ A> return $v/child::∗ : (<B/><C/><D/>)+

Still, the ﬁrst and third examples are accepted if they are given a more general output type as follows:

(5) for $v in < A/>, < A/> return $v : < A/>+
(6) for $v in < A>{<B/>}</ A>, < A/>, < A>{<C/><D/>}</ A> return $v/child::∗ : (<B/> | <C/> | <D/>)+

We  will  explain  how  these  examples  are  accepted  by  our  type  inference  system  after  discussing  the  inference  rules  for 
for-loop expressions below.

(cid:3)) ∈ S × S (cid:3)

To infer an input type for for-loop expressions, we use three rules. First, given an expression for $v in e1 return e2, 
if the output type is (), then no matter how many times we evaluate e2 with different bindings for $v, it must reduce to (cid:5). 
Therefore, in the rule I-ForEmpty, we infer a constraint S1 from e1 with the output type C($v)∗
where C is a constraint-set 
inferred by analyzing e2 with (). Note that  C($v)∗
is zero or more repetitions of a single formula type  C($v) that makes 
e2 reduce to an empty sequence. In addition, we also consider the case where e1 reduces to an empty sequence (cid:5) since if 
e1 reduces to (cid:5), then the whole for-loop expression also reduces to (cid:5). The remaining two rules cover the cases where the 
output type ρ is not (). In particular, the rules I-For and I-ForNullable cover the cases where the output type ρ is not 
nullable and nullable, respectively.

The  rule I-For combines  the  following  three  cases.  First,  the  set  S (cid:3)

of  constraint-sets,  inferred  from  e2 and  (),  is 
unsatisﬁable,  i.e.,  S (cid:3) = 0.  This  means  that  e2 never  reduces  to  an  empty  sequence  regardless  of  the  value  of  $v.  Second, 
every constraint-set inferred from e2 and ρ is incompatible with every constraint-set inferred from e2 and (), i.e., C\$v (cid:24)
(cid:3)\$v = {⊥} for every (C, C
. Finally, e2 can reduce to both an empty and a non-empty sequence depending on 
C
is 
the value of $v. The ﬁrst and second cases are treated equally and thus we explain them ﬁrst. For these cases, the set  S
empty, and we use only the constraint-sets inferred from e2 and ρ, i.e., those in S . To illustrate, suppose that e1 reduces 
to  f 1, . . . , fn. Then, we accept only the cases where (cid:2)e2(cid:3)η,$v (cid:8)→ f i has type ρ for all i’s and for some substitution η. In other 
words, for some  i, if  (cid:2)e2(cid:3)η,$v (cid:8)→ f i has type ρ(cid:3)
which is not a subtype of ρ, then the given for-loop expression is rejected 
by our inference system. More speciﬁcally, if the output type ρ is not a repetition type, then the rule I-For requires e1 to 
reduce to a single focused tree of type C($v) where C is a constraint-set inferred from e2 and ρ. However, if e1 may reduce 
to a sequence of more than one focused tree node, say  f 1, f 2, then it is rejected since the whole for-loop expression would 
reduce to a sequence (cid:2)e2(cid:3)η,$v (cid:8)→ f 1 , (cid:2)e2(cid:3)η,$v (cid:8)→ f 2 whose type is (ρ, ρ) which is not equivalent to ρ, that is, the output type 
of the for-loop expression. Now consider the case where the output type ρ is a repetition type of the form ρ+
0 . In this case, 
e1 may reduce to a sequence of any number of focused trees because no matter how many times we evaluate e2, it would 
reduce to a sequence of type ρ+
0 (i.e., ρ+
0 ). Therefore, the output 
type of e1 is determined as C($v)+
, that is, we require e1 to reduce to a sequence of nodes  f 1, . . . , fn where each  f i is of 
type  C($v). Here  C is again a constraint-set inferred from  e2 and ρ. To distinguish repetition types from other types, we 
use an auxiliary function Quant(). Finally, the rule I-For also considers the case where e2 can reduce to both an empty and 
a non-empty sequence depending on the value of $v. In this case, we also infer an input constraint from e1 with the output 
(cid:3)($v) and  C($v) are  the  types  that  make  e2 reduce  to  an  empty 
sequence  type  (C
and a non-empty sequence, respectively. The rule I-ForNullable is the same as the rule I-For except that it also considers 
the case where e1 reduces to an empty sequence and ρ is nullable, as in the rule I-ForEmpty.

0 and their concatenation is also of type ρ+

(cid:3)($v)∗).Quant(ρ) where  C

(cid:3)($v)∗, C($v), C

0 , . . . , ρ+

0 <: ρ+

(cid:3)

Now let us consider the example (5) given above. For this example, we apply the rule I-For since the given output type is 
not nullable. Note that 0 ← $v : (). Next, a constraint-set {($v : < A/>)} is inferred by the rule I-FVar with $v and < A/>+
. 

92

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

Then,  < A/>, < A/> is matched against  < A/>+
which succeeds by the rules I-Seq and I-Element.  As for the example (6), 
we also apply the rule I-For. Note that $v/child::∗ can be of type (), i.e., when $v is of type ¬ (cid:4)1(cid:5) (cid:14) which means that 
there are no child nodes. Next, from  $v/child::∗ and (<B/> | <C/> | <D/>)+
, a constraint-set {($v : T )} is inferred by 
the rule I-Axis where T is deﬁned as follows (with some simpliﬁcation):

T ≡ element ∗ {(<B/> | <C/> | <D/>)+}

Then,  < A>{<B/>}</ A>, < A/>, < A>{<C/><D/>}</ A> is  matched  against  ((¬ (cid:4)1(cid:5) (cid:14))∗, T , (¬ (cid:4)1(cid:5) (cid:14))∗)+
ceeds by the rules I-Seq and I-Element.

which  again  suc-

5.2.  Complexity

5.2.1.  Complexity for XPath axes

We ﬁrst analyze the complexity of our backward type inference system for XPath axes. To this end, we ﬁrst deﬁne the 

length len(ρ) and the size |ρ| of a formula-enriched sequence type ρ:

len((ϕ, u)) = 1
len(()) = 1

len(ρ1, ρ2) = len(ρ1) + len(ρ2) + 1
len(ρ1 | ρ2) = len(ρ1) + len(ρ2) + 1

len(ρ+) = len(ρ) + 1

|(ϕ, u)| = |ϕ| + |u|

| () | = 1

|ρ1, ρ2| = |ρ1| + |ρ2| + 1
|ρ1 | ρ2| = |ρ1| + |ρ2| + 1

|ρ+| = |ρ| + 1

The  size  |ϕ| of  a  formula ϕ and  the  length  len(τ ) and  the  size  |τ | of  a  regular  tree  type τ are  also  deﬁned  as  usual.  In 
particular, in the analysis below, we mean by |τ | the size of the classical binary representation of τ [2].

Lemma 5.2. The time complexity of computing an application of each auxiliary function introduced in Section 4 is as follows.

• nullable(ρ) can be computed in O (len(ρ)) time.
• child-type(ρ) can be computed in O (len(ρ)) time.
• parent-type(ρ) can be computed in O (len(ρ)) time.
• desc-type(ρ) can be computed in O (|ρ|) time.

child-type(ρ) in  Fig. 4 is  deﬁned  only  when  the  argument  ρ is  of  the  form  (ϕ1, u1) | . . . | (ϕn, un) where  ui =
element ni {τi}, and its precise complexity is indeed  O (len(ρ) × max len(τi)). We consider max len(τi) as a constant and 
omit it in the above analysis since it is usually small and does not affect the overall complexity of our inference system.

Among the functions listed in Lemma 5.2, only nullable() may be called many times during the inference. More precisely, 
when the output type is (ϕ1, u1), . . . , (ϕn, un), the naive cumulative cost of calling nullable() is in total  O (n2). With addi-
tional space, however, if we memoize the result of nullable() on each subterm of the output type ρ when it is called for the 
ﬁrst time, the cumulative cost is still  O (len(ρ)).

Lemma 5.3. Given an output type ρ, an input type for an XPath axis is inferred in O (|ρ|) time.

Proof. Easy from the fact that we analyze the structure of the output type, with an empty type () and a pair type (ϕ, u)
as base cases, and the cumulative cost of using auxiliary functions during the inference is  O (|ρ|). (cid:2)

To analyze the size of the inferred input type, below we assume that we use an optimization technique such as hash-
consing to represent types and formulas, i.e., to share the same subterms. Otherwise, in the input type, some formula may 
be duplicated an exponential number of times in terms of the length of the output type, e.g., when the output type is of the 
form (ρ1 | ρ2), . . . , (ρn−1 | ρn). Note that in the rule Axis-Or, with a naive representation of formulas, the with parameter ψ
may be duplicated in the inferred input formula ϕ1 ∨ ϕ2: one in ϕ1, the other in ϕ2.

Lemma 5.4. Assume ϕ ← axis::n, ρ with ψ . Then the size of ϕ is O (|ρ| + |ψ|).

Proof. By induction on a derivation of ϕ ← axis::n, ρ with ψ . In the proof, we use the fact that all the auxiliary deﬁnitions 
used in Fig. 16, which take a formula χ as argument, return another formula of size  O (|χ |). The proof also relies on that 
form(u) has the same size as the classical binary representation of the regular tree type u [19]. (cid:2)

Lemma 5.5. Given an output type ρ, the size of the inferred input type for an XPath axis is O (|ρ|).

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

93

Proof. The cases for the axes except self, parent, child, and anc are easily proved by Lemma 5.4. The case for self
is  proved  by  structural  induction  on  the  output  type  ρ.  The  cases  for parent, child,  and anc are  proved  by  the  fact 
that  the  size  of  child-type(ρ),  parent-type(ρ),  and  desc-type(ρ) is  O (|ρ|) with  optimized  representations  of 
types. (cid:2)

Corollary 5.6. Given an output type ρ and an XPath axis, we can check in 2O (|ρ|) time if there exists some tree that when applied to 
the axis, returns a sequence of nodes of type ρ, by testing the satisﬁability of the inferred input type using the decision procedure in 
[28].

Precisely, if ρ(cid:3) ← axis::n, ρ, then ρ(cid:3)
satisﬁability of each ϕi in the inferred input type.

is of the form (ϕ1, u1) | . . . | (ϕn, un) where ϕi <: ui , and thus it suﬃces to check the 

5.2.2.  Complexity for the XQuery core

Now we analyze the complexity of our backward type inference system for the XQuery core. We deﬁne the size |C| of C
and the size |S | of S as the number of bindings in C and the number of constraint-sets in S , respectively. In particular, 
|C| does not take into consideration the size of the types included in C and similarly for |S |. Then, |C1 (cid:24) C2| ≤ |C1| + |C2|, 
|S1 (cid:24) S2| ≤ |S1| × |S2|, and |S1 (cid:25) S2| ≤ |S1| + |S2|. The size |e| of an XQuery expression e is inductively deﬁned as usual, 
e.g., see Deﬁnition 8.1 in [8].

Lemma 5.7. Suppose S ← e : ρ. Then the maximum size, denoted by T (e, ρ), of a largest type appearing in S is O (2
single exponential in terms of the size of the given expression e.

|e||ρ|), i.e., 

Proof. By solving the following set of recursive equations, which are derived from the inference rules:

T (e, ρ1 | ρ2) = maxi T (e, ρi)
T (e, ρ1 ∧ ρ2) = T (e, ρ1) + T (e, ρ2) + 1
T ((e1, e2), ρ) = max(ρ1,ρ2)∈split(ρ)(T (e1, ρ1) + T (e2, ρ2) + 1)

T ((<σ >{e}</σ > : element n {τ }), ρ) = T (e, form-enriched(τ ))
T (if nempty(e1) then e2 else e3, ρ) = T (e1, ((cid:14), AnyElt)∗) + T (e2, ρ) + T (e3, ρ) + 2

T (let $v := e1 return e2, ρ) = T (e2, ρ) + T (e1, T (e2, ρ)) + 1
T (for $v in e1 return e2, ρ) = T (e2, ρ) + T (e2, ()) + T (e1, (T (e2, ρ) + 2T (e2, ()) + 5)) + 2

T (e, ρ) = O (|ρ|)

(otherwise)

where we use a type and its size interchangeably as the second argument to T (−, −). (cid:2)

Lemma 5.8. Suppose S ← e : ρ. Then the maximum size, denoted by N(e, ρ), of S is O (22
of the size of the given expression e.

|e||ρ|), i.e., double exponential in terms 

Proof. By solving the following set of recursive equations, which are derived from the inference rules. We use the result 
from Lemma 5.7.

N(e, ρ1 | ρ2) = N(e, ρ1) + N(e, ρ2)
N(e, ρ1 ∧ ρ2) = N(e, ρ1) × N(e, ρ2)
N((e1, e2), ρ) = |split(ρ)| × max(ρ1,ρ2)∈split(ρ)(N(e1, ρ1) × N(e2, ρ2))

N((<σ >{e}</σ > : element n {τ }), ρ) = N(e, form-enriched(τ ))
N(if nempty(e1) then e2 else e3, ρ) = N(e1, ((cid:14), AnyElt)∗) × N(e2, ρ) × N(e3, ρ)

N(let $v := e1 return e2, ρ) = N(e2, ρ) × N(e1, T (e2, ρ))
N(for $v in e1 return e2, ρ) = N(e2, ρ) × N(e2, ()) × N(e1, (T (e2, ρ) + 2T (e2, ()) + 5)) +

N(e, ρ) = O (1)

N(e2, ρ) × N(e1, T (e2, ρ))
(otherwise)

In the above equations, we use a type and its size interchangeably as the second argument to N(−, −). (cid:2)

Lemma 5.9. Suppose S ← e : ρ. Then S is computed in 2O (2

|e||ρ|) time in the worst case.

Proof. Let  I(e, ρ) denote the complexity of deducing a set of constraint-sets from e and ρ using our inference system. We 
obtain the complexity by solving the following set of recursive equations, which are derived from the inference rules. We 
use the result from Lemmas 5.7 and 5.8. We also use a type and its size interchangeably as the second argument to I(−, −).

94

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

I((cid:5), ρ) = I($v, ρ) = 1

I(e, ρ1 | ρ2) = I(e, ρ1 ∧ ρ2) = 1 + I(e, ρ1) + I(e, ρ2)
I($v, ρ) = I($v/axis::n, ρ) = O (|ρ|)

I((<σ >{e}</σ > : element n {τ }), ρ) = 2 + I(e, form-enriched(τ )) + 2O (|u|+|ρ|)
I(if nempty(e1) then e2 else e3, ρ) = 1 + I(e1, ((cid:14), AnyElt)∗) + I(e2, ρ) + I(e3, ρ)

I((e1, e2), ρ) = 1 + |split(ρ)| × max(ρ1,ρ2)∈split(ρ)(I(e1, ρ1) + I(e2, ρ2))

I(let $v := e1 return e2, ρ) = 1 + I(e2, ρ) + N(e2, ρ) × I(e1, T (e2, ρ)) + N(e2, ρ) × 2O (T (e2,ρ))
I(for $v in e1 return e2, ρ) = 1 + I(e2, ρ) + I(e2, ()) + O (len(ρ)) + I(e1, ()) +

N(e2, ρ) × N(e2, ()) × I(e1, (T (e2, ρ) + 2T (e2, ()) + 5)) +
N(e2, ρ) × I(e1, T (e2, ρ)) + N(e2, ρ) × 2O (T (e2,ρ)) +
N(e2, ()) × 2O (T (e2,()))

In  the  above  equations,  the  case  of  the  element  construction  includes  the  complexity  for  the  subtype  check  u <: ρ.  The 
cases of let-expressions and for-loop expressions include the complexity of satisﬁability checks for the inferred type for the 
bound variable, e.g., C($var). (cid:2)

Lastly, we state the worst-case time complexity of our backward type inference for the XQuery core.

Theorem 5.10 (Complexity of type inference). Assume we are given an XQuery expression e and its output type ρ. Then a set of
solvable constraint-sets is computed in |e| · 2O (2(|e|+1)|ρ|) time by our inference system. That is, the overall cost is double exponential in 
terms of the size of the given expression e.

|e||ρ|) by Lemma 5.8. The 
Proof. Suppose S ← e : ρ. We obtain S in 2O (2
size of any constraint-set C in S is the number of free variables in e, which is at most |e|. Since the size of the largest type 
|e||ρ|) time by the 
in S is  O (2
|e||ρ|) which is 
decision procedure in [28]. Overall, the complexity of our inference system is 2O (2
simply |e| · 2O (2(|e|+1)|ρ|). (cid:2)

|e||ρ|) by Lemma 5.7, for each constraint-set C in S , its satisﬁability can be tested in |e| · 2O (2

|e||ρ|) time by Lemma 5.9. The size of S is  O (22

|e||ρ|) × |e| · 2O (2

|e||ρ|) + O (22

5.3.  Soundness

Now  we  state  the  soundness  property  for  our  inference  system.  Below  we  use  (cid:26) η : C to  mean  that  if  $var (cid:8)→ s ∈ η, 

then ($var : ρ) ∈ C and s ∈ (cid:2)ρ(cid:3).

Theorem 5.11 (Soundness). Let e and ρ be an XQuery expression and its output type, respectively. Suppose S ← e : ρ. Then for any 
C ∈ S such that C (cid:9)= {⊥}, if  (cid:26) η : C and (cid:2)e(cid:3)η = s, then s ∈ (cid:2)ρ(cid:3).

Proof. By induction on a derivation of S ← e : ρ. Here we only show the case for the rule I-For. Other cases are similarly 
proved. We have the following assumptions:
(1) (cid:25) S ∈S∪S(cid:3) S ← for $v in e1 return e2 : ρ
(2) C0 ∈ (cid:25) S ∈S∪S(cid:3) S and  (cid:26) η : C0
(3) (cid:2)for $v in e1 return e2(cid:3)η = s

Then, we need to prove s ∈ (cid:2)ρ(cid:3).
(4) Let (cid:25) S ∈S∪S(cid:3) S be S1 (cid:25) . . . (cid:25) Sm.
(5) Without loss of generality, let C0 ∈ Si ∈ S

(cid:3)

.

The case for Si ∈ S is similarly proved. From the premises of the rule I-For, we have

(6) S ← e2 : ρ
(7) S (cid:3) ← e2 : ()
(8) C ∈ S and C
(9) S (cid:3)(cid:3) ← e1 : (C
(10) Si = S (cid:3)(cid:3) (cid:24) {C\$v (cid:24) C

(cid:3) ∈ S (cid:3)
(cid:3)($v)∗, C($v), C

(cid:3)\$v}

From (3), we have

(11) (cid:2)e1(cid:3)η = f 1, . . . , fn

(cid:3)($v)∗).Quant(ρ)

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

95

(12) s = (cid:7) f 1,..., fn

(cid:2)e2(cid:3)η,$v (cid:8)→ f i

From (2), (5) and (10),

(13) ∃C

(cid:3)
0

∈ S (cid:3)(cid:3)

such that C0 = C

(cid:3)
0

(cid:24) C\$v (cid:24) C

(cid:3)\$v and  (cid:26) η : C

(cid:3)
0.

By induction hypothesis on (9) with (11) and (13), we have

(14)

f 1, . . . , fn ∈ (cid:2)(C

(cid:3)($v)∗, C($v), C

(cid:3)($v)∗).Quant(ρ)(cid:3).

Assume  Quant(ρ) = 1. The case where  Quant(ρ) = + is similarly proved using the following property: ρ+, . . . , ρ+ <: ρ+
Then, there exists  j such that

. 

(15)
(16)
(17)

f 1, . . . , f j−1 ∈ (cid:2)C
f j ∈ (cid:2)C($v)(cid:3)
f j+1, . . . , fn ∈ (cid:2)C

(cid:3)($v)∗(cid:3) and thus  fk ∈ (cid:2)C

(cid:3)($v)(cid:3) where k = 1, . . . , j − 1

(cid:3)($v)∗(cid:3) and thus  fk ∈ (cid:2)C

(cid:3)($v)(cid:3) where k = j + 1, . . . , n

From (2), (5) and (10), we have  (cid:26) η : C\$v and  (cid:26) η : C

(cid:3)\$v. Together with (15)–(17), we have

(18) (cid:26) η, $v (cid:8)→ f j : C
(19) (cid:26) η, $v (cid:8)→ fk : C

(cid:3)

where k = 1, . . . , j − 1, j + 1, . . . , n

By induction hypothesis on (6) and (7) with (18) and (19), respectively, we have

(20) (cid:2)e2(cid:3)η,$v (cid:8)→ f j
(21) (cid:2)e2(cid:3)η,$v (cid:8)→ fk

∈ (cid:2)ρ(cid:3)
∈ (cid:2)()(cid:3) where k = 1, . . . , j − 1, j + 1, . . . , n

From (20) and (21), we have s = (cid:7) f 1,..., fn

(cid:2)e2(cid:3)η,$v (cid:8)→ f i

∈ (cid:2)ρ(cid:3) as desired. (cid:2)

Unlike the type inference for XPath axes, the type inference for the XQuery core is only sound and not complete, mainly 
because of the approximation introduced for for-loop expressions. From the soundness and the decidability of the inference 
system, we deduce a sound typechecking algorithm as a corollary.

Corollary 5.12 (Typechecking). Let e be an XQuery expression with the only free variable $doc, which denotes an input document. Let 
ρi be an input type (the type for $doc) and ρo an output type. Then there exists a typechecking algorithm that says yes if S ← e : ρo
and ∃C ∈ S such that C (cid:9)= {⊥} and ρi <: C($doc). Combined with the soundness property in Theorem 5.11, for any tree node t ∈ (cid:2)ρi(cid:3), 
if (cid:2)e(t)(cid:3) = s, then s ∈ (cid:2)ρ(cid:3) is guaranteed.

m, u

In the corollary above, the input type ρi should be of the form (ϕ1, u1) | . . . | (ϕn, un) or simply u since it is the type for 
(cid:3)
XML documents, but not for arbitrary XQuery expressions. Indeed, the inferred type  C($doc) is also of the form (ϕ(cid:3)
1) |
(cid:3)
. . . | (ϕ(cid:3)
m).  Moreover,  the  use  of  the  variable  $doc has  no  particular  implication;  it  suﬃces  to  have  a  name  of  some 
(cid:3)
element that is considered as the root in the input type, e.g., e should be of the form let $doc := /self:: ∗ return e
. 
To typecheck a given expression e with the input type ρi and the output type ρo, we ﬁrst infer a constraint-set C from e
and ρo using our backward type inference, and then simply check the inclusion relation between ρi and the inferred type 
C($doc).

1, u

Theorem 5.13 (Complexity of typechecking). Let e be an XQuery expression with only one free variable $doc. Then, given an input type 
ρi of the form (ϕ1, u1) | . . . | (ϕn, un) and an output type ρo, e can be typechecked in 2O (2(|e|+1)|ρo|+|ρi |) time. That is, the complexity 
of typechecking is double exponential in terms of the size of the given expression e.

Proof. Suppose  S ← e : ρo where  S is  a  set  of  solvable  constraint-sets.  S can  be  computed  in  2O (2(|e|+1)|ρ|) time  by 
Theorem 5.10. (Note that there is only one free variable in e.) For the purpose of typechecking, we need to check if there 
exists  C ∈ S such that ρi <: C($doc) holds. We note that ρi ≡ (ϕ1, u1) | . . . | (ϕn, un) can be translated into an equivalent 
formula ψ ≡ (ϕ1 ∧ form(u1)) ∨ . . . ∨ (ϕn ∧ form(un)) of the same size in terms of big O notation and similarly C($doc) into 
ψ (cid:3)
using the decision procedure 
|e||ρo|) by Lemma 5.7, the satisﬁability test can be done in 
in [28]. Since the size of the largest type appearing in S is  O (2
|e||ρo|) by Lemma 5.8, we can check if there 
2O (2
|e||ρo|+|ρi |) time, which is simply 2O (2(|e|+1)|ρo|+|ρi |). Overall, 
exists  C ∈ S such that ρi <: C($doc) holds in  O (22
the complexity of typechecking is double exponential in terms of |e|. (cid:2)

. Then, the subtype check ρi <: C($doc) can be done by testing the satisﬁability of ψ ∧ ¬ψ (cid:3)

|e||ρo|+|ρi |) time in the worst case. Since the size of S is bounded by  O (22

|e||ρo|) × 2O (2

96

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

This result easily extends to the cases where more free variables are used. In such cases, we simply need an input type 

for each free variable and the complexity of typechecking still remains the same.

6.  Related work and discussion

6.1.  Typechecking for XML transformations

The problem of typechecking XML transformations has been extensively studied since the introduction of XML. There are 
two major approaches, namely forward type inference and backward type inference. Given an expression e that transforms 
XML  documents  of  type  ρi into  documents  of  type  ρo ,  forward  type  inference  ﬁrst  computes  the  image  O of  the  input 
type ρi under the transformation e, i.e.,  O  := {e(t) | t ∈ ρi}, and then checks if  O  ⊆ ρo. This approach does not work even 
for simple top-down tree transducers since  O can be beyond context-free tree languages and in this case checking  O  ⊆ ρo
is  undecidable [14].  In  contrast,  backward  type  inference  computes  the  pre-image  J of  the  complement  of  ρo under  e, 
i.e.,  J := {t | e(t) ∈ ¬ρo},  and  then  checks  the  emptiness  of  intersection  of  J and  ρi .  (Or  alternatively,  for  deterministic 
transducers, it may compute the pre-image  I of the output type ρo and then checks if ρi ⊆ I .) When types are modeled as 
regular tree languages, exact typechecking may be done in the form of backward type inference by using tree transducers 
as a model of XML transformations [10–12]. In contrast, in forward type inference, even for simple XML transformations, 
their  image  may  not  be  regular,  as  illustrated  in  Section 5.1.  Therefore,  if  the  type  system  infers  regular  tree  types  for 
admissible outputs, which is often the case in the literature, then typechecking cannot be exact. Still, forward type inference 
is more intuitive than backward type inference, and thus many practical XML programming languages such as XQuery [1,3], 
XDuce [24], and CDuce [34] build on forward type inference and instead introduce some approximation, i.e., some type-safe 
programs are rejected in these languages. For a more detailed, general survey of typechecking for XML transformations, we 
refer the reader to [35,36] and references therein. Below we discuss only closely related work on backward type inference 
and precise type systems for XPath and XQuery.

6.2.  Inverse type inference

A problem of inverse type inference, which is another name of backward type inference, has been extensively investigated 
to develop an exact typechecking algorithm for XML transformations [9–14]. For example, Milo et al. [10] propose an exact 
inverse type inference algorithm for k-pebble tree transducers, which are ﬁnite state transducers that can mark nodes of the 
input tree using up to k different pebbles. Although we can model a broad range of XQuery expressions using k-pebble tree 
transducers, the complexity of typechecking is hyper-exponential, i.e., when using k pebbles, its complexity is  O (hk+2(n))
with h0(n) = n and hm+1(n) = 2hm(n).

Maneth  et  al. [12] also  study  the  problem  of  exact  inverse  type  inference  for  tree  transformations  using  macro  tree 
transducers (MTTs) [15], which can accumulate part of the input and copy it in the output. Their transformation language 
called  TL  uses  monadic  second-order  logic  (MSO)  as  a  pattern  language,  which  subsumes  XPath  without  arithmetics  and 
data value comparisons. By using MTTs and MSO, TL can be used to describe many real-world XML transformations. Their 
formalism, however, is based on ﬁnite automata and thus requires for implementation purposes a translation from MSO to 
a ﬁnite automaton which may introduce a non-elementary blow-up.

Perst and Seidl [11] extend MTTs with concatenation and propose macro forest transducers (MFTs) as a model of XML 
transformations. They develop an exact inverse type inference algorithm for MFTs and show that the complexity of type-
checking  is  DEXPTIME-complete.  Moreover,  by  combining  with  a  translation  from  a  downward  navigational  fragment  of 
XQuery  into  MFTs [37],  MFTs  can  be  used  as  an  intermediate  language  for  a  subset  of  XQuery.  The  translation,  however, 
considers  only  XPath  axes  such  as child, desc,  and following-sibling,  and  a  restricted  form  of  for-loop  expres-
sions, i.e., in for $v in e1 return e2, e1 must be a path expression.

In order to support backward axes, one may use tree-walking automata [38] as a pattern language. Indeed, a k-pebble 
tree transducer can be decomposed into a (k + 1)-fold composition of tree-walking transducers [16]. Similarly, a TL program 
using MSO patterns can be compiled into a composition of an MTT and a macro tree-walking transducer, which can then 
be decomposed into a three-fold composition of (stay) MTTs [12]. Therefore, the complexity of typechecking a TL program 
is  quadruple  exponential  even  if  we  do  not  consider  a  possible  blow-up  in  the  translation  of  MSO  patterns  to  ﬁnite  au-
tomata. In this paper, we also study the problem of backward type inference, but develop a type inference system directly 
on  the  XQuery  core.  We  present  an  exact  backward  type  inference  algorithm  for  XPath  axes  whose  complexity  is  simple 
exponential. This result corresponds to the fact that the complexity of inverse type inference for tree-walking transducers 
is also exponential [16]. As for the XQuery core, instead of trying to develop yet another hyper-exponential algorithm, we 
introduce a sound approximation similar to the one used in forward type systems.

6.3.  Precise type systems for XPath and XQuery

Typing XPath expressions has been a challenging topic. Most previous proposals for the XQuery static type system, in-
cluding  the  one  standardized  by  the  W3C [3],  support  only  downward  navigation  in  XML  trees.  As  thoroughly  discussed 
in [19], it is mainly due to the discrepancy between the XML data model and the type model, namely regular tree types [2]. 

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

97

Since XPath backward axes are the main source of diﬃculty, one may want to translate XPath selection queries with back-
ward axes into equivalent queries with only forward axes. Olteanu et al. [39,40] propose such translations which generate 
a query containing the same number of joins, i.e., identity-based equality, as reverse steps or a query without joins but of 
exponential size. The translations, however, are deﬁned only for XPath and it is unclear how to extend them to deal with 
XQuery-like  languages.  Møller  et  al. [41] propose  static  typechecking  for  XSLT [42] programs  which  builds  on  a  context-
sensitive ﬂow analysis. Although they introduce some approximation for abstract evaluation of XPath axes with respect to 
DTDs,  they  experimentally  validate  using  a  number  of  benchmarks  that  their  algorithm  is  highly  precise.  Benzaken  et  al. 
develop a precise type inference system for XPath in their work on type-based XML projection [43]. Their system handles 
backward axes and is also sound and complete for a particular class of regular tree types that are ∗-guarded, non-recursive, 
and parent-unambiguous. In contrast, our inference system for XPath axes is exact with no such restrictions on types.

Benedikt and Cheney [44] propose a type system for the XQuery Update Facility language [45] assuming the existence 
of a sound typechecker for XPath axes. In the work on independence analysis of XML queries and updates [46], they use 
satisﬁability  solvers [20,47,48] to  decide  disjointness  of  selection  queries,  which  may  contain  backward  axes.  In  [47,48], 
weak  monadic  second-order  logic  of  two  successors  (WS2S) [49] is  used,  which  is  one  of  the  most  expressive  decidable 
logic when both regular tree types and XML queries are considered. However, the satisﬁability problem for WS2S is known 
to  be  non-elementary.  Our  work  is  based  on  the  tree  logic  and  its  associated  satisﬁability  solver  used  in  [20].  The  main 
difference is that while [20] considers only XPath, we consider a core fragment of XQuery including element construction. 
Moreover, while in [20] values are deﬁned as sets of nodes, in this work they are deﬁned as sequences of nodes which may 
come from different trees and also retain their original tree context independently for navigation.

Kobayashi et al. [22] propose higher-order multi-parameter tree transducers (HMTTs) and study their veriﬁcation prob-
lems, where input and output speciﬁcations are given as regular tree languages and check if the trees generated by a given 
HMTT conform to the output speciﬁcation, given input trees satisfying the input speciﬁcation. They translate an HMTT ver-
iﬁcation problem into a model checking problem for higher-order recursion schemes with ﬁnite data domains, which can 
be solved by using an extension of the model checking algorithm for recursion schemes proposed in [50]. Their algorithm 
is sound but incomplete for general HMTTs. It is, however, both sound and complete for linear HMTTs which traverse each 
input  tree  at  most  once.  Although  the  complexity  of  the  algorithm  is  hyper-exponential,  Kobayashi et  al.  experimentally 
show that practical implementation is feasible. Since linear HMTTs subsume macro tree transducers, many XML typecheck-
ing problems can also be translated into linear HMTT veriﬁcation problems (through several intermediate steps). However, 
it is unclear and should be further investigated how to address those programs involving XPath backward axes based on the 
HMTT veriﬁcation method.

Recently, Castagna et al. [17] and Genevès and Gesbert [19] independently propose an extended type language to describe 
not  only  a  given  XML  tree  node  but  also  its  context.  In  [17],  the  authors  extend  the  core  calculus  of  CDuce [34] with 
zipper  data  structures [18],  which  denote  the  position  in  the  surrounding  tree  of  the  value  they  annotate  as  well  as  its 
current  path  from  the  root.  By  annotating  not  only  values  but  also  types  with  zippers,  they  allow  tree  navigation  in  any 
direction  and  typecheck  such  navigational  expressions  precisely  (in  their  work,  zipped  values  and  zipped  types  play  a 
similar  role  as  focused  trees  and  formula-enriched  sequence  types,  respectively).  Unlike  our  type  system,  however,  their 
typechecking is not exact for XPath axes. For example, when $v is of type element ∗ {< A/>, <B/>, <C/>}, the type of 
$v/child::∗ is deduced as an approximate type (< A/> | <B/> | <C/>)∗
instead of an exact type (< A/>, <B/>, <C/>). 
More  precisely,  in  [17],  a  sequence  type  (ρ1, . . . , ρn) is  approximated  into  a  more  general  repetition  type  of  the  form 
(ρ1 | . . . | ρn)∗
. In contrast, when $v/child::∗ is of type (< A/>, <B/>, <C/>), our backward type system infers an exact 
type element ∗ {< A/>, <B/>, <C/>} for $v. Meanwhile, Castagna et al. [17] also propose a translation from XQuery 3.0 
core [7,51], with newly added value and type case analysis and higher-order functions, into the extended CDuce and provide 
a type system for XQuery 3.0 via the translation. In contrast to [17], currently we do not support function declarations and 
applications, and thus higher-order functions as well. However, because regular tree types extended with arrow types can 
be translated into tree logic formulas and their subtype relation can be decided through the logic’s decision procedure [52], 
we expect that our type system can be extended with higher-order functions at least in theory.

This work builds on our previous work [19] which proposes the idea of using focused trees to denote XML values and 
of combining regular tree types with tree logic formulas to describe both tree nodes and their contexts simultaneously, and 
thus  supports  all  the  major  navigational  features  of  the  XQuery  core.  The  main  difference  is  that  while  we  use  forward 
inference in [19], we use backward inference in this work. Our backward type inference is arguably more complex because 
we need to analyze the structure of the output type as well as the given expression (in particular, inference rules for for-loop 
expressions are simpler in [19]), but as a trade-off it provides an exact typechecking algorithm for XPath axes (typechecking 
for  XPath  axes  is  not  exact  in  [19]).  Another  difference  is  that  while  we  use  a  small-step  operational  semantics  for  the 
XQuery core in [19], we use a denotational semantics in this work because it is more suitable for proving properties of our 
backward type inference. Considering all these aspects, it would be quite interesting to combine the two approaches.

7.  Conclusion

In  this  paper,  we  propose  a  novel  backward  type  inference  system  for  XQuery  as  an  alternative  method  to  forward 
type inference. Speciﬁcally, the contributions of the paper are summarized as follows. First, we deﬁne a focused-tree-based 
denotational semantics for a navigational fragment of XQuery, including all major XPath axes. Second, we propose a novel 

98

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

tree-logic-based backward type inference system for XPath axes and prove its soundness and completeness. In contrast to 
ours, forward type inference is only sound. Finally, based on this result, we propose a sound backward type inference system 
for the XQuery core, with a characterized complexity.

An interesting direction for future work would be to develop a bidirectional typechecking algorithm by combining both 
backward  and  forward  type  inference  methods.  The  basic  idea  is  to  typecheck  for-loop  expressions  using  forward  type 
inference, thus obtaining a lower complexity than our backward approach, while typechecking XPath axes using backward 
type  inference,  thus  obtaining  better  precision  than  the  forward  approaches  such  as  in [17,19].  In  doing  so,  one  possible 
diﬃculty would be to ﬁnd minimal type annotations to enable effective bidirectional typechecking.

Declaration of competing interest

The  authors  declare  that  they  have  no  known  competing  ﬁnancial  interests  or  personal  relationships  that  could  have 

appeared to inﬂuence the work reported in this paper.

Acknowledgement

The  authors  thank  the  anonymous  reviewers  for  their  helpful  comments.  This  work  was  supported  by  the  National 
Research  Foundation  of  Korea  (NRF)  grant  funded  by  the  Korea  government  (MSIP)  (No.  2016R1C1B1015095)  and  by  the 
ANR project CLEAR (ANR-16-CE25-0010).

References

[1] S. Boag, D. Chamberlin, M. Fernández, D. Florescu, J. Robie, J. Siméon, XQuery 1.0: An XML Query Language, second edition, W3C Recommendation, 

December 2010, https://www.w3 .org /TR /2010 /REC -xquery-20101214/.

[2] H. Hosoya, J. Vouillon, B.C. Pierce, Regular expression types for XML, ACM Trans. Program. Lang. Syst. 27 (1) (2005) 46–90, https://doi .org /10 .1145 /

1053468 .1053470.

19991116/.

[3] D. Draper, M. Dyck, P. Fankhauser, M. Fernández, A. Malhotra, K. Rose, M. Rys, J. Siméon, P. Wadler, XQuery 1.0 and XPath 2.0 Formal Semantics, second 

edition, W3C Recommendation, December 2010, http://www.w3 .org /TR /xquery-semantics/.

[4] J.  Clark,  S.  DeRose,  XML  Path  Language  (XPath)  Version  1.0,  W3C  Recommendation,  November  1999,  https://www.w3 .org /TR /1999 /REC -xpath -

[5] A. Berglund, S. Boag, D. Chamberlin, M.F. Fernández, M. Kay, J. Robie, J. Siméon, XML Path Language (XPath) 2.0, second edition, W3C Recommendation, 

December 2010, http://www.w3 .org /TR /xpath20.

[6] J. Robie, D. Chamberlin, M. Dyck, J. Snelson, XML Path Language (XPath) 3.0, W3C Recommendation, April 2014, http://www.w3 .org /TR /xpath -30/.
[7] J. Robie, D. Chamberlin, M. Dyck, J. Snelson, XQuery 3.0: An XML Query Language, W3C Recommendation, April 2014, http://www.w3 .org /TR /xquery-

[8] D. Colazzo, C. Sartiani, Precision and complexity of XQuery type inference, in: Proceedings of the 13th International ACM SIGPLAN Symposium on 

Principles and Practices of Declarative Programming, PPDP ’11, 2011, pp. 89–100.

[9] A. Tozawa, Towards static type checking for XSLT, in: ACM Symposium on Document Engineering, 2001, pp. 18–27.
[10] T. Milo, D. Suciu, V. Vianu, Typechecking for XML transformers, J. Comput. Syst. Sci. 66 (1) (2003) 66–97, https://doi .org /10 .1016 /S0022 -0000(02 )00030 -

30/.

2.

[11] T. Perst, H. Seidl, Macro forest transducers, Inf. Process. Lett. 89 (3) (2004) 141–149, https://doi .org /10 .1016 /j .ipl .2003 .05 .001.
[12] S. Maneth, A. Berlea, T. Perst, H. Seidl, XML type checking with macro tree transducers, in: Proceedings of the Twenty-Fourth ACM SIGMOD-SIGACT-

SIGART Symposium on Principles of Database Systems, PODS ’05, 2005, pp. 283–294.

[13] A. Tozawa, XML type checking using high-level tree transducer, in: Proceedings of the 8th International Symposium on Functional and Logic Program-

ming, FLOPS ’06, 2006, pp. 81–96.

[14] A. Frisch, H. Hosoya, Towards practical typechecking for macro tree transducers, in: Proceedings of the 11th International Conference on Database 

Programming Languages, DBPL’07, Springer-Verlag, 2007, pp. 246–260.

[15] J. Engelfriet, H. Vogler, Macro tree transducers, J. Comput. Syst. Sci. 31 (1) (1985) 71–146, https://doi .org /10 .1016 /0022 -0000(85 )90066 -2.
[16] J. Engelfriet, The time complexity of typechecking tree-walking tree transducers, Acta Inform. 46 (2) (2009) 139–154, https://doi .org /10 .1007 /s00236 -

[17] G. Castagna, H. Im, K. Nguyen, V. Benzaken, A core calculus for XQuery 3.0: combining navigational and pattern matching approaches, in: Proceedings 

of the 24th European Symposium on Programming, 2015, pp. 232–256.

[18] G. Huet, The zipper, J. Funct. Program. 7 (5) (1997) 549–554, https://doi .org /10 .1017 /S0956796897002864.
[19] P. Genevès, N. Gesbert, XQuery and static typing: tackling the problem of backward axes, in: Proceedings of the 20th ACM SIGPLAN International 

Conference on Functional Programming, 2015, pp. 88–100.

[20] P. Genevès, N. Layaïda, A. Schmitt, Eﬃcient static analysis of XML paths and types, in: Proceedings of the 28th ACM SIGPLAN Conference on Program-

ming Language Design and Implementation, PLDI ’07, 2007, pp. 342–351.

[21] S. Maneth, T. Perst, H. Seidl, Exact XML type checking in polynomial time, in: Proceedings of the 11th International Conference on Database Theory, 

ICDT’07, Springer-Verlag, Berlin, Heidelberg, 2006, pp. 254–268.

[22] N. Kobayashi, N. Tabuchi, H. Unno, Higher-order multi-parameter tree transducers and recursion schemes for program veriﬁcation, in: Proceedings of 
the 37th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’10, ACM, New York, NY, USA, 2010, pp. 495–508.
[23] N. Alon, T. Milo, F. Neven, D. Suciu, V. Vianu, XML with data values: typechecking revisited, J. Comput. Syst. Sci. 66 (4) (2003) 688–727, https://

008 -0087 -y.

doi .org /10 .1016 /S0022 -0000(03 )00032 -1.

767193 .767195.

[24] H. Hosoya, B.C. Pierce, XDuce: a statically typed XML processing language, ACM Trans. Internet Technol. 3 (2) (2003) 117–148, https://doi .org /10 .1145 /

[25] M. Murata, D. Lee, M. Mani, K. Kawaguchi, Taxonomy of XML schema languages using formal language theory, ACM Trans. Internet Technol. 5 (4) 

(2005) 660–704, https://doi .org /10 .1145 /1111627.1111631.

[26] R.M. Amadio, L. Cardelli, Subtyping recursive types, ACM Trans. Program. Lang. Syst. 15 (4) (1993) 575–631, https://doi .org /10 .1145 /155183 .155231.
[27] A. Brüggemann-Klein, D. Wood, One-unambiguous regular languages, Inf. Comput. 140 (2) (1998) 229–253, https://doi .org /10 .1006 /inco .1997.2688.

H. Im et al. / Theoretical Computer Science 823 (2020) 69–99

99

[28] P. Genevès, N. Layaïda, A. Schmitt, N. Gesbert, Eﬃciently deciding μ-calculus with converse over ﬁnite trees, ACM Trans. Comput. Log. 16 (2) (2015) 

16, https://doi .org /10 .1145 /2724712.

[29] M. Wand, A simple algorithm and proof for type inference, Fundam. Inform. 10 (1987) 115–122.
[30] F. Pottier, Simplifying subtyping constraints: a theory, Inf. Comput. 170 (2) (2001) 153–183, https://doi .org /10 .1006 /inco .2001.2963.
[31] G.M. Bierman, A.D. Gordon, C. Hri ¸tcu, D. Langworthy, Semantic subtyping with an SMT solver, J. Funct. Program. 22 (1) (2012) 31–105, https://doi .org /

10 .1017 /S0956796812000032.

(2008) 19, https://doi .org /10 .1145 /1391289 .1391293.

[32] A. Frisch, G. Castagna, V. Benzaken, Semantic subtyping: dealing set-theoretically with function, union, intersection, and negation types, J. ACM 55 (4) 

[33] S. Heubach, T. Mansour, Combinatorics of Compositions and Words, Chapman and Hall/CRC, 2009.
[34] V. Benzaken, G. Castagna, A. Frisch, CDuce: an XML-centric general-purpose language, in: Proceedings of the Eighth ACM SIGPLAN International Con-

[35] A. Møller, M.I. Schwartzbach, The design space of type checkers for XML transformation languages, in: Proceedings of the 10th International Conference 

ference on Functional Programming, ICFP ’03, 2003, pp. 51–63.

on Database Theory, ICDT ’05, Springer-Verlag, 2005, pp. 17–36.

[36] V.  Benzaken,  G.  Castagna,  H.  Hosoya,  B.C.  Pierce,  S.  Vansummeren,  XML  typechecking,  in:  Encyclopedia  of  Database  Systems,  Springer  US,  2009, 

[37] S. Hakuta, S. Maneth, K. Nakano, H. Iwasaki, XQuery streaming by forest transducers, in: IEEE 30th International Conference on Data Engineering, 

[38] A. Aho, J. Ullman, Translations on a context free grammar, Inf. Control 19 (5) (1971) 439–475, https://doi .org /10 .1016 /S0019 -9958(71 )90706 -6.
[39] D. Olteanu, H. Meuss, T. Furche, F. Bry, XPath: looking forward, in: XML-Based Data Management and Multimedia Engineering — EDBT 2002 Workshops, 

[40] D. Olteanu, Forward node-selecting queries over trees, ACM Trans. Database Syst. 32 (1) (2007), https://doi .org /10 .1145 /1206049 .1206052.
[41] A. Møller, M.O. Olesen, M.I. Schwartzbach, Static validation of XSL transformations, ACM Trans. Program. Lang. Syst. 29 (4) (2007), https://doi .org /10 .

[42] J. Clark, XSL Transformations (XSLT) Version 1.0, W3C Recommendation, November 1999, https://www.w3 .org /TR /1999 /REC -xslt -19991116.
[43] V. Benzaken, G. Castagna, D. Colazzo, K. Nguyen, Optimizing XML querying using type-based document projection, ACM Trans. Database Syst. 38 (1) 

[44] M. Benedikt, J. Cheney, Semantics, types and effects for XML updates, in: Proceedings of the 12th International Symposium on Database Programming 

Languages, DBPL ’09, Springer-Verlag, 2009, pp. 1–17.

[45] J. Robie, D. Chamberlin, M. Dyck, D. Florescu, J. Melton, J. Siméon, XQuery Update Facility 1.0, W3C Recommendation, March 2011, http://www.w3 .org /

[46] M. Benedikt, J. Cheney, Destabilizers and independence of XML updates, Proc. VLDB Endow. 3 (1–2) (2010) 906–917, https://doi .org /10 .14778 /1920841.

[47] N. Klarlund, A. Møller, MONA Version 1.4 User Manual, BRICS, January 2001.
[48] P. Genevès, N. Layaïda, Deciding XPath containment with MSO, Data Knowl. Eng. 63 (1) (2007) 108–136, https://doi .org /10 .1016 /j .datak.2006 .11.003.
[49] J. Doner, Tree acceptors and some of their applications, J. Comput. Syst. Sci. 4 (5) (1970) 406–451, https://doi .org /10 .1016 /S0022 -0000(70 )80041 -1.
[50] N. Kobayashi, Model-checking higher-order functions, in: Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative 

Programming, PPDP ’09, ACM, New York, NY, USA, 2009, pp. 25–36.

[51] M. Benedikt, H. Vu, Higher-order functions and structured datatypes, in: Proceedings of the 15th International Workshop on the Web and Databases, 

WebDB 2012, 2012, pp. 43–48.

[52] N. Gesbert, P. Genevès, N. Layaïda, Parametric polymorphism and semantic subtyping: the logical connection, in: Proceedings of the 16th ACM SIGPLAN 

International Conference on Functional Programming, ICFP ’11, 2011, pp. 107–116.

pp. 3646–3650.

ICDE ’14, 2014, pp. 952–963.

2002, pp. 109–127.

1145 /1255450 .1255454.

(2013) 4.

TR /xquery-update -10/.

1920956.

