Approximate Querying on Property Graphs
Stefania Dumbrava, Angela Bonifati, Amaia Nazabal Ruiz Diaz, Romain

Vuillemot

To cite this version:

Stefania Dumbrava, Angela Bonifati, Amaia Nazabal Ruiz Diaz, Romain Vuillemot. Approximate
Querying on Property Graphs. SUM 2019 - 13th international conference on Scalable Uncertainty
Management, Dec 2019, Compiègne, France. pp.250-265,
￿hal-
02417259￿

￿10.1007/978-3-030-35514-2_19￿.

HAL Id: hal-02417259

https://hal.science/hal-02417259

Submitted on 18 Dec 2019

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Approximate Querying on Property Graphs

Stefania Dumbrava1, Angela Bonifati2, Amaia Nazabal Ruiz Diaz2, and
Romain Vuillemot3

1 ENSIIE ´Evry & CNRS Samovar
stefania.dumbrava@ensiie.fr
2 University of Lyon 1 & CNRS LIRIS
{angela.bonifati,amaia.nazabal-ruiz-diaz}@univ-lyon1.fr
3 ´Ecole Centrale Lyon & CNRS LIRIS
romain.vuillemot@ec-lyon.fr

Abstract. Property graphs are becoming widespread when modeling
data with complex structural characteristics and enriching edges and
nodes with a list of properties. In this paper, we focus on the approxi-
mate evaluation of counting queries involving recursive paths on property
graphs. As such queries are already diﬃcult to evaluate over pure RDF
graphs, they require an ad-hoc graph summary for their approximate
evaluation on property graphs. We prove the intractability of the op-
timal graph summarization problem, under our algorithm’s conditions.
We design and implement a novel property graph summary suitable for
the above queries, along with an approximate query evaluation module.
Finally, we show the compactness of the obtained summaries as well as
the accuracy of answering counting recursive queries on them.

1

Introduction

A tremendous amount of information stored in the LOD can be inspected, by
leveraging the already mature query capabilities of SPARQL, relational, and
graph databases [14]. However, arbitrarily complex queries [2, 3, 7], entailing
rather intricate, possibly recursive, graph patterns prove diﬃcult to evaluate,
even on small-sized graph datasets [4, 5]. On the other hand, the usage of these
queries has radically increased in real-world query logs, as shown by recent
empirical studies on SPARQL queries from large-scale Wikidata and DBPe-
dia corpuses [8, 17]. As a tangible example of this growth, the percentage of
SPARQL property paths has increased from 15% to 40%, from 2017 to begin-
ning 2018 [17], for user-speciﬁed Wikidata queries. In this paper, we focus on
regular path queries (RPQs) that identify paths labeled with regular expres-
sions and aim to oﬀer an approximate query evaluation solution. In particular,
we consider counting queries with regular paths, which are a notable fragment
of graph analytical queries. The exact evaluation of counting queries on graphs
is #P −complete [21] and is based on another result on enumeration of simple
graph paths. Due to this intractability, an eﬃcient and highly-accurate approxi-
mation of these queries is desirable, which we address in this paper.

2

S.Dumbrava, A.Bonifati, A.Diaz, R.Vuillemot

l4

l4

l4

P3

P1

P2

l0

l0

l1

l0

l0

P6

P4

l1

P7

l0

P9

l0

l0

l0

P5

l1

P8

l0

l0

l0

P10

l4

l2

l4

l6

l2

R1

R2

l5

l5

R3

l5

R4

l5

M1

M2

M3

l3

l3

F1

l3

l4

l4

R5

R6

R7

l5

l5

l5

M4

M5

M6

l3

l3

l3

F2

Ans(count( )) ← l5( , )
Q1(l5)
Ans(count( )) ← l2?( , )
Q2(l2)
Ans(count( )) ← l+
0 ( , )
Q3(l0)
Ans(count( )) ← l∗
Q4(l0)
0 ( , )
Q5(l4, l1) Ans(count( )) ← l4 + l1( , )
Q6(l4, l5) Ans(count( )) ← l−
4 · l5( , )
Q7(l4, l5) Ans(count(x)) ← l−
4 · l5(x, ), ≥ (x.age, 18),
≤ (x.age, 24).

Forum

Message

Reply

Person

knows (l0)

follows (l1) moderates (l2)

contains (l3)

authors (l4)

replies (l5)

reshares (l6)

Fig. 2: Targeted Advertising Queries

Fig. 1: Example Social Graph GSN

Approximate query processing on relational data and the related sampling
methods are not applicable to graphs, since the adopted techniques are based on
the linearity assumption [15], i.e., the existence of a linear relationship between
the sample size and execution time, typical of relational query processing. As
such, we design a novel query-driven graph summarization approach tailored for
property graphs. These signiﬁcantly diﬀer from RDF and relational data models,
as they attach data values to property lists on both nodes and edges [7].

To the best of our knowledge, ours is the ﬁrst work on approximate prop-
erty graph analytics addressing counting estimation on top of navigational graph
queries. We illustrate our query fragment with the running example below.
Example 1 (Social Network Advertising). Let GSN (see Fig. 1) be a property
graph (see Sec. 2) encoding a social network, whose schema is inspired by the
LDBC benchmark [12] 4. Entities are people (type Person, Pi) that know (l0)
and/or follow (l1) either each other or certain forums (type Forum, Fi). These
are moderated (l2) by speciﬁc persons and can contain (l3) messages/ads (type
Message, Mi), to which persons can author (l4) other messages in reply (l5).

We focus on a RPQ [3, 23] dialect with counting, capturing following query
types (Q1 −Q7) (see Fig. 2): (1) Simple/Optional Label. The number of pairs sat-
isfying Q1, i.e., () l5−→(), counts the ad reactions, while that for Q2, i.e., () l2?−−→(),
indicates the number of potential moderators. (2) Kleene Plus/Kleene Star. The
number of the connected /potentially connected acquaintances is the count of node
pairs satisfying Q3, i.e., () ← l+
0(). (3) Disjunc-
tion. The number of the targeted subscribers is the sum of counting all node pairs
satisfying Q5, i.e., () l4←−() or () l1←−(). (4) Conjunction. The direct reach of a com-
pany via its page ads is the count of node pairs satisfying Q6, i.e., () l4←−() l5−→().
(5) Conjunction with Property Filters. Recommendation systems can further re-
ﬁne the Q6 estimates. Thus, one can compute the direct demographic reach and
target people within an age group, e.g., 18-24, by counting all node pairs that
satisfy Q7, i.e. (x) l4←−() l5−→(), s.t x.age ≥ 18 and x.age ≤ 24.

0 (), respectively, Q4, i.e., () ← l∗

4 One of the few benchmarks currently available for generating property graphs.

Approximate Querying on Property Graphs

3

Contributions. Our paper provides the following main contributions:

– We design a property graph summarization algorithm for approximately

evaluating counting regular path queries (Sec. 3).

– We prove the intractability of the optimal graph summarization problem

under the conditions of our summarization algorithm (Sec. 3).

– We deﬁne a query translation module, ensuring that queries on the initial
and summary property graphs are expressible in the same fragment (Sec. 4).
– Based on this, we experimentally exhibit the small relative errors of various
workloads, in the expressive query fragment from Example 1. We measure
the relative response time between estimating counting recursive queries on
summaries and on the original graphs. For non-recursive queries, we compare
with SumRDF [19], a baseline graph summary for RDF datasets (Sec. 5).

In Section 2, we revisit the property graph model and query language. We present
related work in Section 6 and conclude the paper in Section 7.

2 Preliminaries

Graph Model. We take the property graph model (PGM) [7] as our foundation.
Graph instances are multi-edge digraphs; its objects are represented by typed,
data vertices and their relationships, by typed, labeled edges. Vertices and edges
can have any number of properties (key/value pairs). Let LV and LE be disjoint
sets of vertex (edge) labels and G = (V, E), with E ⊆ V × LE × V , a graph
instance. Vertices v ∈ V have an id label, lv, and a set of property labels (at-
tributes, li), each with a (potentially undeﬁned) term value. For e ∈ E, we use
the binary notation e = le(v1, v2) and abbreviate v1, as e.1, and v2, as e.2. We
denote the number of occurrences of le, as #le, and the set of all edge labels in
G, as Λ(G). Other key notations henceforth used are given in Table 1.

G, Φ, v, V, e, E (cid:44) Graph, graph partitioning, vertex (set), edge (set)

G∗, v∗, V ∗, e∗, E∗ (cid:44) S-graph, s-node (set), s-edge (set)
ˆG, ˆv, ˆV , ˆe, ˆE (cid:44) H-graph, h-node (set), h-edge (set)

λ(G) (cid:44) label on which a graph G is maximally l-connected

Λd(v∗), d ∈ {1, 2} (cid:44) set of edge labels with direction d w.r.t v∗ (1-incoming, 2-outgoing)

Table 1: Notation Table

Graph Query Language. To query the above property graph model, we rely on
an RPQ [10,11] fragment with aggregate operators (see Fig. 3). RPQs correspond
to SPARQL 1.1 property paths and are a well-studied query class tailored to
express graph patterns of one or more label-constrained reachability paths. For
lk
labels li
e−→
vk, is the concatenation l1
e . In their full generality, RPQs allow one
to select vertices connected via such labeled paths in a regular language over

e and vertices vi, the labeled path π, corresponding to v1

l1
e−→ v2 . . . vk−1

e · . . . · lk

4

S.Dumbrava, A.Bonifati, A.Diaz, R.Vuillemot

Clauses C ::= A ← A1, . . . , An | Q ← A1, . . . , An
Queries Q ::= Ans(count( )) | Ans(count(lv)) | Ans(count(lv1 , lv2 ))
Atoms A ::= π(lv1 , lv2 ) | op(lv1 .li, lv2 .lj) | op(lv1 .li, k), op ∈ {<, ≤, >, ≥}, k ∈ R
Paths π ::= (cid:15) | le | le? | l−1

e | le1 · le2 | π + π

| l∗

e

Fig. 3: Graph Query Language

LE. We restrict RPQs to handle atomic paths – bi-directional, optional, single-
labeled (le, le?, and l−
e ) and transitive single-labeled (l∗
e) – and composite paths
– conjunctive and disjunctive composition of atomic paths (le · le and π + π).
While not as general as SPARQL, our fragment already captures more than 60%
of the property paths found in practice in SPARQL query logs [8]. Moreover, it
captures property path queries, as found in the large Wikidata corpus studied
in [9]. Indeed, almost all the property paths in the considered logs contain Kleene-
star expressions over single labels. In our work, we enrich the above query classes
with the count operator and support basic graph reachability estimates.

3 Graph Summarization

We introduce a novel algorithm that summarizes any property graph into one
tailored for approximately counting reachability queries. The key idea is that,
as nodes and edges are compressed, informative properties are iteratively added
to the corresponding newly formed structures, to enable accurate estimations.

The grouping phase (Sec. 3.1) computes Φ, a label-driven G-partitioning
into subgroupings, following the connectivity on the most frequent labels in G. A
ﬁrst summarization collapses the vertices and inner-edges of each subgrouping
into s-nodes and the edges connecting s-nodes, into s-edges. The merge phase
(Sec. 3.2), based on further label-reachability conditions, speciﬁed by a heuristic
mode m, collapses s-nodes into h-nodes and s-edges into h-edges.

3.1 Grouping Phase

For each frequently occurring label l in G, in descending order, we iteratively
partition G into Φ, containing components that are connected on l, as below.

Deﬁnition 1 (Maximal L-Connectivity). A G-subgraph5, G(cid:48) = (V (cid:48), E(cid:48)), is
maximally l-connected, i.e., λ(G(cid:48)) = l, iﬀ 1) G(cid:48) is weakly-connected, 2) removing
any l-labeled edge from E(cid:48), there exists a V (cid:48) node pair not connected by a l+-
labeled undirected path, 3) no l-labeled edge connects a V (cid:48) node to V \ V (cid:48).

Example 2. In Fig. 1, G1 is maximally l0-connected, since it is weakly-connected,
not connected by an l0-labeled edge to the rest of G, and such that, by removing
P8

l0−→ P9, no undirected, l+

0 -labeled path unites P8 and P9.

5 G(cid:48) is a G-subgraph iﬀ V (cid:48) ⊆ V and E(cid:48) ⊆ E and is weakly connected iﬀ there exists an

undirected path between any pair of vertices.

Approximate Querying on Property Graphs

5

l4

l4

l4

l4

l4

l4

R1

R2

l5

l5

R3

l5

R4

l5

M1

M2

M3

l4

R5

l3

l5

R6

R7

l5

l5

v∗
1

l4

l6

l4

l2

l4
l3

l4

l4

v∗
4

l3

v∗
7

v∗
3

l3

v∗
6

l3

l3

l3

v∗
9

v∗
2

l4
v∗
5

l2

v∗
8

(b) Evaluation Phase

l2

l3

M4

M5

M6

l3

l3

l3

l2

F1

F2

l3

G2

ˆv1

l4

ˆv2

l4

P1

P2

P3

l0

l0

l0

l0

P4
l1

l0

l0

l1

P7

P6

l0

l0

l6

P5

l1

P8

l0

l0

P10

P9

l0

G1

G3

Grouping

Subgrouping

(a) Grouping Phase

l6

l2

ˆv3

l3

ˆv1

l3

ˆv4

l6

l4

l2

ˆv2

ˆv3

l3

Fig. 4: Summarization Phases for GSN

(c) Source and Target Merge

We call each such component a subgrouping. The procedure (see Alg.1) com-
putes, as the ﬁrst grouping, all the subgroupings for the most frequent label, l1,
and then identiﬁes those corresponding to the rest of the graph and to l2. At
the end, all remaining nodes are collected into a ﬁnal subgrouping. We illustrate
this in Fig. 4, on the running example below.

Example 3 (Grouping). In Fig. 1, #l0 = 11, #l1 = 3, #l2 = 2, #l3 = 6, #l4 =
−−−→
Λ(G) = [l0, l5, l4, l3, l1, l2, l6], as #l4 = #l5 allows arbi-
#l5 = 7, #l6 = 1, and
trary ordering. We add the maximal l0-connected subgraph, G1, to Φ. Hence, V =
{Ri∈1,7, Mi∈1,6, F1, F2}. Next, we add G2, regrouping the maximal l5-connected
subgraph. Hence, V = {F1, F2}; we add G3 and output Φ = {G1, G2, G3}.

−−−→
Λ(G) ← [l1, . . . , ln], Φ ← ∅, i ← 1
−−−→
Λ(G) do
k = (V ∗

Algorithm 1 GROUPING(G)
Input: G – a graph; Output: Φ – a graph partitioning
1: n ← |Λ(G)|,
2: for all li ∈
3: Φ ← Φ ∪ {G∗
4: V ← V \ {v ∈ V ∗
5:
6: Φ ← Φ ∪ {Gi = (V ∗
7: return Φ

k , E∗
k | k ∈ N}

k) ⊆ G | λ(G∗

i = V \ V ∗}

i ) ⊆ G | V ∗

i ← i + 1

k) = li}

i , E∗

(cid:46)Descending frequency label list

−−−→
Λ(G)
(cid:46)Label-driven partitioning computation
(cid:46)Maximally li-Connected Subgraphs
(cid:46)Discard Already Considered Nodes

(cid:46)Collect Remains in Final Subgroup

A G-partitioning Φ (see Fig. 4a) is transformed into a s-graph G∗ = (V ∗, E∗)
(see Fig. 4b). As such, each s-node gathers all the nodes and inner edges of a
Φ-subgrouping, G∗
j , and each s-edge, all same-labeled cross-edges (edges between
pairwise distinct s-nodes). During this phase, we compute analytics concerning
the regrouped entities. We leverage PGM’s expressivity to internalize these as

6

S.Dumbrava, A.Bonifati, A.Diaz, R.Vuillemot

4, v∗

properties, e.g., Fig. 5 (right)6. Hence, to every s-edge, e∗, we attach EW eight,
its number of compressed edges, e.g., in Fig. 4b, all s-edges have weight 1, except
e∗(v∗
1), with weight 2. To every s-node, v∗, we attach properties concerning:
(1) Compression. VWeight and EWeight store its number of inner vertices/edges.
(2) Inner-Connectivity. The percentage of its l-labeled inner edges is LPercent
and the number of its vertex pairs, connected with an l-labeled edge, is LReach.
These ﬁrst two types of properties will be useful in Sec.4, for estimating Kleene
paths, as the labels of inner-edges in s-nodes are not unique, e.g., both l0 and
l1 appear in v∗
1. (3) Outer-Connectivity. For pairs of labels and direction indices
with respect to v∗ (d = 1, for incoming edges, and d = 2, for outgoing ones), we
compute cross-connectivity, CReach, as the number of binary cross-edge paths
that start/end in v∗. Analogously, we record that of binary traversal paths, i.e.,
formed of an inner v∗ edge and of a cross-edge, as T Reach. Also, for a label l
and given direction, we store, as VF , the number of frontier vertices on l, i.e.,
that of v∗ nodes at either endpoint of a l-labeled s-edge.

We can thus record traversal connectivity information, LP art, dividing the
number of traversal paths by that of the frontier vertices on the cross-edge label.
Intuitively, this is due to the fact that, traversal connectivity, as opposed to cross
connectivity, also needs to account for the “dispersion” of the inner-edge label
of the path, within the s-node it belongs to. For example, for a traversal path
lc · li, formed of a cross-edge, lc, and an inner one, li, not all frontier nodes lc
are endpoints of li labeled inner-edges, as we will see in the example below.

1 (cid:55)→ 10, v∗
VW eight v∗
v∗
4 (cid:55)→ 3, v∗
1 (cid:55)→ 14, v∗
EW eight v∗
4 (cid:55)→ 3, v∗
v∗
1 , l0) (cid:55)→ 11, (v∗
LReach (v∗
1 , l0) → 79, (v∗
LP ercent (v∗

{2,3,5,6,7} (cid:55)→ 2,
{8,9} (cid:55)→ 1
{2,3,5,6,7} (cid:55)→ 1,
{8,9} (cid:55)→ 0

1 , l1) (cid:55)→ 3
1 , l1) → 21

Fig. 5: Selected Properties for Fig.4b (right); Frontier Vertices (left);

Example 4 (Outer-Connectivity). Fig.5 (left) depicts a stand-alone example, such
that circles denote s-nodes, labeled arrows denote the s-edges relating them, and
crosses represent nameless vertices, as we only label relevant ones, for simplicity.
We use this conﬁguration to illustrate analytics regarding cross and traversal con-
nectivity on labels l1 and l2. For instance, as we will see in Sec.4, when counting
l1 · l−
2 cross-edge paths, we will look at the CReach s-node properties mentioning
these labels and note that there is a single such one, i.e., that corresponding to
l1 and l2 appearing on edges incoming v∗
1, l1, l2, 1, 1) = 1. When
counting l1 · l2 traversal paths, for the case when l1 appears on the cross-edge, we
will look at the properties of s-nodes containing l2 inner-edges. Hence, for v∗
2, we
note that there is a single such path, formed by an outgoing l2 edge and incom-
ing l1 edge, as T Reach(v∗
2, l1, l2, 1, 1) = 1. To estimate the traversal connectivity
we will divide this by the number of frontier vertices on incoming l1 edges. As,
VF (v∗

2, l1, 1) = {v2, v3}, we have that LPart(v∗

1, i.e., CReach(v∗

2, l1, l2, 1, 1) = 0.5.

6 All corresponding formulas are provided in the additional material.

Approximate Querying on Property Graphs

7

3.2 Merge Phase

We take as input the graph computed by Alg.1, and a label set and output a com-
pressed graph, ˆG = ( ˆV , ˆE). During this phase, sets of h-nodes, ˆV , and h-edges,
ˆE, are created. At each step, as previously, ˆG is enriched with approximation-
relevant precomputed properties (see Sec. 4).
i , v∗
Each h-node, ˆv, merges all s-nodes, v∗
i ) = λ(v∗

j ∈ V ∗, that are maximally label
connected on the same label, i.e., λ(v∗
j ), and that have either the
same set of incoming (source-merge) or outgoing (target-merge) edge labels, i.e.,
Λd(v∗
j ), d ∈ {1, 2} (see Alg. 2). Each h-edge, ˆe, merges all s-edges in
E∗ with the same label and orientation, i.e., e∗

i ) = Λd(v∗

j .d, for d ∈ {1, 2}.

i .d = e∗

Algorithm 2 MERGE(V ∗, Λ, m)
Input: V ∗ – s-nodes; Λ – labels; m – heuristic mode; Output: ˆV – h-nodes
1: for all v∗ ∈ V ∗ do
2: Λd(v∗) ← {l ∈ Λ | ∃e∗ = l( , ) ∈ E∗ ∧ e.d = v∗}
3: for all v∗
4:
5:
6: else ˆv ← {v∗
7: ˆV ← {ˆvk | k ∈ [1, |V ∗|]}
8: return ˆV

1 ) ?= λ(v∗
bλ ← λ(v∗
if m = true then ˆv ← {v∗
1 , v∗

(cid:46)Labels Incoming/Outgoing v∗
(cid:46)Pair-wise S-node Inspection
(cid:46)Boolean Conditions
(cid:46)Target-Merge
(cid:46)Source-Merge
(cid:46)H-node Computation

2 | bλ ∧ b1 = true}

2 | bλ ∧ b2 = true}

2 ), bd ← Λd(v∗

1 ) ?= Λd(v∗

2 ), d ∈ {1, 2}

2 ∈ V ∗ do

1 , v∗

1 , v∗

To each h-node, we attach properties, whose values, except LP ercent, are
the sum of those corresponding to each of its s-nodes. For the label percentage,
these values record the weighted percentage mean. Next, we merge s-edges into
h-edges, if they have the same label and endpoints, and attach to each h-edge, its
number of compressed s-edges, EW eight. We also record the avg. s-node weight,
V ∗W eight, to estimate how many nodes a h-node compresses.

To formally characterize the graph transformation corresponding to our sum-

marization technique, we ﬁrst deﬁne the following function.

Deﬁnition 2 (Valid Summarization). For G = (V, E), a valid summariza-
tion function χΛ : V → N assigns vertex identiﬁers, s.t., any vertices with the
same identiﬁer are either in the same maximally l-connected G-subgraph, or in
diﬀerent ones, not connected by an l-labeled edge.

A valid summary is thus obtained from G, by collapsing vertices with the
same χΛ into h-nodes and edges with the same (depending on the heuristic,
ingoing/outgoing) label into h-edges. We illustrate this below.

Example 5 (Graph Compression). The graphs in Fig. 4c are obtained from G∗ =
(V ∗, E∗), after the merge phase. Each h-node contains the s-nodes (see Fig.
4b) collapsed via the target-merge (left) and source-merge (right) heuristics.

We study our summarization’s optimality, i.e., the size of the obtained com-
pressed graph, to grasp its tractability. Speciﬁcally, we investigate the following
MinSummary problem, to establish whether one can always minimize the num-
ber of nodes of an input graph, when constructing its valid summary.

8

S.Dumbrava, A.Bonifati, A.Diaz, R.Vuillemot

Problem 1 (Minimal Summary). Let MinSummary be the problem that, for a
graph G and an integer k(cid:48) ≥ 2, decides if there exists a label-driven partitioning
Φ of G, |Φ| ≤ k(cid:48), such that χΛ is a valid summarization.

Each MinSummary h-node is thus intended to regroup as many nodes from
the original graph as possible, while ensuring these are connected by frequently
occurring labels. This condition (see Def. 2) reﬂects the central idea of our frame-
work, namely that the connectivity of such prominent labels can serve to both
compress a graph and to approximately evaluate label-constrained reachability
queries. Next, we establish the diﬃculty of solving MinSummary.

Theorem 1 (MinSummary NP-completeness). Even for undirected graphs,
|Λ(G)| ≤ 2, and k(cid:48) = 2, MinSummary is NP-complete 7.

The intractability of constructing an optimal summary thus justiﬁes our

search for heuristics with good performance in practice.

4 Approximate Query Evaluation

(cid:74)

(cid:75)

(cid:74)

Q
(cid:75)

Q
(cid:75)
(cid:74)

Query Translation. For G and a counting reachability query Q, we approxi-
G, the evaluation of Q over G. We translate Q into a query QT , evaluated
mate
over the summarization ˆG of G, s.t
QT
G. The translations by input
ˆG ≈
query type are given in Fig. 6, with PGQL as concrete syntax. (1) Simple and
Optional Label Queries. A label l occurs in ˆG either within a h-node or on a cross-
edge. Thus, we either cumulate the number of l-labeled h-node inner-edges or the
l-labeled cross-edge weights. To account for the potential absence of l, we also
estimate, in the optional-label queries, the number of nodes in ˆG, by cumulating
those in each h-node. (2) Kleene Plus and Kleene Star Queries. To estimate l+,
we cumulate the counts within h-nodes containing l-labeled inner-edges and the
weights on l-labeled cross-edges. For the former, we distinguish whether the l+
reachability is due to: 1) inner-connectivity – we use the property counting the
inner l-paths; 2) incoming cross-edges – we cumulate the l-labeled in-degrees
of h-nodes; or 3) outgoing cross-edges – we cumulate the number of outgoing
l-paths. To handle the (cid:15)-label in l∗, we also estimate the number of nodes in ˆG.
(3) Disjunction. We treat each possible conﬁguration, on both labels. Hence, we
either cumulate the number of h-node inner-edges or that of cross-edge weights,
with either label. (4) Binary Conjunction. We distinguish whether the label pair
appears on an inner h-node path, on a cross-edge path, or on a traversal one.

Example 6. We illustrate the approximate evaluation of these query types on
Fig. 4. To evaluate the number of single-label atomic paths, e.g., QT
L(l5), as l5
only occurs inside h-node ˆv2,
ˆG is the amount of l5-labeled inner edges in
(cid:75)
ˆv2, i.e., EW eight(ˆv2, l5) ∗ LP ercent(ˆv2, l5) = 7. To estimate the number of op-
tional label atomic paths, e.g., QT
O(l2), we add to QT
L(l2) the total number of
graph vertices, (cid:80)
ˆv∈ ˆV V ∗W eight(ˆv) ∗ VW eight(ˆv) (empty case). As l2 only ap-
ˆG is 27. To
pears on a h-edge of weight 2 and there are 25 initial vertices,

l2?

l5

(cid:74)

(cid:74)

(cid:75)

7 Proof given at: http://web4.ensiie.fr/∼stefania.dumbrava/SUM19 appx.pdf.

Approximate Querying on Property Graphs

9

estimate Kleene-plus queries, e.g., QT
P (l0), as no h-edge has label l0, we return
LReach(ˆv1, l0), i.e., the number of l0-connected vertex pairs. Thus,
ˆG is 15.
(cid:75)
For Kleene-star, we add to this, the previously computed total number of vertices
and obtain that
ˆG, we cumulate
(cid:75)
the single-labeled atomic paths on each label, yielding 14. For binary conjunc-
ˆG, we rely on the traversal connectivity, LP art(v∗, l4, l5, 2, 2),
tions, e.g.,
(cid:75)
as l4 appears on a h-edge and, l5, inside h-nodes; we thus count 7 node pairs.

ˆG is 40. For disjunction queries, e.g.,

(cid:74)
l−
4 · l5

l4 + l1
(cid:74)

l+
0

l∗
0

(cid:75)

(cid:74)

(cid:74)

QL(l)

QT

L (l)

QO(l)

QT
O

QP (l)

QT

P (l)

QS (l)

QT

S (l)

QD(l1, l2)

QT

D(l1, l2)

SELECT COUNT(*) MATCH () -[:l]-> ()

SELECT SUM(x.LPERCENT_L * x.EWEIGHT) MATCH (x)
SELECT SUM(e.EWEIGHT) MATCH () -[e:l]-> ()

SELECT COUNT(*) MATCH () -[:l?]-> ()

SELECT SUM(x.LPERCENT_L * x.EWEIGHT) MATCH (x)
SELECT SUM(e.EWEIGHT) MATCH () -[e:l]-> ()
SELECT SUM(x.AVG_SN_VWEIGHT * x.VWEIGHT) MATCH (x)

SELECT COUNT(*) MATCH () -/:l+/-> ()

SELECT SUM(x.LREACH_L) MATCH (x) WHERE x.LREACH_L > 0
SELECT SUM(e.EWEIGHT) MATCH () -[e:l]-> ()

SELECT COUNT(*) MATCH () -/:l*/-> ()

SELECT SUM(x.LREACH_L) MATCH (x) WHERE x.LREACH_L > 0
SELECT SUM(e.EWEIGHT) MATCH () -[e:l]-> ()
SELECT SUM(x.AVG_SN_VWEIGHT * x.VWEIGHT) MATCH (x)

SELECT COUNT(*) MATCH () -[:l1|l2]-> ()

SELECT SUM(x.LPERCENT_L1 * x.EWEIGHT + x.LPERCENT_L2 * x.EWEIGHT) MATCH (x)
SELECT SUM(e.EWEIGHT) MATCH () -[e:l1|l2]-> ()

QC (l1, l2, 1, 1)
QC (l1, l2, 1, 2)
QC (l1, l2, 2, 1)
QC (l1, l2, 2, 2)

SELECT COUNT(*) MATCH () -[:l1]-> () <-[:l2]- ()

SELECT COUNT(*) MATCH () -[:l1]-> () -[:l2]-> ()

SELECT COUNT(*) MATCH () <-[:l1]- () <-[:l2]- ()

SELECT COUNT(*) MATCH () <-[:l1]- () -[:l2]-> ()

QT

C (l1, l2, d1, d2)

SELECT SUM((x.LPART_L2_L1_D2_D1 * e.EWEIGHT)/(x.LPERCENT_L1 * x.VWEIGHT))
MATCH (x) -[e:l2] -> () WHERE x.LPERCENT_L1 > 0
SELECT SUM((y.LPART_L1_L2_D1_D2 * e.EWEIGHT)/(y.LPERCENT_L2 * y.VWEIGHT))
MATCH () -[e:l1] -> (y) WHERE y.LPERCENT_L2 >0
SELECT SUM(x.CREACH_L1_L2_D1_D2) MATCH (x)
SELECT SUM(x.EWEIGHT * min(x.LPERCENT_L1, x.LPERCENT_L2)) MATCH (x)

Fig. 6: Query translations onto the graph summary.

5 Experimental Analysis

In this section, we present an empirical evaluation of our graph summariza-
tion, recording (1) the succinctness of our summaries and the eﬃciency of the
underlying algorithm and (2) the suitability of our summaries for approximate
evaluation of counting label-constrained reachability queries.
Setup, Datasets and Implementation. The summarization and approxima-
tion modules are implemented in Java using OpenJDK 1.88. As the underlying
graph database backend, we have used Oracle Labs PGX 3.1, which is the only
property graph engine allowing for the evaluation of complex RPQs.

To implement the intermediate graph analysis operations (e.g., weakly con-
nected components), we used the Green-Marl domain-speciﬁc language and mod-

8 Available at: https://github.com/grasp-algorithm/label-driven-summarization.

10

S.Dumbrava, A.Bonifati, A.Diaz, R.Vuillemot

Dataset |LV | |LE |

bib
social
uniprot
shop

5
15
5
24

∼ 1K

∼ 5K

∼ 25K

∼ 50K

∼ 100K

∼ 200K

|E|

|E|

|V |

|V |

|V |
916 1304 4565 6140 22780 3159 44658 60300 88879 119575 179356 240052
4
897 2127 4434 10896 22252 55760 44390 110665 88715 223376 177301 450087
27
7
2170 3898 6837 18899 25800 97059 47874 192574 91600 386810 177799 773082
82 3136 4318 6605 10811 17893 34052 31181 56443 57131 93780 109205 168934

|V |

|V |

|V |

|E|

|E|

|E|

|E|

Fig. 7: Datasets: no. of vertices |V |, edges |E|, vertex |LV | and edge labels |LE|.

iﬁed the methods to ﬁt the construction of node properties required by our sum-
marization algorithm. We base our analysis on the graph datasets in Fig. 7,
encoding: a Bibliographic network (bib), the LDBC social network schema [12]
(social ), Uniprot knowledge graphs (uniprot), and the WatDiv schema [1] (shop).
We obtained these datasets using gMark [5], a synthetic graph instance and
query workload generator. As gMark tries to construct the instance that best ﬁts
the size parameter and schema constraints, the resulting sizes vary (especially for
the very dense graphs social and shop). Next, on the same datasets, we generated
workloads of varying sizes, for each type in Section 2. These datasets and related
query workloads have been chosen since they provide the most recent benchmarks
for recursive graph queries and also to ensure a comparison with SumRDF [19]
(as shown next) on a subset of those supported by the latter. Studies [8,17] have
shown that practical graph pattern queries formulated by users in online query
endpoints are often small: 56.5% of real-life SPARQL queries consist of a single
edge (RDF triple), whereas 90.8% use 6 edges at most. Hence, we select small-
sized template queries with frequently occuring topologies, such as chains [8],
and formulate them on our datasets, for workloads of ∼ 600 queries.

Experiments ran on a cloud VM with Intel Xeon E312xx, 4 cores, 1.80 GHz
CPU, 128GB RAM, and Ubuntu 16.04.4 64-bit. Each data point corresponds to
repeating an experiment 6 times, removing the ﬁrst value from the average.
Summary Compression Ratios. First, we evaluate the eﬀect that using the
source-merge and target-merge heuristics has on the summary construction time
(SCT). We also assess the compression ratio (CR) on the original graph’s vertices
and edges, by measuring (1 − | ˆV|/|V|) ∗ 100 and, respectively, (1 − | ˆE|/|E|) ∗ 100.
Next, we compare the results for source and target merge. In Fig. 8 (a-d), the
most homogeneous datasets, shop and uniprot, achieve very high CR (close to
100%) and steadily maintain it with varying graph sizes. As far as heterogeneity
signiﬁcantly grows for bib and social, the CR becomes eagerly sensitive to the
dataset size, starting with low values, for smaller graphs, and stabilizing between
85% and 90%, for larger ones. Notice also that bib and social, while similar,
display a symmetric CR behavior: the former better compresses vertices, while
the latter, edges. Concerning the SCT runtime in Fig. 8 (e-f), all datasets keep a
reasonable performance for larger sizes, even the most heterogeneous one shop.
The runtime is, in fact, not aﬀected by heterogeneity, but is rather sensitive, for
larger sizes, to |E| variations (up to 450K and 773K, for uniprot and social ).
Also, while the source and target merge SCT runtimes are similar, the latter
achieves better CRs for social. Overall, the dataset with the worst CR for the
two heuristics is shop, with the lowest CR for smaller sizes. This is also due to the

Approximate Querying on Property Graphs

11

Fig. 8: CRs for vertices and edges, along with SCT runtime for various dataset
sizes, for both source-merge (a-c-e), and target-merge (b-d-f).

(a) Avg. Rel. Error/Workload

(b) Avg. Time Gain/Workload

Fig. 9: Rel. Error (a), Time Gain (b) per Workload, per Dataset, 200K nodes.

high number of labels in the initial shop instances, and, hence, to the high num-
ber of properties its summary needs: on average, for all considered sizes, 62.33
properties, against 17.67, for social graph, 10.0, for bib, and 14.0, for uniprot.
These experiments show that, despite its high complexity, our summarization
provides high CRs and low SCT runtimes, even for large, heterogeneous graphs.
Approximate Evaluation Accuracy. We assess the accuracy and eﬃciency
of our engine with the relative error and time gain measures, respectively. The
i ( ˆG)) (in
relative error (per query Qi) is 1 − min(Qi(G), QT
%), where Qi(G) computes (with PGX) the counting query Qi, on the original
graph, and QT
i , on the
summary. The time gain is: tG − t ˆG/max(tG, t ˆG) (in %), where tG and t ˆG are the
query evaluation times of Qi on the original graph and on the summary.

i ( ˆG) computes (with our engine) the translated query QT

i ( ˆG))/ max(Qi(G), QT

For the Disjunction, Kleene-plus, Kleene-star, Optional and Single Label
query types, we have generated workloads of diﬀerent sizes, bound by the num-
ber of labels in each dataset. For the concatenation workloads, we considered
binary conjunctive queries (CQs) without disjunction, recursion, or optionality.
Note that, currently, our summaries do not support compositionality.

CR Edges (%)607080901001K5K25K50K100K200Kllllll(a) CR Edges (s−m)607080901001K5K25K50K100K200Kllllll(b) CR Edges (t−m)Datasets:lShopSocialBibUniprotCR Vertices (%)929496981001K5K25K50K100K200Kllllll(c) CR Vertices (s−m)8590951001K5K25K50K100K200Kllllll(d) CR Vertices (t−m)lGraph sizes (# nodes)Execution time (sec)0200060001K5K25K50K100K200Kllllll(e) SCT (s−m) [sec]0200060001K5K25K50K100K200Kllllll(f) SCT (t−m) [sec]S.Dumbrava, A.Bonifati, A.Diaz, R.Vuillemot

12

ID

Query Body

Q1 (x0)-[:producer]->()<-[:paymentAccepted]-(x1)
Q2 (x0)-[:totalVotes]->()<-[:price]-(x1)
Q3 (x0)-[:jobTitle]->()<-[:keywords]-(x1)
Q4 (x0)<-[:title]-()-[:performedIn]->(x1)
Q5 (x0)-[:artist]->()<-[:employee]-(x1)
Q6 (x0)-[:follows]->()<-[:editor]-(x1)

Approx. Answer Rel. Error (%) Runtime (ms)
SumRDF APP SumRDF APP SumRDF APP
38.2
17
12.8
8.8
10.6
19

136.30
0.00
50.99
0.00
463.85
0.18
831.72
0.00
0.37
196.77
0.48 1295.83

75
42.4
226.7
19.5
143.3
524

1.32
3.64
2.51
2.50
7.19
0.38

76
44
221
20
133
528

Fig. 10: Performance Comparison: SumRDF vs. APP (our approach): approx.
eval. of binary CQs, SELECT COUNT(*) MATCH Qi, on the summaries of a shop
graph instance (31K nodes, 56K edges); comparing estimated cardinality (no. of
computed answers), rel. error w.r.t the original graph results, and query runtime.

Fig.9 (a) and (b) show the relative error and average time gain for the Dis-
junction, Kleene-plus, Kleene-star, Optional and Single Label workloads. In Fig.
9 (a), we note that the avg. relative error is kept low in all cases and is bound by
5.5%, for the Kleene-plus and Kleene-star workloads of the social dataset. In all
the other cases, including the Kleene-plus and Kleene-star workloads of the shop
dataset, the error is relatively small (near 0%). This conﬁrms the eﬀectiveness
of our graph summaries for approximate evaluation of graph queries. In Fig. 9
(b), we studied the eﬃciency of approximate evaluation on our summaries by re-
porting the time gain (in %) compared with the query evaluation on the original
graphs for the four datasets. We notice a positive time gain (≥ 75%) in most
cases, but for disjunction. While the relative approximation error is still advan-
tageous for disjunction, disjunctive queries are time-consuming for approximate
evaluation on our summaries, especially for extremely heterogeneous datasets,
such as shop (having the most labels). This is due to the overhead introduced
by considering all possible connectivity combinations on the disjunctive labels.
The problem of scaling our method, without prohibitive accuracy loss, to queries
involving multiple labels and further compositionality, e.g., Kleene-star over dis-
junctions [22], is challenging and falls under the scope of future work.

Baseline for approximate query evaluation performance. The closest
system to ours is SumRDF [19] (see Section 6), which, however, operates on
a simpler edge-labeled model rather than on property graphs and is tailored for
estimating the results of conjunctive queries only. As a performance baseline, we
considered the shop dataset in gMark [5], simulating the WatDiv benchmark [1]
(also a benchmark in [19]). From this dataset with 31K nodes and 56K edges,
we generated the corresponding SumRDF and our summaries. We obtained a
better CR than SumRDF, with 2737 nodes vs. 3480 resources and 17430 edges
vs. 29621 triples. This comparison is, however, tentative, as our approach com-
presses vertices independently of the edges, while SumRDF returns triples. We
then considered the same CQ types as in Fig. 10. Comparing our approach
vs. SumRDF (see Fig. 10), we recorded an average relative error of estimation
of only 0.15%. vs. 2.5% and an average query runtime of only 27.55 ms vs.
427.53 ms. As SumRDF does not support disjunctions, Kleene-star/plus queries
and optional queries, further comparisons were not possible.

Approximate Querying on Property Graphs

13

6 Related Work

Preliminary work on approximate graph analytics in a distributed setting has
recently been pursued in [15]. They rather focus on a graph sparsiﬁcation tech-
nique and small samples, in order to approximate the results of speciﬁc graph
algorithms, such as PageRank and triangle counting on undirected graphs. In
contrast, our approach operates in a centralized setting and relies on query-
driven graph summarization for graph navigational queries with aggregates.

RDF graph summarization for cardinality estimation has been tackled in [19],
albeit for a less expressive data model than ours (plain RDF vs. property graphs).
They focus on Basic Graph Patterns (BGP), hence their considered query frag-
ment has limited overlap with ours. As shown in Section 5, our approximate eval-
uation is faster and more accurate on a common set of (non recursive) queries.
An algorithm for answering graph reachability queries, using graph simu-
lation based pattern matching, is given in [13], to construct query preserving
summaries. However, it does not consider property graphs or aggregates.

Aggregation-based graph summarization [16] is at the heart of previous ap-
proaches, the most notable of which is SNAP [20]. This method is mainly de-
voted to discovery-driven graph summarization of heterogeneous networks and
is unsuitable for approximate query evaluation.

More recently, Rudolf et al. [18] have introduced a graph summary suitable
for property graphs based on a set of input summarization rules. However, it does
not support the label-constrained reachability queries in this paper. Graph sum-
maries for answering subgraphs returned by keyword queries on large networks
are studied in [24]. Our query classes signiﬁcantly diﬀer from theirs.

7 Conclusion

Our paper focuses on a novel graph summarization method that is suitable for
property graph querying. As the underlying MinSummary decision problem is
NP-complete, this technique builds on an heuristic that compresses label fre-
quency information in the nodes of the graph summary. We show the practical
eﬀectiveness of our approach, in terms of compression ratios, error rates and
query evaluation time. As future work, we plan to investigate the feasibility of
our graph summary for other query classes, such as those described in [22]. Also,
we aim to apply formal methods, as described in [6], to ascertain the correctness
of our approximation algorithm, with provably tight error bounds.

References

1. Alu¸c, G., Hartig, O., ¨Ozsu, M.T., Daudjee, K.: Diversiﬁed stress testing of RDF

data management systems. In: ISWC. pp. 197–212 (2014)

2. Angles, R., Arenas, M., Barcel´o, P., Boncz, P.A., Fletcher, G.H.L., Gutierrez, C.,
Lindaaker, T., Paradies, M., Plantikow, S., Sequeda, J.F., van Rest, O., Voigt, H.:
G-CORE: A core for future graph query languages. In: SIGMOD. pp. 1421–1432
(2018)

14

S.Dumbrava, A.Bonifati, A.Diaz, R.Vuillemot

3. Angles, R., Arenas, M., Barcel´o, P., Hogan, A., Reutter, J.L., Vrgoc, D.: Founda-
tions of modern query languages for graph databases. ACM Comput. Surv. 50(5),
68:1–68:40 (2017)

4. Arenas, M., Conca, S., P´erez, J.: Counting beyond a Yottabyte, or how SPARQL
1.1 property paths will prevent adoption of the standard. In: WWW. pp. 629–638
(2012)

5. Bagan, G., Bonifati, A., Ciucanu, R., Fletcher, G.H.L., Lemay, A., Advokaat, N.:
gmark: Schema-driven generation of graphs and queries. IEEE Trans. Knowl. Data
Eng. 29(4), 856–869 (2017)

6. Bonifati, A., Dumbrava, S., Arias, E.J.G.: Certiﬁed graph view maintenance with

Regular Datalog. TPLP 18(3-4), 372–389 (2018)

7. Bonifati, A., Fletcher, G., Voigt, H., Yakovets, N.: Querying Graphs. Synthesis

Lectures on Data Management, Morgan & Claypool Publishers (2018)

8. Bonifati, A., Martens, W., Timm, T.: An analytical study of large SPARQL query

logs. PVLDB 11(2), 149–161 (2017)

9. Bonifati, A., Martens, W., Timm, T.: Navigating the maze of Wikidata query logs.

In: WWW. pp. 127–138 (2019)

10. Calvanese, D., De Giacomo, G., Lenzerini, M., Vardi, M.Y.: Rewriting of regular
expressions and regular path queries. J. Comput. Syst. Sci. 64(3), 443–465 (2002)
11. Cruz, I.F., Mendelzon, A.O., Wood, P.T.: A graphical query language supporting

recursion. In: SIGMOD. pp. 323–330 (1987)

12. Erling, O., Averbuch, A., Larriba-Pey, J., Chaﬁ, H., Gubichev, A., Prat-P´erez,
A., Pham, M., Boncz, P.A.: The LDBC Social Network Benchmark: Interactive
Workload. In: SIGMOD. pp. 619–630 (2015)

13. Fan, W., Li, J., Wang, X., Wu, Y.: Query preserving graph compression. In: SIG-

MOD. pp. 157–168 (2012)

14. Hern´andez, D., Hogan, A., Riveros, C., Rojas, C., Zerega, E.: Querying wikidata:

Comparing sparql, relational and graph databases. In: ISWC. pp. 88–103 (2016)

15. Iyer, A.P., Panda, A., Venkataraman, S., Chowdhury, M., Akella, A., Shenker, S.,
Stoica, I.: Bridging the GAP: towards approximate graph analytics. In: GRADES.
pp. 10:1–10:5 (2018)

16. Khan, A., Bhowmick, S.S., Bonchi, F.: Summarizing static and dynamic big graphs.

PVLDB 10(12), 1981–1984 (2017)

17. Malyshev, S., Krotzsch, M., Gonzalez, L., Gonsior, J., Bielefeldt, A.: Getting the
most out of wikidata: Semantic technology usage in wikipedia’s knowledge graph.
In: ISWC (2018)

18. Rudolf, M., Voigt, H., Bornh¨ovd, C., Lehner, W.: Synopsys: Foundations for mul-

tidimensional graph analytics. In: BIRTE. pp. 159–166 (2014)

19. Stefanoni, G., Motik, B., Kostylev, E.V.: Estimating the cardinality of conjunctive
queries over rdf data using graph summarisation. In: WWW. pp. 1043–1052 (2018)
20. Tian, Y., Hankins, R.A., Patel, J.M.: Eﬃcient aggregation for graph summariza-

tion. In: SIGMOD. pp. 567–580. ACM (2008)

21. Valiant, L.G.: The complexity of enumeration and reliability problems. SIAM J.

Comput. 8(3), 410–421 (1979)

22. Valstar, L.D.J., Fletcher, G.H.L., Yoshida, Y.: Landmark indexing for evaluation

of label-constrained reachability queries. In: SIGMOD. pp. 345–358 (2017)

23. Wood, P.T.: Query languages for graph databases. SIGMOD Rec. 41(1), 50–60

(2012)

24. Wu, Y., Yang, S., Srivatsa, M., Iyengar, A., Yan, X.: Summarizing answer graphs

induced by keyword queries. PVLDB 6(14), 1774–1785 (2013)

