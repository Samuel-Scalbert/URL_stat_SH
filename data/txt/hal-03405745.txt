Parallelisable Existential Rules: a Story of Pieces
Maxime Buron, Marie-Laure Mugnier, Michaël Thomazo

To cite this version:

Maxime Buron, Marie-Laure Mugnier, Michaël Thomazo. Parallelisable Existential Rules: a Story
of Pieces. KR 2021 - 18th International Conference on Principles of Knowledge Representation and
Reasoning, Nov 2021, Virtual, Vietnam. pp.163-173, ￿10.24963/kr.2021/16￿. ￿hal-03405745￿

HAL Id: hal-03405745

https://inria.hal.science/hal-03405745

Submitted on 27 Oct 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Parallelisable Existential Rules: a Story of Pieces

Maxime Buron1 , Marie-Laure Mugnier2 , Micha¨el Thomazo3
1 University of Oxford, United Kingdom
2 LIRMM, Inria, University of Montpellier, CNRS, France
3 Inria, DI ENS, ENS, CNRS, PSL University & Inria, France
maxime.buron@cs.ox.ac.uk, michael.thomazo@inria.fr, mugnier@lirmm.fr

Abstract

In this paper, we consider existential rules, an expressive
formalism well suited to the representation of ontological
knowledge and data-to-ontology mappings in the context of
ontology-based data integration. The chase is a fundamental
tool to do reasoning with existential rules as it computes all
the facts entailed by the rules from a database instance. We
introduce parallelisable sets of existential rules, for which the
chase can be computed in a single breadth-ﬁrst step from any
instance. The question we investigate is the characterization
of such rule sets. We show that parallelisable rule sets are
exactly those rule sets both bounded for the chase and be-
longing to a novel class of rules, called pieceful. The pieceful
class includes in particular frontier-guarded existential rules
and (plain) datalog. We also give another characterization of
parallelisable rule sets in terms of rule composition based on
rewriting.

1

Introduction

Ontology-based data access (OBDA) systems aim at facili-
tating data querying through a conceptual layer formalized
by an ontology (Poggi et al. 2008; Xiao et al. 2018). They
rely on a three-level architecture comprising the ontology,
the data sources and the mapping between the two. The key
idea is that a user expresses queries at a conceptual level, and
the system translates these queries into queries on the data
via the mapping, while integrating ontological reasoning.

When we abstract away from data sources and map-
pings, we obtain the fundamental ontology-based query an-
swering problem, which takes as input an ontology O, an
instance (or set of facts) I and a (Boolean) conjunctive
query q, both expressed in the vocabulary of O, and asks
whether I, O |= q. Ontological knowledge is typically
represented in description logics (e.g., (Baader et al. 2017;
Bienvenu and Ortiz 2015)) or existential rules (e.g., (Cal`ı,
Gottlob, and Lukasiewicz 2009; Baget et al. 2009)) and we
shall consider the latter language in this paper. Existen-
tial rules are an extension of ﬁrst-order function-free Horn
rules allowing for existentially quantiﬁed variables in the
rule heads (e.g., ∀x(s(x) → ∃z t(x, z))), which makes them
able to infer the existence of unknown individuals. They
generalise datalog and most description logics used to do
reasoning on data, namely Horn description logics.

Two dual techniques are used to solve the ontology-based
query answering problem: the chase, which enriches I by

performing a ﬁxpoint computation with O until a canonical
model of I and O is obtained (then q is asked on the result of
the chase), and query rewriting, where q is rewritten with O
into a query q(cid:48), such that for all instance I, holds I, O |= q
if and only if holds I |= q(cid:48). Query answering is undecidable
with general existential rules, however there are expressive
subclasses ensuring the termination of either technique.

In the OBDA paradigm, the instance I is not material-
ized, but virtually deﬁned by the mapping and the data. Pre-
cisely, an OBDA speciﬁcation is given by an ontology O, a
relational schema S and a mapping M from S to O (Lenz-
erini 2018). The mapping is itself composed of assertions of
the form qS(x) → qO(x), where qS is a query on schema
S and qO is a conjunctive query on the vocabulary of O,
both with tuple of answer variables x. When qS is also a
conjunctive query, or a relational view, a mapping assertion
can be seen as an existential rule. Then, the virtual instance
I(D,M), associated with a database D (on S) and the map-
ping M, is the set of facts that would be obtained by chasing
D with M. Note that only a single (breadth-ﬁrst) step of the
chase is required here, as bodies and heads of mapping as-
sertions are on disjoint sets of predicates. Since I(D,M) is
virtual, an incoming query has to be rewritten, ﬁrst with O,
then with M, which yields a query directly asked on D. As
rewriting is performed at query time, speeding up this pro-
cess is a crucial issue. In particular, query rewriting with O
is a recursive process, which is not the case with M. For
very lightweight ontology languages (the DL-Lite family or
the W3C language RDFS), a practically efﬁcient approach
consists of compiling (part of) the ontological reasoning
into the mapping, so that the rewriting step with O can
be avoided or drastically reduced (Kontchakov et al. 2014;
Buron et al. 2020b). In these settings, each mapping asser-
tion can be processed independently, the mapping head be-
ing enriched with knowledge it entails. Whether such tech-
nique can be extended to more expressive languages is an
open issue, which motivated the work presented here.

Consider an OBDA setting where existential rules are
used as a uniform language to express both the ontology and
the mapping. Compiling ontological reasoning into the map-
ping can be seen as computing a new mapping M(cid:48) such that
query rewriting with O and M is reduced to query rewriting
with M(cid:48). From a dual viewpoint, for any database D, the
instance I(D,M(cid:48)) is equivalent to the chase of I(D,M) with

O. The next example illustrates the approach.
Example 1. Let M = {M1, M2} and O = {R1, R2},
where si and ti denote predicates from S and O, respec-
tively, and universal quantiﬁers are omitted:
M1 = s1(x, y) → t1(x, y)
M2 = s2(x) → t2(x)
R1 = t2(x) → ∃z t3(x, z)
R2 = t1(x, y) ∧ t3(x, z) → t4(y)
Here, the ontology can be compiled into the mapping, which
yields M(cid:48) = M ∪ {M3, M4}, where:
M3 = s2(x) → ∃z t3(x, z)
M4 = s1(x, y) ∧ s2(x) → t4(y).
Intuitively, M(cid:48) is obtained by composing the rules from
M ∪ O until a ﬁxpoint is reached (see Sect. 4), then keeping
only mapping assertions, i.e., rules whose all body predi-
cates are in S. We can check that, for any database D on S,
a single breadth-ﬁrst step of the chase of D with M(cid:48) sufﬁces
to produce the chase of D with M ∪ O.

With the aim of developing compilation techniques for
OBDA systems based on existential rules, we asked our-
selves the following question: under which conditions on
the rules can the chase be simulated in a single step?

We formalize the desired property by the notion of paral-
lelisable existential rule sets. Informally, a (ﬁnite) rule set
R is parallelisable if there exists a ﬁnite rule set R(cid:48) able to
produce (an equivalent superset of) the chase of R in a sin-
gle breadth-ﬁrst step, independently from any instance. The
question we investigate in this paper is how to characterize
such rule sets. Our main results are the following.
• Clearly, boundedness, which expresses that the number
of chase steps is bounded independently from any in-
stance, is a necessary condition for parallelisability. This
notion has long been studied for datalog (Hillebrand et
al. 1995) and more recently for existential rules (Bourhis
et al. 2019; Delivorias et al. 2021). While boundedness
is equivalent to parallelisability in the case of datalog, it
does not ensure the parallelisability of an existential rule
set. This leads us to deﬁne a new class of existential rules,
namely pieceful. We show that parallelisable rule sets are
exactly those sets that are both bounded and pieceful.

• The novel pieceful class has an interest in itself, as it gen-
eralizes datalog as well as a main class of existential rules,
namely frontier-guarded, which itself covers some promi-
nent description logics (see the last section for details).

• Piecefulness is based on the behavior of rules during the
chase. Adopting the viewpoint of query rewriting, we
study an operator of rule composition (that we call ex-
istential composition) based on so-called piece-uniﬁers, a
notion at the core of rewriting with existential rules. We
show that any bounded and pieceful rule set can be paral-
lelized by a ﬁnite set of composed rules.

• This allows us to provide another characterization of
pieceful rule sets based on their behavior during rule com-
position. Roughly, a certain property (that we call existen-
tial stability) has to be fulﬁlled by every pair of rules of
the set and preserved whenever composed rules are added
to the set.

• Finally, noting that rule composition does not ﬁt well
with the behavior we intuitively expected, we introduce
another rule composition operator (that we call compact
composition). The result of this operator goes beyond the
existential rule language. We show however that, when
the stability property is satisﬁed, both kinds of composi-
tions yield logically equivalent formulas.

We believe that these results open up many practical and
theoretical perspectives, which we discuss in the last section.
Full proofs that could not be included due to space restric-
tions are available in a technical report (Buron, Mugnier, and
Thomazo 2021).

2 Preliminaries
Generalities. A vocabulary is a pair V = (P, C), where P
is a ﬁnite set of predicates and C is a possibly inﬁnite set of
constants. A term on V is a constant from C or a variable.
An atom on V has the form p(t) where p ∈ P is a predicate
of arity n and t is a tuple of terms on V with |t| = n. An
atom is ground if it has no variable. Given an atom or set
of atoms S, we denote by var(S), const(S) and term(S) its
sets of variables, constants and terms, respectively. We will
often see a tuple x of pairwise distinct variables as a set. We
denote by |= the classical logical consequence. Given two
sets of atoms S1 and S2, a homomorphism h from S1 to S2 is
a substitution of var(S1) by term(S2) such that h(S1) ⊆ S2
(we say that S1 maps to S2 by h).

Instances and Rules. An instance is a ﬁnite set of ground
atoms. Any ﬁnite set of atoms S can be turned into an in-
stance, denoted by freeze(S), by freezing its variables, i.e.,
bijectively renaming each variable by a fresh constant. An
extended instance is a (possibly inﬁnite) set of atoms, in
which variables are classically called nulls. The associated
(possibly inﬁnite) formula is the existential closure of the
conjunction of the atoms. An existential rule R (or simply
rule hereafter) is a closed formula of the form

∀x∀y [ B(x, y) → ∃z H(x, z) ]

where B and H are non-empty and ﬁnite conjunctions of
atoms on variables, respectively called the body and the head
of the rule, denoted by body(R) and head(R), and x, y and
z are pairwise disjoint. We make the common assumption
that rules do not contain constants, which simpliﬁes techni-
cal tools. The set x is called the frontier of R and is de-
noted by fr(R). Its elements are called frontier variables.
The set z is called the set of existential variables (of R) and
is denoted by exist(R). An existential rule R is datalog if
|head(R)| = 1 and exist(R) = ∅. For brevity, we often
denote by B → H a rule with body B and head H. In the
following, we denote by R a ﬁnite set of existential rules and
assume w.l.o.g. that distinct rules in R have disjoint sets of
variables. In our examples, we reuse variables for simplicity.
A rule R = B → H is applicable to a set of atoms S if
there is a homomorphism π from B to S. The pair (R, π)
is called a trigger for S. The application of R according
to π (or: of the trigger (R, π)) produces a set of atoms ob-
tained from head(R) by replacing each frontier variable x

with π(x) and each existential variable with a fresh vari-
able, called a null. We denote by πsafe this extension of
π that “safely” renames existential variables; hence, atoms
produced by distinct applications of the same rule have dis-
joint sets of nulls. The set of atoms resulting from the appli-
cation of (R, π) to S is α(S, R, π) = S ∪ πsafe(H).

An R-derivation (from I to Ik) is a ﬁnite sequence
(I0 = I), (R1, π1, I1), . . . , (Rk, πk, Ik) such that for all
0 < i ≤ k, Ri ∈ R, (Ri, πi) is a trigger for Ii−1 and
Ii = α(Ii−1, Ri, πi). When only the successive (extended)
instances are needed, we note (I0 = I), I1, . . . , Ik.
Chase. The chase builds a derivation from an instance by
repeatedly applying rules until a ﬁxpoint is reached. We
rely on the semi-oblivious chase variant (in short, so-chase),
in which two triggers (R, π1) and (R, π2) that coincide on
the frontier of R produce exactly the same result (Marnette
2009). More precisely, we assume that nulls are named
as follows: given a trigger (R, π), for all z ∈ exist(R),
πsafe(z) = z(R,π|fr(R)), where π|fr(R) denotes the restriction
of π to the domain fr(R). Hence, the name of a null cre-
ated by a trigger (R, π) is based on R and π|fr(R), not π it-
self. We consider a breadth-ﬁrst so-chase deﬁned as follows:
chase0(I, R) = I and, for any i > 0,

chasei(I, R) = chasei−1(I, R) ∪

(cid:91)

(πsafe(head(R)))

(R,π)

where (R, π) is any trigger for chasei−1(I, R) and for
any z ∈ exist(R), πsafe(z) = z(R,π|fr(R)).
Finally,
chase∞(I, R) = (cid:83)
i≥0 chasei(I, R).
Example 2. Let I = {p(a, b)} and R = {p(x, y) →
∃z p(x, z) ∧ A(z)}. By the trigger t1 = (R, {x (cid:55)→ a, y (cid:55)→
b}), we obtain chase1(I, R) = {p(a, b), p(a, ν), A(ν)}
The trigger t2 = (R, {x (cid:55)→
with ν = z(R,{x(cid:55)→a}).
a, y (cid:55)→ ν}) then produces the same atoms as t1. Finally,
chase∞(I, R) = chase1(I, R).

Query Answering. A conjunctive query (CQ) is of the
form q(x) = ∃y ϕ(x, y), where x and y are disjoint tu-
ples of variables, ϕ is a conjunction of atoms, and x ∪ y =
var(ϕ); the free variables in ϕ (i.e., x) are called answer
variables. A Boolean CQ has no free variables. A union of
conjunctive queries (UCQ) is a disjunction of CQs that have
the same arity |x|. An (extended) instance I answers posi-
tively to a Boolean CQ q iff I |= q. More generally, a tuple
of constants c is an answer to a CQ q(x), with |x| = |c|, on
I if I |= q[c], where q[c] is obtained by substituting the i-th
variable in x by the i-th constant in c. The CQ answering
problem takes as input an instance I, a rule set R, a query
q(x) and a tuple of constants (c), with |x| = |c|, and asks
whether I, R |= q[c]. It holds that I, R |= q[c] iff there is an
R-derivation from I to I (cid:48) such that I (cid:48) |= q[c]. Equivalently,
I, R |= q[c] iff there is k such that chasek(I, R) |= q[c].
Pieces. The notion of piece is key in this paper. Given a
set of atoms S, a piece of S with respect to a set of terms T
is a non-empty set S(cid:48) ⊆ S such that (1) for any atom a ∈ S,
if a shares a term from T with some a(cid:48) ∈ S(cid:48) then a ∈ S(cid:48),
and (2) there is no strict subset of S(cid:48) that satisﬁes (1), i.e.,

S(cid:48) is minimal. Intuitively, atoms of S are glued together by
the terms of T , which yields pieces. Note that, for any set of
atoms S and set of terms T , S can be partitioned into pieces
w.r.t. T . Here, pieces are deﬁned with respect to existential
variables or to nulls, depending on the considered objects.
By default, a piece of S is w.r.t. exist(S) if S is a rule head
and w.r.t. the nulls in S if S is an (extended) instance.

A rule is called single-piece if its head forms a sin-
gle piece. Any rule can be decomposed into a (trivially)
equivalent set of single-piece rules. For instance, a rule
r(x, y) → ∃z1∃z2 p(x, z1) ∧ A(z1) ∧ A(z2) ∧ p(x, y) has
a head with three pieces: {p(x, z1), A(z1)}, {A(z2)} and
{p(x, y)}, hence can be decomposed into three single-piece
rules: r(x, y) → ∃z1 p(x, z1)∧A(z1); r(x, y) → ∃z2 A(z2)
and r(x, y) → p(x, y). In the following, we assume that
rules are single-piece. This assumption simpliﬁes our set-
ting, although all notions and results of this paper could be
reformulated without making it.

Piece-Uniﬁers. Piece-uniﬁers are a generalization of clas-
sical uniﬁers that take care of existential variables in rule
heads by unifying sets of atoms instead of single atoms
(Baget et al. 2009). Query rewriting as well as rule compo-
sition (see Sect. 4) are based on this notion. In the deﬁnition
below, we give a simpliﬁed version of piece-uniﬁers, which
does not take constants into account. See, e.g., (K¨onig et al.
2015) for details about piece-uniﬁers.

Given sets of atoms S and S(cid:48) ⊆ S, the set of separating
variables in S(cid:48) w.r.t. S, denoted by sepS(S(cid:48)), is the set of
variables that belong to both S(cid:48) and S\S(cid:48). Note that when S(cid:48)
is a piece of an extended instance I, sepI (S(cid:48)) is necessarily
empty (as S(cid:48) shares only constants with the rest of I).
Deﬁnition 1 (Piece-uniﬁer). Let S be a set of atoms and
R = B → H be a rule (both without constants) such that
var(S) ∩ var(B ∪ H) = ∅. A piece-uniﬁer of S with R
(or with H) is a triple µ = (S(cid:48), H (cid:48), u) with S(cid:48) (cid:54)= ∅, S(cid:48) ⊆
S, H (cid:48) ⊆ H, and u is a substitution of fr(R) ∪ var(S(cid:48)) by
var(head(R)) such that:
1. For all x ∈ fr(R), u(x) ∈ fr(R)
2. For all x ∈ sepS(S(cid:48)), u(x) ∈ fr(R)
3. u(S(cid:48)) = u(H (cid:48)).

Let S be a set of atoms and µ = (S(cid:48), H (cid:48), u) be a piece-
uniﬁer of S with R : B → H. The (direct) rewriting of S
w.r.t. µ is β(S, R, µ) = u(B) ∪ u(S \ S(cid:48)). An R-rewriting
Sk of S is obtained by a ﬁnite sequence (S0 = S), . . . , Sk
such that, for all 0 < i ≤ k, Si is a direct rewriting of Si−1
w.r.t. a piece-uniﬁer of Si−1 with a (copy of a) rule from R.
Example 3 (Piece-Uniﬁer). Let R = A(x) → ∃z p(x, z)
There is no piece-uniﬁer
and S1 = {p(w, v), B(v)}.
of S1 with R since v is a separating variable of S(cid:48)
1 =
{p(w, v)}, hence cannot be uniﬁed with z. Let S2 =
The triple µ =
{p(w1, v), B(w1), p(w2, v), C(w2)}.
2 = {p(w1, v), p(w2, v)}, H (cid:48) =
(S(cid:48)
{p(x, z)} and u = {w1, w2 (cid:55)→ x, v (cid:55)→ z} is a piece-
uniﬁer of S2 with R, which yields the direct rewriting
{A(x), B(x), C(x)}.

2, H (cid:48), u) with S(cid:48)

A fundamental property of piece-uniﬁers is the following:
given any instance I, rule set R and Boolean CQ q, there

is an R-derivation from I to an Ii such that q maps to Ii
(Ii |= q) iff there is an R-rewriting q(cid:48) of q such that q(cid:48) maps
to I (I |= q(cid:48)). Note that this property does not rely on rules
being single-piece.

Fundamental Properties of Rule Sets. A rule set R is
so-chase ﬁnite if for any instance I, there is k such that
chasek(I, R) = chase∞(I, R). A rule set R is a ﬁnite uni-
ﬁcation set (fus) if for any Boolean CQ q, there is a ﬁnite set
Q of R-rewritings of q, such that, for any R-rewriting q(cid:48) of
q, there is q(cid:48)(cid:48) ∈ Q that maps to q(cid:48) (Baget et al. 2009). It is
not hard to see that fus is equivalent to ﬁrst-order rewritabil-
ity (introduced in (Calvanese et al. 2007)): R is ﬁrst-order
rewritable if for any Boolean CQ q, there is a UCQ Q, such
that for any instance I, it holds that I, R |= q iff I |= Q.
Moreover, as several times remarked, fus is equivalent to
the bounded derivation depth property (Cal`ı, Gottlob, and
Lukasiewicz 2009): for any Boolean CQ q, there is k such
that for any instance I, if I, R |= q then chasek(I, R) |= q.
Finally, a rule set is so-bounded if there is k (a bound) such
that for any instance I, chasek(I, R) = chase∞(I, R) (De-
livorias et al. 2021). Clearly, when a rule set is so-bounded,
it is also so-chase ﬁnite and fus. The reciprocal holds true
for single-piece rules (follows from (Bourhis et al. 2019)).
In the remaining, we will simply write chase and bounded
in place of so-chase and so-bounded.

Example 4.
R1 = {A(x) → ∃z p(x, z) ∧ A(z)} is fus and not chase-
ﬁnite.
R2 = {R1 : p(x, y) ∧ p(y, z) → p(x, z)} is datalog (hence
chase-ﬁnite) and not fus (hence not bounded).
R3 = R2 ∪ {R2 : p(x, y) ∧ p(u, z) → p(x, z)} is bounded.
Note that the body of R2 contains ‘disconnected’ atoms and
all the atoms produced by R1 are also produced by R2;
moreover, for any instance I, all the atoms producible by
R2 are produced at the ﬁrst breadth-ﬁrst step of the chase.
That is why R3 is bounded with bound 1.

3 Characterizing Parallelisable Rule Sets

In this section, we deﬁne parallelisable rule sets and mo-
tivate the introduction of a new class of existential rules,
namely pieceful. We show that parallelisable rule sets are
exactly those rule sets that are both bounded and pieceful.

3.1 Parallelisable Rule Sets

Parallelisability intuitively means that a sound superset of
the chase can be obtained in a single breadth-ﬁrst step by a
ﬁnite set of rules independent from any instance.

Deﬁnition 2 (Parallelisability). A set of rules R is paral-
lelisable if there exists a ﬁnite rule set R(cid:48) such that for any
instance I:

1. there is an injective homomorphism from chase∞(I, R)

to chase1(I, R(cid:48));

2. there is a homomorphism from chase1(I, R(cid:48))

to

chase∞(I, R).

Such rule set R(cid:48) is said to parallelise R.

Note on this deﬁnition. A more powerful notion of par-
allelisability could be obtained by dropping the injectiv-
ity requirement in Point 1. Then, chase1(I, R(cid:48)) would be
equivalent to chase∞(I, R) but would not necessarily in-
clude it. This notion could also be obtained without chang-
ing the deﬁnition but considering a stronger chase variant
for chase∞(I, R), namely the core chase, which produces a
minimal canonical model of I∪R (Deutsch, Nash, and Rem-
mel 2008). However, the core chase is not monotonic and its
result may even not be obtainable by any R-derivation. We
have chosen here to consider the well-behaved so-chase.
Proposition 1. If R is parallelisable, then it is bounded.

Proof. Let us assume that R is parallelised by R(cid:48). For any
instance I, chase1(I, R(cid:48)) is ﬁnite because R(cid:48) is ﬁnite. As
there is an injection from chase∞(I, R) to chase1(I, R(cid:48)),
chase∞(I, R) is ﬁnite. Now, for each rule R ∈ R(cid:48), let
I = freeze(body(R)): since R is applicable to I and
chase1(I, R(cid:48)) maps to chase∞(I, R), there is kR such that
head(R) maps to chasekR (I, R). Let k be the maximum
kR over all rules R ∈ R. For any instance I, there is n such
that chase∞(I, R) = chasen(I, R) with n ≤ k. Hence, R
is bounded (by k).

The converse is however not true, as witnessed by the fol-

lowing example.
Example 5 (Prime Example). Let R = {R1, R2} where:

R1 : A(x) → ∃z p(x, z)
R2 : p(x, z) ∧ B(y) → r(z, y)

for any n,
R is bounded but not parallelisable.
In = {A(a), B(b1), . . . , B(bn)}.
in
chase∞(In, R) that appears in n + 1 atoms (apply R1 once,
which creates a null, then apply R2 n times). Hence, there is
no ﬁnite set of rules R(cid:48) such that chase∞(In, R) injectively
maps to chase1(I, R(cid:48)) for any n.

There is a null

Let,

Motivated by this example, we now introduce a new class

of rules, called pieceful.

3.2 The Pieceful Class
In short, pieceful rule sets ensure that for any rule applica-
tion, the entire rule frontier is mapped either to terms from
the initial instance or to terms that occur in atoms brought
by a single previous rule application.
Deﬁnition 3 (Pieceful Derivation). An R-derivation (I0 =
I), . . . , Ik, is pieceful if for all i with 0 < i ≤ k, ei-
ther πi(fr(Ri)) ⊆ term(I) or there is j < i such that
πi(fr(Ri)) ⊆ term(Aj), where Aj = πsafe
Deﬁnition 4 (Pieceful Rule Set). A rule set R is pieceful if
(for any instance I) any R-derivation (from I) is pieceful.
Example 6. Consider again Example 5.
From I =
{A(a), B(b)}, one builds a non-pieceful derivation (I0 =
I)(R1, π1, I1)(R2, π2, I2).
(R1, π1) produces
πsafe
(head(R1)) = A1 = {p(a, ν0)}, with ν0 the null cre-
1
ated from z. Then, π2 = {x (cid:55)→ a, y (cid:55)→ b, z (cid:55)→ ν0}. Since
fr(R2) = {y, z} is mapped to {b, ν0}, with b (cid:54)∈ term(A1)
and ν0 (cid:54)∈ term(I), this derivation is not pieceful, hence nei-
ther is R.

(head(Rj)).

Indeed,

j

Interestingly, when a rule set is not pieceful, it is possible
to build instances that generalize the situation from Exam-
ple 5, so that the chase creates nulls that occur in an arbitrar-
ily large number of atoms, as shown by next Proposition 2.
As will become clear later (Proposition 5), the reciprocal
statement is true when the rule set is chase-ﬁnite.
Proposition 2. If R is not pieceful then, for all n, there exist
an instance In and a null νn such that νn occurs in at least
n atoms in chase∞(In, R).

Proof. (Sketch) Let I 0, . . . , I n−1, I n be a non-pieceful
derivation such that I 0, . . . , I n−1 is pieceful, i.e., (Rn, πn)
applied on I n−1 is the ﬁrst application that violates the
pieceful condition. From that derivation, we build a set of
instances {Ii} such that the chase of Ii contains a null that
occurs in at least i (distinct) atoms.

At least one frontier variable of Rn is mapped to a null.
Let k be the largest integer such that (Rk, πk) introduces a
null (in I k) to which a frontier variable of Rn is mapped by
πn. Let ν∗ be this null. We deﬁne by induction on i the
instance Ii as follows, where each fi(I k−1) denotes a freez-
ing of I k−1: (i) I0 = f0(I k−1) and (ii) for any i ≥ 1,
Ii = Ii−1 ∪ fi(I k−1) where:
if x ∈ πk(fr(Rk)), then
fi(x) = f0(x), otherwise fi(x) is a fresh constant (w.r.t. the
whole construction). Intuitively, Ii is built from i + 1 copies
of I k−1, where all the terms have been freshly renamed ex-
cept for those in πk(fr(Rk)). From any Ii, we can build
a derivation that mimics the initial derivation I k−1, . . . , I n
and show that ν occurs in i + 1 atoms.

It follows that any parallelisable set is pieceful:

Proposition 3. If R is parallelisable, then it is pieceful.

Proof. Assume that R is parallelisable by R(cid:48). Notice that
for any I, any null in chase∞(I, R) occurs in at most h
atoms, where h is the maximal size of a rule head in R(cid:48)
(indeed, two distinct rule applications from R(cid:48) cannot share
any null). Since h is bounded independently from I, by con-
traposite of Proposition 2, R is pieceful.

How does the pieceful class ﬁt in the existential rule
landscape? Clearly, pieceful rule sets are greedy-bounded-
treewidth sets (gbts) (Baget et al. 2011b; Rudolph et al.
2014)1, an expressive family for which CQ answering is de-
cidable. The gbts class includes some prominent existential
classes, see Figure 1. There are three basic classes: (plain)
datalog (e.g., (Abiteboul, Hull, and Vianu 1994)), in which
there are no existential variables at all; guarded rules, in
which all the variables from a rule body are guarded, i.e.,
jointly occur in a body atom (Cal`ı, Gottlob, and Lukasiewicz
2009; Cal`ı, Gottlob, and Kifer 2013); frontier-one rules, in
which the frontier of a rule is restricted to (at most) one
variable (Baget et al. 2009). Combining guardedness and
frontier-based restrictions leads to frontier-guarded rules, in
which only the frontier of a rule needs to be guarded (Baget,
Lecl`ere, and Mugnier 2010). The guardedness condition is
further relaxed in weakly (frontier) guarded (w(f)g) rules, in

1Indeed, a pieceful derivation is a speciﬁc greedy derivation and

gbts are those sets for which all derivations are greedy.

Figure 1: The gbts classes ordered by syntactic inclusion (and the
data complexity of the associated Boolean CQ answering problem)

which only the (frontier) variables possibly mapped to nulls
during the chase need to be guarded.

As pictured in Figure 1, the pieceful class includes datalog
and frontier-guarded, but not wg (Example 5 is wg) and it is
not difﬁcult to see that it is actually incomparable with wfg.

Proposition 4. Any set of frontier-guarded existential rules
or of datalog rules is pieceful.

3.3 Characterizing Parallelisability

We ﬁrst point out that the chase of any instance I is equal
to the union of its pieces (w.r.t.
nulls). A fundamen-
tal property of pieceful rules is that the application of a
rule B → H at level i can never connect two pieces of
chasei−1(I, R); when it does not produce an atom already
present in chasei−1(I, R), either it creates a new piece of
size |H| (when the frontier is mapped to terms from I), or it
makes an existing piece grow by |H| atoms (when the fron-
tier is mapped to terms with at least one null).

Proposition 5. If R is pieceful then for any instance I and
integer k, the maximal size of a piece in chasek(I, R) is
bounded independently from I.

Proof. (Sketch) Given I and R, we note P (i) the maximal
size of a piece in chasei(I, R). We prove that P (0) = 1 and,
for i ≥ 0, P (i + 1) ≤ (P (i) × a)fr × h × |R|, where a is the
maximal arity of a predicate, fr and h are the maximal size
of a rule frontier in R and a rule head in R, respectively.

Corollary 1. If R is pieceful and bounded, then for any
instance I, the maximal size of a piece in chase∞(I, R) is
bounded independently from I.

Based on this corollary, we are now able to show that any
bounded pieceful set is parallelisable. We will give another
proof of this result in Sect. 4 (see Cor. 2).

Proposition 6. If R is pieceful and bounded then it is par-
allelisable.

Proof. (Sketch) As R is pieceful and bounded, there is a ﬁ-
nite set of pieces P such that for any instance I, any piece of
chase(I, R) is isomorphic to a piece of P. By isomorphism
from a piece P1 to a piece P2, we mean a bijection b from
term(P1) to term(P2) such that, for all x ∈ term(P1), b(x)
is a null iff x is a null, and b(P1) = P2.

For any piece P ∈ P, let (cP) be a tuple obtained
by a total ordering on const(P ), and consider the query
qP (cP) = ∃y P (cP, y), with y denoting the variables from
P . Let QP be a ﬁnite complete set R-rewritings of qP (note
that we need here the general deﬁnition of piece-uniﬁers that
deals with constants). There is such set for any P , as R is
bounded, hence fus. We deﬁne R(cid:48) as the set of rules of the
shape q(cid:48)
P (x) → ∃yP (x, y), where x is a tuple of variables
in bijection with cP, for P ∈ P and q(cid:48)

P ∈ QP .

From Propositions 1, 3 and 6, we ﬁnally obtain the fol-

lowing characterization of parallelisability:

Theorem 1. A rule set is parallelisable if and only if it is
both bounded and pieceful.

4 Parallelisability and Rule Composition
Early work on datalog has shown that a datalog rule set R
is ‘parallelisable’ (according to our deﬁnition) if and only if
it is bounded (see, e.g., (Gaifman et al. 1993)). Moreover,
such set, say R(cid:63), can be computed by an operation called
unfolding: given rules R1 : B1 → H1 and R2 : B2 → H2,
and a (most general) uniﬁer u of an atom A in B2 with the
atom in H1, the unfolding of R2 by R1 is the rule u(B1) ∪
u(B2 \{A}) → u(H2); starting from R, on can build R(cid:63) by
repeatedly unfolding a rule from R(cid:63) by a rule from R, until
a ﬁxpoint is reached. This is illustrated by the next example.
Example 7 (Datalog Unfolding). Let R = {R1, R2, R3}
with:
R1 : A(x) → B(x)
R2 : C(x) → D(x)
R3 : B(x) ∧ D(x) → G(x)
Denoting Ri ◦ Rj the unfolding of Ri by Rj, we obtain:
R3 ◦ R1 : A(x) ∧ D(x) → G(x)
R3 ◦ R2 : C(x) ∧ B(x) → G(x)
(R3 ◦ R1) ◦ R2 : A(x) ∧ C(x) → G(x)
(R3 ◦ R2) ◦ R1 = (R3 ◦ R1) ◦ R2.
Finally, R(cid:63) = R ∪ {R3 ◦ R1, R3 ◦ R2, (R3 ◦ R1) ◦ R2}.
Here R(cid:63) is ﬁnite, as R is bounded.

In the following, we will consider composition of existen-

tial rules, which generalizes this notion of unfolding.

4.1 Rule Composition
Composition of existential rules has been exploited as a
means of tracing ‘chained’ sequences of rule applications
(e.g., (Baget et al. 2014; Wang, Wang, and Zhang 2018)). It

is naturally based on the notions of piece-uniﬁer and rewrit-
ing. The next deﬁnition of rule composition furthermore
takes pieces into account.
Deﬁnition 5 (Rule Composition). Given rules R1 : B1 →
H1 and R2 : B2 → H2 on disjoint sets of variables, and
µ = (B(cid:48)
1, u) a piece-uniﬁer of B2 with R1, the (exis-
tential) composition of R2 with R1 w.r.t. µ is the following
existential rule, denoted by R2 ◦µ R1, or simply R2 ◦ R1:
1. If u(fr(R2)) ∩ exist(R1) = ∅:

2, H (cid:48)

R2 ◦µ R1 = u(B1) ∪ u(B2 \ B(cid:48)

2) → u(H2)

2. Otherwise:

R2 ◦µ R1 = u(B1) ∪ u(B2 \ B(cid:48)

2) → u(H1) ∪ u(H2)

Note that u(B1) ∪ u(B2 \ B(cid:48)

2) is exactly the rewriting of

B2 w.r.t. µ.

The ﬁrst case in the deﬁnition is when no frontier variable
from R2 is uniﬁed with an existential variable from R1, i.e.,
u(fr(B(cid:48)
2)) ⊆ fr(R1). Then, deﬁning R2 ◦µ R1 as in Point 2
would lead to a rule with a two-piece head (resp., u(H1) and
u(H2)), which can be decomposed into two single-piece-
head rules. Moreover, the rule u(B1)∪u(B2\B(cid:48)
2) → u(H1)
is useless because every application of this rule can be ob-
tained with an application of R1. In the second case, since
at least one frontier variable from B(cid:48)
2 is uniﬁed with an ex-
istential variable from R1, u(H1) ∪ u(H2) forms a single
piece. Therefore, restricting the rule head to u(H2) would
result in a loss of information. Note that in both cases, the
obtained rule R2 ◦ R1 has a single piece head.
Example 8. Let R contain three rules:
R1 : A(x) → ∃z p(x, z)
R2 : p(x, z) → B(z)
R3 : C(x) ∧ B(y) → r(x, y)
The composed rule R3 ◦ R2 = p(x(cid:48), z) ∧ C(x) → r(x, z)
illustrates Point 1. Deﬁning R3 ◦R2 as in Point 2 would lead
to the following rule with a two-piece head:
p(x(cid:48), z) ∧ C(x) → B(z) ∧ r(x, z)
We can see that p(x(cid:48), z) ∧ C(x) → B(z) is useless w.r.t. R2.
R2 ◦ R1 = A(x) → ∃z p(x, z) ∧ B(z) illustrates Point 2.

The set R(cid:63) includes the original set R as well as all rules

obtained by composition.
Deﬁnition 6. (R(cid:63)) The set of (existentially-) composed rules
associated with R, denoted by R(cid:63), is the possibly inﬁnite set
inductively deﬁned as follows:
(base) R ⊆ R(cid:63),
(induction) if Ri, Rj ∈ R(cid:63) and there is a piece-uniﬁer µ of
body(Ri) with Rj, then Ri ◦µ Rj ∈ R(cid:63).

R(cid:63) is sound and complete in the sense that entailment
of Boolean CQs is preserved (with R(cid:63) applied in a single
breadth-ﬁrst step). Formally: for any rule set R, instance
I and Boolean CQ q, holds I, R |= q if and only if holds
chase1(I, R(cid:63)) |= q. Soundness relies on the fact that all
the rules in R(cid:63) are entailed by R and completeness follows
from (Wang, Wang, and Zhang 2018), Prop. 2.

The next proposition yields a more speciﬁc completeness
result: if R is a pieceful rule set, then for any instance I,
each piece of chase∞(I, R) can be obtained by applying a
rule from R(cid:63) to I.

Proposition 7. Let I be an instance and R be a set of rules.
For any pieceful derivation of length i resulting in Ii, for any
piece P in Ii, either P ⊆ I or there exist a rule R∗ ∈ R(cid:63)
and a homomorphism π from body(R∗) to I such that P
maps to πsafe(head(R∗)) by an injective homomorphism.

Proof. (Sketch) We prove the result by induction on the
length i of the derivation. For i = 1, if P (cid:54)⊆ I, then
P has been generated by an application of a rule from
R ∈ R ⊆ R(cid:63). Assuming that the result holds for any piece
P of Ii−1 with i > 1, we show it also holds for any piece
P of Ii. Let I0, (R1, π1, I1), . . . , (Ri, πi, Ii) be a derivation
of length i. The body of Ri is mapped by πi to k pieces
of Ii−1, where k ≤ |var(body(Ri))|. Let P be the piece
created or completed by the application of Ri by πi. As the
derivation is pieceful, P is either a piece of Ii−1 to which
πsafe
(head(Ri)) has been added, or a new piece. We build
i
by induction on k a rule RP that maps by πP to I and such
that P injectively maps to the result of the application of RP
by πP .

We conjecture that the previous result actually holds with-
out the pieceful restriction, but its proof would be more in-
tricate. Thanks to this result, we can reﬁne Proposition 6:
Corollary 2. If R is pieceful and bounded then it is paral-
lelisable by a (ﬁnite) subset of R(cid:63).

Proof. Since R is bounded, the maximum size of a piece is
bounded and each piece can be generated by a derivation of
length bounded by an integer n, where n is independent of
the instance.

Since CQ answering with general existential rules is not
decidable, R(cid:63) can be inﬁnite. The next example shows that
R(cid:63) can be inﬁnite even for R a bounded set of rules, which
may seem surprising.
Example 9. We consider again the prime example, where
R = {R1, R2} is bounded. Let us build R(cid:63):
R1 : A(x) → ∃z p(x, z)
R2 : p(x, z) ∧ B(y) → r(z, y)
R2 ◦ R1 : A(x) ∧ B(y) → ∃z p(x, z) ∧ r(z, y)
R2 ◦ (R2 ◦ R1) : A(x) ∧ B(y) ∧ B(y1) →

∃z p(x, z)∧r(z, y)∧r(z, y1)
etc. At each step, one obtains a new rule by the composition
R2 ◦ R∗, where R∗ is the rule created at the preceding step:
A(x) ∧ B(y) ∧ B(y1) . . . B(yi) →

∃z p(x, z)∧r(z, y)∧r(z, y1) . . .∧r(z, yi)
Not only R(cid:63) is inﬁnite, but no ﬁnite subset of it is complete.
Moreover, the previous example shows that rule compo-
sitions of the form R ◦ R∗, with R ∈ R and R∗ ∈ R(cid:63) are
required to achieve completeness, while rule compositions
of the form R∗ ◦ R are sufﬁcient in the datalog fragment.

4.2 Existential Stability
In Sect. 3.3, we have shown that a rule set is parallelisable if
and only if it is both bounded and pieceful, with this last no-
tion being deﬁned by the behavior of rules during the chase.
The next question we study is whether pieceful rule sets can
be characterized by their behavior during rule composition.

We ﬁrst introduce the ‘existential stability’ property (the rea-
son for this name will be explained in Sect. 4.3).
Deﬁnition 7 (Existential stability). Given rules R1 and R2,
we say that a piece-uniﬁer µ = (B(cid:48)
1, u) of body(R2)
with R1 satisﬁes the (existential) stability property if the fol-
lowing holds:
• either u(fr(R2)) ∩ exist(R1) = ∅,
• or fr(R2) ⊆ var(B(cid:48)

2, H (cid:48)

This notion is extended to a rule set: R satisﬁes the sta-
bility property if, for any rules R1 and R2 in R, any piece-
uniﬁer of R2 with R1 satisﬁes the stability property.

2).

Informally, the stability property says that when a frontier
variable from R2 is uniﬁed with an existential variable from
R1 then all the frontier variables from R2 are uniﬁed. By
the next example, we point out that the stability property of
a rule set may not be preserved when composed rules are
added.
Example 10. Let R from Example 8. It can be checked that
it has the stability property. Now, consider R2 ◦ R1 and R3:
R2 ◦ R1 : A(x) → ∃z p(x, z) ∧ B(z)
R3 : C(x) ∧ B(y) → r(x, y)
Then, R3 ◦ (R2 ◦ R1) involves a piece-uniﬁer that does not
satisfy the stability property: fr(R3) = {x, y}; y is uniﬁed
with z ∈ exist(R2 ◦ R1) but x is not uniﬁed, hence R ∪
{R2 ◦ R1} does not have the stability property.

We say that a rule set R is stable at the inﬁnite if R(cid:63)
satisﬁes the stability property. Next, we show that pieceful
rule sets are exactly those rule sets stable at the inﬁnite.
Proposition 8. Any pieceful rule set satisﬁes the stability
property.

2, H (cid:48)

Proof. Let R1 : B1 → H1 and R2 : B2 → H2 be two
rules of a pieceful rule set and let µ = (B(cid:48)
1, u) be a
piece-uniﬁer of body(R2) with R1. Assume that µ does not
satisfy the stability property. Let I = u(B1) ∪ u(B2 \ B(cid:48)
2).
For simplicity here, we confuse I and its freezing, and we
assume that safe renamings are the identity (indeed, we will
consider a single application of R1 followed by a single
application of R2). R1 is applicable on I by a homomor-
phism h1 extending u|var(B1) (i.e., for all x ∈ var(B1),
h1(x) = u(x) if x ∈ fr(R1), otherwise h1(x) = x). R2 is
applicable on the result of this application, i.e., I ∪ h1(H1),
by a homomorphism h2 extending u|var(B2) (i.e., for all
x ∈ var(B2), h2(x) = u(x) if u(x) is deﬁned, otherwise
h2(x) = x). Since u does not satisfy the stability property,
for some x ∈ fr(R2), u(x) ∈ exist(R1) and for another
x(cid:48) ∈ fr(R2), u(x(cid:48)) is not deﬁned. Hence, h2(x) (cid:54)∈ term(I),
while h2(x(cid:48)) (cid:54)∈ term(h1(H1)), which shows that the deriva-
tion is not pieceful.

Proposition 9. If R is pieceful, then for any rules R1 and
R2 from R, R ∪ {R2 ◦µ R1} is also pieceful.
Proof. (Sketch) We show the contrapositive. Assume R(cid:48) =
R ∪ {R2 ◦µ R1} is not pieceful. Let D(cid:48) = I (cid:48)
n be a
pieceful R(cid:48)-derivation on which (Rn+1, πn+1) is applicable
in a non-pieceful way. We build a non-pieceful R-derivation
D = I1, . . . , Iϕ(n) by induction on n, which satisﬁes the
following:

0, . . . , I (cid:48)

• For all 1 ≤ i ≤ n, there is an isomorphism ψi from I (cid:48)

i to

Iϕ(i)

A(cid:48)

• For any set Aj (produced by an application in D), there is
k (produced by an application in D(cid:48)) s.t. Aj ⊆ ψn(A(cid:48)
k).
Consider now (Rn+1, πn+1). Then ψn ◦ πn+1 is a ho-
If Rn+1 ∈
momorphism from body(Rn+1) to Iϕ(n).
R, by hypothesis on (Rn+1, πn+1),
k s.t.
πn+1(fr(Rn+1))) ⊆ term(A(cid:48)
k). By induction hypothesis,
for every Aj in D, there is A(cid:48)
k(cid:48) s.t. Aj ⊆ ψn(A(cid:48)
k(cid:48)). Hence,
there is no Aj in D s.t. ψn ◦ πn+1(fr(Rn+1)) ⊆ term(Aj),
If Rn+1 = R2 ◦µ R1, the same
and R is not pieceful.
reasoning applies, noting that, since µ satisﬁes the stabil-
ity property, either fr(Rn+1) ⊆ u(fr(R2)) or fr(Rn+1) ⊆
u(fr(R1)).

there is no A(cid:48)

From Prop. 8 and 9, we obtain that pieceful rule sets are

stable at the inﬁnite. We now show the converse direction.

Proposition 10. Any rule set that is stable at the inﬁnite is
pieceful.

Proof. (Sketch) We prove the result by contrapositive. Con-
sidering the ﬁrst application (R, π) that violates the pieceful
constraint in a derivation, we consider a piece P that con-
tains π(x) for some x ∈ fr(R). We consider RP that gener-
ates P (using Proposition 7), and build a piece-uniﬁer µ of
body(R) with RP that violates the stability property.

From the three previous propositions, we obtain the de-

sired result:
Theorem 2. A rule set is pieceful if and only if it is stable at
the inﬁnite.

Finally, as a corollary of Th. 1 and 2, we obtain another

characterization of parallelisable sets of rules.
Corollary 3. A rule set is parallelisable if and only if it is
both bounded and stable at the inﬁnite.

4.3 Beyond Existential Composition
In this section, we question the notion of rule composition
and provide preliminary ﬁndings. We deﬁne another rule
composition operation, which seems to ﬁt better with our
intuition and is more succinct (hence, its name ‘compact’),
but which goes beyond existential rules. We then show that,
for piece-uniﬁers that satisfy the stability property, existen-
tial and compact compositions actually coincide.

For datalog, we know that R(cid:63) is ﬁnite if and only if R is
bounded. To better understand why this is no longer true
for existential rules, let us focus on compositions of the
form R2 ◦ R1, with exist(R1) (cid:54)= ∅. Intuitively, the rules
R2 ◦ R1 capture the situations in the chase where ‘an ap-
plication of R1 leads to trigger a new application of R2’.
More formally: for any instance I, application of R1 to I
yielding I1, homomorphism π2 from body(R2) to I1 such
that π2(body(R2)) (cid:54)⊆ I, with I2 = α(I1, R2, π2), there is
a composed rule R2 ◦ R1 whose application to I yields an
instance isomorphic to I2. One might be tempted to con-
clude that the set of all rules of the form R2 ◦µ R1 (i.e.,
for all piece-uniﬁers µ) is able to capture ‘all applications of

R2 that use an atom brought by an application of R1’, i.e.,
chase1(I, {R1, R2 ◦µ R1|∀µ}) would be equivalent to I1 =
chase1(I, {R1})) ∪ {α(I1, R2, π2)|π2(body(R2)) (cid:54)⊆ I}).

However, this does not hold, as illustrated below.

Example 11. Consider again the prime example with R =
{R1, R2}:
R1 : A(x) → ∃z p(x, z)
R2 : p(x, z) ∧ B(y) → r(z, y)
R2 ◦ R1 : A(x) ∧ B(y) → ∃z p(x, z) ∧ r(z, y).
Let I = {A(a), B(b), B(c)}. Then:

chase∞(I, R) = I ∪ {p(a, z0), r(z0, b), r(z0, c)}

As it is obtained by one application of R1 which trig-
gers two parallel applications of R2,
this also cor-
responds to the above (I1 = chase1(I, {R1})) ∪
{α(I1, R2, π2)|π2(body(R2)) (cid:54)⊆ I}. One (breadth-ﬁrst)
chase step with R ∪ {R2 ◦ R1} would produce instead:

I ∪ {p(a, z0), p(a, z1), r(z1, b), p(a, z2), r(z2, c)}

this is here equal

to chase1(I, {R1, R2 ◦µ
Note that
R1|∀µ}). We can see that two nulls z1 and z2 are created in-
stead of a single one. Obviously, both results are not equiv-
alent. F.i., the Boolean CQ q() = ∃u r(u, b) ∧ r(u, c) would
be answered positively in the ﬁrst case, but not in the second.

In the previous example, the logical formula associated

with R2 ◦ R1 is the following:

∀x∀y (A(x) ∧ B(y) → ∃z (p(x, z) ∧ r(z, y))).

Instead, we propose to interpret rule composition as:

∀x (A(x) → ∃z (p(x, z) ∧ ∀y (B(y) → r(z, y))))

By removing the knowledge entailed by R1, we obtain:

R2 • R1 = ∀x∃z∀y (A(x) ∧ B(y) → p(x, z) ∧ r(z, y))

Deﬁnition 8 (Compact Composition). Let
R1 = ∀x1∀y1 [ B1(x1, y1) → ∃z1 H1(x1, z1) ] and
R2 = ∀x2∀y2 [ B2(x2, y2) → ∃z2 H2(x2, z2) ].
Let µ = (B(cid:48)

1, u) be a piece-uniﬁer of B2 with R1.

2, H (cid:48)

The compact composition of R2 with R1 w.r.t. µ, denoted

by R2 •µ R1 is the following closed formula:

∀x(cid:48)

1∀y1∃z1∀x(cid:48)
(u(B1) ∧ u(B2 \ B(cid:48)

2∀y(cid:48)
2

2) → ∃z2 (u(H1) ∧ u(H2)))
2 = y2 \ var(B(cid:48)

2), y(cid:48)

where x(cid:48)

1 = u(x1), x(cid:48)

2 = x2 \ var(B(cid:48)
2).
Compact composition is more succinct than existential
composition, since a single •-composed rule may capture an
unbounded number of ◦-composed rules. However, the re-
sulting formula is generally not an existential rule. We show
below that, when the piece-uniﬁers involved in rule com-
position satisfy the stability property, the result of compact
composition is equivalent to an existential rule (hence the
name ‘existential stability’) and it coincides with existential
composition (for clarity, we consider below the general form
of existential composition, i.e., ignore Point 1 in Def. 5).

Proposition 11. When the stability property is satisﬁed, the
compact composition is equivalent to the existential compo-
sition, i.e., for all rules R1 and R2, and any piece-uniﬁer
µ of body(R2) with R1 satisfying the stability property,
R2 ◦µ R1 ≡ R2 •µ R1 (where ≡ denotes the logical equiv-
alence and ◦ is deﬁned according to Point 2 of Def. 5).

2∀y(cid:48)

Proof. Note that R2 ◦µ R1 is equivalent to the formula ob-
tained from R2 •µ R1 by moving ∃z1 after ∀x(cid:48)
2. Here,
such an inversion of quantiﬁers can be done without change
of semantics if we can group the atoms in R2 •µ R1 into
two sets, such that one contains all the atoms with vari-
ables in z1 and the other all the atoms with variables in
2 ∪ y(cid:48)
x(cid:48)
2. Since u(H2) may contain variables from both
x(cid:48)
2 and z1, this is possible if and only if u(H2) contains
no variable from x(cid:48)
2 or no variable from z1. We check that
it is indeed the case when µ has the stability property:
if
u(fr(R2))∩exist(R1) = ∅, then u(H2) does not contain any
variable from z1; if fr(R2) ⊆ var(B(cid:48)
2 is empty,
hence u(H2) does not contain any variable from x(cid:48)
2.

2), then x(cid:48)

Finally, one could think of skolemizing existential rules
to get (speciﬁc) logic-programming rules. Brieﬂy, skolem-
ization consists of replacing each existential variable in a
rule head by a fresh functional term over the rule frontier.
Then, rule composition is based on classical (most general)
uniﬁers. However, as illustrated below, the composition of
two skolemized existential rules may not be a skolemized
existential rule. Actually, such composition can be seen as
the skolemization of the formula obtained by compact com-
position, which leads us again beyond the existential rule
fragment.
Example 12 (Skolem composition). Consider the skolem-
ization (noted sk) of the rules from the prime example:
sk(R1) : A(x) → p(x, f (x))
sk(R2) = R2 : p(x, z) ∧ B(y) → r(z, y)
Then, the composition of sk(R2) with sk(R1) yields the fol-
lowing rule, where p(x, f (x)) could be removed:

A(x) ∧ B(y) → p(x, f (x)) ∧ r(f (x), y)
This rule is not the skolemization of any existential rule be-
cause f does not span over the whole rule frontier {x, y}.
Instead, it is sk(R2 • R1).

5 Concluding Remarks
In this paper, we introduce the notion of parallelisability of
a set of existential rules and characterize parallelisable rule
sets in two different ways. One characterization relies on
the behavior of rules during the chase, which leads to de-
ﬁne a new class of existential rules, namely pieceful. An-
other characterization relies on the behavior of rules during
rewriting, which led us to question the notion of rule compo-
sition. We believe that these results open up many perspec-
tives, which we now outline.

Application to OBDA Mature systems, such as OnTop
(Calvanese et al. 2017) or Mastro (Calvanese et al. 2011), are
based on lightweight description logics (typically DL-LiteR
underpinning the W3C language OWL2 QL) and the map-
ping is GAV (i.e., mapping assertions qS(x) → qO(x) sat-
isfy var(qO) ⊆ x). Some other OBDA systems are based on

the lightweight ontological language RDFS, e.g., UltraWrap
(Sequeda, Arenas, and Miranker 2014), where RDFS is ex-
tended with inverse and transitive properties, and mappings
are still GAV, and Obi-Wan (Buron et al. 2020a), strictly re-
stricted to RDFS but with GLAV mappings (i.e., qO is any
CQ).We believe that the existential rule framework is par-
ticularly well suited to the development of OBDA systems
in more expressive settings.
Indeed, existential rules are
able to express both ontological knowledge and relational
GLAV mappings; GLAV mappings provide increased ﬂexi-
bility compared to GAV mappings, by their ability to invent
values, thanks to existential variables. This yields a uniform
setting for the whole OBDA speciﬁcation, thereby facilitat-
ing the analysis of the interactions between O and M, which
is key to efﬁciency. Furthermore, a rich family of existen-
tial rule dialects achieving various expressivity/tractability
tradeoffs are available. In this paper, we have taken a ﬁrst
step towards the design of compilation techniques for this
setting, by characterizing the notion of parallelisability. In-
deed, when the rule set is parallelisable, ontological rea-
soning can be totally compiled into the mapping. Our re-
sults pave the way for the development of query answer-
ing techniques exploiting parallelisation and the speciﬁcities
of existential rule dialects. Another interesting extension of
our work would be to investigate combined reasoning (Lutz,
Toman, and Wolter 2009) or partitioned reasoning (Baget et
al. 2011a), which would allow us to go beyond parallelisable
rule sets.

Deepening Theoretical Foundations The novel pieceful
class is of interest in itself, specially in the context of query
answering.
It includes both datalog and frontier-guarded,
a prominent class of existential rules. Frontier-guarded it-
self covers some major DL dialects used in query answering
(e.g., DL-LiteR or ELHI, see (Mugnier 2020) for more de-
tails on the relationships between these DLs and the gbts
family). We conjecture that CQ answering with pieceful
rules is in PTime for data complexity. By all these features,
the pieceful class is related to the recently introduced warded
class (Bellomarini, Sallinger, and Gottlob 2018), even if
both are incomparable, at least from a syntactic viewpoint
(our prime example is warded but not pieceful, on the other
hand warded does not include frontier-guarded).

Concerning the notion of parallelisability itself, we based
our study on the semi-oblivious chase.
In line with this,
parallelisability requires an injective homomorphism from
chase∞(I, R) to chase1(I, R(cid:48)) (where R(cid:48) is the parallelisa-
tion of R). Dropping the injectivity requirement, i.e., con-
sidering logical equivalence, would lead to a more general
notion of parallelisability, which remains to be investigated.

Finally, we have seen that compact rule composition leads
us beyond the existential rule fragment. The obtained for-
mulas belong to strictly more expressive logical fragments
that have been studied in particular in (Gottlob, Pichler, and
Sallinger 2015). Whether such fragments could lead to par-
allelisation techniques is another open issue.

Acknowledgements
This work is partly supported by the ANR project CQFD
(ANR-18-CE23-0003).

References
Abiteboul, S.; Hull, R.; and Vianu, V. 1994. Foundations of
Databases. Addison Wesley.
Baader, F.; Horrocks, I.; Lutz, C.; and Sattler, U. 2017. An
Introduction to Description Logic. Cambridge University
Press.
Baget, J.-F.; Lecl`ere, M.; Mugnier, M.-L.; and Salvat, E.
2009. Extending Decidable Cases for Rules with Existential
In Proceedings of the 21st International Joint
Variables.
Conference on Artiﬁcial Intelligence, IJCAI 2009, 677–682.
Baget, J.-F.; Lecl`ere, M.; Mugnier, M.-L.; and Salvat, E.
2011a. On rules with existential variables: Walking the de-
cidability line. Artiﬁcial Intelligence 175(9-10):1620–1654.
Baget, J.-F.; Mugnier, M.-L.; Rudolph, S.; and Thomazo,
M. 2011b. Walking the Complexity Lines for Generalized
Guarded Existential Rules. In Proceedings of the 22nd Inter-
national Joint Conference on Artiﬁcial Intelligence, IJCAI
2011, 712–717.
Baget, J.; Garreau, F.; Mugnier, M.; and Rocher, S. 2014.
Extending acyclicity notions for existential rules. In Schaub,
T.; Friedrich, G.; and O’Sullivan, B., eds., ECAI 2014 - 21st
European Conference on Artiﬁcial Intelligence, 18-22 Au-
gust 2014, Prague, Czech Republic - Including Prestigious
Applications of Intelligent Systems (PAIS 2014), volume 263
of Frontiers in Artiﬁcial Intelligence and Applications, 39–
44. IOS Press.
Baget, J.-F.; Lecl`ere, M.; and Mugnier, M.-L. 2010. Walk-
ing the Decidability Line for Rules with Existential Vari-
ables. In Principles of Knowledge Representation and Rea-
soning: Proceedings of the Twelfth International Confer-
ence, KR 2010. AAAI Press.
Bellomarini, L.; Sallinger, E.; and Gottlob, G. 2018. The
vadalog system: Datalog-based reasoning for knowledge
graphs. Proc. VLDB Endow. 11(9):975–987.
Bienvenu, M., and Ortiz, M. 2015. Ontology-mediated
query answering with data-tractable description logics.
In
Reasoning Web, volume 9203 of Lecture Notes in Computer
Science, 218–307. Springer.
Bourhis, P.; Lecl`ere, M.; Mugnier, M.; Tison, S.; Ulliana, F.;
and Gallois, L. 2019. Oblivious and semi-oblivious bound-
edness for existential rules. In Kraus, S., ed., Proceedings of
the Twenty-Eighth International Joint Conference on Artiﬁ-
cial Intelligence, IJCAI 2019, Macao, China, August 10-16,
2019, 1581–1587. ijcai.org.
Buron, M.; Goasdou´e, F.; Manolescu, I.; and Mugnier, M.
2020a. Obi-wan: Ontology-based RDF integration of het-
erogeneous data. Proc. VLDB Endow. 13(12):2933–2936.
Buron, M.; Goasdou´e, F.; Manolescu, I.; and Mugnier, M.
2020b. Ontology-based RDF integration of heterogeneous
data. In Proceedings of the 23nd International Conference
on Extending Database Technology, EDBT 2020, Copen-
hagen, Denmark, March 30 - April 02, 2020, 299–310.

Buron, M.; Mugnier, M.-L.; and Thomazo, M.
2021.
Parallelisable existential rules: a story of pieces. CoRR
abs/2107.06054.
Cal`ı, A.; Gottlob, G.; and Kifer, M. 2013. Taming the in-
ﬁnite chase: Query answering under expressive relational
constraints. J. Artif. Intell. Res. (JAIR) 48:115–174.
Cal`ı, A.; Gottlob, G.; and Lukasiewicz, T. 2009. A General
Datalog-Based Framework for Tractable Query Answer-
In Proceedings of the Twenty-Eigth
ing over Ontologies.
ACM SIGMOD-SIGACT-SIGART Symposium on Principles
of Database Systems, PODS 2009, 77–86. ACM.
Calvanese, D.; De Giacomo, G.; Lembo, D.; Lenzerini, M.;
and Rosati, R. 2007. Tractable Reasoning and Efﬁcient
Query Answering in Description Logics: The DL-Lite Fam-
ily. Journal of Automated Reasoning 39(3):385–429.
Calvanese, D.; De Giacomo, G.; Lembo, D.; Lenzerini, M.;
Poggi, A.; Rodriguez-Muro, M.; Rosati, R.; Ruzzi, M.; and
Savo, D. F. 2011. The MASTRO system for ontology-based
data access. Semantic Web 2(1).
Calvanese, D.; Cogrel, B.; Komla-Ebri, S.; Kontchakov, R.;
Lanti, D.; Rezk, M.; Rodriguez-Muro, M.; and Xiao, G.
2017. Ontop: Answering SPARQL queries over relational
databases. Semantic Web 8(3).
Delivorias, S.; Lecl`ere, M.; Mugnier, M.; and Ulliana, F.
2021. Characterizing boundedness in chase variants. Theory
Pract. Log. Program. 21(1):51–79.
The
Deutsch, A.; Nash, A.; and Remmel, J.
In Proceedings of the Twenty-Seventh
chase revisited.
ACM SIGMOD-SIGACT-SIGART Symposium on Principles
of Database Systems, PODS 2008, 149–158.
Gaifman, H.; Mairson, H. G.; Sagiv, Y.; and Vardi, M. Y.
1993. Undecidable optimization problems for database logic
programs. J. ACM 40(3):683–713.
Gottlob, G.; Pichler, R.; and Sallinger, E. 2015. Func-
tion symbols in tuple-generating dependencies: Expressive
power and computability.
In Milo, T., and Calvanese, D.,
eds., Proceedings of the 34th ACM Symposium on Princi-
ples of Database Systems, PODS 2015, Melbourne, Victoria,
Australia, May 31 - June 4, 2015, 65–77. ACM.
Hillebrand, G. G.; Kanellakis, P. C.; Mairson, H. G.; and
Vardi, M. Y. 1995. Undecidable boundedness problems for
datalog programs. J. Log. Program. 25(2):163–190.
K¨onig, M.; Lecl`ere, M.; Mugnier, M.; and Thomazo, M.
2015. Sound, complete and minimal ucq-rewritings for ex-
istential rules. Semantic Web Journal 6(5):451–475.
Kontchakov, R.; Rezk, M.; Rodriguez-Muro, M.; Xiao, G.;
and Zakharyaschev, M. 2014. Answering SPARQL queries
over databases under OWL 2 QL entailment regime. In The
Semantic Web - ISWC 2014 - 13th International Semantic
Web Conference, volume 8796, 552–567. Springer.
Lenzerini, M. 2018. Managing data through the lens of an
ontology. AI Mag. 39(2):65–74.
Lutz, C.; Toman, D.; and Wolter, F. 2009. Conjunctive
Query Answering in the Description Logic EL Using a Re-
lational Database System. In Proceedings of the 21st Inter-

2008.

2009.

national Joint Conference on Artiﬁcial Intelligence, IJCAI
2009, 2070–2075.
Generalized schema-mappings:
Marnette, B.
In Proceedings of the
from termination to tractability.
Twenty-Eigth ACM SIGMOD-SIGACT-SIGART Symposium
on Principles of Database Systems, PODS 2009, 13–22.
Mugnier, M. 2020. Data access with horn ontologies: Where
description logics meet existential rules. K¨unstliche Intell.
34(4):475–489.
Poggi, A.; Lembo, D.; Calvanese, D.; De Giacomo, G.;
Lenzerini, M.; and Rosati, R. 2008. Linking data to on-
tologies. J. Data Semantics 10:133–173.
Rudolph, S.; Thomazo, M.; Baget, J.-F.; and Mugnier, M.-L.
2014. Worst-case optimal query answering for greedy sets of
existential rules and their subclasses. CoRR abs/1412.4485.
Sequeda, J. F.; Arenas, M.; and Miranker, D. P. 2014.
OBDA: query rewriting or materialization?
in practice,
both! In ISWC.
Wang, Z.; Wang, K.; and Zhang, X. 2018. Forgetting and
unfolding for existential rules. In McIlraith, S. A., and Wein-
berger, K. Q., eds., Proceedings of the Thirty-Second AAAI
Conference on Artiﬁcial Intelligence, (AAAI-18), the 30th
innovative Applications of Artiﬁcial Intelligence (IAAI-18),
and the 8th AAAI Symposium on Educational Advances in
Artiﬁcial Intelligence (EAAI-18), New Orleans, Louisiana,
USA, February 2-7, 2018, 2013–2020. AAAI Press.
Xiao, G.; Calvanese, D.; Kontchakov, R.; Lembo, D.; Poggi,
A.; Rosati, R.; and Zakharyaschev, M. 2018. Ontology-
based data access: A survey. In IJCAI, 5511–5519. ijcai.org.

