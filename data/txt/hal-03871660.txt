Web Audio Modules 2.0: Audio Plugins for the Web
Platform!
Michel Buffa

To cite this version:

Michel Buffa. Web Audio Modules 2.0: Audio Plugins for the Web Platform!. ADC 2022 - Audio
Developer Conference, Nov 2022, Londres, United Kingdom. ￿hal-03871660￿

HAL Id: hal-03871660

https://inria.hal.science/hal-03871660

Submitted on 25 Nov 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Who am I? What is our group?

● Professor / researcher at Université Côte d’Azur (UCA), France

○ Member of the WIMMICS research group common to INRIA and I3S lab from CNRS
○ W3C Advisory Committee Representative for UCA
○ Member of the W3C WebAudio Working 

Group since 2014 

○ michel.buffa@univ-cotedazur.fr, @micbuffa

● Other members of the WAM group:

○ WAM original creators: Jari Kleimola

And Oliver Larkin,

○ Developers, academic researchers, PhD 

Students : Shihong Ren, Owen Campbell, 
Tom Burns, Steven Yi, Stéphane Letz, 
Hugo Mallet…
Thanks to: Jordan Sintes, Guillaume Etevenard, GRAME friends…

○

Web Audio Modules: VSTs for the Web!

Wams in hosts… here with a host from the WAM 
distrib https://mainline.i3s.unice.fr/wam2/packages/_/ 

WAMs in hosts… WIP open source DAW (100% 
WAM-based)

WAMs in hosts… here the WASABI pedalboard

WAMs in hosts… https://sequencer.party/

Wams in hosts… https://app.ampedstudio.com/

WAMs in hosts… JSPatcher, aka Max MSP in the 
browser  (https://github.com/Fr0stbyteR/jspatcher)

WAMs in plugins that acts as hosts (i.e pedalboard)

These ones 
are open 
source 

(from wam-examples 
and wam-community 
github repositories)

… and loaded in a DAW!

A few reminders before proceeding…

W3C WebAudio API: connecting nodes and build an 
audio graph, it’s a low level API…

Example: an audio delay effect, made with standard audio nodes. You assemble 
the graph in JavaScript (main thread), then control the parameters, the GUI.
Audio rendering is done in the browser, in the audio thread. 

The Web Audio API also supports custom DSP 
programming with the AudioWorklet

This is where custom 
DSP processing is done!

Can be done in 
JavaScript or in a
WebAssembly module!

This is where the AW 
node is created, 
connected to the audio 
graph, where the GUI is 
managed etc. 
(JavaScript)

Web Audio development

Web developers

● Use plain HTML/CSS/JavaScript but very often 

also bundlers/minifiers (webpack, parcel, 
rollup), npm modules, frameworks (react, 
vueJS), and also code with TypeScript, etc.

Audio developers

● Use C++/Rust, DSLs like FAUST, Csound, 

CMajor, patchers like Max, etc.

● Use plugin standards: VSTs, AU, AAX, RTAS, 

JUCE, CLAP, iPlug2, etc.  

How to combine all this?

2015: First WAM proposal by J.Kleimola and 
O.Larkin

● Attract native developers, help going from 
C++ plugins to AudioWorklet/ASM.js and 
later WebAssembly,

● http://webaudiomodules.org has impressive 

synths ported from VST/JUCE/iPlug2

2018: Enlarge the proposal (Buffa and al.)

● Please web developers,
● Support DSLs like FAUST, other 

improvements…

WebAudioModules version 2 (aka WAM or WAM2)

● 2021-2022: WebAudio Modules 2.0 

○

○
○

○

○

○

○
○
○
○

A WAM plugin can be loaded using a 
simple URI!
A WAM plugin is a JavaScript module,
A WAM can be made of a single 
AudioWorklet Node, or made of multiple 
nodes, it will behave like a single 
AudioNode.
Plugin parameters are handled by the 
WamParamMgr,
Focus on performance (ring buffer, audio 
thread isolation)
Plain modern JS or build systems for JS / 
TS / frameworks
Support for C/C++
Support for DSL (Faust, CSound)
Parameter Automation, MIDI support,
host/plugin interaction as an API (+ rich 
SDK). The API can be entirely 
re-implemented for low-level plugins

How to start with WAMs!

Github repo, Home page of 
the project…

WebAudioModules (WAM) is an old standard 
(2015), and WAM2 is the updated version:

● webaudiomodules.org will remain the home 

of the project (not yet up to date! 
Soon with a section about WAM2!)

●

The official github repo is the regular 
webaudiomodules one: 
https://github.com/webaudiomodules.

● Everything is under MIT/MPL/Apache 2.0 

open source licence…

● Also available as npm modules

API vs SDK

API (Standard)

SDK (Implementation/Tools)

- Defines required methods
- Abstract classes

- Reference API implementations
- Utility classes and example plugins

● Developers can choose to adapt their existing code to the API

● Others can use the SDK that implements the API (much easier), inherit classes etc.

The sdk-parammgr repository 

Dedicated to plugins made of an 
audio graph:

● Exports a CompositeNode 

class, the plugin will be seen as 
a single node!

● Deals with parameter mapping 

and automation (figure).

3 exposed 
parameters

Dozens of internal parameters

The wam-examples repository

WAM2 step by step tutorials

Several tutorials are available at https://wam-examples.vidalmazuy.fr/

Also, check the wam-community repository 
https://github.com/boourns/wam-community

Used by the community to publish and 
share “ready to use” plugins!

● Remember that a plugin is just a URI!
● Several dozens of plugins available, 
99% also available with source code to 
study (github.com/boourns/burns-audio-wam)
● Cover all classic effects, proposes 

some instruments and utilitary plugins.

● All plugins available in the 

https://sequencer.party host.

Build a WebAssembly WAM 
in seconds with FAUST DSL

FAUST: a DSL for DSP programming, born in 2002 at GRAME-CNCM, France

Used in artistic productions, education and research, open source projects and 
commercial applications.

Faust offers end-users a high-level alternative to C/C++ to develop audio 
applications for a large variety of platforms.

The role of the Faust compiler is to synthesize the most efficient implementations 
for the target language (C, C++, LLVM, WebAssembly, etc.).

Online doc / tutorial so that you can experiment yourself, create, build GUI, export 
WAM2 plugins directly from the FAUST online IDE.

Conclusion / Perspectives

The WAM standard is stable now and comes with many examples.

OUR MAIN CONCERN NOW: get inputs from developers 

regarding barriers to entry / adoption!

Things that will come soon:

○
○

The wam-community repo is growing :-)
The WAM SDK has been extended to support 3D 
WebGL/GLSL/Video extensions

○ A WAM based DAW is under development and will be open source
○ More examples using WASM, in particular C++/WASM
○ Remote plugin server with API

Join us on slack WebAudio channel / #webaudiomodules!

Interact with a host, be it in main or audio thread
1 - The WebAudioModule API

Main Thread

AudioWorklet Thread

WebAudioModule API

Host

WamNode API

WamProcessor API

Host

GUI (HTMLElement)

WamEnv API

A plugin = instance of a WAM = “a WAM”
API - WebAudioModule

export interface WebAudioModule<Node extends WamNode = WamNode> {

    /**

     * This async method must be redefined to get `AudioNode` that

    /** should return `true` */

    readonly isWebAudioModule: boolean;

    /** The `AudioContext` where the plugin's node lives in */

    audioContext: BaseAudioContext;

    /**

     * The `AudioNode` that handles audio in the plugin

     * where the host can connect to/from

     */
   audioNode: Node;

     * will connected to the host.

     * It can be any object that extends `AudioNode` and implements `WamNode`

     */
   createAudioNode(initialState?: any): Promise<WamNode>;

    /**

     * The host will call this method to initialize the WAM with an initial state.

     *

     * In this method, WAM devs should call `createAudioNode()`

     * and store its return `AudioNode` to `this.audioNode`,

    /** This will return true after calling `initialize()`. */

     * then set `initialized` to `true` to ensure that

    initialized: boolean;

     * the `audioNode` property is available after initialized.

    /** The identifier of the current WAM, composed of vender + name */
   readonly moduleId: string;

    /** The unique identifier of the current WAM instance. */
   readonly instanceId: string;

    /** The values from `descriptor.json` */

    readonly descriptor: WamDescriptor;

    /** The WAM's name */

    readonly name: string;

    /** The WAM Vendor's name */

    readonly vendor: string;

     *

     * These two behaviors are implemented by default in the SDK.

     *

     * The WAM devs can also fetch and preload the GUI Element in while initializing.

     */

    initialize(state?: any): Promise<WebAudioModule>;

    /** Redefine this method to get the WAM's GUI as an HTML `Element`. */
   createGui(): Promise<Element>;

    /** Clean up an element previously returned by `createGui` */

    destroyGui(gui: Element): void

}

2 - The WamNode API

Main Thread

AudioWorklet Thread

WebAudioModule API

Host

WamNode API

WamProcessor API

Host

GUI (HTMLElement)

WamEnv API

A WAM contains a WamNode, here is the API

export interface WamNode extends AudioNode, Readonly<WamNodeOptions> {

    readonly module: WebAudioModule;

    /** Get parameter info for the specified parameter ids, or omit argument to get info for all parameters. */

    getParameterInfo(...parameterIdQuery: string[]): Promise<WamParameterInfoMap>;

    /** Get parameter values for the specified parameter ids, or omit argument to get values for all parameters. */

    getParameterValues(normalized?: boolean, ...parameterIdQuery: string[]): Promise<WamParameterDataMap>;

    /** Set parameter values for the specified parameter ids. */

    setParameterValues(parameterValues: WamParameterDataMap): Promise<void>;

    /** Returns an object (such as JSON or a serialized blob) that can be used to restore the WAM's state. */
    getState(): Promise<any>;

  setState(state: any): Promise<void>;

    /** Compensation delay hint in samples */

    getCompensationDelay(): Promise<number>;

    /** Register a callback function so it will be called when matching events are processed. */

    addEventListener<K extends keyof WamEventMap>(type: K, listener: (this: this, ev: CustomEvent<WamEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;

    addEventListener(type: string, listener: (this: this, ev: CustomEvent) => any, options?: boolean | AddEventListenerOptions): void;

    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;

    /** Deregister a callback function so it will no longer be called when matching events are processed. */

    removeEventListener<K extends keyof WamEventMap>(type: K, listener: (this: this, ev: CustomEvent<WamEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;

    removeEventListener(type: string, listener: (this: this, ev: CustomEvent) => any, options?: boolean | AddEventListenerOptions): void;

    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;

    /** Schedule a WamEvent. Listeners will be triggered when the event is processed. */
  scheduleEvents(...event: WamEvent[]): void;

    /** Clear all pending WamEvents. */

    clearEvents(): void;

    /** Connect an event output stream to another WAM. If no output index is given, assume output 0. */
    connectEvents(to: WamNode, output?: number): void;

    /** Disconnect an event output stream from another WAM. If no arguments are given, all event streams will be disconnected. */

    disconnectEvents(to?: WamNode, output?: number): void;

    /** Stop processing and remove the node from the graph. */

    destroy(): void;

}

3 - The WamProcessor API

Main Thread

AudioWorklet Thread

WebAudioModule API

Host

WamNode API

WamProcessor API

Host

GUI (HTMLElement)

WamEnv API

WAMs also have an explicit/implicit WamProcessor
API - WamProcessor

export interface WamProcessor extends AudioWorkletProcessor {

    readonly moduleId: string;

    readonly instanceId: string;

    /** Compensation delay hint in seconds. */

    getCompensationDelay(): number;

    /** Schedule a WamEvent. Listeners will be triggered when the event is processed. */

    scheduleEvents(...event: WamEvent[]): void;

    /** Schedule events for all the downstream WAMs */
    emitEvents(...events: WamEvent[]): void;

    /** Clear all pending WamEvents. */

    clearEvents(): void;

    /** Process a block of samples. Note that `parameters` argument is ignored. */
    process(inputs: Float32Array[][],outputs: Float32Array[][],parameters: Record<string, Float32Array>): boolean;

    /** Stop processing and remove the node from the WAM event graph. */

    destroy(): void;

}

WamEnv and WamGroup: manage plugin chains

Send events downstream to a list of chained plugins…, manage group (states) etc.

