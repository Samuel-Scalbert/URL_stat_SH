Passive Query-Recovery Attack Against Secure
Conjunctive Keyword Search Schemes
Marco Dijkslag, Marc Damie, Florian Hahn, Andreas Peter

To cite this version:

Marco Dijkslag, Marc Damie, Florian Hahn, Andreas Peter. Passive Query-Recovery Attack Against
Secure Conjunctive Keyword Search Schemes. ACNS 2022 - International Conference on Applied
Cryptography and Network Security, Jun 2022, Rome, Italy. pp.126-146, ￿10.1007/978-3-031-09234-
3_7￿. ￿hal-03854573￿

HAL Id: hal-03854573

https://inria.hal.science/hal-03854573

Submitted on 28 Jun 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Passive query-recovery attack against secure
conjunctive keyword search schemes

Marco Dijkslag1, Marc Damie3, Florian Hahn1, and Andreas Peter1,2

1 University of Twente, Enschede, The Netherlands
m.dijkslag@alumnus.utwente.nl, {f.w.hahn,a.peter}@utwente.nl
2 University of Oldenburg, Oldenburg, Germany
andreas.peter@uni-oldenburg.de
3 Univ. Lille, Inria, CNRS, Centrale Lille, UMR 9189 - CRIStAL, Lille, France
marc.damie@inria.fr

Abstract. While storing documents on the cloud can be attractive, the
question remains whether cloud providers can be trusted with storing
private documents. Even if trusted, data breaches are ubiquitous. To
prevent information leakage one can store documents encrypted. If en-
crypted under traditional schemes, one loses the ability to perform simple
operations over the documents, such as searching through them. Search-
able encryption schemes were proposed allowing some search function-
ality while documents remain encrypted. Orthogonally, research is done
to ﬁnd attacks that exploit search and access pattern leakage that most
eﬃcient schemes have. One type of such an attack is the ability to re-
cover plaintext queries. Passive query-recovery attacks on single-keyword
search schemes have been proposed in literature, however, conjunctive
keyword search has not been considered, although keyword searches with
two or three keywords appear more frequently in online searches.
We introduce a generic extension strategy for existing passive query-
recovery attacks against single-keyword search schemes and explore its
applicability for the attack presented by Damie et al. (USENIX Secu-
rity ’21). While the original attack achieves up to a recovery rate of
85% against single-keyword search schemes for an attacker without ex-
act background knowledge, our experiments show that the generic exten-
sion to conjunctive queries comes with a signiﬁcant performance decrease
achieving recovery rates of at most 32%. Assuming a stronger attacker
with partial knowledge of the indexed document set boosts the recov-
ery rate to 85% for conjunctive keyword queries with two keywords and
achieves similar recovery rates as previous attacks by Cash et al. (CCS
’15) and Islam et al. (NDSS ’12) in the same setting for single-keyword
search schemes.

Keywords: Searchable encryption · conjunctive keyword search · pas-
sive query-recovery attack.

1

Introduction

With increasing number of enterprises storing their documents in the cloud the
question arises how to cope with storing sensitive documents on the cloud with-

2

M. Dijkslag et al.

out the cloud provider learning information about the stored documents or in-
formation being leaked when a data breach occurs. One solution for this problem
would be to encrypt the documents to hide its contents to the cloud provider.
However, this prevents users from using the (often available) computational re-
sources cloud providers oﬀer, since searching through the documents is no longer
possible without ﬁrst downloading and decrypting it.

Searchable symmetric encryption schemes can be a solution to this prob-
lem that oﬀer constructions for search functionalities over encrypted documents.
The ﬁrst practical solution towards searchable encryption has been proposed
by Song et al. [22]. Proposers of searchable encryption schemes need to ﬁnd a
trade-oﬀ in eﬃciency, security, and functionality. With this trade-oﬀ in terms of
security comes information leakage such as possible search pattern leakage (re-
vealing which queries concerned the same underlying, but unknown, keyword)
and access pattern leakage (revealing the identiﬁers of all documents matching
the search query). Most of the eﬃcient searchable encryption schemes that allow
for keyword search leak information in the access pattern for eﬃciency.

Searchable encryption is an active line of research for ﬁnding eﬃcient schemes
that allow for search in encrypted documents with well-deﬁned security in terms
of a leakage function. Orthogonally, research is performed on ﬁnding attacks
against proposed searchable encryption schemes. One such type of attack is a
query-recovery attack, i.e. the ability for an adversary to recover the plaintexts
from performed queries. In general two kinds of query-recovery attacks exist: (1)
a passive attack where an adversary only has access to the information leaked
by a scheme and (2) an active attack in which an adversary is able to inject
tailored documents into the to-be-searched dataset.

Active query-recovery attacks on conjunctive keyword search do exist [28,
18] which are described as an extension on the proposed single-keyword search
attack. Currently, all existing passive query-recovery attacks against searchable
symmetric encryption that allow for keyword searches only focuses on single-
keyword search schemes. However, these attacks do not reﬂect a realistic scenario,
since single-keyword searches are limited and statistics show that the number of
keywords used by people online in the US peaks at two keywords [5]. Also, three
keyword searches are still more frequent than searches for a single keyword. The
frequency of searches using seven or more keywords becomes negligible.

Note that the recovery of conjunctive keyword queries is more diﬃcult with
respect to the recovery of single-keyword queries using similar vocabulary sizes.
This diﬃculty stems from the fact that the space for keyword conjunctions is
combinatorial in the number of conjunction terms compared to single-keywords,
therefore an attacker needs to consider more possible candidates of keyword
conjunctions for each observed query.

In this work, we explore a passive query-recovery attack against secure con-
junctive keyword search (CKWS) schemes. We propose a generic extension strat-
egy for query-recovery attacks against single-keyword search to recover conjunc-
tive queries using the same attack. Our extension strategy is based on the use
of trapdoors created from a keyword-conjunction set as a generalization of trap-

Passive query-recovery attack against secure CKWS schemes

3

doors created from single-keywords. Replacing keywords with keyword conjunc-
tion sets. Our attack is static and does also work on forward and backward
private schemes ([17]).

We introduce an adaptation of the query-recovery attack proposed by Damie
et al. [6] to achieve keyword conjunction recovery. We explore the applicability of
the attack in two setups: (1) a similar-documents attack, where the attacker only
has access to a set of documents that is similar, but otherwise diﬀerent, from the
indexed documents and (2) a known-documents attack, where the attacker has
(partial) knowledge of the indexed documents. In both setups it is assumed the
attacker knows the keyword conjunctions for a small set of queries a priori. We
experimentally show that our attack can work for a relatively small vocabulary
size (500) in an attack setup allowing only conjunctive keyword search using 2
keywords. However, we show that in an attack setup using similar-documents
the attack performs poorly unless many known queries are assumed to be part of
the attacker’s knowledge. Furthermore, we demonstrate limitations of our generic
extension posed by the combinatorial complexity increase for larger conjunctions.

2 Related work

Most attacks against searchable symmetric encryption that have been described
in the literature are query-recovery attacks. Islam et al. [10] were the ﬁrst to
propose a passive query-recovery attack in which they are exploiting the access
pattern leakage, i.e. leaked document identiﬁers from observed queries. In their
attack, the adversary needs to know all the documents indexed on the server to
be successful. They introduced the idea of computing (word-word and trapdoor-
trapdoor) co-occurrences to attack SSE. This idea being reused by other the
passive attacks. The attack works by ﬁnding the closest mapping between the
word-word co-occurrence matrix and trapdoor-trapdoor co-occurrence matrix in
which they use meta heuristic simulated annealing. Also, the attack requires a
number of known queries to work, i.e. trapdoors from which the attacker knows
the underlying plaintext value.

Cash et al. [3] proposed another passive query-recovery attack. Their attack
ﬁrst exploits that keywords with high frequency have unique keyword document
counts to initialize their set of known queries. Then for keywords that do not have
a unique keyword document occurrence count they construct a co-occurrence
matrix of their known documents and observed queries, similar to Islam et al.
They try to recover more queries by constructing for every unknown query their
candidate set (i.e. keywords having the same document occurrence count) and
remove candidates from the set that do not have the same co-occurrence with a
known query in the known queries set. If after iterating over every known query
only one candidate is left, the last candidate is appended to the known queries
set. This process is repeated for all unknown queries until the set of known
queries stops increasing.

Both [10, 3] rely on the attacker knowing a large part of the indexed doc-
uments, where the count attack performs better than the attack by Islam et

4

M. Dijkslag et al.

al. However, their query recovery rate roughly only increases when the attacker
knows at least 80% of the indexed documents.

The query-recovery attack proposed by Pouliot et al. [21] uses weighted graph
matching where the attacker needs to ﬁnd mapping of keyword graph 𝐺 and trap-
door graph 𝐻. The attack achieves recovery rates above 90% when the attacker
knows the entire set of indexed documents, but fails as similar-documents attack
unless having a smaller set of documents and vocabulary size. Also, the runtime
of the attack increases rapidly, where for a vocabulary size of 500 the attack runs
in less than one hour, whereas it takes more than 16 hours for a vocabulary size
of 1000. The attack in [10] has a runtime of a maximum of 14 hours, whereas
attacks from [3, 6] run in seconds.

Ning et al. [15] introduced a query-recovery attack that works when the
attacker knows a percentage of the indexed documents. Keywords and trapdoors
are represented as a binary string where the 𝑖-th bit is 1 if the keyword (resp.
trapdoor) occurs in document 𝑖. Recovery is done by converting the bit strings
to integers, where it is considered that a keyword corresponds to a trapdoor if
they have the same integer value.

The proposed attack outperforms the attack by Cash et al. [3], where in their
scenario [3] achieves a recovery rate of roughly 28% and their proposed attack
around 56% when the attacker knows 80% of the indexed documents. However,
they do not report a recovery rate for an attacker having knowledge of more
than 80% of the indexed documents.

Blackstone et al. [2] proposed a ”sub-graph” attack requiring much less known
documents to be successful and also works on co-occurrence hiding schemes.
Their experiments show that an attacker only needs to know 20% of the indexed
documents to succeed in her attack.

In [6], Damie et al. proposed their reﬁned score attack that works in a setting
where the attacker only knows a similar, but otherwise diﬀerent and non-indexed,
set of documents for query-recovery. A mathematical formalization of the simi-
larity is proposed in their paper. In [3] they showed that both the attack proposed
by Islam et al. [10] and their proposed count attack do not work using similar
documents. In [6], the query-recovery attack uses similar techniques as used by
[10, 3], i.e. constructing co-occurrence matrices from the document set known by
the attacker and a trapdoor-trapdoor co-occurrence matrix from the assumed
access pattern leakage. By starting with a few known (keyword, trapdoor)-pairs
their attack iteratively recovers queries where previous recovered queries with
high conﬁdence scores are added to the set of known queries. Using this approach
their attack reaches recovery rates around 85%.

Other types of attacks. Zhang et al. [28] proposed an eﬀective active
document injection attack to recover keywords. Furthermore, they proposed an
extension of their attack to a conjunctive keyword search setting which was
experimentally veriﬁed for queries with 3 keywords.

In [18], Poddar et al. proposed several attacks that uses volume pattern as
auxiliary information in combination with the attacker’s ability to replay queries
and inject documents. Moreover, they also gave an extension of their attack for

Passive query-recovery attack against secure CKWS schemes

5

queries with conjunctive keywords which is based on the extension from [28]
using a document injection approach.

Liu et al. [14] proposed a query-recovery attack which makes use of the search
pattern leakage as auxiliary information. In particular, they exploit the query
frequency. However, they simulated their queries by applying Gaussian noise to
keyword search frequency from Google Trends4 because of the lack of a query
dataset. The attacker has access to the original frequencies.

Another attack introduced by Oya and Kerschbaum [16] combines both vol-
ume information derived from the access pattern leakage and query frequency
information derived from the search pattern leakage as auxiliary information.

Conjunctive keyword search schemes. Passive query-recovery attacks
against single-keyword search schemes already work for some conjunctive key-
word search schemes where the server performs search for each individual key-
word in a query independently and returns the intersection of document identi-
ﬁers of each single-keyword search, i.e. leaking the full access pattern for each
individual keyword in the conjunction. However, these attacks cannot be applied
on conjunctive keyword search schemes with less or common access pattern leak-
age, where common refers to the scheme only leaking the document identiﬁers for
the documents containing all keywords from a conjunctive keyword query. Hence,
in this work we explore one extension strategy for conjunctive keywords that can
be applied to most passive query-recovery attacks against single-keyword search
using only common access pattern leakage.

[19, 23] both proposed such a conjunctive keyword search scheme that returns
the intersection of document identiﬁers for each individual keyword in a conjunc-
tive keyword query, thus leaking the full access pattern. However, we would like
to emphasize that in this scenario only an honest-but-curious server that is able
to observe the result set for each intermediate keyword can be considered an at-
tacker, since an eavesdropper on the communication channel would not be able
to observe the document identiﬁers for each intermediate single-keyword search.
Furthermore, it should be noted that both schemes also oﬀer more functionality
than conjunctive keyword search alone. Where [19] allows for phrase searches
and [23] oﬀers result set veriﬁability and index updatability.

Other proposed conjunctive keyword search schemes exist ([8, 4, 11, 7, 27,
13, 26, 9, 24]). However, all of them leak at least the common access pattern,
where [4, 9, 25] have more than common access pattern leakage. To the best of
our knowledge there do not exist eﬃcient conjunctive keyword search schemes
that have no access pattern leakage.

3 Preliminaries

We ﬁrst introduce some notations that are used throughout this work. Let doc-
ument set D consist of documents {𝐷1, ..., 𝐷 𝑛}. Let keyword set W consist of
keywords {𝑤1, ..., 𝑤𝑚}. Document 𝐷𝑖 consists of keywords that form a subset of
4 https://trends.google.com/trends

6

M. Dijkslag et al.

Table 1. Notation

Notation Meaning

Size notation

Q
𝑅𝑄
KnownQ Known (td, ckw)-pairs by the adversary

Set of observed trapdoors by the adversary
Document identiﬁers for each observed td ∈ Q

ckw𝑞

𝐶ckw

𝐶td

Set of distinct keywords used in
a conjunctive keyword query 𝑞

ckw-ckw co-occurrence matrix created
from Dsimilar or D 𝑝−known
td-td co-occurrence matrix created from 𝑅𝑄

Dreal
Dsimilar
D 𝑝−known 𝑝-Known document set (0 < 𝑝 ≤ 1)

Real (indexed) document set
Similar document set

𝑙
𝑙
𝑘

𝑑

𝑚similar × 𝑚similar
or 𝑚known × 𝑚known
𝑙 × 𝑙

𝑛real
𝑛similar
𝑛known (= 𝑝 · 𝑛real)

Vocabulary of keywords extracted from Dreal

Wreal
𝑣real
Wsimilar Vocabulary of keywords extracted from Dsimilar
𝑣similar
Wknown Vocabulary of keywords extracted from D 𝑝−known 𝑣known

Kreal

Ksimilar

Kknown

Set containing possible conjunctions of keyword
combinations generated from Wreal
Set containing possible conjunctions of keyword
combinations generated from Wsimilar
Set containing possible conjunctions of keyword
combinations generated from Wknown

𝑚real = (cid:0)

𝑣real
𝑑 (cid:1)

𝑚similar = (cid:0)

𝑣similar
𝑑

(cid:1)

𝑚known = (cid:0)

𝑣known
𝑑 (cid:1)

keyword set W. Let 𝑖𝑑 (𝐷𝑖) = 𝑖 return the identiﬁer for document 𝐷𝑖. We denote
𝑥 ∈ 𝐷𝑖 if keyword 𝑥 (∈ W) occurs in document 𝐷𝑖. A summary of all notations
and their meaning used throughout this work is given in Table 1.

3.1 Searchable symmetric encryption

A searchable encryption scheme allows a user to search in encrypted documents
and is often described in a client-server setting. The client can search through
encrypted documents stored on the server, without the server learning informa-
tion about the plaintext documents. Often a searchable encryption scheme can
be divided in four algorithms:

– KeyGen(1𝑘 ): takes security parameter 𝑘 and outputs a secret key 𝐾.
– BuildIndex(𝐾, D): takes document set D and secret key 𝐾 and produces an

(inverted) index 𝐼.

– Trapdoor(𝐾, 𝑞): takes query 𝑞 and secret key 𝐾 and outputs a trapdoor 𝑡𝑑𝑞.
– Search(𝐼, td𝑞): takes trapdoor td𝑞 and index 𝐼 and outputs the documents

that match with query 𝑞.

In single-keyword search schemes 𝑞 corresponds to a keyword 𝑤, whereas
in conjunctive keyword search schemes 𝑞 would correspond to a query for doc-
uments containing 𝑑 keywords, i.e., the conjunction of keywords 𝑤1∧ ... ∧𝑤𝑑

Passive query-recovery attack against secure CKWS schemes

7

of keywords 𝑤1, ..., 𝑤𝑑. Then, td𝑞 would correspond to the conjunction of 𝑑
keywords.

3.2 Considered conjunctive keyword search model

We assume a ﬁxed number of keywords (𝑑) that are allowed to be searched for
in a conjunctive keyword search. For instance if 𝑑 = 2, only trapdoors with 2
distinct keywords are allowed. We denote such a ﬁxed-𝑑 scheme as secure 𝑑-
conjunctive keyword search scheme.

For simplicity, we assume a ﬁxed number of 𝑑 distinct keywords, however one
could consider 𝑑 as a maximum number of keywords in the conjunctive search
by reusing the same keyword for non-used keyword entries in the conjunction.
For instance, when 𝑑 = 2, 𝑘𝑤 ∧ 𝑘𝑤 for the same keyword 𝑘𝑤 would be equivalent
to a single-keyword search for 𝑘𝑤.

We consider ckw to be the set of 𝑑 diﬀerent keywords that are used to con-
struct a trapdoor (tdckw). For instance, if we consider a conjunctive keyword
search scheme that allows search for 𝑑 = 3 conjunctive keywords, we would
create a keyword set ckw for every possible combination of 3 keywords, where
ckw1 = {𝑘𝑤1, 𝑘𝑤2, 𝑘𝑤3}. 5

First, in the BuildIndex algorithm, the client encrypts every document in
the document set locally. Then creates an encrypted index of the document set
(locally). Given a trapdoor 𝑡𝑑𝑐𝑘 𝑤 , the server can ﬁnd the documents containing
keywords in 𝑐𝑘𝑤 using such a created index. The encrypted document set and
index are then uploaded by the client to the server.

Although in literature diﬀerent methods for constructing such an index were
proposed, here we do not ﬁx which index is used. We only require the model to
have at least common access pattern leakage, where common refers to the scheme
only leaking the document identiﬁers for the documents containing all keywords
in a conjunctive keyword query. All conjunctive search schemes described in
Section 2 leak at least the common access pattern.

The client can search documents by constructing trapdoors. The client con-
structs a trapdoor by picking 𝑑 keywords she wants to search for. In our model,
she constructs a trapdoor using the function td𝑞 = Trapdoor(𝐾, ckw𝑖 = {𝑘𝑤1, ...,
𝑘𝑤𝑑 }), for the keywords she wants to search for. By sending the trapdoor td𝑞
to the server, the server responds with a set of document identiﬁers 𝑅td𝑞 for
documents that contain all keywords in ckw𝑖.

3.3 Attacker model

Like in [6], we consider two types of passive attackers which both can observe
trapdoors sent by a user and its response including the document identiﬁers. The
ﬁrst type of attacker is an honest-but-curious server. The server is considered
to be an honest entity meaning it follows the protocol. Hence, it always returns
the correct result for each query. However, such curious server tries to learn as
5 Note: 𝑑 = 1 refers to a single-keyword search scheme.

8

M. Dijkslag et al.

much information as possible using the scheme leakage. Secondly, we consider an
eavesdropper that is able to observe pairs of trapdoor and document identiﬁers
from the communication channel between client and server as an attacker.

For both attackers an 𝑜𝑏𝑠𝑒𝑟𝑣𝑎𝑡𝑖𝑜𝑛𝑖 is a tuple (td𝑞, 𝑅td𝑞 ) considering conjunc-
tive keyword queries where trapdoor td corresponds to 𝑑 conjunctive keywords.

3.4 Attacker knowledge

It is assumed the attacker knows the number of keywords 𝑑 that are allowed
to construct trapdoors. Moreover, it can be assumed that an honest-but-curious
attacker knows the byte size of the stored documents and the number of docu-
ments stored (e.g. from the index). However, an eavesdropper does not. In that
case we make use of the proposed formula by [6] that approximates the number
of documents stored on the server (𝑛real) derived from the attacker’s knowledge.
We consider two types of attack setups, i.e. a similar-documents attack setup
where the attacker has access to a set of similar documents (as formalized in [6])
and a known-documents attack setup where the attacker has (partial) knowledge
of the documents stored on the server.

Similar-documents attack. In our similar-documents attack we assume
the attacker has a document set Dsimilar that is 𝜖-similar to the real indexed
document set Dreal. However, we assume 𝜖-similarity (as formalized in [6]) over
the possible keyword conjunctions rather than keywords, where smaller 𝜖 means
more similar. Also, Dsimilar ∩ Dreal = ∅, thus do not have overlapping documents.
Known-documents attack. Like in [10, 3], for our known-documents at-
tack setup we assume that the attacker has a 𝑝-known document set D 𝑝−known,
where 0 < 𝑝 ≤ 1 deﬁnes the known-documents rate. Meaning, the attacker knows
a fraction 𝑝 of the real indexed document set Dreal stored on the server.

It should be noted that a similar-documents attack can be considered more
realistic than a known-documents attack as discussed by Damie et al. [6]. Since
a known-documents attack will most likely only be possible on a data breach,
whereas documents that are only similar to the actual indexed documents maybe
even publicly available. Moreover, the user could remove the leaked documents
that are used in a known-documents attack from the index.

The assumption that the attacker knows (a subset of) the documents stored
on the server is rather strong, but is based on what is done in previous work
[10, 3].

4 CKWS-adapted reﬁned score attack

In this section we describe our conjunctive keyword search (CKWS) adapta-
tion of the reﬁned score attack. Our adaptation builds upon the score attacks
that were introduced by Damie et al. [6]. We have chosen to use their query-
recovery attack against single-keyword search schemes, since it is, to the best
of our knowledge, the most accurate similar-documents attack that has been
described yet. Furthermore, the matching algorithm used in their attack only

Passive query-recovery attack against secure CKWS schemes

9

has a runtime of 20 seconds while considering a vocabulary size of 4000 key-
words. Since the space of possible queries increases combinatorial, we have to
consider many possible keyword conjunctions and thus faster runtimes is desired.
Moreover, their attack can use either known documents or similar documents as
adversary’s knowledge. We describe how one can transform their query-recovery
attack to an attack on conjunctive keyword search schemes, i.e. considering the
(abstract) secure 𝑑-conjunctive keyword search scheme described in Section 3.2,
using similar terminology as in [6].

In addition, the code for the score attacks has been made publicly available
online by Damie et al. This allowed us to verify their results ﬁrst before adapting
it to our conjunctive keyword setting.

4.1 Score attacks

Damie et al. [6] ﬁrst propose the score attack based on the idea of ranking
potential keyword-trapdoor mappings according to a score function. To run the
score attack an attacker calculates the word-word co-occurrence matrix from its
auxiliary document set and constructs a trapdoor-trapdoor co-occurrence matrix
from observed queries and their result sets. Assuming some known queries, the
attacker removes the columns from both matrices that do not occur in their set of
known queries (i.e. word-trapdoor pairs) to obtain so-called sub-matrices. Then
for every (observed) trapdoor, it goes through all possible keywords extracted
from the auxiliary document set and returns the keyword for which their score
function is maximized.

Secondly, their proposed reﬁned score attack builds upon previously described
score attack. Instead of returning a prediction for all trapdoors, they deﬁne a
certainty function for each prediction and only keep the 𝑅𝑒 𝑓 𝑆 𝑝𝑒𝑒𝑑 best predic-
tions according to this certainty function. These predictions are then added to
the set of known queries and the attacker recomputes the co-occurrence sub-
matrices. This procedure is repeated until there are no predictions left to make,
i.e. no unknown queries left.

4.2 Generic extension

In short, our generic extension proposes to replace single keywords with keyword
conjunction sets. The extension consists of ﬁve steps, highlighted by the next
ﬁve subsections to adapt a passive query-recovery attack against single-keyword
search to conjunctive keyword search, i.e. attacks that try to ﬁnd a mapping be-
tween co-occurrences of keywords and trapdoors to recover queries. We describe
our extension in a similar-documents attack setup using Dsimilar, but the same
steps can be taken in a known-documents attack setup using D 𝑝−known as the
attacker’s auxiliary document set.

Extract vocabulary. First, the attacker extracts keywords from the set
of documents Dsimilar to vocabulary Wsimilar. As in query-recovery attacks on
single-keyword search [10, 3, 6], we also assume that the keyword extraction

10

M. Dijkslag et al.

method used by the attacker is the same as the one used by the user when she
created the encrypted index.

Construct set of possible keyword conjunctions. The attacker creates
the set of all possible keyword conjunctions Ksimilar = {ckw𝑖 ∈ P (Wsimilar) (cid:12)
(cid:12)
|ckw𝑖 | = 𝑑}, where 𝑚similar = |Ksimilar| = (cid:0)𝑣similar
(cid:1) and P (𝑋) denotes the power
set of set 𝑋.

𝑑

Compute co-occurrence matrix for keyword conjunctions. From
Dsimilar and derived keyword conjunctions set Ksimilar the attacker creates the
𝑚similar × 𝑚similar matrix 𝐼 𝐷similar. Here 𝐼 𝐷similar [𝑖, 𝑗] = 1 if the 𝑖-th document
in Dsimilar contains the keywords that are in keyword conjunction ckw 𝑗 and
is otherwise 0. Then the attacker computes the ckw-ckw co-occurrence matrix
𝐶ckw = 𝐼 𝐷𝑇

similar · 𝐼 𝐷similar ·

1

𝑛similar . 6

Compute the trapdoor-trapdoor co-occurrence matrix. We deﬁne
Q = {td1, ..., td𝑙 } to be the set of observed queries by the attacker containing
trapdoors that have been queried by the user. These trapdoors were created
by the user from keyword conjunctions in Kreal = {ckw𝑖 ∈ P (Wreal) (cid:12)
|ckw𝑖 | =
(cid:12)
𝑑}. Let 𝑅td = {𝑖𝑑 (𝐷)|(ckw ∈ Kreal) ∧ (td = Trapdoor(𝐾, ckw)) ∧ (𝐷 ∈ Dreal) ∧
∀𝑘 𝑤𝑡 ∈ckw (𝑘𝑤𝑡 ∈ 𝐷)} be the set of document identiﬁers that were observed by
the attacker for trapdoor td. Then we deﬁne the set of document identiﬁers
𝐷𝑜𝑐𝑢𝑚𝑒𝑛𝑡𝐼 𝐷𝑠 = Ðtd∈Q 𝑅td of size 𝑠, where 𝑠 ≤ 𝑛real. Similar to the construction
of the matrix 𝐼 𝐷similar, we construct 𝑠 × 𝑙 trapdoor-document matrix 𝐼 𝐷real,
where 𝐼 𝐷real [𝑖, 𝑗] = 1 if 𝑖-th document identiﬁer occurs in 𝑅td 𝑗 (and 𝑡𝑑 𝑗 refers
to 𝑗-th trapdoor from Q). Otherwise, 𝐼 𝐷real [𝑖, 𝑗] = 0. Then trapdoor-trapdoor
co-occurrence matrix 𝐶td = 𝐼 𝐷𝑇

real · 𝐼 𝐷real ·

1
𝑛real .

Apply attack. The last step is to apply a passive query-recovery attack

using the set of keyword conjunctions and the co-occurrence matrices.

4.3 Transform key steps of reﬁned score attack

As in [10, 3, 6], our attack also requires the attacker to have knowledge of a set
of known queries. However, our set of known queries is slightly diﬀerent because
of the keyword conjunctions. In a similar-documents attack setup our set of
known queries 𝐾𝑛𝑜𝑤𝑛𝑄 = {(ckw𝑖, tdknown)|(ckw𝑖 ∈ Ksimilar ∩ Kreal) ∧ (tdknown ∈
Q) ∧ (tdknown = Trapdoor(𝐾, ckw𝑖)}. For our known-documents attack setup,
𝐾𝑛𝑜𝑤𝑛𝑄 is similarly deﬁned by replacing Ksimilar with Kknown.

We recall key steps in the score attack w.r.t. the projection of the keyword-
keyword co-occurrence and trapdoor-trapdoor co-occurrence matrix to sub-matrices
using the set of known queries. These steps are important because they are dif-
ferent for our CKWS-adapted reﬁned score attack. In short, the projection is
done by only keeping the columns of known queries in 𝐶ckw and 𝐶td.

Our goal is to generate sub-matrices 𝐶 𝑠

td from 𝐶ckw and 𝐶td re-
spectively. We describe the projection step for 𝐶ckw using Ksimilar, but the same
holds for Kknown. Recall that Ksimilar = {ckw1, ..., ckw𝑚similar }.

ckw and 𝐶 𝑠

6 𝐴𝑇 denotes the transpose of matrix A.

Passive query-recovery attack against secure CKWS schemes

11

We deﬁne 𝑝𝑜𝑠(ckw), which returns the position of ckw ∈ K𝑠𝑖𝑚𝑖𝑙𝑎𝑟 . That is,
𝑝𝑜𝑠(ckw𝑖) = 𝑖. Similarly, 𝑝𝑜𝑠(𝑡𝑑) returns the position of td in Q = {td1, ..., td𝑙 }.
Let 𝐶ckw = (cid:0). . . , ®𝑐𝑖, . . .(cid:1) 𝑖 ∈ [𝑚similar ] be the 𝑚similar × 𝑚similar co-occurrence ma-
trix, where the column vector ®𝑐𝑖 denotes its 𝑖-th column. Then the 𝑚similar × 𝑘
ckw = (cid:0). . . , ®𝑐 𝑝𝑜𝑠 (ckw 𝑗 ) , . . .(cid:1) (ckw 𝑗 ,td 𝑗 ) ∈𝐾 𝑛𝑜𝑤 𝑛𝑄, where ®𝑐 𝑝𝑜𝑠 (ckw 𝑗 ) is the
sub-matrix 𝐶 𝑠
𝑝𝑜𝑠(ckw 𝑗 )-th column vector of 𝐶ckw.

Let 𝐶td = (cid:0). . . , ®𝑢𝑖, . . .(cid:1) 𝑖 ∈ [𝑙] be the 𝑙×𝑙 trapdoor-trapdoor co-occurrence matrix,
where the column vector ®𝑢𝑖 denotes its 𝑖-th column. Then 𝑙 × 𝑘 sub-matrix 𝐶 𝑠
td
td = (cid:0). . . , ®𝑢 𝑝𝑜𝑠 (td 𝑗 ) , . . .(cid:1) (ckw 𝑗 ,td 𝑗 ) ∈𝐾 𝑛𝑜𝑤 𝑛𝑄, where
can be constructed as follows: 𝐶 𝑠
𝑢 𝑝𝑜𝑠 (td 𝑗 ) is the 𝑝𝑜𝑠(td 𝑗 )-th column vector of 𝐶td.

Superscript 𝑠 emphasizes that 𝐶 𝑠

respectively. Also, we denote 𝐶 𝑠
conjunction set ckw𝑖 and 𝐶 𝑠
where |𝐶 𝑠

ckw [ckw𝑖]| = |𝐶 𝑠

td [td 𝑗 ]| = 𝑘.

ckw and 𝐶 𝑠

td are sub-matrices of 𝐶ckw and 𝐶td
ckw [ckw𝑖] to be the 𝑖-th row vector for keyword
td [td 𝑗 ] to be the 𝑗-th row vector for trapdoor td 𝑗 ,

Additionally, we revise the scoring algorithm for which the score is higher if a
trapdoor corresponds to a certain keyword conjunction, i.e. the distance between
two vectors 𝐶 𝑠
ckw [ckw𝑖] is small. Using keyword conjunctions the
score function is deﬁned as: 𝑆𝑐𝑜𝑟𝑒(td 𝑗 , ckw𝑖) = −𝑙𝑛(||𝐶 𝑠
td [td 𝑗 ]||), for
all ckw𝑖 ∈ Ksimilar (or Kknown) and all td 𝑗 ∈ Q, where 𝑙𝑛(·) is the natural log and
|| · || is a vector-norm (e.g. L2 norm).

td [td 𝑗 ] and 𝐶 𝑠

ckw [ckw𝑖] − 𝐶 𝑠

4.4 Revised algorithm

𝑘 𝑤 for 𝐶 𝑠

We substitute 𝐶 𝑠
ckw in [6] to transform the reﬁned score attack to the
CKWS-adapted reﬁned score attack. Algorithm 1 contains its pseudocode, where
a step is highlighted blue if it is diﬀerent from the reﬁned score attack proposed
by Damie et al. [6]. Note that this algorithm is described using Ksimilar, but also
works for Kknown as input.

One iteration of the algorithm can be deﬁned by the three key phases. First re-
move known queries from the observed queries set Q. Secondly, ﬁnd the best scor-
ing keyword conjunction candidate for each unknown query and compute the cer-
tainty of this candidate. Using keyword conjunctions the certainty of a keyword
conjunction candidate ckw𝑖 for trapdoor td is deﬁned by: 𝐶𝑒𝑟𝑡𝑎𝑖𝑛𝑡𝑦(td, ckw𝑖) =
𝑆𝑐𝑜𝑟𝑒(td, ckw𝑖) − max 𝑗≠𝑖 𝑆𝑐𝑜𝑟𝑒(td, ckw 𝑗 )

Using this deﬁnition the certainty of a correct match of keyword conjunction
with a trapdoor is higher when the score of the match is much higher than all
other possible candidate scores.

The algorithm deﬁnes a notion of reﬁnement speed (𝑅𝑒 𝑓 𝑆 𝑝𝑒𝑒𝑑) which deﬁnes
the number of most certain predictions that will be added each iteration of the
algorithm to the set of known queries. Which describes the third and last key step
of an iteration, i.e. adding the most certain predictions to the known queries and
recompute sub-matrices 𝐶 𝑠
td. Thereafter, either start a new iteration
or stop the algorithm if the number of unknown queries is less than 𝑅𝑒 𝑓 𝑆 𝑝𝑒𝑒𝑑.

ckw and 𝐶 𝑠

12

M. Dijkslag et al.

Algorithm 1: CKWS-adapted reﬁned score attack.

Input: Ksimilar, 𝐶𝑠
Result: List of keyword conjunctions as predictions for trapdoors with

td, 𝐾𝑛𝑜𝑤𝑛𝑄, 𝑅𝑒 𝑓 𝑆 𝑝𝑒𝑒𝑑

ckw, Q, 𝐶𝑠

certainty
𝑓 𝑖𝑛𝑎𝑙 𝑝𝑟𝑒𝑑 ← [];
𝑢𝑛𝑘𝑛𝑜𝑤𝑛𝑄 ← Q;
while 𝑢𝑛𝑘𝑛𝑜𝑤𝑛𝑄 ≠ ∅ do

// Set remaining unknown queries.
𝑢𝑛𝑘𝑛𝑜𝑤𝑛𝑄 ← {𝑡𝑑 : (𝑡𝑑 ∈ Q) ∧ (šckw ∈ Ksimilar : (𝑡𝑑, ckw) ∈ 𝐾𝑛𝑜𝑤𝑛𝑄)};
𝑡𝑒𝑚 𝑝 𝑝𝑟𝑒𝑑 ← [];

// Propose a prediction for each unknown query.
forall td ∈ 𝑢𝑛𝑘𝑛𝑜𝑤𝑛𝑄 do

𝑐𝑎𝑛𝑑 ← [];
forall ckw ∈ Ksimilar do

𝑠 ← −𝑙𝑛(||𝐶𝑠
Append {“kw”: ckw, “score”: 𝑠 } to 𝑐𝑎𝑛𝑑;

ckw [ckw] − 𝐶𝑠

td [td]||);

end
Sort 𝑐𝑎𝑛𝑑 in descending order according to the score;
𝑐𝑒𝑟𝑡𝑎𝑖𝑛𝑡𝑦 ← 𝑠𝑐𝑜𝑟𝑒(𝑐𝑎𝑛𝑑 [0]) − 𝑠𝑐𝑜𝑟𝑒(𝑐𝑎𝑛𝑑 [1]);
Append (td, 𝑐𝑎𝑛𝑑 [0], 𝑐𝑒𝑟𝑡𝑎𝑖𝑛𝑡𝑦) to 𝑡𝑒𝑚 𝑝 𝑝𝑟𝑒𝑑;

end

// Stop refining or keep refining.
if |𝑢𝑛𝑘𝑛𝑜𝑤𝑛𝑄| < 𝑅𝑒 𝑓 𝑆 𝑝𝑒𝑒𝑑 then

𝑓 𝑖𝑛𝑎𝑙 𝑝𝑟𝑒𝑑 ← 𝐾𝑛𝑜𝑤𝑛𝑄 ∪ 𝑡𝑒𝑚 𝑝 𝑝𝑟𝑒𝑑;
𝑢𝑛𝑘𝑛𝑜𝑤𝑛𝑄 ← ∅;

else

Add 𝑅𝑒 𝑓 𝑆 𝑝𝑒𝑒𝑑 most certain predictions 𝑡𝑒𝑚 𝑝 𝑝𝑟𝑒𝑑 to 𝐾𝑛𝑜𝑤𝑛𝑄;
Add the columns corresponding to the new known queries to 𝐶𝑠
𝐶𝑠
td

ckw and

end

end
return 𝑓 𝑖𝑛𝑎𝑙 𝑝𝑟𝑒𝑑

4.5 Complexity

As in [6], a higher reﬁnement speed will result in a faster runtime, but less accu-
rate predictions. However, due to our use of keyword conjunctions the number
of candidates for a trapdoor increases for larger 𝑑. Therefore, the runtime of the
CKWS-adapted reﬁned score attack grows combinatorial. The time complexity
of the attack is given by O ( 𝑓 (𝑣) +𝑔(𝑣)), where 𝑓 (𝑣) =
𝑑!( 𝑣−𝑑)! · (𝑑 −1) corresponds
to the time complexity of the generic extension, where we assume multiplying
two vectors takes constant time. Further, 𝑔(𝑣) =
𝑑!(𝑣−𝑑)! · 𝑘 is
the time complexity of the attack. For both 𝑓 and 𝑔, input 𝑣 is either 𝑣similar or
𝑣known depending on the attack setup.

𝑅𝑒 𝑓 𝑆 𝑝𝑒𝑒𝑑 · |Q| ·

| Q |

𝑣!

𝑣!

Besides the increase in runtime, having 𝑑 > 1 also the space complexity of
the algorithm increases faster relative to the vocabulary size. Since co-occurrence

Passive query-recovery attack against secure CKWS schemes

13

matrix 𝐶ckw in the similar-documents attack setup is 𝑚similar × 𝑚similar, in terms
𝑣similar!
𝑑!( 𝑣similar−𝑑)! thus increasing faster with larger
of vocabulary size is
𝑣similar.

𝑣similar!
𝑑!(𝑣similar−𝑑)! ×

This increase in time and space complexity led us to ﬁrst further optimize the
revised algorithm for our implementations. Moreover, we use a GPU to decrease
runtimes through computing expensive matrix operations on it.

5 Experiments

5.1 Setup

Documents. As described previously, in our experiments we simulate our attack
using the publicly available Enron email document set introduced by Klimt &
Yang [12]. We chose this document set since this one is also used in most attack
papers requiring a set of documents. Similarly, we constructed the same corpus
of emails from the folder 𝑠𝑒𝑛𝑡 𝑚𝑎𝑖𝑙 which results in a set of 30109 documents.
Keyword extraction. We extract keywords from solely the contents of the
emails in the dataset, i.e. we do not consider email addresses or email subjects to
be part of the document set. For keyword extraction we use the Porter Stemmer
algorithm [20] to obtain stemmed words, moreover we remove stop words in the
English language like ’the’ or ’a’. Using this method results in a total of 62976
unique keywords in our entire considered document set.

Number of keywords in conjunction. Throughout our experiments we
ﬁx 𝑑, i.e. the number of keywords allowed in one conjunction, to either 1, 2 or
3. This means that no mixture of number of keywords is allowed in search. For
instance, when the 𝑑 = 3 only queries with 3 distinct keywords are allowed, i.e.
queries that contain either 1 or 2 keywords are not allowed.

Testing environment. We implemented the attack on an Ubuntu 20.04
server with Intel Xeon 20-core processor (64 bits, 2.2 GHz), 512 GB of memory,
and NVIDIA Tesla P100 GPU (16GB). We used Python 3.7 and the Tensorﬂow
library [1] to accelerate matrix operations on a GPU.7

Limitations. Running experiments with larger vocabulary sizes requires a
lot of memory, since a vocabulary size of 150 and 𝑑 = 2 means a document-
keyword-conjunction matrix size of 18065 × 11175 (already 1.5 GiB) and a max-
imum co-occurrence matrix size of 11175 × 11175 (0.9 GiB) which both have to
ﬁt in the memory of the GPU for fast calculations. Therefore, having similar
vocabulary sizes as used in the score attack is unrealistic in our generic exten-
sion strategy setting without having suﬃcient resources. However, we propose
an extrapolation strategy to have approximate results for larger vocabularies.

5.2 Results

In our experiments where similar-documents are used as the attacker’s knowl-
edge, we use the same ratio in similar (40%) and real (60%) documents as in

7 Our code is available at https://github.com/marcowindt/passive-ckws-attack

14

M. Dijkslag et al.

[6]. Similar to [10, 3, 6], we deﬁne the accuracy to be the number of correct pre-
dictions divided by the number of unknown queries excluding the initial known
queries, i.e. the 𝑎𝑐𝑐𝑢𝑟𝑎𝑐𝑦 = |𝐶𝑜𝑟𝑟 𝑒𝑐𝑡 𝑃𝑟 𝑒𝑑𝑖𝑐𝑡𝑖𝑜𝑛𝑠 (𝑢𝑛𝑘𝑛𝑜𝑤 𝑛𝑄) |

| Q |− |𝐾 𝑛𝑜𝑤 𝑛𝑄 |
If not speciﬁed otherwise, each accuracy result corresponds to the average
accuracy over 50 experiments. Also, the vocabulary used in experiments is always
created from the most frequently occurring keywords in the document set. From
this vocabulary the keyword conjunctions set is generated. In each experiment
it is assumed the attacker has observed 15% of queries that can be performed
by the user, i.e. |Q| = 0.15 · 𝑚real, where queries are sampled u.a.r. from Kreal to
construct trapdoors.

.

y
c
a
r
u
c
c
A

1.0

0.8

0.6

0.4

0.2

0.0

50

|KnownQ| = 15
|KnownQ| = 30
|KnownQ| = 60

100

200
Vocabulary size (vsimilar = vreal)

150

0.45

0.40

0.35

0.30

0.25

0.20

0.15

0.10

0.05

0.00

y
c
n
e
u
q
e
r
F

0

500

250

d = 1
d = 2
d = 3

3500

4000

1000

1500

2000
3000
Keyword conjunction rank

2500

for

using

Score

attack

Fig. 1.
similar-
documents
vocabulary
sizes and initially known queries with
𝑑 = 2, |Dreal| = 18𝐾, |Dsimilar| = 12𝐾,
|Q| = 0.15 · 𝑚real.

varying

Fig. 2. Frequency of keyword conjunctions
ordered from most frequent to least fre-
quent occurring keyword conjunction in
Dsimilar.

Result extrapolation. Figure 1 shows the accuracy of the score attack from
[6] where the attacker has access to similar-documents for varying vocabulary
size and 𝑑 = 2. We show these results to highlight that we can extrapolate
the accuracy of the attack in a similar-documents setting closely, where the
extrapolation is depicted by the dashed line and measured results are the solid
line. We obtain this extrapolation by ﬁrst transforming the accuracies using the
logit8 function. Using this transformation, we obtain a space in which we seem
to have a linear relationship such that logit(𝑎𝑐𝑐) = 𝑏 · 𝑣similar + 𝑎. We then
perform a linear regression to obtain these coeﬃcients using our experimental
results. Lastly, we use the inverse logit function to transform it back to the
original scale. We make use of this extrapolation where running experiments
becomes infeasible (i.e. experiments with 𝑑 = 2 and 𝑣real > 500) to extrapolate
the accuracy for larger vocabulary sizes.

In our linear regressions, we do not provide the coeﬃcient of determination
𝑅2 and the 𝑝-value since they are based on the assumption that results are inde-
pendent which is not true in our experiments as they all use the same document

8 logit(𝑥) = log( 𝑥

1−𝑥 )

Passive query-recovery attack against secure CKWS schemes

15

set. Hence, these values should not be used to evaluate the quality of the model
even if they are high (e.g. 𝑅2 ≈ 0.95 in Figure 1) but the linear regression is still
valid. Although there may exist more precise extrapolation techniques, our in-
tention is to have a simple yet realistic approximation of the accuracy for larger
vocabularies for the sake of our discussion.

Frequency of keyword conjunctions. Figure 2 shows the frequency of a
keyword conjunction occurring in Dsimilar for 𝑑 ∈ {1, 2, 3}, where keyword con-
junction rank is lowest for the most frequent keyword conjunction. We observe
the behavior of using keyword conjunctions instead of a single-keyword, i.e. the
frequency of the most frequent keyword conjunction becomes smaller with higher
𝑑 and the frequency of the least frequent keyword conjunction reaches almost
zero. This is to be expected, since the larger vocabulary size the higher the prob-
ability that certain keywords from a keyword conjunction do not appear in any
document together, i.e. considering the vocabulary is generated with the most
frequent keywords ﬁrst. Note however, that the frequency for rank between 200
and 3600 part is higher for 𝑑 = 2 relative to 𝑑 = 1, which is due to the fact that
obtaining 4000 keyword conjunctions requires a smaller vocabulary size of 90 for
𝑑 = 2, and it is still the case that the most frequent keywords occur together.
Nevertheless, the same does not hold for 𝑑 = 3 relative to 𝑑 = 2, where we actu-
ally observe a decrease in keyword conjunction frequency. Here it already is the
case that the most frequent keywords used to create a keyword conjunction of 3
keywords do not have to necessarily occur together in a document.

y
c
a
r
u
c
c
A

1.0
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0.0

0

|KnownQ| = 5
|KnownQ| = 10
|KnownQ| = 15
|KnownQ| = 30
|KnownQ| = 60

100

200

300
Vocabulary size (vsimilar = vreal)

400

500

1.0
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0.0

y
c
a
r
u
c
c
A

5

600

vknown = vreal = 130

10

15
Known queries (|KnownQ|)

30

60

Fig. 3. Accuracy plot of
the CKWS-
adapted reﬁned score attack with 𝑑 = 2
extrapolated and varying vocabulary size.
With |Dreal| = 18𝐾,
|Dsimilar| = 12𝐾,
|Q| = 0.15 · 𝑚real.

Fig. 4. Accuracy plot of
the CKWS-
adapted reﬁned score attack with 𝑑 = 2
and varying number of known queries.
With |D𝑟 𝑒𝑎𝑙 | = 18𝐾,
|D𝑠𝑖𝑚𝑖𝑙𝑎𝑟 | = 12𝐾,
|Q| = 0.15 · 𝑚𝑟 𝑒𝑎𝑙.

CKWS-adapted reﬁned score attack using similar-documents. Fig-
ure 3 shows the accuracy of the CKWS-adapted reﬁned score attack using
similar-documents with 𝑑 = 2 and varying vocabulary size. Also, the plot shows
an extrapolation of the accuracies for vocabulary sizes larger than 130 (and
smaller than 50). From the extrapolation of the accuracies for varying vocab-
ulary sizes we clearly see a rapid decrease in accuracy with larger vocabulary

16

M. Dijkslag et al.

sizes. We conclude that, when we consider the results with 30 known queries we
can still reach a reasonable recovery rate above 50% for vocabulary size 300 to
400 keywords. However, the results are far from the single-keyword search set up
presented in [6] achieving up to 85% recovery rate for vocabulary size of 1000.
In [6], they discussed how the ’quality’ of a known query inﬂuences the accu-
racy. A known query is more qualitative if the underlying keyword occurs more
frequently. We remind that in the CKWS-adapted setting, it is a way to reduce
the number of known queries needed. A lower rank of a keyword conjunction in
Figure 2 the query for the keyword-conjunction is considered more qualitative.
Figure 4 shows the accuracy of the CKWS-adapted reﬁned score attack using
similar-documents with 𝑑 = 2 and varying number of known queries. The plot
shows that the standard deviation of the accuracy, assuming 5 or 10 known
queries, is relatively high compared to the standard deviation for 15, 30, or 60
known queries. For 5 known queries the standard deviation is 0.15, which is at
least 3 times higher than the standard deviation for 15 known queries (≈ 0.05).
The accuracy increases and standard deviation decreases with a higher number
of known queries, since it becomes more likely to pick more qualitative queries
(u.a.r.). This also explains why we observe this noisy behavior of the accuracy
in the plot.

y
c
a
r
u
c
c
A

1.0
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0.0

0.0

0.1

|KnownQ| = 5
|KnownQ| = 10

0.2

0.3

0.6
0.4
Percentage known-data (p)

0.5

0.7

0.8

y
c
a
r
u
c
c
A

1.0
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0.0

|KnownQ| = 5
|KnownQ| = 10

250
500
Vocabulary size (vknown = vreal)

Fig. 5. Accuracy of the CKWS-adapted
reﬁned score attack using known-data for
varying known-data rates 𝑝 with 𝑑 = 2 and
𝑣 𝑘𝑛𝑜𝑤 𝑛 = 𝑣𝑟 𝑒𝑎𝑙 = 130.

Fig. 6. Accuracy of the extended reﬁned
score known-documents attack with 𝑑 = 2
and 𝑝 = 0.7, i.e. 𝑛known = 𝑝 · 𝑛real.

CKWS-adapted reﬁned score attack using 𝑝-known-documents. Since

we have shown in Section 5.2 that the CKWS-adapted reﬁned score attack
does provide limited scaling with having 𝑑 > 1, we explore how well the at-
tack performs assuming known-documents as the attacker’s knowledge. Figure 5
shows the accuracy of the attack using known-documents with varying known-
documents rates of 0.05 ≤ 𝑝 ≤ 0.8 and steps of 0.05. We observe that with the ini-
tial |𝐾𝑛𝑜𝑤𝑛𝑄| = 10 setting the attack achieves higher accuracies faster for lower
known-documents rates compared to an attack setting having |𝐾𝑛𝑜𝑤𝑛𝑄| = 5
initially. Also, with known-documents rates 𝑝 ≥ 0.7 the accuracy of the attack
becomes constant and reaches near 100% accuracy for both 5 and 10 known

Passive query-recovery attack against secure CKWS schemes

17

queries. However, we do note that having a vocabulary size of 𝑣real = 130 is a
rather limited setting. In the next section we explore the attack using known-
documents with larger vocabularies.

CKWS-adapted reﬁned score attack using 0.7-known-documents. In
the previous result with varying known-documents rates we observed that the
accuracy of the attack using known-documents reaches near 100% for known-
documents rate 𝑝 = 0.7 for both 5 and 10 known queries. Here we explore the
accuracy of the attack by ﬁxing the known-documents rate to 𝑝 = 0.7 with vo-
cabulary sizes 250 and 500. Figure 6 shows a bar plot for both these results with
error bar describing the standard deviation of the accuracy over 50 experiments.
We observe that for vocabulary size 250 the diﬀerence with an attack using 5
known queries compared to 10 known queries is small. Also, the standard devi-
ation in both settings is small. However, for the 500 keyword setting we clearly
see a decrease in accuracy using 5 known queries and a large standard deviation.
Whereas for 10 known queries the attack still reaches above 93% accuracy and
standard deviation is small. We do note however that in this case an attacker has
great advantage, since it knows at least 70% of the whole indexed dataset and 10
known queries. In comparison, previous passive query-recovery attacks [3, 10] on
single-keyword search did not exceed 40% accuracy assuming known-documents
rate of 0.8.

90

80

70

60

50

40

30

20

10

0

)
.
n
m

i

(

e
m

i
t
n
u
R

100

200

300
Vocabulary size (vreal = vknown)

400

500

Fig. 7. Runtime of the CKWS-adapted re-
ﬁned score attack using known-documents
w.r.t. to vocabulary size, with 𝑑 = 2 and
𝑝 = 0.7.

Runtime and memory usage. Figure 7 describes the average runtime of
the attack using known-documents over 50 repetitions in function of 𝑣real for 𝑑 =
2. We observe that the runtime is high for considerably small vocabulary sizes,
which is to be expected considering the time complexity described in Section
4.5. We only show the runtime of the attack using known-documents, however,
runtime of the attack using similar-documents is similar. Although our runtime
can further beneﬁt from using multiple GPUs and even our code is written in
such fashion, we found that using two GPUs does not necessarily speed up our
attack due to large overhead.

18

M. Dijkslag et al.

The overall memory usage is dominated by the size of co-occurrence matrices
𝐶ckw and 𝐶td. Therefore, we can deﬁne the main memory usage of the attack by
the size of these two matrices as a function of the vocabulary size and the number
of queries observed. In our experiments we always assume the attacker observes
|Q| = 0.15 · 𝑚real queries. As a result an accurate estimation of the bytes used by
2
one experiment is given by numberOfBytes(𝑣real, 𝑑) = 2 · (0.15 + 0.152) · (cid:0)𝑣real
·
𝑑 (cid:1)
sizeof (ﬂoat), where sizeof (·) returns the number of bytes used by the system to
store a certain data type. Filling in for 𝑣real = 500, 𝑑 = 2 and using 64 bit ﬂoat,
numberOfBytes(500, 2) ≈ 40 GiB, whereas the GPU used in our experiments ﬁts
at most 16 GB, meaning batching intermediate results is already required.

6 Discussion

Runtime. Although requiring large co-occurrence matrices for the extended
reﬁned score attack is cumbersome, if the adversary has suﬃcient memory re-
sources these large matrices will not be her only concern. Her main concern will
be the runtime of the attack because without being able to parallelize our attack
to multiple GPUs our attack is diﬃcult to run for vocabulary sizes > 500 and be-
comes infeasible for vocabulary sizes > 1000, whereas the added time complexity
using our extension strategy is relatively small.

Observed queries. Furthermore, the question arises whether it is realistic
for an attacker to observe 15% of all possible queries. With only single-keyword
search we believe this can be achieved. However, with 𝑑 = 2 the number of key-
word conjunctions to be observed is big, i.e. 0.15 · (cid:0)𝑣real
𝑑 (cid:1). Although a smaller per-
centage could be considered more realistic and would even decrease the runtime
of the attack, larger |Q| is still desired, since it will result in better estimators
for prediction and thus higher accuracies.

Query distribution. In our experiments we only sampled queries using a
uniform distribution. However, it is likely that this is unrealistic for keyword
conjunctions, since certain keywords might be more likely to be used in a query
together whereas other possible conjunctions might not be queried at all. Having
knowledge of whether certain keywords are more likely to be searched for in
conjunction would decrease the complexity of the attack, since one can then
only consider the top most likely keyword conjunctions.

Countermeasure. Previous query-recovery attacks on single-keyword search
also describe a countermeasure against their attack. In our work we focus on
the question if a generic extension is possible. However, because of our generic
extension strategy, countermeasures tested in [6] will be applicable but were
not explored. Also, most introduced countermeasures do not actually leak less
information, they make the leakage unusable by the attack proposed in the cor-
responding work (e.g. adding false positives in the result set).

Generic extension. Although we described an adapted version of the re-
ﬁned score attack by [6] to a conjunctive keyword setting since it is good per-
forming with low runtimes for single-keywords, our generic extension strategy
using keyword conjunction sets is also valid for other attacks ([10, 3, 2]) and even

Passive query-recovery attack against secure CKWS schemes

19

other types of attacks (e.g. attacks using query frequency [14, 16]). However, we
expect similar runtime issues due to the large query space. Blackstone et al. [2]
has a particular algorithm using cross-ﬁltering that could be helpful to be an
attack speciﬁcally against conjunctive keyword search.

7 Conclusion

In this work we presented a generic extension strategy to adapt any passive
query-recovery attack to a conjunctive keyword search setting. We speciﬁcally
explored its applicability using the reﬁned score attack proposed by Damie et
al. [6] to a conjunctive keyword search setting. It is the ﬁrst study of passive
query-recovery attacks in the conjunctive keyword search setting. We showed
that our attack using documents that are similar, but otherwise diﬀerent from
the indexed documents on the server, does only achieve accuracy of 32% as
attack on conjunctive keyword search. However, applying the adapted attack
using known-documents can still perform with a low number of known queries
and vocabulary size of 500 and achieves a recovery rate similar to previous passive
query-recovery attacks [10, 3, 15] against single-keyword search.

Further, we discussed that the time complexity of the adapted attack grows
combinatorial with the number of keywords in the conjunctive search query.
Also, the storage required to perform the attack is dominated by the size of
the co-occurrence matrices computed from the attacker’s knowledge which also
increases combinatorial.

References

1. Abadi, M., Barham, P., Chen, J., Chen, Z., Davis, A., Dean, J., Devin, M., Ghe-
mawat, S., Irving, G., Isard, M., et al.: Tensorﬂow: A system for large-scale machine
learning. In: 12th {USENIX} symposium on operating systems design and imple-
mentation ({OSDI} 16) (2016)

2. Blackstone, L., Kamara, S., Moataz, T.: Revisiting leakage abuse attacks. IACR

Cryptol. ePrint Arch. 2019 (2019)

3. Cash, D., Grubbs, P., Perry, J., Ristenpart, T.: Leakage-abuse attacks against
searchable encryption. In: Proceedings of the 22nd ACM SIGSAC conference on
computer and communications security (2015)

4. Cash, D., Jarecki, S., Jutla, C., Krawczyk, H., Ro¸su, M.C., Steiner, M.: Highly-
scalable searchable symmetric encryption with support for boolean queries. In:
Annual cryptology conference. Springer (2013)

5. Clement, J.: U.s. online search query size in 2020. https://www.statista.com/
(Aug

statistics/269740/number-of-search-terms-in-internet-research-in-the-us/
2020)

6. Damie, M., Hahn, F., Peter, A.: A highly accurate query-recovery attack against
searchable encryption using non-indexed documents. In: 30th USENIX Security
Symposium (USENIX Security 21). USENIX Association (Aug 2021)

7. Fairouz, S.A., Lu, S.F.: Symmetric key encryption with conjunctive ﬁeld free key-
word search scheme. Journal of Advances in Mathematics and Computer Science
(2016)

20

M. Dijkslag et al.

8. Golle, P., Staddon, J., Waters, B.: Secure conjunctive keyword search over en-
crypted data. In: International conference on applied cryptography and network
security. Springer (2004)

9. Hu, C., Song, X., Liu, P., Xin, Y., Xu, Y., Duan, Y., Hao, R.: Forward secure

conjunctive-keyword searchable encryption. IEEE Access 7 (2019)

10. Islam, M.S., Kuzu, M., Kantarcioglu, M.: Access pattern disclosure on searchable
encryption: ramiﬁcation, attack and mitigation. In: Ndss. vol. 20. Citeseer (2012)
11. Jho, N.S., Hong, D.: Symmetric searchable encryption with eﬃcient conjunctive
keyword search. KSII Transactions on Internet & Information Systems 7(5) (2013)

12. Klimt, B., Yang, Y.: Introducing the enron corpus. In: CEAS (2004)
13. Lai, S., Patranabis, S., Sakzad, A., Liu, J.K., Mukhopadhyay, D., Steinfeld, R., Sun,
S.F., Liu, D., Zuo, C.: Result pattern hiding searchable encryption for conjunctive
queries. In: Proceedings of the 2018 ACM SIGSAC Conference on Computer and
Communications Security (2018)

14. Liu, C., Zhu, L., Wang, M., Tan, Y.A.: Search pattern leakage in searchable en-

cryption: Attacks and new construction. Information Sciences 265 (2014)

15. Ning, J., Xu, J., Liang, K., Zhang, F., Chang, E.C.: Passive attacks against search-
able encryption. IEEE Transactions on Information Forensics and Security 14(3)
(2018)

16. Oya, S., Kerschbaum, F.: Hiding the access pattern is not enough: Exploiting search
pattern leakage in searchable encryption. In: 30th {USENIX} Security Symposium
({USENIX} Security 21) (2021)

17. Patranabis, S., Mukhopadhyay, D.: Forward and backward private conjunctive

searchable symmetric encryption. Cryptology ePrint Archive (2020)

18. Poddar, R., Wang, S., Lu, J., Popa, R.A.: Practical volume-based attacks on en-
crypted databases. In: 2020 IEEE European Symposium on Security and Privacy
(EuroS&P). IEEE (2020)

19. Poon, H.T., Miri, A.: An eﬃcient conjunctive keyword and phase search scheme
for encrypted cloud storage systems. In: 2015 IEEE 8th International Conference
on Cloud Computing. IEEE (2015)

20. Porter, M.F.: An algorithm for suﬃx stripping. Program (1980)
21. Pouliot, D., Wright, C.V.: The shadow nemesis: Inference attacks on eﬃciently
deployable, eﬃciently searchable encryption. In: Proceedings of the 2016 ACM
SIGSAC conference on computer and communications security (2016)

22. Song, D.X., Wagner, D., Perrig, A.: Practical techniques for searches on encrypted
data. In: Proceeding 2000 IEEE Symposium on Security and Privacy. S&P 2000.
IEEE (2000)

23. Sun, W., Liu, X., Lou, W., Hou, Y.T., Li, H.: Catch you if you lie to me: Eﬃcient
veriﬁable conjunctive keyword search over large dynamic encrypted cloud data. In:
2015 IEEE Conference on Computer Communications (INFOCOM). IEEE (2015)
24. Wang, S., Poddar, R., Lu, J., Popa, R.A.: Practical volume-based attacks on en-

crypted databases. IACR Cryptol. ePrint Arch. 2019 (2019)

25. Wang, Y., Wang, J., Sun, S., Miao, M., Chen, X.: Toward forward secure sse

supporting conjunctive keyword search. IEEE Access 7 (2019)

26. Wu, Z., Li, K.: Vbtree: forward secure conjunctive queries over encrypted data for

cloud computing. The VLDB Journal 28(1) (2019)

27. Zhang, L., Zhang, Y., Ma, H.: Privacy-preserving and dynamic multi-attribute
conjunctive keyword search over encrypted cloud data. IEEE Access 6 (2018)
28. Zhang, Y., Katz, J., Papamanthou, C.: All your queries are belong to us: The
power of ﬁle-injection attacks on searchable encryption. In: 25th {USENIX} Secu-
rity Symposium ({USENIX} Security 16) (2016)

