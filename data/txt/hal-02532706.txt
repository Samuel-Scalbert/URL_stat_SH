Nested Regular Expressions can be Compiled to Small
Deterministic Nested Word Automata
Iovka Boneva, Joachim Niehren, Momar Sakho

To cite this version:

Iovka Boneva, Joachim Niehren, Momar Sakho. Nested Regular Expressions can be Compiled to Small
Deterministic Nested Word Automata. CSR 2020 - 15th International Computer Science Symposium
in Russia, Jun 2020, Ekaterinburg, Russia. ￿hal-02532706v2￿

HAL Id: hal-02532706

https://inria.hal.science/hal-02532706v2

Submitted on 19 Jul 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Nested Regular Expressions can be Compiled to
Small Deterministic Nested Word Automata

Iovka Boneva1, Joachim Niehren2, and Momar Sakho1,2

1 Universit´e de Lille, 2 Inria Lille, France

Abstract. We study the problem of whether regular expressions for
nested words can be compiled to small deterministic nested word au-
tomata (NWAs). In theory, we obtain a positive answer for small deter-
ministic regular expressions for nested words. In practice of navigational
path queries, nondeterministic NWAs are obtained for which NWA de-
terminization explodes. We show that practical good solutions can be
obtained by using stepwise hedge automata as intermediates.

Keywords: Automata · Regular Expressions · Nested Words · XPath

1

Introduction

Nested words are nested structures omnipresent in computer science. They were
used in particular to represent data trees or Xml documents, or to analyze the
call structure of recursive programs. The idea of nested words is to generalize
words and unranked trees at the same time. Nested words can be obtained by
enriching Dyck words with internal letters, besides opening and closing paren-
theses. Nested words can also be deﬁned recursively as the elements of the least
set that contains internal letters from a given alphabet, triples consisting of an
opening parenthesis, a nested word, and a closing parenthesis, and all sequences
of nested words. Alternatively, nested words can be speciﬁed as ﬁnite sequences
of internal letters, opening parentheses and closing parentheses. Only well-nested
sequences are permitted in which every opening parenthesis is properly closed
and every closing parenthesis is properly opened. Or else, nested words can be
identiﬁed with sequences of unranked trees, which are often called hedges.

From the viewpoint of formal language theory, the natural question is how to
lift and relate the notions of ﬁnite automata and regular expressions for words
and trees to the case of nested words. Automata for nested words (NWAs)
are well studied [1,3,23] and also known as visibly pushdown automata. While
having the same expressiveness as hedge automata [26,10], which generalize tree
automata from ranked to unranked trees, they are often deﬁned as pushdown
automata with visible stacks, meaning that exactly one symbol is pushed when
reading an opening parenthesis, and exactly one symbol is popped when reading
a closing parenthesis, while the stack is not used otherwise. Their main advantage
is a powerful notion of determinism, generalizing both over bottom-up and top-
down determinism of tree automata for ranked trees [1]. In contrast to more
general pushdown automata, NWAs permit determinization, basically since they
are so closely related to tree automata.

2

I. Boneva, J. Niehren and M. Sakho

Regular expressions for nested words were ﬁrst introduced under the name
of regular expression types by Hosoya et al. in the context of the Xml pro-
gramming language XDuce [19]. We will call them nested regular expressions
(NREs) instead. Independently, more complex notions of regular expressions
were proposed [21,25] that can also deal to some extent with generalizations of
nested words, in which dangling opening and closing parentheses are permitted.
It was already claimed in [19], that NREs have the same expressiveness as hedge
automata [26,10], which in turn have the same expressiveness as NWAs [1]. How-
ever, the question under which conditions nested words can be compiled to small
deterministic NWAs has not been studied. Whenever possible, one can decide
language inclusion or equivalence in P. Otherwise, these problems may not be
feasible since EXP-complete for general NWAs or NREs.

Our concrete interest in the universality of deterministic NWAs is moti-
vated by Xml stream processing: we want to compute the certain answers of
a CoreXPath query on an Xml stream [24,15], i.e., those elements that are se-
lected in all possible futures of the stream. Whether an answer is certain is
computationally hard for tiny syntactic fragments of CoreXPath [4,15], but can
be done in polynomial time for queries deﬁned by deterministic NWAs [16].
A natural question is therefore, whether it is possible to compile CoreXPath
queries as in the usual benchmark [14] to deterministic NWAs of reasonable
size. Unfortunately, the existing compilers fail to do so [12], since they are based
on NWA determinization for dealing with disjunction, negation, and recursive
steps. Thereby they produce huge deterministic automata even for very simple
CoreXPath queries from the benchmark, or do not terminate after some hours.
In this paper, we consider NREs for deﬁning queries on nested words, since
there exist compilers that can map the CoreXPath queries from the usual bench-
mark to NREs of reasonable size, under the condition that the path query
contains only forwards steps. We then distinguish a subclass of “deterministic”
NREs that can be complied in polynomial time to deterministic NWAs by gener-
alizing on Glushkov’s construction of deterministic ﬁnite-state automata (Dfas)
from “deterministic” regular expressions [6,7]. However, the NREs obtained by
compilation from CoreXPath queries are rarely deterministic, so neither are the
NWAs obtained from them by direct compilation. Neither can we apply NWA
determinization to them as argued above. We show that deterministic NWAs can
be obtained nevertheless based on stepwise hedge automata (SHAs), that we in-
troduce. SHAs combine stepwise tree automata [8] for unranked trees with ﬁnite
state automata on words (Nfas). They can be determinized in a bottom-up and
left-to-right manner, simply by combining the determinization procedures for
tree automata and for Nfas. Furthermore, we can compile deterministic SHAs
to deterministic NWAs in polynomial time. Conversely, NWAs can be compiled
to SHAs in polynomial time too, but at the cost of introducing nondeterminism.
By composing these compilers and determinization algorithms, NREs can
be compiled to deterministic NWAs in the following two manners. The ﬁrst
method is to compile the NRE to an SHA, from there to an NWA, which is
then determinized. The second way consists of compiling the NRE to an SHA,
determinize it, and convert the result to a deterministic NWA. In an experimen-
tal study, we consider a collection of NREs that we constructed automatically

Small dNWAs for Nested Regular Expressions

3

from CoreXPath queries in the XMark benchmark [14]. It turns out a little sur-
prisingly that both above algorithms yield a satisfactory solution: they produce
small deterministic NWAs for all NREs in our collection. The sizes of the de-
terministic may diﬀer, sometimes in favor of the one or the other algorithm. We
also discuss, why the NWA determinization behaves reasonably for the NWAs
obtained from SHAs, while it behaved so badly for NWAs obtained directly from
NREs. The reason seems to be that the former NWAs in contrast to the latter
have the single entry property, which basically states that the NWA performs
all its work in a bottom-up and left-to-right manner, and none when moving
top-down. This conjecture is supported by practical evidence rather than some
formal statement.
Related Work. CoreXPath [17] is a fragment of nested regular path queries
on data trees, in which recursion is restricted to basic steps up, down, left and
right. Nested regular path queries were introduced in the seventies [13] under
the name of the propositional dynamic logic (PDL). There they were applied to
general labeled graphs, rather than being restricted to data trees.

Since certain query answering for CoreXPath was considered as diﬃcult, the
currently existing approaches to CoreXPath evaluation on Xml streams [12,24]
either approximate certain query answers based on nondeterministic machines
or restrict the queries so that answers certainty can be decided without latency
[22,4]. This also holds for recent streaming algorithms on words without nesting
in the context of complex event processing [18].

2 Nested Words

Nested words are words with parentheses that are well-nested. They can be
identiﬁed with hedges, that is sequences of internal symbols and unranked trees.
Nested words are constructed with an opening and a closing parentheses,
respectively (cid:104) and (cid:105). An unranked alphabet Σ is a possibly inﬁnite set of so
called “internal” symbols, that does not contain the two parentheses. Nested
words over Σ then have the following abstract syntax:

h, h(cid:48) ::= ε

| a |

(cid:104)h(cid:105)

| h · h(cid:48)

where a ∈ Σ

c

(cid:104)(cid:105)

(cid:104)(cid:105)

The empty word is denoted by ε and assumed to satisfy
ε · h = h = h · ε. Nested words can be identiﬁed with hedges,
i.e., words of trees and internal symbols. Seen as a graph,
the inner nodes are labeled by the tree constructor (cid:104)(cid:105) and
the leafs by symbols in Σ or the tree constructor. For in-
stance (cid:104)a · (cid:104)b(cid:105) · ε(cid:105) · c · (cid:104)d · (cid:104)ε(cid:105)(cid:105) corresponds to the hedge on
the right. A nested word of type tree has the form (cid:104)h(cid:105).
Variants. Our notion of nested words accepts only well-nested words without
dangling opening or closing parentheses in contrast to others [1,3]. This will lead
to simpler notion of regular expressions, avoiding the more complex operators
as with visibly rational expressions [5,25]. A less important diﬀerence is that we
do not support labeled parentheses.
Labeled trees. Labeled parentheses can be simulated by using internal letters.
For instance, the labeled tree a(b(), c()) can be represented by the nested word

(cid:104)(cid:105)

(cid:104)(cid:105)

b

d

a

4

I. Boneva, J. Niehren and M. Sakho

of type tree (cid:104)a · (cid:104)b(cid:105) · (cid:104)c(cid:105)(cid:105). In this way, the labeled tree a() is represented by the
nested word (cid:104)a(cid:105) which is of type tree (while the internal letter a alone is not).
Xml documents are particular labeled trees, such as for instance: (cid:104)a name =
“uf f ”(cid:105)(cid:104)b(cid:105)isgaga(cid:104)d/(cid:105)(cid:104)/b(cid:105)(cid:104)c/(cid:105)(cid:104)/a(cid:105). Labeled trees satisfying the Xml data model
can be represented as nested words over a signature that contains the Xml node-
types (elem, attr, text, . . .), the Xml names of the document (a, . . . , d, name),
and the characters of the data values, say UTF8. For the above example, we get
the nested word (cid:104)elem · a · (cid:104)attr · name · u · f · f (cid:105)(cid:104)elem · b · (cid:104)text · i · s · g · a · g ·
a(cid:105)(cid:104)elem · d(cid:105)(cid:105)(cid:104)elem · c(cid:105)(cid:105)

3 Nested Regular Expressions

We present nested regular expressions (NREs), that were introduced under the
name regular expression types in the context of XDuce [19] up to minor details.
A NRE over alphabet Σ has the following abstract syntax:

E, E(cid:48) ::= ε | a | ¬Σ(cid:48) | ∅ | E · E(cid:48) | E + E(cid:48) | E&E(cid:48) | E∗ | (cid:104)E(cid:105) | µa.E

where a ∈ Σ and Σ(cid:48) ⊆ Σ is ﬁnite. We restrict the recursive expressions µa.E
such that all occurrences of a in E are nested below parentheses. The sets of
free and bound symbols fn(E) and bn(E) are deﬁned as usual where µa.E binds
symbol a with scope E and there is no other binder.

There are two diﬀerences with the regular expression types from [19]. First,
our NREs treat labels as internal symbols instead of labels of parentheses. Sec-
ond, they provide recursion through the µ-operator instead of using recursive
equation systems. Even though not needed from the view point of expressive-
ness, we allow conjunctions E&E(cid:48) to simplify the compilation of CoreXPath
expressions with ﬁlters to NREs. NREs having no subexpressions E&E(cid:48) are
called conjunction-free (CF-NREs). Any NRE describes a language of nested
words that is deﬁned by structural induction as follows:

L(a) = {a}

L(ε) = {ε}
L(E · E(cid:48)) = L(E) · L(E(cid:48))
L(E + E(cid:48)) = L(E) ∪ L(E(cid:48))
L((cid:104)E(cid:105)) = {(cid:104)h(cid:105) | h ∈ L(E)}

L(∅) = ∅

L(¬Σ(cid:48)) = Σ \ Σ(cid:48)
L(E∗) = L(E)∗
L(E&E(cid:48)) = L(E) ∩ L(E(cid:48))
L(µa.E) = ∪n≥0L(µna.E)

A negation ¬Σ(cid:48) stands for Σ\Σ(cid:48). This is useful for dealing with inﬁnite alphabets
and with large ﬁnite alphabets. For all expressions E, E1 and E2, the notation
E[E1/E2] stands for the expression E where all the occurrences of E1 have
been replaced by E2. The semantics of a µ-operator is then deﬁned using the
shortcuts µ0a.E = E[a/∅] and µna.E = E[a/µn−1a.E] for all n ≥ 1. Note that
µa. b · a · c + ε would deﬁne the string language {bn · cn | n ≥ 0} which is not
regular. But this expression is ruled out since the µ-bound name a is not nested
below parentheses.

In the context of Xml queries, we can express the child and descendant-or-

self axes of XPath expressions by using the following NREs:

ch(E) =df T · (cid:104)E(cid:105) · T
ch∗(E) =df µx. (E + ch(x))
ch+(E) =df µx. (ch(E) + ch(x))

T =df µx. ((cid:104)x(cid:105) + ¬∅)∗
where x (cid:54)∈ fn(E)

where x (cid:54)∈ fn(E)

Small dNWAs for Nested Regular Expressions

5

Thereby, the XPath expression a[following-sibling::b]/descendant::c can be ex-
pressed as a NRE, in which x ∈ Σ serves as the selection variable, while the
negation ¬{x} expresses nonselection.

(cid:104)elem · a · ¬{x} · ch+((cid:104)elem · c · x · T (cid:105))(cid:105) · T · (cid:104)elem · b · ¬{x} · T (cid:105) · T

Our next objective is to distinguish NREs that can be evaluated deterministi-
cally in polynomial time, for instance by compilation to deterministic NWAs.
For this, we consider the language of NREs nregexp(ch, T ) extended by the
constant T and the unary constructor ch.

Deﬁnition 1. An expression of nregexp(ch, T ) is deterministic if it does not
contain a subexpression of any of the forms: E1 + E2, E∗, T · E, µa.E.

Note in particular that ch(a) is a deterministic expression of nregexp(ch, T ).
In contrast, the semantically equivalent expression T.(cid:104)a(cid:105).T is not deterministic.
Similarly, T is deterministic while the equivalent expression µx.((cid:104)x(cid:105) + ¬∅)∗ is
not. The expression ch∗(E) is not deterministic since its deﬁnition relies on the
µ-operator.

4 Nested Word Automata

Nested word automata (NWAs) are pushdown automata reading nested words,
whose stacks are visible: they push a single stack symbol when reading an open-
ing parenthesis, pop a single stack symbol when reading a closing parenthesis,
and don’t alter or inspect the stack otherwise.

Deﬁnition 2. An NWA is a tuple A = (Qh, Qt, Σ, Γ, ∆, I, F ) consisting of a
possibly inﬁnite set Σ of internal symbols, ﬁnite sets Qh and Qt of states of type
hedge and tree respectively, sets of initial and ﬁnal states I, F ⊆ Qh, a ﬁnite set
Γ of stack symbols, and a ﬁnite set ∆ of transition rules of the forms:

hedge rules
opening rules
hedge ending rules
closing rules

a∆, ∆, ε∆ ⊆ Qh × Qh where a ∈ Σ
(cid:104)∆
where γ ∈ Γ
γ ⊆ Qh × Qh
tree ∆ ⊆ Qh × Qt
(cid:105)∆
γ ⊆ Qt × Qh

Our NWAs are symbolic, in that they come with else rules, i.e elements
of (q, q(cid:48)) ∈ ∆ that we will denote by q −→ q(cid:48), for dealing with large or inﬁnite
alphabets. An example for an NWA is given in a graphical syntax in Fig. 1. Tree
states are drawn in circles that are ﬁlled in light gray q , while hedge states
are in unﬁlled circles q . Initial states are drawn as → q and ﬁnal states as
q . Hedge rules that have the form (q1, q2) ∈ o∆(cid:48)
denoted by q1
of the type of letter o. Opening rules (q1, q2) ∈ (cid:104)∆
and closing rules (q1, q2) ∈ (cid:105)∆

where o ∈ Σ ∪ { , ε, tree} are
o−→ q2. They are either label, else, epsilon, or tree rules depending
(cid:104)↓γ
−−→ q2

γ are represented as q1

(cid:105)↑γ
−−→ q2.

γ as q1

6

I. Boneva, J. Niehren and M. Sakho

Fig. 1: Nested word automaton nwa(ch∗(a + b)).

Our notion of NWAs supports factorization in the spirit of [9]. It is obtained
by distinguishing two types of states q ∈ Qh and p ∈ Qt, and adding explicit
type coercion rules q tree−−→ p. Semantically, both kinds of states could be merged
when replacing type the coercion rules by the epsilon rule q ε−→ p, but at the cost
of introducing additional nondeterminism. This may lead to quadratically larger
deterministic automata, as we will illustrate at the NWA in Fig. 5.

The language of nested words between two states q1, q2 ∈ Qh is deﬁned as

the least language such that:

Lq1,q2 (∆) = {ε | if q1 = q2 or q1
∪ {a | if q1
∪ {(cid:104)h(cid:105) | ∃q(cid:48)

ε−→ q2 wrt.∆} ∪ (cid:83)
a−→ q2 ∈ ∆ or (q1 −→ q2 ∈ ∆(cid:48) and ¬∃q(cid:48)
(cid:104)↓γ
1, q(cid:48)
−−→ q(cid:48)
tree−−→ q3 ∈ ∆ and q3

2 ∈ Qh.∃q3 ∈ Qt.∃γ ∈ Γ. q1

(cid:105)↑γ
−−→ q2 ∈ ∆}.

q3∈Qh

q(cid:48)
2

Lq1,q3(∆) · Lq3,q2(∆)
a−→ q(cid:48)
2 ∈ ∆)}
2. q1
(∆),
1, h ∈ Lq(cid:48)

1,q(cid:48)
2

The language of the NWA then is L(A) = (cid:83)
q1∈I,q2∈F Lq1,q2(∆) . NWAs can be
determinized by adapting the usual determinization procedure for NWAs [12,1]
so that it can account for hedge ending and else rules, as shown in the appendix.
As argued earlier, NREs have the same expressiveness as NWAs and thus
as deterministic NWAs. But in practice, the sizes may blow-up surprisingly
by determinization [12]. We next discuss on a compiler from expression an E of
nregexp(T, ch) to an NWA nwa(E) that preserves determinism. For instance, the
NWA for the expression ch∗(a + b) is shown in Fig. 1. For regular expressions
without nesting, the compiler is based on Glushkov’s construction recursively
on the structure of the expression while eliminating ε-edges on the ﬂy. Such
construction is known to preserve determinism [7]. For deterministic expressions
ch(E), we adapt ideas from [12]. Conjunctions E&E(cid:48) are compiled to products of
automata. Special care has to be given to µa.E expressions in order to preserve
the recognized language and also have the following complexity result:

Theorem 1. For any nested regular expression E we can construct an NWA
A such that L(A) = L(E) while preserving determinism in at most exponential
time. For conjunction-free NREs, the construction is in time O(|E|2).

This quadratic time result generalizes a previous result for the Glushkov
construction [6] from conjunction-free regular expressions to CF-NREs. Since
conjunctions are compiled to products of automata, the NWAs produced may

Small dNWAs for Nested Regular Expressions

7

Fig. 2: Stepwise hedge automaton sha(ch∗(a + b)): the part with the stepwise
tree automaton is on the left and middle, and the Nfa part on the right.

be of exponential size in the worst case. As a consequence of Theorem 1 small
deterministic CF-NREs can be compiled to small deterministic NWAs. This
gives a ﬁrst positive answer to the motivating question of the present paper.

As for nondeterministic expressions, the NWA determinization procedure is
not a solution to the problem at hand, due to huge size increase. For instance,
the deterministic NWA det(nwa(ch∗(a + b))) in Fig. 15 has size 271, which may
seem way too large. Even worse cases can be found in the experimental section.
The problem is not solved by factorization, and actually conﬁrms a size increase
reported earlier for NWAs obtained from XPath by a diﬀerent compiler [12].
So the question is, whether there do not exist better methods to obtain smaller
deterministic NWAs for nested regular expressions.

5 Stepwise Hedge Automata

We propose SHAs as an extension of stepwise tree automata [8] to recognize not
only unranked trees but also hedges. The problematic notion of determinism of
the hedge automata from [20,10,26] is avoided.

Our notion of SHAs will be symbolic in using else rules, and factorized in the
sense of [9]: there are two types of states for hedges and trees and an operator
for explicit type coercion. We also propose a novel treatment of internal letters
inspired by nested word automata, so that SHAs generalize both on stepwise
tree automata and on Nfas.

Deﬁnition 3. A SHA is a tuple S = (Qh, Qt, Σ, ∆, I, F ) such that Qt and Qh
are ﬁnite set of states of two types t for tree and respectively h for hedge, Σ an
alphabet of internal letters (that may be inﬁnite), I, F ⊆ Qh subsets of initial
and ﬁnal states respectively, and ∆ a ﬁnite set of transition rules such that for
all q ∈ Qt and a ∈ Σ:

hedge rules
tree ﬁnal rules
tree initial states (cid:104)(cid:105)∆ ⊆ Qh

q∆, a∆, ∆, ε∆ ⊆ Qh × Qh
tree ∆ ⊆ Qh × Qt

An example for a SHA is given in graphical syntax in Fig. 2. It recognizes
all hedges which are either just a or b or contain some tree node that contains
either just a or b. In the graphical syntax, the states of type tree q ∈ Qt are
drawn in circles ﬁlled in light gray q , while the states of type hedge q(cid:48) ∈ Qh

8

I. Boneva, J. Niehren and M. Sakho

are drawn in unﬁlled circles q(cid:48) . The right part of the graph is an Nfa which
uses tree states as additional edge labels, while the left part is a stepwise tree
automaton, that deﬁnes the tree languages of these tree states.

Let ∆h be the restriction of ∆ to the hedge rules. Then, (Qh, Σ (cid:93)Qt, ∆h, I, F )
is a standard Nfa with ε-rules, which is symbolic [11] in providing else rules for
dealing with large or inﬁnite alphabets in addition. Therefore, we denote the
initial states q ∈ I by → q and the ﬁnal states q ∈ F by q . A rule with an
a−→ q2 wrt ∆ stating that a hedge in
internal letter (q1, q2) ∈ a∆ is denoted by q1
state q1 can be extended by the internal letter a leading to a hedge in state q2.
ε−→ q2, and an else rule
Similarly, an epsilon rule (q1, q2) ∈ ε∆ is denoted by q1
(q1, q2) ∈ ∆ is denoted by q1 −→ q2. In the same spirit, a hedge rule (q1, q2) ∈ q∆
q
is denoted by q1
−→ q2 wrt. ∆, stating that a hedge in state q1 can be extended
by a tree in state q leading to a hedge in state q2.

A tree initial state q ∈ (cid:104)(cid:105)∆ is graphically denoted by

(cid:104)(cid:105)
−→ q and a tree ﬁnal rule
tree−−→ q2. Intuitively, a tree (cid:104)h(cid:105) can be evaluated to state q
(cid:104)(cid:105)
−→ q1 to some state q2
tree−−→ q. More formally, the hedge languages Lq1,q2 (S) between any

(q1, q2) ∈ tree ∆ by q1
if h can be evaluated starting with some tree initial state
such that q2
two hedge states q1, q2 ∈ Qh are deﬁned as follows:
ε−→ q2 wrt. ∆} ∪ (cid:83)
a−→ q2 ∈ ∆ or (q1 −→ q2 ∈ ∆ and ¬∃q(cid:48)

Lq1,q3(S) · Lq3,q2(S)
a−→ q(cid:48)
2. q1

Lq1,q2 (S) = {ε | if q1 = q2 or q1
∪ {a | if q1
∪ (cid:83)

2 ∈ ∆)}

q3∈Qh

Lq(S)

q−→q2∈∆

q1

This deﬁnition is mutually recursive with the deﬁnition of the tree languages
Lq(S) of all tree states q ∈ Qt:

Lq(S) = {(cid:104)h(cid:105) |

(cid:104)(cid:105)
−→ q1, h ∈ Lq1,q2 (S), q2

tree−−→ q}

a−→ p1

(cid:104)(cid:105)
−→ p0

The hedge language L(S) that is recognized by automaton is (cid:83)
q1∈I,q2∈F Lq1,q2 (S).
The rules of standard bottom-up tree automata have the form a(q1, . . . , qn) → q
where a is a symbol of arity n. With SHAs, this rule can be encoded by the
tree−−→ q where the states q1, . . . , qn, q
sequence
are all tree states, and p0, . . . , pn fresh hedge states. Stepwise hedge automata
have a natural notion of determinism, generalizing both on that of stepwise tree
automata and on Nfas, in contrast to the earlier notion of hedge automata in
[10,26], as presented in the appendix. For instance, the SHA in Fig. 3 is obtained
by determinization of the automaton in Fig. 2. It consists of a Dfa on the right
and a deterministic stepwise tree automaton on the left. We show that

qn−→ pn

q1−→ . . .

Proposition 1. Any SHA can be made deterministic in at most exponential
time such that the hedge language is preserved.

Any expression E can be compiled to a SHA sha(E) = (Qh, Qt, Σ, ∆, I, F )
| E(cid:48) = (cid:104)E(cid:48)(cid:48)(cid:105) subexpression of E} and Lt(E(cid:48)) = L(E(cid:48))
such that Qt = {E(cid:48)
for all tree states E(cid:48) ∈ Qt. The SHA sha(E) can be partitioned into disjoint
SHAs sha(E) = Atop ∪ (cid:83)
h , Qt, Σ, ∆top, I, F )
h , Qt, Σ, ∆E(cid:48)
= (QE(cid:48)
and AE(cid:48)
= ∅.

E(cid:48)∈Qt
, ∅, ∅) for all E(cid:48) ∈ Qt and (cid:104)∆top

such that Atop = (Qtop

AE(cid:48)

Small dNWAs for Nested Regular Expressions

9

0 = {1, 3, 5, 6}
1 = {8, 10, 14, 16, 18, 19}
2 = {2, 5, 6}
3 = {4, 5, 6}
4 = {5, 6}
5 = {9, 10, 15, 18, 19}
6 = {9, 10, 17, 18, 19}
7 = {10, 18, 19}
8 = {(cid:104)T (cid:105)}
9 = {(cid:104)T (cid:105), (cid:104)x(cid:105)}
10 = {9, 10, 18, 19, 20}
11 = {5, 6, 12}

Fig. 3: The determinized SHA det(sha(ch∗(a + b))).

Proposition 2. For any CF-NRE E we can construct in time O(|E|2) a SHA
sha(E) such that L(sha(E)) = L(E).

However, the construction does not preserve determinism. For the determin-
istic NRE (cid:104)a1 · (cid:104)a2 · . . . · (cid:104)an(cid:105) . . . (cid:105)(cid:105), one would have an SHA having a tree initial
state for each of the (cid:104)ai . . . (cid:105) subtree, implying nondeterminism. This is in con-
trast to the compiler to NWAs, which can rely on top-down determinism that
is unavailable for SHAs though. Furthermore, as for NWAs, conjunctions may
cause an exponential blow-up of the produced SHA.

6 NWAs versus SHAs

We next show how to compile SHAs to NWAs such that determinism is pre-
served, and back while introducing nondeterminism. Thereby we can obtain
small NWAs for NREs such as E = ch∗(a + b) for which det(nwa(E)) blows up
in size in a surprising manner.
SHAs to NWAs. Any SHA S = (Qh, Qt, Σ, ∆, I, F ) can be compiled to an
NWA nwa(S) = (Qh, Qt, Σ, Γ, ∆(cid:48), I, F ) such that Lq1,q2 (S) = Lq1,q2 (nwa(S)).
We set Γ = Qh, ∆(cid:48)

= a∆ for all a ∈ Σ, ε∆(cid:48)

= ε∆, tree ∆(cid:48)

= ∆, a∆(cid:48)

= tree ∆:

q1

q
−→ q2 ∈ ∆ p ∈ (cid:104)(cid:105)∆

(cid:104)↓q1−−−→ p ∈ ∆(cid:48) and q

(cid:105)↑q1−−−→ q2 ∈ ∆(cid:48)

q1

Clearly, if S is deterministic then so is nwa(S), since p is unique in this case in
particular. One might be tempted to restrict the above construction rule to states
p such that Lq(S[(cid:104)(cid:105)∆/{p}]) (cid:54)= ∅ where the set of tree initial states (cid:104)(cid:105)∆ is replaced
by {p}. However, this would lead to huge blow-up when determinizing these
NWAs, basically since this change spoils the single-entry property discussed in
Deﬁnition 4.

The conversion of sha(ch∗(a + b)) in Fig. 2 yields the NWA in Fig. 4. Note
that the opening rules are deterministic (but not the whole NWA), since for
all tree states q there is at most one hedge state p with (cid:104)(cid:105) → p such that q is
accessible from p. The NWA has size 64, while its determinization has size 159
(see Fig. 17 of the appendix). The size increase raised by determinization is thus
95 = 159 − 64 for this NWA.

10

I. Boneva, J. Niehren and M. Sakho

Fig. 4: The NWA from the SHA nwa(sha(ch∗(a + b))).

4

a

b

20

8

-

<↓1

-

-

<↓8
<↓6

-

2

<↓5

14

-

16

>↑5
>↑1
>↑8
>↑6
>↑10

<↓10

tree

-

6

tree

-

22

tree
>↑4

>↑7
>↑9

>↑2
>↑3

>↑10

<↓4

a

b
<↓3

tree

<↓2

12

24

<↓7

-

10

<↓9

18

>↑6
>↑5
>↑1
>↑8

-

>↑2

-

>↑3

>↑7

>↑9
>↑4

tree

Fig. 5: Deterministic NWA: nwa(det(sha(ch∗(a + b)))).

The size increase for determinization is considerably smaller for the NWA
obtained from the regular expressions by indirection via a stepwise hedge au-
tomaton, than for NWAs obtained by direct compilation. Indeed, the deter-
minization of nwa(ch∗(a + b)) blows the size from 39 to 271. The size increase
for the determinization of nwa(ch∗(a + b)) is thus 242 = 271 − 39 and while for
nwa(sha(ch∗(a + b))) is is only 95 = 159 − 64.

The experiments will show that this is not an exception but the general rule.
Intuitively, the reason is that NWAs obtained from stepwise hedge automata do
all work bottom-up, where NWAs obtained directly from the regular expression
do a considerable amount of work top-down. In terms of [2] this restriction can
be characterized syntactically by the single-entry property:

Deﬁnition 4. An NWA A has the single-entry property, if there exists a single
state qentry ∈ Qh such that all opening rules of A have the form q

(cid:104)↓q
−−→ qentry.

It can be shown that nwa(S) has the single-entry property for all SHAs S for
which the p’s are unique in the above construction rule, i.e. such that (cid:104)(cid:105) −→ p.
Note that this wasn’t the case for sha(ch∗(a + b)) in Fig. 2 but could have been
imposed wlog leading to a slightly diﬀerent NWA than in Fig. 4.

Small dNWAs for Nested Regular Expressions

11

o ∈ Σ ∪ {tree, , ε} q1

o−→ q2 ∈ ∆ q ∈ Qh

q1

(q, q1) o−→ (q, q2) ∈ ∆s
(cid:104)↓γ
−−→ q2 ∈ ∆ q3 ∈ Qt
(q2,q3)
−−−−→ (q, q4) ∈ ∆s

(q, q1)

q3

(cid:105)↑γ
−−→ q4 ∈ ∆ q ∈ Qh

(cid:104)↓γ
−−→ q2 ∈ ∆

q1
(cid:104)(cid:105)
−→ (q2, q2) ∈ ∆s

Fig. 6: NWA to stepwise conversion.

The conversion of the determinization det(sha(ch∗(a+b))) in Fig. 3 yields the
deterministic NWA in Fig. 5. The size goes up slightly from 53 to 73. It should
be noticed, that factorization avoids a quadratic blow up in this case. This
can be observed at state 14, which has 3 incoming tree-edges and 10 outgoing
closing edges. Without factorization, the 3 tree edges could be replaced by 3
ε-edges whose elimination would produce 30 closing edges. This would increase
the number 3 + 10 edges to 3 ∗ 10 edges.
NWAs to SHAs. Conversely, NWAs can be compiled to stepwise hedge au-
tomata, but at the cost of introducing nondeterminism, since an NWA may
traverse the branches of a tree top-down, while a stepwise must traverse them
bottom-up. For this, the stepwise guesses the state in which the NWA will arrive
from above and then evaluates the subtree starting with this state, while veri-
fying the correctness of the guess later on. Let A = (Qh, Qt, Σ, ∆(cid:48), I, F ) be an
NWA. We build a SHA sha(A) = (Qs
h, Qs
h = Qh × Qh,
t = Qh × Qt, I s = {(q, q) | q ∈ I}, F s = I × F and ∆s is the smallest satisfying
Qs
the rule schemas in Fig. 6. The construction is such that L(A) = L(sha(A)).

t , Σ, ∆s, I s, F s) where Qs

For the NWA nwa(ch∗(a + b)) in Fig. 1 we obtain the stepwise in Fig. 16 up-
to removing useless states and separating the top-level. Determinization yields
det(sha(nwa(ch∗(a + b)) = det(sha(ch∗(a + b))) in Fig. 3.

7 Experimental Results and Discussion
We now compare the sizes of deterministic NWAs that we can obtain by com-
posing the various compilers in diﬀerent orders.

We test the A1, . . . , A8 XPath queries in the usual XPath benchmark [14],
which contain not only forward child, descendant and following-sibling axes, but
also ﬁlters and path compositions. Note that the queries A4 until A8 contain
ﬁlters, which are mapped to NREs with conjunctions. We compiled these queries
automatically to nested regular expressions, then compiled these expressions to
deterministic NWAs, by composing the various compilers presented earlier in all
reasonable manners. A1 is the only query for which we obtain a deterministic
regular expression. But since we replaced ch(E) systematically by T · (cid:104)E(cid:105) · T in
our experiments, all nested regular expression become nondeterministic.

The overall size of the resulting automata and the number of their rules
are given in Fig. 7. We can see that determinization applied to the NWAs for
these expressions fails. Only 2 out of 8 automata have a size less than 400000,
and for the others, the determinization run out of time. In contrast, 3 of the
4 other methods – that use stepwise hedge automaton intermediately – pro-
duce reasonable small deterministic NWAs. For the fourth method in the last

12

I. Boneva, J. Niehren and M. Sakho

det(nwa(.))

nwa(det(

det(nwa(

sha(.)))

sha(.)))

A1
A2 362600 (6782)
A3 318704 (8216)
A4
A5
A6
A7
A8

398 (37)
668 (57)
469 (44)
487 (42)
676 (55)
548 (45)
468 (41)
2520 (124)

302 (62)
4889 (221)
542 (66)
335 (67)
1054 (110)
332 (62)
285 (54)
1236 (137)

nwa(det(
sha(nwa(.))))
398 (37)
1648 (127)
625 (56)
487 (42)
856 (67)
548 (45)
468 (41)
1804 (118)

det(nwa(
sha(nwa(.))))
398 (37)
4105 (148)
907 (62)
487 (42)
1192 (73)
548 (45)
468 (41)

Fig. 7: Deterministic NWAs for XPath benchmark: size (#states).

det(nwa(.))

nwa(det(

det(nwa(

sha(.)))

sha(.)))

nwa(det(
sha(nwa(.)))

det(nwa(

sha(nwa(.))))

ch3[a] 19828 (1281)
ch4[a]
ch5[a]
ch7[a]
ch9[a]

85 (13)
177 (21)
457 (37)
4825 (133)

157 (30)
206 (39)
255 (48)
353 (66)
451 (84)

192 (24)
664 (56)
3336 (168)

352 (32)
2200 (88)

Fig. 8: Deterministic NWAs queries chn[a] for n = 3, 4, 5, 7, 9: size (#states).

column, NWA-determinization didn’t terminate on nwa(sha(nwa(A8))) after a
few hours.

We also tested our algorithms on collections of XPath queries with a scalable
parameter, such as the queries chn(a) for increasing n. This series is known to
require many states for deterministic bottom-up evaluation. Indeed, the deter-
minization for stepwise hedge automata nwa(det(sha)) leads to a size explosion.
The method det(nwa(sha(.))), however, still yields small deterministic automata!
Generally this method produced satisfactory results in all our experiments. In
quite some cases, however, nwa(det(sha(.))) still behaves better.

We conjecture that these diﬀerences are related to the lack of minimization
in our current implementation. The main problem here is that minimal deter-
ministic NWAs do not exist for all regular languages of nested words [2]. This
is in strict contrast to the cases of word automata, tree automata, and SHAs.

We point out that SHAs are determinized in bottom-up and left-to-right
manner by combining the usual bottom-up determinization algorithms for tree
automata and the usual left-to-right determinization algorithm for Nfas. In
contrast to deterministic NWAs, they cannot support top-down determinism in
combination with bottom-up and left-to-right determinism though. The NWAs
obtained by compilation from SHAs are special in that they perform all their
work in a bottom-up and left-to-right manner, and nothing top-down. Such
NWAs were characterized syntactically as single-entry NWAs, and determin-
istic single-entry NWAs are shown to admit a unique minimization in [2]. Our
experiments show that NWA determinization often works nicely for single-entry
NWAs, while it explodes quickly without the single-entry restriction. The intu-
ition is that single-entry NWAs behave like SHAs.

Small dNWAs for Nested Regular Expressions

13

References

1. Alur, R.: Marrying words and trees. In: 26th ACM SIGMOD-SIGACT-SIGART
Symposium on Principles of Database Systems. pp. 233–242. ACM-Press (2007),
http://dx.doi.org/10.1145/1265530.1265564

2. Alur, R., Kumar, V., Madhusudan, P., Viswanathan, M.: Congruences for vis-
ibly pushdown languages. In: Automata, Languages and Programming, 32nd
International Colloquium. Lecture Notes in Computer Science, vol. 3580, pp.
1102–1114. Springer Verlag (2005). https://doi.org/10.1007/11523468 89, http:
//dx.doi.org/10.1007/11523468_89

3. Alur, R., Madhusudan, P.: Visibly pushdown languages. In: 36th ACM Symposium
on Theory of Computing. pp. 202–211. ACM-Press (2004), http://portal.acm.
org/citation.cfm?coll=GUIDE&dl=GUIDE&id=1007390

4. Benedikt, M., Jeﬀrey, A., Ley-Wild, R.: Stream Firewalling of XML Constraints.
In: ACM SIGMOD International Conference on Management of Data. pp. 487–498.
ACM-Press (2008)

5. Bozzelli, L., S´anchez, C.: Visibly rational expressions. Acta Inf. 51(1), 25–49 (Feb
2014). https://doi.org/10.1007/s00236-013-0190-6, http://dx.doi.org/10.1007/
s00236-013-0190-6

6. Br¨uggemann-Klein, A.: Regular expressions into ﬁnite automata. Theoretical
Computer Science 120(2), 197–213 (Nov 1993). https://doi.org/10.1016/0304-
3975(93)90287-4, http://dx.doi.org/10.1016/0304-3975(93)90287-4

7. Br¨uggemann-Klein, A., Wood, D.: One-Unambiguous regular languages. Informa-

tion and Computation 142(2), 182–206 (May 1998)

8. Carme, J., Niehren, J., Tommasi, M.: Querying unranked trees with stepwise tree
automata. In: 19th International Conference on Rewriting Techniques and Applica-
tions. Lecture Notes in Computer Science, vol. 3091, pp. 105–118. Springer Verlag
(2004), http://www.ps.uni-sb.de/Papers/abstracts/stepwise.html

9. Champav`ere, J., Gilleron, R., Lemay, A., Niehren, J.: Eﬃcient inclusion checking
for deterministic tree automata and XML schemas. Information and Computation
207(11), 1181–1208 (2009). https://doi.org/10.1016/j.ic.2009.03.003, http://dx.
doi.org/10.1016/j.ic.2009.03.003

10. Comon, H., Dauchet, M., Gilleron, R., L¨oding, C., Jacquemard, F., Lugiez, D.,
Tison, S., Tommasi, M.: Tree automata techniques and applications. Available
online since 1997: http://tata.gforge.inria.fr (Oct 2007)

11. D’Antoni, L., Alur, R.: Symbolic visibly pushdown automata. In: Biere, A., Bloem,
R. (eds.) Computer Aided Veriﬁcation - 26th International Conference, CAV 2014,
Held as Part of the Vienna Summer of Logic, VSL 2014, Vienna, Austria, July
18-22, 2014. Proceedings. Lecture Notes in Computer Science, vol. 8559, pp.
209–225. Springer (2014). https://doi.org/10.1007/978-3-319-08867-9 14, https:
//doi.org/10.1007/978-3-319-08867-9_14

12. Debarbieux, D., Gauwin, O., Niehren, J., Sebastian, T., Zergaoui, M.: Early nested
word automata for xpath query answering on XML streams. Theor. Comput. Sci.
578, 100–125 (2015). https://doi.org/10.1016/j.tcs.2015.01.017, http://dx.doi.
org/10.1016/j.tcs.2015.01.017

13. Fischer, M.J., Ladner, R.E.: Propositional dynamic logic of regular programs.
J. Comput. Syst. Sci. 18(2), 194–211 (1979). https://doi.org/10.1016/0022-
0000(79)90046-1, https://doi.org/10.1016/0022-0000(79)90046-1

14. Franceschet, M.: Xpathmark performance test. https://users.dimi.uniud.it/

~massimo.franceschet/xpathmark/PTbench.html, accessed: 2020-03-27

15. Gauwin, O., Niehren, J.: Streamable fragments of forward XPath. In: Markhoﬀ,
B.B., Caron, P., Champarnaud, J.M., Maurel, D. (eds.) International Conference

14

I. Boneva, J. Niehren and M. Sakho

on Implementation and Application of Automata. Lecture Notes in Computer
Science, vol. 6807, pp. 3–15. Springer (2011). https://doi.org/10.1007/978-3-642-
22256-6 2, http://dx.doi.org/10.1007/978-3-642-22256-6_2

16. Gauwin, O., Niehren, J., Tison, S.: Earliest query answering for deterministic
nested word automata. In: 17th International Symposium on Fundamentals of
Computer Theory. Lecture Notes in Computer Science, vol. 5699, pp. 121–132.
Springer Verlag (2009), http://hal.inria.fr/inria-00390236/en

17. Gottlob, G., Koch, C., Pichler, R.: The complexity of XPath query evaluation.
In: 22nd ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database
Systems. pp. 179–190 (2003)

18. Grez, A., Riveros, C., Ugarte, M.: A formal framework for complex event pro-
cessing. In: Barcel´o, P., Calautti, M. (eds.) 22nd International Conference on
Database Theory, ICDT 2019, March 26-28, 2019, Lisbon, Portugal. LIPIcs,
vol. 127, pp. 5:1–5:18. Schloss Dagstuhl
- Leibniz-Zentrum fuer Informatik
(2019). https://doi.org/10.4230/LIPIcs.ICDT.2019.5, https://doi.org/10.4230/
LIPIcs.ICDT.2019.5

19. Hosoya, H., Pierce, B.C.: Xduce: A statically

Internet Techn.

typed XML process-
(2003).
https://doi.org/10.1145/767193.

117–148

3(2),

ing
language. ACM Trans.
https://doi.org/10.1145/767193.767195,
767195

20. Martens, W., Niehren, J.: On the Minimization of XML-Schemas and Tree Au-
tomata for Unranked Trees. Journal of Computer and System Science 73(4),
550–583 (2007). https://doi.org/10.1016/j.jcss.2006.10.021, https://hal.inria.
fr/inria-00088406, special issue of DBPL 05

21. Mozafari, B., Zeng, K., Zaniolo, C.: From regular expressions to nested words:
Unifying languages and query execution for relational and XML sequences.
PVLDB 3(1), 150–161 (2010). https://doi.org/10.14778/1920841.1920865, http:
//www.vldb.org/pvldb/vldb2010/pvldb_vol3/R13.pdf

22. Mozafari, B., Zeng, K., Zaniolo, C.: High-performance complex event pro-
cessing over XML streams. In: Candan, K.S., Chen, Y., Snodgrass, R.T.,
Gravano, L., Fuxman, A., Candan, K.S., Chen, Y., Snodgrass, R.T., Gra-
vano, L., Fuxman, A.
(eds.) SIGMOD Conference. pp. 253–264. ACM
(2012). https://doi.org/10.1145/2213836.2213866, http://dx.doi.org/10.1145/
2213836.2213866

23. Neumann, A., Seidl, H.: Locating matches of tree patterns in forests. In: Founda-
tions of Software Technology and Theoretical Computer Science. Lecture Notes in
Computer Science, vol. 1530, pp. 134–145. Springer Verlag (1998)

24. Olteanu,

D.:

SPEX:

IEEE Trans.

XPath.
https://doi.org/10.1109/TKDE.2007.1063,
2007.1063

Streamed

progressive
and
on Know. Data Eng. 19(7),

of
(2007).
http://dx.doi.org/10.1109/TKDE.

evaluation

934–949

25. Pitcher, C.: Visibly pushdown expression eﬀects for xml stream processing. In:

PlanX (2005)

26. Thatcher, J.W.: Characterizing derivation trees of context-free grammars through
a generalization of automata theory. Journal of Computer and System Science 1,
317–322 (1967)

Small dNWAs for Nested Regular Expressions

15

A XPath Benchmark

We consider the navigational XPath queries A1-A8 from the XPath benchmark
with forward axes child and descendant axes, path compositions, and ﬁlters.
These are recalled in Fig. 9 We encoded these XPath queries semi-automatically
to nested regular expressions, some of which are given in Fig. 10. Without ﬁlters
as in A1 and A2 this is can be done automatically. In the case of nonoverlapping
ﬁlters as in A4, we test them in all possible orders.

B NWAs for µ-Expressions

For illustration, we consider the NRE E = µa.(cid:104)a∗(cid:105). The reader should be warned
that constructing an NWA for E is less trivial than it might seem at ﬁrst sight.
One has to start from the NWA for (cid:104)a∗(cid:105)) which is given in Fig. 11. Simply
adding epsilon edges to capture the operator µa will not work though. It will
lead to the wrong automaton in Fig. 12. This automaton will wrong accept the
hedge (cid:104)(cid:105)(cid:104)(cid:105), since this hedge does not belong to L(E).

Fig. 13 illustrates the product automaton for E obtained by our construction,

where only accessible states are kept.

C Determinization of NWAs

We adapt the usual determinization procedure for NWAs [12,1] so that they can
account for hedge ending and else rules.

Deﬁnition 5. An NWA is deterministic if I is a singleton or empty, ε∆ is
empty, for all a ∈ Σ a∆ and ∆ are partial functions from Qh to Qh, for all
q ∈ Qh and γ ∈ Γ there exists a most one q(cid:48) ∈ Qh such that q(cid:48) ∈ (cid:104)∆
γ , and for all
γ ∈ Γ , (cid:105)∆

γ is a partial function from Qh to Qt.

(cid:104)↓γ1−−−→ q1 and q

Given an NWA A = (Qh, Qt, Σ, Γ, ∆, I, F ), the diﬃculty is to deal with con-
(cid:104)↓γ2−−−→ q2 in ∆ during determinization with-
current opening rules q
out mixing up the stack symbols γ1 and γ2. Therefore, we use transition relations
, Σ, Γ det , ∆det ,
as states of the determinized automaton det(A) = (Qdet
t = 2Qh×Qt. The only initial state is the
h = 2Qh×Qh, Qdet
I det , F det ), that is Qdet
transition idI which relates all initial states of A to themselves, i.e., I det = {idI }.
The set of ﬁnal states is F det = {τ ∈ Qdet
| τ ∩(I ×F ) (cid:54)= ∅}. Schemas generating
h
the transition rules in ∆det are given in Fig. 14. For a transition τ ∈ Q × Q, we
write lab(τ ) = {a ∈ Σ | ∃(q, q(cid:48)) ∈ τ, q(cid:48)(cid:48) ∈ Q.q(cid:48) a−→ q(cid:48)(cid:48) wrt. ∆}. These schemas for
generate transition rules for the accessible transitions only.

h , Qdet

t

The determinization of det(nwa(ch∗(a + b))) is given in Fig. 15 of the ap-
pendix: it has size 271 while the nondeterministic version has size 39. Even worse,
we will see in Section 7, that the size increase is really too bad in many practical
cases of the XPath benchmark suite. Unfortunately, this problem is not solved
by adding factorization and restricting the compiler to accessible transitions.
Indeed, the problem of such a huge size increase was also reported earlier for

16

I. Boneva, J. Niehren and M. Sakho

NWAs obtained from XPath by a diﬀerent compiler [12] via a logical intermedi-
ate language. So the question is, whether there do not exist better compilation
methods to obtain smaller deterministic NWAs for nested regular expressions.

D Determinization of SHAs

We formalize the notion of determinism for stepwise hedge automata and show
that how determinization works.

Deﬁnition 6. A SHA is deterministic if (cid:104)(cid:105)∆ and I are both singletons or empty,
ε∆ is empty, for all a ∈ Σ and q ∈ Qt, a∆, q∆, ∆ are partial functions from Qh
to Qh, and tree ∆ is a partial function from Qh to Qt.

Proposition 1 A SHA can be made deterministic in at most exponential time
such that the hedge language is preserved.

Proof. In a ﬁrst step we eliminate ε-rules as usual for NFAs in cubic time. Given
a stepwise hedge automaton S = (Qh, Qt, Σ, ∆, I, F ) without ε-rules, we deﬁne
an equivalent deterministic stepwise hedge automaton det(A) = (Qdet
, Σ,
t = 2Qt, I det = {I} and F det =
∆det , I det , F det ) such that Qdet
{Q(cid:48) ⊆ Qh | Q(cid:48) ∩ F (cid:54)= ∅}. There is a unique tree initial state in (cid:104)∆det
= {(cid:104)∆}
and no ε-rule in ε∆det
= ∅. Furthermore, for all Q1, Q2 ⊆ Qh, a ∈ lab(Q1), and
Q(cid:48) ⊆ Qt:

h = 2Qh, Qdet

h , Qdet

t

Q(cid:48)
−→ Q2 wrt. ∆det iﬀ Q2 = {q2 | ∃q1 ∈ Q1, q ∈ Q(cid:48). q1
a−→ Q2 wrt. ∆det iﬀ Q2 = {q2 | ∃q1 ∈ Q1, q1

q(cid:48)
−→ q2 wrt ∆}
a−→ q2 wrt ∆}∪

Q1
Q1

{q2 | ∃q1 ∈ Q1. q1 −→ q2 wrt. ∆ and (cid:54) ∃q3 ∈ Q.q1

a−→ q3 wrt. ∆}

(cid:105)
−→ Q2 wrt. ∆det iﬀ Q2 = {q2 | ∃q1 ∈ Q1, q1

(cid:105)
Q1
−→ q2 wrt ∆}
Q1 −→ Q2 wrt. ∆det iﬀ Q2 = {q2 | ∃q1 ∈ Q1, q1 −→ q2 wrt ∆}

We can show for all Q1, Q2 ⊆ Qh and Q(cid:48) ⊆ Qt that LQ1,Q2 (det(S)) =
(cid:83)
q(cid:48)∈Q(cid:48) Lq(cid:48)(S). Hence L(det(S)) =
q1∈Q1,q2∈Q2
(cid:83)
q2∈F Lq1,q2 (S) = L(S).

Lq1,q2(S) and that LQ(cid:48)(det(S)) = (cid:83)
Q(cid:48)∈F det LI,Q(cid:48)(det(S)) and thus L(det(S)) = (cid:83)

q1∈I

(cid:83)

Small dNWAs for Nested Regular Expressions

17

A1: /site/closed auctions/closed auction/annotation/description/text

/keyword

A2: //closed auction//keyword
A3: /site/closed auctions/closed auction//keyword
A4: /site/closed auctions/closed auction

[annotation/description/text/keyword]/date

A5: /site/closed auctions/closed auction[descendant::keyword]/date
A6: /site/people/person[profile/gender and profile/age]/name
A7: /site/people/person[phone or homepage]/name
A8: /site/people/person

[address and (phone or homepage) and (creditcard or profile)]
/name

Fig. 9: XPath benchmark queries.

A1 (cid:104)doc ·

· (cid:104)elem · site ·

· T · (cid:104)elem · closed auctions ·
· T · (cid:104)elem · annotation ·

(cid:104)elem · closed auction ·
(cid:104)elem · description ·
(cid:104)elem · keyword · x · T (cid:105) · T (cid:105) · T (cid:105) · T (cid:105) · T (cid:105) · T (cid:105) · T (cid:105) · T (cid:105)

· T · (cid:104)elem · text ·

· T ·

· T ·

· T ·

A2 (cid:104)doc ·

· (µd1.((cid:104)elem · closed auction ·

· T · (µd2.(

(cid:104)elem · keyword · x · T (cid:105) · T + (cid:104)T · d1 · T (cid:105) · T ))(cid:105) · T + (cid:104)T · d1 · T (cid:105) · T ))(cid:105)

A3 (cid:104)doc ·

· (cid:104)elem · site ·

· T · (cid:104)elem · closed auctions ·

· T · (cid:104)elem · closed auction ·

· T · (

µd.((cid:104)elem · keyword · x · T (cid:105) · T + (cid:104)T · d · T (cid:105) · T ))(cid:105) · T (cid:105) · T (cid:105) · T (cid:105)

A4 (cid:104)doc ·

· T ·
· (cid:104)elem · site ·
(cid:104)elem · closed auctions ·

(T · (cid:104)elem · annotation ·

· T · (cid:104)elem · closed auction ·
· T · (cid:104)elem · description ·

·
· T ·

(cid:104)elem · text ·

· T · (cid:104)elem · keyword ·
& (T · (cid:104)elem · date · x · T (cid:105) · T (cid:105) · T )(cid:105) · T (cid:105) · T (cid:105)

· T (cid:105) · T (cid:105) · T (cid:105) · T (cid:105) · T (cid:105) · T )

A5 (cid:104)doc ·

· T · (cid:104)elem · closed auctions ·

· T · (

· (cid:104)elem · site ·
(cid:104)elem · closed auction ·
µd.((cid:104)elem · keyword ·
&((cid:104)elem · closed auction ·

· T · (
· T (cid:105) · T + (cid:104)T · d · T (cid:105) · T ))(cid:105) · T )

A6 (cid:104)doc ·

· (cid:104)elem · site ·

(cid:104)elem · prof ile ·
&((cid:104)elem · person ·
&((cid:104)elem · person ·
· (cid:104)elem · site ·

A7 (cid:104)doc ·

· T · (cid:104)elem · date · x · T (cid:105) · T (cid:105) · T )(cid:105) · T (cid:105) · T (cid:105)
· T ·

· T · (((cid:104)elem · person ·

· T · (cid:104)elem · people ·

· T · (cid:104)elem · gender ·

· T (cid:105) · T (cid:105) · T (cid:105) · T )

· T · (cid:104)elem · prof ile ·
· T · (cid:104)elem · name · x · T (cid:105) · T (cid:105) · T )(cid:105) · T (cid:105) · T (cid:105)
· T · (((cid:104)elem · person ·
· T · (cid:104)elem · people ·

· T · (cid:104)elem · age ·

· T ·

· T (cid:105) · T (cid:105) · T (cid:105) · T ))

(cid:104)elem · phone ·
(cid:104)elem · person ·
&((cid:104)elem · person ·

· T (cid:105) · T (cid:105) · T +
· T · (cid:104)elem · homepage ·
· T · (cid:104)elem · name · x · T (cid:105) · T (cid:105) · T )(cid:105) · T (cid:105) · T (cid:105)

· T (cid:105) · T (cid:105) · T ))

A8 (cid:104)doc ·

· (cid:104)elem · site ·
((((cid:104)elem · person ·
& ((cid:104)elem · person ·
(cid:104)elem · person ·
& (((cid:104)elem · person ·
(cid:104)elem · person ·
& ((cid:104)elem · person ·

· T ·

· T · (cid:104)elem · people ·
· T · (cid:104)elem · address ·
· T · (cid:104)elem · phone ·
· T · (cid:104)elem · homepage ·

· T (cid:105) · T (cid:105) · T )
· T (cid:105) · T (cid:105) · T +

· T (cid:105) · T (cid:105) · T ))

· T · (cid:104)elem · creditcard ·

· T (cid:105) · T (cid:105) · T +

· T · (cid:104)elem · prof ile ·
· T · (cid:104)elem · name · x · T (cid:105) · T (cid:105) · T )(cid:105) · T (cid:105) · T (cid:105)

· T (cid:105) · T (cid:105) · T )))

Fig. 10: The NREs of the XPath benchmark queries. Here
is the NRE that
accepts any internal letter, that is ¬{}. The schema restricts this letter to be
either equal to the variable x or its negation ¬x. In most cases it must be ¬x
since x will be read elsewhere, and may be read at most once.

18

I. Boneva, J. Niehren and M. Sakho

(cid:104) ↓ γ

q0

a

q1

tree

q2

(cid:105) ↓ γ

q3

Fig. 11: Automaton for the (cid:104)a∗(cid:105)
expression.

ε

(cid:104) ↓ γ

ε

q0

tree

q1

(cid:105) ↓ γ

q3

q2

ε

Fig. 12: Bad automaton for µa.(cid:104)a∗(cid:105)

(q0, 1)

(q3, 1)

ε

(cid:104) ↓ (γ, γ1)

(cid:105) ↓ (γ, γ1)

(q0, 2)

(cid:104) ↓ (γ, γ2 )

(q1, 2)

tree

ε

(cid:105) ↓ (γ, γ2)

(q3, 2)

(q2, 3)

ε

Fig. 13: Good automaton for µa.(cid:104)a∗(cid:105)

τ ∈ Qdet
h
τ −→ τ ◦ ∆ ∈ ∆det

τ ∈ Qdet
h

Q(cid:48) = {q(cid:48) | ∃( , q) ∈ τ. q

(cid:104)↓γ
−−→ q(cid:48) ∈ ∆}

(cid:104)↓τ
−−→ idQ(cid:48) ∈ ∆det

τ

τ ∈ Qdet
h
τ tree−−−→ τ ◦ tree∆ ∈ ∆det
τ ∈ Qdet
a ∈ lab(τ )
h

τ ∈ Qdet

t

(cid:104)τ (cid:105)∆ = ∪γ∈Γ (cid:104)∆

γ ◦ τ ◦ (cid:105)∆

γ

(cid:105)↑τ (cid:48)
−−−→ τ (cid:48) ◦ (cid:104)τ (cid:105)∆ ∈ ∆det

τ

τ (cid:48) = {(q, q(cid:48)) ∈ ∆ |(cid:54) ∃q(cid:48)(cid:48).q a−→ q(cid:48)(cid:48) wrt∆}

τ a−→ τ ◦ (a∆ ∪ τ (cid:48)) ∈ ∆det

Fig. 14: Determinization of NWAs.

Small dNWAs for Nested Regular Expressions

19

Fig. 15: Deterministic NWA: det(nwa(ch∗(a + b)).

20

I. Boneva, J. Niehren and M. Sakho

Fig. 16: Stepwise hedge automaton from NWA for sha(nwa(ch∗(a + b))).

Small dNWAs for Nested Regular Expressions

21

Fig. 17: Determinization
det(nwa(sha(ch∗(a + b)))).

of NWA from stepwise

hedge

automaton:

