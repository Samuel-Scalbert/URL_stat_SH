An extension of chronicles temporal model with
taxonomies -Application to epidemiological studies
Johanne Bakalara, Thomas Guyet, Olivier Dameron, André Happe,

Emmanuel Oger

To cite this version:

Johanne Bakalara, Thomas Guyet, Olivier Dameron, André Happe, Emmanuel Oger. An extension
of chronicles temporal model with taxonomies -Application to epidemiological studies. HEALTHINF
2021 - 14th International Conference on Health Informatics, Feb 2021, online, France. pp.1-10. ￿hal-
03096846￿

HAL Id: hal-03096846

https://hal.science/hal-03096846

Submitted on 5 Jan 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

An extension of chronicles temporal model with taxonomies - Application
to epidemiological studies

Johanne Bakalara1,2, Thomas Guyet2,3, Olivier Dameron2, Andr´e Happe4, and Emmanuel Oger1
1Univ Rennes, EA-7449 REPERES
2Univ Rennes, Inria, IRISA-UMR6074
3Institut Agro, Rennes
4CHRU Brest

Keywords:

Temporal query, Medico-administrative databases, Sequences of events, Chronicles, Semantic Web.

Abstract:

Medico-administrative databases contain information about patients’ medical events, i.e. their care trajecto-
ries. Semantic Web technologies are used by epidemiologists to query these databases in order to identify
patients whose care trajectories conform to some criteria. In this article we are interested in care trajecto-
ries involving temporal constraints. In such cases, Semantic Web tools lack computational efﬁciency while
temporal pattern matching algorithms are efﬁcient but lack of expressiveness. We propose to use a temporal
pattern called chronicles to represent temporal constraints on care trajectories. We also propose an hybrid
approach, combining the expressiveness of SPARQL and the efﬁciency of chronicle recognition to query care
trajectories. We evaluate our approach on synthetic data and real large data. The results show that the hybrid
approach is more efﬁcient than pure SPARQL, and validate the interest of our tool to detect patients having
venous thromboembolism disease in the French medico-administrative database.

1 Introduction

Pharmaco-epidemiology (PE) studies the condi-
tions and consequences of health products, i.e. drugs
or medical devices usage at the population scale in
real situations using methodologies developed in gen-
eral epidemiology.

Modern PE relies on administrative databases to
perform such studies on care trajectories, i.e.
on
patient-centered sequences of drugs deliveries, med-
ical procedures and hospitalizations. The use of
medico-administrative databases (MADB) is useful in
PE studies, since data are readily available and cover
a large population.

The problem with MADB is the semantic gap be-
tween raw data and the epidemiological question. On
the one side, epidemiologists are looking for medi-
cal events. For instance, they would like to iden-
tify patients suffering from venous thromboembolism
(VTE). On the other side, raw data are related to reim-
bursements of medical acts or drug deliveries. There
is no exploitable diagnosis available in administrative
databases and no clinical results related to medical
acts or exams.

The challenge for epidemiologists is to deﬁne phe-
notypes of medical events (Hong et al., 2019), i.e. a
combination of information available in the database

that reveals an occurrence of a medical event. For
instance, a patient having a lower limbs doppler ul-
trasonography exam and few days after a delivery of
anticoagulant drugs for 3 to 6 or 12 months is prob-
ably suffering from VTE. As MADB record medical
exam and drugs deliveries, the above description may
be used as a proxy of VTE.

The Semantic Web offers a relevant framework for
representing complex data patterns and linking them
with domain knowledge. Semantic Web data lan-
guage (e.g. RDF) is suitable to represent structured
data of MADB (Rivault et al., 2019). Moreover, link-
ing raw data to standard medical taxonomies is in-
teresting to enrich the description of cares with for-
malized expert knowledge (for instance, ICD-101 for
diagnosis or ATC2 for drugs). Once care trajectories
have been represented in standard Semantic Web for-
mat, SPARQL query engines can be used to enumer-
ate all situations that match a query. A query can be
seen as a phenotype. However, if the expressiveness
of SPARQL is interesting to specify complex care tra-
jectories as a phenotype, the drawback is their com-

1ICD-10:

International Classiﬁcation of Diseases,
10th Revision. http://bioportal.bioontology.org/ontologies/
ICD10

2ATC: Anatomical Therapeutic Chemical.

https://

bioportal.bioontology.org/ontologies/ATC

putation time. In the following, we assume the reader
to be familiar with RDF and SPARQL, but a thorough
introduction to semantic web can be found in (Hitzler
et al., 2009). The example of VTE illustrates that such
query may be a complex arrangement of cares in a pa-
tient care trajectory. These arrangement involve tem-
poral relations between events (quantitative delays).
Thus, we are interested in specifying complex tempo-
ral patterns that may occur in care trajectories. Taking
into account numerical ﬁlters in metric temporal con-
straints is not efﬁcient in SPARQL queries, and we
can not expect to achieve reasonable computational
efﬁciency on large MADB.

This article addresses the problem of enumerating
the occurrences of a complex temporal pattern in a
dataset of care trajectories.

We focus on a class of temporal patterns called
chronicles and propose a template of SPARQL query
that is both expressive and efﬁcient. A chronicle is
an expressive temporal pattern.
It is deﬁned as a
set of events linked with temporal constraints. De-
spite its lack of taxonomy handling, this temporal
model is suitable to represent complex temporal care
pathways. One of its interests is its efﬁciently to
be recognized in a sequence of events (Dousson and
Le Maigat, 2007).

Our contribution is threefold: (i) we show how
chronicles can be encoded as SPARQL queries to enu-
merate all their occurrences in a sequence of events
represented in RDF; (ii) we propose HYCOR, an hy-
brid method combining the expressiveness of Seman-
tic Web and the efﬁciency of a pattern occurrence
enumeration algorithm; (iii) we evaluate HYCOR on
a real case study of enumerating VTE events in the
French MADB.

2 Related Work

In this section, we review some approaches to enu-
merate occurrences of temporal patterns in sequences
of events and their connection to Semantic Web.

Temporal databases and querying tools (Snod-
grass and llsoo Ahn, 1986) address a part of the prob-
lem by extending the notion of database to times-
tamped data. They cover data representation prob-
lems but also speciﬁc querying language problems.
This family encompasses the temporal extension of
relational databases (e.g. TSQL) but also Seman-
tic Web approaches which combine query language
(SPARQL) extended to temporal data with Allen’s re-
lations (Wang et al., 2010). These approaches de-
ﬁnes relative temporal constraints between intervals
which are not relevant for the MADB query problems

(Pacaci et al., 2018).

Rivault et al. (Rivault et al., 2019) used RDF to
represent care trajectories and shown that querying
care trajectories can be achieved with the SPARQL
query language. Semantic Web is a relevant approach
it does not explicitly address the
for our problem:
problem of timed queries, but it is relevant to deal
with data representation and taxonomies querying.
RDF also enables ontology management with OWL
based on the Description Logic (DL) (Baader et al.,
2003) allowing ontology-mediated query answering
(OMQA) (Bienvenu, 2016). For instance, O’Connor
et al. (O’Connor et al., 2009) developed a tool based
on OWL for research data management with a tem-
poral reasoning in a clinical trial system. This aspect
could be added to the presented method.
Some approaches proposed to extend RDF/SPARQL
with temporal queries in a generic way. For instance,
Zhang et al. (Zhang et al., 2019) propose SPARQL[t]
and EP-SPARQL (Anicic et al., 2011a) which is a
SPARQL extension of event processing. Finally, ON-
TOP is an ontology-based data access framework that
has been extended for temporal data (Kalayci et al.,
2019). However, these generic tools turn out to lack
practical efﬁciency. This calls for investigating more
algorithmic solutions.

Several temporal models have been highlighted
in literature, one of the most promising is the Com-
plex Event Processing (CEP) (Giatrakos et al., 2017)
which aims at processing a stream of event logs with
patterns. CEP processes these logs to detect or to lo-
cate complex events (or patterns) deﬁned by the user.
These models emphasis on the effectiveness of pro-
cessing and the expressivity of patterns. Some expres-
sive formalisms, e.g. ETALIS (Anicic et al., 2011b) or
logic-based event recognition (Giatrakos et al., 2017)
propose very expressive representations of complex
events, including reasoning techniques (encompass-
ing ontologies).

While the complex event descriptions of ETALIS
are based on Allen’s logic, temporal constraint net-
works (Cabalar et al., 2000) and Chronicles (Dous-
son and Le Maigat, 2007) propose complex event de-
scriptions with more permissive temporal constraints.
These temporal models are also interesting for their
graphical representation, but are restricted to patterns
which do not involve taxonomies. It has been mainly
used to discover patterns in biomedical data (Daux-
ais et al., 2017; Sahugu`ede et al., 2018) or in logs of
industrial processes (Sellami et al., 2018).

3 Sequences and Taxonomies

In this work, we adopt a longitudinal view of a
MADB. Each patient is represented by a sequence of
timestamped cares, so called events. We ﬁrst intro-
duce the deﬁnition of event and taxonomy of event
labels. Then, we introduce the notion of temporal se-
quence of events, or sequence for short.

Formally, an event is a pair (e,t) where e is an
event label and t ∈ N is a timestamp (in days). In the
following, (E, ≤E) denotes the totally ordered set of
events. Usually, labels of medical events are related
to taxonomies such as ATC2 for drugs or ICD-101 for
diseases.

Deﬁnition 1 (Event taxonomy). An event taxonomy
is an ordered set of equivalence relations (R i)i∈[n],
where n is the number of levels of the taxonomy, such
that:

∀(i, j), i < j, ∀(e, e(cid:48)) ∈ E, eR je(cid:48) =⇒ eR ie(cid:48).
We denote by c j

i the i-th equivalent class at level
j induced by the taxonomy. By deﬁnition, we have
that e ∈ E ⇔ ∃!i, c0
i = e. C denotes the set of all
equivalent classes.

(1)

An event label e ∈ E is a c ∈ C, denoted e (cid:32) c, iff
e is in the equivalent class of c. By extension, c ∈ C
is a c(cid:48) ∈ C, denoted c(cid:48) (cid:32) c iff e (cid:32) c(cid:48) ⇒ e (cid:32) c for all
e ∈ E. And then (E, ≤E, (cid:32)) denotes a set of ordered
event labels equipped by a taxonomy relation.

In the Table 1, events are represented by ATC
codes. Each ATC code is a class in the ATC taxon-
omy. For example, the ATC code A01AA01 is a sub-
class of A (A01AA01 (cid:32) A).

Let us now introduce the formal deﬁnition of a

temporal sequence of events.

Deﬁnition 2 (Sequence). A sequence s is a ﬁnite list
of events (cid:104)(e1,t1), (e2,t2), · · · , (en,tn)(cid:105) where ei is an
event label which is a taxonomy class. Events in a
sequence are ordered by their timestamps and then
their label: i ≤ j ⇔ ti < t j ∨(ti = t j ∧ei ≤E e j), ∀i, j ∈
{1, . . . , n}.

A dataset of sequences is a ﬁnite unordered set
of sequences, S = {s1, . . . , sm}. Tab. 1 illustrates six
sequences where each event is a drug delivery where
event labels are issued from the ATC taxonomy.

4 Chronicle Occurrences

Enumeration

In this section, we propose an extended deﬁni-
tion of chronicles (Dauxais et al., 2017; Dousson

B01A,2

[-1,3]

A01,1

[
-
2
2
]

,

[-3,5]

C,3

[1,3]

C,4

Figure 1: Chronicle example with 4 events (vertices) and 4
temporal constraints (edges with temporal intervals). Vertex
labels give the event label (ATC codes).

and Le Maigat, 2007; Sahugu`ede et al., 2018) with
events belonging to taxonomy classes. Then, we de-
ﬁne formally a chronicle occurrence in a sequence
and the enumeration of all chronicle occurrences in
a sequence.

A chronicle is a set of events and a set of tempo-
ral constraints between pairs of events (Dousson and
Le Maigat, 2007). In our applied context, chronicle
enables to represent a phenotype. The enumeration
of chronicles occurrences aims at localizing where
this medical pattern occurs in a patient care trajec-
tory. This paper proposes a chronicle extension where
event may have label belonging to the equivalence
class of an event label.
Deﬁnition 3 (Chronicle). A chronicle C is a pair
(E,T ) where

• E

is

an

ordered
,

of

set
where

events
all

{(c1, 1), · · · , (cm, m)}
i ∈ {1, . . . , m}, ci ∈ E is an event label.
i designates the index of the i-th event index.

for

• T is a set of temporal constraints, i.e. expressions

of the form (c j, j)[t−,t+](ck, k) such that
– (c j, j), (ck, k) ∈ E,
– t−,t+ ∈ R ∪ {+∞, −∞} and
– For all (c j, j), (ck, k) ∈ E, j < k,

c j (cid:32) ck =⇒ ∃(c j, j)[t−,t+](ck, k) ∈ T
s.t. [t−,t+] ⊆ [1, +∞[

(2)

The chronicle size is m (number of events).
A temporal constraint (c j, j)[t−,t+](ck, k) en-
forces an event (ck, k) to occur with a temporal delay
in between t− and t+ from an occurrence of (c j, j).
Note that several events can have the same label. A
chronicle event may also have its label belonging to
the equivalent class of another event label. In these
cases, Eq. 2 enforces event occurrences to be ordered
by their index.

The Fig. 1 illustrates graphically the following 4-

sized chronicle C = (E,T ):

Table 1: Example of a dataset of six sequences (longitudinal view on six patients). Each sequence is made of drug deliveries
events (couples of label and timestamp). Labels are ATC codes, i.e. the code of a delivered drug in the ATC toxonomy.

id
s1
s2
s3
s4
s5
s6

Sequence
(A01AA01, 1), (B01AA01, 3), (A01AB14, 4), (C01AA01, 5), (C02AC01, 6), (D01AA01, 7)
(B01AA01, 2), (D01AA01, 4), (A01AA01, 5), (C01AA01, 7)
(A03AA01, 1), (B01AA01, 4), (C01AA01, 5), (B01AA01, 6), (C01AA01, 8), (D01AA01, 9)
(B01AA01, 4), (A01AB14, 6), (N01AA01, 8), (C01AA01, 9)
(B01AA01, 1), (A01AA01, 3), (C01AA01, 4)
(C01AA01, 4), (B01AA01, 5), (A01AA01, 6), (C01AA01, 7), (D01AA01, 10)

• E = {(A01, 1), (B01A, 2), (C, 3), (C, 4)}
{(A01, 1)[−1, 3](B01A, 2)
• T

=

(A01, 1)[−3, 5](C, 3) ,
(B01A, 2)[−2, 2](C, 3) , (C, 3)[1, 3](C, 4)}

,

where event labels belong to the ATC taxonomy. No-
tice that temporal constraints may have negative val-
ues. The temporal constraint (A01, 1)[−3, 5](C, 3)
states that an event with label in the equivalence class
of A01 must occur from 3 days before occurrence of
a C to 5 days after this occurrence. Thus, the chron-
icle Fig. 1 means: “An event A01 is followed by an
event B01A within a delay of [−1, 3] units of time
(ut). The later is followed by an event C within a de-
lay of [−2, 2] ut. In addition the delay between this
event C and the event labeled A01 must be in [−3, 5]
ut. Finally, C event is followed by an another event C
within a delay of [1, 3] ut”.

In the following, we introduce the deﬁnition of a
chronicle occurrence in a sequence. Then, one can be
interested in two different tasks: enumerating all oc-
currences of a chronicle in a sequence (chronicle enu-
meration), or deciding whether a chronicle occurs at
least once in the sequence (chronicle recognition). In
the following, we focus on the chronicle enumeration
task.
Deﬁnition 4 (Chronicle occurrence). Let

s = (cid:104)(e1,t1), (e2,t2), . . . , (en,tn)(cid:105)

be a sequence of length n and

C = (E = {(c1, 1), . . . , (cm, m)},T )

be a chronicle of size m over a set of labels
(E, ≤E, (cid:32)).

An occurrence of C in s is a subsequence of s of
length m, denoted ˜s = (cid:104)(eε1 ,tε1), . . . , (cεm,tεm)(cid:105), where
(εi)i=1..m are indices of an event in s and s.t.
(cid:32) ci
1. eεi
2. tε j − tεi ∈ [t−,t+]

whenever (ci, i)[t−,t+](c j, j) ∈ T .
(εi)i=1..m describes ˜s a subsequence of s. The ﬁrst
condition ensures that the i-th event label of ˜s is a sub-
class of ci. The second condition ensures that tempo-
ral constraints are satisﬁed. Note that Eq. 2 enforces

to have a strict order between events ck, c j whenever
ck (cid:32) c j. Thus, all εi, i ∈ [1, n] are distinct.

The chronicle of Fig. 1 occurs in sequences s1
For instance,

and s6 of the dataset in Table 1.
{(A01AA01, 1), (B01AA01, 3), (C01AA01, 5),
(C02AC01, 6)} is an occurrence of C in s1. This
occurrence is the subsequence of s1 with indices
(cid:104)1, 2, 4, 5(cid:105). The chronicle does not occur in s2 nei-
ther in s4 because of unsatisﬁed temporal constraints.
It does not occur in s5 as there is only one event with
a type of class C in the sequence and the chronicle
requires two different events. It does not occur in s3
because there is not an event in the subgroup of A01.

5 Semantic Web for Chronicle

Recognition

Semantic Web is a framework designed to repre-
sent, share and manipulate structured data. The key-
stones of Semantic Web are (i) formal data represen-
tations, such as the RDF language, and (ii) query lan-
guages, such as SPARQL. Semantic Web is particu-
larly suitable to represent taxonomies.

Semantic Web is suitable to represent sequences
with label events belonging to taxonomies and to en-
code chronicle enumeration with SPARQL. So, we
propose to represent sequences in RDF and to en-
code a chronicle enumeration in SPARQL. We pro-
pose two approaches for chronicle enumeration: the
ﬁrst approach fully uses Semantic Web technologies;
the second approach is an hybrid tool combining
SPARQL query and a dedicated algorithm.

5.1 Sequence Representation in RDF

Sequences are represented in a RDF-Graph (Fig. 2).
We remind that our concrete objective is to query a
dataset of sequences, where each patient care trajec-
tory is represented as a sequence.

seq:seq5 seq:hasEvent seq:seq5evt0 .
seq:seq5evt0 seq:evtLabel atc:B01AA01 ;

seq:evtDate '1'ˆˆxsd:integer .

seq:seq5 seq:hasEvent seq:seq5evt1 .
seq:seq5evt1 seq:evtLabel atc:A01AA01 ;

seq:evtDate '3'ˆˆxsd:integer .

seq:seq5 seq:hasEvent seq:seq5evt2 .
seq:seq5evt2 seq:evtLabel atc:C01AA01 ;

seq:evtDate '4'ˆˆxsd:integer .

Figure 2: Example of sequence representation in RDF
graph (see sequence s5 in Table 1).

SELECT DISTINCT * WHERE{
?sequence patdb:hasEvent ?evt1 .
?evt1 seq:evtDate ?date1 .
?evt1 seq:evtlabel ?atc1 .
?atc1 rdfs:subClassOf* atc:A01 .

?sequence patdb:hasEvent ?evt2 .
?evt2 seq:evtDate ?date2 .
?evt2 seq:evtlabel ?atc2 .
?atc2 rdfs:subClassOf* atc:B01A .

?sequence patdb:hasEvent ?evt3 .
?evt3 seq:evtDate ?date3 .
?evt3 seq:evtlabel ?atc3 .
?atc3 rdfs:subClassOf* atc:C .

?sequence patdb:hasEvent ?evt4 .
?evt4 seq:evtDate ?date4 .
?evt4 pseq:evtlabel ?atc4 .
?atc4 rdfs:subClassOf* atc:C .

FILTER ( ?date2 - ?date1 >= -1)
FILTER ( ?date2 - ?date1 <= 3)
FILTER ( ?date3 - ?date1 >= -3)
FILTER ( ?date3 - ?date1 <= 5)
FILTER ( ?date3 - ?date2 >= -2)
FILTER ( ?date3 - ?date2 <= 2)
FILTER ( ?date4 - ?date3 >= 1)
FILTER ( ?date4 - ?date3 <= 3)
}

Figure 3: Example of a SPARQL query for chronicle enu-
meration

In RDF, each event (e j,t j) in a sequence si is en-

coded by three tuples:

• seq:sequencei seq:hasEvent seq:sequenceievtj de-

notes existence of an event e j in sequence si

• seq:sequenceievtj seq:eventLabel atc:lk denotes
event e j has the label lk. Note atc referees to the
ATC taxonomy2 where lk is a leaf-class

• seq:sequenceievtj seq:eventDate '1'ˆˆ xsd:integer

denotes event e j has a date t j equal to 1.
Fig. 1 illustrates the representation in RDF by pro-
viding the representation of sequence s5 (see Table 1).

5.2 SPARQL for chronicle occurrences

enumeration

This section presents the chronicle recognition task
with SPARQL. SPARQL queries RDF sequences

where all sequences are in the same RDF named
Graph.

Figure 3 gives the SPARQL query for the chroni-

cle in Fig. 1. The query has three types of variables:

• ?sequence denotes an identiﬁer of a sequence

• ?evtj corresponds the j-th element of the chronicle

set.

• ?datej is the date of the j-th element of an occur-

rence (tε j with notation of Deﬁnition 4).
The taxonomy of event labels are handled by
rdfs:subClassOf* pattern operator. This operator is
equivalent to the operator (cid:32) deﬁned in Def. 1. Tem-
poral constraints are expressed in FILTER clauses. For
instance, the temporal constraint (C, 3)[1, 3](C, 4) is
translated in a couple of constraints between ?date4
and ?date3.

SPARQL is expressive enough for enumerating
chronicle occurrences. However the enumeration of
chronicle occurrences is a very computational task.
A SPARQL query can not compete with dedicated
enumeration algorithms as its solver strategy is not
optimised for this task (see experiments in Sect. 6).
Therefore, we propose an hybrid approach to beneﬁt
from the best of both ﬁelds: efﬁciency of dedicated
approaches and expressiveness of Semantic Web.

5.3 HYCOR for chronicle recognition

HYCOR (Hybrid-Chronicle Occurrences Recogni-
tion) combines SPARQL and a speciﬁc algorithm
to enumerate efﬁciently occurrences of a chronicle.
Fig. 5 illustrates the HYCOR process.

First (left box of Fig. 5), a SPARQL query yields
ﬂattened sequences . A ﬂattened sequence contains
only the sequence events that belong to the equivalent
class of at least one event label of E, i.e. the chronicle
events (see Def. 3). Such a query for chronicle of
Fig. 1 is on 4:

SELECT DISTINCT ?seq ?date ?label where{
values ?label { atc:A01 atc:B01A atc:C }
GRAPH patdb:onto { ?l rdfs:subClassOf* ?label }.
GRAPH ?seq{

?event patdb:drugDelivered ?l.
?event patdb:deliveryDate ?date.}}

Figure 4: Illustration of SPARQL query to map sequences
on the set of events of chronicle in Fig. 1.

Second (right box of Fig. 5), HYCOR applies Al-
gorithm 1 to enumerate chronicle occurrences in the
ﬂattened sequences.

The algorithm’s principle is to reﬁne progressively
intervals in which a chronicle event (ci, i) ∈ E may

Figure 5: Schema of the HYCOR process to enumerate occurrences of a chronicle C

Algorithm 1: Occurrences of a chronicle C
in a sequence s.

Input: C = (E = {(c1, 1), . . . , (cm, m)},T ),

s = (cid:104)(e1,t1) . . . (en,tn)(cid:105)

Output: occs: a set of occurrences of C in s

1 occs ← /0 // Set of occurrences
2 foreach (e,t) ∈ s do
3

if e = c1 then

// create a set of admissible
positions π of size m
π ← {[t,t], [−∞, ∞], . . . , [−∞, ∞]};
// propagate chronicle

constraints

foreach (c1, 1)[t−,t+](cp, p) ∈ T do

πp =
[max(t1,t + t−), min(t + t+,tn)];

occs ← occs∪
RECENUMERATE(π,1,C ,s);

4

5

6

7

8 return occs

occur in s. These intervals are called admissible po-
sitions. The algorithm goes through the set of events
(ei,ti) ∈ s and propagates the temporal constraints of
the chronicle to narrow position intervals until inter-
vals are only single position. Thus admissible posi-
tion designates a subsequence of s, i.e., an occurrence
of the chronicle. Algorithm 1 makes recursive calls
to Algorithm 2. The later assumes that the k − 1 ﬁrst
events have been located in s. This means that the
k ﬁrst intervals of the admissible intervals π are sin-
gleton intervals. The recursive call looks for event ck
in the admissible positions of s for k-th event (lines
If found, it is a candidate for further reﬁne-
5-6).
ments and temporal constraints of the chronicle are
propagated. The constraint (ck, k)[t−,t+](cp, p) is a
constraint from (ck, k) event to the event cp at posi-
tion p. It is used to possibly narrow the admissible
positions of event p (line 11). In case the new posi-
tions are inconsistent (line 12) then this candidate oc-
currence can not satisfy the temporal constraints and

Algorithm 2: RECENUMERATE(π, k, C , s).

Input: π: admissible positions, k: recursion

level,
C = (E = {(c1, 1), . . . , (cm, m)},T )),
s = (cid:104)(e1,t1) . . . (en,tn)(cid:105)

Output: occs: a set of occurrences of C in s

1 occs ← /0 // Set of occurrences
2 if k = m + 1 then

3

// An occurrence has been found
occ ← {(eki,tki) ∈ s | ci = eki, πi = tki, i =
1..m};
return {occ}

4
5 foreach (e,t) ∈ s s.t. t ∈ πk do
6

if e = ck then

// create a copy of

7

8

9

10

11

12

13

14

15

16

admissible positions π

˜π ← π;
˜πk ← [t,t];
// propagate chronicle

constraints
satis f iable ← true;
foreach (ck, k)[t−,t+](c, p) ∈ T do

p ,t +
p ,t + t+)];

˜πp ← [max( ˜π−
t−), min( ˜π+
p > ˜π+
if ˜π−
p then
satis f iable ← f alse;
break;

if satis f iable then

// Recursive call
occs ← occs∪
RECENUMERATE( ˜π, k + 1, C , s);

17 return occs

is discarded (satis f iable is set to f alse). If all con-
straints are satisﬁed, the recursive call attempts to re-
ﬁne further these positions (line 16). Note that only
forward constraints are propagated. Indeed, backward
constraints (i.e. constraint to event at position lower
than k in the set) have already been taken into account
in parent calls.

Sequenceswith only events of the chronicle C sequences verifying CSPARQL mapping events of Ctaking in account taxonomiesRecognition Algorithmverifying time constraints events of CSequencesillustrate the algorithm on a sim-
Let us
(A, 5)
ple example.
(B, 6) (C, 7) (C, 9) (C, 10)(cid:105) and C = ({(A, 1), (B, 2),
(A, 1)[−3, 5](C, 3),
(C, 3)},
(B, 2)[−1, 3](C, 3)}).

{(A, 1)[−2, 2](B, 2),

s = (cid:104)(B, 2)

(C, 3)

Let

1. Processing of event A

• generates a single tuple of admissible positions

π = ([5, 5], [−∞, ∞], [−∞, ∞])

• constraints propagation:
– (A, 1)[−2, 2](B, 2): π = ([5, 5], [3, 7], [−∞, ∞])
– (A, 1)[−3, 5](C, 3): π = ([5, 5], [3, 7], [2, 10])

2. Processing of event B

• narrows positions with occurrences: (B, 2) is
invalid (2 /∈ [3, 7]), but (B, 6) satisﬁes the ad-
missible positions [3, 7] so the admissible posi-
tions can be updated (π = ([5, 5], [6, 6], [2, 10]))

• constraints propagation:
– (B, 2)[−1, 3](C, 3): π = ([5, 5], [6, 6], [2, 10] ∩

[5, 9]) = ([5, 5], [6, 6], [5, 9])

3. Processing of event C

• narrows intervals with occurrences: (C, 3) and
(C, 10) are invalid, but (C, 7) and (C, 9) are
valid, then the both subsequences where the
chronicle occurs are obtained by updating the
admissible positions (([5, 5], [6, 6], [7, 7]) and
([5, 5], [6, 6], [9, 9])).

6 Experiments

In this section, we compare execution times of
SPARQL and HYCOR on synthetic datasets. All ex-
periments have been executed with a TDB-graph for-
mat for RDF and Jena-Fuseki as SPARQL engine.
The HYCOR algorithm is implemented in Python.
The computer has 16Go RAM and an SSD.

6.1 Synthetic datasets generation and

plan of experiments

Several synthetic datasets have been generated. Each
dataset contains a set of sequences where event labels
are randomly chosen at the lowest level of ATC tax-
onomy. The ATC taxonomy contains 1 900 classes.
In addition, occurrences of ten 15-sized chronicles3
are embedded in the dataset. For each chronicle, a
constraint is generated for each pair of events without
inconsistency between the temporal constraints.

3A n-sized-chronicle denotes a chronicle of size n.

The synthetic dataset generation process ensures
that each chronicle occurs in about 20% of the se-
quences. Chronicles contain event labels from sev-
eral levels of ATC following this probability: 1
15 level
1 (ex: N), 2
15 level 3 (ex: N02B),
15 level 4 (ex: N02BE), 6
3

15 level 2 (ex: N02), 3

15 level 5 (ex: N02BE01).

We introduce the notation Dns,ne to denote a syn-
thetic dataset with ns sequences and ne care events
per sequence (all sequences have the same num-
ber of events). For the following experiments, 25
synthetic datasets have been generated where ns ∈
{1 000, 5 000, 10 000, 15 000, 20 000} and ne ∈ {100,
200, 300, 400, 500}. Each dataset is encoded in RDF.
The ATC taxonomy is attached to the dataset.

6.2 Experiments and Results

The following experiments evaluate the impact of two
main parameters on execution times of SPARQL and
HYCOR: the size of the dataset (number of sequences
and number of events per sequence) and the chronicle
size.

Fig. 6 compares the execution times of SPARQL
and HYCOR with respect to the length of the se-
It shows that HYCOR is at least one or-
quences.
der of magnitude more efﬁcient than pure SPARQL.
6 shows that SPARQL does not scale up for datasets
containing more than 50 000 sequences. The HYCOR
SPARQL query language does not have the same lim-
itation. Indeed, the pure SPARQL query uses ﬁlters
to deal with temporal constraints on each admissible
event while SPARQL HYCOR query only uses val-
ues to ﬁnd admissible event. So, the use of ﬁlters on
a large scale of admissible events seems to be inefﬁ-
cient in SPARQL for this kind of use.

We also evaluate the part of HYCOR execution
times spent by the SPARQL mapping and the chroni-
cle enumeration algorithm. On average, the SPARQL
query execution represents 85% ± 3.47 of the total ex-
ecution time.

Experiments now focus on the HYCOR evalua-
tion. Fig. 7 illustrates the impact of the number of
events per sequence on the execution times. We ob-
serve that time increases linearly with the number of
events and with the number of sequences. Outliers
and variance of the computing time can be explained
by the variability of the number of events occurrences
in the sequence that inﬂuence the time execution of
the Algorithm 2. The more an event occurs in a se-
quence, the more candidate occurrences, therefore the
longer the time spent in the algorithm. Nonetheless,
we can notice in the hardest condition: D20 000,500,
enumeration of a chronicle with 15 events takes in av-
erage less than a minute.

Figure 6: Execution times (in seconds) of SPARQL and HYCOR wrt sequences length on 10 000 sequences (on the left) and
wrt number of sequences (with length 100).

Figure 7: Execution times of chronicle occurrences enumeration wrt sequences length.

Fig. 8 presents execution time of HYCOR wrt
chronicle size. HYCOR is run on a unique dataset
(ns = 10 000 and ne = 100) and seven sets of 10
chronicles with sizes 2 to 14. We observe execution
time linearly increases with the chronicle size.

HYCOR outperforms pure-SPARQL for

the
chronicle enumeration task.
Its execution time in-
creases with the chronicle sizes and the dataset size,
but it still offers impressive results for large datasets.

7 Use case on the SNDS to ﬁnd

patients with thromboembolism

Our use case proposes to ﬁnd patients diagnosed
with venous thromboembolism (VTE) in the SNDS.
The SNDS is the french national health insurance
database, which covers most of the french population
(above 65 million inhabitants). The advantage of this
database is to gather information about most the reim-
bursed medical events, from drug deliveries to nurse
home cares, specialist consultations, etc. The range
of medical events that are recorded in the database
makes it suitable to conduct a wide variety of health
studies (Tuppin et al., 2017). However, SNDS has
been designed for administrative purposes (care re-
imbursements) and does not contain detailed medical
information such as medical reports, laboratory re-
sults or diagnosis. This use case uses a geographical-

based SNDS subset (the north western French Brit-
tany population) which contains 377 359 individuals.
For the use case application, rdf:type have been
added in the RDF event triples to speed up access to
event labels. We used ﬁve different types: DrugDe-
liveries (e.g., drug deliveries from pharmacy), Cares
(e.g., nurse assistance, domestic assistance), Medical
acts (e.g., radiology, surgery), Biologies (e.g., blood
withdrawal), Hospitalisations.

VTE is identiﬁed by epidemiologists in SNDS

when a patient matches the following description:

In clinical practice facing a suspicion of VTE
physicians ﬁrst prescribe anticoagulant and
then conﬁrm or not the diagnosis through spe-
ciﬁc medical acts: e.g. Doppler ultrasonogra-
phy or CT scan. Patients with suspected PE
are often hospitalized whereas patients with
suspected DVT are managed on an ambula-
tory basis. If the suspicion is conﬁrmed, an-
ticoagulant deliveries continues for 3 to 12
months (once per month) or sometimes longer
duration. Hence, the diagnosis (through med-
ical act) is preceded or followed by anticoagu-
lant initiation within a time window of at most
0 to 7 days, keeping in mind that PE suspicion
leads to hospitalisation during which medical
acts to conﬁrm the diagnosis are performed
and then anticoagulant delivery is observed
only after the patient comes back home.

100150200250300350400450500Sequence length101102103Execution time (s)MethodHyCORSPARQL2500500075001000012500150001750020000Nb of sequences010203040Execution time (s)MethodHyCORSPARQL100200300400500Sequence length020406080Execution time (s)1000 sequences100200300400500Sequence length5000 sequences100200300400500Sequence length10000 sequences100200300400500Sequence length15000 sequences100200300400500Sequence length20000 sequencesFigure 8: Execution time (in seconds) wrt chronicle size (ns = 10 000 and ne = 100)

Fig. 9 illustrates two chronicles deﬁning the phe-
notype of “patients with VTE”. Each chronicle speci-
ﬁes temporal constraints (within 7 days and one anti-
coagulant delivery per month) but also takes into ac-
count some details on the anti-coagulant class and on
the medical acts on ambulatory or in hospital. An-
ticoagulant are identiﬁed with the ATC code B01.
We also added to the knowledge base a class named
ccam:thrombose which is deﬁned as an union
of 36 different codes of medical acts issued of the
CCAM taxonomy 4. Furthermore, some VTE are
identiﬁed in hospital through ICD-10 codes1, they are
gathered in a class called cim:diagthrombose.

For this experiment, we load RDF graphs, we
query them with both chronicles, one by one, and
evaluate computing time. Note that we do not have
the ground truth. Thus, we are not interested in the
accuracy of the chronicles to identify true VTE. In
this experiments, we compare the computational efﬁ-
ciency to enumerate the same set of VTE occurrences.

The ﬁrst result is that the corresponding pure-
SPARQL query does not ﬁnish the enumeration
within a day of computation. This is due to the scale
up limitation shown in Sect. 5.2.

HYCOR ﬁnds 2 686 patients having VTE in
105.06s. The ﬁrst chronicle ﬁnds 2 568 patients in
56.21s (of which 52.86s in algorithm execution), the
second chronicle ﬁnds 118 patients in 48.85s (of
which 48.46s in algorithm execution). Use case time
execution is even faster than expected by experiments
on synthetic data. The real patient sequences length
is about 100 events in average. So if we refer to
Fig. 6, on the right, the expected execution time is
about 11min41s. We explain this difference by the
lower size of the chronicles in our use case query.

4CCAM : common classiﬁcation of medical acts used

by the french social security

8 Conclusion

In this article, we extended the model of chron-
icle with taxonomies to enumerate complex tempo-
ral patterns in sequences. This problem is moti-
vated by the need for phenotyping patients in medico-
administrative databases. We proposed HYCOR, an
hybrid approach that combines the expressiveness of
SPARQL and the efﬁciency of a dedicated algorithm.
The results show that HYCOR is one order of mag-
nitude faster than pure SPARQL queries on both syn-
thetic and real dataset. As a perspective, chronicles
should be extended with negation to denote the ab-
sence of event. Furthermore, it could be interesting to
compare the efﬁciency of different SPARQL engines.

B01A

[-2,2]

ccam:thrombose

[
1
,
3

1
]

B01A

[1,31]

B01A

B01A

[-2,2]

cim:thrombose

[
1
,
3

1
]

B01A

[1,31]

B01A

Figure 9: Chronicles for representing VTE phenotype.

2468101214Chronicle size02468Execution time (s)macological and medical knowledge to data. Bioin-
formatics.

Sahugu`ede, A., Le Corronc, E., and Le Lann, M.-V. (2018).
In 3nd
An ordered chronicle discovery algorithm.
ECML/PKDD Workshop on Advanced Analytics and
Learning on Temporal Data, AALTD’18.

Sellami, C., Samet, A., and Tobji, M. A. B. (2018). Fre-
quent chronicle mining: Application on predictive
maintenance. In Proc. of Int. Conf. on Machine Learn-
ing and Applications (ICMLA), pages 1388–1393.
Snodgrass, R. T. and llsoo Ahn (1986). Temporal databases.

Computer, 19(09):35–42.

Tuppin, P., Rudant, J., Constantinou, P., Gastaldi-M´enager,
C., et al. (2017). Value of a national administrative
database to guide public decisions: From the syst`eme
national d’information interr´egimes de l’assurance
maladie (sniiram) to the syst`eme national des donn´ees
de sant´e (snds) in france. Revue d’epidemiologie et de
sante publique, 65:S149–S167.

Wang, Y., Zhu, M., Qu, L., Spaniol, M., and Weikum,
G. (2010). Timely YAGO: harvesting, querying, and
visualizing temporal knowledge from wikipedia.
In
Proc. of Int. Conf. on Extending Database Technology
(EDBT), pages 697–700.

Zhang, F., Wang, K., Li, Z., and Cheng, J. (2019). Temporal
data representation and querying based on RDF. IEEE
Access, 7:85000–85023.

REFERENCES

Anicic, D., Fodor, P., Rudolph, S., and Stojanovic, N.
(2011a). EP-SPARQL: a uniﬁed language for event
processing and stream reasoning. In Proc. of Int. Conf.
on World Wide Web (WWW), pages 635–644.

Anicic, D., Fodor, P., Rudolph, S., St¨uhmer, R., Stojanovic,
N., and Studer, R. (2011b). ETALIS: Rule-based rea-
soning in event processing. In Proc. of Reasoning in
event-based distributed systems, pages 99–124.
Baader, F., Calvanese, D., McGuinness, D., Patel-
Schneider, P., and Nardi, D. (2003). The description
logic handbook: Theory, implementation and applica-
tions. Cambridge university press.

Bienvenu, M. (2016). Ontology-mediated query answer-
ing: harnessing knowledge to get more from data. In
Proc. of Int. Join Conf. on Artiﬁcial Intelligence (IJ-
CAI), pages 4058–4061.

Cabalar, P., Otero, R. P., and Pose, S. G. (2000). Tem-
In Proc. of Eu-
poral constraint networks in action.
ropean Conf. on Artiﬁcial Intelligence (ECAI), pages
543–547.

Dauxais, Y., Guyet, T., Gross-Amblard, D., and Happe, A.
(2017). Discriminant chronicles mining. In Proc. of
Conf. on Artiﬁcial Intelligence in Medicine in Europe
(AIME), pages 234–244.

Dousson, C. and Le Maigat, P. (2007). Chronicle recogni-
tion improvement using temporal focusing and hier-
In Proc. of Int. Join Conf. on Artiﬁcial
archization.
Intelligence (IJCAI), pages 324–329.

Giatrakos, N., Artikis, A., Deligiannakis, A., and Garo-
falakis, M. (2017). Complex event recognition in the
big data era. In Proc. VLDB Endow., volume 10, pages
1996–1999.

Hitzler, P., Krotzsch, M., and Rudolph, S. (2009). Founda-
tions of semantic web technologies. CRC press.
Hong, N., Wen, A., Stone, D. J., Tsuji, S., Kingsbury, P. R.,
Rasmussen, L. V., Pacheco, J. A., Adekkanattu, P.,
Wang, F., Luo, Y., et al. (2019). Developing a FHIR-
based EHR phenotyping framework: A case study for
identiﬁcation of patients with obesity and multiple co-
morbidities from discharge summaries. J. of Biomed-
ical Informatics, 99:103310.

Kalayci, E. G., Brandt, S., Calvanese, D., Ryzhikov, V.,
Xiao, G., and Zakharyaschev, M. (2019). Ontology-
based access to temporal data with ontop: A frame-
Int. J. of Applied Mathematics and
work proposal.
Computer Science, 29(1):17–30.

O’Connor, M. J., Shankar, R. D., Parrish, D. B., and Das,
A. K. (2009). Knowledge-data integration for tem-
Int. J. of
poral reasoning in a clinical trial system.
Medical Informatics, 78:77–85.

Pacaci, A., Gonul, S., Sinaci, A. A., Yuksel, M., and
Laleci Erturkmen, G. B. (2018). A semantic transfor-
mation methodology for the secondary use of observa-
tional healthcare data in postmarketing safety studies.
Frontiers in pharmacology, 9:435.

Rivault, Y., Dameron, O., and Le Meur, N. (2019).
queryMed: Semantic web functions for linking phar-

