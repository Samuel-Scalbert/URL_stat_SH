Inconsistency Handling in Prioritized Databases with
Universal Constraints: Complexity Analysis and Links
with Active Integrity Constraints
Meghyn Bienvenu, Camille Bourgaux

To cite this version:

Meghyn Bienvenu, Camille Bourgaux. Inconsistency Handling in Prioritized Databases with Universal
Constraints: Complexity Analysis and Links with Active Integrity Constraints. 20th International
Conference on Principles of Knowledge Representation and Reasoning (KR 2023), Sep 2023, Rhodes,
Greece. pp.97-106, ￿10.24963/kr.2023/10￿. ￿hal-04204432￿

HAL Id: hal-04204432

https://hal.science/hal-04204432

Submitted on 12 Sep 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution 4.0 International License

Inconsistency Handling in Prioritized Databases with Universal Constraints:
Complexity Analysis and Links with Active Integrity Constraints

Meghyn Bienvenu1 , Camille Bourgaux2
1 CNRS, University of Bordeaux, Bordeaux INP, LaBRI, Talence, France
2 DI ENS, ENS, CNRS, PSL University & Inria, Paris, France
meghyn.bienvenu@labri.fr, camille.bourgaux@ens.fr

Abstract

This paper revisits the problem of repairing and querying in-
consistent databases equipped with universal constraints. We
adopt symmetric difference repairs, in which both deletions
and additions of facts can be used to restore consistency, and
suppose that preferred repair actions are specified via a binary
priority relation over (negated) facts. Our first contribution
is to show how existing notions of optimal repairs, defined
for simpler denial constraints and repairs solely based on fact
deletion, can be suitably extended to our richer setting. We
next study the computational properties of the resulting repair
notions, in particular, the data complexity of repair check-
ing and inconsistency-tolerant query answering. Finally, we
clarify the relationship between optimal repairs of prioritized
databases and repair notions introduced in the framework
In particular, we show that
of active integrity constraints.
Pareto-optimal repairs in our setting correspond to founded,
grounded and justified repairs w.r.t. the active integrity con-
straints obtained by translating the prioritized database. Our
study also yields useful insights into the behavior of active
integrity constraints.

1

Introduction

When a database is inconsistent w.r.t. the integrity con-
straints, it is possible to obtain meaningful query answers by
adopting the consistent query answering (CQA) approach
(Arenas, Bertossi, and Chomicki 1999). In a nutshell, the
idea is to consider a set of repairs, which correspond to those
databases that satisfy the constraints and are as close as pos-
sible to the original database. An answer is then considered
true w.r.t. CQA semantics if it holds no matter which repair is
chosen, thus embodying the cautious mode of reasoning em-
ployed in many KR contexts. The CQA approach was subse-
quently extended to the setting of ontology-mediated query
answering, which led to the proposal of other natural repair-
based semantics, such as the brave semantics, which con-
siders as true those answers that hold in at least one repair
(Bienvenu and Rosati 2013), and the intersection (or IAR)
semantics, which evaluates queries w.r.t. the intersection of
the repairs (Lembo et al. 2010). There is now an extensive
literature on CQA and other forms of inconsistency-tolerant
query answering, (Bertossi 2019) and (Bienvenu 2020) pro-
vide recent surveys for the database and ontology settings.

Several different notions of repair have been considered,
depending on the considered class of constraints and the al-

lowed repair actions. For denial constraints (such as func-
tional dependencies, FDs) and constraints given by ontolo-
gies, consistency can be restored only by removing informa-
tion, so subset repairs based upon fact deletions are the most
common choice. For richer classes of constraints, however,
it makes sense to consider symmetric difference repairs ob-
tained using both fact additions and deletions. This is the
case for the universal constraints considered in the present
paper, which can be used to express data completeness as-
sumptions and other kinds of domain knowledge. For exam-
ple, in a hospital setting, a universal constraint can be used
to capture expert knowledge that a patient cannot receive
a certain treatment without a positive test for a given muta-
tion, with violations indicating either an erroneous treatment
record or missing test result. Universal constraints are one
of the most expressive classes of first-order constraints for
which CQA with symmetric difference repairs is decidable,
albeit intractable: Πp
2-complete w.r.t. data complexity (Sta-
worko and Chomicki 2010; Arming, Pichler, and Sallinger
2016). Despite this high complexity, there have been some
prototype implementations using logic programming (Eiter
et al. 2008; Marileo and Bertossi 2010).

Repairs can be further refined by taking into account
information about the relative reliability of the database
facts. In the framework of prioritized databases (Staworko,
Chomicki, and Marcinkowski 2012), a binary priority rela-
tion indicates preferences between pair of facts involved in
some violation of a denial constraint. Three kinds of opti-
mal repair (Pareto-, globally-, and completion-optimal) are
then defined to select the most preferred subset repairs ac-
cording to the priority relation. The complexity of reason-
ing with these three kinds of optimal repair has been inves-
tigated, primarily focusing on databases with FDs (Fagin,
Kimelfeld, and Kolaitis 2015; Kimelfeld, Livshits, and Pe-
terfreund 2017; Livshits and Kimelfeld 2017), but also in the
context of description logic knowledge bases (Bienvenu and
Bourgaux 2020). A recent system implements SAT-based al-
gorithms for optimal repair-based semantics having (co)NP-
complete data complexity (Bienvenu and Bourgaux 2022).

To the best of our knowledge, there has been no work ad-
dressing how to define fact-level preferences for databases
with universal constraints and how to exploit such prefer-
ences to single out the optimal symmetric difference repairs.
Our first contribution is thus an extension of the framework

of prioritized databases to the case of universal constraints
and symmetric difference repairs. By carefully defining
a suitable notion of conflict (which may involve negative
facts), we are able to faithfully lift existing notions of op-
timal repairs and optimal repair-based semantics, while re-
taining many properties of the original framework.

We next study the computational properties of optimal
repairs of prioritized databases with universal constraints.
We provide an almost-complete picture of the data com-
plexity of repair checking and inconsistency-tolerant query
answering for each of the three notions of optimal repair
(Pareto, global, and completion) and three repair-based se-
mantics (CQA, brave, and intersection). Our results show
that adopting optimal repairs does not increase the complex-
ity of inconsistency-tolerant query answering.

Our third contribution is to establish connections with
active integrity constraints (AICs), a framework in which
universal constraints are enriched with information on what
are the allowed update actions (fact deletions or additions)
to resolve a given constraint violation (Flesca, Greco, and
Zumpano 2004; Caroprese et al. 2006; Caroprese, Greco,
and Zumpano 2009). More precisely, we provide a natural
translation from prioritized databases to AICs and observe
that Pareto-optimal repairs coincide with three kinds of re-
pairs (founded, grounded and justified) that have been de-
fined for AICs. This leads us to explore more general con-
ditions under which AIC repair notions coincide, which we
subsequently exploit to exhibit a translation of certain ‘well-
behaved’ sets of AICs into prioritized databases.

Proofs can be found in (Bienvenu and Bourgaux 2023).

2 Preliminaries
We assume familiarity with propositional and first-order
logic (FOL) and provide here terminology and notation for
databases, conjunctive queries, constraints, and repairs.

Relational databases Let C and V be two disjoint count-
ably infinite sets of constants and variables respectively. A
(relational) schema S is a finite set of relation names (or
predicates), each with an associated arity n > 0. A fact over
S is an expression of the form P (c1, . . . , cn) where P ∈ S
has arity n and c1, . . . , cn ∈ C. A database (instance) over
S is a finite set D of facts over S. The active domain of D,
denoted dom(D), is the set of constants occurring in D.

A database D can also be viewed as a finite relational
structure whose domain is dom(D) and which interprets
each predicate P ∈ S as the set {c | P (c) ∈ D}. We
shall use the standard notation D |= Φ to indicate that a (set
of) FOL sentence(s) Φ is satisfied in this structure.

Conjunctive queries A conjunctive query (CQ) is a con-
junction of relational atoms P (t1, . . . , tn) (with each ti ∈
V ∪ C), where some variables may be existentially quan-
tified. A Boolean CQ (BCQ) has no free variables. Given
a query q(x), with free variables x = (x1, . . . , xk), and a
tuple of constants a = (a1, . . . , ak), q(a) denotes the BCQ
obtained by replacing each variable in x by the correspond-
ing constant in a. An answer to q(x) over a database D is a
tuple of constants a from dom(D) such that D |= q(a).

Constraints A universal constraint over a schema S is
a FOL sentence of the form ∀x(R1(t1) ∧ · · · ∧ Rn(tn) ∧
¬P1(u1) ∧ · · · ∧ ¬Pm(um) ∧ ε → ⊥), where each Ri(ti)
(resp. Pi(ui)) is a relational atom over S, ε is a (possibly
empty) conjunction of inequality atoms, and u1∪· · ·∪um ⊆
t1 ∪ · · · ∪ tn (safety condition). Universal constraints can
also be written in the form ∀x(R1(t1) ∧ · · · ∧ Rn(tn) ∧ ε →
P1(u1) ∨ · · · ∨ Pm(um)). For simplicity, we shall often
omit the universal quantification and will sometimes use the
generic term constraint to mean universal constraint.

Denial constraints are universal constraints of the form
∀x(R1(t1) ∧ · · · ∧ Rn(tn) ∧ ε → ⊥), which capture the
well-known class of functional dependencies.

We say that a database D is consistent w.r.t. a set of con-
straints C if D |= C. Otherwise, D is inconsistent (w.r.t. C).
A constraint is ground if it contains no variables. Given a
constraint τ and database D, we use grD(τ ) for the set of all
ground constraints obtained by (i) replacing variables with
constants from dom(D), (ii) removing all true c ̸= d atoms,
and (iii) removing all constraints that contain an atom c ̸= c.
We let grD(C) := (cid:83)
τ ∈C grD(τ ), and note that D |= τ iff
D |= τg for every τg ∈ grD(τ ).

Repairs A symmetric difference repair, or ∆-repair, of D
w.r.t. C is a database R such that (i) R |= C and (ii) there
|= C and R′∆D ⊊ R∆D, where
is no R′ such that R′
∆ is the symmetric difference operator: S1∆S2 = (S1 \
S2) ∪ (S2 \ S1).
If only fact deletions are permitted, we
obtain subset repairs (⊆-repairs), and if only fact additions
are permitted, superset repairs (⊇-repairs). We denote the
set of ∆-repairs of D w.r.t. C by SRep(D, C).

Because of the safety condition, an empty database satis-
fies any set of universal constraints, so every database has at
least one ⊆-repair (which is also a ∆-repair), while it may be
the case that no ⊇-repair exists. Moreover, for the subclass
of denial constraints, ∆-repairs and ⊆-repairs coincide since
adding facts cannot resolve a violation of a denial constraint.

3 Optimal Repairs for Universal Constraints
In this section, we show how existing notions of optimal re-
pairs, defined for ⊆-repairs w.r.t. denial constraints, can be
lifted to the broader setting of ∆-repairs w.r.t. universal con-
straints. We then use the resulting repair notions to define
inconsistency-tolerant semantics for query answering.

3.1 Conflicts for Universal Constraints
In the setting of denial constraints, a conflict is a minimal
subset of the database that is inconsistent w.r.t. the con-
straints. Conflicts and the associated notion of conflict (hy-
per)graph underpin many results and algorithms for consis-
tent query answering, and in particular, they appear in the
definition of prioritized databases (Staworko, Chomicki, and
Marcinkowski 2012). Our first task will thus be to define a
suitable notion of conflict for universal constraints.

An important observation is that the absence of a fact may
contribute to the violation of a universal constraint. For this
reason, conflicts will contain both facts and negated facts,
where ¬P (c) indicates that P (c) is absent. We use Facts S
D
for the set of facts over S with constants from dom(D), and

D = D ∪ {¬α | α ∈ Facts S

let Lits S
D \ D} be the set of
literals of D. Conflicts can then be defined as minimal sets
of literals that necessarily lead to a constraint violation.
Definition 1. Given a database D and set of (universal)
constraints C, the set Conf (D, C) of conflicts of D w.r.t. C
contains all ⊆-minimal sets E ⊆ Lits S
D such that for every
database I, if I |= E, then I ̸|= C.
Example 1. Let D = {A(a), B(a)} and C = {τ1, τ2, τ3},
where τ1 := A(x) → C(x), τ2 := B(x) → D(x), and
τ3 := C(x) ∧ D(x) → ⊥. It can be verified that

SRep(D, C) = {∅, {A(a), C(a)}, {B(a), D(a)}}

and that the set Conf (D, C) is as follows:

{{A(a), ¬C(a)}, {B(a), ¬D(a)}, {A(a), B(a)}}

The first (resp. second) conflict directly violates τ1 (resp.
τ2). To see why {A(a), B(a)} is also a conflict, consider
any database I such that {A(a), B(a)} ⊆ I. Then either
C(a) /∈ I or D(a) /∈ I, in which case I violates τ1 or τ2,
or I contains both C(a) and D(a), hence violates τ3.

We also provide two alternative characterizations of con-
flicts, in terms of the hitting sets of literals removed from
∆-repairs and the prime implicants1 of the propositional for-
mula stating that there is a constraint violation (treating the
elements of Lits S
D as propositional literals):
Proposition 1. For every database D and constraint set C:
1. Conf (D, C) = {H ∩ D ∪ {¬α | α ∈ H \ D} | H ∈
MHS (D, C)} where MHS (D, C) is the set of all minimal
hitting sets of {R∆D | R ∈ SRep(D, C)}.
2. Conf (D, C) = {{λ1, . . . , λk} ⊆ Lits S

φ→⊥∈grD(C) φ}.

λk is a prime implicant of (cid:87)
We can show that our notion of conflicts enjoy similar
properties to conflicts w.r.t. denial constraints, but to formu-
late them, we must first introduce some useful terminology
and notation for moving between databases and sets of liter-
als.

D | λ1 ∧ . . . ∧

Given a database D over schema S, a candidate repair for
D is a database B with B ⊆ Facts S
D. For every candidate
repair B for D, we define its corresponding set of literals
Lits D(B) = B ∪ {¬α | α ∈ Facts S
D \ B} and the set of lit-
erals Int D(B) = Lits D(B) ∩ Lits S
D = (B ∩ D) ∪ {¬α | α ∈
Facts S
D \(B ∪D)} upon which B and D agree. Furthermore,
with every subset B ⊆ Lits S
D we can associate a candidate
repair Dat D(B) = B ∩ D ∪ {α | ¬α ∈ Lits S
D \ B}. Note
that if B is a candidate repair, Dat D(Int D(B)) = B.
Proposition 2. Let D be a database, C a set of universal
constraints, and R a candidate repair for D.
1. R ∈ SRep(D, C) iff Int D(R) is a maximal subset of
D such that Dat D(Int D(R)) |= C, i.e., R |= C.
2. R ∈ SRep(D, C) iff Int D(R) is a maximal subset of
D such that E ̸⊆ Int D(R) for every E ∈ Conf (D, C).

Lits S

Lits S

3. R ∈ SRep(D, C) iff Int D(R) ∩ ((cid:83)

E∈Conf (D,C) E) is a
maximal independent set (MIS) of the conflict hypergraph
D, whose vertices are the literals from (cid:83)
GC
E∈Conf (D,C) E
and whose hyperedges are the conflicts of D w.r.t. C.

The first property states that ∆-repairs correspond to the
consistent databases that preserve a maximal set of the orig-
inal literals, while the second rephrases consistency in terms
of conflicts. The third generalizes a well-known hypergraph-
based characterization of ⊆-repairs. As the next remark ex-
plains, an earlier attempt at defining conflicts for universal
constraints failed to obtain such a property.

Remark 1. Staworko and Chomicki (2010) define a con-
flict as a set of literals obtained by grounding a univer-
sal constraint, and the hyperedges of their extended con-
flict hypergraph ECG(D, C) are either conflicts or ‘rele-
vant’ pairs of literals {α, ¬α}. For instance, if we take
D and C as in Example 1,
then ECG(D, C) has hy-
peredges {A(a), ¬C(a)}, {B(a), ¬D(a)}, {C(a), D(a)},
{C(a), ¬C(a)} and {D(a), ¬D(a)}.

Every repair gives rise to a MIS of ECG(D, C), but a
MIS need not correspond to any repair. Proposition 4 in
(Staworko and Chomicki 2010) claims a weaker converse:
for every MIS M of ECG(D, C), either its positive projec-
tion M + = M ∩ Facts S
D is a ∆-repair of D w.r.t. C, or
there exists a MIS N of ECG(D, C) such that N +∆D ⊊
M +∆D. However, our example disproves this claim, as
M = {A(a), B(a), C(a)} is a MIS of ECG(D, C), but
M + = M is not a ∆-repair (it violates τ2), and there is
no MIS N with N +∆D ⊊ M +∆D. Essentially, the prob-
lem is that their notion of conflicts does not take into account
implicit constraints (A(x) ∧ B(x) → ⊥ in this example).

To clarify the relationship between the universal and de-
nial constraint settings, we translate the former into the lat-
ter. Take a database D and set of universal constraints C over
schema S. To represent negative literals, we introduce an ex-
tended schema S′ = S ∪ { (cid:101)P | P ∈ S} and a function facts
that maps sets of literals over S into sets of facts over S′
by replacing each negative literal ¬P (c) by (cid:101)P (c). We then
consider the database Dd = facts(Lits S
D) = D ∪ { (cid:101)P (c) |
P (c) ∈ Facts S
D \ D}, and the set of ground denial con-
straints Cd,D = {((cid:86)
α∈facts(E) α) → ⊥ | E ∈ Conf (D, C)}.
Proposition 3. For every database D and constraint set C:
Conf (Dd, Cd,D) = {facts(E) | E ∈ Conf (D, C)} and
SRep(Dd, Cd,D) = {facts(Int D(R)) | R ∈ SRep(D, C)}.

One may naturally wonder whether a set of denial con-
straints Cd which does not depend on D could be used in
place of Cd,D in Proposition 3. The answer is no: the ex-
istence of such a set Cd would imply a data-independent
bound on the size of conflicts that may appear in any set
Conf (Dd, Cd), and hence in Conf (D, C). However, as the
next example illustrates, universal constraints differ from de-
nial constraints in that the size of the conflicts cannot be
bounded independently from the database.

1We recall that a prime implicant of a propositional formula ψ
is a minimal conjunction of propositional literals κ that entails ψ.

Example 2. Let C consist of R(x, y) ∧ A(x) → A(y) and
A(x) ∧ B(x) → ⊥. Then for every n ≥ 1, we can build

a database {A(a0), R(a0, a1), . . . , R(an−1, an), B(an)} of
size n + 2 which is a conflict (of itself) w.r.t. C.

3.2 Prioritized Databases & Optimal Repairs
With the definition of conflicts in place, we can extend the
notion of prioritized database (Staworko, Chomicki, and
Marcinkowski 2012) to the setting of universal constraints.

Definition 2. A priority relation ≻ for a database D w.r.t. a
set of universal constraints C is an acyclic binary relation
over the literals of Conf (D, C) such that if λ ≻ µ, then
there exists E ∈ Conf (D, C) such that {λ, µ} ⊆ E. We say
that ≻ is total if for every pair λ ̸= µ such that {λ, µ} ⊆ E
for some E ∈ Conf (D, C), either λ ≻ µ or µ ≻ λ. A
completion of ≻ is a total priority relation ≻′ ⊇ ≻.

A priority relation ≻ is score-structured if there is a scor-
E∈Conf (D,C) E → N such that for every

ing function s : (cid:83)
{λ, µ} ⊆ E with E ∈ Conf (D, C), λ ≻ µ iff s(λ) > s(µ).
Definition 3. A prioritized database DC
≻ = (D, C, ≻) con-
sists of a database D, a set of universal constraints C, and a
priority relation ≻ for D w.r.t. C.

We now extend the definitions of optimal repairs to the

case of universal constraints.
Definition 4. Consider a prioritized database DC
(D, C, ≻), and let R ∈ SRep(D, C).

≻ =

• A Pareto improvement of R is a database B consistent
w.r.t. C such that there is µ ∈ Int D(B) \ Int D(R) with
µ ≻ λ for every λ ∈ Int D(R) \ Int D(B).

• A global improvement of R is a database B consistent
w.r.t. C such that Int D(B) ̸= Int D(R) and for every λ ∈
Int D(R) \ Int D(B), there exists µ ∈ Int D(B) \ Int D(R)
such that µ ≻ λ.

We say that R is:

• Pareto-optimal if there is no Pareto improvement of R.
• globally-optimal if there is no global improvement of R.
• completion-optimal if R is a globally-optimal ∆-repair

of DC

≻′, for some completion ≻′ of ≻.

We denote by GRep(DC
≻), PRep(DC
≻) the
sets of globally-, Pareto- and completion-optimal ∆-repairs.

≻) and CRep(DC

≻) ⊆ PRep(DC

≻) ⊆ GRep(DC

≻) ⊆ PRep(DC

A Pareto improvement is also a global improvement,
so GRep(DC
≻), and a global improvement
w.r.t. ≻ is a global improvement w.r.t. any completion ≻′ of
≻, so CRep(DC
≻). Hence, as in the denial
constraints case, CRep(DC
≻) ⊆ GRep(DC
≻).
Moreover,
there always exists at least one completion-
(hence Pareto- and globally-)optimal ∆-repair, which can be
obtained from GC
D by the following greedy procedure: while
some literal from Lits S
D has not been considered, pick a lit-
eral that is maximal w.r.t. ≻ among those not yet considered,
and add it to the current set if it does not introduce a conflict
from Conf (D, C). If B is a subset of Lits S
D obtained by this
procedure, we show that Dat D(B) ∈ CRep(DC
≻). This pro-
cedure requires us to compute Conf (D, C), hence does not
run in polynomial time (unlike the denial constraint case).
However, as for denial constraints, we have:

≻)| = 1.
≻) = PRep(DC

Proposition 4. If ≻ is total, then |PRep(DC
In particular, this means GRep(DC
≻) when
≻ is total, so we may replace globally-optimal by Pareto-
optimal in the definition of completion-optimal ∆-repairs.
Example 3. Let D = {S(a, b), S(a, c), R(d, b), R(d, c)},
where R(d, b) ≻ S(a, b), S(a, b) ≻ ¬A(a), S(a, c) ≻
R(d, c), S(a, c) ≻ ¬B(a), and C contains the constraints:

S(x, y) ∧ S(x, z) ∧ y ̸= z → ⊥
S(x, y) → A(x)
R(x, y) ∧ R(x, z) ∧ y ̸= z → ⊥ S(x, y) → B(x)
R(y, x) ∧ S(z, x) → ⊥

The conflicts are all binary, so the conflict hypergraph is a
graph, pictured below. We use an arrow λ → µ when λ ≻ µ
and dotted lines for conflicting literals with no priority.

R(d, b)

S(a, b)

¬A(a)

R(d, c)

S(a, c)

¬B(a)

It can be verified that the optimal repairs are as follows:

CRep(DC
GRep(DC
PRep(DC

≻) ={{R(d, b), S(a, c), A(a), B(a)}}
≻) =CRep(DC
≻) =GRep(DC

≻) ∪ {{R(d, b)}}
≻) ∪ {{R(d, c)},

{R(d, c), S(a, b), A(a), B(a)}}

and that SRep(D, C) = PRep(DC

≻).

When ≻ is score-structured with scoring function s, we
define the prioritization of (cid:83)
E∈Conf (D,C) E as the partition
S1, . . . , Sn such that for every 1 ≤ i ≤ n, there exists m ∈
N such that Si = {λ | s(λ) = m}, and for every {λi, λj} ⊆
E ∈ Conf (D, C), λi ≻ λj iff λi ∈ Si, λj ∈ Sj and i < j.
Intuitively, the more reliable a literal λ the smaller the index
of Si that contains λ. Bienvenu, Bourgaux, and Goasdou´e
(2014) introduced a notion of ⊆P -repair based upon such
prioritizations, which we adapt below to ∆-repairs.
Definition 5. Let DC
≻ be a prioritized database such that
≻ is score-structured and S1, . . . , Sn is the prioritization of
(cid:83)
≻ is a candidate repair
R such that (i) R |= C and (ii) there is no R′ |= C such that
there is some 1 ≤ i ≤ n such that
• Int D(R) ∩ Si ⊊ Int D(R′) ∩ Si and
• for all 1 ≤ j < i, Int D(R) ∩ Sj = Int D(R′) ∩ Sj.
≻) the set of ∆P -repairs of DC
We denote by LRep(DC
≻.

E∈Conf (D,C) E. A ∆P -repair of DC

As in the case of denial constraints, all four notions of

optimal ∆-repairs coincide when ≻ is score-structured.
Proposition 5. If ≻ is score-structured, then CRep(DC
GRep(DC

≻) = LRep(DC
We can now define variants of existing inconsistency-

≻) = PRep(DC

≻) =

≻).

tolerant semantics based upon our optimal repairs.
Definition 6. Fix X ∈ {S, P, G, C} and consider a priori-
tized database DC
≻, query q(x), and tuple of constants a with
|x| = |a|. Then a is an answer to q(x) over DC
≻

• under X-brave semantics, denoted DC
R |= q(a) for some R ∈ XRep(DC
• under X-CQA semantics, denoted DC
R |= q(a) for every R ∈ XRep(DC

≻);

≻);

≻ |=X

brave q(a), if

≻ |=X

CQA q(a), if

• under X-intersection semantics, denoted DC

≻ |=X

∩ q(a), if

B |= q(a) where B = (cid:84)

R∈XRep(DC

≻) R.

Just as in the case of denial constraints, these semantics

are related as follows:

DC

≻ |=X

∩ q(a) ⇒ DC

≻ |=X

CQA q(a) ⇒ DC

≻ |=X

brave q(a)

R∈PRep(DC

Unlike the denial constraint case, the intersection of the op-
timal ∆-repairs may be inconsistent w.r.t. C. For example, if
D = {A(a)}, C = {A(x) → B(x)∨C(x)}, A(a) ≻ ¬B(a)
and A(a) ≻ ¬C(a), then (cid:84)
≻) R = {A(a)} vio-
lates the constraint. This is not a problem since we consider
conjunctive queries, which are monotone, meaning that if
the intersection of the optimal ∆-repairs yields a query an-
swer, then the tuple is an answer in every optimal ∆-repair.
Example 4 (Example 3 cont’d). Considering the different
semantics based upon Pareto-optimal repairs:
• DC
• DC
If we consider now CQA semantics for the different kinds of
optimal repairs, we find that:
• DC
• DC

brave A(a) but DC
≻ ̸|=P
CQA ∃yR(d, y) but DC

CQA A(a) but DC
CQA R(d, b) but DC

CQA A(a);
≻ ̸|=P

≻ |=C
≻ |=G

≻ |=P
≻ |=P

∩ ∃yR(d, y).

CQA R(d, b).

CQA A(a);

≻ ̸|=G

≻ ̸|=P

4 Complexity Analysis
In this section, we analyze the data complexity of the central
computational tasks related to optimal repairs. We consider
the following decision problems:
• X-repair checking: given a prioritized database DC
candidate repair R, decide whether R ∈ XRep(DC

≻ and a
≻);

itized database DC
decide whether DC

• Query answering under X-Sem semantics: given a prior-
≻, a query q, and a candidate answer a,
≻ |=X

Sem q(a);
where X ∈ {S, P, G, C} and Sem ∈ {brave, CQA, ∩}. We
focus on data complexity, which is measured in terms of the
size of the database D, treating the constraints C and query
q as fixed and of constant size (under the latter assumption,
R and a are of polynomial size w.r.t. D). Table 1 summa-
rizes our new results for optimal repairs w.r.t. universal con-
straints alongside existing results for denial constraints.

Staworko and Chomicki (2010) showed that S-repair
checking is coNP-complete in data complexity. We show
that the same holds for Pareto- and globally-optimal repairs:
Theorem 1. X-repair checking is coNP-complete in data
complexity for X ∈ {P, G}.

Proof Sketch. The lower bound is inherited from ∆-repairs.
For the upper bounds, we sketch NP procedures for check-
ing whether R ̸∈ XRep(DC
≻) for a given candidate repair R.
In a nutshell, we guess either (i) ‘inconsistent’, (ii) ‘not

S

P

C

G

. RC
v
i
n
U

l RC
a
i
n
e
D

coNP coNP coNP-h, in Σp
Σp
BRAVE
2
CQA, INT Πp
2
in P
NP

Σp
2
Πp
2
in P
BRAVE
NP
CQA, INT coNP coNP

Σp
2
Πp
2
in P
NP
coNP

2 coNP
Σp
2
Πp
2
coNP
Σp
2
Πp
2

Table 1: Data complexity of X-repair checking (RC) and query
answering under X-brave (BRAVE), X-CQA, and X-intersection
(INT) semantics (X ∈ {S, P, G, C}) w.r.t. universal or denial con-
straints. Completeness results except where indicated otherwise.

maximal’ together with another candidate repair R′, or (iii)
‘improvement’ together with a candidate (Pareto or global)
improvement B. In case (i), it suffices to verify in P that
R ̸|= C, returning yes if so. In case (ii), we test in P whether
R′∆D ⊊ R∆D and R′ |= C, returning yes if both condi-
tions hold. In case (iii), we check in P whether B is indeed a
(Pareto / global) improvement of R, returning yes if so.

Interestingly, we observe that P-repair checking is hard

even if we already know the input is a ∆-repair:
Lemma 1. Deciding whether a given ∆-repair is Pareto-
optimal is coNP-complete in data complexity.

We next turn to C-repair checking. A first idea would be
to guess a completion ≻′ and check (using an NP oracle)
that the input database is Pareto-optimal w.r.t. ≻′. However,
determining whether the guessed binary relation is a com-
pletion is not straightforward, as we must make sure that
we relate all and only those literals that appear together in
some conflict. As the following result shows, even identify-
ing conflicts is a challenging task for universal contraints:
Lemma 2. Deciding whether a set of literals belongs to
Conf (D, C) is BH2-complete w.r.t. data complexity.

With a more careful approach, we can show that C-repair
checking does belong to Σp
2. The exact complexity is open.
Theorem 2. C-repair checking is coNP-hard and in Σp
2
w.r.t. data complexity.

Proof Sketch. We use a non-deterministic version of the
greedy procedure sketched in Section 3.2: to decide if R ∈
≻), we guess the order in which literals of Lits S
CRep(DC
D
will be considered, and for each λ ∈ Lits S
D \ Int D(R), we
guess a set of literals L ⊆ Int D(R) that precede λ in the
order and such that L ∪ {λ} forms a conflict.

Leveraging our results for repair checking, we can estab-
lish the precise data complexity of query answering for all
combinations of semantics and optimality notions:
Theorem 3. Query answering under X-brave (resp. X-CQA
2-complete (resp. Πp
and X-intersection) semantics is Σp
2-
complete) in data complexity, for X ∈ {P, G, C}.

The lower bounds that are higher for universal constraints
than denial constraints involve databases whose conflicts are
difficult to compute. This is no coincidence, as we show that
if the set of conflicts are available, the complexity drops:

Theorem 4. If Conf (D, C) is given and considered as part
of the input, then all complexity results for denial constraints
listed in Table 1 hold also for universal constraints.

The lower complexities apply in particular to sets of con-
straints whose conflicts have bounded size, such as universal
constraints with at most two relational atoms. Unfortunately,
we show that it is impossible in general to determine whether
a given set of constraints has bounded conflicts:

Theorem 5. Given a set of universal constraints C, it is un-
decidable to determine whether there exists k ∈ N such that
for every database D, maxE∈Conf (D,C)(|E|) ≤ k.

5 Links with Active Integrity Constraints

Active integrity constraints define which update operations
are allowed to solve a constraint violation (Flesca, Greco,
and Zumpano 2004; Caroprese et al. 2006; Caroprese,
Greco, and Zumpano 2009), in the same spririt that prior-
itized databases express preferred ways of solving conflicts.
This section investigates how these two frameworks relate.

5.1 Preliminaries on Active Integrity Constraints

We briefly recall the basics of active integrity constraints,
directing readers to (Bogaerts and Cruz-Filipe 2018) for a
good overview of the area.

Update actions An update atom is of the form +P (x)
or −P (x) where P (x) is a relational atom. We use fix to
map relational literals to the corresponding update atoms:
fix (P (x)) = −P (x) and fix (¬P (x)) = +P (x). An up-
date action is a ground update atom, i.e., is of the form −α
or +α with α a fact. A set of update actions U is consistent
if U does not contain both −α and +α for some fact α. The
result of applying a consistent set of update actions U on a
database D is D ◦ U := D \ {α | −α ∈ U} ∪ {α | +α ∈ U}.

Active integrity constraints An active integrity con-
straint (AIC) takes the form r = ℓ1 ∧ · · · ∧ ℓn →
{A1, . . . , Ak}, where body(r) = ℓ1 ∧ · · · ∧ ℓn is such that
τr := body(r) → ⊥ is a universal constraint, upd(r) =
{A1, . . . , Ak} is non-empty, and every Aj is equal to fix (ℓi)
for some ℓi. We use lits(r) for the set of literals appear-
ing in body(r), and say that ℓ ∈ lits(r) is non-updatable if
fix (ℓ) ̸∈ upd(r). A database D satisfies r, denoted D |= r,
if it satisfies τr. It satisfies a set of AICs η, denoted D |= η,
if D |= r for every r ∈ η. A set of AICs is consistent if there
exists a database D such that D |= η.

A ground AIC is an AIC that contains no variables. The
set grD(r) contains all ground AICs obtained from r by (i)
replacing variables by constants from dom(D), (ii) remov-
ing all true c ̸= d atoms, and (iii) removing all ground AICs
with an atom c ̸= c. We let grD(η) := (cid:83)
r∈η grD(r), and
observe that D |= r iff D |= rg for every rg ∈ grD(r).

An AIC is called normal if |upd(r)| = 1. The normal-
ization of an AIC r is the set of AICs N (r) = {body(r) →
{A} | A ∈ upd(r)}. The normalization of a set of AICs η is
N (η) = (cid:83)
r∈η N (r). Note that grD(N (η)) = N (grD(η)).

Repair updates A repair update (r-update)2 of a database
D w.r.t. a set of AICs η is a consistent subset-minimal set of
update actions U such that D ◦ U |= η. We denote the set of
r-updates of D w.r.t. η by Up(D, η). It is easy to check that
{D ◦ U | U ∈ Up(D, η)} = SRep(D, Cη) where Cη is the
set of universal constraints that correspond to AICs in η.

To take into account the restrictions on the possible update
actions expressed by the AICs, several classes of r-updates
have been defined. The first one, founded r-updates (Caro-
prese et al. 2006), was criticized for exhibiting circularity
of support, leading to the introduction of more restrictive
justified (Caroprese and Truszczynski 2011), well-founded
(Cruz-Filipe et al. 2013), and grounded r-updates (Cruz-
Filipe 2016). The latter were motivated by arguably un-
expected behaviors of justified and well-founded r-updates.
In particular, justified r-updates are criticized for being too
complicated and for excluding some r-updates that seem rea-
sonable. Moreover, they are sensitive to normalization, un-
like founded, well-founded and grounded r-updates.
Definition 7. An r-update U of D w.r.t. η is:
• founded if for every A ∈ U, there exists r ∈ grD(η) such

that A ∈ upd(r) and D ◦ U \ {A} ̸|= r.

• well-founded if

there exists a sequence of actions
A1, . . . , An such that U = {A1, . . . , An}, and for ev-
ery 1 ≤ i ≤ n, there exists ri ∈ grD(η) such that
Ai ∈ upd(ri) and D ◦ {A1, . . . , Ai−1} ̸|= ri.

• grounded if for every V ⊊ U, there exists r ∈ grD(N (η))

such that D ◦ V ̸|= r and upd(r) ⊆ U \ V.

• justified if ne(D, D ◦ U) ∪ U is a minimal set of update
actions closed under η that contains ne(D, D ◦ U) where
– ne(D, D ◦ U) = {+α | α ∈ D ∩ (D ◦ U)} ∪ {−α | α /∈

D ∪ (D ◦ U), α ∈ Facts S

D} (set of no-effect actions)

– U is closed under η if for every r ∈ grD(η), if U satis-
fies all the non-updatable literals of r, then U contains
an update action from r.

We denote by FoundUp(D, η), WellFoundUp(D, η),
GroundUp(D, η) and JustUp(D, η) respectively the sets of
founded, well-founded, grounded and justified r-updates of
D w.r.t. η and let XRep(D, η) = {D ◦ U | U ∈ XUp(D, η)}
be the set of corresponding repairs.

Calautti et al. (2021) recently redefined founded r-
updates. In fact, we show that their definition coincides with
grounded r-updates, yielding the following characterization.
Proposition 6. For every U ∈ Up(D, η), U is grounded iff
U ∈ Up(D, η[U]), where η[U] is the set of AICs obtained
from grD(η) by deleting update actions not occurring in U
and AICs whose update actions have all been deleted.

The relationships between the various kinds of repairs
are represented below, where a plain arrow from X to Y
means X ⊆ Y and the dotted arrow represents an inclu-
sion that only holds when η is a set of normal AICs. All
inclusions may be strict (Caroprese and Truszczynski 2011;
Cruz-Filipe et al. 2013; Cruz-Filipe 2016).

2Repair updates are usually called repairs in the AIC literature,

we use this term to avoid confusion with the other repair notions.

GroundRep(D, η)

FoundRep(D, η)

JustRep(D, η)

WellFoundRep(D, η)

5.2 From Prioritized Databases to AICs
Given a prioritized database DC
of ground AICs: ηC

≻ = {rE | E ∈ Conf (D, C)} where

≻ we define the following set

(cid:94)

rE :=

λ → {fix (λ) | λ ∈ E, ∀µ ∈ E, λ ̸≻ µ}.

λ∈E
≻ expresses that conflicts of DC
Intuitively, ηC
by modifying the least preferred literals according to ≻.

≻ should be fixed

We can prove that Pareto-optimal repairs of DC

≻ coincide

≻) = JustRep(D, ηC

≻) = GroundRep(D, ηC

with several kinds of repairs of D w.r.t. ηC
≻.
Proposition 7. For every prioritized database DC
≻,
PRep(DC
≻) =
FoundRep(D, ηC

≻) ⊆ WellFoundRep(D, ηC
This result is interesting not only because it provides addi-
tional evidence for the naturalness of Pareto-optimal repairs,
but also because it identifies a class of AICs for which jus-
tified, grounded, and founded r-updates coincide. The proof
in fact shows that these three notions coincide for every set
of ground AICs η that is monotone, i.e. does not contain
both a fact α and the complementary literal ¬α.

≻).

≻ where D = {α, β, γ, δ} and ηC

We remark that the final inclusion in Proposition 7 may
be strict. This is demonstrated on the next example, which
suggests that well-founded repairs may be too permissive:
Example 5. It is possible to construct a prioritized database
DC
≻ = {α∧β → {−β}, α∧
γ → {−α}, γ ∧ δ → {−γ}}. For the AICs ηC
≻, the r-update
{−α, −γ} is well-founded, but not founded, as the only
founded r-update is {−β, −γ}. We argue that {−β, −γ}
should indeed be preferred to {−α, −γ}, since the first AIC
expresses that it is better to remove β than α.

The reduction used to show Proposition 7 is data-
dependent and requires us to create potentially exponentially
many ground AICs, one for every conflict. In the case of
denial constraints, however, we can give an alternative data-
independent reduction, provided that the priority relation ≻
is specified in the database. We thus assume for the next
result that P≻ is a predicate in S, that the first attribute of
each relation in S \ {P≻} stores a unique fact identifier, and
P≻ stores pairs of such identifiers. Then given a set of de-
nial constraints C over S \ {P≻}, we build a set min(C)
that is equivalent to C but has the property that the conflicts
of D w.r.t. C are precisely the images of constraint bodies
of min(C) on D. This can be achieved by replacing each
φ → ⊥ ∈ C with all refinements obtaining by (dis)equating
variables in φ with each other, or with constants mentioned
in C, then removing any subsumed constraints. For example,
if C = {R(x, x) → ⊥, R(x, y) ∧ S(y) → ⊥}, then min(C)
contains R(x, x) → ⊥ and R(x, y) ∧ S(y) ∧ x ̸= y → ⊥, so
{R(a, a), S(a)} is no longer an image of a constraint body.
We then define ηC as the set of all AICs

(cid:0)ℓ1 ∧ . . . ∧ ℓn ∧ ε ∧

(cid:94)

ℓj ̸=ℓi

¬P≻(idi, idj)(cid:1) → {−ℓi}.

such that ℓ1 ∧ . . . ∧ ℓn ∧ ε → ⊥ ∈ min(C), i ∈ {1, . . . , n},
and for every 1 ≤ k ≤ n, ℓk = R(idk, t) for some R, t.
Proposition 8. For every set of denial constraints C,
database D and priority relation ≻ of D w.r.t. C,
PRep(DC
≻) = JustRep(D, ηC) = GroundRep(D, ηC) =
FoundRep(D, ηC) ⊆ WellFoundRep(D, ηC).

This reduction could be used for example to transfer data
complexity lower bounds for prioritized databases with de-
nial constraints to the setting of AICs.

5.3 Towards Well-Behaved AICs
When translating a prioritized database into AICs, we ob-
tained monotone sets of AICs, for which most of the differ-
ent kinds of r-update coincide. Can we generalize this idea
to obtain larger classes of ‘well-behaved’ sets of AICs which
share this desirable behavior? This subsection explores this
question and provides some first insights.

We start by defining the following condition, which serves

to ensure that all constraints are made explicit:
Definition 8. We say that a set η of ground AICs is closed
under resolution if it is consistent, and for every pair of
AICs r1, r2 ∈ η, if there exists α ∈ lits(r1) such that
¬α ∈ lits(r2), and lits(r1) ∪ lits(r2) \ {α, ¬α} is a con-
sistent set of literals, then there exists r3 ∈ η with lits(r3) =
lits(r1) ∪ lits(r2) \ {α, ¬α}. A set of AICs η is closed under
resolution if so is grD(η) for every database D.

The name ‘closure under resolution’ comes from con-
sidering the clauses that correspond to the negation of the
if we have AICs whose clauses are ¬α ∨ φ
rule bodies:
and α ∨ ψ, then we should also have an AIC for their
resolvent φ ∨ ψ′, corresponding to the implied constraint
¬φ ∧ ¬ψ → ⊥. This property ensures that η captures
all potential conflicts: for every D, if Cη = {τr | r ∈
η}, then Conf (D, Cη) = {lits(r) | r ∈ grD(η), D ̸|=
r, and there is no r′ ∈ grD(η) with lits(r′) ⊊ lits(r)}.

The following example, given by Bogaerts and Cruz-
Filipe (2018) to show that grounded r-updates do not co-
incide with the intersection of founded and well-founded r-
updates, illustrates that sets of AICs not closed under reso-
lution may exhibit undesirable behaviors.
Example 6. Consider D = ∅ and η that contains the AICs:

r1 : ¬α ∧ ¬β → {+α}
r2 : α ∧ ¬β → {+β}
r3 : ¬α ∧ β → {−β}

r4 : α ∧ β ∧ ¬γ → {+γ}
r5 : α ∧ ¬β ∧ γ → {+β}
r6 : ¬α ∧ β ∧ γ → {+α}

U = {+α, +β, +γ} is founded and well-founded but is not
grounded: taking V = {+β}, we have V ⊊ U but there is
no r ∈ η such that {β} ̸|= r and upd(r) ∩ {+α, +γ} ̸= ∅.

However, it can be verified that U is in fact the only r-
Indeed, the conflicts of D w.r.t. the

update of D w.r.t. η.
constraints expressed by η are {¬α}, {¬β} and {¬γ}.

If η were closed under resolution, it would contain ¬α →
{+α}, ¬β → {+β}, and ¬γ → {+γ}, in which case U
would be grounded, as expected for the unique r-update.

It is always possible to transform a set of ground AICs
into one that is closed under resolution by adding the re-
quired AICs. However this may result in an exponential

blowup. Moreover, we need to choose the update actions
of the added AICs. We advocate for this to be done by prop-
agating the relevant update actions of the rules on which the
resolution is done. A set of ground AICs obtained in this
way will be closed under resolution and will preserve ac-
tions under resolution according to the following definition.
Definition 9. We say that a set η of ground AICs pre-
serves actions under resolution if for every triple of AICs
r1, r2, r3 ∈ η, if there exists α such that α ∈ lits(r1),
¬α ∈ lits(r2), and lits(r3) = lits(r1) ∪ lits(r2) \ {α, ¬α},
then upd(r1) ∪ upd(r2) \ {+α, −α} ⊆ upd(r3). A set of
AICs η preserves actions under resolution if so does grD(η)
for every database D.

The next example shows that a set of AICs which does

not preserve actions under resolution may be ambiguous.
Example 7. Let D = {α, β, γ}, and η that contains:

r1 : α ∧ β → {−α}
r2 : β ∧ γ → {−γ}

r3 : α ∧ ¬δ → {+δ}
r4 : β ∧ δ → {−β}

This set of AICs is closed under resolution but does not pre-
serve actions under resolution: due to r3 and r4, −β should
be an update action of r1. Indeed, r3 and r4 together indi-
cate that if α and β are present, β should be removed (since
if δ is absent, it should be added, due to r3, and β should be
removed when δ is present, by r4).

To make η preserve actions under resolution, there are
three possibilities: (1) change r1 to α ∧ β → {−β} (if α is
preferred to β), or (2) change r4 to β ∧ δ → {−δ} (if β is
preferred to α), or (3) change r1 to α ∧ β → {−α, −β} (if
neither α nor β is preferred to the other).

Sets of AICs that are closed under resolution and preserve
actions under resolution are well behaved in the sense that
they make most of the r-update notions coincide. The mono-
tone sets of AICs mentioned in relation to Proposition 7 triv-
ially satisfy these two conditions.
If η is closed under resolution and
Proposition 9.
preserves actions under
every
database D, JustRep(D, η) = GroundRep(D, η) =
FoundRep(D, η) ⊆ WellFoundRep(D, η).

resolution,

then for

The next example shows that both conditions are neces-

sary for obtaining Proposition 9.
Example 8. Consider D = {α, β, γ} and the two sets

η1 ={α ∧ ¬β → {−α}, ¬α ∧ β → {−β},

α ∧ β ∧ γ → {−γ}}
η2 =η1 ∪ {α ∧ γ → {−γ},

β ∧ γ → {−γ}}.

η1 is not closed under resolution but (trivially) preserves ac-
tions under resolution, while η2 is closed under resolution
but does not preserve actions under resolution.

In both cases, there are two founded r-updates: {−γ} and
{−α, −β}. However, {−α, −β} is not well-founded, hence
not grounded nor justified.
Indeed, D violates only AICs
whose only update action is −γ.

Even if a set of AICs is such that justified, grounded and
founded repairs are guaranteed to exist and coincide, its be-
havior may still be puzzling, as illustrated next.

Example 9. Let D = {α, β, γ, δ} and η be the monotone
set of AICs comprising the following AICs:

r1 : α ∧ δ → {−δ}
r2 : α ∧ β ∧ δ → {−α}

r3 : α ∧ β ∧ γ ∧ δ → {−β}
r4 : β ∧ γ → {−γ}

There are four r-updates:

U1 ={−α, −γ} and U2 = {−δ, −γ} are founded
U3 ={−δ, −β} is not founded but is well-founded
U4 ={−α, −β} is not founded nor well-founded

There are two conflicts: {α, δ} and {β, γ}. It is natural to
prefer removing γ rather than β to resolve the latter conflict
(due to r4), which would justify to preferring U1 and U2 over
U4 and U3 respectively. However, the exact same argument
applied to r1 should lead us to prefer removing δ to solve
the first conflict, thus to prefer U2 over U1. It is therefore
not clear why both U1 and U2 should be the preferred r-
updates. The intention of a user specifying the preceding
AICs is probably quite far from their actual behavior.

We thus believe that a reasonable property for sets of
AICs is to respect the principle that adding atoms to a rule
body can only restrict the possible update actions. We call
the anti-normalization of a set η of AICs the set AN (η) of
AICs that replace all the AICs r1, . . . , rn ∈ η that share the
same body by a single AIC whose update actions are the
union of the update actions of r1, . . . , rn.
Definition 10. We say that a set η of ground AICs preserves
actions under strengthening if for every pair of AICs r1, r2
in AN (η), if lits(r1) ⊆ lits(r2), then upd(r2) ⊆ upd(r1).
A set of AICs η preserves actions under strengthening if so
does grD(η) for every database D.

The following proposition shows that if η preserves ac-
tions under strengthening, then constraints that have non-
minimal bodies have no influence on the r-updates.

Proposition 10. Let η be a set of ground AICs and min(η)
be the set of AICs from AN (η) that have (subset-)minimal
If η preserves actions under strengthening, then
bodies.
for every D,
for X ∈ {Found , WellFound , Ground }
XUp(D, η) = XUp(D, AN (η)) = XUp(D, min(η)), and
JustUp(D, AN (η)) = JustUp(D, min(η)).

5.4 From AICs to Prioritized Databases
We next study the possibility of reducing well-behaved sets
of AICs to prioritized databases and discuss the differences
between the two settings.

Binary conflicts case We first consider the case where the
size of the conflicts is at most two (this covers, for exam-
ple, AIC bodies corresponding to functional dependencies
In this case, given a set η of AICs
or class disjointness).
closed under resolution that preserves actions under resolu-
tion and under strengthening and a database D, we build a
set of constraints Cη and a binary relation ≻η such that if ≻η
is acyclic, the Pareto-optimal repairs of DCη
≻η coincide with
the founded, grounded and justified repairs of D w.r.t. η. We
take Cη = {τr | r ∈ η} and define ≻η so that λ ≻η µ iff

• there exists r ∈ min g(η) such that D ̸|= r, {λ, µ} ⊆

lits(r), and fix (µ) ∈ upd(r); and

• for every r ∈ min g(η) such that D ̸|= r and {λ, µ} ⊆

lits(r), fix (λ) ̸∈ upd(r),

there is no r′ ∈ grD(η)
where min g(η) = {r ∈ grD(η) |
with lits(r′) ⊊ lits(r)}. As η is closed under resolution,
Conf (D, Cη) = {lits(r) | r ∈ min g(η), D ̸|= r}.
Proposition 11. If η is closed under resolution, preserves
actions under resolution and under strengthening, the size of
the conflicts of D w.r.t. η is bounded by 2, and ≻η is acyclic,
then PRep(DCη
≻η ) = JustRep(D, η) = GroundRep(D, η)
= FoundRep(D, η) ⊆ WellFoundRep(D, η).

The following examples show that the three first condi-

tions are necessary.
Example 10. Let D = {α, β, γ} and η = {α ∧ β → {−β},
¬β ∧ γ → {−γ}}, which preserves actions under resolution
and strengthening but is not closed under resolution. We
have Conf (D, Cη) = {{α, β}, {α, γ}} and α ≻η β. Both
{α} and {β, γ} are Pareto-optimal, but the only founded r-
update (which is also grounded and justified) is {−β, −γ}.
Example 11 (Example 7 cont’d). In Example 7, η is closed
under resolution and preserves actions under strengthen-
ing but not under resolution. We have Conf (D, Cη) =
{{α, β}, {β, γ}, {α, ¬δ}} and β ≻η α, β ≻η γ, α ≻η ¬δ.
The only Pareto-optimal repair is {β}, but {−β, +δ} is a
founded, grounded and justified r-update.
Example 12 (Example 9 cont’d). In Example 9, η is closed
under resolution and preserves actions under resolution
but not under strengthening. We have Conf (D, Cη) =
{{α, δ}, {β, γ}} and α ≻η δ, β ≻η γ. The only Pareto-
optimal repair is {α, β}, but {−α, −γ} is a founded,
grounded and justified r-update.

Note that ≻η may be cyclic: if η = {A(x) ∧ B(x) →
{−A(x)}, B(x) ∧ C(x) → {−B(x)}, C(x) ∧ A(x) →
{−C(x)}} and D = {A(a), B(a), C(a)}, we obtain
A(a) ≻η C(a) ≻η B(a) ≻η A(a).

General case Let us now consider the case where the size
of the conflicts is not bounded.
If we apply the same re-
duction, we can only show the following inclusions between
repairs of D w.r.t. η and Pareto-optimal repairs of DCη
≻η :
Proposition 12. If η is closed under resolution, preserves
actions under resolution and under strengthening, and ≻η
is acyclic, then JustRep(D, η) = GroundRep(D, η) =
FoundRep(D, η) ⊆ PRep(DCη

≻η ).
The next example shows that the inclusion may be strict.

Example 13. Let D = {α, β, γ, δ, ϵ} and η consist of:

r1 : α ∧ β ∧ γ → {−β}
r2 : α ∧ β ∧ δ → {−α, −β}

r3 : δ ∧ ϵ → {−δ}

We obtain Conf (D, Cη) = {{α, β, γ}, {α, β, δ}, {δ, ϵ}}
and γ ≻η β, δ ≻η α, δ ≻η β and ϵ ≻η δ (note that α ̸≻η β
because −α is an update action of r2). The repair {β, γ, ϵ}
is Pareto-optimal, but the corresponding r-update {−α, −δ}
is not founded, as −α appears only in r2 and D◦{−δ} |= r2.

One might try to modify the definition of ≻η by dropping
the second condition and adding fix (λ) ̸∈ upd(r) to the first.
In this case, {β, γ, ϵ} is no longer Pareto-optimal. How-
ever, now if we take η′ = η \ {r3}, then {−α} would be
founded, but the corresponding repair {β, γ, δ, ϵ} would not
be Pareto-optimal, violating the inclusion of Proposition 12.

This example shows that even for AICs corresponding to
denial constraints, there is no clear way to define a priority
relation that captures the preferences expressed by the AICs.

6 Conclusion and Future Work
We studied how to incorporate preferences into repair-based
query answering for an expressive setting in which databases
are equipped with universal constraints, and both fact ad-
ditions and deletions are used to restore consistency. We
showed that the existing framework of prioritized databases
could be faithfully adapted to this richer setting, although the
proofs are more involved and crucially rely upon finding the
right definition of what constitutes a conflict. While these re-
sults focus on databases, we expect that they will also prove
useful for exploring symmetric difference repairs in related
KR settings, e.g. ontologies with closed predicates.

Our complexity analysis showed that adopting optimal re-
pairs in place of symmetric difference repairs does not in-
crease the complexity of repair-based query answering. A
major difference between denial and universal constraints
is that the latter may lead to conflicts of unbounded size.
We showed that it is intractable to recognize a conflict and
that several problems drop in complexity if we assume that
the conflicts are available. This suggests the interest of de-
veloping structural conditions on constraint sets that ensure
easy-to-compute conflicts, as well as practical algorithms for
computing and updating the set of conflicts, which could en-
able an integration with existing SAT-based approaches.

Intrigued by the high-level similarities between priori-
tized databases and active integrity constraints, we explored
how the two formalisms relate. We exhibited a natural trans-
lation of prioritized databases into AICs whereby Pareto-
optimal repairs coincide with founded, grounded and justi-
fied repairs w.r.t. the generated set of AICs. We take this
as further evidence that Pareto-optimal repairs are an es-
pecially natural notion (we previously showed that Pareto-
optimal (subset) repairs correspond to stable extensions in
argumentation (Bienvenu and Bourgaux 2020)). It would be
of interest to extend our comparison to other more recent
notions of repair updates for AICs (Feuillade, Herzig, and
Rantsoudis 2019, Bogaerts and Cruz-Filipe 2018; 2021).

Our work also provided new insights into AICs. Existing
examples used to distinguish different notions of r-update
often seem unnatural in some respect. This led us to de-
vise a set of criteria for ‘well-behaved’ AICs, which provide
sufficient conditions for founded, grounded and justified re-
pairs to coincide (Example 5 suggests that well-founded re-
pairs are too permissive). Even for such restricted AICs, it
is not always clear what user intentions are being captured.
We thus believe that there is still work to be done to develop
user-friendly formalisms for expressing constraints and pref-
erences on how to handle constraint violations.

Acknowledgements

This work was supported by the ANR AI Chair INTENDED
(ANR-19-CHIA-0014).

References

2023.

Arenas, M.; Bertossi, L. E.; and Chomicki, J. 1999. Con-
sistent query answers in inconsistent databases. In Proceed-
ings of the 18th ACM SIGMOD-SIGACT-SIGAI Symposium
on Principles of Database Systems (PODS).
Arming, S.; Pichler, R.; and Sallinger, E. 2016. Complexity
of repair checking and consistent query answering. In Pro-
ceedings of the 19th International Conference on Database
Theory (ICDT).
Bertossi, L. E. 2019. Database repairs and consistent query
answering: Origins and further developments. In Proceed-
ings of the 38th ACM SIGMOD-SIGACT-SIGAI Symposium
on Principles of Database Systems, (PODS), 48–58.
Bienvenu, M., and Bourgaux, C. 2020. Querying and repair-
ing inconsistent prioritized knowledge bases: Complexity
analysis and links with abstract argumentation. In Proceed-
ings of the 17th International Conference on Principles of
Knowledge Representation and Reasoning (KR).
Bienvenu, M., and Bourgaux, C. 2022. Querying inconsis-
tent prioritized data with ORBITS: algorithms, implementa-
tion, and experiments. In Proceedings of the 19th Interna-
tional Conference on Principles of Knowledge Representa-
tion and Reasoning (KR).
Bienvenu, M., and Bourgaux, C.
Inconsistency
handling in prioritized databases with universal constraints:
Complexity analysis and links with active integrity con-
straints. arxiv.org/abs/2306.03523 [cs.DB].
Bienvenu, M., and Rosati, R. 2013. Tractable approxi-
mations of consistent query answering for robust ontology-
based data access. In Proceedings of the 23rd International
Joint Conference on Artificial Intelligence (IJCAI).
Bienvenu, M.; Bourgaux, C.; and Goasdou´e, F.
2014.
Querying inconsistent description logic knowledge bases
under preferred repair semantics. In Proceedings of the 28th
AAAI Conference on Artificial Intelligence (AAAI).
Bienvenu, M. 2020. A short survey on inconsistency han-
dling in ontology-mediated query answering. K¨unstliche In-
telligenz 34(4):443–451.
Bogaerts, B., and Cruz-Filipe, L. 2018. Fixpoint semantics
for active integrity constraints. Artif. Intell. 255:43–70.
Bogaerts, B., and Cruz-Filipe, L. 2021. Stratification in
approximation fixpoint theory and its application to active
integrity constraints. ACM Trans. Comput. Log. 22(1):6:1–
6:19.
Calautti, M.; Caroprese, L.; Greco, S.; Molinaro, C.; Trubit-
syna, I.; and Zumpano, E. 2021. Existential active integrity
constraints. Expert Syst. Appl. 168:114297.
Caroprese, L., and Truszczynski, M. 2011. Active integrity
constraints and revision programming. Theory Pract. Log.
Program. 11(6):905–952.

Caroprese, L.; Greco, S.; Sirangelo, C.; and Zumpano, E.
2006. Declarative semantics of production rules for integrity
In Logic Programming, 22nd International
maintenance.
Conference, ICLP 2006, Seattle, WA, USA, August 17-20,
2006, Proceedings.
Caroprese, L.; Greco, S.; and Zumpano, E. 2009. Active
integrity constraints for database consistency maintenance.
IEEE Trans. Knowl. Data Eng. 21(7):1042–1058.
Cruz-Filipe, L.; Gaspar, G.; Engr´acia, P.; and Nunes, I.
2013. Computing repairs from active integrity constraints.
In Seventh International Symposium on Theoretical Aspects
of Software Engineering, TASE 2013, 1-3 July 2013, Birm-
ingham, UK.
2016. Grounded fixpoints and active
Cruz-Filipe, L.
In Technical Communications of
integrity constraints.
the 32nd International Conference on Logic Programming,
ICLP 2016 TCs, October 16-21, 2016, New York City, USA.
Eiter, T.; Fink, M.; Greco, G.; and Lembo, D.
2008.
Repair localization for query answering from inconsistent
databases. ACM Trans. Database Syst. 33(2):10:1–10:51.
Fagin, R.; Kimelfeld, B.; and Kolaitis, P. G. 2015. Di-
In Pro-
chotomies in the complexity of preferred repairs.
ceedings of the 34th ACM SIGMOD-SIGACT-SIGAI Sym-
posium on Principles of Database Systems (PODS).
Feuillade, G.; Herzig, A.; and Rantsoudis, C. 2019. A dy-
namic logic account of active integrity constraints. Fundam.
Informaticae 169(3):179–210.
Flesca, S.; Greco, S.; and Zumpano, E.
2004. Ac-
In Proceedings of the 6th In-
tive integrity constraints.
ternational ACM SIGPLAN Conference on Principles and
Practice of Declarative Programming, 24-26 August 2004,
Verona, Italy.
Kimelfeld, B.; Livshits, E.; and Peterfreund, L. 2017. De-
tecting ambiguity in prioritized database repairing. In Pro-
ceedings of the 20th International Conference on Database
Theory (ICDT).
Lembo, D.; Lenzerini, M.; Rosati, R.; Ruzzi, M.; and Savo,
D. F. 2010. Inconsistency-tolerant semantics for description
logics. In Proceedings of the 4th International Conference
on Web Reasoning and Rule Systems (RR).
Livshits, E., and Kimelfeld, B. 2017. Counting and enumer-
ating (preferred) database repairs. In Proceedings of the 36th
ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of
Database Systems (PODS).
Marileo, M. C., and Bertossi, L. E. 2010. The consistency
extractor system: Answer set programs for consistent query
answering in databases. Data Knowl. Eng. 69(6):545–572.
Staworko, S., and Chomicki, J. 2010. Consistent query
answers in the presence of universal constraints. Inf. Syst.
35(1):1–22.
Staworko, S.; Chomicki, J.; and Marcinkowski, J. 2012.
Prioritized repairing and consistent query answering in rela-
tional databases. Annals of Mathematics and Artificial Intel-
ligence (AMAI) 64(2-3):209–246.

