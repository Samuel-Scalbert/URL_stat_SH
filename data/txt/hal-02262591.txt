VersionClimber: version upgrades without tears
Christophe Pradal, Sarah Cohen-Boulakia, Patrick Valduriez, Dennis Shasha

To cite this version:

Christophe Pradal, Sarah Cohen-Boulakia, Patrick Valduriez, Dennis Shasha. VersionClimber: ver-
sion upgrades without tears. Computing in Science and Engineering, 2019, 21 (5), pp.87-93.
￿10.1109/MCSE.2019.2921898￿. ￿hal-02262591￿

HAL Id: hal-02262591

https://inria.hal.science/hal-02262591

Submitted on 2 Aug 2019

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

1

VersionClimber: version upgrades without tears

Christophe Pradal UMR AGAP, CIRAD and Inria, Univ. Montpellier, Montpellier, France
christophe.pradal@cirad.fr
Sarah Cohen-Boulakia LRI CNRS 8623, U.Paris Sud, France
cohen@lri.fr
Patrick Valduriez Inria and LIRMM, Univ. Montpellier, France
patrick.valduriez@inria.fr
Dennis Shasha Courant Institute, New York University, USA
Inria and LIRMM, Montpellier, France
shasha@cs.nyu.edu

2

VersionClimber is an automated system to help update the package and data infrastructure of a software application based on
priorities that the user has indicated (e.g. I care more about having a recent version of this package than that one). The system does
a systematic and heuristically efﬁcient exploration (using bounded upward compatibility) of a version search space in a sandbox
environment (Virtual Env or conda env), ﬁnally delivering a lexicographically maximum conﬁguration based on the user-speciﬁed
priority order. It works for Linux and Mac OS on the cloud.

Abstract

Software Engineering, Versioning, conda, software deployment,

Index Terms

I. INTRODUCTION

Data scientists, natural scientists, and enterprise-scale application programmers typically need to analyze multiple data sources
using multiple packages, each of which evolves independently. As professionals primarily concerned with their domains, the
data scientists have neither the interest nor the technical skill to engage in the continuous development protocols [1], [2] that
are currently considered the best practice to keep up with recent versions of each package. More likely, they ﬁnd themselves
needing to update the packages or data sources of some software system (often implemented as a workﬂow) whose original
developer has left or whose project was put on hold.

Because updating the version of one package may break compatibility with other packages, one approach to explore this
package-version space is manual testing among version combinations, but that proves to be frustratingly time-consuming given
the number of combinations to be tested.

In the current state of the art, a data scientist might use conda as a multi-OS package manager because of its ability to
build conda environments that can contain different versions of different packages. A conda environment is isolated from the
operating system and can be exported as a set of versioned packages to be cloned on another computer. However, updating
an environment often produces errors due to conﬂicts between different versioned packages, so updating a set of packages to
later versions remains a trial-and-error process when using conda.

A complementary approach to support isolation is to use containers, such as Docker containers, to install a set of package-
versions on a given Operating System in an image that can be stored on the web and deployed on diverse computer and
operating systems. While this supports both isolation and reproducibility across platforms, building a docker image requires
substantial engineering knowledge and the frozen image cannot evolve through time. Evolution remains manual.

An automatic approach to updating versions is an active area of research in the Linux kernel community (e.g. https:
//kernelnewbies.org/KernelProjects/kconﬁg-sat). The idea is to encode the dependencies between package-version pairs and
then to use a satisﬁability (SAT) solver to ﬁnd compatible versions of package-versions [3]. This could work well for the
Linux kernel where the number of packages is limited and well known, but knowing these compatibility relationships in a
system put together in a one-of-a-kind way is infeasible in general.

VersionClimber is an automated system to help update the package and data infrastructure of a software application based
on package priorities that the user has indicated. Based on conﬁguration ﬁles and a notion of success and failure that the user
sets up, VersionClimber does an efﬁcient exploration through version space ﬁnally arriving at a lexicographically maximum
conﬁguration based on that priority order.

We will show two examples to illustrate VersionClimber in action. The software (source and binary) is available at the

addresses given in the summary.

II. LASER INTERFEROMETER GRAVITATIONAL-WAVE OBSERVATORY (LIGO) CASE STUDY

Our ﬁrst example is a data science pipeline used in physics and developed in Python to analyse LIGO data. A reproducible
pipeline built on a Jupyter Notebook exists to analyze gravitational waves data. The notebook uses the following packages:
Python, NumPy, SciPy, Jupyter Notebook, H5Py and also plotting libraries such as Matplotlib and SeaBorn. While all these
libraries are quite standard, the Notebook depends on Python 2 and fails with Python 3.

Let us say that another physics group wanted to update those packages to their latest versions to use them for a new
application of gravitational interferometry. VersionClimber allows such a group to specify the package order in descending
order of priority (of which ones they most want to bring up to date) and the versions of each package to be considered and
ﬁnds the most up-to-date conﬁguration that works based on the versions the user would like to consider for each package. We
now present a step by step tutorial for how to do this.

A. Updating the LIGO software using VersionClimber

First, install conda: create a conda environment cise with VersionClimber installed in it, and activate it:

conda create --name cise -c versionclimber versionclimber -y
conda activate cise

Then, to reproduce the LIGO analysis pipeline, create a directory containing a conﬁguration ﬁle named conﬁg.yaml avail-
able at https://github.com/VersionClimber/VersionClimber/blob/master/example/tuto ligo/conﬁg.yaml. VersionClimber uses this
declarative conﬁguration ﬁle to indicate which packages have to be tested and their priority order.

p r e : g i t
p a c k a g e s :

c l o n e h t t p s : / / g i t h u b . com / p r a d a l / l i g o −b i n d e r . g i t

l i g o

3

− name
s c i p y
:
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

− name
: numpy
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

i n s t a l l −y

i n s t a l l −y

s e a b o r n

− name
:
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

i n s t a l l −y

− name
: h5py
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

i n s t a l l −y

− name
: n o t e b o o k
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

i n s t a l l −y

− name
: n b c o n v e r t
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

i n s t a l l −y

− name
: m a t p l o t l i b
: c o n d a
v c s
: c o n d a
cmd
h i e r a r c h y : p a t c h
: p a t c h
s u p p l y

i n s t a l l −y

− name
: p y t h o n
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m a j o r
s u p p l y

i n s t a l l −y

r u n :

− j u p y t e r n b c o n v e r t −−E x e c u t e P r e p r o c e s s o r . t i m e o u t =60 −−t o n o t e b o o k
−−e x e c u t e

l i g o / i n d e x . i p y n b

4

p o s t : c o n d a env e x p o r t > e n v i r o n m e n t . yml

The YAML ﬁle is divided into four sections, namely pre, packages, run, and post:
• pre (Optional): A set of commands to execute before running VersionClimber. Here, we will clone from github the
repository ligo-binder that contains a notebook index.ipynb which will be run on each potential conﬁguration of package-
versions.

• packages: A package is declared using a set of meta-information such as:

– name is the name of the package.
– vcs is the type of version control system the package use (i.e. git or svn for source packages or pypi and conda for

binary packages).

– url is the address where the package will be cloned or checkout. (This information is needed only for source packages.)
– cmd is the command to build the package.
– conda is an optional argument to indicate if the package is managed by conda (True) or pip (False).VersionClimber
supports only these two package managers because they support package installation across multiple platforms in
user space (i.e., without administrator privileges).

– recipe is the local path where the conda recipe is deﬁned. This optional parameter is deﬁned when building executables

from source.

– channels is a list of priority channels to consider when installing with conda.
– hierarchy is a way to describe the search space for a package, i.e. the set of versions to consider. The possible values
are major, minor, patch and commits (default). For example, in the case of ”hierarchy:patch”, VersionClimber will
consider the set of versions consisting of the last commit of each patch. By contrast ”hierarchy:minor” means that
VersionClimber will consider only the latest commit of the latest patch of each minor version. The larger the search
space the more work, but potentially also the slightly more up-to-date conﬁguration that will come out.

– supply indicates a list of consecutive versions of a package that are backward compatible in the sense that every
version in the list supplies the same functions with the same signatures (i.e. same API). So, for example, saying
”supply: minor” means that all versions of a package that share the same major and minor version designations
provide exactly the same functions with the same signatures and the same semantics. They are said to be ”supply-
constant.” When semantic versioning doesn’t apply, then this will require user knowledge. If that knowledge is not
available, then the user can set this parameter to demand: X where X is the same value as given as a parameter to
hierarchy. That will slow things down (perhaps by a lot) but may result in a more recent version of this package.
The ”anchor” of a supply-constant sequence of versions is the ﬁrst member of the sequence, because that version
provides the same services as the others and demands the least.
demand: By contrast, the line ”demand:X” (e.g., demand: major) means that all versions that have the same X (in
this example, major) designation are backward compatible and all those versions require (i.e., ”demand”) the same
function-signatures from other packages. They are said to be ”demand-constant”. The ”anchor” of a demand-constant
sequence of versions is the last member of the sequence, because that version provides the most services of any in
the sequence without demanding more. We formalize these notions in the next subsection.

• run: the command to test the different packages together to know if a conﬁguration is valid. In this example, the Jupyter
Notebook is executed and its return status indicate if the packages at a given version are compatible (success) or not
(failure). A user may include other commands that execute a test suite or a script.

• post (Optional):

a command run at the end of the process, when VersionClimber has found the up-to-date package
combination. Here, we export the conda environment into a ﬁle to be able to recreate it on another computer. Other
options are possible, e.g., build a Docker image.

To run VersionClimber in the directory containing the conﬁg.yaml ﬁle, just use the command:

vclimb -a

The number of potential combinations for the LIGO application is very large: 53,212,287,744. The number of anchors (see
next subsection) to explore is much smaller, but remains quite large: 45,208,800. The versions of each package and the number
of conﬁguration can be obtained by running the following command:

vclimb --version

The optimal working conﬁguration is found after testing 9 conﬁgurations in 1050s. (Working in this case means simply ”not

crashing”, but in our next example, we show how to integrate user-written tests to indicate what working means.)

−−−
C o n f i g u r a t i o n 1
s c i p y : 1 . 2 . 0 , numpy : 1 . 1 6 . 0 , h5py : 2 . 9 . 0 ,
n b c o n v e r t : 5 . 4 . 0 , m a t p l o t l i b : 3 . 0 . 2 , p y t h o n : 3 . 7 . 3

s e a b o r n : 0 . 9 . 0 , n o t e b o o k : 5 . 7 . 0 ,

FAILURE
−−−
C o n f i g u r a t i o n 9
s c i p y : 1 . 2 . 1 , numpy : 1 . 1 6 . 3 , h5py : 2 . 9 . 0 ,
n b c o n v e r t : 5 . 4 . 1 , m a t p l o t l i b : 2 . 2 . 3 , p y t h o n : 2 . 7 . 1 6

s e a b o r n : 0 . 9 . 0 , n o t e b o o k : 5 . 7 . 8 ,

5

Run c o n d a
n b c o n v e r t = 5 . 4 . 1 m a t p l o t l i b = 2 . 2 . 3 p y t h o n = 2 . 7 . 1 6 i n 2 6 . 5 9 5 1 6 1 s

s c i p y = 1 . 2 . 1 numpy = 1 . 1 6 . 3 h5py = 2 . 9 . 0 s e a b o r n = 0 . 9 . 0 n o t e b o o k = 5 . 7 . 8

i n s t a l l −y

j u p y t e r n b c o n v e r t −−E x e c u t e P r e p r o c e s s o r . t i m e o u t =60 −−t o n o t e b o o k −−e x e c u t e
C o n f i g u r a t i o n e x e c u t i o n i n 1 5 . 6 2 4 0 1 3 s
SUCCESS
−−−

l i g o / i n d e x . i p y n b

T o t a l

t i m e i n 1 0 5 0 . 4 1 4 9 7 1 s

B. Supply-constant and Demand-constant – the building blocks of VersionClimber

Deﬁnition: The supply set of a package-version P.v, denoted supplyset(P.v) is the set of function-signatures that P.v supports.
Deﬁnition: A consecutive series of versions P.vbottom ... P.vtop is supply monotonic (commonly known as backward com-
patible) if the supplyset(P.v1) is a subset of supplyset(P.v2) for all v1, v2 such that vbottom ≤ v1 ≤ v2 ≤ vtop. That is, the
supply set is monotonically increasing and every function preserves its semantics once it is included in some version.
Deﬁnition: The demand set of P.v, denoted demandset(P.v), are the external functions called by P.v in the application. Each
function is uniquely deﬁned by the package it comes from and the types of its arguments and the type of its return value.
Deﬁnition: A consecutive series of versions are demand monotonic if the demandset(P.v1) is a subset of demandset(P.v2) for
all v1, v2 such that vbottom ≤ v1 ≤ v2 ≤ vtop. That is, the demand set is monotonically increasing.
Deﬁnition: A well-formed mini-series is supply monotonic and demand monotonic.
Deﬁnition: A demand-constant mini-series Pi.vbottom ... Pi.vtop is well-formed and has the additional property that demand-
set(Pi.vtop) = demandset(Pi.vbotom). That is, the demand set doesn’t change.
Deﬁnition: A supply-constant mini-series Pi.vbottom ... Pi.vtop is well-formed and has the additional property that supply-
set(P.vbottom) = supplyset(P.vtop).

Note that in a semantic versioning setting, patch versions within the same major-minor release are often supply-constant.
Also note that a single version is always demand-constant and supply-constant. Pragmatically speaking, that means the user
can always choose to try every version of a package.

III. MULTI-LINGUAL CASE STUDY: PHENOMENAL
Our second example uses packages from multiple languages (i.e. C++ and Python) to process biological image data and

extract three-dimensional structural information to infer genotype to phenotype relationship.

A Python library, named Phenomenal, has been developed and depends on a set of widely used libraries for scientiﬁc visu-
alisation and image processing such as VTK and OpenCV. While these libraries have Python interfaces, they are implemented
in C++ for efﬁciency. However, they are known to be difﬁcult to install due to binary conﬂicts and pairwise dependencies.

In addition, Phenomenal relies on some code that is not available on any public conda channel. For each conﬁguration, we
will rebuild the local packages. Then, to test the status of each conﬁguraion, rather than executing a notebook, we will run
the full test suite. That is what ”working” will mean in this case.

Phenomenal depends on Python packages such as Python, NumPy, SciPy, MatPlotLib, NetworkX, Pandas, Scikit-Learn,

Scikit-Image, and OpenCV and VTK. It depends also on utilities such as nose, coverage or openalea.deploy.

The complete example is available at https://github.com/VersionClimber/CiSE multilanguage.
The user might create the Phenomenal conﬁguration as follows:

p a c k a g e s :

: o p e n a l e a . d e p l o y
: g i t
: h t t p s : / / g i t h u b . com / o p e n a l e a / d e p l o y . g i t

i n s t a l l −y −−use−l o c a l

− name
v c s
u r l
b u i l d c m d : c o n d a b u i l d
cmd
c o n d a
r e c i p e
h i e r a r c h y : p a t c h

: c o n d a
: T r u e
:

r e c i p e s / d e p l o y

s u p p l y

: m i n o r

6

: o p e n a l e a . p h e n o m e n a l
: g i t
: h t t p s : / / g i t h u b . com / o p e n a l e a / p h e n o m e n a l . g i t

− name
v c s
u r l
b u i l d c m d : c o n d a b u i l d
cmd
c o n d a
r e c i p e
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

: c o n d a
: T r u e
:

i n s t a l l −y −−use−l o c a l

r e c i p e s / p h e n o m e n a l

− name
: n o s e
: c o n d a
v c s
: c o n d a
cmd
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

i n s t a l l −y

c o v e r a g e

− name
:
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

− name
: p a n d a s
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

− name
: v t k
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

− name
: o p e n c v
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

i n s t a l l −y

i n s t a l l −y

i n s t a l l −y

i n s t a l l −y

− name
: n e t w o r k x
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

i n s t a l l −y

s c i k i t −image

− name
:
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

i n s t a l l −y

s c i k i t −l e a r n

− name
:
: c o n d a
v c s
: c o n d a
cmd
h i e r a r c h y : p a t c h

i n s t a l l −y

7

s u p p l y

: m i n o r

− name
s c i p y
:
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

− name
: c y t h o n
: c o n d a
v c s
: c o n d a
cmd
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

− name
: numba
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

− name
: numpy
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m i n o r
s u p p l y

i n s t a l l −y

i n s t a l l −y

i n s t a l l −y

i n s t a l l −y

− name
: m a t p l o t l i b
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: p a t c h
s u p p l y

i n s t a l l −y

− name
: p y t h o n
: c o n d a
v c s
cmd
: c o n d a
h i e r a r c h y : p a t c h
: m a j o r
demand

i n s t a l l −y

r u n :

− n o s e t e s t s −w . v c l i m b / o p e n a l e a . p h e n o m e n a l / t e s t

p o s t : c o n d a env e x p o r t > e n v i r o n m e n t . yml

All the packages are installed from conda using the default channel. Only two packages, namely openalea.deploy and
openalea.phenomenal are built from source. The source code is retrieved from github. For each tagged version, a conda
package is built then installed with the other dependencies.

Because this example requires re-compilation, the user must create a conda ”recipe”. The recipe is the part of the requirements
following ”build-cmd:” and lists the names of the packages under test. The particular package-versions are taken from those
installed from conda. In the example below, pandas version 0.23.4, numba 0.41.0 etc.

An example of an openalea.phenomenal recipe is the following. The $version notation causes VersionClimber to specify
the version of the openalea.phenomenal package to conda. One should use this for any package that is recompiled for each
conﬁguration as we describe in more detail in the documentation.

p a c k a g e :

name : o p e n a l e a . p h e n o m e n a l
v e r s i o n : ” $ v e r s i o n ”

s o u r c e :
p a t h :

. . / . . / . v c l i m b / o p e n a l e a . p h e n o m e n a l

b u i l d :

number : 0
p r e s e r v e e g g d i r : T r u e
s t r i n g : p h e n o m e n a l
s c r i p t :

− p y t h o n s e t u p . py i n s t a l l −−s i n g l e −v e r s i o n −e x t e r n a l l y −managed −−r e c o r d r e c o r d . t x t

8

r e q u i r e m e n t s :

b u i l d :

− p y t h o n
− s e t u p t o o l s
− o p e n a l e a . d e p l o y
− c y t h o n
− numpy

r u n :

− p y t h o n
− numpy
− numba
− c y t h o n
− o p e n a l e a . d e p l o y
− s c i p y
− s c i k i t −image
− s c i k i t −l e a r n
− n e t w o r k x
− o p e n c v
− m a t p l o t l i b
− v t k
− pywin32 [ win ]
− n o s e
− c o v e r a g e
− s p h i n x

There are a total of 28,669,893,502,228,070,400 possible conﬁgurations. Alternatively, a simple heuristic to ﬁnd the optimal
conﬁguration is to test the conﬁgurations in a lexicographically descending order, based on the priorities of the packages. That
would require testing 5963 conﬁgurations requiring over 10 days. We stopped the process after testing 730 conﬁgurations over
30 hours. VersionClimber by contrast found the optimal solution in 8 hours and 48 minutes after testing 78 conﬁgurations.

The result is

o p e n a l e a . d e p l o y =v2 . 1 . 1
o p e n a l e a . p h e n o m e n a l =v1 . 6 . 1
n o s e = 1 . 3 . 7
c o v e r a g e = 4 . 5 . 3
p a n d a s = 0 . 2 4 . 2
v t k = 8 . 2 . 0
o p e n c v = 4 . 1 . 0
n e t w o r k x = 2 . 2
s c i k i t −image = 0 . 1 4 . 2
s c i k i t −l e a r n = 0 . 2 0 . 3
s c i p y = 1 . 2 . 1
c y t h o n = 0 . 2 9 . 7
numba = 0 . 4 3 . 1
numpy = 1 . 1 5 . 4
m a t p l o t l i b = 2 . 2 . 3
p y t h o n = 2 . 7 . 1 6

9

IV. SUMMARY

VersionClimber helps developers upgrade their systems by choosing conﬁgurations efﬁciently and then testing them auto-
matically. These conﬁgurations may consist of source packages as well as binary ones and may be implemented using multiple
languages. VersionClimber has been tested on both Linux and Mac OSX, though the software is also deployable on Windows.
VersionClimber uses the package managers pip and conda, because of their support for multiple platforms and their ability to
load packages into user space.

VersionClimber is open source and is available at

https://github.com/VersionClimber/VersionClimber with the documentation available here:
https://versionclimber.readthedocs.io

[1] P. M. Duvall, S. Matyas, and A. Glover, Continuous integration: improving software quality and reducing risk. Pearson Education, 2007.
[2] C. Larman, Agile and iterative development: a manager’s guide. Addison-Wesley Professional, 2004.
[3] P. Trezentos, I. Lynce, and A. L. Oliveira, “Apt-pbo: solving the software dependency problem using pseudo-boolean optimization,” in Proceedings of

the IEEE/ACM international conference on Automated software engineering. ACM, 2010, pp. 427–436.

REFERENCES

