Discovery of Link Keys in RDF Data Based on Pattern
Structures: Preliminary Steps
Nacira Abbas, Jérôme David, Amedeo Napoli

To cite this version:

Nacira Abbas, Jérôme David, Amedeo Napoli. Discovery of Link Keys in RDF Data Based on Pattern
Structures: Preliminary Steps. CLA 2020 - The 15th International Conference on Concept Lattices
and Their Applications, Jun 2020, Tallinn / Virtual, Estonia. ￿hal-02921643￿

HAL Id: hal-02921643

https://hal.science/hal-02921643

Submitted on 25 Aug 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Discovery of Link Keys in RDF Data Based on Pattern
Structures: Preliminary Steps

Nacira Abbas1, J´erˆome David2, and Amedeo Napoli1

1 Universit´e de Lorraine, CNRS, Inria, Loria, F-54000 Nancy, France
Nacira.Abbas@inria.fr, Amedeo.Napoli@loria.fr
2 Univ. Grenoble Alpes, Inria, CNRS, Grenoble INP, LIG, F-38000 Grenoble, France
Jerome.David@inria.fr

Abstract. In this paper, we are interested in the discovery of link keys among
two different RDF datasets based on FCA and pattern structures. A link key iden-
tiﬁes individuals which represent the same real world entity. Two main strategies
are used to automatically discover link keys, ignoring or not the classes to which
the individuals belong to. Indeed, a link key may be relevant for some pair of
classes and not relevant for another. Then, discovering link keys for one pair of
classes at a time may be computationally expensive if every pair should be consid-
ered. To overcome such limitations, we introduce a speciﬁc and original pattern
structure where link keys can be discovered in one pass while specifying the pair
of classes associated with each link key, focusing on the discovery process and
allowing more ﬂexibility.

Keywords: Link key· Link Key Discovery· Pattern Structures· Linked Data·
RDF.

1

Introduction

RDF (Resource Description Framework) triples (cid:104)subject,property,object(cid:105) are the
basic bricks of the web of data. The elements in the triples are described using terms of
RDF Schema and OWL ontologies. The same real world entity can be represented in
different datasets by different individuals, i.e. subjects. Data interlinking is the task of
ﬁnding identity links across datasets. Two main approaches are proposed to perform this
task. The ﬁrst one measures a similarity between subjects considering that the closest
the subjects, the more likely they are the same [13, 11]. The second one is based on
rules, which express sufﬁcient conditions for two subjects to be the same [12, 2, 1]. One
method using the latter approach is based on link keys [3] that extend the notion of a
key used in databases. Link keys are rules allowing to infer identity links between RDF
datasets. A link key takes the form of two sets of pairs of properties associated with a
pair of classes. The pairs of properties express sufﬁcient conditions for two subjects,
from the associated pair of classes, to be the same. An example of a link key is:

{(cid:104)designation, title(cid:105)}, {(cid:104)creator, author(cid:105)}, (cid:104)Book, Novel(cid:105)

stating that whenever an instance a1 of the class Book has the same values for the
property designation as an instance b1 of the class Novel for the property title,

2

N. Abbas et al.

and that a1 and b1 share at least one value for the properties creator and author, then
a1 and b1 denote the same entity.

Usually link keys are not provided. For this reason, a ﬁrst algorithm was proposed in
[3] for automatically discovering link keys from datasets. This algorithm starts from two
RDF datasets, discovers link key candidates then, evaluates these candidates according
to quality measures. The quality of a link key candidate is evaluated according to two
measures [3]. The ﬁrst one, called coverage, relies on the intuition that the more subjects
linked by a link key candidate, the more complete this link key is. The second measure,
called discriminability, assumes that subjects, in each dataset, have to be distinct. It
measures the capability of a link key candidate to discriminate between subjects. In
order to take into account these two measures, an harmonic mean might be used.

The question of using Formal Concept Analysis (FCA) to discover link keys has
arisen naturally, since a link key candidate presents some mathematical properties which
are similar to the ones of a formal concept in FCA [4, 5].

To discover link keys candidates, the existing methods apply one of the following
strategies. The ﬁrst one takes as input all the subjects from two datasets, ignoring the
classes to which the subjects belong to, e.g. Book. This strategy generates link key
candidates that apply to the whole datasets, i.e. it does not specify the pair of classes as-
sociated with each link key candidate. These candidates are then evaluated considering
the whole datasets and again without taking into account the pair of classes. This eval-
uation, however, is not accurate since a link key candidate may be relevant for a pair of
classes e.g. (cid:104)Book, Dictionary(cid:105) and not relevant for another pair e.g. (cid:104)Book, Novel(cid:105).
The second strategy consists in ﬁnding link key candidates for one particular pair of
classes at a time, then evaluating these candidates w.r.t. this particular pair. This strat-
egy repeats the same process for all the pairs of classes issued from the two datasets.
This allows a more accurate evaluation of the link key candidates. However, we do not
know in advance which classes to take as input at a time. Consequently, a naive ap-
proach would be to consider all the pairs of classes from the Cartesian product of the
sets of classes of the given datasets, or to require a class alignment [7]. The ﬁrst solution
is computationally expensive and the second one is not always possible because we do
not have systematically a class alignment.

In this paper, we propose a method based on Pattern Structures, a generalization
of Formal Concept Analysis [8], that overcomes these limits. This method allows to
ﬁnd link key candidates in one pass, i.e. without iterating on every pair of classes, while
specifying the pairs of classes associated with each link key candidate without requiring
an a priori alignment. Moreover, datasets may classify the same entities differently,
for example, in one dataset "Marie Curie" is an instance of the class "Woman" and
at the same time an instance of the class "Scientist", while in an another dataset,
"Marie Curie" is an instance of a unique class "FemaleScientist". In this work,
we propose to take into account this difference in abstraction, by generalizing the notion
of a link key associated with a pair of classes to a link key associated with a pair of class
expressions. For example, such a link key candidate could be associated with the pair
(cid:104)Woman and Scientist, FemaleScientist(cid:105) where "Woman and Scientist" is a
class expression.

Discovery of Link Keys in RDF Data Based on Pattern Structures: Preliminary Steps

3

The plan of the paper is as follows. First we give some deﬁnitions and notations.
Then, we present how the problem of link key discovery is encoded in FCA. After
that, we formalize the problem with pattern structure and we show how to discover link
keys from two datasets in one pass while speciﬁng which pairs of class expressions are
associated with these candidates.

2 Preliminaries

An RDF dataset [10] is a set of triples (cid:104)s,p,o(cid:105) ∈ (U ∪ B) × U × (U ∪ B ∪ L), where
U is a set of IRIs (Internationalized Resource Identiﬁer), B a set of blank nodes i.e.
variables or ”anonymous resources” and L a set of literals, i.e. values depending on
datatypes. To avoid any confusion with FCA objects, we refer to an ”object” in an
RDF triple as ”RDF object”. Figure 1 represents two RDF datasets where an example
of an RDF triple is (cid:104)b13, title,Les Mis´erables(cid:105), expressing that the subject b13 is
related through the property title to the RDF object Les Mis´erables. For short,
we will write that b13 has the value Les Mis´erables for the property title. The
properties in RDF are not functional, i.e. for one property, a subject may be related to
more than one RDF object or no RDF object at all. The set of values of a subject s for
the property p is given by p(s) such as p(s) = {o|(cid:104)s, p, o(cid:105) ∈ D} e.g. author(b15) =
{Stephen King, Peter Straub}. The property rdf:type is used in RDF to expess
that a subject belongs to a particular class i.e. that a subject is an instance of a class.
For example, the triple (cid:104)b13, rdf:type,Novel(cid:105) means that b13 is an instance of the
class Novel. Given a dataset D, the sets S(D), P(D),Cl(D) denote respectively the set
of subjects, the set of properties and the set of classes in D. The set of instances of a
class C is S(C) = {s | (cid:104)s,rdf:type,C(cid:105) ∈ D}.

2.1 Link keys

Given two datasets D1 and D2, we aim to discover identity links between these datasets.
An identity link is a statement of the form (cid:104)s1, owl:sameAs, s2(cid:105) expressing that the sub-
ject s1 from D1 and the subject s2 from D2 represent the same real world entity. For
example, given D1 and D2 as represented in Figure 1, the data interlinking task should
discover the identity link (cid:104)a13,owl:sameAs,b13(cid:105) because the subjects a13 and b13 rep-
resent both the same book Les Mis´erables written by Victor Hugo. For short, we
write (cid:104)a13, b13(cid:105) and we call this pair a link. A link key is used to generate such links.

We distinguish two notions related to link keys. The ﬁrst one is link key expression
which is the syntactic form of a link key, i.e. it does not necessarily generate actual links.
The second one is link key candidate which is a link key expression that generates at
least a link and it is maximal w.r.t. its generated link set. Actually, link key discovery
methods ﬁnd link key candidates and evaluate them thanks to adapted measures such as
proposed in [3]. Finally, the most relevant candidates will be selected as valid link keys
and used to infer identity links among the datasets.

The notion of a link key has been deﬁned in [5]. In this paper, we generalize the
notion of a link key candidate associated with a pair of classes to a link key candidate
associated with a pair of class expressions. We restrict ourselves to a subset of class

4

N. Abbas et al.

Woman

a1

a2

a3

a4

a5

a6

a7

a8

a9

a10

Scientist

n
e
v
i
g
f a m i l y N
f a m i l y N
g i v e n
g i v e n
f a m i l y N

g i v e n
f a m i l y N

g i v e n
familyN

given
familyN

given
familyN

given
familyN
familyN
given

given
familyN

Book

a11

a12

a13

a14

a15

d a t e

designation
d e s i g n a t i o n
date

d e s i g n a t i o n
creator
c r e a t o r
designation

designation
creator

Oprah

Winfrey

Kelly

Grace

Hopper

Anita

Borg

Ada

Lovelace

Katie

Bouman

Rosalind

Franklin

Marie

Curie

Pierre

Alan

Turing

2016

The Merriam-Webster Dictionary

2009

Les Mis´erables

Victor Hugo

Notre-Dame de Paris

The Talisman

Stephen King

Peter Straub

firstName
name

firstName
name

firstName
name

firstName
name

firstName
name

firstName
n a m e

FemaleScientist

b3

b4

b5

b6

b7

b8

year

title

title

year

title
author
author
title

title
author
a u t h o r

Dictionary

b11

b12

b13

b14

b15

Novel

D1

D2

Fig. 1. Example of two RDF datasets. On the left-hand side, the dataset D1 populated with in-
stances of the classes: Woman, Scientist and Book. On the right-hand side, the dataset D2
populated with instances of the classes: FemaleScientist, Dictionary and Novel

Discovery of Link Keys in RDF Data Based on Pattern Structures: Preliminary Steps

5

expressions from description logics [6], composed of concept names related by the
Boolean operators (cid:117)DL and (cid:116)DL (respectively conjunction and disjunction in description
logics). The intuition behind this generalization is that the ontologies on which the
datasets rely may use different levels of abstraction to describe entities. For example
the set of female scientists may be described by the intersection of the classes Woman
and Scientist in one dataset and by the named class FemaleScientist in another
dataset. In this case, it would be more accurate to deﬁne a link key that discovers links
between the class intersection Woman and Scientist and the class FemaleScientist.
The restriction to (cid:117)DL and (cid:116)DL operators, comes from the fact that we are dealing only
with asserted rdf:type in the RDF dataset. Following the semantics of operators in
description logics, the set of subjects belonging to C1 (cid:117)DL C2 is S(C1 (cid:117)DL C2) = S(C1) ∩
S(C2) and the set of subjects belonging to C1 (cid:116)DL C2 is S(C1 (cid:116)DL C2) = S(C1) ∪ S(C2).
Firstly below we introduce the deﬁnition of a link key expression associated with a

pair of class expressions.

Deﬁnition 1 (Link key expression associated with a pair of class expressions). Let
us consider two datasets D1 and D2. Let Eq and In (cid:54)= /0 be subsets of pairs of properties,
such as, Eq ⊆ P(D1) × P(D2), In ⊆ P(D1) × P(D2), Eq ⊆ In. Let CE1 be a class ex-
pression over Cl(D1) and CE2 a class expression over Cl(D2). k = (Eq, In, (cid:104)CE1,CE2(cid:105))
is a link key expression associated with the pair of class expressions (cid:104)CE1,CE2(cid:105) over
D1 and D2.

Actually we replace the pair of named classes in a link key expression as deﬁned in [5]
with a pair of class expressions. As example of link key expression is
k = ({(cid:104)given,year(cid:105)}, {(cid:104)given,year(cid:105)}, (cid:104)Woman(cid:117)DLScientist,FemaleScientist(cid:105)).

A link key expression associated with a pair of class expressions may generate links

among these class expressions. We deﬁne this link set as follows.

Deﬁnition 2 (Link set generated by a link key expression associated with a pair
of class expressions). Given two datasets D1 and D2. Let k = (Eq, In, (cid:104)CE1,CE2(cid:105)) be
a link key expression associated with the pair of class expressions (cid:104)CE1,CE2(cid:105) over
D1 and D2. The link set generated by k is the subset Lk ⊆ (S(CE1) × S(CE2)) deﬁned
as Lk = {(cid:104)s1, s2(cid:105) ∈ S(CE1) × S(CE2)) | p1(s1) = p2(s2) (cid:54)= /0 for all (cid:104)p1, p2(cid:105) ∈ Eq and
p1(s1) ∩ p2(s2) (cid:54)= /0 for all (cid:104)p1, p2(cid:105) ∈ In}.

As the properties in RDF are not functional, we compare the values of subjects in two
ways (i) Eq are pairs of properties for which two subjects share all their values and
(ii) In are those pairs of properties for which two subjects share at least one value. For
example (cid:104)a15, b15(cid:105) ∈ Lk where:
k = ({(cid:104)designation,title(cid:105)}, {(cid:104)designation,title(cid:105), (cid:104)creator,author(cid:105)}, (cid:104)Book,Novel(cid:105))
because (cid:104)a15, b15(cid:105) ∈ S(Book) × S(Novel) and designation(a15) = title(b15) (cid:54)= /0 and
creator(a15)∩author(b15) (cid:54)= /0.

A link key candidate is a link key expression that generates at least a link and it is
maximal on the link set that it generates. To deﬁne ”maximality” we have to deﬁne an
order between link key expressions.

Deﬁnition 3 (Meet, join of link key expressions associated with a pair of class
expressions). Given two datasets D1 and D2. Let k1 = (Eq1, In1, (cid:104)CE1
2 (cid:105)) and

1 ,CE1

6

N. Abbas et al.

k2 = (Eq2, In2, (cid:104)CE2
1 ,CE2
the join (cid:116) of k1 and k2 are deﬁned as follows:

2 (cid:105)) be link key expressions over D1 and D2. The meet (cid:117) and

k1 (cid:117) k2 = (Eq1 ∩ Eq2, In1 ∩ In2, (cid:104)(CE1
k1 (cid:116) k2 = (Eq1 ∪ Eq2, In1 ∪ In2, (cid:104)(CE1

1 (cid:116)DL CE2
1 (cid:117)DL CE2

1 ), (CE1
1 ), (CE1

2 (cid:116)DL CE2
2 (cid:117)DL CE2

2 )(cid:105))
2 )(cid:105))

The link set of a link key expression k1 (cid:117) k2 is equal to the union of the link sets of k1
and k2. The less the number of pairs of properties to compare in a link key expression,
the more the pairs of subjects satisfying these pairs of properties. Thus the larger the
classes in a link key expression, and dually for k1 (cid:116) k2.
As an example from the datasets represented in Figure 1, the meet of two link key ex-
pressions k1 = ({(cid:104)given,firstName(cid:105)}, {(cid:104)given,firstName(cid:105)}, (cid:104)Woman,FemaleScientist(cid:105))
and k2 = ({(cid:104)given,firstName(cid:105)}, {(cid:104)given,firstName(cid:105), (cid:104)name,familyN(cid:105)},
(cid:104)(Woman(cid:117)DLScientist),FemaleScientist(cid:105)) is
k1 (cid:117) k2 = ({(cid:104)given,firstName(cid:105)}, {(cid:104)given,firstName(cid:105)}, (cid:104)Woman,FemaleScientist(cid:105)) .
The join k1 (cid:116) k2 = ({(cid:104)given,firstName(cid:105)}, {(cid:104)given,firstName(cid:105), (cid:104)name,familyN(cid:105)},
(cid:104)(Woman(cid:117)DLScientist),FemaleScientist(cid:105)).

Now we formally deﬁne a link key candidate associated with a pair of class expres-

sions.

Deﬁnition 4 (Link key candidate associated with a pair of class expressions). Let us
consider two datasets D1 and D2. Let k = (Eq, In, (cid:104)CE1,CE2(cid:105)) be a link key expression
associated with the pair of class expressions (cid:104)CE1,CE2(cid:105) over D1 and D2. k is a link key
candidate for D1 and D2 if

– Lk (cid:54)= /0, and
– k = (cid:70)

h∈[k] h such that [k] = {h | Lk = Lh}

Intuitively the link sets generated by link key expressions form a partition of the set
of link key expressions. Link key candidates are the maximal elements of the classes
of this partition. This deﬁnition matches the deﬁnition of a closed set. This explains
the use of Formal Concept Analysis [9] for link key discovery since the intent and the
extent of a formal concept are closed sets.

2.2 Link key discovery with Formal Concept Analysis

The link key discovery based on Formal Concept Analysis is detailed in [5]. Given two
datasets D1 and D2 and a pair of classes (cid:104)C1,C2(cid:105) ∈ Cl(D1) ×Cl(D2). The LK−formal
context or the formal context for link key candidates associated with a pair of classes
(cid:104)C1,C2(cid:105) is the triple (cid:104)(S(C1) × S(C2)), {∃, ∀} × P(D1) × P(D2), I(cid:105) such that:

– The set of objects of the LK−formal context is the set of pairs of subjects (cid:104)s1, s2(cid:105) ∈

(S(C1) × S(C2)).

– The set of attributes of the LK−formal context is the set of pairs of properties
(cid:104)p1, p2(cid:105) ∈ P(D1) × P(D2) preceded by a quantiﬁer in {∃, ∀} i.e. ∀(cid:104)p1, p2(cid:105) and
∃(cid:104)p1, p2(cid:105).

– The relation I between an object and an attribut is deﬁned as follows:

(cid:104)s1, s2(cid:105) I ∀(cid:104)p1, p2(cid:105) iff p1(s1) = p2(s2) (cid:54)= /0
(cid:104)s1, s2(cid:105) I ∃(cid:104)p1, p2(cid:105) iff p1(s1) ∩ p2(s2) (cid:54)= /0

Discovery of Link Keys in RDF Data Based on Pattern Structures: Preliminary Steps

7

Link key discovery based on FCA takes as input one pair of classes at a time. To dis-
cover link key candidates, in one pass, we take as input the pair of classes (cid:104)owl:Thing,
owl:Thing(cid:105), where owl:Thing is a class containing all the subjects. The generated
link key candidates will be associated with the pair (cid:104)owl:Thing,owl:Thing(cid:105) which
means that they apply to the whole datasets. Figure 2 presents the concept lattice related
to the LK−formal context associated with the pair of classes (cid:104)owl:Thing, owl:Thing(cid:105)
for the datasets D1 and D2 introduced in Figure 1.

k0
S(D1) × S(D2)

/0

k8
co=.50 di=.85 hm=.63
{(cid:104)a2, b3(cid:105)}

k7
co=.50 di=.85 hm=.63
{(cid:104)a9, b8(cid:105)}

{∀(cid:104)given,firstName(cid:105),
∃(cid:104)given,firstName(cid:105)}

{∀(cid:104)familyN,name(cid:105),
∃(cid:104)familyN,name(cid:105)}

{(cid:104)a3, b3(cid:105), (cid:104)a4, b4(cid:105), (cid:104)a5, b5(cid:105),
(cid:104)a6, b6(cid:105), (cid:104)a7, b7(cid:105), (cid:104)a8, b8(cid:105)}

k9
co=.46 di=1 hm=.63

k1
co=.38 di=71 hm=.49
{(cid:104)a11, b12(cid:105), (cid:104)a12, b11(cid:105)}

{∀(cid:104)designation,title(cid:105),
∃(cid:104)designation,title(cid:105)}

k3
co=.23 di=.60 hm=.33

{∃(cid:104)creator,author(cid:105)}

k2
co=.15 di=1 hm=.26
{(cid:104)a11, b11(cid:105), (cid:104)a12, b12(cid:105)}

{∀(cid:104)date,year(cid:105),
∃(cid:104)date,year(cid:105)}

k10

/0
P(D1) × P(D2)

{(cid:104)a15, b15(cid:105)}

k4
co=.23 di=1
hm=.37

k5
co=.15 di=.50 hm=.23
{(cid:104)a13, b14(cid:105), (cid:104)a14, b13(cid:105)}

{∀(cid:104)creator,author(cid:105)}

{(cid:104)a13, b13(cid:105), (cid:104)a14, b14(cid:105)}

k6
co=.15 di=1 hm=.26

Fig. 2. The lattice of
(cid:104)owl:Thing, owl:Thing(cid:105)

the LK−formal context associated with the pair of classes

It was shown in [5] that the intents of the formal concepts of the lattice gener-
ated from the LK−formal context (cid:104)C1 ×C2, {∃, ∀} × P(D1) × P(D2), I(cid:105) are the link key
candidates for the pair of classes (cid:104)C1,C2(cid:105). In this case, if (A, B) is a formal concept,
the link key candidate in (A, B) is kB = (Eq, In, (cid:104)C1,C2(cid:105)) where Eq = {∀(cid:104)p1, p2(cid:105) ∈ B},
In = {∃(cid:104)p1, p2(cid:105) ∈ B} and the link set generated by kB is the extent of this formal concept
LkB = A. For example, k8 corresponds to the link key candidate ({(cid:104)given,firstName(cid:105)},
{(cid:104)given,firstName(cid:105)},(cid:104)owl:Thing, owl:Thing(cid:105)).

Now, to evaluate the quality of a link key candidate in terms of coverage and dis-
criminability, let us consider L ⊆ (S(CE1)×S(CE2)) and π1(L) = {s1 ∈ S(CE1)|(cid:104)s1, s2(cid:105) ∈
L}, π2(L) = {s2 ∈ S(CE2)|(cid:104)s1, s2(cid:105) ∈ L}, where π1(L) is the set of instances of the class

8

N. Abbas et al.

expession CE1 appearing in L and π2(L) is the set of instances of the class expession
CE2 appearing in L.

The coverage of a link key candidate k associated with a pair of class expressions

(cid:104)CE1,CE2(cid:105) is denoted by co(k) and deﬁned as:

co(k) =

|π1(Lk) ∪ π2(Lk)|
|S(CE1) ∪ S(CE2)|

The coverage is the proportion between the number of instances identiﬁed (linked) by
k and the overall number of instances of the two class expressions. This means that the
coverage measures how general a link key candidate is. When co(k) is equal to 1, this
means that all instances from CE1 and CE2 are identiﬁed by the link key candidate k.
The discriminability of a link key candidate k associated with a pair of class expressions
(cid:104)CE1,CE2(cid:105) is denoted by di(k) and deﬁned as:

di(k) =

min(|π1(Lk), π2(Lk)|)
|Lk|

di(k) is the proportion of the minimum number of instances identiﬁed by k and the
number of links generated by k. When di(k) is equal to 1, then the link key is perfectly
discriminant, i.e. it generates one-to-one mappings.

Coverage and discriminability are aggregated by the harmonic mean denoted

hm(k) and deﬁned as:

hm(k) =

2

+

1
di(k)

1
co(k)

The coverage, discriminability, and harmonic mean of the link key cadidate k9 in the
lattice in Figure 2, are respectively, co=0.46, di=1, hm=0.63. The link key discovery
methods return as link keys the link key candidates whose harmonic mean value is
the highest. In this example, they return the link key candidates k7, k8 and k9, because
they have the highest hm. However, even if these candidates are relevant for the pair
(cid:104)(Woman(cid:117)DLScientist),FemaleScientist(cid:105), they do not generate any links for the pair
(cid:104)Book,Dictionary(cid:105). In fact for this latter pair, the link key candidate k2 is more relevant,
because it generates only and all correct links, even if it has a low hm. For the pair
(cid:104)Book,Novel(cid:105), the candidate k4 is more relevant. Even if they are relevant, these link key
candidates show a low hm because they are evaluated considering the whole datasets i.e.
(cid:104)owl:Thing, owl:Thing(cid:105).

We propose in the following our main contribution which is a method based on

pattern structures for discovering relevant link keys for given pairs of classes.

3 Link key discovery within Pattern Structures

In the following, we propose a method based on pattern structures, a generalization of
FCA [8], that, given two datasets, discovers link key candidates in one pass (without
iterating on every pair of classes) while specifying the classes associated with each link
key candidate.

Discovery of Link Keys in RDF Data Based on Pattern Structures: Preliminary Steps

9

3.1 A Pattern Structure for Link Key Discovery

We deﬁne the pattern structure for link key candidates discovery where the set of objects
is the set of pairs of subjects issued from two datasets. Actually these pairs correspond to
potential links. In the pattern structure, the description of a potential link is given by the
maximal link key expression that generates this link. Then the meet of two descriptions
corresponds to the meet of link key expressions as introduced in Deﬁnition 3.

Deﬁnition 5 (Pattern structure for link key candidate discovery). Given two datasets
D1 and D2. The pattern structure for link key candidate discovery between D1 and
D2, called hereafter the LK−pattern structure, is the triple (S(D1) × S(D2), (E, (cid:117)), δ )
where:

– The set of objects S(D1) × S(D2) is the set of pairs of subjects over D1 and D2.
– E is the set of potential object descriptions. A description is a link key expression

k = (Eq, In, (cid:104)CE1,CE2(cid:105)) over D1 and D2.

– (E, (cid:117)) is a meet semilattice where the meet (cid:117) of two descriptions

k1 = (Eq1, In1, (cid:104)CE1
1 ,CE1
tion 3: k1 (cid:117) k2 = (Eq1 ∩ Eq2, In1 ∩ In2, (cid:104)(CE1
The descriptions are partially ordered by (cid:118) deﬁned w.r.t. the similarity operator (cid:117).
If k1 (cid:117) k2 = k1 ⇔ k1 (cid:118) k2.

2 (cid:105)) and k2 = (Eq2, In2, (cid:104)CE2
1 (cid:116)DL CE2

2 (cid:105)) is given in Deﬁni-
2 (cid:116)DL CE2
2 )(cid:105)).

1 ,CE2
1 ), (CE1

– The mapping δ : S(D1) × S(D2) → E associates each pair of subjects (cid:104)s1, s2(cid:105) ∈
S(D1) × S(D2) to its description δ ((cid:104)s1, s2(cid:105)) = (Eq, In, (cid:104)CE1,CE2(cid:105)) where, Eq =
{(cid:104)p1, p2(cid:105)|p1(s1) = p2(s2) (cid:54)= /0}, In = {(cid:104)p1, p2(cid:105)|p1(s1) ∩ p2(s2) (cid:54)= /0}, CE1 (resp.
CE2) is the conjunction of the classes of s1 (resp. s2) over Cl(D1) (resp. Cl(D2)).

The LK−pattern structure for the datasets in Figure 1 is given in Table 1. The set of ob-
jects is the set of pairs of subjects from S(D1)×S(D2). The set of potential object descrip-
tions E is the set link key expressions over D1 and D2. For example, such a description
is given by k = ({(cid:104)designation,title(cid:105)}, {(cid:104)designation,title(cid:105)},(cid:104)Book,Dictionary(cid:105)).
We may calculate the description of the pair (cid:104)a8, b8(cid:105) ∈ S(D1) × S(D2) as follows:

δ ((cid:104)a8, b8(cid:105)) = ({(cid:104)given,firstName(cid:105), (cid:104)familyN,name(cid:105)},

{(cid:104)given,firstName(cid:105), (cid:104)familyN,name(cid:105)},
(cid:104)(Woman(cid:117)DLScientist),FemaleScientist(cid:105))

The meet of the two descriptions k1 and k2 can be calculated as follows:

k1 = ({(cid:104)given,firstName(cid:105), (cid:104)familyN,name(cid:105)}, {(cid:104)given,firstName(cid:105), (cid:104)familyN,name(cid:105)},

(cid:104)(Woman(cid:117)DLScientist),FemaleScientist(cid:105))

k2 = ({(cid:104)given,firstName(cid:105)}, {(cid:104)given,firstName(cid:105)}, (cid:104)Woman,FemaleScientist(cid:105))
k1 (cid:117) k2 = ({(cid:104)given,firstName(cid:105)}, {(cid:104)given,firstName(cid:105)}, (cid:104)Woman,FemaleScientist(cid:105))
k1 (cid:117) k2 = k2, hence, k2 (cid:118) k1

The derivation operators .(cid:3) form a Galois connection between 2S(D1)×S(D2) and E

and deﬁned as follows:
L(cid:3) = (cid:100)
k(cid:3) = {(cid:104)s1, s2(cid:105) ∈ S(D1) × S(D2)|k (cid:118) δ ((cid:104)s1, s2(cid:105))}

δ ((cid:104)s1, s2(cid:105))

(cid:104)s1,s2(cid:105)∈L

L ⊆ S(D1) × S(D2)

k ∈ E

10

N. Abbas et al.

Objects

S(D1) × S(D2)Eq

(cid:104)a2, b3(cid:105)

(cid:104)a3, b3(cid:105)

(cid:104)a4, b4(cid:105)

(cid:104)a5, b5(cid:105)

(cid:104)a6, b6(cid:105)

(cid:104)a7, b7(cid:105)

(cid:104)a8, b8(cid:105)

(cid:104)a9, b8(cid:105)

(cid:104)a11, b11(cid:105)

(cid:104)a11, b12(cid:105)
(cid:104)a12, b11(cid:105)

(cid:104)a12, b12(cid:105)

(cid:104)a13, b13(cid:105)

(cid:104)a13, b14(cid:105)
(cid:104)a14, b13(cid:105)

(cid:104)a14, b14(cid:105)

Descriptions

(cid:104)CE1,CE2(cid:105)
(cid:104)Woman, FemaleScientist(cid:105)
(cid:104)(Woman(cid:117)DLScientist),
FemaleScientist(cid:105)
(cid:104)(Woman(cid:117)DLScientist),
FemaleScientist(cid:105)
(cid:104)(Woman(cid:117)DLScientist),
FemaleScientist(cid:105)
(cid:104)(Woman(cid:117)DLScientist),
FemaleScientist(cid:105)
(cid:104)(Woman(cid:117)DLScientist),
FemaleScientist(cid:105)
(cid:104)(Woman(cid:117)DLScientist),
FemaleScientist(cid:105)
(cid:104)Scientist, FemaleScientist(cid:105)

In
{(cid:104)given,firstName(cid:105)}
{(cid:104)given,firstName(cid:105),
(cid:104)familyN,name(cid:105)}
{(cid:104)given,firstName(cid:105),
(cid:104)familyN,name(cid:105)}
{(cid:104)given,firstName(cid:105),
(cid:104)familyN,name(cid:105)}
{(cid:104)given,firstName(cid:105),
(cid:104)familyN,name(cid:105)}
{(cid:104)given,firstName(cid:105),
(cid:104)familyN,name(cid:105)}
{(cid:104)given,firstName(cid:105),
(cid:104)familyN,name(cid:105)}
{(cid:104)familyN,name(cid:105)}
{(cid:104)date,year(cid:105),
(cid:104)designation,title(cid:105)}

{(cid:104)given,firstName(cid:105)}
{(cid:104)given,firstName(cid:105),
(cid:104)familyN,name(cid:105)}
{(cid:104)given,firstName(cid:105),
(cid:104)familyN,name(cid:105)}
{(cid:104)given,firstName(cid:105),
(cid:104)familyN,name(cid:105)}
{(cid:104)given,firstName(cid:105),
(cid:104)familyN,name(cid:105)}
{(cid:104)given,firstName(cid:105),
(cid:104)familyN,name(cid:105)}
{(cid:104)given,firstName(cid:105),
(cid:104)familyN,name(cid:105)}
{(cid:104)familyN,name(cid:105)}
{(cid:104)date,year(cid:105),
(cid:104)designation,title(cid:105)}
{(cid:104)designation,title(cid:105)}{(cid:104)designation,title(cid:105)}(cid:104)Book,Dictionary(cid:105)
{(cid:104)designation,title(cid:105)}{(cid:104)designation,title(cid:105)}(cid:104)Book,Dictionary(cid:105)
{(cid:104)date,year(cid:105),
(cid:104)designation,title(cid:105)}
{(cid:104)creator,author(cid:105),
(cid:104)designation,title(cid:105)}
{(cid:104)creator,author(cid:105)}
{(cid:104)creator,author(cid:105)}
{(cid:104)creator,author(cid:105),
(cid:104)designation,title(cid:105)}

{(cid:104)date,year(cid:105),
(cid:104)designation,title(cid:105)}
{(cid:104)creator,author(cid:105),
(cid:104)designation,title(cid:105)}
{(cid:104)creator,author(cid:105)}
{(cid:104)creator,author(cid:105)}
{(cid:104)creator,author(cid:105),
(cid:104)designation,title(cid:105)}
{(cid:104)creator,author(cid:105),
(cid:104)designation,title(cid:105)}

(cid:104)Book,Novel(cid:105)
(cid:104)Book,Novel(cid:105)

(cid:104)Book,Dictionary(cid:105)

(cid:104)Book,Dictionary(cid:105)

(cid:104)Book,Novel(cid:105)

(cid:104)Book,Novel(cid:105)

(cid:104)Book,Novel(cid:105)

(cid:104)a15, b15(cid:105)

{(cid:104)designation,title(cid:105)}

Table 1. LK−pattern structure for the datasets given in Figure 1

As usual, L is a closed set if L(cid:3)(cid:3) = L and k is a closed set if k(cid:3)(cid:3) = k. Then a pattern
concept veriﬁes: L(cid:3) = k and k(cid:3) = L. The link key expression k is a link key candidate
for the two datasets D1 and D2 if and only if (L, k) is a pattern concept of the LK−pattern
structure for D1 and D2.

3.2 Discussion

Figure 3 represents the pattern concept lattice generated from the LK−pattern structure
in Table 1. Each intent of a pattern concept represents a link key candidate associ-
ated with a pair of class expressions. For example the link key candidate k9 is asso-
ciated with the pair of class expressions (cid:104)(Woman(cid:117)DLScientist),FemaleScientist(cid:105). It
should be noticed that the link key candidate k9 in Figure 3 corresponds to the link
key candidate k9 in Figure 2 (calculated with plain FCA). In the pattern concept lat-
tice we can see that the link key k9 is associated with the pair of class expressions
(cid:104)(Woman(cid:117)DLScientist),FemaleScientist(cid:105), whereas this was not possible using plain
FCA (see [5]). Moreover, different link key candidates may have the same sets of pairs
of properties (Eq and In) but are associated with different pairs of class expressions. For
example, k1a and k1b, which correspond to the link key candidate k1 in Figure 2, have
the same sets of pairs of properties {(cid:104)designation,title(cid:105)}, {(cid:104)designation,title(cid:105)},
but they are associated with different pairs of class expressions: k1a is associated with
(cid:104)Book,(Dictionary(cid:116)DLNovel)(cid:105) and k1b is associated with (cid:104)Book,Novel(cid:105). The properties

Discovery of Link Keys in RDF Data Based on Pattern Structures: Preliminary Steps

11

k8
co=.92 di=.85 hm=.89
{(cid:104)a2, b3(cid:105)}

{(cid:104)given,firstName(cid:105)},
{(cid:104)given,firstName(cid:105)}

k0
S(D1) × S(D2)
∗

k7
co=.92 di=.85 hm=.89
{(cid:104)a9, b8(cid:105)}

{(cid:104)familyN,name(cid:105)}},
{(cid:104)familyN,name(cid:105)}}

(cid:104)Woman,FemaleScientist(cid:105)

(cid:104)Scientist,FemaleScientist(cid:105)

k9
co=1 di=1 hm=1
{(cid:104)a3, b3(cid:105), (cid:104)a4, b4(cid:105), (cid:104)a5, b5(cid:105),
(cid:104)a6, b6(cid:105), (cid:104)a7, b7(cid:105), (cid:104)a8, b8(cid:105)}
{(cid:104)familyN,name(cid:105), (cid:104)given,firstName(cid:105)},
{(cid:104)familyN,name(cid:105), (cid:104)given,firstName(cid:105)}

(cid:104)(Woman(cid:117)DLScientist),FemaleScientist(cid:105)

k1a
co=1 di=.71 hm=.83

{(cid:104)designation,title(cid:105)},
{(cid:104)designation,title(cid:105)}

(cid:104)Book,(Dictionary(cid:116)DLNovel)(cid:105)

k3
co=.75 di=.60 hm=.66

{}, {(cid:104)creator,author(cid:105)}

(cid:104)Book,Novel(cid:105)

k1b
co=.57 di=.50 hm=.53
{(cid:104)a11, b12(cid:105), (cid:104)a12, b11(cid:105)}

{(cid:104)designation,title(cid:105)},
{(cid:104)designation,title(cid:105)}

(cid:104)Book,Dictionary(cid:105)

k4
co=.75 di=1 hm=.85
{(cid:104)a15, b15(cid:105)}
{(cid:104)designation,title(cid:105)}
{(cid:104)designation,title(cid:105), (cid:104)creator,author(cid:105)}

(cid:104)Book,Novel(cid:105)

k5
co=.50 di=.0.50 hm=.50
{(cid:104)a13, b14(cid:105), (cid:104)a14, b13(cid:105)}

{(cid:104)creator,author(cid:105)},
{(cid:104)creator,author(cid:105)}

(cid:104)Book,Novel(cid:105)

k2
co=.57 di=1 hm=.72
{(cid:104)a11, b11(cid:105), (cid:104)a12, b12(cid:105)}

k6
co=.50 di=1 hm=.66
{(cid:104)a13, b13(cid:105), (cid:104)a14, b14(cid:105)}

{(cid:104)date,year(cid:105), (cid:104)designation,title(cid:105)}
{(cid:104)date,year(cid:105), (cid:104)designation,title(cid:105)}

{(cid:104)creator,author(cid:105), (cid:104)designation,title(cid:105)}
{(cid:104)creator,author(cid:105), (cid:104)designation,title(cid:105)}

(cid:104)Book,Dictionary(cid:105)

(cid:104)Book,Novel(cid:105)

k10

P(D1) × P(D2)

Fig. 3. Pattern concept lattice generated from the LK−pattern structure in Table 1

appearing in such link key candidates are used to describe subjects belonging to differ-
ent classes. For example, the property title appearing in k1a and k1b is used to describe
the instances of the classes Dictionary and Novel. Furthermore, we may notice that one
pair of classes can be associated with more than one link key candidate. For example,
we can see the pair of classes (cid:104)Book,Novel(cid:105) (in orange) which is associated with four
link key candidates k3, k4, k5 and k6. This means that there are four possible choices to
select a link key candidate for the pair (cid:104)Book,Novel(cid:105) among the four candidates k3, k4,
k5 and k6.

Specifying the pairs of classes associated with a link key candidate is a critical task
to properly evaluate this candidate. For example, the link key candidate k4, in Figure 2,
shows a low harmonic mean hm=0.37, because it is evaluated on the whole datasets.
Consequently, k4 is poorly ranked by a system based on FCA. This means that k4 will
not be returned as a relevant candidate despite the fact that it generates all the correct
links between the classes Book and Novel while no other candidate is able to generate
those links. By contrast, in Figure 3, k4, shows a good harmonic mean hm=0.85 be-
cause it is evaluated on the ”right pair” of classes (cid:104)Book,Novel(cid:105). The candidate k4 will
be returned by a LK−pattern structure as a relevant candidate for the pair of classes
(cid:104)Book,Novel(cid:105). Hence, we can appreciate the importance of introducing the notion of

12

N. Abbas et al.

LK−pattern structure and the discovery of link key candidates associated with pairs of
classes.

4 Conclusion

Link keys are used to discover identity links across RDF datasets. In this paper, given
two datasets, we propose a method based on pattern structures and introduce the notion
of LK−pattern structure to discover link key candidates. An added value of the present
method is to allow the discovery of link key candidates while specifying the classes
to which they apply. This is a substantial improvement for properly evaluating the dis-
covered link key candidates. For future work we plan to study the scalability and the
efﬁciency of the method by running experiments on real-world datasets.We also intend
to extend this research work by taking advantage of domain ontologies related to the
datasets under study.

Acknowledgments

This work has been supported by the ANR project Elker (ANR-17-CE23-0007-01) and
the BnF in the context of the agreement between Inria and Minist`ere de la culture.

References

1. Al-Bakri, M., Atencia, M., David, J., Lalande, S., Rousset, M.C.: Uncertainty-sensitive rea-
soning for inferring same as facts in linked data. In: Proceedings of ECAI. pp. 698–706
(2016)

2. Al-Bakri, M., Atencia, M., Lalande, S., Rousset, M.C.: Inferring same-as facts from linked

data: an iterative import-by-query approach. In: Proceedings of AAAI (2015)

3. Atencia, M., David, J., Euzenat, J.: Data interlinking through robust linkkey extraction. In:

ECAI. pp. 15–20 (2014)

4. Atencia, M., David, J., Euzenat, J.: What can FCA do for database linkkey extraction? In:

Proceedings of FCA4AI workshop. pp. 85–92. No commercial editor. (2014)

5. Atencia, M., David, J., Euzenat, J., Napoli, A., Vizzini, J.: Link key candidate extraction with

relational concept analysis. DAM. 273, 2–20 (2020)

6. Baader, F., Calvanese, D., McGuinness, D., Patel-Schneider, P., Nardi, D., et al.: The descrip-

tion logic handbook: Theory, implementation and applications (2003)

7. Euzenat, J., Shvaiko, P.: Ontology Matching, Second Edition. Springer (2013)
8. Ganter, B., Kuznetsov, S.O.: Pattern structures and their projections. In: ICCS. pp. 129–142.

Springer (2001)

9. Ganter, B., Wille, R.: Formal Concept Analysis - Mathematical Foundations. Springer (1999)
10. Hitzler, P., Krotzsch, M., Rudolph, S.: Foundations of semantic web technologies. CRC press

(2009)

11. Ngomo, A.C.N., Auer, S.: Limes—a time-efﬁcient approach for large-scale link discovery

on the web of data. In: Proceedings of IJCAI (2011)

12. Sa¨ıs, F., Pernelle, N., Rousset, M.C.: L2r: A logical method for reference reconciliation. In:

Proceedings of AAAI. pp. 329–334 (2007)

13. Volz, J., Bizer, C., Gaedke, M., Kobilarov, G.: Silk-a link discovery framework for the web

of data. LDOW 538 (2009)

