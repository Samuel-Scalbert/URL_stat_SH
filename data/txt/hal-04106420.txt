Earliest Query Answering for Deterministic Stepwise
Hedge Automata
Antonio Al Serhali, Joachim Niehren

To cite this version:

Antonio Al Serhali, Joachim Niehren. Earliest Query Answering for Deterministic Stepwise Hedge
Automata. 27th International Conference on Implementation and Application of Automata (CIAA),
Sep 2023, famagusta, Cyprus. ￿hal-04106420￿

HAL Id: hal-04106420

https://inria.hal.science/hal-04106420

Submitted on 25 May 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution 4.0 International License

Earliest Query Answering for
Deterministic Stepwise Hedge Automata

Antonio Al Serhali and Joachim Niehren

Inria and University of Lille, France

Abstract. Earliest query answering (EQA) is the problem to enumerate
certain query answers on streams at the earliest events. We consider
EQA for regular monadic queries on hedges or nested words deﬁned by
deterministic stepwise hedge automata (dShas). We present an EQA
algorithm for dShas that requires time O(c m) per event, where m is the
size of the automata and c the concurrency of the query. We show that
our EQA algorithm runs eﬃciently on regular XPath queries in practice.

1

Introduction

Streaming algorithms for hedges or nested words were widely studied for complex
event processing [11,7] and for transforming XML documents in an online man-
ner [16,4]. The open end of a stream can be instantiated continuously. Therefore,
streams can be seen as incomplete databases, for which the notion of certain
query answers (CQAs) was widely studied [9]. An element is a certain query
answer if it is selected by all completions of the incomplete database. For in-
stance, the XPath query following::a[following::b] selects all a-elements
of a nested word (modeling an XML document) that are followed eventually by
some b-element. On the stream aabaabaaaaa . . . all a-positions before the b are
CQAs of this query, while those after are not.

Earliest query answering (EQA) is the problem of detecting CQAs on streams
at the earliest event [6]. We study EQA for regular monadic queries which select
nodes of trees or hedges. For this, we consider streams that elongate preﬁxes
of nested words such as aa(cid:104)b(cid:104)a(cid:105)(cid:104)b . . . to well-nested words. EQA requires to
decide the existence of CQAs which is computationally hard problem even for
tiny fragments of regular XPath queries [3], since Cqa is a universality problem
concerning all completions of the stream. Gauwin et al. [6] showed that EQA
can be done in polynomial time for monadic queries deﬁned by deterministic
nested word automata (dNwas) [2,15]. Their algorithm, however, requires time
O(c n2) per event, where the concurrency c is the number of alive candidates
of the query (not of the algorithm) and n the number of the automaton states.
In the worst case c may be the length of the stream for monadic queries, so the
overall complexity may be quadratic in the size of the stream too.

For complex event processing [11,7] EQA has often been avoided, by re-
stricting the class of queries such that the certainty of an answer candidate
depends only on the past of the stream and not on its future [11,7]. This rules

2

A. Al Serhali and J. Niehren

out XPath query with ﬁlters such as following::a[following::b]. Riveros
et al. [12] proposed instead to enumerate the query answers late at the end of
the stream, which however requires to buﬀer a large number of candidates. For
XML streaming, EQA was often approximated [16,4] so that all CQAs are even-
tually selected but not always earliest. Or else, as done by Saxon [8], only very
restricted regular XPath queries were permitted.

A major bottleneck for automata based EQA algorithms in practice [4] was
the diﬃculty to compile regular path queries on nested words to deterministic
automata that are reasonably small. This problem was solved recently [1] based
on stepwise hedge automata (Shas) [13] and schema-based determinization [14].
Shas naturally generalize on ﬁnite state automata for words and trees. They
can recognize all regular languages of hedges equally to Nwas but don’t have
any explicit stack (such as tree automata). Shas can always be determinized
in a bottom-up and left-to-right manner. Nwas can also be determinized but
diﬀerently, since their determinization has to deal with top-down processing via
explicit stacks, often leading to a huge size increase.

The availability of dShas for regular path queries gave new hope for the
feasibility of EQA in practice. For this, however, more eﬃcient EQA algorithms
are needed. In particular, the time per event should no more be quadratic in
n and neither should the preprocessing time be cubic in n. Sakho [17] showed
recently that EQA for boolean dSha queries can be done time O(m) per event,
where m is the overall size of the automaton. This improvement relies on the
fact, that the set of accessible states of an dSha can be computed time O(m),
while for dNwas it requires time O(n2) after O(n3) preprocessing, where n the
number of the states of the automaton.

In the present paper, we present a new EQA algorithm for monadic dSha
queries. Our approach is to adapt the general idea’s of Gauwin from dNwas to
dShas. This yields an EQA algorithm in time O(c m) per event where c is the
concurrency c of the query. Gauwin’s quadratic factor n2 is reduced to m while
the cubic preprocessing in time O(n3) is removed. The algorithm obtained is
more eﬃcient than the best previous EQA algorithm, based on a reduction to
Gauwin’s EQA algorithm by compiling dShas to dNwas in linear time.

We implemented our new EQA algorithm in the AStream tool and applied
it the regular XPath queries from the XPathMark collection [5] scaling to huge
documents, and to the regular XPath queries extracted from practical XSLT
programs by Lick and Schmitz [10] but on smaller documents. It turns out that
AStream runs eﬃciently on huge XML documents (>100GB) for all queries with
low concurrency. Some queries can be answered in streaming mode where the
best existing non earliest query answering algorithm failed to be earliest [4].

Outline. We start with preliminaries in Section 2, 3, and 4. An earliest mem-
bership tester for dShas is presented in Section 5 and a late streaming algorithm
for answering monadic queries in Section 6. We then present our new EQA al-
gorithm in Section 7 and discuss experimental results with AStream in Section
8. Complete proofs and supplementary material are given in the appendix.

Earliest Query Answering on Nested Streams

3

2 Preliminaries

Let A and B be sets. A partial function f : A (cid:44)→ B is a relation f ⊆ A × B that
is functional. The domain of a partial function is dom(f ) = {a ∈ A | f (a) ∈ B}.
A total function f : A → B is a partial function f : A (cid:44)→ B with dom(f ) = A.
Let N be the set of natural numbers including 0.
Words. Let alphabet Ω be a set. The set of words over Ω is Ω∗ = ∪∞
n∈NΩn.
A word (a1, . . . , an) ∈ Ωn is written as a1 . . . an. We denote the empty word of
length ε ∈ Ω0 and by v1 · v2 ∈ Ω∗ the concatenation of two words v1, v2 ∈ Ω∗.
For any word v ∈ Ω∗ let prefs(v) ⊆ Ω∗ be the set of its preﬁxes. For any v ∈ Ω∗
and a ∈ Ω let #a(v) be the number of occurrences of a in v.
Hedges. Hedges are sequences of letters and trees (cid:104)h(cid:105) with some hedge h. More
formally, a hedge h ∈ HΩ has the following abstract syntax:

h, h (cid:48) ∈ HΩ ::= ε

| a |

(cid:104)h(cid:105)

| h · h (cid:48)

where a ∈ Ω

We assume ε · h = h · ε = h and (h · h1) · h2 = h · (h1 · h2). Therefore, we consider
any word in Ω∗ as a hedge in HΩ, i.e., Ω∗ (cid:51) aab = a · a · b ∈ HΩ. For any h ∈ HΩ
and a ∈ Ω let #a(h) be the number of occurrences of a in h. The size |h| is the
number of the letters and opening parenthesis of h. The nesting depth d of h
is the maximal number of nested opening parenthesis of trees in h. The set of
positions of a hedge h ∈ HΩ is pos(h) = {1, . . . , |h|}.
Nested Words. Hedges can be identiﬁed with nested words, i.e., words over
alphabet ˆΩ = Ω ∪ {(cid:104), (cid:105)} in which all parentheses are well-nested. This is done
by the function nw (h) : HΩ → (Ω ∪ {(cid:104), (cid:105)})∗ such that: nw (ε) = ε, nw ((cid:104)h(cid:105)) =
(cid:104) · nw (h) · (cid:105), nw (a) = a, and nw (h · h (cid:48)) = nw (h) · nw (h (cid:48)). The set of nested word
preﬁxes is nwprefs Ω = prefs(nw (HΩ)) ⊆ ˆΩ∗. Note that nested word preﬁxes
may lack closing parenthesis, in which case they are not well-nested.
Monadic Queries. Let Σ be a set. A monadic query Q on hedges with signature
Σ is a function that maps any hedge h ∈ HΣ to a subset of its positions Q(h) ⊆
pos(h). We next relate monadic queries on hedges to hedge languages. For this,
we ﬁx a selection variable x (cid:54)∈ Σ arbitrarily and consider hedge languages over
signature Σx = Σ ∪ {x}. For any h ∈ HΣ let ˜h ∈ HΣ∪pos(h) be its annotation
with its positions. For instance (cid:94)aa(cid:104)(cid:105)a = a1a2(cid:104)3(cid:105)a4. For any variable assignment
α : {x} (cid:44)→ pos(h) we deﬁne the hedge h ∗ α ∈ HΣx annotated with x by
substituting in (cid:101)h the position α(x) by x and removing all other positions. For
instance, aa(cid:104)(cid:105)a ∗ [x/2] = aax(cid:104)(cid:105)a. The monadic query on hedges with signature
Σ deﬁned by a hedge language L ⊆ HΣx is qry L(h) = {α(x) | α : {x} →
pos(h), h ∗ α ∈ L}.

3 Stepwise Hedge Automata

We deﬁne regular hedge languages by stepwise hedge automata (dShas).
Deﬁnition 1. A d Sha is a tuple A = (Ω, Q, δ, qinit , F ) where Ω and Q are
ﬁnite sets, qinit ∈ Q, F ⊆ Q, and δ = ((aδ)a∈Ω, (cid:104)(cid:105)δ, @δ) where: aδ : Q (cid:44)→ Q,
(cid:104)(cid:105)δ ∈ Q, and @δ : Q × Q (cid:44)→ Q.

4

A. Al Serhali and J. Niehren

Fig. 1: A dSha for
query
the monadic
on hedges with let-
ters in Σ = {a} that
selects
positions
1, . . . , n − 1 on hedges
of the form an · (cid:104)h(cid:105) · h (cid:48)
if h does not start with
letter “a” and position
n otherwise.

the

a

a

a

x

2

2

2

0

a

9

9

5

1

(cid:104)(cid:105)

a

3

Fig. 2: A successful run of the dSha A in Fig. 1 on aaax(cid:104)a(cid:105)a.

There are states q ∈ Q, an initial state is qinit and ﬁnal states in F . The
transition rules in δ have three forms: If aδ(q) = q(cid:48) then we have an internal rule
q a−→ q(cid:48), if q@δp = q(cid:48) then we have an apply rule q
(cid:104)(cid:105)
then we have a tree initial rule
−→ q. We denote by n = |Q| the number of states
of A, and by m = n + |Ω| + (cid:80)
a∈Ω |aδ| + |@δ| + |F | + 2 its overall size. Note
that m ∈ O(n2 + |Ω| n) by determinism. For any hedge h ∈ HΣ we deﬁne the
: Q (cid:44)→ Q such that for all q ∈ Q, a ∈ Ω, and h, h (cid:48) ∈ HΣ:
transition

q(cid:48), and if q = (cid:104)(cid:105)δ ∈ Q

δ =

h

p

(cid:74)

(cid:75)

h
(cid:74)

(cid:75)

(q) = q

ε
(cid:74)
(cid:75)
h · h (cid:48)
(cid:74)

(q) =

(cid:75)

h (cid:48)

h

(
(cid:74)

(cid:75)

(cid:75)

(cid:74)

(q))

a
(cid:75)
(cid:104)h(cid:105)
(cid:75)

(cid:74)
(cid:74)

(q) = aδ(q)

(q) = q@δ(

((cid:104)(cid:105)δ))

h

(cid:74)

(cid:75)

A hedge is accepted if its transition from the initial state yields some ﬁnal
state. The language L(A) is the set of all accepted hedges: L(A) = {h ∈ HΩ |
(qinit ) ∈ F }. We call a hedge language L ⊆ HΩ regular if it can be deﬁned by
h
(cid:74)
some dSha. A monadic query over hedges in HΣ is called regular if it is equal
to qry L for some regular hedge language L ⊆ HΣx .

(cid:75)

For example let Ω = Σx where Σ = {a}. We draw in Fig. 1 the graph of a
dSha for the query on hedges in HΣ that selects the positions 1, . . . , n − 1 on
hedges of the form an · (cid:104)h(cid:105) · h (cid:48) if h does not start with letter “a” and position n
otherwise. The drawing of dShas are similar as for usual ﬁnite state automata,
except that now, edges may also be labeled by states and not only by letters.

A successful run of this automaton on the hedge aaax(cid:104)a(cid:105)a is given in Fig. 2.
In state 5 the transition must suspend on the result of the evaluation of the

subhedge, which is started by the tree initial rule

(cid:104)(cid:105)
−→ 1. The two edges 5

9

Earliest Query Answering on Nested Streams

5

and 3
in state 5 is resumed in state 9 when going up from the subtree in state 3.

are justiﬁed by the apply rule 5

9: the suspended computation

3

h
(cid:74)

The set of states that are accessible from a state q ∈ Q through some hedge
is accδ(q) = {q(cid:48) | q(cid:48) =
(q), h ∈ HΩ}. For any Q ⊆ Q, the set accδ(Q) can
(cid:75)
be computed in time O(m) as well as invaccδ(Q) = {q(cid:48) | q ∈ accδ(q(cid:48)), q ∈ Q}. A
tree state is a state in P = accδ((cid:104)(cid:105)δ). We call a set of transition rules δ complete
if @δ|Q×P is a total function, as well as all aδ where a ∈ Ω. For instance, the
dSha in Fig. 1 has the tree states P = {1, 3, 7}. Note that δ is not complete
since xδ is not total. But its restriction to the letters in Σ = {a} is complete due
to the sink state 4.

4 Nested Word Automata

We deﬁne streaming algorithms for dShas by inﬁnitary nested word automata
(dNWAs ∞). These have the advantage to run naturally in streaming mode,
while being able to pass information top-down, bottom-up, and left to right. In
contrast, dShas cannot pass any information top-down.

Deﬁnition 2. An dNWA∞ is a tuple B = (Ω, Q, Γ, δ, qinit , F ), where Ω, Γ and
Q are sets, qinit ∈ Q, F ⊆ Q, and δ = ((aδ)a∈Ω, (cid:104)δ, (cid:105)δ) contains partial functions
aδ : Q (cid:44)→ Q, (cid:104)δ : Q (cid:44)→ Γ × Q, and (cid:105)δ : Q × Γ (cid:44)→ Q. A d Nwa is a dNWA∞
whose sets Q, Ω, and Γ are ﬁnite.

The elements of Γ are called stack symbols. The transition rules in δ have
(cid:104)↓γ
three forms: letter rules q a−→ q(cid:48), opening rules q
−−→ q(cid:48) for pushing a stack
(cid:105)↑γ
symbol if (cid:104)δ(q) = (q(cid:48), γ) and closing rules q
−−→ q(cid:48) popping a stack symbol if
(cid:105)δ(q, γ) = q(cid:48). Any dNWA∞ deﬁnes a pushdown machine that runs on words
with parenthesis. A conﬁguration of this machine is a pair in K = Q × Γ ∗ of
a state and a stack. For any word v ∈ ˆΩ∗, we deﬁne a streaming transition
v

str : K (cid:44)→ K such that for all q ∈ Q, stacks s ∈ Γ ∗ and γ ∈ Γ :

v

δ
str =

(cid:74)

(cid:75)

(cid:75)

(cid:74)
str(q, s) = (aδ(q), s)
a
(cid:75)
str(q, s) = (q, s)
ε
(cid:75)
v(cid:48)
v · v(cid:48)
str(q, s) =

(cid:74)
(cid:74)
(cid:74)
A word v ∈ ˆΩ∗ is accepted if

(cid:74)
(cid:74)

(cid:75)

(cid:74)

(cid:105)
(cid:75)
(cid:104)
(cid:75)

str(q, s · γ) = ((cid:105)δ(q, γ), s)
str(q, s) = (q(cid:48), s · γ) where (q(cid:48), γ) = (cid:104)δ(q)

str(q(cid:48), s(cid:48)) where (q(cid:48), s(cid:48)) =
(cid:75)

str(q, s)

v

(cid:74)

(cid:75)

str(qinit , ε) yields a ﬁnal conﬁguration
(cid:75)
in F × {ε}: The language of a dNWA∞ is the set of nested words that it accepts:
L(B) = {v ∈ ˆΩ∗ |
str(qinit , ε) ∈ F × {ε}}. Since the initial and ﬁnal stack are
(cid:75)
required to be empty it follows that any word L(B) is well-nested.

nw (h)

v

(cid:74)

(cid:74)

For any dSha A = (Ω, Q, δ, qinit , F ) we deﬁne the dNwa Anwa = (Ω, Q,
Γ, δnwa , qinit , F ) with Γ = Q such that δnwa contains for all a ∈ Ω and q, p ∈ Q
(cid:105)↑p
the rules q a−→ aδ(q), q
−−→ p@δq. In Fig. 5 we draw a run of the
dNwa Anwa for the dSha in Fig. 1. The graph of this dNwa is in Fig. 6.

(cid:104)↓q
−−→ (cid:104)(cid:105)δ, and q

Lemma 3. L(Anwa ) = nw (L(A)).

6

A. Al Serhali and J. Niehren

Intuitively, the lemma follows since the run of any dSha A can be identiﬁed
with the run of the dNwa Anwa . To illustrate this, we reconsider the run of the
dSha in Fig. 2 and compare it to the run of corresponding dNwa in Fig. 5. The
(cid:104)↓5
transition 5 (cid:57)(cid:57)(cid:75) 1 of Anwa is justiﬁed by the opening rule 5
−−→ 1: when entering
the subtree, the current state 5 is pushed to the stack and the computation is
for the apply rule
continued in state 1. The edges 5
(cid:105)↑5
5@3 → 9 of the dSha are mimicked by the closing rule 3
−−→ 9 of the dNwa:
when going up from the subtree in state 3, the state 5 is popped from the stack
and the computation continues in state 9.

9 and 3

5 Earliest Membership

(cid:74)

δnwa
str

nw (h)
(cid:75)

A late streaming evaluator of a dSha A on hedges h ∈ HΩ can be obtained by
evaluating the dNwa Anwa in streaming mode on the nested word of h, i.e., by
testing
(qinit , ε) ∈ F × {ε}. In this manner, h is never loaded into
the memory. Instead, only a state and a stack are stored at any event, i.e. at any
preﬁx of nw (h). The memory costs thus only depend on the depth of the hedge.
The decision of whether membership holds, however, is taken at the very end
of the stream. Instead, we want to decide language membership at the earliest
event when it becomes certain. We consider Σ-certain membership to languages
L ⊆ HΩ where Ω ⊇ Σ as needed for certain query answering later on.

Deﬁnition 4. Let Σ ⊆ Ω and L ⊆ HΩ. A nested word preﬁx v with letter in Ω
satisﬁes cert-mem L

Σ(v) if ∀h ∈ HΩ. (∃w ∈ ˆΣ∗. v · w = nw (h)) → h ∈ L.

In other words, a nested word preﬁx v is Σ-certain for membership in L ⊆
HΩ, if any completion of v with letters from Σ to a hedge in HΩ belongs to L.
For instance, if Σ = {a} then the preﬁx v = aaax(cid:104)a is Σ-certain for the language
of the dSha A with signature Ω = {a, x} in Fig. 1, since any completion of v
without further x’es will be accepted by A.

Since certain membership is a universality property, we need to consider
universal automata states. Given a state q ∈ Q let A[qinit /q] = (Ω, Q, δ, q, F ) be
obtained from A by replacing its initial state by q. We deﬁne:

q ∈ universal A

Σ ⇔ HΣ ⊆ L(A[qinit /q])

In order to characterize universality by accessibility, we deﬁne for all Q ⊆ Q:

safeδ(Q) = {q ∈ Q | accδ(q) ⊆ Q}

If δ is complete then safeδ(Q) = Q \ invaccδ(Q \ Q), so it can be computed in
O(m). For any Σ ⊆ Ω, let δ|Σ be the restriction of δ to the letters of Σ, i.e.,
δ|Σ = ((aδ)a∈Σ, (cid:104)(cid:105)δ, @δ).

Lemma 5. Let A = (Ω, Q, δ, qinit , F ) be a d Sha and Σ ⊆ Ω such that δ|Σ is
complete, and q ∈ Q. Then: q ∈ universal A

Σ ⇔ q ∈ safeδ|Σ (F ).

Earliest Query Answering on Nested Streams

7

Safety can be used to detect certain language membership. For this we deﬁne

for any Q ⊆ Q and q ∈ Q such that q@δp is well-deﬁned for some p ∈ Q:

dδ(q, Q) = safeδ(dn@δ (q, Q)) where dn@δ (q, Q) = {p ∈ Q | q@δp ∈ Q}.

Note that if q@δp is undeﬁned for all p then dδ(q, Q) remains undeﬁned too. We
deﬁne the dNwa Ac

Σ for testing certain Σ-membership to L(A) as follows.

Qc

Σ = Q × 2Q = Γ c
Σ,

qinit

c

Σ = (qinit , safeδ|Σ (F )).

The transition rules in δc

Σ allow for all S ⊆ Q, q, p ∈ Q, and a ∈ Ω:

(q, S)

(cid:104)↓(q,S)
−−−−→ ((cid:104)(cid:105)δ, dδ|Σ (q, S)), p

(cid:105)↑(q,S)
−−−−→ (q@δp, S),

(q, S) a−→ (aδ(q), S).

Σ, Γ c

Finally, let Ac
component Ac
safety information. Therefore, L(A) = L(Anwa ) = L(Ac
the streaming evaluator of Ac

Σ = F × 2Q. In the ﬁrst
Σ = (Ω, Qc
Σ behaves like Anwa , while in the second component it computes
Σ). We next show that

Σ detects certain membership at any time.

Σ) where F c

Σ, qinit

Σ, F c
c

Σ, δc

c

(cid:74)

v

δc
str(qinit
Σ
(cid:75)

Σ (v) ⇔ q ∈ S.

Proposition 6. Let A = (Ω, Q, δ, qinit , ) be a d Sha, v ∈ nwprefs Ω a nested
word preﬁx, and Σ ⊆ Ω such that δ|Σ is complete. If q ∈ Q and S ⊆ Q such
Σ, ε) then: cert-mem L(A)
that ((q, S), ) =
We illustrate Proposition 6 in Fig. 7 at the dSha A from Fig. 1. Recall
that it has signature Ω = Σx where Σ = {a}. Given that δ|Σ is complete, Σ-
certain membership of aaax(cid:104)a(cid:105)a to L(A) can be detected at the earliest event
aaax(cid:104)a, by running the streaming evaluator of earliest automaton Ac
Σ. Note that
the earliest automaton is a dNwa passing safety information top-down (while
dShas cannot pass any information top-down). We have safeδ|Σ ({9}) = {9}
δc
and dδ|Σ (5, {9}) = {3}. Hence
c
Σ) = ((1, {3}), s) where the stack
str(qinit
Σ
(cid:75)
is s = (5, {9}). Since 1 (cid:54)∈ {3}, membership is not yet Σ-certain. Indeed, the
Σ-completion aaax(cid:104)(cid:105) is not accepted. After reading the next letter a, we have
δc
str = ((3, {3}), s). Since the current state 3 belongs to the current set
aaax(cid:104)a
Σ
(cid:74)
(cid:75)
of safe states {3}, membership is Σ-certain, i.e., membership of all completions
without further x’es.

aaax(cid:104)

(cid:74)

6 Late Monadic Query Answering

We study the problem of how to answer monadic queries on hedges in streaming
mode, while selecting query answers lately at end of the stream.

Our algorithm will generate candidates [x/π] binding the selection variable x
to positions π of the input hedge. We want to formulate the streaming algorithm
without ﬁxing the input hedge a priori, thus we consider the inﬁnite set of
candidates Cands = {α | α : {x} (cid:44)→ N}. Given a dSha A with signature Σx and
a hedge h ∈ HΣ, our algorithm computes the answer set qry L(A)(h) in streaming
mode. For this, we compile A to the late dNWA∞ Al and run the streaming

8

A. Al Serhali and J. Niehren

0[]∅

a

2[]∅
5[x/1]∅

a

D

4[]∅
9[x/2]∅
4[x/1]∅

4 = 2@δ 3
9 = 8@δ 3
4 = 5@δ 3

D=






2[]∅
8[x/1]∅
5[x/2]∅

@
@
@

3[]∅
3[x/1]{x}
3[x/2]{x}






= E

↓D

↑D

1[]∅
1[x/1]{x}
1[x/2]{x}

a

E

Fig. 3: The run of the late dNwa Al for the dSha A in Fig. 1 on aa(cid:104)a(cid:105).

evaluator of Al on the nested word (cid:94)nw (h). The aphabet of Al is Σ ∪ N. It has the
state set Ql = 2Q×Cands×2{x}
init = {(qinit , [], ∅)}.
If the evaluator goes into some state D ∈ Ql, then (q, α, V ) ∈ D means that
the candidate α is in state q with Anwa while the variables in V ⊆ dom(α) were
bound in the context, i.e., before the last dangling opening parenthesis (so a
preceding node that is not a preceding sibling). The set δl contains the following
transition rules for all D, E ∈ Ql, a ∈ Σ, V ⊆ {x}, and π ∈ N:

= Γ l and the initial state ql

D a−→ {(aδ(q), α, V ) | (q, α, V ) ∈ D}
D π−→ {(xδ(q), [x/π], ∅) | (q, [], ∅) ∈ D} ∪ D
(cid:104)↓D
−−→ {((cid:104)(cid:105)δ, α, dom(α)) | (q, α, V ) ∈ D}
D
(cid:105)↑D
−−→ {(q@δp, α(cid:48), V ) | (q, α, V ) ∈ D, (p, α(cid:48), dom(α)) ∈ E, α ∈ {[], α(cid:48)}}

E

When reading a position π ∈ N in a state D that contains a triple with the empty
candidate (q, [], ∅), a new candidate [x/π] is created, and the triple (xδ(q), [x/π], ∅)
is added to D. At opening events, the current state D of Al is pushed onto the
stack. It is also updated for continuation: if D contains a triple with candidate α,
then the next state of Al contains ((cid:104)(cid:105)δ, α, dom(α)). At closing events, the state
D of the parent hedge is popped from the stack. Let E be the current state.
Any (q, α, V ) ∈ D must be matched with some (p, α(cid:48), dom(α)) ∈ E, so that Al
can continue in q@δp. Matching here means that either α = α(cid:48) or, α(cid:48) = [x/π]
and α = []. This is expressed by the condition α ∈ {[], α(cid:48)}. Note that if α = []
matches α(cid:48) = [x/π] then dom(α) = ∅ so that π was not bound in the context.
This is where the knowledge on the context is needed.

An example run of Al on the hedge aa(cid:104)a(cid:105) is given in Fig. 3, where A
is the dSha A from Fig. 1. The tuples are written there without commas
and parenthesis. The run of Al ﬁrst consumes aa and goes into state D =
{(2, [], ∅), (8, [x/1], ∅), (5, [x/2], ∅)}. It contains the candidates [x/1] and [x/2] for
the two leading a position, plus the empty candidate []. After the following open
parenthesis (cid:104), the run goes into the set {(1, [], ∅), (1, [x/1], {x}), (1, [x/2], {x})}.
The state of each of the candidates got set to (cid:104)(cid:105)δ = 1. Furthermore, the set
memoizes that the candidates [x/1] and [x/2] were bound in the context. It then
consumes the letter a and reaches E = {(3, [], ∅), (3, [x/1], {x}), (3, [x/2], {x})}.

Earliest Query Answering on Nested Streams

9

When reading the closing parenthesis D is popped from the stack, its tuples
in state q are matched with tuples in state p those from with E as illustrated
in the ﬁgure, so that one can apply the apply rules q@δp of A. The tuple in
state 5 of D, for instance, matches the tuple in state 3 of E, so Al continues
the candidate [x/2] in state 9 = 5@δ3. Since 9 ∈ F A, position 2 is selected, i.e.
2 ∈ qry L(A)(aa(cid:104)a(cid:105)).

Proposition 7 (Correctness of the late streaming evaluator). If (D, ε) =
nw (˜h)
init , ε) then qry L(A)(h) = {π | (q, [x/π], ∅) ∈ D, q ∈ F }.
(cid:74)

δl
str(ql
(cid:75)

7 Certain Answers and Earliest Query Answering

In order to justify early selection, we need the concept of certain answers. Let
Q be a monadic query on HΣ and v ∈ nwprefs Σ a nested word preﬁx.
Deﬁnition 8. A position π ∈ N is a certain answer of Q at preﬁx v – written
π ∈ CAQ(v) – if π ∈ pos(v) ∧ ∀h ∈ HΣ. v ∈ prefs(nw (h)) → π ∈ Q(h).

A position π is thus a certain answer of query Q at preﬁx v of the stream
if it answers the query for all completions h of v. Certain answers can be safely
selected however the stream continues. For instance, the position 3 is a certain
answer on the preﬁx aaa(cid:104)a for the query deﬁned by the dSha in Fig. 1.

In analogy we can deﬁne that π is certainly a nonanswer of Q at v, and
denote this by π ∈ CNAQ(v). Once π becomes a certain nonanswer then it can
be safely rejected. The positions 1, ..., n − 1, for instance, are certain nonanswers
on our example query on an(cid:104)a. We call a position π alive for Q at v it it is
neither a certain answer nor a certain nonanswer of Q at v. The concurrency
c of Q at v is its number of alive candidates. For the shorter preﬁx aaa(cid:104), for
instance, all n positions 1, . . . , n are alive, so the concurrency is n.

We next want to link certain answers to certain Σ-membership. For this we
need to annotate nested word preﬁxes with positions and variables, similarly
as for hedges. Given a word v ∈ ˆΣ, the set of positions of v then is pos(v) =
{1, . . . , #Σ∪{(cid:104)}(v)}. We can deﬁne the annotation of v with its positions as a
word (cid:101)v ∈ ( (cid:98)Σ ∪ pos(v))∗. For any variable assignment α : {x} (cid:44)→ pos(v) we deﬁne
an annotated word v ∗ α ∈ (cid:99)Σx

in analogy as for hedges.

∗

Lemma 9. For any preﬁx v ∈ prefs(nw (HΣ)), language L ⊆ HΣx and candi-
date α = [x/π] with π ∈ pos(v): cert-mem L

Σ(v ∗ α) ⇔ π ∈ CAqry L(v).

Proposition 10 (Corollary of Proposition 6 and Lemma 9). Let A =
(Σx, , δ, qinit , ) be a d Sha such that δ|Σ is complete. For any v ∈ nwprefs Σ,
δc
Σ, ε): π ∈ CAqry L(A) (v) ⇔ q ∈ S .
str(qinit
π ∈ pos(v), and ((q, S), ) =
Σ
For any dSha A over Σx, we construct the earliest dNWA∞ Ae with alphabet
Σ ∪ N, testing for all candidates [x/π] on preﬁxes (cid:101)v, whether π is certain for
selection. For this Ae simulates the runs of Ac
Σ on all v ∗ [x/π]. It has the states
init = {(qinit , [], ∅, safeδ|Σ (F ))}. Initially,
Qe = Q × Cands × 2{x} × 2Q = Γ e and qe

v ∗[x/π]
(cid:75)
(cid:74)

c

10

A. Al Serhali and J. Niehren

0[]∅{9}

a

2[]∅{9}
5[x/1]∅{9}

a

2[]∅{9}
5[x/2]∅{9}
8[x/1]∅{9}

4[]∅{9}
9[x/2]∅{9}
4[x/1]∅{9}

1[]∅∅
1[x/2]{x}{3}
1[x/1]{x}{7}

a

3[]∅∅
3[x/2]{x}{3}
3[x/1]{x}{7}

Fig. 4: A run of the earliest automaton Ae for the dSha A in Fig. 1.

all states in safeδ|Σ (F ) are safe for selection. Let δe contain the following rules
for all M, N ∈ Qe, a ∈ Σ, π ∈ N, S ⊆ Q and q ∈ Q:

M a−→ {(aδ(q), α, V, S) | (q, α, V, S) ∈ M }
M π−→ {(xδ(q), [x/π], ∅, S) | (q, [], ∅, S) ∈ M } ∪ M
M

(cid:104)↓M
−−−→ {((cid:104)(cid:105)δ, α, dom(α), dδ|Σ (q, S)) | (q, α, V, S) ∈ M }
(cid:105)↑M
−−−→ ({(q@δp, α(cid:48), V, S) | (q, α, V, S) ∈ M, (p, α(cid:48), dom(α), S(cid:48)) ∈ N, α ∈ {[], α(cid:48)}}

N

For the dSha A in Fig. 1, for instance, a run of Ae is given in Fig. 4. It sat-
init , ε) = ({(3, [x/2], {x}, {3, 4}), (3, [x/1], {x}, {4, 9})}, ).
isﬁes
The certain answer [x/2] is in a safe state now, while the other candidate [x/1]
can be seen to be safe for rejection so it could be removed.

a1a2(cid:104)3a4
(cid:75)

δe
str(qe

(cid:74)

Proposition 11. Let A be a d Sha with signature Σx such that δ|Σ is complete.
For any nested word preﬁx v ∈ nwprefs Σ with

init , ε) = (M, ):

δe
str(qe
(cid:101)v
(cid:75)

(cid:74)

CAqry L(A) (v) = {α(x) | q ∈ S ∧ (q, α, ∅, S) ∈ M ∧ dom(α) = {x}}

We can thus obtain an EQA algorithm by running the streaming evaluator
of the earliest automaton Ae. Without removing candidates that are certainly
nonanswers, however, it would maintain and update many candidates that are
no more alive, leading to quadratic time in O(m2) even for bounded concurrency.

Theorem 1. EQA for monadic d Sha queries can be done in time O(c m) per
event, where c is the concurrency of the query at the event.

This complexity for dShas improves on Gauwin et al. [6] for dNwas, which
required time O(c n2) per event after O(n3) preprocessing time. Note also that
EQA for monadic queries can also be used to detect certain membership for
language of dShas. In this case, we have c = 1 so the time per event is reduced
to O(m). Finally, for monadic queries where c is bounded for all events and input
hedges, the complexity per event is also reduced to O(m).

Earliest Query Answering on Nested Streams

11

8 Experimentation

We present experimental results of our EQA algorithm that we implemented in
the AStream tool, with current version 3.36. The objective is to relate the theo-
retical complexity to practical eﬃciency. We note that we implemented AStream
in Scala while using Java’s abc-datalog for safety computation.

First, we consider a collection of 77 regular XPath queries [1] that was se-
lected from the larger collection of XPath queries harvested by Lick and Schmitz
[10] from real-world XSLT program. The queries are listed in Table 2. A single
matching XML document per XSLT program of size less than 2MB was provided
too. We used the dShas for these XPath queries from [1] as inputs (so the time
for the automaton construction is ignored here). We could correctly answer all
the 77 queries, yielding the same answer set as with Saxon. The overall time
for computing the 77 answer sets was in 1:50 minute on a Macbook pro Apple
M1 laptop with 16GB of RAM. With Saxon in-memory evaluation it required
0:45 minutes. The low running time of AStream reﬂects the low concurrency of
all the queries on all these documents according to Theorem 1. There are 12
queries with concurrency 1, 47 with concurrency 2, 6 with concurrency 3, and
12 with concurrency 4. Our eﬃciency results for AStream thus show for the
ﬁrst time, that EQA is indeed feasible in practical scenarios with queries of low
concurrency.

Second, we compare AStream to existing streaming tools for regular XPath
queries with large coverage. We focus on the most eﬃcient streaming evaluator
called QuiXPath [4]. A detailed comparison to the many alternative tools is given
there too. We note that QuiXPath is not always earliest, but still earliest in most
cases. As done there, we consider the queries A1-A8 of the XPathMark collection
[5], see Table 1. The other queries are either not regular or contain backward
axis that our compiler to Shas does not support. We also added the queries O1
and O2 from [4], in order to illustrate diﬃculties of non-earliest query answering
and high concurrency. The XPathMark collection also provides a generator for
scalable XML documents. We run AStream on XML documents of increasing
size up to 1.2GB, but can also stream much larger documents >100GB. Up to
1GB we veriﬁed the correctness of the answer sets by comparison to Saxon’s
inmemory evaluator (which is limited to 1GB).

The running times on the scaling documents are reported in Fig. 8. The
times grow linearly for all these queries except O1, given that their concurrency
is bounded to 2. In contrast the time grows quadratically for query O1, since its
concurrency grows linearly with the size of the document. The quadratic growth
can be observed more clearly in Fig. 9 on smaller documents scaling from 27KB
to 5MB. In average on the XPathMark queries A1-A8, AStream 3.36 is by a
factor of 60 slower than QuiXPath, so requiring minutes instead of seconds. The
main reason for this is the lack of streaming projection algorithms for dShas.
In contrast, QuiXPath uses streaming projection for queries deﬁned by dNwas
with selection states [18]. On the one hand side, QuiXPath cannot stream query
O2 on large documents, since not being earliest. While the concurrency of O2 is
1, linearly many candidates are buﬀered by QuiXPath, until the buﬀer overﬂows

12

A. Al Serhali and J. Niehren

for documents larger than 5GB. For AStream’s EQA algorithm, this query is
not a problem since having low concurrency. On the other hand, QuiXPath can
stream queries with high concurrency such as O1, where AStream 3.36 runs out
of time for documents of 1MB. This is due to QuiXPath’s state sharing, i.e. the
sharing of the computations of all concurrent candidates in the same state.
Conclusion and Future Work. We introduced an EQA algorithm for regular
monadic queries represented by dShas with a time complexity of O(c m) per
event. Its implementation in the AStream tool has demonstrated its eﬃciency on
queries in practical scenarios with low concurrency. However, in order to compete
with the current best non-earliest streaming algorithms, we need to develop
streaming projection for dShas (as done previously for NWAs [18]), and to add
some kind of factorization for candidates in the same state [4]. Additionally,
we plan to extend our streaming algorithm to hyperstreaming, which involves
handling multiple streams with references and holes [17].

References

1. A. Al Serhali and J. Niehren. A Benchmark Collection of Deterministic Automata
for XPath Queries. In XML Prague 2022, Prague, Czech Republic, June 2022.

2. R. Alur. Marrying words and trees. PODS 2007.
3. M. Benedikt, A. Jeﬀrey, and R. Ley-Wild. Stream Firewalling of XML Constraints.

In Proc. ACM SIGMOD Int. Conf. Manag. Data, 2008.

4. D. Debarbieux, O. Gauwin, J. Niehren, T. Sebastian, and M. Zergaoui. Early
nested word automata for XPath query answering on XML streams. TCS 2015.
5. M. Franceschet. XPathMark performance test. https://users.dimi.uniud.it/

~massimo.franceschet/xpathmark/PTbench.html. Accessed: 2020-10-25.

6. O. Gauwin, J. Niehren, and S. Tison. Earliest query answering for deterministic

nested word automata. In FCT 2009.

7. A. Grez, C. Riveros, and M. Ugarte. A formal framework for complex event pro-

cessing. ICDT 2019, pages 5:1–5:18, 2019.

8. M. Kay. Streaming in the saxon XSLT processor. In XML Prague, pages 81–101,

2014.

9. L. Libkin. How to deﬁne certain answers. In IJCAI 2015.

10. A. Lick and S. Sylvain. XPath Benchmark, Last visited April 13th 2022.
11. B. Mozafari, K. Zeng, and C. Zaniolo. High-performance complex event processing

over XML streams. SIGMOD Conference. ACM, 2012.

12. M. Mu˜noz and C. Riveros. Streaming enumeration on nested documents. ICDT

2022.

13. J. Niehren and M. Sakho. Determinization and minimization of automata for

nested words revisited. Algorithms, 14(3):68, 2021.

14. J. Niehren, M. Sakho, and A. A. Serhali. Schema-based automata determinization.

GandALF 2022.

15. A. Okhotin and K. Salomaa. Complexity of input-driven pushdown automata.

SIGACT News, 45(2):47–67, 2014.

16. D. Olteanu. SPEX: Streamed and progressive evaluation of XPath. IEEE Trans.

on Know. Data Eng., 19(7):934–949, 2007.

17. M. Sakho. Certain Query Answering on Hyperstreams. Theses, July 2020.
18. T. Sebastian and J. Niehren. Projection for nested word automata speeds up xpath

evaluation on XML streams. In SOFSEM 2016.

Earliest Query Answering on Nested Streams

13

A Proofs for Section 2 (Preliminaries)

Also, we deﬁne for any n ∈ N a hedge (cid:101)hn ∈ HΣ∪{n,...,n+|h|−1} by induction on
the structure of h:

(cid:101)εn = ε, (cid:101)an = a · n, (cid:93)h · h (cid:48)

n

= (cid:101)h n · (cid:101)h (cid:48)

n+|h|

n
, (cid:103)(cid:104)h(cid:105)

= (cid:104)n · (cid:101)h n+1 · (cid:105)

We then set (cid:101)h = (cid:101)h1. That is: h ∗ α = (cid:101)h[α(x)/x][π/ε | π (cid:54)= α(x)]

B Proofs for Section 3 (Stepwise Hedge Automata)

Accessibility can be deﬁned equivalently by the following inference rules:

q a−→ q(cid:48) a ∈ Ω
q(cid:48) ∈ accδ(q)

q1@δp = q2

p ∈ accδ((cid:104)(cid:105)δ)
q2 ∈ accδ(q)

q1 ∈ accδ(q)

For completing transition rules in linear time generally, we need to add else rules
q −−→ q(cid:48) that represent a set of |Ω| internal rules and apply else rules q
q(cid:48)
that can represent a set of n apply rules. When doing so, m = n2 +|Ω| n remains
possible after completion.

-

C Proofs for Section 4 (Nested Word Automata)

Alternatively, dNWAs ∞can also directly be run on hedges rather than on nested
words. For this, we deﬁne transitions
: Q (cid:44)→ Q for any hedge h ∈ HΣ,
such that for all q ∈ Q:

δ =

h

h

(cid:74)

(cid:74)

(cid:75)

(cid:75)

(q) = q
(q) = aδ(q)

ε
(cid:75)
a
(cid:75)

(cid:74)
(cid:74)

h · h (cid:48)
(cid:104)h(cid:105)

(q) =
(cid:75)
(cid:74)
(q) = (cid:105)δ(

(cid:74)
(cid:74)
str(q, ε) = (
(cid:75)

(cid:75)

h

(cid:74)

(cid:75)

h (cid:48)
(cid:75)
h
(cid:75)
(cid:74)
(q), ε).

Lemma 12.

nw (h)

(cid:74)

(q))

(
h
(cid:74)
(q(cid:48)), γ) where (q(cid:48), γ) = (cid:104)δ(q)

(cid:75)

Proof. First, we prove a more general equality for any dNWA∞ B = (Ω, Q, Γ, δ, qinit , F )
and for all h ∈ HΩ, q ∈ Q and s ∈ Γ ∗ such that:

nw (h)
(cid:75)

(cid:74)

δ
h
str(q, s) = (
(cid:74)

δ(q), s)
(cid:75)

The proof is done by induction on the structure of h. Let s ∈ Γ ∗ and q ∈ Q

be arbitrary, we then distinguish four cases of h:

Case h = ε. So nw (h) = ε, we then have:

nw (h)

(cid:74)

(cid:75)

str(q, s) =

ε
(cid:75)

ε
str(q, s) = (q, s) = (
(cid:74)

(cid:74)

(q), s) = (
(cid:74)

h
(cid:75)

(cid:75)

(q), s)

Case h = a. With nw (h) = a, we have :

nw (h)

(cid:74)

(cid:75)

str(q, s) =

str(q, s) = (aδ(q), s) = (
a
(cid:74)
(cid:75)

(cid:74)

a
(cid:75)

(q), s) = (
(cid:74)

h
(cid:75)

(q), s)

14

A. Al Serhali and J. Niehren

a

a

a

x

2

2

2

0

a

9

5

1

↓ 5

↑ 5

a

9

3

Fig. 5: A successful run of the dNwa Anwa in Fig. 6 on aaax(cid:104)a(cid:105)a.

Case h = h1 · h2. Thus, nw (h) = nw (h1) · nw (h2). The induction hypothesis
str(q, s) = (

applied to h1 yields

(q), s). Hence:

h1

nw (h)
(cid:75)
(cid:74)

nw (h1)
(cid:75)

(cid:74)

(cid:75)
(cid:74)
str(q, s) =
str(q, s)
nw (h1) · nw (h2)
(cid:75)
(cid:74)
nw (h2)
(q), s)
h1
str(
=
(cid:75)
(cid:74)
(cid:75)
(cid:74)
(q)), s)
h1
(
h2
= (
(cid:75)
(cid:75)
(cid:74)
(cid:74)
h1 · h2
= (
(q), s)
(cid:74)
(cid:75)
(q), s)
h
= (
(cid:75)
(cid:74)

streaming transition
induction on h2
Nwa transition

Case h = (cid:104)h1(cid:105) : We have nw (h) = (cid:104) · nw (h1) · (cid:105). Let (q(cid:48), γ) = (cid:104)δ(q), thus:

nw (h)
(cid:75)
(cid:74)

(cid:105)δ
nw (h1)
str(
str(q, s) =
(cid:74)
(cid:75)
(cid:74)
(cid:105)δ
nw (h1)
str(
=
(cid:74)
(cid:75)
(cid:74)
(cid:105)δ
h1
str(
=
(cid:74)
(cid:75)
(cid:74)
= ((cid:105)δ(
(q(cid:48)), γ), s)
h1
(cid:74)
(cid:75)
(cid:104)h1(cid:105)
= (
(q), s)
(cid:75)
(q), s)
h
= (
(cid:75)

(cid:74)
(cid:74)

(cid:104)
str(
(cid:75)
(cid:75)
(cid:74)
str(q(cid:48), s · γ))
(cid:75)
(q(cid:48)), s · γ)
(cid:75)

str(q, s))) streaming transition
with (q(cid:48), γ) = (cid:104)δ(q)
induction on h1
streaming transition
Nwa transition

For s = ε, our lemma holds.

Lemma 13. The language of nested words accepted by a dNWAs ∞satisﬁes:

L(B) = {nw (h) | h ∈ HΩ,

h

(qinit ) ∈ F }

(cid:75)
Proof. This follows immediately from Lemma 12.

(cid:74)

Lemma 3. L(Anwa ) = nw (L(A)).

Proof. Based on Lemma 13 it is suﬃcient to show that:

L(A) = {h ∈ HΩ |

h
(cid:74)

δnwa
(cid:75)

(qinit ) ∈ F }

This follows from
prove this by induction on the structure of h.

h
(cid:75)

δ(q) =

h

(cid:74)

(cid:75)

(cid:74)

δnwa

(q) for all hedge h ∈ HΩ and q ∈ Q. So we

Case h = ε.
Case h = a.

δ(q) =
h
(cid:75)
(cid:74)
δ(q) =
h
(cid:75)
(cid:74)

δnwa
δ(q) = q =
ε
(cid:75)
(cid:75)
δ(q) = aδ(q) =
a
(cid:75)

a
(cid:75)

ε

(cid:74)

(cid:74)

(cid:74)
(cid:74)

(q) =
δnwa

h
(cid:75)
(cid:74)
(q) =

(q)
δnwa

(q)

δnwa

h
(cid:75)

(cid:74)

Earliest Query Answering on Nested Streams

15

Fig. 6: The dNwa Anwa for the dSha in Fig. 1.

Case h = h1 · h2. With the induction hypothesis applied to h1 yields

h1
(cid:74)

δ(q) =
(cid:75)

δnwa

(q):

h1

(cid:74)

(cid:75)

h
(cid:75)
(cid:74)

δ(q)
h1 · h2
(cid:75)
δ(
h1
h2
(cid:75)
(cid:75)
(cid:74)
δnwa
h1
(
h2
(cid:75)
(cid:74)
δnwa
h1 · h2
(cid:75)
δnwa
h
(q)
(cid:75)
Case h = (cid:104)h1(cid:105) : Let ((cid:104)(cid:105)δ, q) = (cid:104)δ(q) by the rules of Anwa , thus:

Sha transition
(q)) induction on h2
Nwa transition

δ(q) =
=
=
=
=

(q))
δnwa

(cid:74)
(cid:74)
(cid:74)
(cid:74)
(cid:74)

(cid:75)
(q)

δnwa

δnwa

h
(cid:75)

(cid:74)

(q) =

δnwa

(q)
((cid:104)(cid:105)δ), q) Nwa transition
induction on h1
Anwa rules
Sha transition

δ((cid:104)(cid:105)δ), q)
δ((cid:104)(cid:105)δ))

δnwa

(cid:104)h1(cid:105)
(cid:75)
(cid:74)
= (cid:105)δ(
h1
(cid:75)
(cid:74)
= (cid:105)δ(
h1
(cid:75)
(cid:74)
= q@δ(
h1
(cid:75)
(cid:74)
δ(q)
=
(cid:104)h1(cid:105)
(cid:74)
(cid:75)
δnwa
(q)
h
=
(cid:75)
(cid:74)

D Proofs for Section 5 (Earliest Membership)

Lemma 5. Let A = (Ω, Q, δ, qinit , F ) be a d Sha and Σ ⊆ Ω such that δ|Σ is
complete, and q ∈ Q. Then: q ∈ universal A

Σ ⇔ q ∈ safeδ|Σ (F ).

16

A. Al Serhali and J. Niehren

Proof. Let q ∈ Q and Σ ⊆ Ω. For the direction “⇐” we assume that q ∈
safeδ|Σ (F ). To show q ∈ universal A
Σ, we have to show for any h ∈ HΣ that
h ∈ L(A[qinit /q])). So let h ∈ HΣ be arbitrary. Since δ|Σ is complete, there exists
(q). Hence, q(cid:48) ∈ accδ(q). Since q ∈ safeδ|Σ (F ), this implies q ∈ F and
q(cid:48) =
so h ∈ L(A[qinit /q])). For the direction “⇒” we assume that q ∈ universal A
Σ. So
(q) ∈ F . Hence accδ|Σ(q) ⊆
HΣ ⊆ L(A[qinit /q]), i.e., for any h ∈ HΣ we have
F , i.e., q ∈ safeδ|Σ (F ).

h

h

(cid:74)

(cid:75)

(cid:75)

(cid:74)

Proposition 6. Let A = (Ω, Q, δ, qinit , ) be a d Sha, v ∈ nwprefs Ω a nested
word preﬁx, and Σ ⊆ Ω such that δ|Σ is complete. If q ∈ Q and S ⊆ Q such
Σ, ε) then: cert-mem L(A)
that ((q, S), ) =

Σ (v) ⇔ q ∈ S.

v

c

δc
str(qinit
Σ
(cid:75)

(cid:74)

(cid:75)

Σ, ε) for some stack s ∈ (Γ c
c

Proof. Nested word preﬁxes may contain dangling opening parenthesis but no
dangling closing parenthesis. We prove the equivalence for all v and A by in-
duction on the number of dangling opening parenthesis in v. So let ((q, S), s) =
δc
Σ)∗.
str(qinit
v
Σ
(cid:74)
In the base case, v does not have dangling opening parenthesis, so v is well-
nested. The transition rules of δc
Σ change the states in the ﬁrst component in
the same manner than δ. Furthermore, the subset S of target states in the sec-
ond component remains unchanged when reading letters in Ω. The same holds
when processing trees (cid:104)w(cid:105) where w is well-nested: the target set S is pushed
to the stack at the opening parenthesis and popped from the stack at the clos-
δc
c
ing parenthesis for continuation. Therefore the assumption
Σ, ε) =
str(qinit
Σ
((q, S), s) implies that S = safeδ|Σ (F ), s = ε and
δ(qinit ) = q. Hence,
(cid:75)
cert-mem L(A)
Σ (v) ⇔ HΩ ⊆ L(A[qinit /q]). By Lemma 5 and the completeness
of δ|Σ, this is equivalent to q ∈ safeδ|Σ (F ) and thus to q ∈ S.

v

v

(cid:75)

(cid:74)

(cid:74)

(cid:74)

v1

(cid:104)
(cid:74)

δc
str((qinit
Σ
(cid:75)

For the induction step, we consider a nested word preﬁx v with at least one
dangling opening parenthesis. We split v at the ﬁrst dangling parenthesis such
that v = v1 · (cid:104) · v2 for some v1 and v2. This implies that v1 ∈ nw (HΩ) in contrast
c
to v2. Let ((q1, S1), s1) =
Σ, ε). Since the word v1 is well-nested, we
will reach the ﬁrst dangling parenthesis with the empty stack, so s1 = ε and S1 =
safeδ|Σ (F ). Reading the ﬁrst dangling opening parenthesis in this conﬁguration
δc
str((q1, S1), ε) = ((t, S2), γ) where S2 = dδ|Σ (q1, S1) and γ = (q1, S1).
yields
Σ
(cid:75)
Let A2 = A[qinit /(cid:104)(cid:105)δ, F/F2)] where F2 = dn@δ (q1, S1). Let I = ((cid:104)(cid:105)δ, safeδ|Σ (F2))
Σ. Note that safeδ|Σ (F2) = dδ|Σ (q1, S1). The assumption
c
be the initial state of A2
δc
c
str(I, γ) = ((q, S), s). Since the ﬁrst
v2
Σ, ε) = ((q, S), s) implies:
v
Σ
(cid:74)
(cid:74)
dangling opening parenthesis of v will never be closed, the ﬁrst stack symbol
γ is never popped when reading v2, so we have s = γ · s(cid:48) for some stack s(cid:48).
δc
str(I, ε) = ((q, S), s(cid:48)). Hence,
Therefore, γ can be canceled out, showing:
v2
Σ
(cid:75)
(cid:74)
Σ (w) is equivalent to cert-mem L(A2)
cert-mem L(A)
(w2). By induction hypothesis
applied to v2 and A2, this is equivalent to q ∈ S.

δc
str(qinit
Σ

Σ

(cid:75)

(cid:75)

Earliest Query Answering on Nested Streams

17

0{9}

a

2{9}

a

2{9}

a

x

2{9}

5{9}

9{9}

a

9{9}

↓ 5{9}

↑ 5{9}

1{3}

a

3{3}

Fig. 7: A successful run of the dNwa Ac

Σ on aaax(cid:104)a(cid:105)a.

E Proofs for Section 6 (Late Monadic Query Answering)

The correctness of the late automaton is stated by the following lemma.

Lemma 14.

(cid:101)h
(cid:74)

δl
(cid:75)

(ql

init ) = {(q, α, ∅) | q =

h ∗ α

(cid:74)

(cid:75)

δ(qinit ), α : {x} (cid:44)→ pos(h)}}

Proof. We call a state D ∈ Ql admissible if any (q, α, V ) ∈ D satisﬁes V ⊆
init via δl are admissible. For any
dom(α). Note that all states accessible from ql
n ∈ N and variable assignment α : {x} (cid:44)→ {n, . . . , n + |h| − 1} we deﬁne a
hedge h ∗n α ∈ HΣx by substituting in (cid:101)hn the position α(x) if deﬁned by x and
removing all other positions:

h ∗n α = (cid:101)h n[α(x)/x][π/ε | π (cid:54)= α(x)]

Clearly, h ∗ α = h ∗1 α. We call a state D ∈ Ql applicable to h with oﬀset n
if ( , [x/π], V ) ∈ D implies π < n. We will prove for all h ∈ HΣ, n ∈ N, and
admissible states D ∈ Ql that are applicable with oﬀset n:

(cid:101)h n
(cid:74)

δl
(cid:75)

(D) =

{(
(cid:74)
∪{(

h ∗n [x/π]
δ(q), α, V ) (cid:12)
(cid:75)
(cid:75)

h
(cid:74)

δ(q), [x/π], ∅) (cid:12)

(cid:12) (q, α, V ) ∈ D }

(cid:12) π ∈ {n, . . . , n + |h| − 1}, (q, [], ∅) ∈ D }

Applied with D = ql

init and n = 0 this claim yields exactly the lemma. The
proof is by induction on the structure of h, using the facts that admissibility and
applicability are maintained while the oﬀsets are adapted.

So let h ∈ HΣ, n ∈ N, and D ∈ Ql an admissible state that is applicable

with oﬀset n. We distinguish cases according to all possible forms of h:

Case h = a. We have (cid:101)h n = a · n and h ∗n [x/n] = a · x.

δl

(D) =

a · n

δl

(D)

(cid:101)h n

(cid:74)

(cid:75)

(cid:74)

(cid:75)

δ(q), [x/n], ∅) (cid:12)

= {(xδ(aδ(q)), [x/n], ∅) | (q, [], ∅) ∈ D}
∪ {(aδ(q), α, V ) | (q, α, V ) ∈ D}
= {(
(cid:74)
∪ {(
(cid:74)
= {(
(cid:74)
∪ {(
(cid:74)

a · n
(cid:75)
a
(cid:75)
h ∗n [x/n]
(cid:75)
h
(cid:75)

δ(q), [x/n], ∅) (cid:12)

(cid:12) (q, α, V ) ∈ D }

(cid:12) (q, α, V ) ∈ D }

δ(q), α, V ) (cid:12)

δ(q), α, V ) (cid:12)

(cid:12) (q, [], ∅) ∈ D }

(cid:12) (q, [], ∅) ∈ D }

18

A. Al Serhali and J. Niehren

Case h = ε. We have (cid:101)h n = ε and h ∗n [] = ε.

δl

(cid:101)h n

(cid:74)

(cid:75)

(D) =

(D)

δl
ε
(cid:74)
(cid:75)
= D
= {(
(cid:74)
∪ {(
(cid:74)

h ∗n [x/π]
δ(q), α, V ) (cid:12)
(cid:75)
h
(cid:75)

δ(q), [x/π], ∅) (cid:12)

(cid:12) π ∈ ∅, (q, [], ∅) ∈ D }

(cid:12) (q, α, V ) ∈ D }

Case h = h1 · h2. Let n1 = n + |h1|. Then we have (cid:101)h n = (cid:102)h1

n

n1

· (cid:102)h2

. Hence:

δl
(cid:75)

(cid:101)h n
(cid:74)
(D), D2 =

(D) =

(cid:102)h2
(cid:74)
δl

n1

n

δl

Let D1 =
hypothesis applied to h1, D, and n yields:

(cid:102)h2

(cid:102)h1

(cid:75)

(cid:74)

(cid:75)

(cid:74)

h1 ∗n [x/π]
D1 = ({(
(cid:74)
h1
∪ {(
(cid:74)

δ(q), α, V ) (cid:12)

(cid:75)

(cid:75)

δ(q), [x/π], ∅) (cid:12)
(cid:12) (q, α, V ) ∈ D })

n1

δl

(cid:75)

(cid:102)h1

(
(cid:74)

n

δl

(cid:75)

(D))

(D1) and n2 = n1 + |h2|. The induction

(cid:12) π ∈ {n, . . . , n1 − 1}, (q, [], ∅) ∈ D}

Note that D1 is applicable with oﬀset n1. The induction hypothesis applied
to h2, D1, and n1 yields:

h2 ∗n1 [x/π]
(cid:75)
h2

δ(q1), α, V ) (cid:12)

δ(q1), [x/π], ∅) (cid:12)

(cid:12) (q1, α, V ) ∈ D1 }

(cid:12) π ∈ {n1, . . . , n2 − 1}, (q1, [], ∅) ∈ D1}

D2 = {(
(cid:74)
∪ {(
(cid:74)

Hence,

(cid:75)

δ(
(cid:74)
δ(q)), α, V ) (cid:12)

δ(q)), [x/π], ∅) (cid:12)
h1
δ(q)), [x/π], ∅) (cid:12)
(cid:75)
(cid:75)
h1 ∗n [x/π]
(cid:75)
h1

δl
(cid:101)h n
(D)
(cid:74)
(cid:75)
h2 ∗n1 [x/π]
= {(
(cid:74)
h2
∪ {(
(cid:75)
(cid:74)
h2
∪ {(
(cid:75)
(cid:74)
δ(q)) = (
Note that
h1
(cid:75)
(cid:74)
δ(
{n, . . . , n2 −1}, and similarly,
h2
(cid:75)
(cid:74)
for any π ∈ {n, . . . , n1 − 1}. Thus

δ(
(cid:74)
δ(
(cid:74)
h2 ∗n1 [x/π]
(cid:75)

δ(

(cid:75)

(cid:74)

(cid:12) (q, α, V ) ∈ D }

(cid:74)

δl

(cid:101)h n
(cid:75)
= {(
∪ {(

(cid:74)
(cid:74)
= {(
(cid:74)
∪ {(
(cid:74)

(D)
h1 · h2 ∗n [x/π]
(cid:75)
h1 · h2

δ(q), α, V ) (cid:12)
(cid:75)

δ(q), [x/π], ∅) (cid:12)

(cid:12) (q, α, V ) ∈ D }

h ∗n [x/π]
δ(q), α, V ) (cid:12)
(cid:75)
h
(cid:75)

δ(q), [x/π], ∅) (cid:12)

(cid:12) (q, α, V ) ∈ D }

Case h = (cid:104)h1(cid:105). Thus (cid:101)hn = (cid:104)n · (cid:102)h1

n+1

· (cid:105). Let:
D(cid:48) = {((cid:104)(cid:105)δ, α, dom(α)) (cid:12)

(cid:12) π ∈ {n1, . . . , n2 − 1}, (q, [], ∅) ∈ D}
(cid:12) π ∈ {n, . . . , n1 − 1}, (q, [], ∅) ∈ D}

δ(q) for any π ∈
h1 · h2 ∗n [x/π]
(cid:75)
δ(q)
h1 ·h2 ∗n [x/π]
δ(q)) = (
(cid:75)
(cid:74)

(cid:74)
h1 ∗n [x/π]
(cid:74)

(cid:75)

(cid:12) π ∈ {n, . . . , n2 − 1}, (q, [], ∅) ∈ D}

(cid:12) π ∈ {n, . . . , n + |h| − 1}, (q, [], ∅) ∈ D}

(cid:12) (q, α, V ) ∈ D}

Thus (D(cid:48), D) = (cid:104)δl

(D) and:

δl

(cid:101)h n

(cid:74)

(cid:75)

(D) =

n+1

· (cid:105)
n+1

(cid:74)
= (cid:105)δl
= (cid:105)δl

(cid:104)n · (cid:102)h1
(
(cid:74)
(
(cid:74)

n · (cid:102)h1
n+1
(cid:102)h1

δl

(cid:75)

δl

(cid:75)
δl
(cid:75)
(
(cid:74)

n

(cid:75)

(D)
(D(cid:48)), D)
δl

(D(cid:48))), D)

Earliest Query Answering on Nested Streams

19

Let D1 = D(cid:48) ∪ {(xδ((cid:104)(cid:105)δ), [x/n], ∅) (cid:12)
Then:

(cid:12) (q, [], ∅) ∈ D} and D2 =

n+1

(cid:102)h1
(cid:74)

δl

(D1).

(cid:75)

(cid:101)h n

δl

(D) = (cid:105)δl

n+1

δl

(D1), D) = (cid:105)δl

(D2, D)

(cid:102)h1

(
(cid:74)

(cid:74)

(cid:75)
Let and n1 = n+|h1|.Note that D1 is applicable with oﬀset n1. The induction
hypothesis applied to h1, D1 and n + 1 shows:

(cid:75)

D2 = {(
(cid:74)
∪ {(
(cid:74)

δ(q1), α, V ) (cid:12)

h1
h1 ∗n+1 [x/π]
(cid:75)

(cid:75)

(cid:12) (q1, α, V ) ∈ D1}
δ(q1), [x/π], ∅) (cid:12)

(cid:12) π ∈ {n + 1, . . . , n1}, (q1, [], ∅) ∈ D1}

Thereby and by the deﬁnition of D1 we obtain: I put n as correction for x.
Also dom(α) instead of V as for D(cid:48)

δ((cid:104)(cid:105)δ)), α, dom(α)) (cid:12)
δ(nδ((cid:104)(cid:105)δ)), [x/n], ∅) (cid:12)
(cid:75)
(cid:75)

D2 = {(
h1
(cid:74)
∪ {(
h1
(cid:74)
h1 ∗n+1 [x/π]
∪ {(
(cid:75)
(cid:74)

δ((cid:104)(cid:105)δ), [x/π], ∅) (cid:12)

(cid:12) (q, α, V ) ∈ D}
(cid:12) (q, [], ∅) ∈ D}

(cid:12) π ∈ {n + 1, . . . , n1}, (q, [], ∅) ∈ D}

With this equation, we can develop the right hand side of the equation
(D2, D) by applying the deﬁnition of the closing rule of δl:
(cid:101)h n
(cid:74)
at closing time, we take back V , not dom(α)

(D) = (cid:105)δl

δl
(cid:75)

(cid:105)δl
∪ {(q@
∪ {(q@

(D2, D) = {(q@
n · h1
(cid:74)
(cid:75)
h1 ∗n+1 [x/π]
(cid:75)
(cid:74)

h1
(cid:74)

δ((cid:104)(cid:105)δ), α, V ) (cid:12)

(cid:12) (q, α, V ) ∈ D}

δ((cid:104)(cid:105)δ), [x/n], ∅) (cid:12)
(cid:75)
δ((cid:104)(cid:105)δ), [x/π], ∅) (cid:12)

(cid:12) (q, [], ∅) ∈ D}

(cid:12) π ∈ {n + 1, . . . , n1}, (q, [], ∅) ∈ D}

Note that the admissibility of D ensures above that [x/n] cannot match with
any (q, [], {x}) ∈ D. We next apply the deﬁnition of

δ to show:

(cid:104).(cid:105)
(cid:75)

(cid:74)

δ(q), α, V ) (cid:12)

(cid:105)δl
∪ {(
(cid:74)
∪ {(
(cid:74)

(D2, D) = {(
(cid:74)
(cid:104)n · h1(cid:105)
(cid:75)
(cid:104)h1 ∗n+1 [x/π](cid:105)
(cid:75)

(cid:104)h1(cid:105)
δ(q), [x/n], ∅) (cid:12)
(cid:75)
δ(q), [x/π], ∅) (cid:12)

(cid:12) (q, [], ∅) ∈ D}

(cid:12) (q, α, V ) ∈ D}

(cid:12) π ∈ {n + 1, . . . , n1}, (q, [], ∅) ∈ D}

Since h = (cid:104)h1(cid:105) we get:

(cid:105)δl
∪ {(
∪ {(

δ(q), α, V ) (cid:12)
(D2, D) = {(
h
δ(q), [x/n], ∅) (cid:12)
(cid:75)
(cid:74)
h ∗n [x/n]
δ(q), [x/π], ∅) (cid:12)
(cid:75)
h ∗n [x/π]
(cid:75)

(cid:74)
(cid:74)

(cid:12) (q, α, V ) ∈ D}
(cid:12) (q, [], ∅) ∈ D}
(cid:12) π ∈ (n + 1, . . . , n1), (q, [], ∅) ∈ D}

δ(q), α, V ) (cid:12)
h
(cid:75)
h ∗n [x/π]
(cid:75)
(D) = (cid:105)δl

= {(
∪ {(

(cid:74)
(cid:74)
δl
(cid:75)

Since,

(cid:101)h n
(cid:74)

(cid:12) (q, α, V ) ∈ D}

δ(q), [x/π], ∅) (cid:12)

(cid:12) π ∈ (n, . . . , |h| − 1), (q, [], ∅) ∈ D}

(D2, D) the inductive statement follows.

We ﬁnally notice that the restriction of states D to be applicable with oﬀset n
is not strictly necessary. The claim remains true when omitting it.

The late automaton thus computes the answer set of the query as follows:

20

A. Al Serhali and J. Niehren

Lemma 15. qry L(A)(h) = {π | (q, [x/π], ∅) ∈

˜h

δl

(ql

init ), q ∈ F }

(cid:74)

(cid:75)

Proof. Let α = [x/π] for some π ∈ N. By Lemma 14, we have that q =
init ). Hence:
α

(ql

(cid:101)h

δl

δ(qinit ) iﬀ (q, α, ∅) ∈
(cid:75)

(cid:74)

(cid:75)

h ∗

(cid:74)

π ∈ qry L(A)(h) iﬀ π = α(x) and h ∗ α ∈ L(A)
δ(qinit ) ∈ F
iﬀ π = α(x) and
(cid:74)
iﬀ π = α(x) and ∃q ∈ F. (q, α, ∅) ∈

h ∗ α

(cid:75)

δl

(ql

init ).

(cid:101)h

(cid:74)

(cid:75)

δl
str(ql

Proposition 7 (Correctness of the late streaming evaluator). If (D, ε) =
nw (˜h)
init , ε) then qry L(A)(h) = {π | (q, [x/π], ∅) ∈ D, q ∈ F }.
(cid:74)
(cid:75)
Proof. This is an immediate consequence of Lemma 15 and
˜h
ε) = (
(cid:74)

init ), ε) as shown in Lemma 12.

nw (˜h)
(cid:75)

δl
str(ql

δl
(cid:75)

init ,

(ql

(cid:74)

For ﬁnalizing the deﬁnition of Al = (Σ ∪ N, Ql, Γ l, δl, ql

init , F l) we set F l =

{D ∈ Ql | (q, α, ∅) ∈ D, q ∈ F, dom(α) = {x}}.

Corollary 16. qry L(A)(h) (cid:54)= ∅ ⇔ nw (˜h) ∈ L(Al)

Proof. By Proposition 7, qry L(A)(h) (cid:54)= ∅ if and only if there exists q ∈ F and
α : {x} → N such that (q, α, ∅) ∈
(ql
init ) ∈
F l and thus to ˜h ∈ L(Al).

init ). This is equivalent to

(ql

˜h

˜h

δl

δl

(cid:74)

(cid:75)

(cid:75)

(cid:74)

F Proofs for Section 7 (Certain Answers and Earliest

Query Answering)

Deﬁnition 17. A natural number π is certainly a nonanswer of a monadic
query Q at nested word preﬁx v, denoted by π ∈ CNAQ(v), if:

π ∈ pos(v) ∧ ∀h ∈ HΣ. v ∈ prefs(nw (h)) → π (cid:54)∈ Q(h)

n

n+|pos(v)|

= (cid:101)vn · (cid:101)v(cid:48)

n
= (cid:104)·n, and (cid:101)(cid:105)

More generally, we deﬁne a position annotated word (cid:101)vn ∈ (Σ ∪ {n, . . . , n +
,
= (cid:105). By substituting in (cid:101)v, the position α(x) by x if x ∈ dom(α),

|pos(v)|−1})∗ for any n ∈ N such that (cid:101)εn = ε (cid:101)an = a·n, (cid:93)v · v(cid:48)
n
(cid:101)(cid:104)
and removing all other positions: v ∗ α = (cid:101)v[α(x)/x][π/ε | π (cid:54)= α(x)].
Lemma 9. For any preﬁx v ∈ prefs(nw (HΣ)), language L ⊆ HΣx and candidate
α = [x/π] with π ∈ pos(v): cert-mem L

Σ(v ∗ α) ⇔ π ∈ CAqry L(v).
Proof. For the forwards implication “⇒” we assume cert-mem L
Σ(v ∗ α). We ﬁx
h ∈ HΣ arbitrarily such that v ∈ prefs(nw (h)). Then there exists w ∈ ˆΣ∗ such
that v · w = nw (h). Let h (cid:48) = h ∗ α. Since h(cid:48) = nw ((v ∗ α) · w), the certainty of
Σ-membership of v ∗ α for L yields h (cid:48) ∈ L. For the backwards implication “⇐”
we assume π ∈ CAqry L (v). We ﬁx h(cid:48) ∈ HΣx and w ∈ ˆΣ∗ arbitrarily such that
(v ∗ α) · w ∈ nw (h(cid:48)). Let h = nw (v · w). Then v ∈ prefs(nw (h)), and since π is a
certain answer of qry L on v, it follows that h ∗ α ∈ L. Hence h (cid:48) = h ∗ α ∈ L.

Earliest Query Answering on Nested Streams

21

Proposition 10 (Corollary of Proposition 6 and Lemma 9). Let A =
(Σx, , δ, qinit , ) be a d Sha such that δ|Σ is complete. For any v ∈ nwprefs Σ,
δc
Σ, ε): π ∈ CAqry L(A) (v) ⇔ q ∈ S .
π ∈ pos(v), and ((q, S), ) =
str(qinit
Σ

c

v ∗[x/π]
(cid:75)
(cid:74)

c
Proof. Let α = [x/π] and ((q, S), ) =
Σ, ε). For the direction “⇒”,
we assume α(x) ∈ CAqry L(A) (v). Lemma 9 yields cert-mem L(A)
Σ (v ∗ α). Since δ|Σ
is complete, Proposition 6 shows q ∈ S. For the other direction “⇐”, we assume
that q ∈ S. Since δ|Σ is complete, Proposition 6 shows cert-mem L(A)
Σ (v ∗ α).
Lemma 9 proves α(x) ∈ CAqry L(A)(v).

v ∗α

(cid:75)

(cid:74)

δc
str(qinit
Σ

Lemma 18. Let A be a d Sha with signature Σx such that δ|Σ is complete. For
any nested word preﬁx v ∈ nwprefs Σ, pair (M, ) =
init , ε) and variable
assignment α : {x} → pos(v), q ∈ Q and S ⊆ Q:

δe
str(qe

(cid:101)v
(cid:75)

(cid:74)

((q, S), ) =

v ∗ α

(cid:74)

δc
str(qinit
Σ
(cid:75)

c
Σ, ε) ⇔ (q, α, , S) ∈ M

Proof. By induction on the structure of v. Assume v ∈ nwprefs Σ, (M, ) =
init , ε), variable assignment α : {x} → pos(v), q ∈ Q and S ⊆ Q. In the
(cid:101)v
(cid:74)
(cid:75)
base case, v is the empty word:

δe
str(qe

δe
str(qe

Case v = ε. Hence, (cid:101)v = ε and

init , ε). Also, M = qe
init =
{(qinit , [], ∅, safeδ|Σ (F ))}. On the other hand,
c
Σ, ε) is deﬁned
v ∗ α
(cid:74)
Σ, ε) = ((qinit , safeδ|Σ (F )), ε)
c
only if α = [], and in this case, it is equal to (qinit
So (q, α, , S) ∈ M iﬀ q = qinit , α = [] and S = safeδ|Σ (F ) iﬀ ((q, S), ) =
v ∗ α

init , ε) = (qe

δc
str(qinit
Σ

(cid:101)v
(cid:75)

(cid:75)

(cid:74)

δc
str(qinit
Σ

c
Σ, ε).

(cid:74)

(cid:75)

For the inductive step, there are three cases depending on the type of the last
letter of v. Then, there are a ∈ Σ or v(cid:48), v(cid:48)(cid:48) ∈ nwprefs Σ such that:

(cid:75)

δe
str(qe

Case v = v(cid:48) · a. So there exists π ∈ N such that (cid:101)v = (cid:101)v(cid:48) · a · π. Let (M (cid:48), ) =
init , ε). We consider two cases depending on whether α binds x to

(cid:101)v(cid:48)
(cid:74)
the last position π or not:
Case α = [x/π]. We have (q, α, , S) ∈ M iﬀ exists q(cid:48) and q(cid:48)(cid:48) such that
(q(cid:48), [], ∅, S) ∈ M (cid:48) and q(cid:48) a−→ q(cid:48)(cid:48) x−→ q ∈ δ. By induction hypothesis,
δc
c
(q(cid:48), [], ∅, S) ∈ M (cid:48)
is equivalent to ((q(cid:48), S), ) =
Σ, ε).
str(qinit
Σ
v(cid:48) ∗
Hence, (q, α, , S) ∈ M iﬀ exists q(cid:48) and q(cid:48)(cid:48) such that ((q(cid:48), S), ) =
(cid:74)
δc
Σ, ε). and q(cid:48) a−→ q(cid:48)(cid:48) x−→ q ∈ δ. And this is equivalent to ((q, S), ) =
str(qinit
[]
Σ
(cid:75)
δc
str(qinit
v ∗ α
Σ
(cid:74)
Case α (cid:54)= [x/π]. We have (q, α, , S) ∈ M iﬀ exists q(cid:48) such that (q(cid:48), α, , S) ∈
M (cid:48) and q(cid:48) a−→ q ∈ δ. By induction hypothesis, (q(cid:48), α, , S) ∈ M (cid:48) is equiva-
δc
c
v(cid:48) ∗ α
lent to ((q(cid:48), S), ) =
str(qinit
Σ, ε). Hence, (q, α, , S) ∈ M iﬀ exists
Σ
(cid:75)
δc
Σ, ε) and q(cid:48) a−→ q ∈ δ. And this
q(cid:48) such that ((q(cid:48), S), ) =
v(cid:48) ∗ α
str(qinit
Σ
(cid:75)
(cid:74)
δc
c
is equivalent to ((q, S), ) =
Σ, ε).
str(qinit
v ∗ α
Σ

v(cid:48) ∗ []
(cid:75)

c
Σ, ε).

(cid:74)

(cid:74)

(cid:75)

c

c

(cid:74)

(cid:75)

22

A. Al Serhali and J. Niehren

(cid:74)

(cid:101)v(cid:48)

δe
str(qe
(cid:75)

v(cid:48)∗α

Case v = v(cid:48) · (cid:104). Hence, (cid:101)v = (cid:101)v(cid:48) · (cid:104). Let (M (cid:48), ) =

init , ε). If α binds some
position to x then it must be a position of (cid:101)v(cid:48). So, (q, α, , S) ∈ M iﬀ q =
(cid:104)(cid:105)δ and there exist q(cid:48) ∈ Q and S(cid:48) ⊆ Q such that (q(cid:48), α, , S(cid:48)) ∈ M (cid:48) and
dδ|Σ (q(cid:48), S(cid:48)) = S. By induction hypothesis, (q(cid:48), α, , S(cid:48)) ∈ M (cid:48) is equivalent to
Σ, ε). Hence, (q, α, , S) ∈ M iﬀ q = (cid:104)(cid:105)δ and there
((q(cid:48), S(cid:48)), ) =
c
exist q(cid:48) ∈ Q and S(cid:48) ⊆ Q such that ((q(cid:48), S(cid:48)), ) =
c
Σ, ε) and
c
dδ|Σ (q(cid:48), S(cid:48)) = S. The latter is equivalent to ((q, S), ) =
Σ, ε).
Case v = v(cid:48) · (cid:104) · v(cid:48)(cid:48) · (cid:105) and v(cid:48)(cid:48) is well-nested. Let n = #Σ(v). We have (cid:101)v =
(cid:101)v(cid:48) · (cid:104) · n · (cid:102)v(cid:48)(cid:48)
(cid:105). Let s be the stack in the second component of (M, ). The
run of Ae leading to (M, s) must have the following form: Let (M (cid:48), s) =
(cid:101)v(cid:48)

δc
str(qinit
Σ
(cid:75)
δc
v ∗ α
str(qinit
Σ
(cid:74)

δc
str(qinit
Σ

init , ε), and

δe
str(qe

v(cid:48) ∗ α

n+1

(cid:74)

(cid:75)

(cid:75)

(cid:74)

(cid:74)

(cid:75)

M0 = {(qinit , α(cid:48), dom(α(cid:48)), dδ|Σ (q(cid:48), S(cid:48))) | (q(cid:48), α(cid:48), , S(cid:48)) ∈ M (cid:48)}.

δe
Let (M (cid:48)(cid:48), ) =
str(M0, s · M (cid:48)). We distinguish two cases, depending
(cid:75)
on whether α binds x to a position of v(cid:48) or not.
Case α = [x/π] where π ∈ pos(v(cid:48)). We have v ∗ α = (v(cid:48) ∗ α) · (cid:104)v(cid:48)(cid:48)(cid:105). We

n · (cid:102)v(cid:48)(cid:48)

(cid:74)

(cid:74)

(cid:75)

(cid:75)

(cid:75)

(cid:74)

v(cid:48)(cid:48)
(cid:74)

δe
str(qe

consider both implications independently.
“⇒” We suppose that (q, α, , S) ∈ M and have to show that ((q, S), ) =
δc
str(qinit , ε). Since (q, α, , S) ∈ M there is (q(cid:48)(cid:48), α, {x}, S(cid:48)(cid:48)) ∈
v ∗ α
Σ
(cid:74)
(cid:75)
M (cid:48)(cid:48), (q(cid:48), α, , S) ∈ M (cid:48) such that S(cid:48)(cid:48) = dδ|Σ (q(cid:48), S) and q = q(cid:48)@δq(cid:48)(cid:48). By
init , ε) and (q(cid:48), α, , S) ∈ M (cid:48)
induction hypothesis, (M (cid:48), s) =
(cid:101)v(cid:48)
δc
imply that there exists s(cid:48) such that ((q(cid:48), S), s(cid:48)) =
v(cid:48) ∗ α
str(qinit , ε).
Σ
The induction hypothesis applied to (q(cid:48)(cid:48), α, {x}, S(cid:48)(cid:48)) ∈ M (cid:48)(cid:48) implies
δc
that ((q(cid:48)(cid:48), S(cid:48)(cid:48)), ) =
str((cid:104)(cid:105)δ, s(cid:48) · (q(cid:48), S)). Since v(cid:48)(cid:48) is well nested,
Σ
the stack component of ((q(cid:48)(cid:48), S(cid:48)(cid:48)), ) must be unchanged, i.e. equal to
s(cid:48) · (q(cid:48), S). Hence, we can apply the closing rule of Ac
Σ showing that
δc
((q(cid:48)@δq(cid:48)(cid:48), S), s(cid:48)) =
str(qinit , s). Since q(cid:48)@δq(cid:48)(cid:48) = q it follows that
Σ
(cid:75)
((q, S), ) =
v ∗ α

v ∗α
(cid:74)
δc
str(qinit , ε) as required.
Σ
(cid:75)
δc
str(qinit , s) and have to show
Σ
δc
that (q, α, , S) ∈ M . Let ((q(cid:48), S(cid:48)), ) =
str(qinit , s). By in-
Σ
(cid:75)
duction hypothesis, we have (q(cid:48), α, , S(cid:48)) ∈ M (cid:48). Let ((q(cid:48)(cid:48), S(cid:48)(cid:48)), ) =
δc
v(cid:48)(cid:48)
str(qinit , s·(q(cid:48), S(cid:48)). So S(cid:48)(cid:48) = dδ|Σ (q(cid:48), S(cid:48)). By induction hypothesis,
Σ
(cid:74)
we have (q(cid:48)(cid:48), [], , S(cid:48)(cid:48)) ∈ M (cid:48)(cid:48). Hence also (q(cid:48)(cid:48), α, {x}, S(cid:48)(cid:48)) ∈ M (cid:48)(cid:48). The
closing rule permits to metch the tuples with α of M (cid:48) and M (cid:48)(cid:48) yield-
ing (q(cid:48)@δq(cid:48)(cid:48), α, , S(cid:48)) ∈ M . Since α can only belong to a single tuple
of M it follows that q(cid:48)@q(cid:48)(cid:48) = q and S(cid:48) = S. Hence, (q, α, , S) ∈ M .
Case α = [x/n]. So we have v∗α = v(cid:48)·(cid:104)x·v(cid:48)(cid:48)(cid:105). We consider both implications

“⇐” We suppose that ((q, S), ) =

v(cid:48) ∗ α

v ∗ α

(cid:74)

(cid:75)

(cid:74)

(cid:74)

(cid:75)

independently.
“⇒” We suppose that (q, α, , S) ∈ M and have to show that ((q, S), ) =
δc
str(qinit , ε). Since (q, α, , S) there are (q(cid:48)(cid:48), α, {x}, S(cid:48)(cid:48)) ∈ M (cid:48)(cid:48)
v ∗ α
Σ
(cid:74)
(cid:75)
and (q(cid:48), [], ∅, S) ∈ M (cid:48) such that S(cid:48)(cid:48) = dδ|Σ (q(cid:48), S) and q = q(cid:48)@δq(cid:48)(cid:48). By
init , ε) and (q(cid:48), [], ∅, S) ∈ M (cid:48)
induction hypothesis, (M (cid:48), s) =
(cid:101)v(cid:48)

δe
str(qe
(cid:75)

(cid:74)

Earliest Query Answering on Nested Streams

23

(cid:74)

x · v(cid:48)(cid:48)
(cid:74)

v(cid:48) ∗ []
(cid:75)

δc
imply that there exists s(cid:48) such that ((q(cid:48), S), s(cid:48)) =
str(qinit , ε).
Σ
The induction hypothesis applied to (q(cid:48)(cid:48), α, {x}, S(cid:48)(cid:48)) ∈ M (cid:48)(cid:48) implies
δc
that ((q(cid:48)(cid:48), S(cid:48)(cid:48)), ) =
str((cid:104)(cid:105)δ, s(cid:48) · (q(cid:48), S)). Since v(cid:48)(cid:48) is well nested,
Σ
(cid:75)
the stack component of ((q(cid:48)(cid:48), S(cid:48)(cid:48)), ) must be unchanged, i.e. equal to
s(cid:48) · (q(cid:48), S). Hence, we can apply the closing rule of Ac
Σ showing that
δc
((q(cid:48)@δq(cid:48)(cid:48), S), s(cid:48)) =
str(qinit , s). Since q(cid:48)@δq(cid:48)(cid:48) = q it follows that
Σ
(cid:75)
v ∗ α
((q, S), ) =

v ∗α
(cid:74)
δc
str(qinit , ε) as required.
Σ
(cid:75)
δc
str(qinit , s) and have to show
Σ
(cid:74)
δc
that (q, α, , S) ∈ M . Let ((q(cid:48), S(cid:48)), ) =
str(qinit , s). By induc-
Σ
tion hypothesis, we have (q(cid:48), [], , S(cid:48)) ∈ M (cid:48). Let ((q(cid:48)(cid:48), S(cid:48)(cid:48)), ) =
x ·
δc
v(cid:48)(cid:48)
str(qinit , s · (q(cid:48), S(cid:48)). So S(cid:48)(cid:48) = dδ|Σ (q(cid:48), S(cid:48)). By induction hypothe-
Σ
(cid:75)
sis, we have (q(cid:48)(cid:48), α, , S(cid:48)(cid:48)) ∈ M (cid:48)(cid:48). The closing rule permits to match
the tuple with α in M (cid:48)(cid:48) with the tuple with [] of M (cid:48). This yields
(q(cid:48)@δq(cid:48)(cid:48), α, , S(cid:48)) ∈ M . Since α can only belong to a single tuple of
M it follows that q(cid:48)@q(cid:48)(cid:48) = q and S(cid:48) = S. Hence, (q, α, , S) ∈ M .

v ∗ α

v(cid:48)

(cid:75)

(cid:74)

(cid:74)

(cid:75)

(cid:74)

“⇐” We suppose that ((q, S), ) =

(cid:75)

(cid:74)

(cid:75)

v(cid:48)(cid:48) ∗ α

δe
str(qe

Case else. So now either α = [] or α = [x/π] with π−n−1 ∈ pos(v(cid:48)(cid:48)) and we
have v ∗ α = v(cid:48) ∗ ·(cid:104)v(cid:48)(cid:48) ∗ α(cid:105). We consider both implications independently.
“⇒” We suppose that (q, α, , S) ∈ M and have to show that ((q, S), ) =
δc
str(qinit , ε). Since (q, α, , S) there are (q(cid:48)(cid:48), α, ∅, S(cid:48)(cid:48)) ∈ M (cid:48)(cid:48) and
v ∗ α
Σ
(cid:74)
(q(cid:48), [], ∅, S) ∈ M (cid:48) such that S(cid:48)(cid:48) = dδ|Σ (q(cid:48), S) and q = q(cid:48)@δq(cid:48)(cid:48). By
init , ε) and (q(cid:48), [], , S) ∈ M (cid:48)
induction hypothesis, (M (cid:48), ) =
(cid:101)v(cid:48)
δc
imply that there exists s(cid:48) such that ((q(cid:48), S), s(cid:48)) =
v(cid:48) ∗ []
str(qinit , ε).
Σ
(cid:75)
The induction hypothesis applied to (q(cid:48)(cid:48), α, , S(cid:48)(cid:48)) ∈ M (cid:48)(cid:48) implies that
δc
((q(cid:48)(cid:48), S(cid:48)(cid:48)), ) =
str((cid:104)(cid:105)δ, s(cid:48) · (q(cid:48), S)). Since v(cid:48)(cid:48) is well nested,
Σ
(cid:75)
the stack component of ((q(cid:48)(cid:48), S(cid:48)(cid:48)), ) must be unchanged, i.e. equal to
s(cid:48) · (q(cid:48), S). Hence, we can apply the closing rule of Ac
Σ showing that
δc
((q(cid:48)@δq(cid:48)(cid:48), S), s(cid:48)) =
str(init, s). Since q(cid:48)@δq(cid:48)(cid:48) = q it follows that
Σ
v ∗ α
((q, S), ) =

v ∗ α
(cid:74)
δc
str(init, ε) as required.
Σ
(cid:75)
δc
str(init, s) and have to show
Σ
(cid:75)
δc
that (q, α, , S) ∈ M . Let ((q(cid:48), S(cid:48)), ) =
str(qinit , s). By induc-
Σ
v(cid:48)(cid:48) ∗
tion hypothesis, we have (q(cid:48), [], , S(cid:48)) ∈ M (cid:48). Let ((q(cid:48)(cid:48), S(cid:48)(cid:48)), ) =
δc
str(qinit , s · (q(cid:48), S(cid:48)). So S(cid:48)(cid:48) = dδ|Σ (q(cid:48), S(cid:48)). By induction hypothe-
α
Σ
sis, we have (q(cid:48)(cid:48), α, , S(cid:48)(cid:48)) ∈ M (cid:48)(cid:48). The closing rule permits to match
the tuple with α in M (cid:48)(cid:48) with the tuple with [] of M (cid:48). This yields
(q(cid:48)@δq(cid:48)(cid:48), α, , S(cid:48)) ∈ M . Since α can only belong to a single tuple of
M it follows that q(cid:48)@q(cid:48)(cid:48) = q and S(cid:48) = S. Hence, (q, α, , S) ∈ M .

“⇐” We suppose that ((q, S), ) =

v ∗ α

v(cid:48)

(cid:75)

(cid:74)

(cid:75)

(cid:74)

(cid:74)

(cid:74)

(cid:74)

(cid:74)

(cid:75)

Proposition 11. Let A be a d Sha with signature Σx such that δ|Σ is complete.
For any nested word preﬁx v ∈ nwprefs Σ with

init , ε) = (M, ):

δe
str(qe

(cid:101)v
(cid:75)

(cid:74)

CAqry L(A) (v) = {α(x) | q ∈ S ∧ (q, α, ∅, S) ∈ M ∧ dom(α) = {x}}

c
Proof. Let π ∈ pos(v), α = [x/π], and ((q, S), ) =
Σ, ε). By
Lemma 18, we have (q, α, , S) ∈ M . Proposition 10 shows that π ∈ CAqry L(A)(v)

v ∗ [x/π]
(cid:74)

(cid:75)

δc
str(qinit
Σ

24

A. Al Serhali and J. Niehren

is equivalent to q ∈ S, and thus to π ∈ {α(x) | q ∈ S∧(q, α, ∅, S) ∈ M ∧dom(α) =
{x}}.

Certain nonanswers can be detected in analogy to certain answers. For this
we can add a set of states that are safe for rejection. At the beginning, this is
safeδ(Q \ F ) lateron we have to use the function dδ to update it when moving
down into subtrees.

G Earliest Automaton with Safe Rejection

We next extend the earliest automaton with safe states for rejection. Given an
dSha A over Σx, we next construct the earliest automaton with rejection Aer .
Its extends the states of Ae with a component with a subset of rejection states:

Qer = Q × Cands × 2{x} × (2Q)2 = Γ er
init = {((cid:104)(cid:105)δ, [], ∅, safeδ|Σ (F ), safeδ(Q \ F ))}.
qer
At the beginning all states in safeδ(Q \ F ) are safe for rejection. Let δer contain
the following rules for all M, N ∈ Qer , a ∈ Σ, and π ∈ N:
M a−→ {(aδ(q), α, V, S, R) | (q, α, V, S, R) ∈ M }
M π−→ {(xδ(q), [x/π], ∅, S, R) | (q, [], ∅, S, R) ∈ M } ∪ M
M

(cid:104)↓M
−−−→ {((cid:104)(cid:105)δ, α, dom(α), dδ|Σ (q, S), dδ(q, R)) | (q, α, V, S, R) ∈ M }
(cid:105)↑M
−−−→ ({(q@δp, α(cid:48), V, S, R) | (q, α, V, S, R) ∈ M, (p, α(cid:48), dom(α), S(cid:48), R(cid:48)) ∈ N,

N

α ∈ {[], α(cid:48)}}

Theorem 1. EQA for monadic d Sha queries can be done in time O(c m) per
event, where c is the concurrency of the query at the event.

Proof. We run the streaming evaluator of earliest automaton with safe rejection
with two exceptions:

1. Whenever creating or updating a tuple (q, α, V, S, R) in the current set M ,
we test whether x ∈ dom(α) and q ∈ S, and if so we output α(x) and remove
the tuple from M .

2. Whenever creating or updating a tuple (q, α, V, S, R) in the current set M ,

we test whether q ∈ R and if so we remove the tuple from M .

This algorithm soundly outputs all certain query answers at the earliest time
spoint by Proposition 11. It remains to argue the complexity per event. Since
the candidates of all tuples in the current state M are pairwise distinct and alive,
the cardinality of M is bounded by the number c of alive candidates of the query
(not of the algorithm). For each tuple (q, α, V, S, R) ∈ M , we need to compute
dδ|Σ (q, S) and dδ(q, R) or some transitions aδ(q) and xδ(q) where a ∈ Σ. The
costs for this are in O(m).

H Proofs for Section 8 (Experimentation)

Earliest Query Answering on Nested Streams

25

Fig. 8: Running times of AStream 3.36 for streaming XPathMark queries on
XML documents whose size scale from 27 KB to 1.2GB. Only the running time
of query O1 is not scaling up linearly, and thus running out of time for 128KB
already. The concurrency of all other queries is bounded on these documents.

Table 1: XPathMark list of queries.

Id
A1:

A2:
A3:
A4:

A5:

A6:
A7:
A8:

O1:
O2:

XPath Query
/site/closed auctions/closed auction/annotation/
description/text/keyword
//closed auction//keyword
/site/closed auctions/closed auction//keyword
/site/closed auctions/closed auction[annotation/description/
text/keyword]/date
/site/closed auctions/closed auction[descendant::keyword]/
date
/site/people/person[profile/gender and profile/age]/name
/site/people/person[phone or homepage]/name
/site/people/person[address and (phone or homepage) and
(creditcard or profile)]/name
/site[closed auctions/closed auction/type]//item
/site[c or not(c)]//bidder

26

A. Al Serhali and J. Niehren

Fig. 9: The quadratic running time of AStream 3.36 on XPath query O1 with
linear concurrency on XML documents ranging from 27 KB to 5 MB.

Table 2: The 77 queries of the XPath corpus of Lick and Schmitz without
dublicates up to renaming.

XPath Query

Id
18330 / descendant-or-self::node()/child::parts-of-speech
17914 /

descendant-or-self::node()/child::tei:back/descendant-or-

self::node()/child::tei:interpGrp
10745 *//tei:imprint/tei:date[@type=’access’]
02091 * | .//refentry
00744 .//@id | .//@xml:id
12060 .//attDef
02762 .//authorgroup/author | .//author
06027 .//authorinitials | .//author
02909 .//bibliomisc[@role=’serie’]
06415 .//email | address/otheraddr/ulink
03257 .//equation[title or info/title]
05122 .//procedure[title]
09138 .//rng:ref

.//tei:elementRef

|

|

.//tei:classRef

.//tei:dataRef

|

.//tei:macroRef

|

Earliest Query Answering on Nested Streams

27

05460 .//table//footnote | .//informaltable//footnote
12404 .//tei:dataRef[@name]
10337 .//tei:note[@place=’end’]
06639 .//tgroup//footnote
14340 //*
13804 //GAP/@DISP
13896 //HEADER//IDNO[@TYPE=’evans citation’]
02194 //annotation
06726 //doc:table | //doc:informaltable
13640 //equiv[@ﬁlter]
05735 //glossary[@role=’auto’]
15766 //h:body/h:section[@data-type=’titlepage’]
15524 //h:section[@data-type=’titlepage’]
06512 //refentry//text()
06176 //set | //book | //part | //reference | //preface | //chapter | //appendix |
//article | //colophon | //refentry | //section | //sect1 | //sect2 | //sect3
| //sect4 | //sect5 | //indexterm | //glossary | //bibliography | //*[@id]

12539 //tei:elementSpec | //tei:classSpec[@type=’atts’]
11780 //tei:ref[@type=’cite’] | //tei:ptr[@type=’cite’]
11478 //xhtml:p[@class]
11227 /tei:TEI/tei:text//tei:note[@type=’action’]
05684 @abbr | @align | @axis | @bgcolor | @border | @cellpadding | @cellspac-
ing | @char | @charoﬀ | @class | @dir | @frame | @headers | @height |
@id | @lang | @nowrap | @onclick | @ondblclick | @onkeydown | @on-
keypress | @onkeyup | @onmousedown | @onmousemove | @onmouseout
| @onmouseover | @onmouseup | @rules | @scope | @style | @summary |
@title | @valign | @valign | @width | @xml:id | @xml:lang

06947 anchor | areaset | audiodata | audioobject | beginpage | constraint |
itermset | keywordset | msg | doc:anchor | doc:areaset
indexterm |
| doc:audiodata | doc:audioobject | doc:beginpage | doc:constraint |
doc:indexterm | doc:itermset | doc:keywordset | doc:msg

06794 articleinfo | chapterinfo | bookinfo | doc:info | doc:articleinfo |

doc:chapterinfo | doc:bookinfo

06169 article | preface | chapter | appendix | refentry | section | sect1 | glossary

| bibliography

06924 authorblurb | formalpara | legalnotice | note | caution | warning | impor-
tant | tip | doc:authorblurb | doc:formalpara | doc:legalnotice | doc:note
| doc:caution | doc:warning | doc:important | doc:tip

11958 biblStruct//note
01705 book | article | part | reference | preface | chapter | bibliography | ap-
pendix | glossary | section | sect1 | sect2 | sect3 | sect4 | sect5 | refentry
| colophon | bibliodiv[title] | setindex | index

28

A. Al Serhali and J. Niehren

02086 book | article | topic | part | reference | preface | chapter | bibliography |
appendix | glossary | section | sect1 | sect2 | sect3 | sect4 | sect5 | refentry
| colophon | bibliodiv[title] | setindex | index

02000 chapter | appendix | epigraph | warning | preface | index | colophon |
glossary | biblioentry | bibliography | dedication | sidebar | footnote |
glossterm | glossdef | bridgehead | part

02697 chapter | appendix | preface | reference | refentry | article | topic | index

| glossary | bibliography

14183 content//rng:ref
07106 dbk:appendix | dbk:article | dbk:book | dbk:chapter | dbk:part |
dbk:preface | dbk:section | dbk:sect1 | dbk:sect2 | dbk:sect3 | dbk:sect4
| dbk:sect5
05824 descendant-or-self::*
11368 descendant-or-self::tei:TEI/tei:text/tei:back
15848 descendant::*[@class=’refname’]
15462 descendant::h:span[@data-type=’footnote’]
04267 descendant::label
07113 following-sibling::*[self::dbk:appendix | self::dbk:article | self::dbk:book
| self::dbk:chapter | self::dbk:part | self::dbk:preface | self::dbk:section
| self::dbk:sect1 | self::dbk:sect2 | self::dbk:sect3 | self::dbk:sect4 |
self::dbk:sect5] | following-sibling::dbk:para[@rnd:style = ’bibliography’
or @rnd:style = ’bibliography-title’ or @rnd:style = ’glossary’ or
@rnd:style = ’glossary-title’ or @rnd:style = ’qandaset’ or @rnd:style
= ’qandaset-title’]

03864 guibutton | guiicon | guilabel | guimenu | guimenuitem | guisubmenu |

interface

15484 h:pre[@data-type=’programlisting’]//text()
15461 h:table[descendant::h:span[@data-type=’footnote’]]
11160 html:table | html:tr | html:thead | html:tbody | html:td | html:th |

html:caption | html:li

|

imageobjectco

06856 imageobject

|
|
doc:imageobject | doc:imageobjectco | doc:audioobject | doc:videoobject
06458 info | refentryinfo | referenceinfo | refsynopsisdivinfo | refsectioninfo |
refsect1info | refsect2info | refsect3info | setinfo | bookinfo | articleinfo
| chapterinfo | sectioninfo | sect1info | sect2info | sect3info | sect4info |
sect5info | partinfo | prefaceinfo | appendixinfo | docinfo

audioobject

videoobject

|

13710 persName | orgName | addName | nameLink | roleName | forename |

surname | genName | country | placeName | geogName

06808 personname | surname | ﬁrstname | honoriﬁc | lineage | othername |
contrib | doc:personname | doc:surname | doc:ﬁrstname | doc:honoriﬁc |
doc:lineage | doc:othername | doc:contrib

Earliest Query Answering on Nested Streams

29

04338 refsynopsisdiv/title | refsection/title | refsect1/title | refsect2/title |
refsect3/title | refsynopsisdiv/info/title | refsection/info/title | ref-
sect1/info/title | refsect2/info/title | refsect3/info/title

04358 section/title | simplesect/title | sect1/title | sect2/title | sect3/title
| sect4/title | sect5/title | section/info/title | simplesect/info/title |
sect1/info/title | sect2/info/title | sect3/info/title | sect4/info/title
| sect5/info/title | section/sectioninfo/title | sect1/sect1info/title |
sect2/sect2info/title |
sect4/sect4info/title |
sect3/sect3info/title |
sect5/sect5info/title

13632 self::placeName |

self::persName |
self::region | self::country | self::bloc

self::district

|

self::settlement

|

01847 set | book | part | preface | chapter | appendix | article | reference |
refentry | book/glossary | article/glossary | part/glossary | bibliography
| colophon

05219 set | book | part | preface | chapter | appendix | article | topic | reference
| refentry | book/glossary | article/glossary | part/glossary | book/bibli-
ography | article/bibliography | part/bibliography | colophon

05226 set | book | part | preface | chapter | appendix | article | topic | reference |
refentry | sect1 | sect2 | sect3 | sect4 | sect5 | section | book/glossary | ar-
ticle/glossary | part/glossary | book/bibliography | article/bibliography
| part/bibliography | colophon

03325 set | book | part | reference | preface | chapter | appendix | article | topic
| glossary | bibliography | index | setindex | refentry | sect1 | sect2 | sect3
| sect4 | sect5 | section

03410 set | book | part | reference | preface | chapter | appendix | article | topic
| glossary | bibliography | index | setindex | refentry | refsynopsisdiv |
refsect1 | refsect2 | refsect3 | refsection | sect1 | sect2 | sect3 | sect4 |
sect5 | section

03407 set | book | part | reference | preface | chapter | appendix | article |
glossary | bibliography | index | setindex | refentry | sect1 | sect2 | sect3
| sect4 | sect5 | section

04245 set | book | part | reference | preface | chapter | appendix | article |
glossary | bibliography | index | setindex | refentry | refsynopsisdiv |
refsect1 | refsect2 | refsect3 | refsection | sect1 | sect2 | sect3 | sect4 |
sect5 | section

04953 set | book | part | reference | preface | chapter | appendix | article |
glossary | bibliography | index | setindex | topic | refentry | refsynopsisdiv
| refsect1 | refsect2 | refsect3 | refsection | sect1 | sect2 | sect3 | sect4 |
sect5 | section

07095 sf:stylesheet | sf:stylesheet-ref | sf:container-hint | sf:page-start | sf:br
| sf:selection-start | sf:selection-end | sf:insertion-point | sf:ghost-text |
sf:attachments

05463 table//footnote | informaltable//footnote
12960 tei:classSpec/tei:attList//tei:attDef/tei:datatype/rng:ref

30

A. Al Serhali and J. Niehren

12961 tei:classSpec/tei:attList//tei:attDef/tei:datatype/tei:dataRef
09123 tei:content//rng:ref[@name = ’macro.anyXML’]
12514 tei:content/tei:classRef | tei:content//tei:sequence/tei:classRef
12964 tei:dataSpec/tei:content//tei:dataRef
08632 tei:front//tei:titlePart/tei:title
10595 tei:label | tei:ﬁgure | tei:table | tei:item | tei:p | tei:title | tei:bibl |

tei:anchor | tei:cell | tei:lg | tei:list | tei:sp

12962 tei:macroSpec/tei:content//rng:ref

