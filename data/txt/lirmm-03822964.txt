A graph based semantics for Logical Functional
Diagrams in power plant controllers
Mohamed Aziz Sfar Gandoura, Dina Irofti, Madalina Croitoru

To cite this version:

Mohamed Aziz Sfar Gandoura, Dina Irofti, Madalina Croitoru. A graph based semantics for Logical
Functional Diagrams in power plant controllers. FoIKS 2022 - 12th International Symposium on Foun-
dations of Information and Knowledge Systems, Jun 2022, Helsinki, Finland. pp.55-74, ￿10.1007/978-
3-031-11321-5_4￿. ￿lirmm-03822964￿

HAL Id: lirmm-03822964

https://hal-lirmm.ccsd.cnrs.fr/lirmm-03822964

Submitted on 20 Oct 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

A graph based semantics for Logical Functional
Diagrams in power plant controllers

Aziz Sfar1,2[0000−0003−0359−0600], Dina Irofti2[0000−0002−9254−7980], and
Madalina Croitoru1[0000−0001−5456−7684]

1 GraphIK, INRIA, LIRMM, CNRS and University of Montpellier, France
2 PRISME Department, EDF R&D, France

Abstract. In this paper we place ourselves in the setting of formal rep-
resentation of functional specifications given in logical diagrams (LD)
for verification and test purposes. Our contribution consists in defining
a formal structure that explicitly encodes the semantics and behavior of
a LD. We put in a complete transformation procedure of the non-formal
LD specifications into a directed state graph such that properties like os-
cillatory behavior become formally verifiable on LDs. We motivate and
illustrate our approach with a scenario inspired from a real world power
plant specification.

Keywords: System Validation · Functional Specifications · Logic Func-
tional Diagram · Graph based Knowledge Representation and Reasoning.

1

Introduction

A power plant is a complex system and its functional behavior is described, for
each of its subsystems, using logical diagrams. The logical diagrams are coded
and uploaded into the controllers. During the power plant life-cycle (around 60
years and even more), the controllers’ code needs to be updated and verified.
Engineers generate scenarios in order to verify the new code. However, the sce-
narios generation is far from being a simple procedure because of the system’s
complexity. Indeed, the power plant contains a few hundred subsystems, and the
behavior of each subsystem is described in a few hundred pages of logical dia-
grams. Knowing that a logical diagram page contains on average 10 logic blocks,
a quick calculation shows that a power plant behavior can be described by a few
hundred of thousands of logic blocks. Another nontrivial problem for scenario
generation for such systems is caused by the loops existing between the logic
blocks, i.e. the input of some logic blocks depends on their outputs, which can
cause cyclic behaviors. These are indefinite variations of signals in the controller
without a change occurring on its input parameters.

Logical diagram specifications lack the formal semantics that allow the use of
formal methods for properties verification and test scenarios generation. Done
through manual procedures, these tasks are tedious. In this paper, we tackle
the problem of lack of semantics of logical diagram specifications. To solve
this problem, we propose a formal graph model called the Sequential Graph

2

Aziz Sfar, Dina Irofti, and Madalina Croitoru

of State/Transition (SGST ) and we define a transformation method of logical
diagrams into the proposed graph. On the SGST , we show how to formally
verify that the functional behavior described by the logical diagram specifica-
tion is deterministic. In fact, the specification model is supposed to provide a
description of the expected behavior of the controller. If the expected behavior
itself is non-deterministic, then test generation based on that behavior does not
make sense. This problem can be generated by the presence of loop structures in
the logical diagrams that may prevent the behavior (i.e the expected outputs)
from converging. The convergence property has to be verified before getting to
test generation. Verifying this property directly on the logical diagram, which
is a mix of logical blocks and connections presented in a non-formal diagram,
is not easy to achieve. This task is possible in theory, as the logical diagrams
can be reduced to combinatorial circuits. In literature, a combinatorial circuit
[7] is a collection of logic gates for which the outputs can be written as Boolean
functions of the inputs. In [11] it is shown that a cyclic circuit can be combina-
torial, and a method based on binary decision diagrams is proposed to obtain
the truth table of the circuit. The problem of where to cut the loops in the cir-
cuits and how to solve this loops has also been addressed in other studies [12],
and applied in particular on the Esterel synchronous programming language [6].
Another algorithm for analysis cyclic circuits based on minimising the set of
input assignments to cover all the combinatorial circuit has been proposed in
[8]. Identifying oscillatory behavior due the combinatorial loops in the circuit
has also been studied (see [2] and references therein). However, all studies cited
here are mainly based on simulation rather than formal verification on models.
The focus of these works is entirely dedicated to the verification of the cyclic
behavior of the circuits and not to test purposes. Yet, several studies have al-
ready been published for the matter of both formal properties verification and
test sequences generation. For instance, in their survey [5] Lee and Yannakakis
address the techniques and challenges of black box tests derived from design
specifications given in the form of finite state machines (Mealy machines). In
[13], the author extends the test sequences generation to timed state machines
inspired from the theory of timed automata [1]. These results and many others
(such as formal verification of properties [9]) are applicable on state/transition
graphs and can by no means be directly used on logical diagrams. In order to
take advantage of the already established techniques, we focus our study on
transforming logical diagrams into formal state graphs. Prvosot [10], has pro-
posed transformation procedures of Grafcet specifications into Mealy machines,
allowing the application of the previously mentioned formal methods of verifica-
tion and test generation. However, Grafcets and logical diagrams are completely
different representation models. A model transformation of logical diagrams into
state graphs has been conducted by Electrict´e de France (EDF) [3] for cyclic be-
havior verification purposes; we note that [3] is not suitable for test generation
and does not take into consideration the behavior of timer blocks. We inspired
our work from both [10] and [3] to develop a formal state graph representation
of the exhaustive behavior encoded in the logical diagram, the SGST . The pro-

A graph based semantics for Logical Functional Diagrams

3

posed graph allows the verification of the cyclic behavior (called convergence in
this paper) and potentially the formal verification of other properties. It also
provides the ground to obtain the equivalent Mealy machine on which the exist-
ing formal test generation results can be applied.
This paper is organized as follows. The second section introduces the Logical Di-
agram specification with an example. A formal definition of the proposed SGST
is given in Section 3. Section 4 details the model transformation procedure from
logical diagrams to SGST graphs. In Section 5 we show how the behavior con-
vergence property could be formally verified on the SGST . A discussion and a
conclusion are given in the last section.

2 Motivating example and preliminary notions

The main objective of a logical controller is to fulfill the set of requirements that
it was built for. After their definition, the requirements are transformed into a
functional description of the expected behavior called functional specification.
A two level verification is needed to validate the controllers: first, the model is
compared with respect to the specification, and second, the physical controller is
tested to verify the conformity with respect to the specification (see functional
validation and system validation in [4]). For both aspects, the specification model
is the key point and the basis of the procedure, therefore it has to be well
established and comprehended. In this section, we introduce Logical Diagram
specifications used for power plant controllers, we define its composing elements
and explain how it describes the functional behavior of the controller.

2.1 Logical diagrams

Logical diagrams are specification models used to describe control functions in
power plants. They contain a number of interconnected logic blocks that define
how a system should behave under a set of input values.

Figure 1 illustrates a logical diagram extracted from a larger real world con-
troller’s logic specification in a power plant. It has five inputs (denoted by i1
to i5), one output (denoted o1) and logic blocks: either blocks corresponding to
logic gates or status blocks (corresponding to memory and on-delay timer blocks
described below). The gates in Figure 1 are: two NOT gates followed by two
AND gates and two OR gates. They correspond to the conjunction (·), disjunc-
tion (+), and negation (¯) Boolean operators, respectively (e.g. the output of
an OR gate with two inputs is equal to 0 if and only if both inputs are equal
to 0 etc.). The on-delay timer block gives the value 1 at its output if its input
maintains the value 1 for 2 seconds; 2 seconds being the characteristic delay θ
of the timer shown in the T block in Figure 1. The memory block is a set (E)
/reset (H) block: if the E input is equal to 1, then the output is equal to 1; if
the H input is equal to 1, then the output of the block is 0. If both E and H
inputs are equal to 1, the output is equal to 0 since the memory in this example
gives priority to the reset H over the set E. This priority is indicated in the block

4

Aziz Sfar, Dina Irofti, and Madalina Croitoru

symbol by the letter p. A 0 at both inputs keeps the output of the memory block
at the same last given value.

The timer and the memory are blocks whose outputs not only depend on the
values at their inputs, but also on their last memorized status. In this paper we
call them status blocks. Each of them possesses a finite set of status values and
evolves between them. A status block output value {0,1} is associated to each
possible status. In the case of the example of Figure 1, the memory block M2
has two possible status values M 1 and M 0 where the status M 1 gives a logic
value of 1 at the output of the block M2 and M 0 status corresponds to the logic
value 0. The on-delay timer block T1 has 3 statuses denoted T D 0, T I 0 and
T A 1, where the associated block output values are 0, 0 and 1, respectively. We
also note on this example the presence of a loop structure (containing the block
T1, an OR block and the memory block M2).

Fig. 1. Example of a logical diagram specification.

More formally, a logical diagram specification is composed of I, the set of
inputs of the diagram, O, the set of outputs of the diagram and B, the set of the
logic blocks of the diagram. The logic blocks B connect the outputs O to the
inputs I and define the function that relates them. B = BS ∪ BLG, namely:

– the logic gates BLG: these are the AND, OR and NOT blocks in the diagram.
Each of them is equivalent to a Boolean expression over its entries using the
Boolean operators (+), (.) and (¯) for AND, OR and NOT, respectively.
– the status blocks BS: these are blocks that have a status that evolves between
a set of values. The evolution of a status of a block bs ∈ BS depends on the
values at its entries and the last value of its status. A logic value at the
output of the status block is associated to each of these status values.

Definition 1 (Pstatus set). We denote by Pstatus the set of all the possible
status values of the blocks BS of the logical diagram.

We note that the status values that a block bs ∈ BS can take are in a subset of
Pstatus. Some insights are given in the following example.

2si1M2i2i3i4i5ON-delay timerT1NOTNOTOROR ANDANDmemoryO1A graph based semantics for Logical Functional Diagrams

5

Example 1 (Illustration of Pstatus set on the motivating example given in Fig-
ure 1). For an on-delay timer status block (such as the block denoted T1 in
Figure 1), P TON
status = {T D 0, T I 0, T A 1}; for a memory status block (such as
M2 block in Figure 1), P M
status = {M 0, M 1}. The associated block output logic
value of a status value ’S X’ is indicated in its name by the numeric ’X’. The
Pstatus set for the example illustrated in Figure 1 is Pstatus = P TON
status.
Logic variables Vars. Logic gates BLG in the diagram can be developed
into Boolean expressions over logic variables Vars by substituting them with
their equivalent Boolean operator. Basically, we end up having outputs O and
entries of BS blocks that are equal to Boolean expressions on Vars.

status ∪ P M

Definition 2 (Vars and ExpV ars sets). We define Vars = I ∪ OBS by the set
of logic variables, that includes I, the set of input variables of the logical diagram
and OBS : the set of output variables of status blocks Bs in the diagram.

We denote by ExpV ars the infinite set of all possible Boolean expressions on
logic variables in Vars. For example, (obs
+ ik) ∈ ExpV ars. In the reminder of
this paper, we will use the following mathematical notations on sets. Let A be
a set of elements:

k

(cid:123)

(cid:122)
Ak =
A × A × ... × A is the set of all ordered k-tuples of elements of A. Given
e =(a1,...,ak)∈ Ak, we denote e(i) the ith element of e, i.e. e(i) = ai. Given
e =(a1,...,ak)∈ Ak, we denote orde(ak) = k the order k of ak in e.

k
(cid:125)(cid:124)

2.2 Test generation for logical diagrams

Let us explain how these diagrams are supposed to be read and subsequently
implemented in a physical system (i.e. the logic controller3). The diagrams are
evaluated in evaluation cycles repeated periodically. Within each evaluation cycle
the status blocks BS are sequentially evaluated in accordance to a defined order
ω while logic gates are evaluated from left to right.
The logic specification diagrams are implemented using a low level programming
language into logical controllers. In order to check the conformity of the code
with respect to the diagram, test beds are generated. The tests function in a
black box manner: we check the conformance of the observed output values to
the expected ones for different input values.
As one can see, even for a simple diagram like the one given in Figure 1, finding
an exhaustive testing strategy is not obvious. A simple solution for scenario test
generation is through simulations of the diagram for each and every possible
combination on the inputs i1...i5. This poses practical difficulties for two main
reasons. On one hand, manual exhaustive test generation is a tedious, time-
consuming task that has to be done to hundreds and hundreds of logical diagram
specifications uploaded on logic controllers. On the other hand, a loop structure
in the logical diagram could cause oscillation problems. This means that logic
values that circulate in a loop could keep changing indefinitely when passing

3 We refer to the implemented logical diagram specification as a logic controller.

6

Aziz Sfar, Dina Irofti, and Madalina Croitoru

through the blocks of the loop. This is a non desired phenomenon as it might
prevent the controller’s outputs from converging for a fixed set of input values. To
overcome these difficulties, we propose (1) a graph state model called sequential
graph of state/transition (SGST ) and (2) a transformation procedure of the
logical diagrams into the SGST . In this new graph, the nodes represent the states
of the logical controller. The edges are labelled with the Boolean conditions over
logic variables Vars. For instance, using the procedure we propose in this paper,
we obtain for the logical diagram shown in Figure 1 the corresponding sequential
graph of state/transition given by Figure 2. Throughout this paper, the logical

Fig. 2. The SGST corresponding to the non-formal logical diagram given by Fig. 1,
obtained using our transformation procedure.

diagram in Figure 1 will be our case study.

3 The sequential graph of state/transition (SGST )

A sequential graph of state transition (SGST ) is a combinatorial structure that
explicitly represents all the possible evaluation steps within evaluation cycles of
the logical diagram by the controller.
Formally, the Sequential Graph of State/Transition (SGST) is an directed
graph defined by the tuple (N , E) where N is the set of nodes and E ⊆ N × N
is the set of directed edges. Nodes and edges of the graph are both labeled using
the labeling functions lN and lE, respectively.

Definition 3 (lN function). For a given set of status blocks BS, the label-
ing function of the nodes of the SGST graph lN is defined as lN : N (cid:55)→
(Pstatus)L, where L = Card(BS). This function assigns, for each status block
bs ∈ BS in the logical diagram, a status value to the node n ∈ N in the SGST .

M2_1     T1D_0n2M2_1     T1I_0n3M2_1     T1A_1n4M2_0     T1I_0n5M2_0     T1A_1n6M2_0     T1D_0n1TrueTrueTrueTrueA graph based semantics for Logical Functional Diagrams

7

Definition 4 (lE function). For a given set of logic variables Vars, the label-
ing function of the edges of the SGST graph lE : E (cid:55)→ ExpV ars, assigns
a logical expression including logic variables from Vars to e ∈ E in the SGST .

Fig. 3. SGST graph representation: example of two states nS and nA linked with a
transition e. An edge e of the SGST graph links two states, from the starting node
nS to the arrival node nA. The edge e is labelled with a Boolean expression label
from the ExpV ars set. The starting and arrival nodes are labelled with a set of L
status values, where L is the total number of status blocks in the logical diagram,
i.e. Card(BS) = L. The set ExpV ars contains Boolean expressions on logic variables
in Vars. The set Vars = I ∪ OBS contains both the input variables I of the logical
diagram, and the output variables OBS of status blocks BS in the logical diagram.
Definition 5 (Evallogic function). We define Evallogic : Pstatus (cid:55)→ {0, 1} as
the logic evaluation function that returns the equivalent logic value of a status
value. In a node n ∈ N , the logic value at the output of a status block bs
i is
obs
i in the node n.
Some notions from Definitions 2–5 are illustrated in Figure 3. We remind that
a logic value at the output obs is associated to each status value of bs assigned
to a node n ∈ N . Therefore, a node n containing the status values of all blocks
BS encodes the logic values at each of their outputs.
Definition 6 (nSeq logical sequence). For a given set of status blocks BS,
we define nSeq of a node n ∈ N as the logical sequence on status blocks output
variables oBS . It is a logical expression associated to the set of status values
in N . This expression uses only the conjunction operator AND ( · ) and the
complement operator (¯) and involves all the status output variables obs ∈ OBS
of status blocks bs ∈ BS:

= Evallogic(n(i)) where n(i) is the status value of the block bs

i

L
(cid:89)

nSeq =

(Evallogic(n(k)) · obs

k

+ Evallogic(n(k)) · obs

k

); whereL = Card(BS).

k=1

Example 2 (Illustration of nSeq on the motivating example given by Figure 1).
In the SGST example of Figure 2, the node n1 encapsulates the status val-
ues {M2 0, T1D 0}. These status values correspond to the logic values 0 and
0 at the outputs of the blocks M2 and T1, respectively. The logical sequence
0
(cid:125)(cid:124)

1
(cid:125)(cid:124)

(cid:123)

(cid:122)
Evallogic(M2 0) ·oM2) ·

nSeq
1

of the node n1 is nSeq

1 = (

0
(cid:125)(cid:124)

(cid:122)
Evallogic(T1D 0) ·oT1 +
(

(cid:123)

(cid:123)

(cid:122)
Evallogic(M2 0) ·oM2 +
1
(cid:125)(cid:124)

(cid:122)
(cid:123)
Evallogic(T1D 0) ·oT1) = oM2 · oT1 .

nS{ nS(1),  nS(2),...,  nS(L) }nA{ nA(1),  nA(2),...,  nA(L) }label ? ExpVars e = (nS, nA)8

Aziz Sfar, Dina Irofti, and Madalina Croitoru

4 SGST construction

Given a logical diagram D, we consider ID (the set of input variables of D)
and BD (the set of logic blocks of D). As explained in the previous sections,
LG is
BD=BD
the set of logic gates of D. The SGST graph of the diagram D is denoted
SGSTD : (ND, ED) and is constructed as follows.

S is the set of status blocks of D and BD

LG, where BD

S ∪ BD

4.1 Building the SGST nodes

status)nM × (P TON

We will construct one node for each possible combination of status values be-
tween the status blocks. Let us start by defining the set of all the possible
combinations of status values of blocks bs ∈ BS
D. Let nT be the number of
on-delay timer blocks and nM the number of memory blocks in the logical di-
agram D. We define the set of all combinations of status values as Cstatus =
status)nT . The number of nodes of the SGSTD is Card(ND) =
(P M
Card(Cstatus) = 3nT × 2nM ; Card(P TON
status) = 3, Card(P M
status) = 2. To each
of these nodes we attribute a combination of status values using the lN func-
tion: ∀ni ∈ ND, lN (ni) = ci where ci ∈ Cstatus, i ∈ {1..Card(ND)}. In the
example of Figure 1, P TON
status = {M 0, M 1},
Cstatus ={(M 0, T D 0), (M 1, T D 0), (M 1, T I 0), (M 1, T A 1), (M 0, T I 0),
(M 0, T A 1)}. Card(Cstatus)=6, the SGSTD has therefore six nodes n1 to
n6 ∈ ND labeled c1...c6 ∈ Cstatus, as shown in Figure 2.

status = {T D 0, T I 0, T A 1}, P M

4.2 Building the SGST edges

Edges that link the nodes in the graph are labelled with a logical expressions
over Vars. If for a set of logic values of Vars, a Boolean expression that labels
an edge starting from a node nS and arriving to a node nA is True, a change of
status values of a BS block in the diagram takes place. The SGSTD of a logical
diagram D is developed to represent the evolution of states of the diagram in a
formal model. The way this evolution works is defined by the evaluation process
of the diagram by the controller. This evaluation is done in periodic cycles:

1. Reading and saving the values of all input variables ik, where k ∈ N.
2. Running a sequential evaluation algorithm on status blocks: at this point,
each status block is evaluated, one after another, in accordance to the logic
values at their entries and their last evaluated status value. The logic values
at the entries of status blocks are obtained by the evaluation of logic gates
connected to these entries in a left to right direction. We denote by ω the
order of the evaluation sequence of status blocks.

3. Evaluating outputs. Outputs ok are Boolean expressions of input variables

ID and status blocks output variables OBS .

We build the edges of the SGSTD that link the nodes following the sequential
evaluation of status blocks that we just established. This sequential evaluation
dictates that only one status block is evaluated at a time. In other words, status
blocks are not evaluated simultaneously. The result of evaluation of a status

A graph based semantics for Logical Functional Diagrams

9

block is used in the evaluation of the next status block in the ordered sequence
ω. This is translated in the graph by building edges that only connect nodes that
have the same status values for all status blocks except for one. We call these
nodes neighboring nodes.

Proposition 1. Let n1 and n2 be two nodes of ND and lN (n1) = (µ1, µ2, ..., µL)
and lN (n2) = (λ1, λ2, ..., λL) be their status values. n1 and n2 are two neighboring
nodes and can possibly be linked by an edge in the SGSTD if ∃c ∈ {1, ..., L}, with
L = Card(BS

D), satisfying the following two conditions:

– ∀k ∈ {1, ..., L}\c, µk = λk; we note that µk = n1(k) is the status value of
k are status

bs
k in n1 and λk = n2(k) is the status value of bs
blocks in BS
D.

k in n2 where bs

– n1(c) = µc ̸= λc = n2(c) where bs

c ∈ BS

D is the only status block that changes

value from µc in node n1 to λc in node n2.

Roughly speaking, Proposition 1 tells us that two nodes in the SGST graph can
be neighbours only if all their status values are identical except one. To conclude,
an edge of the graph is equivalent to a change of the status value of a single status
block between two neighboring nodes nS and nA linked by that edge. We refer
to this change of value as an evolution evol and we define EV OLbs as the set of
all evolution possibilities of bs ∈ BS

D between its status values P bs

status.

Definition 7 (evol tuple). An evolution evol ∈ EV OLbs is defined by the
tuple (si, sf , Cevol), with:

– si: the initial status value of the evolution evol; si ∈ P bs
– sf : the final status value of the evolution evol; sf ∈ P bs
– Cevol: the evolution condition; this is a Boolean expression deducted from the
logical diagram. The evolution from si to sf can only occur if this expression
is True. We note that Cevol ∈ ExpV ars.

status

status

In order to construct the edges of the SGSTD, first the Boolean expressions of
the status block entries have to be calculated (A). Second, the evolution sets
EV OLbs of every status block bs have to be determined using the calculated
expressions (B). Finally, edges of the graph are constructed based on the deter-
mined evolution sets of status blocks (C).

A. Developing the logical expressions at the entries of status blocks:
We remind that the status value of a block bs ∈ BS
D is calculated based on its
previous status value and the logic values at the entries of the block. The logic
values at these entries are obtained by evaluating the elements connected to
them. We develop these connections into Boolean expressions. The evaluation
of a Boolean expression associated to an entry of a status block gives the logic
value of that entry. These expressions are developed as follows:
Let xbs
the following elements:

be an entry of a status block bs

could be connected to one of

k ∈ BS

D. xbs

k

k

10

Aziz Sfar, Dina Irofti, and Madalina Croitoru

Algorithm 1 Evolution construction algorithm for status blocks of memory
type

Input: Boolean expressions (E,H)
block
Output: evolution set EV OLbs ; Reminder: evol ∈ EV OLbs , evol =(si, sf , Cevol)
for all (si, sf ) ∈ P M

▷ E and H are the two entries of the memory

status × P M

status do

if (si, sf ) = (M 1, M 0) then

Cevol ← H

else if (si, sf ) = (M 0, M 1) then

Cevol ← E · H

end if
evol ← (si, sf , Cevol)
add evol to EV OLM

end for

– An input ij ∈ ID: in this case the logic value of this entry is equal to the

logic value of the input variable xbs

= ij;

k

– The output of a status block bs

j, with j ̸= k: here, the entry takes the logic

value of the output of the block bs

j denoted by obs

j

. Then, xbs

k

= obs

;

j

k

– The output of a logic gate bLG: we denote by obLG the output of the logic
gate bLG; then, xbs
= obLG. The output obLG of the logic gate bLG can
be developed into a Boolean expression that uses the logic operator of the
block bLG over its entries. Entries of bLG that are connected to the output
of another logic gate are further developed into Boolean expressions and so
on. This recursive development continues through all the encountered logic
gates and stops at logic inputs ID and status block outputs OBS .

Example 3. The logical diagram of Figure 1 has two status blocks T1 and M2
with outputs denoted oT1 and oM2, respectively. The block T1 has a single entry
xT directly connected to the output oM : xT = oM2. The block M2 has two
input terminals denoted E and H. The entry H is connected to the output of
an ’OR’ gate that we call or1, H = or1. The variable or1 can be developed
into the following expression: or1 = i5 + oT1. The expression of the entry H
is therefore H = i5 + oT Similarly, the input terminal E is connected to an
’OR’ logic gate E = or2. We denote by x1 and x2 the input terminals of this
’OR’ gate. or2 = x1 + x2. Both x1 and x2 are connected to logic gates. They are
therefore developed into Boolean expression in their turn. Following this process,
we obtain E = i1 · i2 + i3 · i4.

B. Building the evolution sets EV OLbs of every status blocks bs ∈ BS
D:
The evolution possibilities of each status block are determined by the nature of
the status block (i.e. memory blocks or timer blocks). Knowing the Boolean
expressions at the entries of a block bs ∈ BS
D we define the algorithms that
construct all the evolution possibilities EV OLbs of the block: Algorithm 1 cor-
responds to the evolution set construction for memory blocks, and Algorithm 2
constructs the evolution set for a timer block. We note that, in the case of timers,
in addition to the logic value at the entry of the block, the status and output

A graph based semantics for Logical Functional Diagrams

11

Algorithm 2 Evolution construction algorithm for status blocks of timer type
▷ X is the entry of the block

Input: Boolean expressions X
Output: evolution set EV OLbs ; evol ∈ EV OLbs , evol =(si, sf , Cevol)
for all (si, sf ) ∈ P TON

status do
if (si, sf ) = (T D 0, T I 0) then

status × P TON

Cevol ← X

else if (si, sf ) = (T I 0, T D 0) then

Cevol ← X

else if (si, sf ) = (T I 0, T A 1) then

Cevol ← X · X/θ

else if (si, sf ) = (T A 1, T D 0) then

Cevol ← X

end if
evol ← (si, sf , Cevol)
add evol to EV OLM

end for

value of timer blocks also depend on time. After receiving a stimulus (i.e. a rins-
ing or falling edge), a timer changes its status automatically after a time period
during which the stimulus action is maintained. In the case of an on-delay timer
with a characteristic delay θ, if its input X is set to 1 for a period ∆t > θ, the
timer goes to the activated status T A giving the value 1 at its output instead of
0 in its deactivated status T D. We introduce another logic variable X/θ ∈ Vars

(cid:40)

such that:

X/θ = 1
X/θ = 0

if X holds the value 1 for a period t > θ
otherwise

Example 4. Applying Algorithms 1 and 2 on the diagram example of Figure 1,
we obtain the evolution sets of the two status blocks in the diagram. For the
timer T1, we obtain T1 = {evol1, evol2, evol3, evol4}, with:
evol1 = (T1D 0, T1I 0, OM2); evol2 = (T1I 0, T1D 0, OM2);
evol3 = (T1I 0, T1A 1, OM2 · OM2\θ); evol4 = (T1A 1, T1D 0, OM2).
For the memory M2, we obtain EV OLM2 = {evol1, evol2}, with:
evol1 = (M2 0, M2 1, OT1 · e5 · (i1 + i4) · (i1 + i3) · (i4 + i2) · (i2 + i3));
evol2 = (M2 1, M2 0, OT1 + e5).

C. Building the edges ED of the SGSTD:
Having built the nodes of the graph and determined all the evolution sets
EV OLbs of status blocks BS
D, we build the edges that connect these nodes.
We remind that the controller evaluates its status blocks in an ordered sequence
ω. In other words, status blocks are not evaluated simultaneously; they are eval-
uated one at a time. A node in the SGSTD encapsulates the status values of all
the blocks BS
D. Two nodes in ND can have one or many different status values.
The sequential evaluation of the controller is reproduced in the graph by building
edges that only link neighboring nodes that have the exact same status values of
all blocks BS
D except for one (see Proposition 1). An edge linking two neighboring
nodes corresponds to an evolution evol ∈ EV OLbs of a single status block bs.
We propose Algorithm 5 for building the edges of the graph SGSTD of a logical

12

Aziz Sfar, Dina Irofti, and Madalina Croitoru

diagram D. For each node nk ∈ ND of the SGST , the algorithm generates all
the possible outgoing edges corresponding to all the evolution possibilities of all
status blocks BS
D from the node nk. Algorithms 3 and 4 are used in Algorithm 5
for neighboring nodes recognition and nodes logical sequences generation.

Algorithm 3 Test whether nS and nA are neighboring nodes (see Proposition 1)

Input: nS, nA ∈ ND
Output1: AreN eighbors ∈ {T rue, F alse}
Output2: c the index of the status block whose status value is changed from nS to
nA
AreN eighbors ← T rue
dif f erences ← 0
for all k = 1 to Card(BS
if nS(k) ̸= nA(k) then

▷ number of different status values between nS and nA

D) do

dif f erences ← dif f erences + 1
if dif f erences > 1 then

AreN eighbors ← F alse
break loop

end if
c ← k

end if

end for

▷ c is the index of the block that changes status from nS to nA

5 Reasoning with the SGST

In this section, we show how the convergence of the expected behavior of the
controller described by its logical diagram could be verified using the equivalent
SGST of that diagram. The SGST is composed of a set of nodes and edges
that reproduce the information encoded in the logical diagram in a formal and
explicit description. A node in the SGST corresponds to a possible state of the
controller, i.e. a possible combination of status values. An edge corresponds to
an evolution of a single status block. That is a change of the status value of a
block bs ∈ BS
D. The outgoing edges Enj of a node nj ∈ ND in the SGSTD graph
of a diagram D, are all the theoretical evolution possibilities of all the status
blocks from the node nj. In practice, only one of these outgoing edges e ∈ Enj ,
is traversed depending on the values of the input variables ID of the diagram.
A traversal of an edge (nS, nA) is the effective transition of the controller’s
state from the node nS to the node nA by running the correspondent status
block evolution of the traversed edge.
We remind that a full evaluation cycle of the logical diagram is held periodi-
cally by the controller. In each evaluation cycle of the diagram, status blocks are
evaluated one after another according to an order ω until each and every block
bs ∈ BS is evaluated once and only once.
In the SGST , for a set of input values Iv a full evaluation cycle corresponds to
a chain of successive edges traversed one after another in respect to the order of
evaluation ω. In some cases, many successive evaluation sequences ω may have

A graph based semantics for Logical Functional Diagrams

13

Algorithm 4 Build nseq
to status values in nS (see Definition 6)

S

the logical values sequence of outputs OBS

equivalent

D

Input: nS ∈ ND
Output: nseq
nseq
S ← T rue
for all k = 1 to Card(BS

S

D) do

S ← nseq
nseq
end for

S · (Evallogic(nS(bs

k)) · obs

+ Evallogic(nS(k)) · obs
k

)

k

to be run to finally converge to a node. However in other cases, even after
multiple evaluation sequences, this convergence may never be reached; Traversal
of edges could be endlessly possible for a set of input values Iv.
The convergence of status values is the property that we are going to study
in the rest of this paper. If we consider the real world case of power plants, the
convergence property has to be verified on the logical diagrams before imple-
menting them in the controllers. The non convergence of the evaluation cycles
of the diagram for a set of input values Iv leads to the physical output signals of
the controller alternating continuously between 0 and 1 which is a non-desired
phenomenon. In the SGST graph, this corresponds to a circuit of nodes being
visited over and over again indefinitely. We will define trails and circuits in the
graph then propose a formal criteria of behavior convergence on the SGST .

5.1 Traversal of the SGST : Trails

In the SGST , nodes are visited by traversing the edges that link them. A se-
quence of visited nodes in the graph is called a trail τ and is defined as follows:

Definition 8 (Trail τ ). For a given SGSTD = (ND, ED), a trail τ ∈ (ND)k,
with k ∈ N, is an ordered set of nodes (n1, n2,..., nk) where each pair of succes-
sive nodes ni and ni+1, with i ∈ {1..k − 1}, are neighboring nodes.

A trail is therefore a series of state changes along neighboring nodes in the SGST
graph. From the SGST we can form an infinite number of trails. However, only a
finite subset of these trails could be effectively traversed in practice. This is due
to the order ω of the evaluation of status blocks. We call trails that are conform
to the order ω determined trails. These trails correspond to the progressive
traversal of viable edges in the SGST for a set of input values Iv.

Definition 9 (Viability of an edge). Let e = (nS, nA) ∈ ED be an edge in
the SGST linking the start node nS to the arrival node nA. The edge e is said
to be viable for a set of input values Iv if the Boolean expression label(e) is True
for the values Iv. The traversal of the edge e changes the state of the controller
from nS to nA by changing the status value of a single block bs ∈ BS
D. We denote
the status block bs whose value was altered by going from nS to nA.
by bs

nS (cid:55)→nA

A node nk visited in the middle of a determined trail τ , can have multiple
outgoing edges in the SGST that are viable at the same time for a set of input
values Iv. Only one of the viable edges is traversed in accordance to the edge

14

Aziz Sfar, Dina Irofti, and Madalina Croitoru

Algorithm 5 Edge construction Algorithm

Input1: EV OLbs ∀bs ∈ BS
D
Input2: the set of nodes ND of the SGSTD
Output: the set of edges ED of the SGSTD; e ∈ E, e = (nS, nA, label)
for all (nS, nA) ∈ ND × ND do

AreNeighbors, c =Algorithm3(nS, nA)
whose status value is changed from nS to nA

▷ c is the index of the status block

if AreN eighbors = T rue then
nseq
S =Algorithm4(nS)
for all evol ∈ EV OLbs

c do

▷ bs

c is the block that changes status from nS
c is the evolution set of bs
c

▷ to nA; EV OLbs

if si(evol) = nS(c) and sf (evol) = nA(c) then ▷ Find the evolution of bs
c
▷ that corresponds to
▷ nS(c) (cid:55)→ nA(c)

expression = Cevol(evol)
if expression ∧ nSeq

S

̸= F alse then

▷ check if the expression of the evolution is contradictory
▷ to the logic values of status blocks outputs OBS
D
of nS

▷ given by the sequence nSeq

S

e = (nS, nA)
lE(e) = Cevol(evol)
add e to the set of edges ED
break loop

end if

end if

end for

end if

end for

traversal determination rule (nk−1 , nk)(cid:55)→ nk+1: the next viable edge (nk, nk+1)
to be traversed is the one that alters the status value of the block bs
of
the lowest order in ω after bs
the block whose status value changed from
nk−1 to nk.

nk−1(cid:55)→nk

nk(cid:55)→nk+1

Proposition 2 (edge traversal determination rule). Let ω ∈ (BS)L, be an
order of the evaluation sequence of status blocks, L = Card(BS). Let us suppose
that for a set of input values Iv, the controller is placed in the state of node nk,
coming from the previous node nk−1; between these two nodes, the status value
of the block bs
has changed. Let Nnext be the set of all the reachable nodes
from nk by the viable edges e =(nk,nnext), with nnext ∈ Nnext.
Then, the next node nk+1 ∈ Nnext to be effectively visited in the trail is satisfying:
) < ordω(bs
ordω(bs
) ∀nnext ∈ Nnext\{nk+1},
where ∀nj ∈ ND; ∀(nk, nj) ∈ ED then ordω(bs
) is the order of evaluation
in ω; bs
of the block bs

is the status changing block from nk to nj.

) < ordω(bs

nk(cid:55)→nnext

nk−1(cid:55)→nk

nk−1(cid:55)→nk

nk(cid:55)→nk+1

nk(cid:55)→nj

nk(cid:55)→nj

nk(cid:55)→nj

Example 5. Let us consider a logical diagram with three status blocks of memory
type BS = {M1, M2, M3}; the corresponding SGST graph is illustrated in
Figure 4, and has four nodes and three edges. We fix the set of inputs values (i1,

A graph based semantics for Logical Functional Diagrams

15

i2, i3)=(1, 1, 1). We suppose that the last visted node is nk coming from nk−1. We
note that, from the node nk, both edges e2=(nk, nu) and e3=(nk, nv), labeled
i2 and i3, respectively, are viable for the input values (1, 1, 1). The following

Fig. 4. Trail building in an SGST graph. Two possible trails are valid for the same
input values Iv in this example, depending on the order of evaluation of the three status
blocks, M1, M2, M3.

node of the trail τ =(nk−1, nk) is determined in accordance with Proposition 2.
We first consider ω =(M1, M2, M3) the order of evaluation of the three status
blocks. The last traversed edge is e1=(nk−1, nk) with a change on the status
value of the block M1 of order ordω(M1) = 1 in the evaluation sequence ω.
Edge e2 alters the status value of the block M2 of order ordω(M2) = 2 while
the edge e3 alters the status value of the block M3 of order ordω(M3) = 3.
Since ordω(M1) = 1 < ordω(M2) = 2 < ordω(M3) = 3, the next status block
to be evaluated after M1 is M2, so the next node in the trail τ is nk+1 = nu.
In this case, τ =(nk−1, nk, nu). However, if we consider ω =(M3, M2, M1), i.e.
ordω(M3) = 1, ordω(M2) = 2, ordω(M1) = 3, then the last evaluated block
M1 in the trail (nk−1, nk) is of order 3 which is the last order in the evaluation
sequence ω. For the same input values (i1, i2, i3)=(1, 1, 1), the next block to
be evaluated from nk is this time M3 of the order 1, which corresponds to edge
e3=(nk, nv). In this case, τ =(nk−1, nk, nv).

We make the assumption that the initial node of a determined trail is a perma-
nent node. A permanent node, unlike a transitional node, is a node in which
the controller’s state can remain permanently for a certain set of input values.

Definition 10 (permanent node). Let nk ∈ ND be a node, and Enk ⊂ ED the
set of outgoing edges from the node nk. We say that the node nk is a permanent
node if ∃ Iv, a set of input values, satisfying the holding on condition of the node
nk: CHold = (cid:81)

label(ei).

ei∈Enk

Example 6. For the SGST graph given in Figure 2, node n2 has two outgoing
edges labeled i5 and T rue. The holding on condition of node n2 is CHold =
i5 · T rue = F alse. This condition is False for any set of input values Iv; thus,
n2 is not a permanent node. The node n1 has only one outgoing edge labeled
i5 · (i1 + i4) · (i1 + i3) · (i4 + i2) · (i2 + i3). The holding on condition of node n1 is

CHold = i5 · (i1 + i4) · (i1 + i3) · (i4 + i2) · (i2 + i3) = i5+i2·i3+i2·i4+i3·i1+i1·i4,

and can be satisfied for certain sets of input values, e.g. (i1, i2, i3, i4, i5) =
(0, 0, 0, 0, 1). Thus, node n1 is a permanent node. From the permanent node n1,

 M1_0    M2_0    M3_0 M1_0    M2_0    M3_0 M1_0    M2_0    M3_0 M1_0    M2_0    M3_0i2i3i1nk-1nknunv16

Aziz Sfar, Dina Irofti, and Madalina Croitoru

and for an order of evaluation ω =(M2, T1), a possible determined trail that
could be effectively traversed would be τ1=(n1, n2, n3, n4, n6, n1) for the order
ω =(M2, T1) and the set of input values (i1, i2, i3, i4, i5) = (1, 0, 0, 1, 0).

5.2 Formal verification of the convergence property in the SGST
In practice, we say that a signal converges if its periodic evaluation by the logic
controller gives a constant value over a long time range during which the input
signals I remain constant. A non convergent Boolean signal is a signal that
keeps oscillating between 0 and 1 over multiple evaluation cycles of the logic
controller while input values are unchanged. In the SGST , oscillating Boolean
signals correspond to an indefinite visiting of the same subset of nodes over and
over again. This causes an indefinite change of status values, which results in its
turn to an indefinite change of logic values at the output of status blocks.

Definition 11 (Circuits in the SGST ). We define a circuit in a SGST
graph as a finite series of nodes (n1,n2,. . . ,nm) such that the consecutive nodes
nk and nk+1 are neighboring nodes and n1 = nm.

However, a determined trail in the SGST graph could contain a circuit of nodes
without necessarily traversing it indefinitely. Indeed, a trail could correspond to
a one-time traversal of a circuit to leave it as soon as it visits the same node
twice, as shown by Example 7.

Fig. 5. Example of multiple circuits in an SGST graph.

Example 7. We consider the SGST graph given by Figure 5. The status blocks
of the SGST are BS={M1, M2}. It contains three possible circuits (n1, n2, n1),
(n1, n3, n1) and (n1, n2, n1, n3, n1). We suppose the evaluation order ω=(M2,
M1). We fix a set of input values (i1, i2, i3, i4) = (1, 1, 1, 0). Using Proposition 2,
we obtain the trail τ =(n1, n3, n1, n2), starting from the permanent node n1. We
can observe that τ contains the circuit (n1, n3, n1), but this circuit is quit to the
node n2. However, if we fix the set of input values at (i1, i2, i3, i4) = (1, 1, 0, 0),
and start from node n1, we obtain the trail τ =(n1, n3, n1, n3) that is equivalent
to an indefinite traversal of the circuit (n1, n3, n1).

Generally, if for an input Iv the progressive calculation of a the nodes of a trail τ
results in visiting twice the same successive neighboring node couple (nk, nk+1),
then τ corresponds to a circuit of nodes that can be indefinitely visited and the
outputs of the blocks whose status values are changed in that trail are oscillating.

M1_1     M2_1i2M1_1     M2_0M1_0     M2_1i4i3i1A graph based semantics for Logical Functional Diagrams

17

Definition 12 (Convergence property in a trail). We denote by T ω
SGST
the set of all determined trails in the SGST that can be effectively traversed for
an evaluation order ω. A trail τ = (n1, n2, ..., nm) ∈ T ω
SGST is convergent if
ek ̸= ej ∀ek = (nk, nk+1), ej = (nj, nj+1) two tuples of neighboring nodes in τ .

Definition 13 (Convergent logical diagram). We say that a logical diagram
D is convergent for all the sets of input values if all the determined trails of its
SGSTD are convergent.

We propose a method for searching all the determined trails T ω
SGST for an evalu-
ation order ω. Trails are determined by giving their symbolic Boolean condition
of traversal instead of the sets of input values. This means that a determined
trail τ ∈ T ω
SGST is defined by the sequence of its nodes τ = (n1, n2, ..., nm−1, nm)
and its traversal condition Cτ = (cid:81)
Starting from each permanent node in the SGST we calculate all the possible
trails based on the trail determination rule for an order ω (Proposition 2). From
each node we explore all the possible outgoing edges by negating the condition
labels of edges alternating the blocks of the least order. Each label of an explored
edge is added to Cτ . For instance, let us suppose that a trail reaches a node nk
coming from nk−1 and that nk that has two outgoing edges e1=(nk, nu) and
e2=(nk, nv). τ = (n1, n2, ..., nk−1, nk), Cτ = (cid:81)
j∈{1..k−1} label(ek = (nj, nj+1)).

k∈{1..m−1} label(ek = (nk, nk+1)).

Fig. 6. Trail traversal condition update.

nk(cid:55)→nu

nk−1(cid:55)→nk

) < ordω(bs

We suppose that ordω(bs
) < ordω(bs
), for the or-
der ω. Since the status block altered by e1 is of a lower order than the one
altered by e2, if label(e1) = T rue then e1 is the next movement in τ , but if
label(e1) = F alse and label(e2) = T rue then the next movement in τ is e2.
Thus, two determined trails τ1 and τ2 can branch off from the determined trail
τ at nk such that Cτ1 = Cτ · label(e1) and Cτ2 = Cτ · label(e1) · label(e2). Both
new trails continue the course and branch off to more possible trails at each bi-
furcation. Path exploration of a trail can stop in one of the following scenarios:

nk(cid:55)→nv

– If the last encountered node nk is a permanent node. Here, τ is a determined
trail that puts the controller in the state of the node nk starting from the
state of the initial node n1 for all the input values Iv that satisfy Cτ .

– If for the last encountered node nk, the update of the traversal condition
Cτ · label(e = (nk−1, nk)) is False. This means that the trail is not possible
due to a contradiction of the condition labels of the graph edges crossed by
the trail.

n1nvnk-1nunke1e218

Aziz Sfar, Dina Irofti, and Madalina Croitoru

– If the last two couple of nodes (nk−1, nk) have already been visited in τ . In
this case τ corresponds to a circuit of nodes that can be effectively traversed
an infinite number of times for the inputs values Iv satisfying condition Cτ .

Example 8. The SGST example of Figure 2 has only one permanent node n1.
Starting from n1, only two determined trails are possible in the case of the
evaluation order ω = (T1, M2):
τ1 = (n1, n1), Cτ1 = i5+i2·i3+i2·i4+i3·i1+i1·i4, τ2 = (n1, n2, n3, n4, n6, n1, n2),
Cτ2 = i5 · (i1 + i4) · (i1 + i3) · (i4 + i2) · (i2 + i3). τ2 does not converge meaning
that for any set of input values Iv that satisfies Cτ2 the nodes of τ2 are visited
indefinitely which causes oscillating signals in the controller.

6 Discussion

In this paper, we proposed a formal model, called the SGST graph, representing
the possible states of a controller programmed based on a logical diagram spec-
ification. We show how to transform the logical diagram into the corresponding
SGST graph, and how to verify the convergence property, i.e. verify that the
controller does not have undesired oscillatory behavior.

Making sure that the behavior described by the logical diagram converges
is crucial for test generation and for the overall verification and validation pro-
cedure. However, this is not the sole goal of transforming logical diagrams into
SGST graphs. We developed the SGST to take a step in the application of
the existing formal testing methods on logical diagrams. For the time being,
generating tests derived from logical diagram specifications of power plants log-
ical controllers is still handled manually or simulation-based. So, we designed
the SGST to provide an explicit formal and exhaustive representation of the
evolution steps between possible states of the controller described by a logical
diagram. A test scenario is a sequence of these steps which are modeled with
edges in the SGST . Therefore, the test sequences generation could be trans-
posed into the application of existing graph traversal techniques such as the
Chinese postman tour [14]. The existing test generation ([5, 13]) and selection
techniques are based on finite state machines specifications. We consider the
SGST to be an important intermediate step to move from non-formal diagrams
to state machines. A coded solution of the developed method has shown that
the construction of the SGST is feasible for small to medium sized logical di-
agrams and provides very accurate graph representations. However, the SGST
generation for diagrams with tens of memory and timer blocks is quite expensive
in terms of complexity. This is due to the number of maximal states being in
the worst case exponential to the number of blocks which can quickly lead to an
explosion of the graph size.

We are currently working on methods to resolve the complexity problems
such as the partition of the diagram into sub-diagrams and transforming them
in SGST s then synchronizing them. Further work on complexity as well as
transforming SGST graphs into state machines to apply test generation results
in the literature for controllers described with logical diagrams will be handled
in the future.

A graph based semantics for Logical Functional Diagrams

19

References

1. Alur, R., Dill, D.L.: A theory of timed automata. Theoretical computer science

126(2), 183–235 (1994)

2. Fayyazi, M., Kirsch, L.: Efficient simulation of oscillatory combinational loops. In:

Proceedings of the 47th Design Automation Conference. pp. 777–780 (2010)

3. Jean-fran¸cois Hery, J.c.L.: Stabilit´e de la sp´ecification logique du contrˆole-

commande - m´ethodologie et mise en œuvre. Tech. rep., EDF R&D (2019)

4. IEC, P.P.: Instrumentation and control important to safety–general requirements

for systems. iec 61513. International Electrotechnical Commission (2011)

5. Lee, D., Yannakakis, M.: Principles and methods of testing finite state machines-a

survey. Proceedings of the IEEE 84(8), 1090–1123 (1996)

6. Lukoschus, J., Von Hanxleden, R.: Removing cycles in esterel programs. EURASIP

Journal on Embedded Systems 2007, 1–23 (2007)

7. Malik, S.: Analysis of cyclic combinational circuits. IEEE Transactions on
Computer-Aided Design of Integrated Circuits and Systems 13(7), 950–956 (1994)
8. Neiroukh, O., Edwards, S., Song, X.: An efficient algorithm for the analysis of cyclic
circuits. vol. 2006, p. 6 pp. (04 2006). https://doi.org/10.1109/ISVLSI.2006.18
9. Peled, D., Vardi, M.Y., Yannakakis, M.: Black box checking. In: Formal Methods
for Protocol Engineering and Distributed Systems, pp. 225–240. Springer (1999)

10. Provost, J., Roussel, J.M., Faure, J.M.: Translating grafcet specifications into
mealy machines for conformance test purposes. Control Engineering Practice
19(9), 947–957 (2011)

11. Riedel, M.D.: Cyclic combinational circuits. California Inst. of Technology (2004)
12. Shiple, T.R., Berry, G., Touati, H.: Constructive analysis of cyclic circuits. In:
Proceedings ED&TC European Design and Test Conference. pp. 328–333 (1996)
13. Springintveld, J., Vaandrager, F., D’Argenio, P.R.: Testing timed automata. The-

oretical computer science 254(1-2), 225–257 (2001)

14. Thimbleby, H.: The directed chinese postman problem. Software: Practice and

Experience 33(11), 1081–1096 (2003)

