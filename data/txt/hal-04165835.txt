Subhedge Projection for Stepwise Hedge Automata
Antonio Al Serhali, Joachim Niehren

To cite this version:

Antonio Al Serhali, Joachim Niehren. Subhedge Projection for Stepwise Hedge Automata. 24th Inter-
national Symposium on Fundamentals of Computation Theory, FCT 2023, Sep 2023, Trier, Germany.
￿hal-04165835v3￿

HAL Id: hal-04165835

https://inria.hal.science/hal-04165835v3

Submitted on 1 Nov 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution 4.0 International License

Subhedge Projection for
Stepwise Hedge Automata

Antonio Al Serhali and Joachim Niehren

Inria and University of Lille, France

Abstract. We show how to evaluate stepwise hedge automata (Shas)
with subhedge projection. Since this requires passing finite state infor-
mation top-down, we introduce the notion of downward stepwise hedge
automata. We use them to define an in-memory and a streaming eval-
uator with subhedge projection for Shas. We then tune the streaming
evaluator so that it can decide membership at the earliest time point. We
apply our algorithms to the problem of answering regular XPath queries
on Xml streams. Our experiments show that subhedge projection of
Shas can indeed speed up earliest query answering on Xml streams.

1

Introduction

Projection is necessary for running automata on words, trees, hedges or nested
words efficiently without having to evaluate irrelevant parts of the input struc-
ture. Projection is most relevant for Xml processing as already noticed by
[15,8,14]. Saxon’s in-memory evaluator, for instance, projects input Xml docu-
ment relative to an Xslt program, which contains a collection of XPath queries
to be answered simultaneously [11]. When it comes to processing Xml streams,
quite some algorithms [13,16,10,6] are based on nested word automata (Nwas),
for which an efficient projection algorithm exists [20].

More recently, it was noticed that stepwise hedge automata (Sha) [19] have
important advantages over Nwas when it comes to determinization and earliest
query answering [10]. Shas are a recent variant of standard hedge automata that
go back to the sixties [5,21]. They mix up bottom-up processing of standard tree
automata with the left-to-right processing of finite word automata (Nfas), but
do neither support top-down processing nor have an explicit stack in contrast to
Nwas. In particular, it could be shown that earliest query answering for regular
queries defined by deterministic Shas [3] has a lower worst case complexity than
for deterministic Nwas [10]. Shas have the advantage that the set of states that
are accessible over some hedge from a given set of start states can be computed
in linear time, while for Nwas this requires cubic time.

Based on deterministic Shas, earliest query answering for regular queries
became feasible in practice [3], as shown for a collection of deterministic Shas
for real word regular XPath queries on Xml documents [2]. On the other hand
side, it is still experimentally slower than the best non-earliest approaches [6]. We
believe that this is due to the fact that projection algorithms for Sha evaluation

2

A. Al Serhali and J. Niehren

are missing. Projecting in-memory evaluation assumes that the full graph of the
input hedge is constructed at beforehand. Nevertheless, projection may still save
time, if one has to run several queries on the same input hedge, or, if the graph
got constructed for different reasons anyway. In the streaming case with subhedge
projection, the situation is similar: the whole input hedge on the stream needs
to be parsed. But only for the nodes that are not projected away, the automaton
transitions need to be computed. Given that pure parsing is by two or three
orders of magnitude faster, one can save considerable time as noticed in [20].

Consider the example of the XPath filter [self::list][child::item] that
is satisfied by an Xml document if its root is an list element that has some
item child. When evaluating this filter on an Xml document, it is sufficient to
inspect its roots for having label list and then all its children until some item
is found. The subhedges of these children can be projected away. However, one
must memoize whether the level of the current node is 0, 1, or greater. This level
information can be naturally updated in a top-down manner. The evaluators
of Shas, however, operate bottom-up and left-to-right exclusively. Therefore,
projecting evaluators for Shas need to be based on more general machines. It
would not be sufficient to map Shas to Nwas and use their projecting evaluators
[20]. The Nwas obtained by compilation from Shas do not push any information
top-down, so no projection is enabled. Thus, the objective of the present paper
is to develop evaluators with subhedge projection for Shas.

As more general machines we propose downward stepwise hedge automata
(Sha↓s), a variant of Shas that support top-down processing in addition. They
are basically Neumann and Seidl’s pushdown forest automata [17], except that
they apply to unlabeled hedges instead of labeled forests. Nwas are known to
operate similarly on nested words [9], while allowing for more general visible
pushdowns. We then distinguish subhedge projection states for Sha↓s, and show
how to use them to evaluate Shas with subhedge projection both in-memory and
in streaming mode. Alternatively, subtree projecting evaluators for Sha↓s could
be obtained by compiling them to Nwas, distinguishing irrelevant subtrees there
[20], and using them for subtree projecting evaluation via projecting Nwas.

As a first and main contribution, we show how to compile Shas to Sha↓s
so that one can distinguish appropriate subhedge projection states. The idea is
to distinguish contexts in which states of the Sha will safely not change. For
instance, the XPath filter [self::list][child::item] can be defined by the
deterministic Sha in Fig. 1, which our compiler maps to the Sha↓ in Fig. 2 (up
to renaming of states). The context information made explicit is about the levels
of the states. This permits us to distinguish a projection state Π taken from
level 2 on in which subhedges can be ignored.

We prove the soundness of our compiler given in the appendix. The proof
is based on an nontrivial invariant, that we establish for a slight adaptation of
the original projection algorithm published at FCT [4]. We also note that our
compiler may in the worst case increase the size of the automata exponentially.
Therefore, we avoid constructing the Sha↓s statically but rather construct only

Subhedge Projection for SHAs

3

Sha

Fig. 1: A unique minimal
deterministic
(with
initial state equal tree ini-
tial state) for the XPath filter
[self::list][child::item].

Fig. 2: The deterministic Sha↓
with subhedge projection state
Π obtained by our compiler.

the needed part of the Sha↓s dynamically on the fly when using it to evaluate
some hedge with subhedge projection.

Our second contribution is a refinement of the compiler from Shas to Sha↓s
for distinguishing safe states for rejection and selection. In this way, we obtain an
earliest membership tester for deterministic Shas in streaming mode which im-
proves the recent earliest membership tester of [3] with subhedge projection. The
property of being earliest carries over from there. We lifted this earliest member-
ship tester to an earliest query answering algorithm with subhedge projection
for monadic queries defined by deterministic Shas but omit the details.

Our third contribution is an implementation and experimental evaluation
of an earliest query answering algorithm for dShas with subhedge projection
(not only of earliest membership testing), by introducing subhedge projection
into the AStream tool [3]. For the evaluation, we consider the deterministic
Shas constructed with the compiler from [19] for the forward regular XPath
queries of the XPathMark benchmark [7] and real-world XPath queries [2]. It
turns out that we can reduce the running time for all regular XPath queries
that contain only child axes considerably since large parts of the input hedges
can be projected away. For such XPath queries, the earliest query answering
algorithm of AStream with projection becomes competitive in efficiency with
the best existing streaming algorithm from QuiXPath [6] (which is non-earliest
on some queries though). The win is smaller for XPath queries with descendant
axis, where only few subhedge projection is possible.
Outline. After some preliminaries in Section 2 and 3. In Section 4 we introduce
Sha↓s and show that they enable in-memory evaluation with subhedge projec-
tion. In Section 5 we show how to compile Shas to Sha↓s with subhedge pro-
jection states. Streaming evaluators for Sha↓s with subhedge projection follow
in Section 6. Section 7 improves the compiler from Shas to Sha↓s for obtaining
an earliest membership tester. Section 8 discusses our practical experiments.

4

A. Al Serhali and J. Niehren

Publication Comments. This orignial version of this paper paper was pub-
lished at FCT [4] without appendix. The appendix of the present longer version
[1] contains supplementary material including in particular the soundness proof
of the safe-no-change subhedge projection algorithm. It also contains further
discussion on related work.

2 Preliminaries

Let A and B be sets and r ⊆ A × B a binary relation. The domain of r is
dom(r) = {a ∈ A | ∃b ∈ B. (a, b) ∈ r}. We call r total if dom(r) = A. A partial
function f : A (cid:44)→ B is a relation f ⊆ A × B that is functional. A total function
f : A → B is a partial function f : A (cid:44)→ B that is total.
Words. Let N be the set of natural numbers including 0. Let the alphabet Σ
be a set. The set of words over Σ is Σ∗ = ∪n∈NΣn. A word (a1, . . . , an) ∈ Σn
where n ∈ N is written as a1 . . . an. We denote the empty word of length 0 by
ε ∈ Σ0 and by v1 · v2 ∈ Σ∗ the concatenation of two words v1, v2 ∈ Σ∗.
Hedges. Hedges are sequences of letters and trees ⟨h⟩ with some hedge h. More
formally, a hedge h ∈ HΣ has the following abstract syntax:

h, h ′ ∈ HΣ ::= ε

| a |

⟨h⟩

| h · h ′

where a ∈ Σ

We assume ε · h = h · ε = h and (h · h1) · h2 = h · (h1 · h2). Therefore, we consider
any word in Σ∗ as a hedge in HΣ, i.e., Σ∗ ∋ aab = a · a · b ∈ HΣ.
Nested Words. Hedges can be identified with nested words, i.e., words over
the alphabet ˆΣ = Σ ∪ {⟨, ⟩} in which all parentheses are well-nested. This
is done by the function nw (h) : HΣ → (Σ ∪ {⟨, ⟩})∗ such that: nw (ε) = ε,
nw (⟨h⟩) = ⟨ · nw (h) · ⟩, nw (a) = a, and nw (h · h ′) = nw (h) · nw (h ′).

3 Stepwise Hedge Automata (SHAs)

Stepwise hedge automata (Shas) are automata for hedges mixing up bottom-up
tree automata and left-to-right word automata.

Definition 1. A stepwise hedge automaton ( Sha) is a tuple A = (Σ, Q, ∆, I, F )
where Σ and Q are finite sets, I, F ⊆ Q, and ∆ = ((a∆)a∈Σ, ⟨⟩∆, @∆) where:
a∆ ⊆ Q × Q, ⟨⟩∆ ⊆ Q, and @∆ : (Q × Q) × Q. A Sha is deterministic or
equivalently a d Sha if I and ⟨⟩∆ contain at most one element, and all relations
(a∆)a∈Σ and @∆ are partial functions.

The set of state q ∈ Q, subsumes a subset I of initial state, a subset F of final
states, and a subset ⟨⟩∆ of tree initial states. The transition rules in ∆ have three
forms: If (q, q′) ∈ a∆ then we have a letter rule that we write as q a−→ q′ in ∆.
If (q, p, q′) ∈ @∆ then we have an apply rule that we write as: q@p → q′ in ∆.
And if q ∈ ⟨⟩∆ ∈ Q then we have a tree initial rule that we denote as

⟨⟩
−→ q in ∆.

Subhedge Projection for SHAs

5

0

0

⟨⟩

list

1

0

⟨⟩

item

2

4

3

Fig. 3: A successful run of the Sha in Fig. 1 on ⟨list · ⟨item⟩⟩.

For any hedge h ∈ HΣ we define the transition relation h−→ wrt ∆ such that for
all q, q′, p, p′ ∈ Q, a ∈ Σ, and h, h ′ ∈ HΣ:

true
q ε−→ q wrt ∆

q a−→ q′ in ∆
q a−→ q′ wrt ∆

q h−→ q′ wrt ∆ q′ h′
q h·h′

−−→ q′′ wrt ∆

−→ q′′ wrt ∆

⟨⟩
−→ p in ∆ p h−→ p′

q@p′ → q′ in ∆

⟨h⟩
−−→ q′ wrt ∆
A run of the dSha in Fig. 1 on the tree ⟨h⟩ with subhedge h = list · ⟨item⟩

q

⟨h⟩
−−→ 4 wrt ∆. The
is illustrated graphically in Fig. 2. It justifies the transition 0
run starts on the top-most level of ⟨h⟩ in the initial state 0 of the automaton.
The run on the topmost level is suspended immediately. Instead, a run on the
tree’s subhedge h on the level below is started in the tree initial state, which is 0

⟨⟩
since
−→ 0 in ∆. This run eventually ends up in state 3 justifying the transition
0 h−→ 3 wrt ∆. The run of the upper level is then resumed from state 0. Given
that 0@3 → 4 in ∆ it continues in state 4. In the graph, this instance of the
suspension/resumption mechanism is illustrated by the box in the edge 0
4. The box stands for a future value. Eventually, the box is filled by state 3, as
so that the computation can continue. But in state 4, the
illustrated by 3
upper hedge ends. Since state 4 is final the run ends successfully. The run on the
subhedge justifying 0 h−→ 3 wrt ∆ works in analogy.

A hedge is accepted if its transition started in some initial state reaches some

final state. The language L(A) is the set of all accepted hedges:

L(A) = {h ∈ HΣ | q h−→ q′ wrt ∆, q ∈ I, q′ ∈ F }

For any subset Q ⊆ Q and hedge h ∈ HΣ we define the in-memory evaluation:
(Q) = {q′ | q h−→ q′ wrt ∆, q ∈ Q}. An in-memory membership tester for
h
(cid:75)
(cid:74)
(I) by applying the transition
h ∈ L(A) can be obtained by computing
relation to all elements recursively and testing whether it contains some final
state in F .

h
(cid:75)

(cid:74)

6

A. Al Serhali and J. Niehren

0

0’

⟨⟩

list

1’

0”

⟨⟩

list

1′′

h1

Π

1’

⟨⟩

1′′

0”

item

2”

h2

Π

2”

4

3’

Fig. 4: A run of the Sha↓ in Fig. 2 on ⟨list · ⟨list · h1⟩ · ⟨item · h2⟩⟩.

4 Downward Stepwise Hedge Automata (SHA↓s)

Shas process information bottom-up and left-to-right exclusively. We next pro-
pose an extension to downward stepwise hedge automata with the ability to
pass finite state information top-down. These can also be seen as an extension
of Neumann and Seidl’s pushdown forest automata [18] from (labeled) forests to
(unlabeled) hedges.

Definition 2. A downward stepwise hedge automaton (Sha↓) is a tuple A =
(Σ, Q, ∆, I, F ) where Σ and Q are finite sets, I, F ⊆ Q, and ∆ = ((a∆)a∈Σ, ⟨⟩∆,
@∆). Furthermore, a∆ ⊆ Q × Q, ⟨⟩∆ ⊆ Q × Q, and @∆ : (Q × Q) × Q. A Sha↓
is deterministic or equivalently a dSha↓ if I contains at most one element, and
all relations ⟨⟩∆, a∆, and @∆ are partial functions.

The only difference to Shas is the form of the tree opening rules. If (q, q′) ∈
⟨⟩
−→ q′ in ∆. So here
⟨⟩∆ ∈ Q then we have a tree initial rule that we denote as: q
the state q′ where the evaluation of a subhedge starts depends on the state q of
the parent. The definition of the transition relation and thus the evaluator of a
Sha↓ differs from that of a Sha by the following equation:

⟨⟩
−→ p in ∆ p h−→ p′ wrt ∆ q@p′ → q′ in ∆

q

⟨h⟩
−−→ q′ wrt ∆

q

This means that the evaluation of the subhedge h starts in some state p such

⟨⟩
that q
−→ p in ∆. So the restart state p now depends on the state q above. This
is how finite state information is passed top-down by Sha↓s. Shas in contrast
operate purely bottom-up and left-to-right.

An example of an in-memory evaluation on the dSha↓ in Fig. 2 for the filter
[self::list][child::item] is shown in Fig. 4. The run of Sha↓s works quite
similarly to the runs of Shas, just that when restarting a computation in the
subhedge of some tree in state q, then it will start in some state p such that

⟨⟩
−→ p (rather than in some tree initial state that is independent of q). This

q

Subhedge Projection for SHAs

7

Fig. 5: The Sha↓ Adown for the dSha A in Fig. 1.

can be noticed for example when opening the first subtree labeled with item
⟨⟩
where a transition rule 1′
−→ 0′′ is applied. One can see that all nodes of the
subtrees h1 and h2 are evaluated to the projection state Π, which holds finite-
state information on the current level that was passed top-down.

Any Sha A = (Σ, Q, ∆, I, F ) can be mapped to a Sha↓ Adown = (Σ, Q, ∆down ,

I, F ) with the same runs and language. The only change is described by the fol-
lowing rule.

⟨⟩
−→ p in ∆ q ∈ Q

⟨⟩
−→ p in ∆down

q

Independently of the current state q ∈ Q, the Sha↓ Adown can start the eval-
uation of the subhedge of a subtree in any open tree state p ∈ ∆. Note that
the conversion preserves determinism. For illustration, the dSha↓ for dSha from
Fig. 1 of the introduction is given in Fig. 5. As for other kinds of automata,
making them multi-way does not add expressiveness. So we can convert any
dSha↓ A into an equivalent Sha by introducing nondeterminism . Since Shas
can be determinized in at most exponential time, the same holds for Sha↓s. It is
sufficient to convert it to a Sha, determinize it, and identify the resulting dSha
with a dSha↓.

We next show how to get subhedge projection for Sha↓s. Two notions will

be relevant here, automata completeness and subhedge projection states.

So let A = (Σ, Q, ∆, I, F ) be a Sha↓. We call ∆ complete if all its relations
(a∆)a∈Σ, ⟨⟩∆ and @∆ are total. We call A complete if ∆ is complete and I ̸= ∅.

Definition 3. We call a state q ∈ Q a subhedge pro-
jection state of ∆ if there exists q′ ∈ Q called the witness
of q such that the set of transition rules of ∆ containing
q′ or with q on the leftmost position is included in:

⟨⟩

−→ q′, q@q′ → q, q′ ⟨⟩
{q
∪{q′ a−→ q′, q a−→ q | a ∈ Σ}

−→ q′, q′@q′ → q′}

q′

q

⟨⟩

⟨⟩

q′

q′

a ∈ Σ

a ∈ Σ

8

A. Al Serhali and J. Niehren

In the example Sha↓ in Fig. 2 Π is a subhedge projection state with witness
Π, but also the states 3′, 4, and 2′′ are subhedge projection states with witness
Π. Note that only inclusion holds for the latter but not equality since this
automaton is not complete.

For complete Sha↓s A, the above set must be equal to the set of transition
rules of ∆ with q or q′ on the leftmost position. In the soundness expressed in
Proposition 4, completeness will be assumed and the proof relies on it. In the
examples, however, we will consider automata that are not complete. Still they
are “sufficiently complete” to illustrate the constructions.

Note that a subhedge projection state q may be equal to its witness q′.
Therefore the witness q′ of any subhedge projection state is itself a subhedge
projection state with witness q′.

Let P ⊆ Q be a subset of subhedge projection states of ∆. We define the
transition relation with projection h−→P ⊆ Q × Q with respect to ∆ such that for
all hedges h, h′ ∈ HΣ and letters a ∈ Σ:

q ∈ P
q h−→P q wrt ∆

q ̸∈ P q a−→ q′ in ∆
q a−→P q′ wrt ∆

q ̸∈ P
q ε−→P q wrt ∆

q ̸∈ P q h−→P q′ wrt ∆ q′ h′
q h·h′

−−→P q′′ wrt ∆

−→P q′′ wrt ∆

q ̸∈ P q

⟨⟩

−→ p in ∆ p h−→P p′

q@p′ → q′ in ∆

⟨h⟩
−−→P q′′ wrt ∆

q

Transitions with respect to P stay in states q ∈ P until the end of the current
subhedge is reached. This is correct if p is a subhedge projection state since
transitions without subhedge projection don’t change state p nor if the run is
not blocking.

Proposition 4. Let A = (Σ, Q, ∆, I, F ) be a complete Sha↓ and P a subset
of subhedge projection states for ∆. Then for all hedges h ∈ HΣ and states
q, q′ ∈ Q: q h−→ q′ wrt ∆ iff q h−→P q′ wrt ∆.

For any subset Q ⊆ Q and hedge h ∈ HΣ, we define the in-memory evaluation
P (Q) = {q′ ∈ Q | q h−→P q′ wrt ∆, q ∈ Q}. An in-
with subhedge projection:
memory membership tester for h ∈ L(A) with subtree projection can be obtained
by computing

P (I) and testing whether it contains some state in F .

h
(cid:75)

(cid:74)

h
(cid:75)
(cid:74)

5 Compiling SHAs to SHA↓s with Projection States

We show how to compile any Sha to some Sha↓ with subhedge projection states,
yielding an evaluator with appropriate subhedge projection for the Sha via the
Sha↓. This compiler is the most original contribution of the paper.

Subhedge Projection for SHAs

9

Let A = (Σ, Q, ∆, I, F ) be a Sha. For any set Q ⊆ Q we define the set
acc∆(Q) = {q′ ∈ Q | ∃ q ∈ Q, h ∈ HΣ. q h−→ q′ wrt ∆}. We note that acc∆(Q)
can be computed in linear time in the size of ∆. We define:

safe ∆(Q) = {q ∈ Q | acc∆({q}) ⊆ Q}

If A is complete and deterministic then safety can be used to characterize uni-
versal states, since for all q ∈ Q: L(A[I/{q}]) = HΣ if and only if q ∈ safe ∆(F ).
See Lemma 5 of [3]. Note that safe ∆(Q) can be computed in linear time in the
size of ∆. We define the set of states that may no more change by:

no-change ∆ = {q | q ∈ safe ∆({q})}

Note that q ∈ no-change ∆ if and only if acc∆({q}) ⊆ {q}. In the example
automaton from Fig. 1 we have no-change ∆ = {2, 3, 4}. For any state q ∈ Q and
subset of states Q ⊆ Q we define:

s-down ∆(q, Q) = safe ∆({p ∈ Q | q@∆p ⊆ Q})
s-no-change ∆(q) = s-down ∆(q, {q})

A state belongs to s-down ∆(q, Q) if it can either no more change or if all acces-
sible states p satisfy that q@∆p ⊆ Q.

We next compile the Sha A to a Sha↓ Aπ = (Σ, Qπ, ∆π, I π, F π). For this

let Π be a fresh symbol and consider the state set:

Qπ = {Π} ⊎ (Q × 2Q)

A pair (q, P ) means that the evaluator in state q may project subhedges if q ∈ P
since these will no more lead to any relevant change. The sets of initial and final
states are defined as follows:

I π = {(q, ∅) | q ∈ I}

F π = {(q, ∅) | q ∈ F }

How to generated the transition rules of Aπ from those of A is described in
Fig. 6.

When applied to the Sha in Fig. 1 for [self::list][child::item], the
construction yields the Sha↓ in Fig. 7 which is indeed equal to the Sha↓ from
Fig. 2 up to state renaming. When run on the hedge ⟨list · ⟨list · h1⟩ · ⟨item · h2⟩⟩
as shown in Fig. 4, it does not have to visit the subhedges h1 nor h2, since all
of them will be reached starting from the projection state Π.

Proposition 5 (Soundness). L(Aπ) = L(A) for any complete Sha A.

We have to prove that no more changing states q ∈ P ∪ no-change ∆ is
sound. If q ∈ no-change ∆ this follows from the completeness of ∆, so that
one can neither block nor change the state. In the case q ∈ P , the intuition is
that the state on level above – say r – can no more change, since then P =
s-no-change ∆(r). Neither can the automaton block by completeness.

10

A. Al Serhali and J. Niehren

q a−→ q′ in ∆ q ̸∈ P ∪ no-change ∆
(q, P ) a−→ (q′, P ) in ∆π

q ∈ P ∪ no-change ∆
(q, P ) a−→ (q, P ) in ∆π

⟨⟩
−→ q′ in ∆ q ̸∈ P ∪ no-change ∆

q ∈ P ∪ no-change ∆

(q, P )

⟨⟩
−→ (q′, s-no-change ∆(q)) in ∆π

(q, P )

⟨⟩
−→ Π in ∆π

q@p → q′ in ∆ q ̸∈ P ∪ no-change ∆

(q, P )@(p, s-no-change ∆(q)) → (q′, P ) in ∆π

q ∈ P ∪ no-change ∆
(q, P )@Π → (q, P ) in ∆π

a ∈ Σ
Π a−→ Π in ∆π

true
Π@Π → Π in ∆π

true

Π

⟨⟩
−→ Π in ∆π

Fig. 6: The transition rules of the Sha↓ Aπ inferred from those of the Sha A.

The projecting in-memory evaluator of Aπ will be more efficient than that
the nonprojecting evaluator of A. Note, however, that the size of Aπ may be
exponentially bigger than that of A. Therefore, for evaluating a dSha A with
subhedge projection on a given hedge h, we create only the needed part of Aπ
on the fly. This part has size O(|h|) and can be computed in time O(|A| |h|), so
the exponential preprocessing time is avoid.

Example 6. In order to see how the exponential worst case may happen, we
consider a family of regular languages, for which the minimal left-to-right Dfa
is exponentially bigger than the minimal right-to-left Dfa. The classical example
languages with this property are Ln = Σ∗.a.Σn where n ∈ N and Σ = {a, b}.
Intuitively, a word in Σ∗ belongs to Ln if and only its n + 1-th letter from the
end is equal to ”a”. The minimal left-to-right Dfa for Ln has 2n+1 many states,
since needs to memoize a window of n + 1-letters. In contrast, its minimal right-
to-left Dfa has only n + 1 states; in this direction, it is sufficient to memoize
the distance from the end modulo n + 1.

We next consider the family of hedge languages Hn ∈ HΣ such that each
node of h ∈ Hn is labeled by one symbol in Σ and so that the sequence of labels
of some root-to-leave path of hn belongs to Ln. Note that Hn can be recognized
in a bottom-up manner by the dSha An with O(n + 1) states, which simulates
the minimal deterministic Dfa of Ln on all paths of the input hedge. For an
evaluator with subhedge projection the situation is different. When moving top-
down, it needs to memoize the sequence of labels of the n + 1-last ancestors,
possibly filled with b′s, and there a 2n+1 such sequences. If for some leaf, its
sequence starts with an “a” then the following subhedges with the following leaves
can be projected away. As a consequence, there cannot be any Sha↓ recognizing
Hn that projects away all irrelevant subhedges with less than 2n+1 states. In
particular, the size of Aπ

n must be exponential in the size of An.

Subhedge Projection for SHAs

11

Fig. 7: The dSha↓ Aπ constructed from the dSha A in Fig. 1 except for use-
less state transitions leading out of the schema of our application. Note that
no-change ∆ = {2, 3, 4}. It is equal to the Sha↓ in Fig. 2 up to the state renaming
0 = (0, {}), 0′ = (0, {2, 4}), 0′′ = (0, {1, 3, 4}), 1′ = (1, {2, 4}), 1′′ = (1, {1, 3, 4}),
2′ = (2, {2, 4}), 2′′ = (2, {1, 3, 4}), 3′ = (3, {2, 4}), 4 = (4, {}).

6 Streaming Evaluators for SHA↓s

Any Sha↓ yields a visibly pushdown machine [12] that evaluates nested words
in a streaming manner. The same property was already noticed for Neumann
and Seidl’s pushdown forest automata [9].

Let A = (Σ, Q, ∆, qinit , F ) be a Sha↓. A configuration of the corresponding
visibly pushdown machine is a pair in K = Q×Q∗ containing a state and a stack
of states. For any word v ∈ ˆΣ∗ we define the transition relation of the visibly
pushdown machine v−→

⊆ K × K such that for all q, q′ ∈ Q and σ ∈ Q∗:

str

true

(q, σ) ε−→

str

(q, σ) wrt ∆

(q, σ) v−→

str

(q′, σ)

(q′, σ) v′
−→

str

(q′′, σ) wrt ∆

(q, σ) v·v′
−−→

str

(q′′, σ) wrt ∆

q a−→ q′ in ∆

str

q a−→

q′ wrt ∆

q

(q, σ)

⟨
−→

⟨⟩
−→ q′ in ∆
str

(q′, σ · q) wrt ∆

q@p → q′ in ∆
str

(p, σ · q)

⟩
−→

(q′, σ) wrt ∆

The same visibly pushdown machine can be obtained by compiling the Sha to
an Nwa. In analogy to Theorem 4 of [9], we can show for any hedge h that

the streaming transition relation
transition relation h−→ wrt ∆:

str

nw (h)
−−−−→

wrt ∆ is correct for its in-memory

Proposition 7. L(A) = {h ∈ HΣ | (q, ε)

str

nw (h)
−−−−→

(q′, ε) wrt ∆, q ∈ I, q′ ∈ F }.

12

A. Al Serhali and J. Niehren

(cid:75)

(cid:74)

v

str

Any nested word v ∈ ˆΣ∗ can be evaluated in streaming mode on any subset of
str(K) = {(q′, σ′) | (q, σ) v−→
(q′, σ′) wrt ∆, (q, σ) ∈

configurations K ⊆ K:
K}. So any hedge can be evaluated in streaming mode by computing
{ε}). The hedge is accepted if it can reach some final configuration in F × {ε}.
Going one step further, we show how to enhance the streaming evaluator of
an Sha↓ with subhedge projection, in analogy to the in-memory evaluator. This
approach yields a similar result in a more direct manner, as obtained by mapping
Sha↓s to Nwas, identifying subtree projection states there, and mapping Nwas
with subtree projection states to projecting Nwas [20].

nw (h)
(cid:74)

str(I×
(cid:75)

Let P ⊆ Q be the subset of subhedge projection states of ∆. We define a

str
transition relation with subhedge projection h−→
P ⊆ K × K with respect to ∆
such that for all nested words v, v′ ∈ NΣ, letters a ∈ Σ, states p, q, q′, q′′ ∈ Q
and stacks σ, σ′, σ′′ ∈ Q∗:

q ∈ P
str
P (q, σ) wrt ∆

(q, σ) v−→

q ̸∈ P
(q, σ) a−→

q a−→ q′ in ∆

str
P (q′, σ) wrt ∆

q ̸∈ P
str
P q wrt ∆

q ε−→

q ̸∈ P

(q, σ) v−→

str
P (q′, σ′) wrt ∆
(q, σ) v·v′
−−→

str
P (q′′, σ′′) wrt ∆

(q′, σ′) v′
−→

str
P (q′′, σ′′) wrt ∆

q ̸∈ P

⟨⟩
−→ q′ in ∆

q

p ̸∈ P

(q, σ)

⟨
−→

str
P (q′, σ · q) wrt ∆

(p, σ · q)

⟩
−→

q@p → q′ in ∆
str
P (q′, σ) wrt ∆

The projecting transition relation stays in a configuration with a projection state
until the end of the current subhedge is reached. This is correct since the state
of the non-projecting transition relation would not change the state either, while
the visible stack comes back to its original value after the evaluation of a nested
word (that by definition is well-nested).

Proposition 8. Let v be a word in ˆΣ∗, ∆ a set of transition rules of a complete
Sha↓ with state set Q, q ∈ Q a state and σ ∈ Q∗ a stack. For any subset P ⊆
str
Q of subhedge projection states of ∆: (q, σ) v−→
(q′, σ′) wrt ∆ iff (q, σ) v−→
P
(q′, σ′) wrt ∆.

str

For any subset K ⊆ K and nested word v ∈ NΣ we define the streaming

evaluation with subhedge projection:

str

P (K) = {(q′, σ′) | (q, σ) v−→

str
P (q′, σ′) wrt ∆, (q, σ) ∈ K}

v
(cid:74)

(cid:75)

A streaming membership tester for h ∈ L(A) with subtree projection can be
str
obtained by computing
P (I ×{ε}) and testing whether it contains some
(cid:75)
state in F × {ε}.

nw (h)

(cid:74)

Subhedge Projection for SHAs

13

7 Earliest Membership with Subhedge Projection

We next enhance our compiler from Shas to Sha↓s for introducing subtree pro-
jection such that it can take safe rejection and safe selection into account. The
streaming version for deterministic Shas leads us to an earliest membership
tester, which enhances the previous earliest membership tester for dShas from
[3] with subtree projection.

The idea is as follows: A state is called safe for rejection if whenever the
evaluator reaches this state on some subhedge then it can safely reject the hedge
independently of the parts that were not yet evaluated. In analogy, a state is
safe for selection if whenever the evaluator reaches this state for some subhedge,
the full hedge will be accepted.

Consider a dSha A = (Σ, Q, ∆, I, F ). The states of our dSha↓ will contain
tuples (q, Q, R, S) stating that the evaluator is in state q, that the states in Q
are safe no-changes, the states in R are safe for rejection, and the states in S safe
for selection. State changes are relevant only if they are not safe for no-change,
rejection or selection. Let sel be a fresh symbols beside of Π.

We next compile the given Sha A to a Sha↓ Aπ

e ).
We start with set set of states that are safe for selection S0 = safe ∆(F ) and
respectively safe for rejection R0 = safe ∆(Q \ F ). The state sets of Aπ
e are then:

e = (Σ, Qπ

e , ∆π

e , F π

e , I π

e = (Q × 2Q × 2Q × 2Q) ∪ {Π, sel }
Qπ
I π
e = {(q, ∅, R0, S0) | q ∈ I, q ̸∈ R0 ∪ S0} ∪ {sel | I ∩ S0 ̸= ∅}
F π
e = {(q, ∅, R0, S0) | q ∈ F } ∪ {sel }

The transition rules in ∆π

e are given by the in Fig. 8. For illustration, recon-
sider the dSha from Fig. 1. However, it is not sufficiently complete to obtain the
expected results. The problem is that s-down ∆(0, {4}) = {0, 1, 2, 3, 4} there, but
only the states 3 is really safe for selection one level down. We therefore add a sink
state to it – that we call 5 – yielding the dSha↓ in Fig. ??. For this dSha, which is
still not complete but complete for the intended schema µX.⟨(item+list)·X ∗⟩∗.
We then get s-down ∆(0, {4}) = {3, 4}. I may seem counter intuitive that note
only state 3 but also state 4 down remains safe for selection. This reflects the
fact that no proper subhedge of any hedge satisfying the intended schema may
ever get into state 4. Applying the earliest construction with safe-no-change pro-
jection to dSha in Fig. ?? yields the dSha↓ in Fig. 9. This automaton is the best
dSha↓ that we could hope for the XPath filter [self::list][child::item],
enabling earliest query answering with earliest rejection and perfect subhedge
projection.

Running the Sha↓s Aπ

e in streaming mode with subtree projection yields an
earliest membership tester for dShas with subtree projection. A single adapta-
tions are in order. Whenever the safe selection state sel is reached, the evaluation
can be stopped and the input hedge on the stream is accepted.

Theorem 1. Let A = (Σ, Q, ∆, I, F ) and P the set of its projection states of
∆π
(I) ̸= ∅ wrt ∆

e with witness either sel or Π. For any hedge h ∈ HΣ with

h
(cid:75)

(cid:74)

14

A. Al Serhali and J. Niehren

(q, P ) a−→ (q′, P ) in ∆π
(q, P, S, R) a−→ (q′, P, S, R) in ∆π
e

q′ ̸∈ S ∪ R

(q, P )

⟨⟩
−→ (q′, P ′) in ∆π

q′ ̸∈ S ∪ R

(q, P, S, R)

⟨⟩
−→ (q′, P ′, s-down ∆(q, S), s-down ∆(q, R)) in ∆π
e

(q, P )@(p, P ′) → (q′, P ) in ∆π

q′ ̸∈ S ∪ R

(q, P, S, R)@(p, P ′, s-down ∆(q, S), s-down ∆(q, R)) → (q′, P, S, R) in ∆π
e

(q, P )@Π → (q, P ) in ∆π

q′ ̸∈ S ∪ R

(q, P, S, R)@Π → (q, P, S, R) in ∆π
e

(q, P ) a−→ (q′, P ) in ∆π

q′ ∈ S

(q, P )

⟨⟩
−→ (q′, P ) in ∆π

q′ ∈ S

(q, P, S, R) a−→ sel in ∆π
e

(q, P, S, R)

⟨⟩
−→ sel in ∆π
e

(q, P )@(p, P ′) → (q′, P ) in ∆π

q′ ∈ S

(q, P, S, R)@(p, P ′, s-down ∆(q, S), s-down ∆(q, R)) → sel in ∆π
e

(q, P )@Π → (q, P ) in ∆π

q′ ∈ S

(q, P, S, R)@Π → sel in ∆π
e

a ∈ Σ
Π a−→ Π in ∆π
e

true
Π@Π → Π in ∆π
e

true

Π

⟨⟩
−→ Π in ∆π
e

a ∈ Σ
sel a−→ sel in ∆π
e

µ ∈ Qπ
e
sel @µ → sel in ∆π
e

µ ∈ Qπ
e
µ@sel → sel in ∆π
e

true

sel

⟨⟩
−→ sel in ∆π
e

Fig. 8: The transition rules of the Sha↓ Aπ

e inferred from those of the Sha A.

the streaming evaluation
(cid:74)
h ∈ L(A) at the earliest event when streaming nw (h).

nw (h)
(cid:75)

e ) with respect to ∆π

P (I π
str

e checks membership

The hedge h is accepted once the evaluator reaches state sel . It this doesn’t
happend online, the truth value of q ∈ F is returned where q is the state in the
final tuple.

Proof (sketch). Let P ′ be the set of projection states of A that use state sel as
witness (but not state Π). We obtain an streaming membership tester with ear-
liest selection and earliest rejection (but no safe-no-change subhedge projection)
by computing:
e Earliest selection is detected by reaching the
state sel , while earliest rejection happens when the run fails. We notice that this
algorithm is basically the same as the earliest membership tester from Propo-
sition 6 of [3], except that it also check for safe rejection. The fact that nested
word automata are used there instead of Sha↓s here is not essential. So we can
rely on the definitions of earliest membership testing and the result given there.

e ) wrt. ∆π

P ′ (I π
str

h
(cid:75)

(cid:74)

Subhedge Projection for SHAs

15

Fig. 9: The earliest dSha↓ Aπ
e with safe-no-change subhedge projection for
the the Sha A in Fig. 10 adding sink 5 to the dSha in Fig. 1. The states
e correspond to the following tuples: 0 = (0, ∅, {1, 2, 3, 5}, {4}), 0′ =
of Aπ
(0, ∅, {2, 4, 5}, {3, 4}), 1′ = (1, ∅, {2, 4, 5}, {3, 4}), 0′′ = (0, {1, 3, 4, 5}, ∅, {2, 4, 5}),
and 1′′ = (1, {1, 3, 4, 5}, ∅, {2, 4, 5}).

P (I π
str

In order to add safe-no-change subtree projection, we consider the set of all
projection state P of ∆π
e whose witnesses are either Π or sel . We then compute:
e ) wrt. ∆π
e . The difference is that the evaluator based on P does also
h
(cid:74)
(cid:75)
ignore subtrees that go to safe-no-change projection states. Clearly, this does
not affect earliest selection nor earliest rejection, so we still have an earliest
membership tester, but now safe-no-change subtree projection is added.

8 Experimental Evaluation

We integrated subhedge projection into the earliest query answering tool AS-
tream [3]. It is implemented in Scala while computing safety with ABC Datalog.
In order to benchmark AStream 2.01 with subhedge projection for efficiency,
and to compare it to AStream 1.01 without projection, we considered the regular
XPath queries from the XPathMark [7] A1−A8. We used the deterministic Shas
for all these XPath queries constructed by the compiler from [19]. These were
evaluated on Xml documents of variable size created by the XPathMark gener-
ator. We did further experiments on a sub-corpus of 79 regular XPath queries
extracted by Lick and Schmitz from real-world Xslt and XQuery programs, for
which dShas are available [2]. These experiments confirm the results presented
here, so we don’t describe them in detail.

The XPath queries of the XPathMark without descendant axis are A1,A4 and
A6-A8. The evaluation time on these queries a 1.2 GB document are reduced

16

A. Al Serhali and J. Niehren

between 88 − 97%. In average, it is 92.5%, so the overall time is divided by 12.
While the parsing time remains unchanged the gain on the automaton evaluation
time is proportional to the percentage of subhedge projection for the respective
query. This remains true for the other queries with the descendant axis, just that
the projection percentage is much lower.

Finally, we compared AStream with for QuiXPath [6], the best previous
streaming tool that can answer A1-A8 in an earliest manner. QuiXPath compiles
regular XPath queries to possibly nondeterministic early Nwas, and evaluates
them with subtree and descendant projection [20]. QuiXPath is not generally
earliest though. On the queries without descendant axis, AStream 1.01 without
projection is by a factor of 60 slower than QuiXPath [3]. With subhedge projec-
tion in version 2.01, the overhead goes down to a factor of 5 = 60/12. So our
current implementation is close to becoming competitive with the best existing
streaming tool while guaranteeing earliest query answering in addition.

9 Conclusion and Future Work

We developed evaluators with subhedge projection for Shas in in-memory mode
and in streaming mode. One difficulty was how to push the needed finite state
information for subtree projection top-down given that Shas operate bottom-up.
We solved it based on a compiler from Shas to downward Shas. This compiler
propagates safety information about non-changing states, similar to the propaga-
tion of safety information proposed for earliest query answering for dSha queries
on nested word streams. We confirmed the usefulness of our novel subhedge pro-
jection algorithm for Shas experimentally. We showed that it can indeed speed
up the best previously existing earliest query answering algorithm for dSha
queries on nested word streams, as needed for answering regular XPath queries
on Xml streams. In future work, we plan to improve on subhedge projection
for Shas with descendant projection for Shas and to use it for efficient stream
processing. Another question is whether and how to obtain completeness results
for subhedge projection.

References

1. A. Al Serhali and J. Niehren. Subhedge projection for stepwise hedge automata.

Longer version with appendix of the present paper published at FCT [4].

2. A. Al Serhali and J. Niehren. A Benchmark Collection of Deterministic Automata
for XPath Queries. In XML Prague 2022, Prague, Czech Republic, June 2022.
3. A. Al Serhali and J. Niehren. Earliest query answering for deterministic stepwise
hedge automata. In B. Nagy, editor, Implementation and Application of Automata -
27th International Conference, CIAA 2023, Famagusta, North Cyprus, September
19-22, 2023, Proceedings, volume 14151 of Lecture Notes in Computer Science,
pages 53–65. Springer, 2023.

4. A. Al Serhali and J. Niehren. Subhedge projection for stepwise hedge automata.
In H. Fernau and K. Jansen, editors, Fundamentals of Computation Theory - 24th
International Symposium, FCT 2023, Trier, Germany, September 18-21, 2023,

Subhedge Projection for SHAs

17

Proceedings, volume 14292 of Lecture Notes in Computer Science, pages 16–31.
Springer, 2023.

5. H. Comon, M. Dauchet, R. Gilleron, C. L¨oding, F. Jacquemard, D. Lugiez, S. Tison,
and M. Tommasi. Tree automata techniques and applications. Available online
since 1997: http://tata.gforge.inria.fr, 2007.

6. D. Debarbieux, O. Gauwin, J. Niehren, T. Sebastian, and M. Zergaoui. Early nested
word automata for XPath query answering on XML streams. Theor. Comput. Sci.,
578:100–125, 2015.

7. M. Franceschet. Xpathmark performance test. https://users.dimi.uniud.it/

~massimo.franceschet/xpathmark/PTbench.html. Accessed: 2020-10-25.

8. A. Frisch. Regular tree language recognition with static information. In Exploring
New Frontiers of Theoretical Informatics, IFIP 18th World Computer Congress,
TCS 3rd International Conference on Theoretical Computer Science, pages 661–
674, 2004.

9. O. Gauwin, J. Niehren, and Y. Roos. Streaming tree automata.

Information

Processing Letters, 109(1):13–17, 2008.

10. O. Gauwin, J. Niehren, and S. Tison. Earliest query answering for deterministic
nested word automata. In 17th International Symposium on Fundamentals of Com-
puter Theory, volume 5699 of Lecture Notes in Computer Science, pages 121–132.
Springer Verlag, 2009.

11. M. Kay. The saxon xslt and xquery processor, 2004. https://www.saxonica.com.
12. V. Kumar, P. Madhusudan, and M. Viswanathan. Visibly pushdown automata
for streaming XML. In 16th international conference on World Wide Web, pages
1053–1062. ACM-Press, 2007.

13. P. Madhusudan and M. Viswanathan. Query automata for nested words.

In
34th International Symposium on Mathematical Foundations of Computer Science,
volume 5734 of Lecture Notes in Computer Science, pages 561–573. Springer Verlag,
2009.

14. S. Maneth and K. Nguyen. XPath whole query optimization. VLPB Journal,

3(1):882–893, 2010.

15. A. Marian and J. Sim´eon. Projecting XML documents. In VLDB, pages 213–224,

2003.

16. B. Mozafari, K. Zeng, and C. Zaniolo. High-performance complex event processing
over XML streams.
In K. S. Candan, Y. Chen, R. T. Snodgrass, L. Gravano,
A. Fuxman, K. S. Candan, Y. Chen, R. T. Snodgrass, L. Gravano, and A. Fuxman,
editors, SIGMOD Conference, pages 253–264. ACM, 2012.

17. A. Neumann and H. Seidl. Locating matches of tree patterns in forests. In Foun-
dations of Software Technology and Theoretical Computer Science, volume 1530 of
Lecture Notes in Computer Science, pages 134–145. Springer Verlag, 1998.

18. A. Neumann and H. Seidl. Locating matches of tree patterns in forests. In 18-
th Conference on Foundations of Software Technology and Theoretical Computer
Science, 1998.

19. J. Niehren and M. Sakho. Determinization and minimization of automata for

nested words revisited. Algorithms, 14(3):68, 2021.

20. T. Sebastian and J. Niehren. Projection for Nested Word Automata Speeds up
XPath Evaluation on XML Streams.
In International Conference on Current
Trends in Theory and Practice of Computer Science (SOFSEM), Harrachov, Czech
Republic, 2016.

21. J. W. Thatcher. Characterizing derivation trees of context-free grammars through
a generalization of automata theory. Journal of Computer and System Science,
1:317–322, 1967.

18

A. Al Serhali and J. Niehren

A Proofs for Section 4 (Downward Stepwise Hedge

Automata (SHA↓s))

Proposition 4. Let A = (Σ, Q, ∆, I, F ) be a complete Sha↓ and P a subset
of subhedge projection states for ∆. Then for all hedges h ∈ HΣ and states
q, q′ ∈ Q: q h−→ q′ wrt ∆ iff q h−→P q′ wrt ∆.

Proof. If q ̸∈ P, then for any p ∈ Q, q h−→ p wrt ∆ iff q h−→P p wrt ∆ by definition
of the projecting transition relation. If q ∈ P then p is a subhedge projection
state of ∆, so the set of transition rules of ∆ containing q′ or with q on the
leftmost position are included in the following:

q′

q

⟨⟩

⟨⟩

q′

q′

a ∈ Σ

a ∈ Σ

Since ∆ is complete, equality holds. Hence for any hedge h ∈ HΣ it holds
that q h−→ q wrt ∆ while q ̸ h−→ p wrt ∆ for all p ̸= q. The projecting transition
relation does the same: q h−→P q wrt ∆ while q ̸ h−→P p wrt ∆ for all p ̸= q.

Related Work. We can convert any dSha↓ A into an equivalent Sha elim ↓(A)
as follows.

I elim ↓
F elim ↓

= Q × I
= Q × F

⟨⟩
−→ q′ in ∆

q

⟨⟩
−→ (q, q′) in ∆elim ↓

q a−→ q′ in ∆
r ∈ Q
(q, r) a−→ (q′, r) in ∆elim ↓

q@p → q′ in ∆

r ∈ Q

(q, r)@(p, q) → (q′, r) in ∆elim ↓

Proposition 9. L(A) = L(elim ↓(A)).

Proof. The construction is analogous to the conversion of Nwas to Shas [19] or
to hedge automata [9]. The correctness proofs for these compilers are standard.

It should be noticed that unique minimization fails for Sha↓, as usual for
deterministic multiway automata. This even happens for deterministic two-way
finite state automata on words. In contrast, the class of dShas with the same
initial and tree initial state enjoys unique minimization.

Standard hedge automata [21,5,?,?] have the same expressiveness as Neu-
mann and Seidl’s pushdown forest automata [17] and also as Bojanczyk’s forest
automata (see Section 3.3 of [?]). Note, however, that there is an exponential
difference in succinctness between Shas and Bojanczyk’s forest automata. There-
fore, these forest automata are of quite different nature from those of Neumann
and Seidl.

Subhedge Projection for SHAs

19

B Proofs for Section 5 (Compiling SHAs to SHA↓s with

Projection States)

Proposition 5 (Soundness). L(Aπ) = L(A) for any complete Sha A.

Proof. We have to prove that no more changing states q ∈ P ∪ no-change ∆
is sound. If q ∈ no-change ∆ this follows from the completeness of ∆, so that
one can neither block nor change the state. In the case q ∈ P , the intuition is
that the state on level above – say r – can no more change, since then P =
s-no-change ∆(r). Neither can the automaton block by completeness.

We prove the first inclusion L(A) ⊆ L(Aπ) based on the following three

Claims 5.1a, 5.2a, and 5.3a:
Claim 5.1a. Π h−→ Π wrt ∆π for all hedges h ∈ HΣ.
The proof is straightforward by induction on the structure of h. It uses the last
three transition rules of ∆π in Fig. 6 permitting to always stay in Π for whatever
hedge follows.
Claim 5.2a. For all h ∈ HΣ, q ∈ Q, and P ⊆ Q such that q ∈ P ∪ no-change ∆:

(q, P ) h−→ (q, P ) wrt ∆π

We prove Claim 5.2a by induction on the structure of h. Note that the complete-
ness of ∆ will be needed.

Case h = ⟨h′⟩. In this case, we can use Claim 5.1a to show Π h′

−→ Π wrt ∆π

and the inference rules

q ∈ P ∪ no-change ∆

(q, P )

⟨⟩
−→ Π in ∆π

q ∈ P ∪ no-change ∆
(q, P )@Π → (q, P ) in ∆π

in order to close the following diagram with respect to ∆π:

(q, P )

⟨⟩

(q, P )

Π

h′

Π

This proves (q, P ) h−→ (q, P ) wrt ∆π as required by the claim.

Case h = a. By completeness of ∆ there exists some state q′ such that q a−→

q′ in ∆. Since q ∈ P ∪ no-change ∆ we can apply the inference rule:

q ∈ P ∪ no-change ∆
(q, P ) a−→ (q, P ) in ∆π

This proves this case of the claim.

20

A. Al Serhali and J. Niehren

Case h = ε. We trivially have (q, P ) ε−→ (q, P ) wrt ∆π.
Case h = h′ · h′′. By induction hypothesis applied to h′ and h′′ we have: (q, P ) h′
−→

(q, P ) and (q, P ) h′′

−−→ (q, P ). Hence (q, P ) h′·h′′

−−−→ (q, P ).

This ends the proof of Claim 5.2. The next claim, in which the induction step is
a little more tedious to prove, is the key of the soundness proof.

Claim 5.3a. Let h ∈ HΣ a hedge, q, q′ ∈ Q states and P ⊆ Q a subset of states
such that acc∆(P ) ⊆ P and q ̸∈ P ∪ no-change ∆. If q h−→ q′ wrt ∆ then there
exists q′′ such that (q, P ) h−→ (q′′, P ) wrt ∆π and (q′ = q′′ or q′, q′′ ∈ P ).

Proof. By induction on the structure of h.

Case h = ⟨h′⟩. The assumption q h−→ q′ wrt ∆ shows that there exists some

state p ∈ Q closing the following diagram:

q

⟨⟩

q′

⟨⟩∆

h′

p

Let P ′ = s-no-change ∆(q) and note that acc∆(P ′) ⊆ P ′. Since q ̸∈ P ∪
no-change ∆ we can infer:

⟨⟩
−→ ⟨⟩∆ in ∆ q ̸∈ P ∪ no-change ∆

(q, P )

⟨⟩
−→ (⟨⟩∆, P ′) in ∆π

q@p → q′ in ∆ q ̸∈ P ∪ no-change ∆
(q, P )@(p, P ′) → (q′, P ) in ∆π

Subcase ⟨⟩∆ ̸∈ P ′ ∪ no-change ∆. The induction hypothesis applies to h′

yielding that shows that there exists p′ such that (⟨⟩∆, P ′) h′
and p = p′ ∨ p, p′ ∈ P . We distinguish the latter two cases:
Subsubcase (⟨⟩∆, P ′) h′

−→ (p, P ′) wrt ∆π. We can close the diagram as

−→ (p, P ′) wrt ∆π

follows:

(q, P )

⟨⟩

(q′, P )

(⟨⟩∆, P ′)

h′

(p, P ′)

This shows that (q, P ) h−→ (q′, P ) wrt ∆π, so the first disjunct of the
claim holds for h.

Subsubcase p ∈ P ′ ∧ ∃p′ ∈ P ′. (⟨⟩∆, P ′) h′

−→ (p′, P ′) wrt ∆π. Since ∆
is complete, there exists a state q′′ such that q′′ ∈ q@∆p′. Since both
p, p′ ∈ P ′ we have q′ = q = q′′ by definition of P ′ = s-no-change ∆(q).
Hence we can close the diagram as follows:

Subhedge Projection for SHAs

21

(q, P )

⟨⟩

(q′′, P )

(⟨⟩∆, P ′)

h′

(p′, P ′)

Since q′′ = q′ this shows that (q, P ) h−→ (q′, P ) wrt ∆π, so the first
disjunct of the claim holds again.

Subcase ⟨⟩∆ ∈ P ′ ∪ no-change ∆. Claim 5.2a then shows that (⟨⟩∆, P ′) h′
−→

(⟨⟩∆, P ′) wrt ∆π.
Subsubcase ⟨⟩∆ ∈ P ′. Since p ∈ acc∆(⟨⟩∆) and acc∆(P ′) ⊆ P ′ it fol-
lows that p ∈ P ′ too. By definition P ′ = s-no-change ∆(q) and the
completeness of ∆, the memberships ⟨⟩∆ ∈ P ′ and p ∈ P ′ imply
that q@∆⟨⟩∆ = {q} = q@∆p. We can now close the diagram below
as follows:

(q, P )

⟨⟩

(q, P )

(⟨⟩∆, P ′)

h′

(⟨⟩∆, P ′)

Subsubcase ⟨⟩∆ ∈ no-change ∆. In this case ⟨⟩∆ = p so that q′ ∈

q@∆⟨⟩∆. Hence:

(q, P )

⟨⟩

(q′, P )

(⟨⟩∆, P ′)

h′

(p, P ′)

Case h = a. Since q ̸∈ P ∪ no-change ∆ we can apply the inference rule:

q a−→ q′ in ∆ q ̸∈ P ∪ no-change ∆
(q, P ) a−→ (q′, P ) in ∆π

This shows that (q, P ) h−→ (q′, P ), so claim is valid with the first disjunct.
Case h = ε. In this case we have q = q′ and (q, P ) ε−→ (q, P ) so the first property

required by the claim holds.

Case h = h1 · h2. Since q h−→ q′ wrt ∆, there exists q1 ∈ Q such that q h1−→ q1
h2−→ q′ wrt ∆. Since q ̸∈ P ∪no-change ∆, we apply the induction

wrt ∆ and q1
hypothesis on h1. This implies that there exists q′

1 such that:

(q, P ) h1−→ (q′

1, P ) wrt ∆π ∧ (q1 = q′

1 ∨ q1, q′

1 ∈ P )

We distinguish the two cases of the disjunction:
Subcase q1 = q′

1. We also distinguish two subcases here:

22

A. Al Serhali and J. Niehren

Subsubcase q1 ̸∈ P . The induction hypothesis applied to h2 yields:

∃q′′.(q1, P ) h2−→ (q′′, P ) wrt ∆π ∧ (q′ = q′′ ∨ q′, q′′ ∈ P )

Hence

∃q′′. (q, P ) h−→ (q′′, P ) wrt ∆π ∧ (q′ = q′′ ∨ q′, q′′ ∈ P )

Subsubcase q1 ∈ P . By Claim 5.2a, we have (q1, P ) h2−→ (q1, P ). We
also have q′ ∈ acc({q1}) and since we assume acc(P ) ⊆ P , this
implies q′ ∈ P . Hence (q, P ) h−→ (q1, P ) and q′, q1 ∈ P implying the
claim with the second disjunct valid.

Subcase q1, q′

1 ∈ P . Since q′

1 ∈ P , Claim 5.2a, implies (q′

1, P )
wrt ∆π. Thus (q, P ) h−→ (q′
1, P ) wrt ∆π. Since q′ ∈ acc∆({q1}) and
q1 ∈ P it follows that q′ ∈ acc∆(P ) ⊆ P . Here we used as in the previous
subsubcase that acc(P ) ⊆ P is assumed by the claim. Let q′′ = q′
1. Then
we have (q, P ) h−→ (q′′, P ) wrt ∆π and q′, q′′ ∈ P showing the claim.

1, P ) h2−→ (q′

This ends the proof of Claim 5.3a.

Proof of inclusion L(A) ⊆ L(Aπ). Let h ∈ L(A). Then there exists q0 ∈ I and
q ∈ F such that q0

h−→ q. We distinguish two cases:

Case q0 ∈ no-change ∆. By definition of no-change ∆ and since q ∈ acc∆(q0)
we have q0 = q. Claim 5.2a shows that (q0, ∅) h−→ (q0, ∅) wrt ∆π and thus
(q0, ∅) h−→ (q, ∅) so that h ∈ L(Aπ).

Case q0 ̸∈ no-change ∆. Claim 5.3a with P = ∅ shows that (q0, ∅) h−→ (q, ∅) wrt

∆π and hence h ∈ L(Aπ).

This ends the proof of the first inclusion. We next want to show the inverse
inclusion L(Aπ) ⊆ L(A). It will eventually follow from the following three Claims
5.1b., 5.2b, and 5.3b.

Claim 5.1b. For any hedge h and state µ ∈ Qπ, if Π h−→ µ wrt ∆π then µ = Π.

The proof is straightforward by induction on the structure of h: the only
transitions rules of ∆π with Π on the left hand side are inferred by the last
three rules in Fig. 6. These require to stay in Π whatever hedge follows.

Claim 5.2b. For any hedge h, set P ⊆ Q, state q ∈ P ∪ no-change ∆, and state
µ ∈ Qπ: if (q, P ) h−→ µ wrt ∆π then µ = (q, P ).

Proof. By induction on the structure of h. Suppose that (q, P ) h−→ µ wrt ∆π.

Case h = ⟨h′⟩. There must exist states µ1, µ′

1 ∈ Qπ closing the following dia-

gram:

Subhedge Projection for SHAs

23

(q, P )

⟨⟩

µ

µ1

h′

µ′
1

Since q ∈ P ∪ no-change ∆, the following rule must have been applied to infer

(q, P )

⟨⟩
−→ µ1 wrt ∆π:

q ∈ P ∪ no-change ∆

(q, P )

⟨⟩
−→ Π in ∆π

Therefore µ1 = Π. Claim 5.1b shows that µ′
infered by applying the rule:

1 = Π too. So µ must have been

q ∈ P ∪ no-change ∆
(q, P )@Π → (q, P ) in ∆π

So µ = (q, P ) as required.

Case h = a. The following rule must have been applied:

q ∈ P ∪ no-change ∆
(q, P ) a−→ (q, P ) in ∆π

Hence, µ = (q, P ).
Case h = ε. Obvious.
Case h = h1 · h2. There must exist µ1 such that (q, P ) h1−→ µ1

h2−→ µ wrt ∆π.
By induction hypothesis applied to h1, we have µ1 = (q, P ). We can thus
apply the induction hypothesis to h2 to obtain µ2 = (q, P ).

This ends the proof of Claim 5.2b. We next need an inverse of Claim 5.3a.

Claim 5.3b. Let h ∈ HΣ a hedge, q ∈ Q states and P ⊆ Q a subset of
states such that acc∆(P ) ⊆ P and q ̸∈ P ∪ no-change ∆. If (q, P ) h−→ µ wrt ∆π
then there exists q′, q′′ such that µ = (q′, P ), q h−→ q′′ wrt ∆ and (q′ = q′′ or
q′, q′′ ∈ P ).
Proof. Let P ⊆ Q and q ∈ Q such that acc∆(P ) ⊆ P and q ̸∈ P ∪ no-change ∆.
Assume that (q, P ) h−→ µ wrt ∆π. We prove by induction on h that there exists
q′ such that µ = (q′, P ) and ∃q′′. (q′ = q′′ ∨ q′, q′′ ∈ P ) ∧ q h−→ q′′ wrt ∆.

Case h = ⟨h′⟩. By definition of (q, P ) h−→ µ wrt ∆π there must exist µ1, µ′

1 ∈

Qπ such that the following diagram can be closed:

(q, P )

⟨⟩

µ

µ1

h′

µ′
1

24

A. Al Serhali and J. Niehren

Since q ̸∈ P ∪ no-change ∆, the following inference rule got applied:

⟨⟩
−→ p in ∆ q ̸∈ P ∪ no-change ∆

(q, P )

⟨⟩
−→ (p, s-no-change ∆(q)) in ∆π

Let P ′ = s-no-change ∆(q). Hence there exists p ∈ ⟨⟩∆ such that µ1 = (p, P ′).
Subcase p ∈ P ′ ∪ no-change ∆.

Subsubcase p ∈ P ′. Since p ∈ acc∆({p}) and P ′ = s-no-change ∆(q)
we have q@p = {q}. So q = q′. Furthermore, by completeness of ∆
there exists p′ such that p h′
−→ p′ wrt ∆. In particular p′ ∈ acc∆({p})
so by definition of P ′, it follows that q@p′ → q wrt ∆. Hence, we can
close the following diagram:

q

q

p

⟨⟩

Since q = q′ this shows that q

p′

h′
⟨h′⟩
−−→ q′ wrt ∆.

Subsubcase p ∈ no-change ∆. By completeness of ∆ there exists p′ such
−→ p′ wrt ∆. Since p ∈ no-change ∆ it follows that p′ = p.

that p h′
Hence, we can close the following diagram:

q′

q

p

⟨⟩

h′

p

This shows that q

⟨h′⟩
−−→ q′ wrt ∆.

Subcase p ̸∈ P ′ ∪ no-change ∆. By induction hypothesis, there exists p′, p′′
−→ p′′ wrt ∆, and (p′ = p′′ or p′, p′′ ∈ P ′. By

such that µ′
completeness of ∆ there exist q′′ ∈ q@∆p′′ and q′ ∈ q@∆p′.
Subsubcase p′ = p′′. Hence, we have:

1 = (p′, P ′), p h′

q′

q

p

⟨⟩

h′

p′

This shows q

⟨h′⟩
−−→ q′ wrt ∆.

Subsubcase p′, p′′ ∈ P . By definition of P ′ it follows that q′ = q = q′′.

Hence:

q

q

p

⟨⟩

h′

p′′

Subhedge Projection for SHAs

25

This shows q

⟨h′⟩
−−→ q wrt ∆.

Case h = a. Since q ̸∈ P ∪ no-change ∆, the following inference rule must be

used:

q a−→ q′ in ∆ q ̸∈ P ∪ no-change ∆
(q, P ) a−→ (q′, P ) in ∆π

So µ = (q′, P ) and q a−→ q′ wrt ∆.

Case h = ε. Obvious.
Case h = h1 · h2. The judgement (q, P ) h−→ µ wrt ∆π shows that there exists
h2−→ µ wrt ∆π. Since q ̸∈ P ∪ no-change ∆, we can
1 and q′′
1

µ1 such that (q, P ) h1−→ µ1
apply the induction hypothesis to h1. It shows that there exists q′
such that µ1 = (q′
1 ∈ P ).
1 = q′′
Subcase q′

1, P ) and q h1−→ q′′
1 wrt ∆ ∧ (q′
1 . Hence (q1, P ) h2−→ µ wrt ∆π.

1 = q′′

1 ∨ q′

1, q′′

Subsubcase q′

1 ̸∈ P ∪ no-change ∆. In this case, we can apply the in-
1, P ) h2−→ µ wrt ∆π showing the existence of
duction hypothesis to (q′
h2−→ q′′ ∧ (q′ = q′′ ∨ q′, q′′ ∈ P ).
q′ such that µ = (q′, P ) and ∃q′′. q′
1
Hence ∃q′′. q h−→ q′′ wrt ∆ ∧ (q′ = q′′ ∨ q′, q′′ ∈ P ), so the claim holds.
1, P ) h2−→
1 ∈ P ∪ no-change ∆. Claim 5.2b applied to (q′

Subsubcase q′

1, q′′

µ wrt ∆π shows that µ = (q′
1 ∈ P . Recall that (q′′

1, P ).
1 , P ) h2−→ µ wrt ∆π and q′′
1 , P ) wrt ∆π. We also have q h1−→ q′′

5.2b shows that µ = (q′′
completeness of ∆, there exist a state q′′ such that q′′
1
Since q′
acc(P ) ⊆ P . From q h1−→ q′′
follows since q′′

1 ∈ P . Claim
1 wrt ∆. By
h−→ q′′ wrt ∆.
1 }) ⊆
1 wrt ∆, we get q h−→ q′′ wrt ∆. The claim

1 ∈ P and P is closed by accessibility, we have q′′ ∈ acc({q′′

1 , q′′ ∈ P .

Subcase q′

This ends the proof of Claim 5.3b.

Proof of inclusion L(Aπ) ⊆ L(A). Let h ∈ L(Aπ). Then there exists q0 ∈ I
and q ∈ F such that (q0, ∅) h−→ (q, ∅) wrt ∆π. We distinguish two cases:

Case q0 ∈ no-change ∆. Claim 5.2b shows that q = q0. Claim 5.2a proves that

q0

h−→ q0 wrt ∆. Hence q0

h−→ q wrt ∆ and thus h ∈ L(A).
Case q0 ̸∈ no-change ∆. Claim 5.3b with P = ∅ shows that q0

hence h ∈ L(Aπ).

h−→ q wrt ∆π and

This end the proof of the inverse inclusion, and thus of L(A) = L(Aπ).

C Proofs for Section 6 (Streaming Evaluators for SHA↓s)

Proposition 7. L(A) = {h ∈ HΣ | (q, ε)

Proof. Straightforward.

str

nw (h)
−−−−→

(q′, ε) wrt ∆, q ∈ I, q′ ∈ F }.

26

A. Al Serhali and J. Niehren

Proposition 8. Let v be a word in ˆΣ∗, ∆ a set of transition rules of a complete
Sha↓ with state set Q, q ∈ Q a state and σ ∈ Q∗ a stack. For any subset P ⊆
str
Q of subhedge projection states of ∆: (q, σ) v−→
(q′, σ′) wrt ∆ iff (q, σ) v−→
P
(q′, σ′) wrt ∆.

str

Proof. Analogous to the proof of Proposition 4, i.e., the soundness of the in-
memory evaluator with projection for complete Sha↓s.

Related Work. A streaming evaluator for Sha↓s via a visibly pushdown ma-
chine can also be obtained by compiling a Sha↓ to a nested word automaton
(Nwa) [?], whose streaming evaluator is given by a visibly pushdown machine
[?], previously known as input driven automata [?,?,?].

Definition 10. A nested word automata ( Nwa) is a tuple (Σ, Q, Γ, ∆, I, F ),
where Σ, Γ and Q are sets, I, F ⊆ Q, and ∆ = ((a∆)a∈Σ, ⟨∆, ⟩∆) contains
relations: a∆ ⊆ Q × Q, ⟨∆ ⊆ Q × (Γ × Q) and ⟩∆ : Q × Γ × Q. A Nwa is
deterministic or equivalently a d Nwa if I contains at most one element and all
above relations are partial functions.

The elements of Γ are called stack symbols. The transition rules in ∆ again
⟨↓γ
−−→ q′ if

have three forms: Internal rules q a−→ q′ as for Shas, opening rules q
⟨∆(q) = (q′, γ) and closing rules q

⟩↑γ
−−→ q′ if ⟩∆(q, γ) = q′.

The streaming evaluator for Nwas can be seen as pushdown machines for
evaluating the nested words of hedges in streaming manner. A configuration of
the pushdown machine is a pair in K = Q × Γ ∗ containing a state and a stack.
For any word v ∈ ˆΣ∗ we define a streaming transition relation v−→
⊆ K × K
such that for all q, q′ ∈ Q and S ∈ Γ ∗:

str

true

(q, S) ε−→

str

(q, S) wrt ∆

(q, S) v−→

str

(q′, S)

(q′, S) v′
−→

str

(q′′, S) wrt ∆

(q, S) v·v′
−−→

str

(q′′, S) wrt ∆

q a−→ q′ in ∆

str

q a−→

q′ wrt ∆

⟨↓γ
−−→ q′ in ∆

q

⟩↑γ
−−→ q′ in ∆

q

str

(q, S)

⟨
−→

(q′, S) wrt ∆

(q, S · γ)

str

⟩
−→

(q′, S) wrt ∆

For any dSha↓ A = (Σ, Q, ∆, I, F ) we can define the dNwa Anwa = (Σ, Q,
Γ, ∆nwa , I nwa , F nwa ) such that Γ = Q, while ∆nwa contains for all a ∈ Σ and
q, p ∈ Q the transition rules:

q a−→ q′ in ∆
q a−→ q′ in ∆nwa

⟨⟩
−→ q′ in ∆

q

p@q → q′ in ∆

⟨↓q
−−→ q in ∆nwa

q

⟩↑p
−−→ q′ in ∆nwa

q

Lemma 11. L(Anwa ) = L(A).

Subhedge Projection for SHAs

27

The runs of Sha↓s A and Nwas Anwa can be identified. Projecting evalua-
tors for Nwas were proposed in the context of projecting Nwas [20]. They are
based on the following notion of states of irrelevant subtrees for Nwas.

Definition 12 (Variant of Definition 3 of [20]).
We call a state q of an Nwa a state of irrelevant sub-
trees if there exist two different stack symbols γ, γ′
and a state q′ such that the transitions shown on the
right exist, but no further opening transitions with γ,
no further transitions with γ′, and no further clos-
ing transition in q popping γ. In this case, we write
q ∈ i-treeΣ\∅.

⟨ ↓ γ

q

⟨ ↓ γ′
⟩ ↑ γ′

q′

⟩ ↑ γ

a ∈ Σ

Lemma 13. Any subhedge projection state of a complete Sha↓ A is a state of
irrelevant subtrees of Anwa .

It was then shown in [20] how to map an Nwa with a subset P of states
of irrelevant subtrees to a projecting Nwa, whose streaming semantics yields
a streaming evaluator with subhedge projection. The presentation of subhedge
projection for Sha↓s without passing via Nwas yields the same result in a more
direct manner.

It should also be notice that projecting Nwas support descendant projection

beside of subhedge projection. For Shas this is left to future research.

D Proofs for Section 7 (Earliest Membership with

Subhedge Projection)

Lemma 14. Let P be a subset of projection states of ∆π
prefix v of nw (h), state q ∈ Q, state sets Q, R, S ⊆ Q, and stack σ ∈ Q∗:

e . For any hedge h and

if (I π

e , ε)π
e

v−→

str
P ((q, Q, R, S), σ) wrt. ∆π

e and q ∈ S then h ∈ L(A).

E Proofs for Section 8 (Experimental Evaluation)

Table 1: XPathMark list of queries.

Id
A1:

A2:
A3:
A4:

XPath Query
/site/closed auctions/closed auction/annotation/
description/text/keyword
//closed auction//keyword
/site/closed auctions/closed auction//keyword
/site/closed auctions/closed auction[annotation/description/
text/keyword]/date

28

A5:

A6:
A7:
A8:

A. Al Serhali and J. Niehren

/site/closed auctions/closed auction[descendant::keyword]/
date
/site/people/person[profile/gender and profile/age]/name
/site/people/person[phone or homepage]/name
/site/people/person[address and (phone or homepage) and
(creditcard or profile)]/name

Table 2: Timings in seconds for XPathMark queries that have child axis exclu-
sively with QuiXPath and the two versions of our tool.

Gain:

Factor:

QuiXPath Astream Astream
1.01
nonproj.
644.67
723.03
780.78
601.26
801.96
710.34

11
11.6
10.7
8.6
8.8
10.14

2.01 Astream2.01 vs QuiXPath/
proj.
Astream1.01 Astream2.01
72.83
78.5
65.26
24.64
24.85
53.2

88.7%
89.14%
91.64%
95.9 %
96.9%
92.45%

*6.62
*6.77
*6.1
*2.87
*2.82
*5.036

A1
A4
A6
A7
A8
average

Table 3: Timings in seconds for XPathMark queries that have descendant axis
with QuiXPath and the two versions of our tool.

Gain:

QuiXPath Astream Astream
2.01 Astream2.01 vs QuiXPath/
1.01
proj.
Astream1.01 Astream2.01
nonproj.
569.0112
664.6
673.716 666.124
593.4648 77.785

-16.8%
1.13%
86.89%

*58.3
*57.92
*6.48

11.4
11.5
12

Factor:

A2
A3
A5

Subhedge Projection for SHAs

29

Fig. 10: Adding a sink 5 to the dSha from Fig. 1 for the XPath filter
[self::list][child::item].

