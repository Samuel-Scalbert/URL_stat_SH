Compressing and Querying Skypattern Cubes
Willy Ugarte, Samir Loudni, Patrice Boizumault, Bruno Crémilleux,

Alexandre Termier

To cite this version:

Willy Ugarte, Samir Loudni, Patrice Boizumault, Bruno Crémilleux, Alexandre Termier. Compressing
and Querying Skypattern Cubes. IEA/AIE-2019 - 32nd International Conference on Industrial, En-
gineering & Other Applications of Applied Intelligent Systems, Jul 2019, Graz, Austria. pp.406-421,
￿10.1007/978-3-030-22999-3_36￿. ￿hal-02190788￿

HAL Id: hal-02190788

https://hal.science/hal-02190788

Submitted on 22 Jul 2019

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Compressing and Querying Skypattern Cubes

Willy Ugarte1, Samir Loudni2, Patrice Boizumault2, Bruno Cr´emilleux2, and
Alexandre Termier3

1 Peruvian University of Applied Sciences, Peru
willyugarte@gmail.com
2 Normandie Univ., UNICAEN, ENSICAEN, CNRS – UMR GREYC, France
{name}.{last-name}@unicaen.fr
3 Univ. Rennes, Inria, CNRS, IRISA, France
alexandre.termier@irisa.fr

Abstract. Skypatterns are important since they enable to take into account user
preference through Pareto-dominance. Given a set of measures, a skypattern query
ﬁnds the patterns that are not dominated by others. In practice, different users may
be interested in different measures, and issue queries on any subset of measures
(a.k.a subspace). This issue was recently addressed by introducing the concept of
skypattern cubes. However, such a structure presents high redundancy and is not
well adapted for updating operations like adding or removing measures, due to
the high costs of subspace computations in retrieving skypatterns. In this paper,
we propose a new structure called Compressed Skypattern Cube (abbreviated
CSKYC), which concisely represents a skypattern cube, and gives an efﬁcient
algorithm to compute it. We thoroughly explore its properties and provide an ef-
ﬁcient query processing algorithm. Experimental results show that our proposal
allows to construct and to query a CSKYC very efﬁciently.

Keywords: skypatterns; pareto-dominance relation; skypattern cubes

1

Introduction

The notion of skyline queries [2] has been quite recently integrated into the pattern
discovery paradigm to mine skyline patterns (henceforth called skypatterns) [11, 15].
Given a set of measures, skypatterns are based on a Pareto-dominance relation, which
means that no measure can be improved without degrading the others. As an exam-
ple, a user may prefer patterns with a high frequency, large size and a high conﬁdence.
Then a pattern xi dominates another pattern xj if freq(xj) ≥ freq(xi), size(xj) ≥
size(xi), conf(xj) ≥ conf(xi) where at least one strict inequality holds. The skypat-
tern set contains the patterns that are not dominated by any other pattern. Skypatterns
are highly interesting since they do not require thresholds for the measures and the dom-
inance relation gives them global interestingness with a semantics easily understood by
the user.

In practice, users do not know the exact role of each measure and it is difﬁcult to
select beforehand the most appropriate subset of measures. Users would like to keep all
potentially useful measures, look at what happens on skypattern sets when removing

2

Willy Ugarte et al.

or adding a measure, thus evaluating the impact of measures, and then converge to a
convenient skypattern set.

This issue has been ﬁrst addressed with the notion of a Skypattern Cube [13], which
is the lattice of all possible subsets of measures associated with their skypattern sets.
More formally, given a set M of n measures, the 2n−1 possible non-empty skypattern
subsets should be precomputed to efﬁciently handle various queries of users. By com-
paring two neighboring nodes (differentiated by only one measure), users can observe
new skypatterns and the ones which disappear, greatly helping to better understand the
role of the measures. To sum up, the cube is a structure that enables to discover the most
interesting skypattern sets. The skypattern cube has been exploited in various domains
such as bioinformatics [10] and mutagenicity [13]. However there are 2n−1 possible
non-empty skypattern sets with high redundancy coming from derivations of skypat-
terns among subspaces of the cube [13].

In this paper, we propose a new structure called the Compressed Skypattern Cube
(denoted CSKYC). Each subspace stores skypatterns (called proper skypatterns) that
do not appear in its descendant ones and the compressed skypattern cube contains
only non-empty subspaces. Compared to the original skypattern cube [13], the CSKYC
has fewer duplicates among subspaces, and does not need to store all of them. More-
over the cube includes unbalanced skypatterns. For instance, let M ={freq, size}
and three patterns xi, xj and xk such that freq(xi)=10, size(xi)=1, freq(xj)=2,
size(xj)=8, freq(xk)=4 and size(xk)=5. Clearly, xi (resp. xj) is a skypattern for
{freq} (resp. {size}), thus xi (resp. xj) will be instantly a skypattern for M being
derived from {freq} (resp. {size}). However, xk is also a skypattern for M , being
more balanced over measures than xi (resp. xj) which only has an extreme value for
{freq} (resp. {size}). Proper skypatterns are often well-balanced skypatterns.
Contributions overview. We thoroughly explore interesting properties of the compressed
skypattern cube and provide an efﬁcient query processing algorithm. Our contributions
can be summarized as follows: (i) we provide the summarization structure CSKYC
which concisely represents the whole skypattern cube and preserves its essential infor-
mation. (ii) We propose a bottom-up approach to construct the CSKYC. (iii) We show
how this structure can be used efﬁciently for query processing. Finally, (iv) we present
an extensive set of experiments showing the advantages of our proposals.
Paper organization. The rest of this paper is organized as follows. Section 2 recalls the
deﬁnitions of the notions used in this paper. Section 3 ﬁrst introduces the CSKYC, pro-
vides algorithms to build it, and shows how the CSKYC can handle various skypattern
queries. Section 4 is devoted to related works. Finally, Section 5 shows our experimental
results and Section 6 concludes.

2 Preliminaries

Let I be a set of distinct literals called items. A pattern (or itemset) is a non-empty sub-
set of I. The language of patterns corresponds to LI = 2I\∅. A transactional dataset
T is a multiset of patterns in LI. The traditional example is a supermarket database in
which, for each transaction ti, every item in a transaction is a product bought by the
customer i. Tab. 1 summarizes the different notations used throughout the paper.

Compressing and Querying Skypattern Cubes

3

Trans.

t1 c1
t2 c1
t3 c1
t4
t5
t6
t7

Items

A

E F

B C D E
B C D E F

c2 A B C D E
c2
c2
E F
c2 A B C D E F

B C D
B

Item
Price

A B C D E F
30 40 10 40 70 55

(a) Transactional dataset T.

(b) Skypatterns for {m1, m3}.
Subset of M

Skypatterns

(c) Skypatterns for {m2, m4}.

{m1, m2, m3, m4} BCD, BCDE, BDE, BE, E, EF

{m1, m2, m3} BCD, BCDE, E
{m1, m2, m4} E
{m1, m3, m4} BCD, BCDE, BDE, BE, E, EF
{m2, m3, m4} BCDE, BDE, E, EF
E
BCD, BCDE, B, E
E
BCDE
E
BCDE, BDE, E, EF
B, E
AEF, BCDE, BCDEF, BDE, E,
BCDF, BDEF, BDF, AF, EF, F
BCDE
E

{m1, m2}
{m1, m3}
{m1, m4}
{m2, m3}
{m2, m4}
{m3, m4}
{m1}

{m3}
{m4}

{m2}

Subset of M

Proper
Skypatterns

{m1, m3, m4} BE

{m1, m3} BCD
{m3, m4} BDE, EF

{m1}

{m2}

{m3}
{m4}

B, E
AEF, AF, BDE,
BCDEF, BCDF,
BCDE, BDEF,
BDF, E, EF, F
BCDE
E

(f) CSKY C for M.

(d) Lattice associated to M.

(e) SKY C for M.

Fig. 1: Running example: M = { m1:freq(x), m2:gr1(x), m3:area(x), m4:mean(x.price) }.

Example 1. Fig. 1a depicts a transactional dataset T where items in a transaction ti are
denoted A, . . . , F . It serves as example throughout the paper. An attribute (price) is
associated to each item. For instance, the Price of A is $30. The dataset is partitioned
into two classes, class c1 for clients with loyalty programs and class c2 for other clients.

Constraint-based pattern mining aims at extracting all patterns x∈LI satisfying a
query q(x) which is usually called theory [7]: T h(LI, q) = { x ∈ LI | q(x) is true }.
A common example is the minimal frequency constraint (freq(x) ≥ θ) which provides
patterns having a number of occurrences exceeding a given minimal threshold θ. Many
other measures for patterns can be considered such as:
- size(x) = |x| is the number of items that x contains.
- gr1(x) = (|T |−|T1|)×freq1(x)
- min(x.att)=min
i∈x

|T1|×(freq(x)−freq1(x)) where T1 is a sub-dataset (i.e a class partition) on T .
{i.att}) is the lowest (resp. high-

{i.att} (resp. max(x.att)=max
i∈x

est) among item values of x for attribute att.
- mean(x.att) = (min(x.att) + max(x.att))/2.

Example 2. freq(BC) = 5, mean(BCD.price) = 25, . . .

Skypatterns allow to express a user-preference according to a dominance relation [11].

4

Willy Ugarte et al.

Symbol

Table 1: Notations.

Deﬁnition

T Transactional dataset.
I Set of items.
LI = 2I \ ∅ Language of patterns.

M Set of measures.

U ⊆ M Subspace U (i.e. subset of measures of M).

Sky(LI, U) Skypatterns set over LI for U.

P -Sky(LI, U) Proper Skypattern set over LI for U.
(cid:96)-Sky(LI, U) Large Skypattern set over LI for U.
Desc(LI, U) Union of all proper skypattern sets for all descendant subspaces V ⊂ U.

SKY C(LI, M) Skypattern Cube over LI for M.

CSKY C(LI, M) Compressed Skypattern Cube over LI for M.

P ⊆ LI Set of patterns.

O(P ) Set of data points associated to P .

Skyline(O(P ), U) Set of skyline points on O(P ) for U.

Deﬁnition 1 (Pareto-dominance). A pattern x dominates another pattern y w.r.t a
measure subset (a.k.a subspace) U, noted by x (cid:31)U y, iff ∀mi ∈ U, mi(x) ≥ mi(y)
and ∃mj ∈ U, mj(x) > mj(y).

Example 3. For U = {m1:freq(x), m3:area(x)}, pattern BCD dominates pattern
BC since freq(BCD) = freq(BC) = 5 and area(BCD) > area(BC).

The Skypattern Operator [11] extracts the skypattern set w.r.t a subspace U.

Deﬁnition 2 (Skypattern Operator). A pattern is a skypattern w.r.t a subspace U iff it
is not dominated by any other pattern w.r.t U. The Skypattern Operator returns all the
skypatterns w.r.t U: Sky(LI, U) = { x ∈ LI |

(cid:54) ∃ y ∈ LI, y (cid:31)U x }.

Example 4. Consider the dataset of Fig. 1a, users may ask for the skypatterns for every
combination of the measures {m1, m2, m3, m4}. Figs. 1b and 1c depict skypatterns for
{m1, m3} and {m2, m4} respectively.

As said above, users may query multiple skypattern sets for different subspaces.
Furthermore, for a space M there are 2|M|−1 different skypattern sets. The Skypattern
Cube [13] retrieves all skypattern sets for any subspace.

Deﬁnition 3 (Skypattern Cube). Given a set of measures M, the Skypattern Cube of
M is deﬁned as SKY C(LI, M) = { (U, Sky(LI, U)) | U ⊆ M, U (cid:54)= ∅ }

Example 5. Fig. 1d depicts the lattice associated to M (power set of M: 2M \ ∅).
Fig. 1e associates to each non-empty subset of M its skypattern set.

For computing the skypattern cube, [13] has proposed a bottom-up approach using
two derivation rules that provide an easy way to automatically infer a large proportion
of the skypatterns of a parent node from the skypattern sets of its child nodes without
any dominance test (if k measures are associated to a parent node, its child nodes are
(cid:1) subsets of k − 1 measures).
the nodes deﬁned by the (cid:0) k

k−1

Compressing and Querying Skypattern Cubes

5

)
U

,
I
L
(
y
k
S

Pattern freq area mean(x.price)
BCD
25.00
15
BCDE
40.00
16
E
70.00
6
EF
62.50
8
BDE
55.00
12
BE
10
55.00
(a) Skypatterns for U and U(cid:48).

5
4
6
4
4
5

S
k
y
(
L
I
,

U
(cid:48)
)

Fig. 2: Example of (Proper) Skypatterns for U = {m1, m3, m4} and U(cid:48) = {m3, m4}.

(b) Measure values of skypatterns.

3 Contributions

This section introduces the CSKYC (Compressed Skypattern Cubes) which concisely
represents the entire skypattern cube. The main idea is, for every subspace, to only
store its proper skypatterns. More precisely, a skypattern x for a subspace U is stored
iff x∈Sky(LI, U) and there exists no V⊂U s.t. x∈Sky(LI, V). First, we introduce the
CSKYC of a set of measures. Then, we propose a bottom-up approach for building
such a CSKYC. Finally, we show how to efﬁciently query the whole skypattern set for
U from the CSKYC.

3.1 The Compressed Skypattern Cube

Deﬁnition 4 (Proper Skypattern). The set of proper skypatterns for a subspace U is
the subset of skypatterns on U which are not skypatterns in any subset of U:

P -Sky(LI, U) = { x ∈ Sky(LI, U) | (cid:64)V ⊂ U, x ∈ Sky(LI, V) }

Example 6. Consider U = {m1, m3, m4} and U(cid:48) = {m3, m4}. Tab. 2a shows the mea-
sure values for skypatterns for U and U(cid:48). Fig. 2b illustrates how proper skypattern BE
(in red) (resp. BDE (in light-blue)) is more balanced than other skypatterns for U (resp.
U(cid:48)), having fewer extreme values than the other skypatterns.

Based on this notion, we deﬁne the compressed skypattern cube.

Deﬁnition 5 (Compressed Skypattern Cube). Given a set of measures M, the com-
pressed skypattern cube of M is deﬁned as

CSKY C(LI, M) = (cid:8) (U, P -Sky(LI, U)) | U ⊆ M, U (cid:54)= ∅, P -Sky(LI, U) (cid:54)= ∅ (cid:9)

Example 7. For the dataset shown in Fig. 1a, the CSKY C(LI, M) is depicted in
Fig. 1f and its sub-lattice (in red) in Fig. 1d. It contains only 6 non-empty subsets com-
pared to 15 subsets in SKY C(LI, M). Clearly, the CSKYC is much more compact.

6

Willy Ugarte et al.

3.2 Computing the CSKYC

A ﬁrst and naive way to get the CSKYC consists in ﬁrst computing the skypattern cube,
and then deriving the CSKYC by removing duplicates from their subspaces. Such an
approach is inefﬁcient as the number of subspaces to process is exponential. In this
section, we provide a bottom-up algorithm (CSKYC-BUC) for building the CSKYC.
Given a set of measures M of size d, the subspaces are organized into d levels, such
that the subspaces of size i are in level i. We only keep non-empty subspaces (i.e. those
containing proper skypatterns). All descendant skypatterns of a subspace are collected
to form a large skypattern set ((cid:96)-Sky) which are then used as ﬁlters, and if no new
skypattern is found, the subspace is discarded from the CSKYC.
Let us ﬁrst give some preliminary deﬁnitions in order to compute the CSKYC.

Deﬁnition 6 (Indistinct/Incomparable Skypatterns). Let x, y be two skypatterns w.r.t
a subspace U: (i) x, y are indistinct, noted x =U y, iff ∀mi∈U, mi(x) = mi(y); (ii) x, y
are incomparable, noted x ≺(cid:31)U y, iff x (cid:54)(cid:31)U y, y (cid:54)(cid:31)U x and x (cid:54)=U y.

Incomparable skypatterns and indistinct ones for U constitute partitions of Sky(LI, U).

Deﬁnition 7 (Indistinct Subspace (IS)). A subspace U is an Indistinct Subspace (IS)
iff all patterns in Sky(LI, U) are indistinct from each other.

Example 8. Let U = {m1}, and V = {m1, m3}. B and E are indistinct w.r.t. U, while
BCDE and BCD are incomparable w.r.t. V.

Lemma 1 states that skypatterns that are common to two different subspaces remain
skypatterns in their union.

Lemma 1. Sky(LI, U) ∩ Sky(LI, V) ⊆ Sky(LI, U ∪ V)

Proof (By contradiction). Assume that, for two subspaces U, V s.t. W = U ∪ V,
∃x ∈ Sky(LI, U) ∩ Sky(LI, V)
(cid:123)(cid:122)
(cid:125)
(cid:124)
(1)
x ∈ Sky(LI, V)
. From (2): ∃y ∈ Sky(LI, W), y (cid:31)W x ⇒ ∀mi ∈ W, mi(y) ≥ mi(x)
.
(cid:125)
(cid:125)
(cid:123)(cid:122)
(cid:124)
(4)

. From (1): x ∈ Sky(LI, U)
(cid:125)

, but x /∈ Sky(LI, W)
(cid:125)

(cid:123)(cid:122)
(3)

(cid:123)(cid:122)
(2)

(cid:123)(cid:122)
(5)

(cid:124)

(cid:124)

(cid:124)

and

From (3): y (cid:54)(cid:31)U x ⇒ ∀mi ∈ U, mi(y) ≤ mi(x). From (5): x =U y
From (4): y (cid:54)(cid:31)V x ⇒ ∀mi ∈ V, mi(y) ≤ mi(x). From (5): x =V y
Thus, x ∈ Sky(LI, W) leading to a contradiction.

(cid:27)

x =W y.

Based on lemma 1, the following theorem enables us to characterize empty subspaces
in the CSKYC, i.e. those without proper skypatterns.

Theorem 1 (Empty subspaces in CSKYC). Given two subspaces U and V that are
IS, if Sky(LI, U) ∩ Sky(LI, V) (cid:54)= ∅, then U ∪ V is an IS and P -Sky(LI, U ∪ V) = ∅.

Proof (By contradiction). Let U, V two IS and W = U ∪ V.
- Assume that W is not an IS and ∃x, y ∈ Sky(T, U) ∩ Sky(T, V). From Lemma 1:
x, y∈Sky(T, W). Since W is not an IS, x ≺(cid:31)W y. As x, y∈Sky(T, U), x, y∈Sky(T, V)

Compressing and Querying Skypattern Cubes

7

and U and V are IS, thus, x =U y and x =V y. Thus, x =W y leading to a contradiction.
- Assume that ∃x∈Sky(T, U)∩Sky(T, V) and ∃y ∈ P -Sky(T, W). From Lemma 1:
x∈Sky(T, W). Since W is an IS, x =W y. Thus, x =U y and x =V y. So, y∈Sky(T, U)
and y∈Sky(T, V). Thus, y /∈ P -Sky(T, W) leading to a contradiction.

Example 9. In Fig. 1f, P -Sky(LI, {m1, m4}) = ∅ as Sky(LI, {m1}) ∩ Sky(LI, {m4}) = {E}

The authors in [13] showed that incomparable skypatterns and some indistinct skypat-
terns of a child subspace remain also skypatterns in its parent subspace (they are referred
to as derivable skypatterns). They also showed that a parent subspace can include non-
derivable skypatterns (i.e., those that are not skypatterns in any of its child subspaces).
Thus, one can collect the non-empty sets of descendants (which are proper skypatterns)
of a subspace to form a large skypattern set and to use them as ﬁlters to detect a priori
that no proper skypattern exist (see Corollary 1).

Deﬁnition 8 (Large Skypattern Set). The Large Skypattern Set for a subspace U is
the union of proper skypattern set of U with all proper skypattern sets of its descendant
subspaces V ⊂ U: (cid:96)-Sky(LI, U) = P -Sky(LI, U) ∪ Desc(LI, U),
where Desc(LI, U) = (cid:83)
P -Sky(LI, V) =
(cid:96)-Sky(LI, V)

(cid:83)

V⊂U

V⊂U∧|V|=|U|−1

(cid:122)

Example 10. For U = {m1:freq(x), m3:area(x), m4:mean(x.price)}:
(cid:96)-Sky(LI, U) = P -Sky(LI, U) ∪ (cid:96)-Sky(LI, {m1, m3}) ∪ (cid:96)-Sky(LI, {m1, m4}) ∪ (cid:96)-Sky(LI, {m3, m4})
(cid:122)
(cid:123)
(cid:125)(cid:124)
P -Sky(LI, {m3, m4})
∪
P -Sky(LI, {m3})
∪
P -Sky(LI, {m4})

(cid:122)
(cid:123)
(cid:125)(cid:124)
P -Sky(LI, {m1, m4})
∪
P -Sky(LI, {m1})
∪
P -Sky(LI, {m4})

(cid:122)
(cid:123)
(cid:125)(cid:124)
P -Sky(LI, {m1, m3})
∪
P -Sky(LI, {m1})
∪
P -Sky(LI, {m3})

(cid:125)(cid:124)
B, E,
EF, BCD,
BE, BDE,
BCDE

(cid:123)

Based on Deﬁnition 4, the proper skypatterns of any parent subspace can be computed
thanks to the following corollary.

Corollary 1. P -Sky(LI, U) = Sky(LI, U) \ Desc(LI, U).

To compute P -Sky(LI, U), we ﬁrst retrieve its descendants (which are proper skypat-
terns), then we seek for skypatterns that are not in Desc(LI, U). Algorithm 1 gives
the pseudo-code of our bottom-up approach. It starts by computing P -Sky(LI, mi) for
every mi ∈ M (level 1) and then follows a level-wise strategy: from the lower level,
each level of the lattice is constructed by applying Theorem 1 and, if needed, comput-
ing non-derivable skypatterns (cf. line 21). Two data structures, IS and (cid:96)-Sky are also
maintained during the construction process, storing for each subspace its large pattern
set and its status. They allow an incremental computation of (cid:96)-Sky.

3.3 Querying Sky(LI , U) from CSKY C(LI , M)

When a skypattern set for a given subspace U is queried, the CSKYC may not have
a record for U; even if it does, the skypattern set that is stored for U is not complete.
We propose a straightforward approach to query the complete skypattern set for U from
CSKY C(LI, M).

8

Willy Ugarte et al.

Algorithm 1: CSKYC-BUC: Bottom-up approach for computing CSKYC.

Input: T: a dataset, M: a set of measures.
Output: The Compressed Skypattern Cube w.r.t M.

1 CSKYC ← ∅; IS[ ] ← ∅; (cid:96)-Sky[ ] ← ∅;
2 foreach mi ∈ M do
3

P -Sky ← CP+SK Y(LI, {mi}) ;
(cid:96)-Sky[{mi}] ← P -Sky;
CSKYC ← CSKYC ∪ {({mi}, P -Sky)};
IS[{mi}] ← true;

4

5

6

// Initialization step

// Compute P -Sky(LI, mi)

7 for i ← 2 to |M| do
8

foreach U ⊆ M s.t. |U| = i do

9

10

11

P -Sky ← ComputeProperSky(U);
if P -Sky (cid:54)= ∅ then

CSKYC ← CSKYC ∪ {(U, P -Sky)};

// Compute P -Sky(LI, U)

12 return CSKYC;
13 Function ComputeProperSky(U):
14

|V| = |U| − 1 };

children ← { V ⊂ U |
childrenIS ← { W ∈ children | IS[W] = true };
IS[U] ← f alse;
if ∃V, W ∈ childrenIS s.t. Sky[V] ∩ Sky[W] (cid:54)= ∅ then

// Children of U

// Apply theorem 1

P -Sky ← ∅;
IS[U] ← true;

Desc ← (cid:83)

V∈children

if ¬IS[U] then

(cid:96)-Sky[V];

// Generate the filter skypatterns

P -Sky ← CP+SK Y(LI \ Desc, U);

// Apply corollary 1

(cid:96)-Sky[U] ← P -Sky ∪ Desc;
return P -Sky

// Update (cid:96)-Sky for U

15

16

17

18

19

20

21

22

23

24

Our approach is based on the fact that Sky(LI, U) ⊆ (cid:96)-Sky(LI, U) and proceeds
in two steps (see Algorithm 2): ﬁrst, approximating Sky(LI, U) by (cid:96)-Sky(LI, U), and
then, performing domination tests to ﬁlter dominated patterns.

(i) Approximating Sky(LI, U).
Based on Deﬁnition 8, we have that: ∀ U ⊆ M, Sky(LI, U) ⊆ (cid:96)-Sky(LI, U). The
proof is straightforward: ∀ x∈Sky(LI, U), either x∈P -Sky(LI, U), or ∃V ⊂ U s.t.
x∈P -Sky(LI, V).

(ii) Filtering dominated skypatterns.
To remove dominated skypatterns, we convert the problem into skyline mining oper-
ation in |U| dimensions to process it more efﬁciently. Let f be a mapping function
from a set of patterns P ⊆ LI to IRn that associates, to each pattern xi ∈ P , a data
point f (xi) ∈ IRn with coordinates (m1(xi) = vi,1, . . ., mn(xi) = vi,n). Let us note
by O(P ) = { f (x) | x ∈ P } the set of data points associated to P (see Tab. 2) and
Skyline(O(P ), U) be the set of skyline points of O(P ) w.r.t. U. Thus, ∀U ⊆ M,

Compressing and Querying Skypattern Cubes

9

Table 2: The multidimensional view for a set of patterns P ⊆ LI w.r.t. a subspace U (|U| = n).

n
r
e
t
t
a
P

m1

m2

. . . mn

v1,1
v2,1
...

v1,2
x1
v2,2
x2
...
...
xp−1 vp−1,1 vp−1,2 . . . vp−1,n
vp,2

. . . v1,n
. . . v2,n
...
...

. . . vp,n

vp,1

xp

P ⊆ LI






Algorithm 2: Querying Sky(LI, U) from CSKY C(LI, M)

Input: U: a subspace and CSKY C: the compressed skyppatern cube w.r.t. M.
Output: Sky(LI, U)

1 (cid:96)-Sky ← (cid:83)

P -Sky(LI, V);

// Approximating Sky(LI, U)

V⊆U
2 Sky ← BNL(O((cid:96)-Sky), U);
3 return Sky, (cid:96)-Sky

// Filtering dominated skypatterns

Sky(P, U) = Skyline(O(P ), U). So, applying the skyline operator on O(P ) provides
the skypattern set.

Theorem 2. Sky(LI, U) = Skyline(O((cid:96)-Sky(LI, U)), U).

Proof. Given a subspace U, we prove the two implications:
(⇒) Assume that ∃x∈Sky(LI, U): ∀y∈LI, y (cid:54)(cid:31)U x. So, ∀y∈(cid:96)-Sky(LI, U), y (cid:54)(cid:31)U x
therefore x ∈ Sky((cid:96)-Sky(LI, U), U). Thus, f (x) ∈ Skyline(O((cid:96)-Sky(LI, U)), U).
(⇐) Assume that ∃f (x) ∈ Skyline(O((cid:96)-Sky(LI, U)), U). So, ∀y1 ∈ (cid:96)-Sky(LI, U),
y1 (cid:54)(cid:31)U x. From Def. 8: ∀y2 ∈ LI \ (cid:96)-Sky(LI, U), ∃y3 ∈ Sky(LI, U), y3 (cid:31)U y2. Thus,
y2 (cid:54)(cid:31)U x. Therefore, x ∈ Sky(LI, U).

The second step is performed using a skyline algorithm based on the BNL approach [2].

4 Related Work

Skylines vs Skypatterns. The notion of skyline queries [2, 3] has been recently in-
tegrated into pattern discovery to mine skypatterns [11]. Even if these notions seem
similar, they correspond to very different extraction tasks. Skyline queries focus on the
extraction of dominant tuples of a (point) database (T ). The points (objects) are known
in advance and then dominance test are applied. The skypattern mining task requires to
mine patterns from a dataset (T ) that must be Pareto-dominant for a given set of mea-
sures. Therefore, the latter problem is much harder since the search space for skypat-
terns is much larger than the search space for skylines: O(LI=2|I|) instead of O(|T |).
Two methods have been designed for mining skypatterns: AE T H E R I S [11] is a two-step
method that beneﬁts from theoretical relationships between condensed representations

10

Willy Ugarte et al.

and skypatterns, while CP+SK Y [15] mines skypatterns using dynamic CSPs. Finally,
[12] provides a point-to-point comparison between these two approaches.
Skyline Cube vs Skypattern Cube. To offer the best possible response time for a
subspace skyline query, skyline cubes (a.k.a SkyCube) were introduced independently
by [17, 9]. They proposed several strategies to share skyline computation in different
subspaces. Pei et al. proposed in [8] Stellar, which computes seed skylines groups in the
full space, then extend it to build the ﬁnal set of skyline groups and thus avoid the com-
putation of skylines in all the subspaces. Similarly to the notions of skyline/skypattern,
the skyline cube differs from the skypattern cube. A SkyCube tackles a point database
looking for skyline point sets for a given set of dimensions. The skypattern cube com-
putation has to deal with all the skypattern sets for a given set of measures. As seen in
the previous paragraph, even if these notions are close, computing the skypattern cubes
is much harder due to the huge search space. Two methods have been proposed to com-
pute the skypattern cube. The ﬁrst method, called as CP+SKY+CUBE [13], is based on
a bottom-up approach and derivation rules exploiting the relation between the nodes in
the lattice. The second method [14] proposes an approximation of the skypattern cube
and then applies skyline cube mining in |M| dimensions on that approximation.
The Compressed Skyline Cube. Probably the closest previous work to our proposal
is the so called compressed skycube (CSC) [16]. Its compression technique consists in
storing for every subspace its partial skyline. It also supports concurrent subspace sky-
line queries in frequent updated databases. Our CSKYC can be seen as a reshaping of
the CSC. However, the compressed skypattern cube computation is much harder due to
the huge search space. Indeed, as shown previously, we need to extract patterns from a
transactional dataset (T) in order to determinate proper skypatterns for a given subspace.
Other skycube summarization techniques have also been introduced. For instance, [1]
proposed Hashcube, a structure based on bit-strings for storing the whole skycube. The
work described in [6] proposed the negative skycube that returns subspaces where ob-
jects are not skylines.

5 Experimental Evaluation

This section evaluates constructing and querying the CSKYC on a real-life dataset and
benchmarks. We compare the performances of the CSKYC with those of the original
SKYC in terms of running-time and space storage, followed by query performance
using CSKYC. The implementation of the different algorithms were carried out in C++.
All experiments were conducted on a PC running Linux with a core i3 processor at 2.13
GHz.

5.1 Compressed Skypattern Cubes for Mutagenicity Dataset

We performed experiments on a real-life dataset of large size extracted from muta-
genicity data [5] (a major problem in risk assessment of chemicals). This dataset has
|T|=6, 512 transactions encoding chemicals and |I|=1, 073 items encoding frequent
closed subgraphs previously extracted from T with a 2% relative frequency threshold.
Chemists use up to |M|=11 measures, ﬁve of them are typically used in contrast mining

|
)
U

,
I
L
(
y
k
S

|

(cid:80)

M
⊆
U

(2)

|
)
U

,
I
L
(
y
k
S
-

P

|

(cid:80)

M
⊆
U

(3)

|M|

)
3
(

)
2
(

−
1

1
−

|

|

M
2
(5)

1
2
3
4
5
6
7
8
9
10
11

338
753
1,280
1,983
2,982
4,526
7,146
12,015
21,773
42,386
87,374

1
338
3
493
784
7
15
1,123
31
1,525
63
1,990
2,484
127
255
2,924
511
3,246
1,023
3,462
2,047
3,853
(6) |{ U ⊆ M | P -Sky(LI, U) (cid:54)= ∅ }|

0.00
0.35
0.39
0.43
0.49
0.56
0.65
0.76
0.85
0.92
0.96

Compressing and Querying Skypattern Cubes

11

)
6
(

)
5
(

−
1

0.00
0.67
0.43
0.60
0.65
0.68
0.75
0.80
0.84
0.85
0.86

(6)

1
1
4
6
11
20
32
51
82
149
281

(a) Space analysis.

(b) CPU-times.

(c) Query times.

Fig. 3: Results on Mutagenicity Dataset with |M| = 11.

(e.g. growth rate) and allow to express different kinds of background knowledge. The
other six measures are related to topological and chemical properties of the chemicals.

Space analysis. Fig. 3a shows the storage comparison of CSKYC to skypattern cubes of
different dimensionality. Column 1 corresponds to the number of measures. Columns 2
and 3 report the total number of skypatterns for SKYC and CSKYC respectively. Col-
umn 4 gives their ratio. Columns 5 and 6 report the total number of subspaces for SKYC

12

Willy Ugarte et al.

and CSKYC respectively. Column 7 gives their ratio. For each |M| = k, reported val-
(cid:1) possible sky-
ues in columns (2), (3), (5) and (6) represent the averages over all (cid:0)11
pattern cubes. Overall, CSKYC achieves the best compression of the skypattern sets.
The effect of duplicate elimination is greatly ampliﬁed for |M| ≥ 6. CSKYC achieves
up to 20.6× compression (in number of skypatterns) and permits using 4 − 7× fewer
subspaces. For |M| = 11, the total number of proper skypatterns is 3, 853, while for
SKYC the total number of skypatterns is 87, 374. This lead to a substantial gain greater
than 95%.

k

CPU-time analysis. We compare our approach (CSKYC-BUC) with two methods: (i) a
base-line method (BL-CSKYC) for computing CSKYC, and (ii) CP+SKY+CUBE pro-
posed in [13] for computing SKYC. BL-CSKYC follows a bottom-up strategy: from the
lower level, for each level and each subspace of the lattice, we compute its skypatterns,
collect the skypatterns of its descendant subspaces, and then we remove all the dupli-
cates. Fig. 3b shows the performance of the three methods according to the number of
measures |M |. The scale is logarithmic. For CSKYC-BUC (resp. CP+SKY+CUBE)) and
for |M |=k, the reported CPU-time is the average of CPU-times over all (cid:0)11
(cid:1) possible
CSKYC (resp. SKYC). As we can see, CSKYC-BUC clearly outperforms BL-CSKYC
by several orders of magnitude. This is particularly obvious for higher values of |M | due
to the reduced number of skypatterns involved in the construction. For (2 ≤ |M| ≤ 5),
the average speed-up is 37.3. For |M| = 8, there is an order of magnitude (speed-up
value 213.15). For |M| = 11, the speed-up value reaches 949. Finally, CSKYC-BUC is
an average 2x faster than CP+SKY+CUBE for building the CSKYC.

k

Querying CSKYC. Evaluating the query performance of Algorithm 2, for |M |=k, is
performed by dividing the total time to sequentially query every subspace by 2k−1.
Each query is extracted from the CSKYC. The reported CPU-time in Fig. 3c are the
averages of CPU-times over all (cid:0)11
(cid:1) possible CSKYCs. By comparing the CPU-times
for the two steps of Algorithm 2, overall, the BNL step is negligible as compared to the
ﬁst step. The scale is logarithmic. Experimental results show that query processing of
the CSKYC is fast (less than 10 seconds for |M |=11).

k

5.2 Compressed Skypattern Cubes for UCI Datasets

Experiments were carried out on 15 datasets from UCI benchmarks [4]. We considered
5 measures M ={freq, max, area, mean, gr1}. In order to use measures using numeric
values, like mean, we generated random values associated to attributes, each value being
within the range [0..1]. Fig. 4 summarizes the results we obtained.

CPU-time analysis. Fig. 4a compares the performance of the three methods (with a
graphical view). Cols. 1-4 give the characteristics of each dataset (name, number of
items (I), number of transactions (T ) and density). CSKYC-BUC clearly dominates the
base-line method. On half of the datasets, there is an order of magnitude (speed-up value
at least 11.78) (Col. 8). CSKYC-BUC is an average 2 times faster than CP+SKY+CUBE.

Space analysis. Fig. 4b compares, for each dataset, the number of proper skypatterns vs.
the total number of skypatterns at each level of the cube. For each level i (2 ≤ i ≤ 5),
the corresponding summarization ratio is also depicted. Fig. 4c shows the graphical

Compressing and Querying Skypattern Cubes

13

Dataset

Name

I

T Density

CPU-Time
BL-CSKYC CP+SKY+CUBE CSKYC-BUC
(6)

(7)

Speed-Up

(5)
(7)

(6)
(7)

austral
cleve
cmc
crx
german
heart
hepatic
horse
hypo
lymph

690
55
43
303
28 1,474
59
690
76 1,000
270
38
155
45
300
75
47 3,163
142
59
mushroom 119 8,124
259
tic-tac-toe 29
846
58
179
45
102
43

vehicle
wine
zoo

(5)
6m04s
0.272
1m53s
0.325
26s
0.357
0.269
8m40s
0.276 2h34m18s
1m46s
0.368
6m12s
0.421
10m34s
0.235
0.389 6h13m57s
0.322
4m32s
0.193 9h23m28s
0.344
1m10s
34m01s
0.327
1m00s
0.311
19s
0.394

1m31s
21s
22s
1m13s
14m03s
19s
19s
58s
4m41s
11s
8h54m43s
41s
2m55s
13s
1s

1m01s
15s
16s
59s

5.97 1.49
7.53 1.40
1.63 1.38
8.81 1.24
9m36s 16.07 1.46
9s 11.78 2.11
10s 37.20 1.90
32s 19.81 1.81
1m21s 159.13 3.47
8s 34.00 1.38
1.44 1.36
3.33 1.95
1m03s 32.40 2.78
7s
8.57 1.86
1s 19.00 1.00

6h32m15s
21s

|M|

1

)
U

,
I
L
(
y
k
S

2

)
U

,
I
L
(
y
k
S
-

P

)
U

,
I
L
(
y
k
S

Dataset

(cid:80)

1
=
|
U
|

(cid:80)

2
=
|
U
|

(cid:80)

2
=
|
U
|

3

)
U

,
I
L
(
y
k
S
-

P

)
U

,
I
L
(
y
k
S

(cid:80)

3
=
|
U
|

(cid:80)

3
=
|
U
|

)
4
(

)
3
(

−
1

(a) Time Analysis.
5
4

)
U

,
I
L
(
y
k
S
-

P

)
U

,
I
L
(
y
k
S

(cid:80)

4
=
|
U
|

(cid:80)

4
=
|
U
|

)
U

,
I
L
(
y
k
S
-

P

)
U

,
I
L
(
y
k
S

(cid:80)

5
=
|
U
|

(cid:80)

5
=
|
U
|

)
0
1
(

)
1
1
(

−
1

)
7
(

)
6
(

−
1

)
3
1
(

)
2
1
(

−
1

(3)

(10)

(9)
648
300
299
437

austral
cleve
cmc
crx

(4)
45 0.97
34 0.99
57 0.90
58 0.99
60 0.99
29 0.98
95 0.50
22 0.99

101,630 1,314
43,504 6,601
559
12,208
107,742 5,216
german 1,173,279 35,083
34,400 1,218
heart
189
hepatic
9,598
129,716 10,352
horse
671,961
hypo
45,644
lymph

(12)
(6)
(7)
317
83 0.87
403 211 0.48
111
12 0.96
85 0.64
238
104
1 0.99
269
76 0.72
215
307 105 0.66
1 0.99
610
620 352 0.43 1,198 210 0.82
211
35 0.93
283 133 0.53
343
71 0.91
537 194 0.64
84
10 0.95
64 0.64
177
789 613 0.22 2,134 686 0.68 2,812 129 0.95 1,172
268
98
131
mushroom 650,965 96,164
109
16,157 1,301
tic-tac-toe
421
141,974 15,901
vehicle
57
15,112 1,346
wine
74
599
zoo

428 157 0.63
66 0.69
216
93 0.64
259
480 208 0.57
27 0.82
152
29 0.85
197

59 0.89
524
24 0.92
307
16 0.95
310
827 144 0.83
5 0.97
170
5 0.98
211

55 0.44
45 0.99
77 0.94
69 0.99
25 0.98
50 0.92

468
762
220

4,871

(13)

9 0.97
0 1.00
0 1.00
0 1.00
13 0.98
5 0.98
4 0.99
0 1.00
0 1.00
4 0.99
1 0.99
0 1.00
24 0.94
0 1.00
0 1.00

(b) Space Analysis.

(c) Summarization Ratios.

Fig. 4: Results on UCI datasets with |M| = 5.

view of these ratios. For level 2, on most of the datasets, CSKYC achieves a very high
summarization ratios (up to 99%). For level 3, these ratios mostly decrease since both
levels (2 and 3) share most subspaces ((cid:0)5
(cid:1) = 20 in total against 31 for the cube).
(cid:1) + (cid:0)5
Finally, for level 4 (resp. 5), CSKYC uses less storage than SKYC by at least 82%
(resp. 94%) in size for all datasets we considered. Within these levels, there are almost
(cid:1) = 1)
no proper skypatterns since they have few subspaces ((cid:0)5
for level 5 and each one of these subspaces has a lot of descendant subspaces (14 for
level 4 and 30 for level 5).

(cid:1) = 5 for level 4 and (cid:0)5

2

3

5

4

6 Conclusion

We have presented the compressed skypattern cube which concisely represents the sky-
pattern cube and preserves its essential information. Compared to the original skypat-
tern cube, the compressed skypattern cube has much less duplicates among susbpaces.
We have provided an efﬁcient algorithm to compute it and to query the skypattern set
for any subspace. Our experimental study shows that CSKYC is particularly efﬁcient

14

Willy Ugarte et al.

in terms of build time and space usage compared to the original skypattern cube. An-
other interesting property is its ability to efﬁciently provide the skypattern set of any
subspace. As future work, we plan to investigate the incremental maintenance of the
CSKYC by allowing to add and/or remove any measure.

References

1. Bøgh, K.S., Chester, S., Sidlauskas, D., Assent, I.: Hashcube: A data structure for space- and

query-efﬁcient skycube compression. In: CIKM. pp. 1767–1770 (2014)

2. B¨orzs¨onyi, S., Kossmann, D., Stocker, K.: The skyline operator. In: ICDE. pp. 421–430

(2001)

3. Chomicki, J., Godfrey, P., Gryz, J., Liang, D.: Skyline with presorting. In: ICDE. pp. 717–

719 (2003)

4. Dua, D., Graff, C.: UCI machine learning repository (2017), http://archive.ics.uci.edu/ml
5. Hansen, K., Mika, S., Schroeter, T., Sutter, A., ter Laak, A., Steger-Hartmann, T., Heinrich,
N., M¨uller, K.: Benchmark data set for in silico prediction of ames mutagenicity. JCIM 49(9),
2077–2081 (2009)

6. Hanusse, N., Wanko, P.K., Maabout, S.: Computing and summarizing the negative skycube.

In: CIKM. pp. 1733–1742 (2016)

7. Mannila, H., Toivonen, H.: Levelwise search and borders of theories in knowledge discovery.

Data Min. Knowl. Discov. 1(3), 241–258 (1997)

8. Pei, J., Fu, A.W., Lin, X., Wang, H.: Computing compressed multidimensional skyline cubes

efﬁciently. In: ICDE. pp. 96–105 (2007)

9. Pei, J., Jin, W., Ester, M., Tao, Y.: Catching the best views of skyline: A semantic approach

based on decisive subspaces. In: VLDB. pp. 253–264 (2005)

10. Pham, H., Lavenier, D., Termier, A.: Identifying genetic variant combinations using skypat-

terns. In: DEXA Workshops. pp. 44–48. IEEE Computer Society (2016)

11. Soulet, A., Ra¨ıssi, C., Plantevit, M., Cr´emilleux, B.: Mining dominant patterns in the sky. In:

ICDM. pp. 655–664 (2011)

12. Ugarte, W., Boizumault, P., Cr´emilleux, B., Lepailleur, A., Loudni, S., Plantevit, M., Ra¨ıssi,
C., Soulet, A.: Skypattern mining: From pattern condensed representations to dynamic con-
straint satisfaction problems. Artif. Intell. 244, 48–69 (2017)

13. Ugarte, W., Boizumault, P., Loudni, S., Cr´emilleux, B.: Computing skypattern cubes. In:

ECAI. pp. 903–908 (2014)

14. Ugarte, W., Boizumault, P., Loudni, S., Cr´emilleux, B.: Computing skypattern cubes using

relaxation. In: ICTAI. pp. 859–866 (2014)

15. Ugarte, W., Boizumault, P., Loudni, S., Cr´emilleux, B., Lepailleur, A.: Mining (soft-) sky-

patterns using dynamic CSP. In: CPAIOR. pp. 71–87 (2014)

16. Xia, T., Zhang, D.: Refreshing the sky: the compressed skycube with efﬁcient support for

frequent updates. In: SIGMOD Conference. pp. 491–502 (2006)

17. Yuan, Y., Lin, X., Liu, Q., Wang, W., Yu, J.X., Zhang, Q.: Efﬁcient computation of the skyline

cube. In: VLDB. pp. 241–252 (2005)

