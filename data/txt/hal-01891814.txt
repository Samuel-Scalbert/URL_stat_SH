Computing Possible and Certain Answers over
Order-Incomplete Data
Antoine Amarilli, Mouhamadou Lamine Ba, Daniel Deutch, Pierre Senellart

To cite this version:

Antoine Amarilli, Mouhamadou Lamine Ba, Daniel Deutch, Pierre Senellart. Computing Possible and
Certain Answers over Order-Incomplete Data. Theoretical Computer Science, 2019, 797, pp.42-76.
￿10.1016/j.tcs.2019.05.013￿. ￿hal-01891814￿

HAL Id: hal-01891814

https://inria.hal.science/hal-01891814

Submitted on 20 Jul 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution - NonCommercial 4.0 International License

Version of Record: https://www.sciencedirect.com/science/article/pii/S0304397519303214
Manuscript_5a5346aae94ebd477ffa2198611c185f

Computing Possible and Certain Answers
over Order-Incomplete Data

Antoine Amarillia, Mouhamadou Lamine Bab, Daniel Deutchc,
Pierre Senellarta,d,e

aLTCI, T´el´ecom ParisTech, Universit´e Paris-Saclay; Paris, France
bUniversit´e Alioune Diop de Bambey; Bambey, Senegal
cBlavatnik School of Computer Science, Tel Aviv University; Tel Aviv, Israel
dDI ENS, ENS, CNRS, PSL University; Paris, France
eInria; Paris, France

Abstract

This paper studies the complexity of query evaluation for databases whose
relations are partially ordered; the problem commonly arises when combining or
transforming ordered data from multiple sources. We focus on queries in a useful
fragment of SQL, namely positive relational algebra with aggregates, whose bag
semantics we extend to the partially ordered setting. Our semantics leads to
the study of two main computational problems: the possibility and certainty of
query answers. We show that these problems are respectively NP-complete and
coNP-complete, but identify tractable cases depending on the query operators
or input partial orders. We further introduce a duplicate elimination operator
and study its eﬀect on the complexity results.

Keywords: certain answer, possible answer, partial order, uncertain data

1. Introduction

Many applications need to combine and transform ordered data from multiple
sources. Examples include sequences of readings from multiple sensors, or log
entries from diﬀerent applications or machines, that need to be combined to
form a complete picture of events; rankings of restaurants and hotels based on
various criteria (relevance, preference, or customer ratings); and concurrent edits
of shared documents, where the order of contributions made by diﬀerent users
needs to be merged. Even if the order of items from each individual source is
usually known, the order of items across sources is often uncertain. For instance,
even when sensor readings or log entries are provided with timestamps, these may
be ill-synchronized across sensors or machines; rankings of hotels and restaurants
may be biased by diﬀerent preferences of diﬀerent users; concurrent contributions
to documents may be ordered in multiple reasonable ways. We say that the
resulting information is order-incomplete.

This paper studies query evaluation over order-incomplete data in a relational
setting [1]. We focus on the running example of restaurants and hotels from a

Preprint submitted to Elsevier

April 15, 2019

© 2019 published by Elsevier. This manuscript is made available under the CC BY NC user license
https://creativecommons.org/licenses/by-nc/4.0/

travel website, ranked according to a proprietary function. An example query
would ask for the ordered list of restaurant–hotel pairs such that the restaurant
and hotel are in the same district, or such that the restaurant features a particular
cuisine, and may further apply order-dependent operators to the result, e.g.,
limiting the output to the top-k such pairs, or aggregating a relevance score. To
evaluate such queries, the initial order on the hotels and restaurants must be
preserved through transformations. Furthermore, as we do not know how the
proprietary order is deﬁned, the result of transformations may become uncertain;
hence, we need to represent all possible results that can be obtained depending
on the underlying order.

Our approach is to handle this uncertainty through the classical notions of
possible and certain answers. We say that there is a certain answer to the query
when there is only one possible order on query results, or only one accumulation
result, which is obtained no matter the order on the input and in intermediate
results. In this case, it is useful to compute the certain answer, so that the
user can then browse through the ordered query results (as is typically done
when there is no uncertainty, using constructs such as SQL’s ORDER BY). Certain
answers can arise even in non-trivial cases where the combination of input data
admits many possible orders: consider user queries that select only a small
interesting subset of the data (for which the ordering happens to be certain),
or a short summary obtained through accumulation over large data. In many
other cases, the diﬀerent orders on input data or the uncertainty caused by the
query may lead to several possible answers. In this case, it is still of interest
(and non-trivial) to verify whether an answer is possible, e.g., to check whether
a given ranking of hotel–restaurant pairs is consistent with a combination of
other rankings (the latter done through a query). Thus, we study the problems
of deciding whether a given answer is certain, and whether it is possible.

Our main contributions may be summarized as follows.

Model and Problem Deﬁnition (Sections 2, 3). Our work focuses on bag semantics,
where a tuple may appear multiple times. Note that in the context of (partially)
ordered relations, this means that multiple copies of the same tuple may appear
in diﬀerent “positions” in the order. For example, if we integrate multiple
rankings of restaurants, then the same restaurant appears multiple times in
diﬀerent positions. We capture this model by a notion of po-relations (partially
ordered) relations. A po-relation is essentially a relation accompanied with a
partial order over its tuples; a technical subtlety is that each tuple is associated
with an identiﬁer (presumably internal and automatically generated), so that we
have a way of referring to each tuple occurrence in the partial order (see further
discussion in the problem deﬁnition below).

We then introduce a query language for partially ordered data. Our language
design is guided by the goal of supporting SQL evaluation in presence of such
data, and as such we focus on deﬁning a semantics for an important fragment
of SQL – namely positive relational algebra with aggregates. The semantics is
“faithful” to SQL in the sense that, if we ignore order, then we get the standard
SQL semantics. The notion corresponding to aggregation in our context is

2

LISP-like accumulation, whose semantics we extend to account for partial orders.
We view partially ordered relations as a concise representation of a set of
possible worlds, namely, the linear extensions of the partial orders over the
underlying tuples of the relation. For example, a linear extension is a ranked
list of restaurant cuisines, where a cuisine may appear multiple times in the
list. Note that in each such linear extension, the tuples appear without their
respective internal identiﬁers which, as mentioned earlier, were only present in
the po-relation as a technical tool.

Our deﬁnitions lead to a possible worlds semantics for query evaluation, and
to two natural problems: whether a candidate answer – i.e., a ranked list of
tuples (restaurants, cuisines, etc.) – is possible, i.e., is obtained for some possible
world, and whether it is certain, i.e., is obtained for every possible world. Here
again, note that in a candidate answer a tuple may appear multiple times, and
naturally it appears without identiﬁers (which, as mentioned above, are internal
and are unknown to the user). We formally deﬁne these two problems for our
settings, and then embark on a study of their complexity.

Complexity in the General Case (Section 4). We ﬁrst study the possibility and
certainty problems without any restrictions on the input database. As usual in
data management, given that queries are typically much smaller than databases,
we study the data complexity of the problems, i.e., the complexity when the
query is ﬁxed. For our general deﬁnition of po-relations, we show that deciding
whether an answer is possible is NP-complete, even without accumulation, and
even for some very simple queries and input relations.
In a particular case
where we assume no duplicates – i.e., where tuples are uniquely identiﬁed, which
means we are essentially back to the set semantics – possibility of an answer is
in PTIME without accumulation, but is again NP-complete with accumulation.
As for certainty, the problem can be decided in polynomial time in the case with
no accumulation, but it is coNP-complete for queries with accumulation (even if
we assume no duplicates in the input). Faced by the general intractability of
the possibility and certainty problems, in the rest of the paper we search for
restricted cases for which tractability holds.

Tractable Cases for Possibility Without Accumulation (Section 5). Even though
possibility is NP-hard even without accumulation, we identify realistic cases
where it is in fact tractable. In particular, we show that if the input relations
are totally ordered then possibility is in PTIME for queries using a subset of our
operators (all except the direct product). Assuming more severe restrictions on
the query language, we further show tractability when some of the relations are
(almost) ordered and the rest are (almost) unordered, as formalized via a newly
introduced notion of ia-width.

Tractable Cases with Accumulation (Section 6). With accumulation, the certainty
problem becomes intractable as well. Yet we show that if accumulation is captured
by a ﬁnite cancellative monoid (in particular, if it is performed in a ﬁnite group),
then certainty can again be decided in polynomial time. Further, we revisit the

3

tractability results for possibility from Section 5 and show that they extend
to queries with accumulation under certain restrictions on the accumulation
function.

Language Extensions (Section 7). We then study two extensions to our language,
which are the counterparts of common SQL operators. The ﬁrst is group-by,
which allows us to group tuples for accumulation (as is done for aggregation
in SQL with GROUP BY); we revisit our complexity results in its presence. The
second is duplicate elimination: keeping a single representative of identical tuples,
as in SQL with SELECT DISTINCT. In presence of order, it is challenging to design
a semantics for this operator, and we discuss both semantic and complexity
issues that arise from diﬀerent possible deﬁnitions.

We compare our model and results to related work in Section 8, and conclude

in Section 9.

This article is an extended version of the conference paper [2]. In contrast
with the conference paper [2], all proofs are included here. We also discovered a
bug in the proof of Theorem 22 of that paper [2], that also impacts Theorems 19
and 30 of [2]. Consequently, these results are omitted in the present paper.

2. Data Model and Query Language

We denote by N the set of nonnegative natural numbers and by N>0 the
set of positive natural numbers, i.e., N>0 := N \ {0}. We ﬁx a countable set of
values D that includes N and inﬁnitely many values not in N. A tuple t over D
of arity a(t) is an element of Da(t), denoted (cid:104)v1, . . . , va(t)(cid:105): for 1 (cid:54) i (cid:54) a(t), we
write t.i to refer to vi. The simplest notion of ordered relations are then list
relations [3, 4]: a list relation of arity n ∈ N is an ordered list of tuples over D of
arity n (where the same tuple may appear multiple times). List relations impose
a single order over tuples, but when one combines (e.g., unions) them, there may
be multiple plausible ways to order the results.

We thus introduce partially ordered relations (po-relations). A po-relation
Γ = (ID, T, <) of arity n ∈ N consists of a ﬁnite set of identiﬁers ID (chosen from
some inﬁnite set closed under the Cartesian product, e.g., we can use tuples of
natural numbers), a strict partial order < on ID, and a (generally non-injective)
mapping T from ID to Dn. The domain of Γ is the subset of values of D that
occur in the image of T . The actual identiﬁers in ID do not matter, but we
need them to refer to occurrences of the same tuple value. Hence, we always
consider po-relations up to isomorphism, where (ID, T, <) and (ID (cid:48), T (cid:48), <(cid:48)) are
isomorphic iﬀ there is a bijection ϕ : ID → ID (cid:48) such that T (cid:48)(ϕ(id )) = T (id ) for
all id ∈ ID, and ϕ(id 1)<(cid:48)ϕ(id 2) iﬀ id 1 < id 2 for all id 1, id 2 ∈ ID.

A special case of po-relations are unordered po-relations (or bag relations),
where < is empty: we denote them (ID, T ). Another special case is that of
totally ordered po-relations, where < is a total order.

The point of po-relations is to represent sets of list relations. Formally, a
linear extension <(cid:48) of < is a total order on ID such that < ⊆ <(cid:48), i.e., for each

4

x < y we have x <(cid:48) y. The possible worlds pw (Γ) of Γ are then deﬁned as follows:
for each linear extension <(cid:48) of <, writing ID as id 1 <(cid:48) · · · <(cid:48) id |ID|, the list
relation (T (id 1), . . . , T (id |ID|)) is in pw (Γ). As T is generally not injective, two
diﬀerent linear extensions may yield the same list relation. Note that each such
linear extension “strips away” the identiﬁers and includes only the tuples. For
instance, if Γ is unordered, then pw (Γ) consists of all permutations of the tuples
of Γ; and if Γ is totally ordered then pw (Γ) contains exactly one possible world.
Po-relations can thus model uncertainty over the order of tuples. However,
note that they cannot model uncertainty on tuple values. Speciﬁcally, let us
deﬁne the underlying bag relation of a po-relation Γ = (ID, T, <) as (ID, T ).
Unlike order, this underlying bag relation is always certain.

We extend some classical notions from partial order theory to po-relations.
Letting Γ = (ID, T, <) be a po-relation, an order ideal of Γ is a subset S ⊆ ID
such that, for all x, y ∈ ID, if x < y and y ∈ S then x ∈ S. An antichain [5] of Γ
is a set A ⊆ ID of pairwise incomparable tuple identiﬁers. The width of Γ is
the size of its largest antichain, and the width of a po-database is the maximal
width of its po-relations. In particular, totally ordered po-relations have width 1,
and unordered po-relations have a width equal to their number of tuples; the
width of a po-relation can be computed in polynomial time [6].

A chain partition of Γ is a partition ID = Λ1 (cid:116) · · · (cid:116) Λn such that the
restriction of < to each Λi is a total order: we call each Λi a chain. Note that <
may include comparability relations across chains, i.e., relating elements in Λi
to elements in Λj for i (cid:54)= j. The width of the chain partition is n. By Dilworth’s
theorem [7, 6], the width w of Γ is the smallest possible width of a chain partition
of Γ; furthermore, given Γ, we can compute in polynomial time both its width w
and a chain partition of Γ of width w.

2.1. PosRA: Queries Without Accumulation

We now deﬁne a bag semantics for positive relational algebra operators, to
manipulate po-relations with queries. The positive relational algebra, written
PosRA, is a standard query language for relational data [1]. We will extend
PosRA with accumulation in Section 2.3, and add further operations in Section 7.
Each PosRA operator applies to po-relations and computes a new po-relation;
we present them in turn.

The selection operator restricts the relation to a subset of its tuples, and
the order is the restriction of the input order. The tuple predicates allowed in
selections are Boolean combinations of equalities and inequalities, which involve
constant values in D and tuple attributes written as .i for i ∈ N>0. For instance,
the selection σ.1(cid:54)=“a”∧.2(cid:54)=.3 selects tuples whose ﬁrst attribute is equal to the
constant “a” and whose second attribute is diﬀerent from their third attribute.

selection: For any po-relation Γ = (ID, T, <) and tuple predicate ψ, we de-
ﬁne the selection σψ(Γ) ··= (ID (cid:48), T|ID (cid:48), <|ID (cid:48)), where ID (cid:48) ··= {id ∈ ID |
ψ(T (id )) holds}.

5

The projection operator changes tuple values in the usual way, but keeps the
original tuple ordering in the result, and retains all copies of duplicate tuples
(following our bag semantics).

projection: For a po-relation Γ = (ID, T, <) and attributes A1, . . . , An, we deﬁne
the projection ΠA1,...,An (Γ) ··= (ID, T (cid:48), <), where T (cid:48) maps each id ∈ ID
to ΠA1,...,An (T (id )) := (cid:104)T (id ).A1, . . . , T (id ).An(cid:105).

As for union, we impose the minimal order constraints that are compatible with
those of the inputs. We use the parallel composition [8] of two partial orders
< and <(cid:48) on disjoint sets ID and ID (cid:48), i.e., the partial order <(cid:48)(cid:48)··= (< ∪ <(cid:48)) on
ID ∪ ID (cid:48). Note that <(cid:48)(cid:48) is the same order as < on ID and as <(cid:48) on ID (cid:48), and
that all elements from ID are incomparable to all elements from ID (cid:48).

union: Let Γ = (ID, T, <) and Γ(cid:48) = (ID (cid:48), T (cid:48), <(cid:48)) be two po-relations of the
same arity. We assume that the identiﬁers of Γ(cid:48) have been renamed
if necessary to ensure that ID and ID (cid:48) are disjoint. We then deﬁne
Γ ∪ Γ(cid:48) ··= (ID ∪ ID (cid:48), T (cid:48)(cid:48), (< ∪ <(cid:48))), where T (cid:48)(cid:48) maps id ∈ ID to T (id ) and
id (cid:48) ∈ ID (cid:48) to T (cid:48)(id (cid:48)).

The union result Γ ∪ Γ(cid:48) does not depend on how we renamed Γ(cid:48), i.e., it is unique
up to isomorphism. Our deﬁnition also implies that Γ ∪ Γ is diﬀerent from Γ, as
per bag semantics. In particular, when Γ and Γ(cid:48) have only one possible world,
Γ ∪ Γ(cid:48) usually does not.

We next introduce two possible product operators. First, as in [9], the direct
product <DIR ··= (< ×DIR <(cid:48)) of two partial orders < and <(cid:48) on sets ID and
ID (cid:48) is deﬁned by (id 1, id (cid:48)
2 for each
(id 1, id (cid:48)
1), (id 2, id (cid:48)
2) ∈ ID × ID (cid:48). We deﬁne the direct product operator over
po-relations accordingly: two identiﬁers in the product are comparable only if
both components of both identiﬁers compare in the same way.

2) iﬀ id 1 < id 2 and id (cid:48)

1) <DIR (id 2, id (cid:48)

1 <(cid:48) id (cid:48)

direct product: For any po-relations Γ = (ID, T, <) and Γ(cid:48) = (ID (cid:48), T (cid:48), <(cid:48)),
remembering that the set of possible identiﬁers is closed under product, we
let Γ ×DIR Γ(cid:48) ··= (ID × ID (cid:48), T (cid:48)(cid:48), < ×DIR <(cid:48)), where T (cid:48)(cid:48) maps each (id , id (cid:48)) ∈
ID × ID (cid:48) to the concatenation (cid:104)T (id ), T (cid:48)(id (cid:48))(cid:105).

Again, the direct product result often has multiple possible worlds even when
inputs do not.

The second product operator uses the lexicographic product (or ordinal
product [9]) <LEX ··= (< ×LEX <(cid:48)) of two partial orders < and <(cid:48), deﬁned by
(id 1, id (cid:48)
2, for all
(id 1, id (cid:48)

2) iﬀ either id 1 < id 2, or id 1 = id 2 and id (cid:48)

1) <LEX (id 2, id (cid:48)
1), (id 2, id (cid:48)

2) ∈ ID × ID (cid:48).

1 <(cid:48) id (cid:48)

lexicographic product: For any po-relations Γ = (ID, T, <) and Γ(cid:48) = (ID (cid:48),
T (cid:48), <(cid:48)), we deﬁne Γ ×LEX Γ(cid:48) as (ID × ID (cid:48), T (cid:48)(cid:48), < ×LEX <(cid:48)) with T (cid:48)(cid:48) deﬁned
like for the direct product.

Last, we deﬁne the constant expressions that we allow.

6

hotelname district

hotelname district

(cid:104)TA, 5, B, 8(cid:105)

restname

district

Gagnaire
TourArgent

8
5

Mercure
Balzac
Mercure

5
8
12

Balzac
Mercure
Mercure

8
5
12

(a) Restaurant table

(b) Hotel table

(c) Hotel 2 table

(cid:104)G, 8, B, 8(cid:105)

(cid:104)TA, 5, M, 5(cid:105)

(cid:104)G, 8, M, 5(cid:105)

Figure 1: Running example: Paris restaurants and hotels

Figure 2: Example 1

constant expressions:

• for any tuple t, the singleton po-relation [t] has

only one tuple with value t;

• for any n ∈ N, the po-relation [(cid:54)n] has arity 1 and

has pw ([(cid:54)n]) = {(1, . . . , n)}.

We have now deﬁned a semantics on po-relations for each PosRA operator.
We deﬁne a PosRA query in the expected way, as a query built from these
operators and from relation names. Calling schema a set S of relation names
and arities, with an attribute name for each position of each relation, we deﬁne
a po-database D as having a po-relation of the correct arity for each relation
name R in S. For a po-database D and a PosRA query Q, we denote by |Q| the
number of symbols of Q, and we denote by Q(D) the po-relation obtained by
evaluating Q over D.

Example 1. The po-database D in Figure 1 contains information about restau-
rants and hotels in Paris: each po-relation has a total order (from top to bottom)
according to customer ratings from a given travel website. For brevity, we do
not represent identiﬁers in po-relations, and we also deviate slightly from our
formalism by adopting the named perspective in examples, i.e., giving names to
attributes.

Let Q ··= Restaurant ×DIR (σdistrict(cid:54)=“12”(Hotel)). Its result Q(D) has two

possible worlds, where we abbreviate hotel and restaurant names:

• ((cid:104)G, 8, M, 5(cid:105), (cid:104)G, 8, B, 8(cid:105), (cid:104)TA, 5, M, 5(cid:105), (cid:104)TA, 5, B, 8(cid:105));

• ((cid:104)G, 8, M, 5(cid:105), (cid:104)TA, 5, M, 5(cid:105), (cid:104)G, 8, B, 8(cid:105), (cid:104)TA, 5, B, 8(cid:105)).

In a sense, these list relations of hotel–restaurant pairs are consistent with
the order in D: we do not know how to order two pairs, except when both
the hotel and restaurant compare in the same way. The po-relation Q(D) is
represented in Figure 2 as a Hasse diagram, again writing tuple values instead of
tuple identiﬁers for brevity: note that, following the usual convention for Hasse
diagrams in partial order theory, the order in Figure 2 is drawn in the reverse
direction of that of Figure 1, i.e., from bottom to top.

Consider now the query Q(cid:48) ··= Π(σRestaurant.district=Hotel.district (Q)), where Π
projects out Hotel .district. The possible worlds of Q(cid:48)(D) are ((cid:104)G, B, 8(cid:105), (cid:104)TA, M, 5(cid:105))
and ((cid:104)TA, M, 5(cid:105), (cid:104)G, B, 8(cid:105)), intuitively reﬂecting two diﬀerent opinions on the
order of restaurant–hotel pairs in the same district. Deﬁning Q(cid:48)(cid:48) similarly to Q(cid:48)
but replacing ×DIR by ×LEX in Q, we have pw (Q(cid:48)(cid:48)(D)) = ((cid:104)G, B, 8(cid:105), (cid:104)TA, M, 5(cid:105)).

7

It is easy to show that we can eﬃciently evaluate PosRA queries on po-

relations, which we will use throughout the sequel.

Proposition 2. For any ﬁxed PosRA query Q, given a po-database D, we can
construct the po-relation Q(D) in time O(cid:0) |D||Q| (cid:1), i.e., in polynomial time in
the size of D.

Proof. We show the claim by a simple induction on the query Q, noting that
|Q| is at least k + 1, where k is the number of operators in Q.

• If Q is a relation name R, then Q(D) is obtained in linear time.

• If Q is a constant expression, then Q(D) is obtained in constant time.

• If Q = σψ(Q(cid:48)) or Q = Πk1...kp (Q(cid:48)), then Q(D) is obtained in time linear

in |Q(cid:48)(D)|, and we conclude by the induction hypothesis.

• If Q = Q1 ∪ Q2 or Q = Q1 ×LEX Q2 or Q = Q1 ×DIR Q2, then Q(D) is
obtained in time linear in |Q1(D)| × |Q2(D)|, and we conclude again by
the induction hypothesis.

Note that Proposition 2 computes the result of a query as a po-relation Γ.
However, we cannot eﬃciently compute the complete set pw (Γ) of possible
worlds of Γ, even if all relations of the input po-database are totally ordered.
For instance, consider the query Q := R ∪ S, and a po-database D interpreting
R and S as totally ordered relations with disjoint domains and with n tuples
each. It is easy to see that the query result Q(D) has (cid:0)2n
(cid:1) possible worlds, which
is exponential in D. This intractability is the reason why will we study the
possibility and certainty problems in the sequel.

n

2.2. Incomparability of PosRA Operators

Before extending our query language with accumulation, we address the
natural question of whether any of our operators is subsumed by the others. We
show that this is not the case.

Theorem 3. No PosRA operator can be expressed through a combination of the
others.

We prove Theorem 3 in the rest of this subsection. We consider each operator
in turn, and show that it cannot be expressed through a combination of the others.
We ﬁrst consider constant expressions and show diﬀerences in expressiveness
even when setting the input po-database to be empty.

• For [t], consider the query [(cid:104)0(cid:105)]. The value 0 is not in the database, and
cannot be produced by the [(cid:54)n] constant expression, and so this query has
no equivalent that does not use the [t] constant expression.

• For [(cid:54)n], observe that [(cid:54)2] is a po-relation with a non-empty order, while
any query involving the other operators will have empty order (none of our
unary and binary operators turns unordered po-relations into an ordered
one, and the [t] constant expression produces an unordered po-relation).

8

Moving on to unary and binary operators, all operators but products are

easily shown to be non-expressible.

selection. For any constant a not in N, consider the po-database Da consisting
of a single unordered po-relation with name R formed of two unary tuples
(cid:104)0(cid:105) and (cid:104)a(cid:105). Let Q = σ.1(cid:54)=“0”(R). Then, Q(Da) is the po-relation consisting
only of the tuple (cid:104)a(cid:105). No PosRA query without selection has the same
semantics, as no other operator than selection can create a po-relation
containing the constant a for any input Da, unless it also contains the
constant 0.

projection. Π is the only operator that can decrease the arity of an input

po-relation.

union. [(cid:104)0(cid:105)] ∪ [(cid:104)1(cid:105)] (over the empty po-database) cannot be simulated by any
combination of operators, as can be simply shown by induction: no other
operator will produce a po-relation which has the two elements 0 and 1 in
the same attribute.

Observe that product operators are the only ones that can increase arity,
so taken together they are non-redundant with the other operators. Hence, it
only remains to show that each of ×DIR and ×LEX is not redundant. To do this,
let us call PosRALEX the fragment of PosRA that disallows the ×DIR operator,
but allows all other operators (including ×LEX). We also deﬁne PosRADIR that
disallows ×LEX but not ×DIR.

We will ﬁrst show that the ×DIR product is not redundant, which we will
do using the notion of width. Speciﬁcally, consider the query QDIR = R ×DIR R
and an input po-database Dn where R is mapped to [(cid:54)n] (an input relation of
width 1) for an arbitrary Rn. It is then clear that the po-relation Q(Dn) has
width n. We will show that this query cannot be captured in PosRALEX, because
PosRALEX queries can only make width increase in a way that depends on the
width of the input po-relations, but not on their size.

Lemma 4. Let k (cid:62) 2 and Q be a PosRALEX query. For any po-database D of
width (cid:54) k, the po-relation Q(D) has width (cid:54) k|Q|+1.

Proof. We ﬁrst show by induction on the PosRALEX query Q that the width of
the query output can be bounded as a function of k. For the base case, the
input po-relations have width (cid:54) k, and all constant po-relations (singletons and
constant chains) have width 1. Let us show the induction step.

• Given two po-relations Γ1 and Γ2 with width respectively k1 and k2, their
union Γ := Γ1 ∪ Γ2 clearly has width at most k1 + k2. Indeed, any antichain
in Γ must be the union of an antichain of Γ1 and of an antichain of Γ2.

• Given a po-relation Γ1 with width k1, applying a projection or selection

to Γ1 cannot increase the width.

9

• Given two po-relations Γ1 = (ID 1, T1, <1) and Γ2 = (ID 2, T2, <2) with
width respectively k1 and k2, their product Γ ··= Γ1 ×LEX Γ2 has width
at most k1 · k2. To show this, write Γ = (ID, T, <), consider any set
A ⊆ ID of cardinality > k1 · k2, and let us argue that A is not an antichain.
By the deﬁnition of ×LEX, we can see each identiﬁer of A as an element
of ID 1 × ID 2. Now, one of the following must hold.

1. Letting S1 be the set of identiﬁers u ∈ ID 1 for which we have

(u, v) ∈ A for some v ∈ ID 2, it is the case that |S1| > k1.

2. There exists u such that, letting S2(u) ··= {v | (u, v) ∈ A}, we have

|S2(u)| > k2.

Informally, when putting > k1 · k2 values in buckets (the value of their ﬁrst
component), either > k1 diﬀerent buckets are used, or there is a bucket
containing > k2 elements.
In the ﬁrst case, as S1 ⊆ ID 1, as |S1| > k1, and as Γ1 has width k1, we
know that S1 cannot be an antichain, so it must contain two comparable
elements u <1 u(cid:48). Hence, considering any v, v(cid:48) ∈ ID 2 such that w = (u, v)
and w(cid:48) = (u(cid:48), v(cid:48)) are in A, we have by the deﬁnition of ×LEX that w < w(cid:48),
so that A is not an antichain. In the second case, as S2(u) ⊆ ID 2, as
|S2(u)| > k2, and as Γ2 has width k2, we know that S2(u) cannot be an
antichain, so it must contain two comparable elements v <2 v(cid:48). Hence,
considering w = (u, v) and w(cid:48) = (u, v(cid:48)) which are in A, we have w < w(cid:48),
and again A is not an antichain. Hence, no set of cardinality > k1 · k2 of Γ
is an antichain, so Γ has width (cid:54) k1 · k2 as claimed.

Second, we explain why the bound on the width of the query output can
be chosen as in the lemma statement. Speciﬁcally, letting o be the number of
product operators in Q plus the number of union operators, we show that we
can bound the width of Q(D) by ko+1. Indeed, the output of queries without
product or union operators have width at most k (because k (cid:62) 1). Further,
as projections and selections do not change the width, the only operators to
consider are product and union. For the union operator, if Q1 has o1 such
operators and Q2 has o2 such operators, bounding inductively the width of
Q1(D) by ko1+1 and Q2(D) by ko2+1, for Q := Q1 ∪ Q2, the number of union
and product operators is o1 + o2 + 1, and the new bound is ko1+1 + ko2+1, which
is (cid:54) ko1+1+o2+1 because k (cid:62) 2, i.e., it is (cid:54) k(o1+o2+1)+1. For the ×LEX operator,
we proceed in the same way and directly obtain the k(o1+o2+1)+1 bound. Hence,
we can indeed bound the width of Q(D) by k|Q|+1 as given in the statement,
which concludes the proof.

We have shown Lemma 4: PosRALEX queries can only make the width increase
as a function of the query and of the width of the input po-relations. Hence,
the query QDIR cannot be captured in PosRALEX, and the ×DIR product is not
redundant.

Conversely, let us show that the ×LEX product is not redundant. To do this,

we introduce the concatenation of po-relations.

10

Deﬁnition 5. The concatenation Γ ∪CAT Γ(cid:48) of two po-relations Γ and Γ(cid:48) is
the series composition of their two partial orders. Note that pw (Γ ∪CAT Γ(cid:48)) =
{L ∪CAT L(cid:48) | L ∈ pw (Γ), L(cid:48) ∈ pw (Γ(cid:48))}, where L ∪CAT L(cid:48) is the concatenation of
two list relations in the usual sense.

We show that concatenation can be captured in PosRALEX.

Lemma 6. For any arity n ∈ N and distinguished relation names R and R(cid:48),
there is a query Qn without ×DIR operator such that, for any two po-relations Γ
and Γ(cid:48) of arity n, letting D be the database mapping R to Γ and R(cid:48) to Γ(cid:48), the
query result Qn(D) is Γ ∪CAT Γ(cid:48).
Proof. For any n ∈ N and names R and R(cid:48), consider the following query:

Qn(R, R(cid:48)) ··= Π3...n+2 (σ.1=.2 ([(cid:54)2] ×LEX (([1] ×LEX R) ∪ ([2] ×LEX R(cid:48)))))

It is easily veriﬁed that Qn satisﬁes the claimed property.

By contrast, we show that concatenation cannot be captured in PosRADIR.
Lemma 7. For any arity n ∈ N>0 and distinguished relation names R and R(cid:48),
there is no PosRADIR query Qn such that, for any po-relations Γ and Γ(cid:48) of arity n,
letting D be the po-database that maps R to Γ and R(cid:48) to Γ(cid:48), the query result
Qn(D) is Γ ∪CAT Γ(cid:48).

To prove Lemma 7, we ﬁrst introduce the following concept.

Deﬁnition 8. Let v ∈ D. We call a po-relation Γ = (ID, T, <) v-impartial
if, for any two identiﬁers id 1 and id 2 and 1 (cid:54) i (cid:54) a(Γ) such that exactly one
of T (id 1).i, T (id 2).i is v, the following holds: id 1 and id 2 are incomparable,
namely, neither id 1 < id 2 nor id 2 < id 1 hold.
Lemma 9. Let v ∈ D\N be a value. For any PosRADIR query Q, for any
po-database D of v-impartial po-relations, the po-relation Q(D) is v-impartial.

Proof. Let D be a po-database of v-impartial po-relations. We show by induction
on the query Q that v-impartiality is preserved. The base cases are the following.

• For the base relations, the claim is vacuous by our hypothesis on D.

• For the singleton constant expressions, the claim is trivial as they contain

less than two tuples.

• For the [(cid:54)i] constant expressions, the claim is immediate as v /∈ N.

We now prove the induction step.

• For selection, the claim is shown by noticing that, for any v-impartial
po-relation Γ, letting Γ(cid:48) be the image of Γ by any selection, Γ(cid:48) is itself
Indeed, considering two identiﬁers id 1 and id 2 in Γ(cid:48) and
v-impartial.
1 (cid:54) i (cid:54) a(Γ) satisfying the condition, as Γ is v-impartial, id 1 and id 2 are
incomparable in Γ, so they are also incomparable in Γ(cid:48).

11

• For projection, the claim is also immediate as the property to prove
is maintained when reordering, copying or deleting attributes. Indeed,
considering again two identiﬁers id (cid:48)
2 of Γ(cid:48) and 1 (cid:54) i(cid:48) (cid:54) a(Γ(cid:48)),
the respective preimages id 1 and id 2 in Γ of id (cid:48)
2 satisfy the same
condition for some diﬀerent 1 (cid:54) i (cid:54) a(Γ) which is the attribute in Γ that
was projected to give attribute i(cid:48) in Γ(cid:48), so we again use the impartiality of
the original po-relation to conclude.

1 and id (cid:48)

1 and id (cid:48)

• For union, letting Γ(cid:48)(cid:48) ··= Γ ∪ Γ(cid:48), and writing Γ(cid:48)(cid:48) = (ID (cid:48)(cid:48), T (cid:48)(cid:48), <(cid:48)(cid:48)), assume by
contradiction the existence of two identiﬁers id 1, id 2 ∈ Γ(cid:48)(cid:48) and 1 (cid:54) i (cid:54) a(Γ(cid:48)(cid:48))
such that exactly one of T (cid:48)(cid:48)(id 1).i and T (cid:48)(cid:48)(id 2).i is v but (without loss of
generality) id 1 < id 2 in Γ(cid:48)(cid:48). It is easily seen that, as id 1 and id 2 are not
incomparable, they must come from the same relation; but then, as that
relation was v-impartial, we have a contradiction.

• For ×DIR, consider Γ(cid:48)(cid:48) ··= Γ×DIR Γ(cid:48) where Γ and Γ(cid:48) are v-impartial, and write
Γ(cid:48)(cid:48) = (ID (cid:48)(cid:48), T (cid:48)(cid:48), <(cid:48)(cid:48)) as above. Assume that there are two identiﬁers id (cid:48)(cid:48)
1
and id (cid:48)(cid:48)
2 of ID (cid:48)(cid:48) and 1 (cid:54) i (cid:54) a(Γ(cid:48)(cid:48)) that violate the v-impartiality of Γ(cid:48)(cid:48). Let
1), (id 2, id (cid:48)
(id 1, id (cid:48)
2) ∈ ID × ID (cid:48) be the pairs of identiﬁers used to create id (cid:48)(cid:48)
1
and id (cid:48)(cid:48)
2 . We distinguish on whether 1 (cid:54) i (cid:54) a(Γ) or a(Γ) < i (cid:54) a(Γ)+a(Γ(cid:48)).
In the ﬁrst case, we deduce that exactly one of T (id 1).i and T (id 2).i is v,
so that in particular id 1 (cid:54)= id 2. Thus, by the deﬁnition of the order in ×DIR,
1 and id (cid:48)(cid:48)
it is easily seen that, because id (cid:48)(cid:48)
2 are comparable in Γ(cid:48)(cid:48), id 1 and
id 2 must compare in the same way in Γ, contradicting the v-impartiality
of Γ. The second case is symmetric.

We now conclude with the proof of Lemma 7.

Proof. Let us assume by way of contradiction that there is n ∈ N>0 and a
PosRADIR query Qn that captures ∪CAT. Let v (cid:54)= v(cid:48) be two distinct values
in D\N, and consider the singleton po-relation Γ containing one identiﬁer of
value t and Γ(cid:48) containing one identiﬁer of value t(cid:48), where t (resp. t(cid:48)) are tuples
of arity n containing n times the value v (resp. v(cid:48)). Consider the po-database
D mapping R to Γ and R(cid:48) to Γ(cid:48). Write Γ(cid:48)(cid:48) ··= Qn(D). By our assumption, as
Γ(cid:48)(cid:48) = (ID (cid:48)(cid:48), T (cid:48)(cid:48), <(cid:48)(cid:48)) is Γ ∪CAT Γ(cid:48), it must contain an identiﬁer id ∈ ID (cid:48)(cid:48) such that
T (cid:48)(cid:48)(id ) = t and an identiﬁer id (cid:48) ∈ ID (cid:48)(cid:48) such that T (cid:48)(cid:48)(id (cid:48)) = t(cid:48). Now, as Γ and Γ(cid:48)
are (vacuously) v-impartial, Lemma 9 implies that Γ(cid:48)(cid:48) is v-impartial. Hence, as
n > 0, taking i = 1, as t (cid:54)= t(cid:48) and exactly one of t.1 and t(cid:48).1 is v, the identiﬁers
id and id (cid:48) are incomparable in <(cid:48)(cid:48), so there is a possible world of Γ(cid:48)(cid:48) where id (cid:48)
precedes id . This contradicts the fact that, as we should have Γ(cid:48)(cid:48) = Γ ∪CAT Γ(cid:48),
the po-relation Γ(cid:48)(cid:48) should have exactly one possible world, namely, (t, t(cid:48)).

This establishes that the ×LEX operator cannot be expressed using the others,
and shows that none of our operators is redundant, which concludes the proof of
Theorem 3.

12

2.3. PosRAacc: Queries With Accumulation

We now enrich PosRA with order-aware accumulation as the outermost
operation, inspired by right accumulation and iteration in list programming, and
aggregation in relational databases. Recall that a monoid (M, ⊕, ε) consists of
a set M (not necessarily ﬁnite), an associative operation ⊕ : M × M → M,
and an element ε ∈ M which is neutral for ⊕, i.e., for all m ∈ M, we have
ε ⊕ m = m ⊕ ε = m. We will use a monoid as the structure in which we perform
accumulation. We can now deﬁne accumulation on a given list relation.

Deﬁnition 10. For k ∈ N, let h : Dk × N>0 → M be a function called an
arity-k accumulation map, which maps pairs consisting of an k-tuple and a
position to a value in the monoid M. We call accumh,⊕ an arity-k accumulation
operator; its result accumh,⊕(L) on an arity-k list relation L = (t1, . . . , tn) is
h(t1, 1) ⊕ · · · ⊕ h(tn, n), and it is ε if L is empty. For complexity purposes,
we always require accumulation operators to be PTIME-evaluable, i.e., we can
evaluate the accumulation map and the monoid operator in time polynomial in
their inputs, and we can compute accumh,⊕(L) in polynomial time on any input
list relation L.

Intuitively, the accumulation operator maps each occurrence of a tuple in
the list with h to M, where accumulation is performed with ⊕. (Remember
that the input L to the accumulation is a list relation, so each tuple occurrence
has a speciﬁc position.) The map h may use its second argument to take into
account the absolute position of tuples in L. In what follows, we omit the arity
of accumulation when clear from context.

We will often look at special cases for accumulation, especially when deriving

complexity results. Here are the restrictions that we will consider.

Deﬁnition 11. We say that an accumulation operator is position-invariant if
its accumulation map ignores the second input, so that eﬀectively its only input
is the tuple itself

We say that an accumulation operator is ﬁnite if its monoid (M, ⊕, ε) is

ﬁnite.

For any monoid (M, ⊕, ε), we call a ∈ M cancellable if, for all b, c ∈ M, we
have that a ⊕ b = a ⊕ c implies b = c, and b ⊕ a = c ⊕ a implies b = c. We call
M a cancellative monoid [10] if all its elements are cancellable. We say that an
accumulation operator is cancellative if its monoid is.

Note that, in particular, a group is always cancellative, but there are some
cancellative monoids which are not groups, e.g., the monoid of concatenation.
We can now deﬁne the language PosRAacc that contains all queries of the
form Q = accumh,⊕(Q(cid:48)), where accumh,⊕ is an accumulation operator and Q(cid:48) is
a PosRA query. The possible results of Q on a po-database D, denoted Q(D), is
the set of results obtained by applying accumulation to each possible world of
Q(cid:48)(D), namely:

Deﬁnition 12. For a po-relation Γ, we deﬁne accumh,⊕(Γ) ··= {accumh,⊕(L) |
L ∈ pw (Γ)}.

13

Of course, accumulation has exactly one result whenever the accumulation
operator accumh,⊕ does not depend on the order of input tuples: this covers, e.g.,
the standard sum, min, max, etc. Hence, we focus on accumulation operators
which depend on the order of tuples, e.g., the monoid M of strings with ⊕
being the concatenation operation. In this case, there may be more than one
accumulation result.

Example 13. As a ﬁrst example, let Ratings(user , restaurant, rating) be an un-
ordered po-relation describing the numerical ratings given by users to restaurants,
where each user rated each restaurant at most once. Let Relevance(user ) be a
po-relation giving a partially-known ordering of users to indicate the relevance
of their reviews. We wish to compute a total rating for each restaurant which
is given by the sum of its reviews weighted by a PTIME-computable weight
function w. Speciﬁcally, w(i) gives a nonnegative weight to the rating of the
i-th most relevant user. Consider Q1 ··= accumh1,+(σψ(Relevance ×LEX Ratings))
where we set h1(t, n) ··= t.rating × w(n), and where ψ is the tuple predicate:
restaurant = “Gagnaire” ∧ Ratings.user = Relevance.user . The query Q1 gives
the total rating of “Gagnaire”, and each possible world of Relevance may lead to
a diﬀerent accumulation result. This accumulation operator is cancellative, but
it is neither position-invariant nor ﬁnite.

As a second example, consider an unordered po-relation HotelCity(hotel , city)
indicating in which city each hotel is located, and consider a po-relation City(city)
which is (partially) ranked by a criterion such as interest level, proximity,
etc. Now consider the query Q2 ··= accumh2,concat(Πhotel (Q(cid:48)
2 ··=
σCity.city=HotelCity.city (City ×LEX HotelCity) and h2(t, n) ··= t. Here, the operator
“concat” denotes standard string concatenation. Q2 concatenates the hotel names
according to the preference order on the city where they are located, allowing any
possible order between hotels of the same city and between hotels in incomparable
cities. This accumulation operator is cancellative and position-invariant, but it
is not ﬁnite.

2)), with Q(cid:48)

3. Possibility and Certainty

Evaluating a PosRA or PosRAacc query Q on a po-database D yields a set
of possible results: for PosRAacc, it yields an explicit set of accumulation results,
and for PosRA, it yields a po-relation that represents a set of possible worlds (list
relations). The uncertainty on the result may come from uncertainty on the order
of the input relations (i.e., if they are po-relations with multiple possible worlds),
but it may also be caused by the query, e.g., the union of two non-empty totally
ordered relations is not totally ordered. In some cases, however, there is only
one possible result to the query, i.e., a certain answer. In other cases, we may
wish to examine multiple possible answers. We thus deﬁne the corresponding
problems.

Deﬁnition 14 (Possibility and Certainty). Let Q be a PosRA query, D be
a po-database, and L a list relation. The possibility problem (POSS) asks if

14

L ∈ pw (Q(D)), i.e., if L is a possible result of Q on D. The certainty problem
(CERT) asks if pw (Q(D)) = {L}, i.e., if L is the only possible result of Q on D.
Likewise, if Q is a PosRAacc query with an accumulation monoid M, for a
result v ∈ M, the POSS problem asks whether v ∈ Q(D), and CERT asks whether
Q(D) = {v}.

For PosRAacc, our deﬁnition follows the usual notion of possible and certain
answers in data integration [11] and incomplete information [12]. For PosRA, we
ask for possibility or certainty of an entire output list relation of tuples without
indeed, as we explained above, the identiﬁers are only internally
identiﬁers:
generated and thus expected to be unknown to the user. These problems
correspond to instance possibility and certainty [13]. We now justify that these
notions are useful and discuss more “local” alternatives.

First, as we exemplify below, the output of a query may be certain even for
a complex query and uncertain input. It is important to identify such cases and
present the user with the certain answer in full, like order-by query results in
current DBMSs. Our CERT problem is useful for this task, because we can use it
to decide if a certain output exists: and if it is the case, then we can compute
the certain output in polynomial time, by choosing an arbitrary linear extension
and computing the corresponding possible world. However, CERT is a challenging
problem to solve, because of duplicate values (see the “Technical diﬃculties”
paragraph below).

Example 15. Consider the po-database D of Figure 1 with relations Restaurant
and Hotel 2. To ﬁnd recommended pairs of hotels and restaurants in the same dis-
trict, we can write Q ··= σRestaurant.district=Hotel 2.district (Restaurant ×DIR Hotel 2).
Evaluating Q(D) yields the list relation ((cid:104)G, 8, B, 8(cid:105), (cid:104)TA, 5, M, 5(cid:105)) as a unique
possible world: it is a certain result.

We may also obtain a certain result in cases when the input relations are
larger. Imagine for example that we join hotels and restaurants to ﬁnd pairs of
a hotel and a restaurant located in that hotel. The result can be certain if the
relative ranking of the hotels and of their restaurants agree.

If there is no certain answer, we can instead try to decide whether some list
relations are a possible answer. This can be useful, e.g., to check if a list relation
(obtained from another source) is consistent with a query result. For example,
we may wish to check if a website’s ranking of hotel–restaurant pairs is consistent
with the preferences expressed in its rankings for hotels and restaurants, to
detect when a pair is ranked higher than its components would warrant: this
can be done by checking if the ranking on the pairs is a possible result of the
query that uniﬁes the hotel ranking and restaurant ranking.

When there is no overall certain answer, or when we want to check the
possibility of some aggregate property of the relation, we can use a PosRAacc
query. In particular, in addition to the applications of Example 13, accumulation
allows us to encode alternative notions of POSS and CERT for PosRA queries,
and to express them as POSS and CERT for PosRAacc. For example, instead of

15

possibility or certainty for a full relation, we can express possibility or certainty
of the position 1 of particular tuples of interest.

One particular application of accumulation is to model position-based selection
queries. Consider for instance a top-k operator, deﬁned on list relations, which
retrieves a list relation of the ﬁrst k tuples. Let us extend the top-k operator to
po-relations in the expected way: the set of top-k results on a po-relation Γ is
the set of top-k results on the list relations of pw (Γ). We can implement top-k as
accumh3,concat with h3(t, n) being (t) for n (cid:54) k and ε otherwise, and with concat
being list concatenation. We can similarly compute select-at-k, i.e., return the
tuple at position k, via accumh4,concat with h4(t, n) being (t) for n = k and ε
otherwise. Both these accumulation operators are cancellative because they use
the concatenation monoid, and they are ﬁnite if we assume that the domain of
the output is ﬁxed (e.g., ratings in {1, . . . , 10}), and if we also assume for top-k
that k is ﬁxed.

Accumulation can also be used for a tuple-level comparison. To check whether
the ﬁrst occurrence of a tuple t1 precedes any occurrence of t2, we deﬁne h5
for all n ∈ N by h5(t1, n) ··= (cid:62), h5(t2, n) ··= ⊥ and h5(t, n) ··= ε for t (cid:54)= t1, t2,
and a monoid operator ⊕ that returns its ﬁrst argument: assuming that t1 and
t2 are both present, the result is (cid:62) if the ﬁrst occurrence of t1 precedes any
occurrence of t2, and it is ⊥ otherwise. This accumulation operator is ﬁnite and
position-invariant, but not cancellative.

We study the complexity of these variants in Section 6. We now give examples

of their use.

Example 16. Let Q ··= Πdistrict (σRestaurant.district=Hotel.district (Restaurant ×DIR
Hotel )), that computes ordered recommendations of districts including both hotels
and restaurants. The user can use accumulation to compute the best district to
stay in with Q(cid:48) = top-1(Q). When Q(cid:48) has a certain answer, there is a dominating
hotel–restaurant pair in this district which answers the user’s need. If there is no
certain answer, POSS allows the user to determine the possible top-1 districts.
We can also use POSS and CERT for PosRAacc queries to restrict attention to
tuples of interest. If the user hesitates between districts 5 and 6, they can apply
tuple-level comparison to see whether the best pair of district 5 may be better (or
is always better) than that of 6.

Technical diﬃculties. The main challenge to solve POSS and CERT for
a PosRA query Q on an input po-database D is that the tuple values of the
desired result L may occur multiple times in the po-relation Q(D), making it
hard to match L and Q(D). In other words, even though we can compute the
po-relation Q(D) in polynomial time (by Proposition 2) and present it to the
user, they still cannot easily determine the possible and certain answers out of
the po-relation.

1Remember that the existence of a tuple is not order-dependent, so it is trivial to check in

our setting.

16

jp
e

fr
c

fr
a

jp
f

it
d

it
b

Figure 3: Po-relation in Example 17

Example 17. Consider a po-relation Γ = (ID, T, <) with ID = {id a, id b, id c,
id d, id e, id f }, with T (id a) ··= (cid:104)Gagnaire, fr(cid:105), T (id b) ··= (cid:104)Italia, it(cid:105), T (id c) ··=
(cid:104)TourArgent, fr(cid:105), T (id d) ··= (cid:104)Verdi, it(cid:105), T (id e) ··= (cid:104)Tsukizi, jp(cid:105), T (id f ) ··= (cid:104)Sola,
jp(cid:105), and with id a < id c, id b < id c, id c < id e, id d < id e, and id d < id f .
Intuitively, Γ describes a preference relation over restaurants, with their name
and the type of their cuisine. Consider the PosRA query Q ··= Π(Γ) that projects Γ
on type; we illustrate the result (with the original identiﬁers) in Figure 3. Let L
be the list relation (it, fr, jp, it, fr, jp), and consider POSS for Q, Γ, and L.

We have that L ∈ pw (Q(Γ)), as shown by the linear extension id d <(cid:48) id a <(cid:48)
id f <(cid:48) id b <(cid:48) id c <(cid:48) id e of <. However, this is hard to see, because each of fr,
it, jp appears more than once in the candidate list as well as in the po-relation;
there are thus multiple ways to “map” the elements of the candidate list to
those of the po-relation, and only some of these mappings lead to the existence
of a corresponding linear extension. It is also challenging to check if L is a
certain answer: here, it is not, as there are other possible answers, such as
(it, fr, fr, it, jp, jp).

In the following sections we study the computational complexity of the POSS

and CERT problems, for multiple fragments of our language.

4. General Complexity Results

We have deﬁned the PosRA and PosRAacc query languages, and deﬁned
and motivated the problems POSS and CERT. We now start the study of their
complexity, which is the main technical contribution of our paper. We will
always study their data complexity 2, where the query Q is ﬁxed: in particular,
for PosRAacc, the accumulation map and monoid, which we assumed to be
PTIME-evaluable, is ﬁxed as part of the query, though it is allowed to be inﬁnite.
The input to POSS and CERT for the ﬁxed query Q is the po-database D and the
candidate result (a list relation for PosRA, an accumulation result for PosRAacc).
We summarize the complexity results of Sections 4–6 in Table 1.

In this section, we state our main complexity results and prove the corre-
sponding upper bounds. Lower bounds will be implied by more precise results

2In combined complexity, with Q part of the input, POSS and CERT are easily seen to be
NP-hard even without order, by reducing from the evaluation of Boolean conjunctive queries
(which is NP-hard in combined complexity [1]).

17

Table 1: Summary of complexity results for possibility and certainty

Query

Restr. on accum.

Input po-relations Complexity

POSS PosRA/PosRAacc —
CERT PosRAacc
—
—
CERT PosRA

—
POSS PosRALEX
—
POSS PosRADIR
POSS PosRAno×
—
POSS PosRALEX/PosRADIR —
CERT PosRAacc
POSS PosRAacc
CERT PosRAacc
both PosRAacc
LEX
both PosRAacc
no×
POSS PosRAacc
no×

arbitrary
arbitrary
arbitrary

NP-c.
(Thm. 18)
coNP-c. (Thm. 19)
PTIME (Thm. 32)

width (cid:54) k
PTIME (Thm. 20)
totally ordered
(Thm. 22)
NP-c.
ia-width or width (cid:54) k PTIME (Thm. 24)
(Thm. 31)
1 total. ord., 1 unord. NP-c.

arbitrary

PTIME (Thm. 32)
cancellative
NP-c.
(Thm. 37)
ﬁnite and pos.-invar. totally ordered
coNP-c. (Thm. 42)
ﬁnite and pos.-invar. totally ordered
ﬁnite
PTIME (Thm. 43)
ﬁnite and pos.-invar. ia-width or width (cid:54) k PTIME (Thm. 45)
(Thm. 47)
pos.-invar.

width (cid:54) k

unordered

NP-c.

that will be established in Sections 5 and 6.

We start with POSS, which we show to be NP-complete.

Theorem 18. The POSS problem is in NP for any ﬁxed PosRA or PosRAacc
query. Further, there exists a PosRA query and a PosRAacc query for which the
POSS problem is NP-complete.

Proof. To show that POSS is in NP, evaluate the query without accumulation
in PTIME using Proposition 2, yielding a po-relation Γ. Now, guess a total
order of Γ, checking in PTIME that it is compatible with the comparability
relations of Γ. If there is no accumulation function, then check that it achieves
the candidate result. Otherwise, evaluate the accumulation (in PTIME as the
accumulation operator is PTIME-evaluable), and check that the correct result
is obtained. This shows that POSS is in NP for PosRA and PosRAacc queries.
The NP-hardness will follow from stronger results that will be shown later:
Theorem 22 for PosRA and Theorem 37 for PosRAacc.

A diﬀerent route to prove the NP-hardness of POSS is to use existing work [14]
about the complexity of the so-called shuﬄe problem: given a string w and a
tuple of strings s1, . . . , sn on the ﬁxed alphabet A = {a, b}, decide whether there
is an interleaving of s1, . . . , sn which is equal to w. It is easy to see that there
is a reduction from the shuﬄe problem to the POSS problem, by representing
each string si as a totally ordered relation Li of tuples labeled a and b that
code the string, letting Γ be the po-relation deﬁned as the union of the Li, and
checking if the totally ordered relation that codes w is a possible world of the
identity PosRA query on the po-relation Γ. Hence, as the shuﬄe problem is
NP-hard [14], we deduce that POSS is NP-hard. However, this approach will not
suﬃce to derive the stronger NP-hardness results which we prove in the sequel.

We now show that CERT is coNP-complete for PosRAacc.

Theorem 19. The CERT problem is in coNP for any ﬁxed PosRAacc query, and
there is a PosRAacc query for which it is coNP-complete.

18

Proof. The co-NP upper bound is proved using precisely the same reasoning
applied to the NP upper bound for POSS, except that we now guess an order
that achieves a result diﬀerent from the candidate result. The hardness result
for CERT and PosRAacc is presented (in a slightly stronger form) as Theorem 42
in the sequel.

For PosRA queries, we will show that CERT is in PTIME. This will follow
from a stronger result that we will prove in the sequel (Theorem 32): CERT is
in PTIME for PosRAacc queries that perform accumulation in a cancellative
monoid.

Practical implications. We now discuss some implications of the results high-
lighted in Table 1 on the implementation of the algebra on top of, say, a SQL
database engine. First, recall Proposition 2: computing the result of a query,
as a po-relation, is in PTIME in the size of the input database, and can thus
reasonably be implemented. Second, thanks to Theorem 32, since CERT is in
PTIME for PosRA, it should also be possible to implement certainty tests ef-
ﬁciently. However, Theorem 18 shows that possibility tests are prohibitive to
implement in all generality.

However, in a practical context, input relations are usually not arbitrary
po-relations: it makes sense to assume in many scenarios that input relations
are either totally ordered (say, because they are ordered by their primary key, or
by an explicit ORDER BY construct) or unordered (because no speciﬁc ordering
has been chosen). In this case, we have two ways to ensure that the possibility
problem is tractable: either we only allow totally ordered po-relations as input
and then Theorem 20 (in Section 5) shows that possibility is tractable if the only
product operator allowed is ×LEX; or we allow both totally ordered and unordered
po-relations as input, but then only queries with no product are tractable for
possibility tests (which, arguably, considerably limits the expressive power).

When moving to PosRAacc, the picture is similar, but we need additional
properties of the accumulation function to ensure that the possibility and cer-
tainty problems are tractable (depending on the cases, it should be cancellative,
ﬁnite, or position-invariant).

We next identify further tractable cases. In the following section, we study
PosRA queries: we focus on POSS, as we know that CERT is always in PTIME
for such queries. In Section 6, we turn to PosRAacc.

5. Tractable Cases for POSS on PosRA Queries

We have stated a general NP-hardness result for POSS with PosRA queries.
We next show that tractability may be achieved if we both restrict the allowed
operators and bound some order-theoretic parameters of the input po-database,
e.g., its width. Recall that PosRALEX (respectively, PosRADIR) denotes the
fragment of PosRA that disallows ×DIR (respectively, ×LEX).

19

5.1. (Almost) Totally Ordered Inputs

We start by the natural case where we assume that the width of all input
po-relations is bounded by a constant. This assumption is a common practical
case:
it covers the case where all input po-relations are totally ordered, i.e.,
their order relation is a total order, so they actually represent a list relation.
This applies to situations where we integrate data from multiple sources that
are certain (totally ordered), and where uncertainty only arises because of the
integration query. The assumption also covers the case of po-relations that are
totally ordered except for a few “tied” data items at each level. Recall that
the query result can still have exponentially many possible worlds under this
assumption, e.g., when taking the union of two totally ordered relations. In
a sense, the ×DIR operator is the one introducing the most uncertainty and
“unorderedness” in the result, so we consider the fragment PosRALEX of PosRA
queries without ×DIR, and show the following result.

Theorem 20. For any ﬁxed k ∈ N and ﬁxed PosRALEX query Q, the POSS
problem for Q is in PTIME when all po-relations of the input po-database have
width (cid:54) k.

To show this result, letting D be the input po-database, we can use Proposi-
tion 2 to evaluate Γ := Q(D) in PTIME. Recall that we have previously shown
Lemma 4 on PosRALEX, so we know that the width of the po-relation Γ is con-
stant: it only depends on k and Q, but not on D. Hence, to show Theorem 20,
it suﬃces to show the following.

Lemma 21. For any constant k ∈ N, we can determine in PTIME, for any
po-relation Γ with width (cid:54) k and list relation L, whether L ∈ pw (Γ).

Let us prove this lemma and conclude the proof of Theorem 20.

Proof. Let Γ = (ID, T, <) be the po-relation of width k(cid:48) (cid:54) k, and let P =
(ID, <) be its underlying poset. We use Dilworth’s theorem [7, 6] to compute
in PTIME a chain partition ID = Λ1 (cid:116) · · · (cid:116) Λk(cid:48) of P . For 1 (cid:54) i (cid:54) k(cid:48), we write
ni ··= |Λi|, we write Λi[j] for 1 (cid:54) j (cid:54) ni to denote the j-th element of Λi, and for
(cid:54)j
0 (cid:54) j (cid:54) ni, we write Λ
to denote the ﬁrst j elements of the chain Λi, formally,
i
(cid:54)j
(cid:54)0
i = ∅ and Λni
Λ
i

:= {Λi[j(cid:48)] | 1 (cid:54) j(cid:48) (cid:54) j}. In particular, Λ
We now consider all vectors m of the form (m1, . . . , mk(cid:48)), with 0 (cid:54) mi (cid:54) ni
for each 1 (cid:54) i (cid:54) k(cid:48). There are polynomially many such vectors, more speciﬁcally
at most |Γ|k of them (recall that k is a constant). To each such vector m we
associate the subset s(m) of P consisting of (cid:70)k(cid:48)

i = Λi.

.

(cid:54)mi
i=1 Λ
i

We call such a vector m sane if s(m) is an order ideal. Note that this is
not always the case: while s(m) is always an order ideal of the subposet of the
comparability relations within the chains, it may not be an order ideal of P
overall because of the additional comparability relations across the chains. For
each vector m, we can check in PTIME whether it is sane: simply materialize
s(m) and check that it is an ideal by considering each of the (cid:54) |P |2 comparability
relations.

20

By deﬁnition, for each sane vector m, we know that s(m) is an ideal. We
now observe that the converse is also true: for every ideal S of P , there is a
sane vector m such that s(m) = S. To see why, consider any ideal S, and
determine for each 1 (cid:54) i (cid:54) k(cid:48) the last element of the chain Λi which is in S: let
mi := 1 (cid:54) i (cid:54) ni be the position of this element in Λi, where we set mi := 0 if S
contains no element of Λi. We know that S does not include any element of Λi at
a position later than mi, and because Λi is a chain it must include all elements
before mi; in other words, we have S ∩ Λi = Λ
. As (Λi)1(cid:54)i(cid:54)k(cid:48) is a chain
partition of P , this uniquely determines S. Thus we have indeed S = s(m), and
the fact that s(m) is sane is witnessed by S.

(cid:54)mi
i

We now use a dynamic algorithm to compute, for each sane vector m, a
Boolean denoted t(m) which is true iﬀ there is a topological sort of s(m) whose
label is the preﬁx of the candidate possible world L having length |s(m)| =
(cid:80)k(cid:48)
i=1 mi. We extend the function t to arbitrary vectors by setting t(m) := 0
whenever m is not sane. Speciﬁcally, the base case is that t(0, . . . , 0) ··= true,
because the empty ideal trivially achieves the empty preﬁx. To deﬁne the
induction case, let us denote by ei for 1 (cid:54) i (cid:54) k(cid:48) the vector consisting of n − 1
zeros and a 1 at position i. Now, for each sane vector m, we have:

t(m) ··=

(cid:95)

1(cid:54)i(cid:54)k(cid:48)
mi>0



(cid:32)



T (Λi[mi]) = L

(cid:34) k(cid:48)
(cid:88)

(cid:35)(cid:33)



mi(cid:48)

∧ t(m − ei)



i(cid:48)=1

where L is the candidate possible world and where “−” denotes the component-
wise diﬀerence on vectors. It is clear that t(m) is correct by induction: the key
argument is that, for any sane vector m, any linear extension of s(m) must ﬁnish
by enumerating one of the maximal elements of s(m), that is, Λi[mi] for some
1 (cid:54) i (cid:54) k(cid:48) such that mi > 0: and then the linear extension achieves the preﬁx
of L of length |s(m)| iﬀ the following two conditions are true: (i.) the label by T
of the last element in the linear extension must be the label of element of L at
position |s(m)|; and (ii.) m − ei must be a sane vector such that the restriction
of the linear extension to s(m − ei) achieves the preﬁx of L of length |s(m − ei)|
which by induction was computed as t(m − ei).

It is now clear that we can compute all t(m) in PTIME by a dynamic
algorithm: we enumerate the vectors (of which there are polynomially many) in
lexicographical order, and computing their image by t in PTIME according to
the equation above, from the base case t(0, . . . , 0) = ε and from the previously
computed values of t, recalling that t(m(cid:48)) := 0 whenever m(cid:48) is not sane. Now,
t(n1, . . . , nk(cid:48)) is true iﬀ Γ has a linear extension achieving L, so we have indeed
solved the POSS problem for Γ and L in PTIME, concluding the proof.

We have now shown Theorem 20 and established tractability for POSS with
PosRALEX queries on po-databases of bounded width. We will show in Theorem 43
that this proof technique further extends to queries with accumulation, under
some assumptions over the accumulation function.

21

S

0

1

2

s

s

s

s

s

n

n

n

n

s

e

e

e

e

s

s

s

s

s

n

n

n

n

n

n

e

e

e

e

s

s

s

s

n

n

n

n

n

n

e

n

n

n

n

e

e

e

e

e

e

S(cid:48)

Π2(S ×DIR S(cid:48))

L0

Figure 4: Example for the proof of Theorem 22.

We next show that our tractability result only holds for PosRALEX. Indeed,
if we allow ×DIR, then POSS is hard on totally ordered po-relations, even if we
disallow ×LEX. This result implies the general NP-hardness result on POSS that
we stated earlier (Theorem 18) for queries without accumulation.

Theorem 22. There is a PosRADIR query for which the POSS problem is NP-
complete even when input po-databases consist only of totally ordered po-relations.

Proof. We reduce from the NP-hard UNARY-3-PARTITION problem [15]: given
3m integers E = (n1, . . . , n3m) written in unary (not necessarily distinct) and a
number B, decide if the integers can be partitioned in triples such that the sum
of each triple is B. We reduce an instance I = (E, B) of UNARY-3-PARTITION
to a POSS instance in PTIME. We ﬁx D ··= N (cid:116) {s, n, e}, with s, n and e standing
for start, inner, and end.

Let D be the po-database which interprets the relation name S by the totally
ordered po-relation [(cid:54)3m − 1], and the relation name S(cid:48) by the totally ordered
po-relation constructed from the instance I as follows: for 1 (cid:54) i (cid:54) 3m, consider
1 with value s, ni tuples id i
the concatenation of one tuple id i
j (with 2 (cid:54) j (cid:54) ni +1)
with value n, and one tuple id i
ni+2 with value e, and deﬁne the interpretation
of S(cid:48) by concatenating the 3m sequences of length ni + 2. Consider the query
Q ··= Π2(S ×DIR S(cid:48)), where Π2 projects to the attribute of the relation S(cid:48). See
Figure 4 for an illustration with E = (1, 1, 2) and B = 4.

We deﬁne the candidate possible world L as the list relation L := L1L(cid:48)L2,

with L1, L(cid:48), and L2 deﬁned as follows.

• L1 is a list relation deﬁned as the concatenation, for 1 (cid:54) i (cid:54) 3m, of 3m − i
copies of the following sublist: one tuple with value s, ni tuples with
value n, and one tuple with value e.

• L2 is a list relation deﬁned like L1, except that 3m − i is replaced by i − 1.

• L0 is the list relation consisting of three tuples with value s, B tuples with
value n, three tuples with value e. See Figure 4 for an illustration of L0.

22

• L(cid:48) is the list relation deﬁned as the concatenation of m copies of L0.

We now consider the POSS instance that asks whether L is a possible world
of the query Q on the po-database D. We claim that this POSS instance is
positive iﬀ the original UNARY-3-PARTITION instance I is positive. As the
reduction process described above is clearly PTIME, the only thing left to prove
Theorem 22 is to show this claim, which we now do.

Denote by Γ(cid:48) the po-relation obtained by evaluating Q(D), and note that
(cid:54)k
all tuples of Γ(cid:48) have value in {s, n, e}. For 0 (cid:54) k (cid:54) |L1|, we write L
for the
1
(cid:54)k
preﬁx of L1 of length k. We say that L
is a whole preﬁx if either k = 0 (that
1
is, the empty preﬁx) or the k-th symbol of L1 has value e. We say that a linear
(cid:54)k
(cid:54)k
extension L(cid:48)(cid:48) of Γ(cid:48) realizes L
1 ,
1
(cid:54)|L1|
(cid:54)k
1 , we call the
and that it realizes L1 if it realizes L
1
matched elements the elements of Γ(cid:48) that occur in the ﬁrst k positions of L(cid:48)(cid:48),
and say that the other elements are unmatched. For 1 (cid:54) i (cid:54) 3m, we call the
i-th row of Γ(cid:48) the elements whose ﬁrst component before projection was i − 1:
note that, for each i, the po-relation Γ(cid:48) imposes a total order on the i-th row.
We deﬁne the row-i matched elements to refer to the elements on row-i that are
matched, and deﬁne analogously the row-i unmatched elements.

if the sequence of its k-th ﬁrst values is L

. When L(cid:48)(cid:48) realizes L

1 < . . . < id (cid:48)

Second, when a linear extension L(cid:48)(cid:48) of Γ(cid:48) realizes L

We ﬁrst observe that for any linear extension L(cid:48)(cid:48) realizing L

(cid:54)k
1 , for all i,
writing the i-th row as id (cid:48)
|S(cid:48)|, the unmatched elements must be all
of the form id (cid:48)
j for ki < j (cid:54) |S(cid:48)| for some 0 (cid:54) ki (cid:54) |S(cid:48)|, i.e., they must be a
preﬁx of the total order of the i-th row. Indeed, if they did not form a preﬁx,
then some order constraint of Γ(cid:48) would have been violated when enumerating
L(cid:48)(cid:48). Further, by cardinality we clearly have (cid:80)3m

i=1 ki = k.
(cid:54)k
1 , we say that we are in a
whole situation for k if for all i, either the ﬁrst row-i unmatched element id (cid:48)
ki+1
has value s or there are no row-i unmatched elements (and we write ki := |S(cid:48)|).
When we are in a whole situation for k, the condition on ki means by deﬁnition
that we must have ki = (cid:80)li
j=1(nj + 2) for some 1 (cid:54) li (cid:54) 3m; in this case, letting
Si be the multiset of the nj for 1 (cid:54) j (cid:54) li, we call Si the bag of row-i consumed
integers at k. The row-i remaining integers at k are E \ Si, where we see E as
a multiset and deﬁne the diﬀerence operator on multisets by subtracting the
multiplicities in Si to the multiplicities in E.

We now prove the following claim: for any linear extension of Γ(cid:48) realizing L1,
we are in a whole situation for |L1|, and the multiset union (cid:85)
1(cid:54)i(cid:54)3m Si of the
row-i consumed integers at k is equal to the multiset obtained by repeating
3m − i times the integer ni of E for all 1 (cid:54) i (cid:54) 3m.

We prove the ﬁrst part of the claim by showing it for all whole preﬁxes L

(cid:54)k
1 ,
(cid:54)0
by induction on k. It is certainly the case for L
(the empty preﬁx). Now,
1
assuming that it holds for preﬁxes of length up to l, to realize a whole preﬁx
with l(cid:48) > l, we must ﬁrst realize a strictly shorter whole preﬁx L(cid:54)l(cid:48)(cid:48)
L(cid:54)l(cid:48)
with
l(cid:48)(cid:48) (cid:54) l (take it to be of maximal length), so by induction hypothesis we are in a
whole situation for l(cid:48)(cid:48) when realizing L(cid:54)l(cid:48)(cid:48)
. Now to realize the whole preﬁx L(cid:54)l(cid:48)
having realized the whole preﬁx L(cid:54)l(cid:48)(cid:48)
, by construction of L1, the sequence L(cid:48)(cid:48) of

23

additional values to realize is s, a certain number of n’s, and e. It is now clear
that this must bring us from a whole situation to a whole situation: since there
is only one s in L(cid:48)(cid:48), there is only one row such that an s value becomes matched;
now, to match the additional n’s and e, only the elements of this particular row
can be used, as any ﬁrst unmatched element (if any) of all other rows is s, and
we must use the sequence of n-labeled elements followed by the e-labeled element
of the row. Hence the ﬁrst part of the claim is proved.

To prove the second part of the claim, observe that whenever we go from
a whole preﬁx to a whole preﬁx by additionally matching s, nj times n, and e,
then we add to Si the integer nj. So the claim holds by construction of L1.

has value e and id (cid:48)

A similar argument shows that for any linear extension L(cid:48)(cid:48) of Γ(cid:48) whose ﬁrst
|L1| tuples achieve L1 and whose last |L2| tuples achieve L2, for each 1 (cid:54) i (cid:54) 3m,
extending the deﬁnition of the row-i unmatched elements to refer to the elements
that are matched neither to L1 nor to L2, these elements must form a contiguous
sequence id (cid:48)
j with ki < j < mi for some 0 (cid:54) ki < mi (cid:54) |S(cid:48)| + 1: here ki refers
to the last element of row i matched to L1 (or 0 if none are), and mi to the ﬁrst
element of row i matched to L2 (or |S(cid:48)| + 1 if none are). In addition, if we have
ki < mi − 1, then id (cid:48)
has value s, and the unmatched
ki
values (whose deﬁnition is extended in an analogous fashion) are a multiset
corresponding exactly to the elements n1, . . . , n3m: indeed, each integer ni of E
is matched 3m−i times within L1 and i−1 times in L2, so 3m−i+i−1 = 3m−1
times overall, whereas it occurs 3m times in the grid. So the unmatched elements
when having read L1 (at the beginning) and L2 (at the end) are formed of 3m
sequences, of length ni + 2 for 1 (cid:54) i (cid:54) 3m, of the form s, ni times n, and e: each
of the 3m sequences is totally ordered (as it occurs as consecutive elements in
some row), and there is a certain order relation across the sequences depending
on the rows where they are: the comparability relations exist across sequences
that are on the same row, or that are in diﬀerent rows but where comparability
holds by deﬁnition of ×DIR.

mi

Observe now that there is a way to achieve L1 and L2 while ensuring that
there are no order constraints across the sequences of unmatched elements, i.e.,
the only order constraints within the unmatched elements are those given by the
total order on each sequence. To do so, we achieve L1 by picking the following, in
that order: for 1 (cid:54) j (cid:54) 3m, for 1 (cid:54) i (cid:54) 3m − j, pick the ﬁrst nj + 2 unmatched
tuples of row i. Similarly, to achieve L2 at the end, we can pick the following, in
reverse order: for 3m (cid:62) j (cid:62) 1, for 3m (cid:62) i (cid:62) 3m−j +1, the last nj +2 unmatched
tuples of row i. When we pick elements this way, the unmatched elements are 3m
lists (one for each row, with that of row i being s, ni times n and e, for all i) and
there are no order relations across sequences. We let Γ be the sub-po-relation of
Γ(cid:48) that consists of exactly these unmatched elements: it is illustrated in Figure 4
as the elements of the grid that are in the dashed rectangles. Formally, Γ is the
parallel composition of 3m totally ordered po-relations which we will call Γi for
1 (cid:54) i (cid:54) 3m: the elements of Γi consist of an element labeled s followed by ni
elements labeled n and one element labeled e.

We now claim that for any list relation L(cid:48)(cid:48), the concatenation L1L(cid:48)(cid:48)L2 is a
possible world of Γ(cid:48) if and only if L(cid:48)(cid:48) is a possible world of Γ. The “if” direction

24

was proved with the construction above, and the “only if” holds because Γ is
the least constrained possible po-relation for the unmatched sequences: recall
that the only comparability relations that it contains are those on the sequences
of unmatched elements, which are known to be total orders. Hence, to prove our
original claim, it only remains to show that the UNARY-3-PARTITION instance
I is positive iﬀ L(cid:48) is a possible world of Γ, which we now do.

For the forward direction, we show that, if I is a positive instance of
UNARY-3-PARTITION, then there is a linear extension <(cid:48) of < which wit-
nesses that L(cid:48) ∈ pw (Γ).
3) for
1 (cid:54) i (cid:54) m, with npi
= B for all 1 (cid:54) i (cid:54) m, and each integer of
{1, . . . , 3m} occurring exactly once in p. We can realize L(cid:48) from p by picking
successively the following for 1 (cid:54) i (cid:54) m to realize L0: the three s-labeled
for 1 (cid:54) q (cid:54) 3, then the n-labeled elements of
elements of the po-relations Γpi
these same po-relations (this is B tuples in total, because p is a solution to I),
and last the three e-labeled elements of these po-relations.

Indeed, consider a 3-partition p = (pi
+ npi

+ npi

1, pi

2, pi

2

1

3

q

3

2

1

1, pi

1, pi

2, pi

, Γpi

, and Γpi

For the backward direction, we show that, if there is a linear extension <(cid:48) of <
which witnesses that L(cid:48) ∈ pw (Γ), then we can build a 3-partition p = (pi
2, pi
3)
for 1 (cid:54) i (cid:54) m which satisﬁes the conditions above. To see why, we ﬁrst observe
that, for each 1 (cid:54) i (cid:54) m, considering the i-th occurrence of the sublist L0
in L(cid:48), there must be three distinct values pi
3, such that the elements which
occur in <(cid:48) at the positions of the value n in this occurrence of L0 are precisely
. Indeed, we show
the n-labeled elements of the po-relations Γpi
this claim for increasing values of i, from i = 1 to i = m. Just before we
consider each occurrence of L0, and just after we have considered it, we will
ensure the invariant that, for all 1 (cid:54) i (cid:54) 3m, either all elements of Γi have
been enumerated or none have: this invariant is clearly true initially because
nothing is enumerated yet. Now, considering the i-th occurrence of L0 for some
1 (cid:54) i (cid:54) m, we deﬁne pi
3, such that the elements s3 in this occurrence
1, pi
of L0 are mapped to the s-labeled elements of Γpi
: they must
, Γpi
indeed be mapped to such elements because they are the only ones with value s.
Now, the n-labeled elements of these three po-relations can all be enumerated
(indeed, we have just enumerated the s-labeled elements that precede them), and
they are the only elements with value n that can be enumerated, thanks to the
invariant: the others either have already been enumerated or have a predecessor
with value s that has not been enumerated yet. Further, all elements of this
form must be enumerated, because this is the only possible way for us to ﬁnish
matching L0 and enumerate three elements with value e, namely, those of the
: this uses the invariant again to justify that
three po-relations Γpi
they are the only elements with value e that can be enumerated at this stage.
We are now done with the i-th occurrence of L0, and clearly the invariant is
satisﬁed on the result, because the elements that we have enumerated while
matching this occurrence of L0 are all the elements of Γpi

, and Γpi

, and Γpi

, and Γpi

, Γpi

, Γpi

2, pi

.

1

2

3

2

1

3

Now that we have deﬁned the 3-partition p, it is clear by deﬁnition of a
linear extension that each position 1 (cid:54) i (cid:54) 3m, i.e., each number occurrence
in E, must occur exactly once in p. Further, as <(cid:48) achieves L0, by considering

1

2

3

25

each occurrence of L0, we know that, for 1 (cid:54) i (cid:54) m, we have pi
3 = B.
Hence, p witnesses that I is a positive instance to the UNARY-3-PARTITION
problem.

1 + pi

2 + pi

Hence, it is indeed the case that I is a positive UNARY-3-PARTITION
instance iﬀ L(cid:48) ∈ pw (Γ), which is the case iﬀ L1L(cid:48)L2 is a possible world of Γ(cid:48), i.e.,
iﬀ L is a possible world of Q(D). This establishes the correctness of the reduction
for PosRA, showing that the POSS problem for PosRA queries is NP-hard.

5.2. Disallowing Both Products

We have shown the tractability of POSS without the ×DIR operator, when
the input po-relations are assumed to have bounded width. We now study
the fragment PosRAno× without both kinds of product, and show that this
POSS is tractable for this fragment even for more general input po-relations.
Speciﬁcally, we will allow input po-relations that are almost totally ordered, i.e.,
have bounded width; and we will also allow input po-relations that are almost
unordered, which we measure using a new order-theoretic notion of ia-width.
The idea of ia-width is to decompose the relation in classes of indistinguishable
sets of incomparable elements.

Deﬁnition 23. Given a poset P = (ID, <), a subset A ⊆ ID is an antichain
if there are no x, y ∈ A such that x < y. It is an indistinguishable set (or an
interval [16]) if, for all x, y ∈ A and z ∈ ID\A, we have x < z iﬀ y < z, and
z < x iﬀ z < y. It is an indistinguishable antichain if it is both an antichain
and an indistinguishable set.

An indistinguishable antichain partition (ia-partition) of P is a partition
of ID into indistinguishable antichains. The cardinality of the partition is the
number of antichains. The ia-width of P is the cardinality of its smallest ia-
partition. The ia-width of a po-relation is that of its underlying poset, and the
ia-width of a po-database is the maximal ia-width of its po-relations.

Hence, any po-relation Γ has ia-width at most |Γ|, with the trivial ia-partition
consisting of singleton indistinguishable antichains, and unordered po-relations
have an ia-width of 1. Po-relations may have low ia-width in practice if order
is completely unknown except for a few comparability pairs given by users, or
when they consist of objects from a constant number of types that are ordered
based only on some order on the types.

We can now state our tractability result when disallowing both kinds of
products, and allowing both bounded-width and bounded-ia-width relations. For
instance, this result allows us to combine sources whose order is fully unknown or
irrelevant, with sources that are completely ordered (or almost totally ordered).

Theorem 24. For any ﬁxed k ∈ N and ﬁxed PosRAno× query Q, the POSS
problem for Q is in PTIME when each po-relation of the input po-database has
either ia-width (cid:54) k or width (cid:54) k.

To prove this result, we start by making a simple observation.

26

Lemma 25. Any PosRAno× query Q can be equivalently rewritten as a union
of projections of selections of a constant number of input relations and constant
relations.

Proof. For the semantics that we have deﬁned for operators, it it easy to show
that selection commutes with union, selection commutes with projection, and
projection commutes with union. Hence, we can perform the desired rewriting.

We can thus rewrite the input query using this lemma. The idea is that we
will evaluate the query in PTIME using Proposition 2, argue that the width
bounds are preserved using Lemma 4, and compute a chain partition of the
relations using Dilworth’s theorem. Let us ﬁrst show an analogue of Lemma 4
for the new notion of ia-width.

Lemma 26. Let k (cid:62) 2 and Q be a PosRAno× query. For any po-database D
of ia-width (cid:54) k, the po-relation Q(D) has ia-width (cid:54) max(k, q) × |Q|, where q
denotes the largest value such that [(cid:54)q] appears in Q.

Proof. We ﬁrst show by induction on Q that the ia-width of the query output
can be bounded by a function of k. We show the base cases.

• The input relations have ia-width at most k.

• The constant relations have ia-width (cid:54) q with the trivial ia-partition

consisting of singleton classes.

We then show the induction step.

• Projection clearly does not change ia-width.

• Selection may only decrease the ia-width. Indeed, consider an ia-partition
of the input po-relation, apply the selection to each class, and remove the
classes that became empty. The number of classes has not increased, and
it is clear that the result is still an ia-partition of the output po-relation.

• The union of two relations with ia-width k1 and k2 has ia-width at most
k1 + k2. Indeed, we can obtain an ia-partition for the union as the union
of ia-partitions for the input relations.

Second, we see that the bound max(k, q) × |Q| on the ia-width of Q(D) is
clearly correct, because the base cases have ia-width (cid:54) max(k, q) and the worst
operators are unions, which amount to summing the ia-width bounds on all
inputs, of which there are (cid:54) |Q|. So we have shown the desired bound.

We next show that, like chain partitions for bounded-width po-relations, we

can eﬃciently compute an ia-partition for a bounded-ia-width po-relation.

Proposition 27. The ia-width of any poset and a corresponding ia-partition
can be computed in PTIME.

27

To show this result, we need two preliminary observations about indistin-

guishable antichains.

Lemma 28. For any poset (ID, <) and indistinguishable antichain A, any
A(cid:48) ⊆ A is an indistinguishable antichain.

Proof. Clearly A(cid:48) is an antichain because A is. We show that it is an indistin-
guishable set. Let x, y ∈ A(cid:48) and z ∈ ID\A(cid:48), and show that x < z implies y < z
(the other three implications are symmetric). If z ∈ ID\A, then we conclude
because A is an indistinguishable set. If z ∈ A\A(cid:48), then we conclude because, as
A is an antichain, z is incomparable both to x and to y.

Lemma 29. For any poset (ID, <) and indistinguishable antichains A1, A2 ⊆ ID
such that A1 ∩ A2 (cid:54)= ∅, the union A1 ∪ A2 is an indistinguishable antichain.

Proof. We ﬁrst show that A1 ∪ A2 is an indistinguishable set. Let x, y ∈ A1 ∪ A2
and z ∈ ID\(A1 ∪ A2), assume that x < z and show that y < z (again the other
three implications are symmetric). As A1 and A2 are indistinguishable sets, this
is immediate unless x ∈ A1\A2 and y ∈ A2\A1, or vice-versa. We assume the
ﬁrst case as the second one is symmetric. Consider w ∈ A1 ∩ A2. As x < z, we
know that w < z because A1 is an indistinguishable set, so that y < z because
A2 is an indistinguishable set, which proves the desired implication.

Second, we show that A1 ∪ A2 is an antichain. Proceed by contradiction,
and let x, y ∈ A1 ∪ A2 such that x < y. As A1 and A2 are antichains, we must
have x ∈ A1\A2 and y ∈ A2\A1, or vice-versa. Assume the ﬁrst case, the second
case is symmetric. As A1 is an indistinguishable set, letting w ∈ A1 ∩ A2, as
x < y and x ∈ A1, we have w < y. But w ∈ A2 and y ∈ A2, which is impossible
because A2 is an antichain. We have reached a contradiction, so we cannot have
x < y. Hence, A1 ∪ A2 is an antichain, which concludes the proof.

We can now show Proposition 27.

Proof. Start with the trivial partition in singletons (which is an ia-partition),
and for every pair of items, see if their current classes can be merged (i.e., merge
them, check in PTIME if it is an antichain, and if it is an indistinguishable set,
and undo the merge if it is not). Repeat the process while it is possible to merge
classes (i.e., at most linearly many times). This greedy process concludes in
PTIME and yields an ia-partition A. Let n be its cardinality.

Now assume that there is an ia-partition A(cid:48) of cardinality m < n. There
has to be a class A(cid:48) of A(cid:48) which intersects two diﬀerent classes A1 (cid:54)= A2 of the
greedy ia-partition A, otherwise A(cid:48) would be a reﬁnement of A so we would
have m (cid:62) n. Now, by Lemma 29, A ∪ A1 and A ∪ A2, and hence A ∪ A1 ∪ A2,
are indistinguishable antichains. By Lemma 28, this implies that A1 ∪ A2 is an
indistinguishable antichain. Now, when constructing the greedy ia-partition A,
the algorithm has considered one element of A1 and one element of A2, attempted
to merge the classes A1 and A2, and, since it has not merged them in A, the
union A1 ∪ A2 cannot be an indistinguishable antichain. We have reached a
contradiction, so we cannot have m < n, which concludes the proof.

28

We have shown the preservation of ia-width bounds through selection, pro-
jection, and union (Lemma 26), and shown how to compute an ia-partition in
PTIME (Proposition 27). Let us now return to the proof of Theorem 24. We
use Lemma 25 to rewrite the query to a union of projection of selections. We
evaluate the selections and projections in PTIME by Proposition 2. As union
is clearly associative and commutative, we evaluate the union of relations of
width (cid:54) k, yielding Γ, and the union of those of ia-width (cid:54) k, yielding Γ(cid:48). The
ﬁrst result Γ has bounded width thanks to Lemma 4, and we can compute a
chain partition of it in PTIME using Dilworth’s theorem. The second result has
bounded ia-width thanks to Lemma 26, and we can compute an ia-partition of
it in PTIME using Proposition 27. Hence, to show Theorem 24, it suﬃces to
show the following strengthening of Lemma 21.

Lemma 30. For any constant k ∈ N, we can determine in PTIME, for any
input po-relation Γ with width (cid:54) k, input po-relation Γ(cid:48) with ia-width (cid:54) k, and
list relation L, whether L ∈ pw (Γ ∪ Γ(cid:48)).

Proof. We ﬁrst show the result when assuming that Γ is empty, and will later
return to the general case. Let A = (A1, . . . , Ak) be an ia-partition of width k
of Γ(cid:48) = (ID, T, <), which can be computed in PTIME by Proposition 27. We
assume that the length of the candidate possible world L is |ID|, as we can
trivially reject otherwise.

For any linear extension <(cid:48) of Γ(cid:48), we deﬁne the ﬁnishing order of <(cid:48) as the
permutation π of {1, . . . , k} obtained by considering, for each class Ai of A, the
largest position 1 (cid:54) ni (cid:54) |ID| in <(cid:48) to which an element of Ai is mapped, and
sorting the class indexes in ascending order according to this largest position.
We say we can realize L with ﬁnishing order π if there is a linear extension of Γ(cid:48)
that realizes L and whose ﬁnishing order is π. Hence, it suﬃces to check, for
every possible permutation π of {1, . . . , k}, whether L can be realized from Γ(cid:48)
with ﬁnishing order π: this does not make the complexity worse because the
number of ﬁnishing orders depends only on k and not on Γ(cid:48), so it is constant.
(Note that the order relations across classes may imply that some ﬁnishing orders
are impossible to realize altogether.)

We now claim that to determine whether L can be realized with ﬁnishing
order π, the following greedy algorithm works. Read L linearly. At any point,
maintain the set of elements of Γ(cid:48) that have already been enumerated (distinguish
the used and unused elements; initially all elements are unused), and distinguish
the classes of A in three kinds: the exhausted classes, where all elements are
used; the open classes, the ones where some elements are unused and all ancestor
elements outside of the class are used; and the blocked classes, where some
ancestor element outside of the class is not used. Initially, the open classes are
those which are roots in the poset obtained from the underlying poset of Γ(cid:48) by
taking the quotient by the equivalence relation induced by A; and the other
classes are blocked.

When reading a value t from L, consider all open classes. If none of these
classes have an unused element with value t, reject, i.e., conclude that we cannot
realize L as a possible world of Γ(cid:48) with ﬁnishing order π. Otherwise, take the

29

open class that comes ﬁrst in the ﬁnishing order, and use an arbitrary suitable
element from it. Update the class to be exhausted if it is: in this case, check
that the class was the next one in the ﬁnishing order π (and reject otherwise),
and update from blocked to open the classes that must be. Once L has been
completely read, accept: as |L| = |ID|, all elements are now used.

It is clear by construction that, if this greedy algorithm accepts, then there
is a linear extension of Γ(cid:48) that realizes L with ﬁnishing order π; indeed, when
the algorithm succeeds, then it has clearly respected the ﬁnishing order π, and
whenever an identiﬁer id of Γ(cid:48) is marked as used by the algorithm, then id has
the right value relative to the element of L that has just been read, and id is in
an open class so no order relations of Γ(cid:48) are violated by enumerating id at this
point of the linear extension. The interesting direction is the converse: show that
if L can be realized by a linear extension <(cid:48) of Γ(cid:48) with ﬁnishing order π, then
the algorithm accepts when considering π. To do so, we must show that if there
is such a linear extension, then there is such a linear extension where identiﬁers
are enumerated as in the greedy algorithm, i.e., we always choose an identiﬁer
with the right value and in the open class with the smallest ﬁnishing time: we
call this a minimal identiﬁer. (Note that we do not need to worry about which
identiﬁer is chosen: once we have decided on the value of the identiﬁer and on
its class, it does not matter which element we choose, because all elements in the
class are unordered and have the same order relations to elements outside the
class thanks to indistinguishability.) If we can prove this, then it justiﬁes the
existence of a linear extension that the greedy algorithm will construct, which
we call a greedy linear extension.

Hence, let us see why it is always possible to enumerate minimal identiﬁers.
Consider a linear extension <(cid:48) and take the smallest position in L where <(cid:48)
chooses an identiﬁer id which is non-minimal. We know that id must still have
the correct value, i.e., T (id ) is determined, and by the deﬁnition of a linear
extension, we know that id must be in an open class. Hence, we know that the
class A of id is non-minimal, i.e., there is another open class A(cid:48) containing an
unused element with value T (id ), and A(cid:48) is before A in the ﬁnishing order π.
Let us take for A(cid:48) the ﬁrst open class with such an unused element in the
ﬁnishing order π, and let id (cid:48) be a minimal element, i.e., an element of A(cid:48) with
T (id (cid:48)) = T (id ). Let us now construct a diﬀerent linear extension <(cid:48)(cid:48) by swapping
id and id (cid:48), i.e., enumerating id (cid:48) instead of id , and enumerating id in <(cid:48)(cid:48) at the
point where <(cid:48) enumerates id (cid:48). It is clear that the sequence of values (images
by T ) of the identiﬁers in <(cid:48)(cid:48) is still the same as in <(cid:48). Hence, if we can show
that <(cid:48)(cid:48) additionally satisﬁes the order constraints of Γ(cid:48), then we will have
justiﬁed the existence of a linear extension that enumerates minimal identiﬁers
until a later position; so, reapplying the rewriting argument, we will deduce
the existence of a greedy linear extension. So it only remains to show that <(cid:48)(cid:48)
satisﬁes the order constraints of Γ(cid:48).

Let us assume by way of contradiction that <(cid:48)(cid:48) violates an order constraint
of Γ(cid:48). There are two possible kinds of violation. The ﬁrst kind is if <(cid:48) enumerates
an element id (cid:48)(cid:48) between id and id (cid:48) for which id < id (cid:48)(cid:48), so that having id (cid:48)(cid:48) <(cid:48)(cid:48) id
in <(cid:48)(cid:48) is a violation. The second kind is if <(cid:48) enumerates an element id (cid:48)(cid:48) between

30

id and id (cid:48) for which id (cid:48)(cid:48) < id (cid:48), so that having id (cid:48)(cid:48) <(cid:48)(cid:48) id (cid:48) in <(cid:48)(cid:48) is a violation.
The second kind of violation cannot happen because id (cid:48) is in an open class
when <(cid:48) considers id , i.e., we have ensured that id (cid:48) can be enumerated instead
of id . Hence, we focus on violations of the ﬁrst kind. Consider id (cid:48)(cid:48) such that
id <(cid:48) id (cid:48)(cid:48) <(cid:48) id (cid:48) and let us show that id (cid:54)< id (cid:48)(cid:48). Letting A(cid:48)(cid:48) be the class of id (cid:48)(cid:48),
we assume that A(cid:48)(cid:48)
(cid:54)= A, as otherwise there is nothing to show because the
classes are antichains. Now, we know from <(cid:48) that id (cid:48) (cid:54)<(cid:48) id (cid:48)(cid:48), and that the
class A(cid:48) of id (cid:48) is not exhausted when <(cid:48) enumerates id (cid:48)(cid:48). As <(cid:48) respects the
ﬁnishing order π, and A(cid:48) comes before A in π, we know that A is not exhausted
either when <(cid:48) enumerates id (cid:48)(cid:48). Letting id A be an element of A which is still
unused when <(cid:48) enumerates id (cid:48)(cid:48), we know that id A (cid:54)< id (cid:48)(cid:48). So, as id (cid:48)(cid:48) /∈ A, by
indistinguishability, we have id (cid:54)< id (cid:48)(cid:48). This is what we wanted to show, so
id (cid:48)(cid:48) cannot witness a violation of the ﬁrst kind. Hence <(cid:48)(cid:48) does not violate the
order constraints of Γ(cid:48), and repeating this rewriting argument shows that there
is a greedy linear extension that the greedy algorithm will ﬁnd, contradicting
our assumption. This establishes our result in the case where we only have the
bounded-ia-width po-relation Γ(cid:48).

We now return to the general case where the bounded-width po-relation Γ is
not empty. In this case, we will again enumerate all possible ﬁnishing orders for
the classes of Γ(cid:48), of which there are constantly many, and apply an algorithm
for each ﬁnishing order π, with the algorithm succeeding iﬀ it succeeds for some
ﬁnishing order.

We ﬁrst observe that if there is a way to achieve L as a possible world of
Γ ∪ Γ(cid:48) for a ﬁnishing order π, then there is one where the subsequence of the
tuples that are matched to Γ(cid:48) are matched following the greedy strategy as we
presented before. This is simply because L must then be an interleaving of a
possible world of Γ and a possible world of Γ(cid:48), and a match for the possible
world of Γ(cid:48) can be found as a greedy match, by what was shown above. So
it suﬃces to assume that the tuples matched to Γ(cid:48) are matched following the
greedy algorithm that we previously described.

Second, we observe the following: for any preﬁx L(cid:48) of L and order ideal Γ(cid:48)(cid:48)
of Γ, if we realize L(cid:48) by matching exactly the tuples of Γ(cid:48)(cid:48) in Γ, and by matching
the other tuples to Γ(cid:48) following the greedy algorithm, then the matched tuples
in Γ(cid:48) are entirely determined (up to replacing tuples in a class by other tuples
with the same value). This is because, while there may be multiple ways to
match parts of L(cid:48) to Γ(cid:48)(cid:48) in a way that leaves a diﬀerent sequence of tuples to be
matched to Γ(cid:48), all these ways make us match the same bag of tuples to Γ(cid:48); now
the state of Γ(cid:48) after matching a bag of tuples following the greedy algorithm (for
a ﬁxed ﬁnishing order) is the same, no matter the order in which these tuples
are matched, assuming that the match does not fail.

This justiﬁes that we can solve the problem with a dynamic algorithm
again. The state contains the position m in each chain of Γ, and a position
i in the candidate possible world. As in the proof of Lemma 21, we ﬁlter the
conﬁgurations so that they are sane with respect to the order constraints between
the chains of Γ. For each state, we will store a Boolean value indicating whether
the preﬁx of length i of L can be realized by Γ ∪ Γ(cid:48) such that the tuples of Γ

31

that are matched is the order ideal s(m) described by m, and such that the
other tuples of the preﬁx are matched to Γ(cid:48) following the greedy algorithm with
ﬁnishing order π. By our second remark above, when the Boolean is true, the
state of Γ(cid:48) is uniquely determined, and we also store it as part of the state (it is
polynomial) so that we do not have to recompute it each time.

From each state we can make progress by consuming the next tuple from the
candidate possible world, increasing the length of the preﬁx, and reaching one
of the following states: either match the tuple to a chain of Γ, in which case
we make progress in one chain and the consumed tuples in Γ(cid:48) remain the same;
or make progress in Γ(cid:48), in which case we look at the previous state of Γ(cid:48) that
was stored and consume a tuple from Γ(cid:48) following the greedy algorithm: more
speciﬁcally, we ﬁnd an unused tuple with the right label which is in the open
class that appears ﬁrst in the ﬁnishing order, if the class is now exhausted we
verify that it was supposed to be the next one according to the ﬁnishing order,
and we update the open, exhausted and blocked status of the classes.

Applying the dynamic algorithm allows us to conclude whether L can be
realized by matching all tuples of Γ, and matching tuples in Γ(cid:48) following the
greedy algorithm with ﬁnishing order π (and checking cardinality suﬃces to
ensure that we have matched all tuples of Γ(cid:48)). If the answer of the dynamic
algorithm is YES, then it is clear that, following the path from the initial to
the ﬁnal state found by the dynamic algorithm, we can realize L. Conversely, if
L can be realized, then by our preliminary remark it can be realized in a way
that matches tuples in Γ(cid:48) following the greedy algorithm for some ﬁnishing order.
Now, for that ﬁnishing order, the path of the dynamic algorithm that matches
tuples to Γ or to Γ(cid:48) following that match will answer YES.

Disallowing product is severe, but we can still integrate sources by taking
the union of their tuples, selecting subsets, and modifying tuple values with
projection. In fact, allowing product makes POSS intractable when allowing both
unordered and totally ordered inputs.

Theorem 31. There is a PosRALEX query and a PosRADIR query for which the
POSS problem is NP-complete even when the input po-database is restricted to
consist only of one totally ordered and one unordered po-relation.

Proof. The proof is by adapting the proof of Theorem 22. The argument is
exactly the same, except that we take relation S to be unordered rather than
totally ordered. Intuitively, in Figure 4, this means that we drop the vertical
edges in the grid. The proof adapts, because it only used the fact that id (cid:48)
j < id (cid:48)
k
for j < k within a row-i; we never used the comparability relations across
rows.

6. Tractable Cases for Accumulation Queries

We next study POSS and CERT in presence of accumulation. Recall that in
the general case, POSS is NP-hard and CERT is coNP-hard, so we study tractable
cases in this section.

32

6.1. Cancellative Accumulation

We ﬁrst study the case where accumulation is performed in a cancellative
monoid (recall Deﬁnition 11). This large class of accumulation functions includes
the top-k operator (deﬁned above Example 16) and both operators in Example 13.
We design an eﬃcient algorithm for certainty in this case.

Theorem 32. CERT is in PTIME for any ﬁxed PosRAacc query that performs
accumulation in a cancellative monoid.

To prove this result, we deﬁne a notion of possible ranks for pairs of incompa-
rable elements, and deﬁne a safe swaps property, intuitively designed to ensure
that we have only one possible world.

Deﬁnition 33. Let P = (ID, <) be a poset. For x ∈ ID, we call Ax := {y ∈
ID | y < x} the ancestors of x and call Dx := {y ∈ ID | x < y} the descendants
of x.

Now, given two incomparable elements x and y in ID, we deﬁne the possible
ranks prP (x, y) as the interval [a + 1, |ID| − d], where a := |Ax ∪ Ay| and
d := |Dx ∪ Dy|.

Let (M, ⊕, ε) be a monoid and let h : D × N → M be an accumulation map.
Let Γ be a po-relation with underlying poset P . We say that Γ has the safe swaps
property with respect to ⊕ and h if the following holds: for any pair x (cid:54)= y of
incomparable identiﬁers of Γ, for any pair p, p + 1 in prP (x, y), we have

h(T (x), p) ⊕ h(T (y), p + 1) = h(T (y), p) ⊕ h(T (x), p + 1).

We ﬁrst show the following soundness result for possible ranks.

Lemma 34. For any poset P = (ID, <) and incomparable elements x, y ∈ ID,
for any p (cid:54)= q ∈ prP (x, y), we can compute in PTIME a linear extension <(cid:48) of P
in which element x is enumerated at position p, and element y is enumerated at
position q.

Proof. We write a := |Ax ∪ Ay| and d := |Dx ∪ Dy|. We will build the desired
linear extension <(cid:48) by enumerating all elements of Ax ∪ Ay in any order at the
beginning, and enumerating all elements of Dx ∪ Dy at the end: this can be
done without enumerating either x or y because x and y are incomparable.

Let p(cid:48) := p − a, and q(cid:48) := q − a; it follows from the deﬁnition of prP (x, y)

that 1 (cid:54) p(cid:48), q(cid:48) (cid:54) |ID| − d − a, and clearly p(cid:48) (cid:54)= q(cid:48).

Now, all elements that are not enumerated by <(cid:48) are either x, y, or incompa-
rable to both x and y. Consider any linear extension <(cid:48)(cid:48) of these unenumerated
elements except x and y; it has length |ID| − d − a − 2. Now, as p(cid:48) (cid:54)= q(cid:48), if
p(cid:48) < q(cid:48), then we can enumerate p(cid:48) − 1 of these elements, enumerate x, enumerate
q(cid:48) − p(cid:48) − 1 of these elements, enumerate y, and enumerate the remaining elements,
following <(cid:48)(cid:48). We proceed similarly, reversing the roles of x and y, if q(cid:48) < p(cid:48). We
have constructed <(cid:48) in PTIME and it clearly has the required properties.

We can then show that the safe swaps criterion is tractable to verify.

33

Lemma 35. For any ﬁxed (PTIME-evaluable) accumulation operator accumh,⊕
we can determine in PTIME, given a po-relation Γ, whether Γ has safe swaps
with respect to ⊕ and h.

Proof. Consider each pair (id 1, id 2) of elements of Γ and check in PTIME whether
they are incomparable. If this is the case, compute in PTIME prΓ(id 1, id 2) and
for each pair p, p+1 of consecutive integers, compute h(T (id 1), p)⊕h(T (id 2), p+1)
and h(T (id 2), p) ⊕ h(T (id 1), p + 1) in PTIME (this uses PTIME-evaluability of
the accumulation operator), and check whether they are equal.

We last show the following lemma, from which we will easily be able to prove

Theorem 32.

Lemma 36. For any (PTIME-evaluable) accumulation operator accumh,⊕ on a
cancellative monoid (M, ⊕, ε), for any po-relation Γ, we have |accumh,⊕(Γ)| = 1
iﬀ Γ has safe swaps with respect to ⊕ and h.

Proof. For the forward direction, assume that Γ does not have the safe swaps
property. Hence, there exist two incomparable identiﬁers id 1 and id 2 in Γ and a
pair of consecutive integers p, p + 1 in prΓ(id 1, id 2) such that:

h(T (id 1), p) ⊕ h(T (id 2), p + 1) (cid:54)= h(T (id 2), p) ⊕ h(T (id 1), p + 1)

(1)

We use Lemma 34 to compute two possible worlds L and L(cid:48) of Γ, where id 1
and id 2 occur respectively at positions p and p + 1 in L, and at positions p + 1
and p respectively in L(cid:48): from the proof of Lemma 34 it is clear that we can
ensure that L and L(cid:48) are otherwise identical. As accumulation is associative,
we know that accumh,⊕(Γ) = v ⊕ h(T (id 1), p) ⊕ h(T (id 2), p + 1) ⊕ v(cid:48), where
v is the result of accumulation on the tuples in L before id 1, and v(cid:48) is the
result of accumulation on the tuples in L after id 2. Likewise, accumh,⊕(Γ) =
v ⊕ h(T (id 2), p) ⊕ h(T (id 1), p + 1) ⊕ v(cid:48). We then use cancellativity of M to
deduce that these two values are diﬀerent thanks to Equation (1). Hence, L
and L(cid:48) are possible worlds of Γ that yield diﬀerent accumulation results, so we
conclude that |accumh,⊕(Γ)| > 1.

For the backward direction, assume that Γ has the safe swaps property.
Assume by way of contradiction that there are two possible worlds L1, L2 ∈ pw (Γ)
such that w1 := accumh,⊕(L1) and w2 := accumh,⊕(L2) are diﬀerent. Take L1
and L2 to have the longest possible common preﬁx, i.e., the ﬁrst position i such
that L1 and L2 enumerate a diﬀerent identiﬁer at position i is as large as possible.
Let 0 (cid:54) i0 < |Γ| be the length of the common preﬁx. Let Γ(cid:48) be the result of
removing from Γ the identiﬁers enumerated in the common preﬁx of L1 and L2,
and let L(cid:48)
2 be L1 and L2 without their common preﬁx. Let id 1 (cid:54)= id 2 be
the ﬁrst identiﬁers enumerated by L(cid:48)
1 and L(cid:48)
2; it is immediate that id 1 and id 2
are roots of the underlying poset of Γ(cid:48), that is, no element of Γ(cid:48) is less than them.
Further, it is clear that the result w(cid:48)
2 (but
oﬀsetting all ranks by i0), and the result w(cid:48)
2 of performing accumulation over L(cid:48)
1
(also oﬀsetting all ranks by i0), are diﬀerent. Indeed, by the contrapositive of

1 of performing accumulation over L(cid:48)

1 and L(cid:48)

34

1 and w(cid:48)
cancellativity, combining w(cid:48)
preﬁx leads to the diﬀerent accumulation results w1 and w2.

2 with the accumulation result of the common

Our goal is to construct a possible world L(cid:48)

2. If we can build such a possible world L(cid:48)

3 ∈ pw (Γ(cid:48)) which starts by
enumerating id 1 but ensures that the result of accumulation on L(cid:48)
3 (again
oﬀsetting all ranks by i0) is w(cid:48)
3, then
combining it with the common preﬁx will give a possible world L3 of Γ such
that the result of accumulation on L3 is w2 (cid:54)= w1, yet L1 and L3 have a common
preﬁx of length > i0, contradicting minimality. Hence, it suﬃces to show how to
construct such a possible world L(cid:48)
3.
As id 1 is an identiﬁer of Γ(cid:48), there must be a position where L(cid:48)

2 enumerates id 1,
and all identiﬁers before id 1 in L(cid:48)
2 cannot be descendants of id 1: as id 1 is a root
of Γ(cid:48), these identiﬁers must be incomparable to id 1. Write the sequence of these
identiﬁers in L(cid:48)
2 be the sequence following
id 1, so that L(cid:48)
2 . We now consider the
following sequence of list relations, which are clearly possible worlds of Γ(cid:48), where
we intuitively move id 1 to the beginning of the list via successive swaps:

2 as L(cid:48)(cid:48)
2 is the concatenation of L(cid:48)(cid:48)

2 , id 1, and L(cid:48)(cid:48)(cid:48)

m, and let L(cid:48)(cid:48)(cid:48)

1, . . . , id (cid:48)

2 = id (cid:48)

id (cid:48)

1 . . . id (cid:48)
id (cid:48)

m−2 id (cid:48)

m−1 id (cid:48)

1 . . . id (cid:48)
id (cid:48)

m−2 id (cid:48)
1 . . . id (cid:48)

m L(cid:48)(cid:48)(cid:48)
2 ,

m id 1 L(cid:48)(cid:48)(cid:48)
2 ,
m−1 id 1 id (cid:48)
m L(cid:48)(cid:48)(cid:48)
2 ,
m−1 id (cid:48)
m−2 id 1 id (cid:48)
...
2 id 1 id (cid:48)
1 id 1 id (cid:48)
id 1 id (cid:48)

3 . . . id (cid:48)
2 id (cid:48)
1 id (cid:48)

1 id (cid:48)
id (cid:48)

id (cid:48)

m−2 id (cid:48)

m−1 id (cid:48)

m−2 id (cid:48)

3 . . . id (cid:48)
2 id (cid:48)

3 . . . id (cid:48)

m−2 id (cid:48)

m L(cid:48)(cid:48)(cid:48)
2 ,
m−1 id (cid:48)
m L(cid:48)(cid:48)(cid:48)
2 ,
m−1 id (cid:48)
m L(cid:48)(cid:48)(cid:48)
2 .

jid 1 and the second contains id 1id (cid:48)

We can see that any consecutive pair in this list achieves the same accumula-
tion result. To do so, consider any pair of consecutive lists in this sequence, and
observe that the two lists only diﬀer at two successive identiﬁers, i.e., the ﬁrst
list contains id (cid:48)
j for some 1 (cid:54) j (cid:54) m. Thus, it
suﬃces to show that the accumulation result for id (cid:48)
jid 1 and id 1id (cid:48)
j is the same,
and this is exactly what the safe swaps property for id 1 and id (cid:48)
j says, as it is
easily checked that j, j +1 ∈ prΓ(cid:48)(id (cid:48)
j, id 1).
Now, the ﬁrst list relation above is L(cid:48)
2, and the last list relation above starts
by id 1, so we have built our desired L(cid:48)
3. This establishes the second direction of
the proof and concludes.

j, id 1), so that j +i0, j +i0 +1 ∈ prΓ(id (cid:48)

We are now ready to prove Theorem 32.

Proof. Given the instance (D, v) of the CERT problem for the query Q with
accumulation operator accumh,⊕, we use Proposition 2 to build Γ := Q(D) in
PTIME. We then use Lemma 35 to test in PTIME whether Γ has safe swaps
with respect to ⊕ and h. If it does not, then, by Lemma 36, v cannot be certain,
so (D, v) is not a positive instance of CERT. If it does, then, by Lemma 36, Q(D)

35

has only one possible world, so we can compute an arbitrary linear extension
of Γ, obtain one possible world L ∈ pw (Γ), check whether accumh,⊕(L) = v, and
decide CERT accordingly.

We have shown Theorem 32 on PosRAacc queries. Note that this result
clearly implies that CERT is also tractable for PosRA queries, as we claimed
in Section 4: indeed, we can translate any PosRA query to a PosRAacc query
that uses a dummy accumulation operator in the concatenation monoid, and
hence the CERT problem for PosRA queries reduces to the CERT problem for
PosRAacc queries in this ﬁxed cancellative monoid. The same reasoning applied
to Theorem 22 implies that the POSS problem for PosRAacc is NP-hard even on
cancellative monoids, in contrast with Theorem 32.

6.2. Finite and Position-Invariant Accumulation

We have shown that CERT (but not POSS) is tractable on cancellative accumu-
lation operators. It is then natural to wonder whether a similar result holds when
assuming that accumulation is ﬁnite and position-invariant (recall Deﬁnition 11).
We will now show that these restrictions do not suﬃce to make POSS and CERT
tractable. However, we will show in Section 6.3 that they can ensure tractability
when we combine them with assumptions on the input po-relations.

We start by showing that POSS is intractable.

Theorem 37. There is a PosRAacc query with a ﬁnite and position-invariant
accumulation operator for which POSS is NP-hard even assuming that the input
po-database contains only totally ordered po-relations.

To prove this result, we deﬁne the following ﬁnite domains:

• D− ··= {s−, n−, e−} (the element names used here intuitively correspond

to the names used in the proof of Theorem 22);

• D+ ··= {s+, n+, e+};

• D± ··= D− (cid:116) D+ (cid:116) {l, r} (the additional elements stand for “left” and

“right”).

We deﬁne the following regular expression on D∗
satisﬁes it:

±, and call balanced a word that

e ··= l (s−s+|n−n+|e−e+)∗ r

We now deﬁne the following problem.

Deﬁnition 38. The balanced checking problem for a PosRA query Q asks,
given a po-database D of po-relations over D±, whether there is L ∈ pw (Q(D))
such that L is balanced, i.e., it has arity 1, its domain is D±, and L satisﬁes e
when seen as a word over D±.

We also introduce the following regular expression: e(cid:48) ··= l D∗

± r, which we
will use later to guarantee that there are only two possible worlds. We now show
that the balanced checking problem is intractable.

36

Lemma 39. There exists a PosRA query Qb over po-databases with domain
in D± such that the balanced checking problem for Qb is NP-hard, even when all
input po-relations are totally ordered. Further, Qb is such that, for any input
po-database D, all possible worlds of Qb(D) satisfy e(cid:48).

To prove this lemma, recall the deﬁnition of ∪CAT (Deﬁnition 5), and recall
from Lemma 6 that ∪CAT can be expressed by a PosRA query. We construct the
b(R, T ) ··= [l] ∪CAT ((R ∪ T ) ∪CAT [r]), i.e., the union of R and T , preceded
query Q(cid:48)
by l and followed by r.

For any word w ∈ D∗

+, we denote by L+

w the unary list relation deﬁned
by mapping each letter of w to the corresponding letter in D+, we deﬁne L−
w
analogously for D−, and we write Γ−
w for the totally ordered po-relation with
pw (Γ−
b can
be rephrased in terms of the possibility problem.

w}. We now claim that the balanced checking problem for Q(cid:48)

w) = {L−

Lemma 40. For any w ∈ D∗
L+
instance to the balanced checking problem for Q(cid:48)
b.

w ∈ pw (Γ) iﬀ the po-database D mapping R to Γ−

+ and unary po-relation Γ over D+, we have
w and T to Γ is a positive

Proof. For the forward direction, assume that w is indeed a possible world L
b(D). L(cid:48) starts with l.
of Γ and let us construct a balanced possible world L(cid:48) of Q(cid:48)
Then, L(cid:48) alternatively enumerates one tuple from Γ−
w (in their total order) and
one from Γ (taken in the order of the linear extension that yields L). Finally, L(cid:48)
ends with r. It is clear that L(cid:48) is balanced.

For the backward direction, observe that a balanced possible world of Q(cid:48)
b(D)
must start by l, ﬁnish by r, and, between the two, it must alternatively enumerate
tuples from Γ−
w in their total order and tuples from one of the possible worlds
L ∈ pw (Γ): it is clear that L then achieves w.

We now use Lemma 40 to prove Lemma 39.

Proof. By Theorem 22, there is a query Q0 in PosRA such that the POSS problem
for Q0 is NP-hard, even for totally ordered input relations. What is more, by
inspecting the construction in the proof of Theorem 22, we can observe that
the output arity of Q0 is 1, and that the input relations can be assumed to
indeed, the input po-relation S deﬁned as [(cid:54)3m − 1] uses
have domain D+:
labels that are irrelevant (they are projected away), and the input po-relation
S(cid:48) uses only labels from {s, n, e}, so we can rename them to {s+, n+, e+}. We
now deﬁne the PosRA query Qb: its input relations are those of Q0 plus a fresh
relation name R, and it maps any po-relation Γ(cid:48) for R and input po-database D
b(Γ(cid:48), Q0(D)). By deﬁnition of Q(cid:48)
for Q0 to Q(cid:48)
b, our query Qb clearly satisﬁes the
additional condition that all possible worlds satisfy e(cid:48).

We reduce the POSS problem for Q0 to the balanced checking problem for
Qb in PTIME. More speciﬁcally, we claim that (D, L) is a positive instance
to POSS for Q0 iﬀ D(cid:48) is a positive instance to the balanced checking problem
for Qb, where D(cid:48) is obtained from D by adding the totally ordered relation Γ−
w
to interpret the fresh name R, with w the word on D+ achieved by L. But this
is exactly what Lemma 40 shows, for Γ := Q0(D). This concludes the reduction,

37

so we have shown that the balanced checking problem for Qb is NP-hard, even
assuming that the input po-database (here, D(cid:48)) contains only totally ordered
po-relations.

To prove our hardness result for POSS (Theorem 37), we will now reduce the
balanced checking problem to POSS, using an accumulation operator to do the
job. We will further ensure that there are at most two possible results, which will
be useful for CERT later. To do this, we need to introduce some new concepts.
We deﬁne a deterministic complete ﬁnite automaton A as follows, where all
omitted transitions go to a sink state q⊥ not shown in the picture. It is clear
that A recognizes the language of the regular expression e.

qs

qn

qe

s−

n+

n−

e+

start

qi

s+

l

q

e−

r

qf

We let S be the state space of A, and use it to deﬁne the transition monoid
of A, which is a ﬁnite monoid (so we are indeed performing ﬁnite accumulation).
Let FS be the ﬁnite set of total functions from S to S, and consider the
monoid deﬁned on FS with the identity function id as the neutral element, and
with function composition ◦ as the (associative) binary operation. We deﬁne
inductively a mapping h from D∗
± to FS as follows, which can be understood as
a homomorphism from the free monoid D∗

± to the transition monoid of A:

• For ε the empty word, h(ε) is the identity function id.

• For a ∈ D±, h(a) is the transition table for symbol a for the automaton A,
i.e., the function that maps each state q ∈ S to the one state q(cid:48) such that
there is an a-labeled transition from q to q(cid:48); the fact that A is deterministic
and complete is what ensures that this is well-deﬁned.

• For w ∈ D∗

± and w (cid:54)= ε, writing w = aw(cid:48) with a ∈ D±, we deﬁne

h(w) ··= h(w(cid:48)) ◦ h(a).

It is easy to show inductively that, for any w ∈ D∗

±, and for any q ∈ S, the
state (h(w))(q) is the one that we reach in A when reading the word w from the
state q. We will identify two special elements of FS:

• f0, the function mapping every state of S to the sink state q⊥;

• f1, the function mapping the initial state qi to the ﬁnal state qf , and

mapping every other state in S\{qi} to q⊥.

Recall the deﬁnition of the regular expression e(cid:48) earlier. We claim the

following property on the automaton A.

38

Lemma 41. For any word w ∈ D∗
balanced (i.e., satisﬁes e) and h(w) = f0 otherwise.

± that matches e(cid:48), we have h(w) = f1 if w is

Proof. By the deﬁnition of A, for any state q (cid:54)= qi, we have (h(l))(q) = q⊥, so
that, as q⊥ is a sink state, we have (h(w))(q) = q⊥ for any w that satisﬁes e(cid:48).
Further, by deﬁnition of A, for any state q, we have (h(r))(q) ∈ {q⊥, qf }, so that,
for any state q and w that satisﬁes e(cid:48), we have (h(w))(q) ∈ {q⊥, qf }. This implies
that, for any word w that satisﬁes e(cid:48), we have h(w) ∈ {f0, f1}.

Now, as we know that A recognizes the language of e, we have the desired
property, because, for any w satisfying e(cid:48), h(w)(qi) is qf or not depending on
whether w satisﬁes e or not, so h(w) is f1 or f0 depending on whether w satisﬁes
e or not.

This ensures that we have only two possible accumulation results, and that
they accurately test whether the input word is balanced. We can now prove our
hardness result for POSS, Theorem 37.

Proof. Consider the query Qb whose existence is guaranteed by Lemma 39, and
remember that all its possible worlds on any input po-database must satisfy e(cid:48).
Construct now the query Qa ··= accumh,◦(Qb), using the mapping h that we
deﬁned above, seen as a position-invariant accumulation map. We conclude the
proof by showing that POSS is NP-hard for Qa, even when the input po-database
consists only of totally ordered po-relations. To see that this is the case, we
reduce the balanced checking problem for Qb to POSS for Qa with the trivial
reduction: we claim that for any po-database D, there is a balanced possible
world in Qb(D) iﬀ f1 ∈ Qa(D), which is proved by Lemma 41. Hence, Qb(D)
is balanced iﬀ (D, f1) is a positive instance of POSS for Qa. This concludes the
reduction, and establishes our hardness result.

We last show an analogue of Theorem 37 for CERT as well.

Theorem 42. There is a PosRAacc query with a ﬁnite and position-invariant
accumulation operator for which CERT is coNP-hard even assuming that the input
po-database contains only totally ordered po-relations.

Proof. Consider the query Qa from Theorem 37. We show a PTIME reduction
from the NP-hard problem of POSS for Qa (for totally ordered input po-databases)
to the negation of the CERT problem for Qa (for input po-databases of the same
kind).

Consider an instance of POSS for Qa consisting of an input po-database D
and candidate result v ∈ M. Recall that the query Qa uses accumulation, so it
is of the form accumh,⊕(Q(cid:48)). Evaluate Γ := Q(cid:48)(D) in PTIME by Proposition 2,
and compute in PTIME an arbitrary possible world L(cid:48) ∈ pw (Γ) by picking an
arbitrary linear extension of Γ. Let v(cid:48) = accumh,⊕(L(cid:48)). If v = v(cid:48) then (D, v) is
a positive instance for POSS for Qa. Otherwise, we have v (cid:54)= v(cid:48). Now, solve the
CERT problem for Qa on the input (D, v(cid:48)). If the answer is YES, then (D, v) is a
negative instance for POSS for Qa. Otherwise, there must exist a possible world
L(cid:48)(cid:48) in pw (Γ) with v(cid:48)(cid:48) = accumh,⊕(L(cid:48)(cid:48)) and v(cid:48)(cid:48) (cid:54)= v(cid:48). However, |pw (Qa(D))| (cid:54) 2

39

and thus, as v (cid:54)= v(cid:48) and v(cid:48) (cid:54)= v(cid:48)(cid:48), we must have v = v(cid:48)(cid:48). So (D, v) is a positive
instance for POSS for Qa. This ﬁnishes the reduction and shows that CERT for
Qa is coNP-hard.

6.3. Revisiting Section 5

We now know that ﬁniteness and position-invariance do not suﬃce to ensure
the tractability of POSS and CERT. In this section, we will show that they can
nevertheless be used to obtain tractability when combined with assumptions
on the input po-database, as we did in Section 5. Speciﬁcally, in the rest of
this section, we will always assume that accumulation is ﬁnite, and we will
sometimes assume that it is position-invariant. We call PosRAacc
LEX and PosRAacc
no×
the extension of PosRALEX and PosRAno× with accumulation.

We can ﬁrst generalize our width-based tractability result on PosRALEX
LEX queries with ﬁnite accumulation.

(Theorem 20) to PosRAacc

Theorem 43. For any PosRAacc
POSS and CERT are in PTIME on po-databases of bounded width.

LEX query with a ﬁnite accumulation operator,

To show this, as in Section 5, we can use Proposition 2 and Lemma 4 to
argue that it suﬃces to show the following analogue of Lemma 21. Note that
we compute exactly the (ﬁnite) set of all possible accumulation results, so this
allows us to answer both POSS and CERT.

Lemma 44. For any constant k ∈ N, and ﬁnite accumulation operator accumh,⊕,
we can compute in PTIME, for any input po-relation Γ with width (cid:54) k, the set
accumh,⊕(Γ).

Proof. We extend the proof of Lemma 21 and reuse its notation. For every sane
vector m, we now write t(m) ··= accumh,⊕(T (s(m))), where T (s(m)) denotes the
sub-po-relation of Γ with the tuples of the order ideal s(m). In other words, t(m)
is the set of possible accumulation results for the sub-po-relation on the order
ideal s(m): as the accumulation monoid is ﬁxed on ﬁnite, the set has constant size.
It is immediate that t(0, . . . , 0) = {ε}, i.e., the only possible result is the neutral
element of the accumulation monoid, and that t(n1, . . . , nk(cid:48)) = accumh,⊕(Γ) is
our desired answer. Recall that ei denotes the vector consisting of n − 1 zeros
and a 1 at position i, for 1 (cid:54) i (cid:54) k(cid:48), and that “−” denotes the component-wise
diﬀerence of vectors. We now observe that, for any sane vector m, we have

t(m) =

(cid:91)

1(cid:54)i(cid:54)k(cid:48)
mi>0

(cid:40)

(cid:32)

v ⊕ h

T (Λi[mi]),

(cid:88)

mi(cid:48)

i(cid:48)

(cid:33) (cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:41)

v ∈ t(m − ei)

,

(2)

where we set t(m) := ∅ whenever m is not sane. The correctness of Equation (2)
is shown as in the proof of Lemma 21: any linear extension of s(m) must end
with one of the maximal elements of s(m), which must be one of the Λi[mi]
for 1 (cid:54) i (cid:54) m such that mi > 0, and the preceding elements must be a linear
extension of the ideal where this element was removed (which must be an ideal,

40

i.e., m − ei must be sane). Conversely, any sequence constructed in this fashion is
indeed a linear extension. Thus, the possible accumulation results are computed
according to this characterization of the linear extensions. We store with each
possible accumulation result a witnessing totally ordered relation from which
it can be computed in PTIME, namely, the linear extension preﬁx considered
in the previous reasoning, so that we can use the PTIME-evaluability of the
underlying monoid to ensure that all computations of accumulation results can
be performed in PTIME.

As in the proof of Lemma 21, Equation (2) allows us to compute t(n1, . . . , nk(cid:48))
in PTIME by a dynamic algorithm, which is the set accumh,⊕(Γ) that we wished
to compute. This concludes the proof.

Second, we can adapt the tractability result for queries without product

(Theorem 24) when accumulation is ﬁnite and position-invariant.

Theorem 45. For any PosRAacc
no× query with a ﬁnite and position-invariant
accumulation operator, POSS and CERT are in PTIME on po-databases whose
relations have either bounded width or bounded ia-width.

To do so, again, it suﬃces to show the following analogue of Lemma 30 for

ﬁnite and position-invariant accumulation.

Lemma 46. For any constant k ∈ N, and ﬁnite and position-invariant ac-
cumulation operator accumh,⊕, we can compute in PTIME, for any input po-
relation Γ with width (cid:54) k and input po-relation Γ(cid:48) with ia-width (cid:54) k, the set
accumh,⊕(Γ ∪ Γ(cid:48)).

Proof. We use Dilworth’s theorem to compute in PTIME a chain partition of Γ,
and we use Proposition 27 to compute in PTIME an ia-partition A1 (cid:116) · · · (cid:116) An
of minimal cardinality of Γ(cid:48), with n (cid:54) k.

We then apply a dynamic algorithm whose state consists of the following:

• for each chain in the partition of Γ, the position in the chain;

• for each class A of the ia-partition of Γ(cid:48), for each element m of the monoid,
the number of identiﬁers id of A such that h(T (id ), 1) = m that have
already been used.

There are polynomially many possible states; for the second bullet point,
this uses the fact that the monoid is ﬁnite, so its size is constant because it is
ﬁxed as part of the query. Also note that we use the rank-invariance of h in the
second bullet point.

The possible accumulation results for each of the possible states can then
be computed by a dynamic algorithm. At each state, we can decide to make
progress either in a chain of Γ (ensuring that the element that we enumerate has
the right image by h, and that the new vector of positions of the chains is still
sane, i.e., yields an order ideal of Γ) or in a class of Γ(cid:48) (ensuring that this class
is open, i.e., it has no ancestors in Γ(cid:48) that were not enumerated yet, and that it
contains an element which has the right image by h). This algorithm is correct

41

because there is a bijection between the ideals of Γ ∪ Γ(cid:48) and the pairs of ideals
of Γ and of ideals of Γ(cid:48). Now, the dynamic algorithm considers all ideals of Γ as
in the proof of Lemma 44, and it clearly considers all possible ideals of Γ(cid:48) except
that we identify ideals that only diﬀer by elements in the same class which are
mapped to the same value by h (but this choice does not matter because the
class is an antichain and these elements are indistinguishable outside the class).
As in the proof of Lemma 44, we can ensure that all accumulation operations
are in PTIME, using PTIME-evaluability of the accumulation operator, up to the
technicality of storing at each state, for each of the possible accumulation results,
a witnessing totally ordered relation from which to compute it in PTIME.

We note that the ﬁniteness assumption is important, as the previous result
does not hold otherwise. Speciﬁcally, there is an accumulation operator that is
position-invariant but not ﬁnite, for which POSS is NP-hard even on unordered
po-relations and with a trivial query.

Theorem 47. There is a position-invariant accumulation operator accumh,⊕
no× query Q ··= accumh,⊕(R), even on
such that POSS is NP-hard for the PosRAacc
input po-databases where R is interpreted as an unordered relation.

Proof. We consider the NP-hard partition problem: given a multiset S of integers,
decide whether it can be partitioned into two sets S1 and S2 that have the same
sum. Let us reduce an instance of the partition problem with this restriction to
an instance of the POSS problem, in PTIME.

Let M be the monoid generated by the functions f : x (cid:55)→ −x and ga :
x (cid:55)→ x + a for a ∈ Z under the function composition operation. We have
ga ◦ gb = ga+b for all a, b ∈ N, f ◦ f = id , and f ◦ ga = g−a ◦ f , so we actually
have D = {ga | a ∈ Z} (cid:116) {f ◦ ga | a ∈ Z}. Further, M is actually a group, as we
can deﬁne (ga)−1 = g−a and (f ◦ ga)−1 = f ◦ ga for all a ∈ Z.

We ﬁx D = N (cid:116) {−1}. We deﬁne the position-invariant accumulation map
h as mapping −1 to f and a ∈ N to ga. We encode the partition problem
instance S in PTIME to an unordered po-relation ΓS with a single attribute,
that contains one tuple with value s for each s ∈ S, plus one tuple with value −1.
Consider the POSS instance for the query accumh,+(Γ), on the po-database D
where the relation name R is interpreted as the po-relation ΓS, and for the
candidate result v := f ∈ M.

We claim that this POSS instance is positive iﬀ the partition problem has a
solution. Indeed, if S has a partition, let s = (cid:80)
i. Consider the
total order on ΓS which enumerates the tuples corresponding to the elements
of S1, then the tuple −1, then the tuples corresponding to the elements of S2.
The result of accumulation is then gs ◦ f ◦ gs, which is f .

i = (cid:80)

i∈S1

i∈S2

Conversely, assume that the POSS problem has a solution. Consider a witness
total order of ΓS; it must a (possibly empty) sequence of tuples corresponding
to a subset S1 of S, then the tuple −1, then a (possibly empty) sequence
corresponding to S2 ⊆ S. Let s1 and s2 respectively be the sums of these subsets
of S. The result of accumulation is then gs1 ◦ f ◦ gs2, which simpliﬁes to gs1−s2 ◦ f .

42

Hence, we have s1 = s2, so that S1 and S2 are a partition witnessing that S is a
positive instance of the partition problem.

As the reduction is in PTIME, this concludes the proof.

Finally, as explained above Example 16, we can use accumulation capture
position-based selection (top-k, select-at-k) and tuple-level comparison (whether
the ﬁrst occurrence of a tuple precedes all occurrences of another tuple) for
PosRA queries. Using a direct construction for these problems, we can show
that they are tractable.

Proposition 48. For any PosRA query Q, the following problems are in
PTIME.

• select-at-k: Given a po-database D, tuple value t, and position k ∈ N,
determine whether it is possible/certain that Q(D) has value t at position k;

• top-k: For any ﬁxed k ∈ N, given a po-database D and list relation L of
length k, determine whether it is possible/certain that the top-k values in
Q(D) are exactly L;

• tuple-level comparison: Given a po-database D and two tuple values t1
and t2, determine whether it is possible/certain that the ﬁrst occurrence
of t1 precedes all occurrences of t2.

Proof. To solve each problem, we ﬁrst compute the po-relation Γ ··= Q(D) in
PTIME by Proposition 2. We then address each problem in turn.

First, we show tractability for select-at-k. Considering the po-relation
Γ = (ID, T, <), we can compute in PTIME, for every element id ∈ ID, its
earliest index i−(id ), which is the number of ancestors of id by < plus one, and
its latest index i+(id ), which is the number of elements of Γ minus the number
of descendants of id . It is easily seen that for any element id ∈ ID, there is a
linear extension of Γ where id appears at position i−(id ) (by enumerating ﬁrst
exactly the ancestors of id ), or at position i+(id ) (by enumerating ﬁrst everything
except the descendants of id ), or in fact at any position of [i−(id ), i+(id )], the
interval of id (this is by enumerating ﬁrst the ancestors of id , and then as many
elements as needed that are incomparable to id , along a linear extension of these
elements). Hence, select-at-k possibility for tuple t and position k can be decided
by checking, for each id ∈ ID such that T (id ) = t, whether k ∈ [i−(id ), i+(id )],
and answering YES iﬀ we can ﬁnd such an id . For select-at-k certainty, we
answer NO iﬀ we can ﬁnd an id ∈ ID such that k ∈ [i−(id ), i+(id )] but we have
T (id ) (cid:54)= t.

Second, we show tractability for top-k. Considering the po-relation Γ =
(ID, T, <), we consider each sequence of k elements of Γ, of which there are at
most |ID|k, i.e., polynomially many, as k is ﬁxed. To solve possibility for top-k,
we consider each such sequence id 1, . . . , id k such that (T (id 1), . . . , T (id k)) is
equal to the candidate list relation L, and we check if this sequence is indeed a
preﬁx of a linear extension of Γ, i.e., whether, for each i ∈ {1, . . . , k}, for any

43

id ∈ ID such that id < id i, if id i ∈ {id 1, . . . , id i−1}, which we can do in PTIME.
We answer YES iﬀ we can ﬁnd such a sequence.

For certainty, we consider each sequence id 1, . . . , id k such that we have
(T (id 1), . . . , T (id k)) (cid:54)= L, and we check whether it is a preﬁx of a linear extension
in the same way: we answer NO iﬀ we can ﬁnd such a sequence.

Third, we show tractability for tuple-level comparison. We are given the
two tuple values t1 and t2, and we assume that both are in the image of T , as
the tuple-level comparison problem is vacuous otherwise.

For possibility, given the two tuple values t1 and t2, we consider each id ∈ ID
such that T (id ) = t1, and for each of them, we construct Γid ··= (ID, T, <id )
where <id is the transitive closure of < ∪ {(id , id (cid:48)) | id (cid:48) ∈ ID, T (id (cid:48)) = t2}. We
answer YES iﬀ one of the Γid is indeed a po-relation, i.e., if <id as deﬁned
does not contain a cycle. This is correct, because it is possible that the ﬁrst
occurrence of t1 precedes all occurrences of t2 iﬀ there is some identiﬁer id with
tuple value t1 that precedes all identiﬁers with tuple value t2, i.e., iﬀ one of the
Γid has a linear extension.

For certainty, given t1 and t2, we answer the negation of possibility for t2
and t1. This is correct because certainty is false iﬀ there is a linear extension
of Γ where the ﬁrst occurrence of t1 does not precede all occurrences of t2, i.e.,
iﬀ there is a linear extension where the ﬁrst occurrence of t2 is not after an
occurrence of t1, i.e., iﬀ some linear extension is such that the ﬁrst occurrence
of t2 precedes all occurrences of t1, i.e., iﬀ possibility is true for t2 and t1.

7. Extensions

We consider two extensions to our model: group-by and duplicate elimination.

7.1. Group-By

First, we extend accumulation with a group-by operator, inspired by SQL.

Deﬁnition 49. Let (M, ⊕, ε) be a monoid and h : Dk × N>0 → M be an
accumulation map, and let A = A1, ..., An be a sequence of attributes: we call
accumGroupByh,⊕,A an accumulation operator with group-by. Letting L be
a list relation with compatible schema, we deﬁne accumGroupByh,⊕,A(L) as
an unordered relation that has, for each tuple value t ∈ ΠA(L), one tuple
(cid:104)t, vt(cid:105), where vt is accumh,⊕(σA1=t.A1∧···∧An=t.An (L)) with Π and σ on the list
relation L having the expected semantics. The result on a po-relation Γ is the
set of unordered relations {accumGroupByh,⊕,A(L) | L ∈ pw (Γ)}.

In other words, the operator “groups by” the values of A1, ..., An, and
performs accumulation within each group, forgetting the order across groups. As
for standard accumulation, we only allow group-by as an outermost operation,
calling PosRAaccGBy the language of PosRA queries followed by one accumulation
operator with group-by. Note that the set of possible results is generally not a
po-relation, because the underlying bag relation is not certain.

44

We next study the complexity of POSS and CERT for PosRAaccGBy queries.
Of course, whenever POSS and CERT are hard for some PosRAacc query Q on
some kind of input po-relations, then there is a corresponding PosRAaccGBy
query for which hardness also holds (with empty A). The main point of this
section is to show that the converse is not true: the addition of group-by increases
complexity. Speciﬁcally, we show that the POSS problem for PosRAaccGBy is hard
even on totally ordered po-relations and without the ×DIR operator. This result
contrasts with the tractability of POSS for PosRALEX queries (Theorem 20) and
for PosRAacc
LEX queries with ﬁnite accumulation (Theorem 43) on totally ordered
po-relations.

Theorem 50. There is a PosRAaccGBy query Q with ﬁnite and position-
invariant accumulation, not using ×DIR, such that POSS for Q is NP-hard even
on totally ordered po-relations.
Proof. Let Q be the query accumGroupBy⊕,h,{1}(Q(cid:48)), where we deﬁne

Q(cid:48) ··= Π3,4(σ.1=.2(R ×LEX (S1 ∪ S2 ∪ S3))).

In the accumulation operator, the accumulation map h maps each tuple t to its
second component. Further, we deﬁne the ﬁnite monoid M to be the syntactic
monoid [17] of the language deﬁned by the regular expression s(l+l−|l−l+)∗e,
where s (for “start”), l− and l+, and e (for “end”) are fresh values from D: this
monoid ensures that, for any non-empty word w over the alphabet {s, l−, l+, e}
that starts with s and ends with e, the word w evaluates to ε in M iﬀ w matches
this regular expression.

We reduce from the NP-hard 3-SAT problem: we are given a conjunction of
clauses C1, . . . , Cn, with each clause being a disjunction of three literals, namely,
a variable or negated variable among x1, . . . , xm, and we ask whether there is
a valuation of the variables such that the clause is true. We ﬁx an instance
of this problem. We assume without loss of generality that the instance has
been preprocessed to ensure that no clause contained two occurrences of the
same variable, i.e., we remove duplicate literals in clauses, and we remove any
clause that contains two occurrences of the same variable with diﬀerent polarities
(as the clause is then vacuous). We further assume that the instance has been
preprocessed to ensure that each clause contains exactly 3 variables: we do so by
introducing three fresh variables d1, d2, and d3, by adding all possible clauses
±d1 ∨ ±d2 ∨ ±d3 on these variables except ¬d1 ∨ ¬d2 ∨ ¬d3 (i.e., seven clauses),
and by padding the other clauses to three literals by adding distinct disjuncts
chosen from the ¬di. It is clear that this does not change the semantics of the
instance: any satisfying assignment of the original instance yields a satisfying
assignment of the rewritten instance by setting d1, d2, and d3 to true, and
conversely any satisfying assignment to the rewritten instance must set d1, d2,
and d3 to true (any other assignment will violate the clause where each di has
the polarity which is the opposite of its value in the assignment), so the padding
literals are never used to make a clause true.

We deﬁne the relation R to be [(cid:54)m + 3]. The totally ordered relations S1,

S2, and S3 consist of 3m + 2n tuple values deﬁned as follows.

45

• First, for the tuples with positions from 1 to m (the “opening gadget”):

– The ﬁrst component is 1 for all tuples in S1 and 0 for all tuples in S2

and S3 (so they do not join with R);

– The second component is i for the i-th tuple in S1 (and irrelevant for

tuples in S2 and S3);

– The third component is s for all these tuples.

The intuition for the opening gadget is that it ensures that accumulation in
each of the m groups will start with the start value s, used to disambiguate
the possible monoid values and ensure that there is exactly one correct
value.

• For the tuples with positions from m + 1 to 2m (the “variable choice”

gadget):

– The ﬁrst component is 2 for all tuples in S1 and S2 and 0 for all

tuples in S3 (so they do not join with R);

– The second component is i for the (m + i)-th tuple in S1 and in S2

(and irrelevant for S3);

– The third component is l− for all tuples in S1 and l+ for all tuples

in S2 (and irrelevant for S3).

The intuition for the variable choice gadget is that, for each group, we have
two incomparable elements, one labeled l− and one labeled l+. Hence, any
linear extension must choose to enumerate one after the other, committing
to a valuation of the variables in the 3-SAT instance; to achieve the
candidate possible world, the linear extension will then have to continue
enumerating the elements of this group in the correct order.

• For the tuples with positions from 2m + 1 to 2m + 2n (the “clause check”
gadget), for each 1 (cid:54) j (cid:54) n, letting j(cid:48) ··= 2n + j + 1, we describe tuples j(cid:48)
and j(cid:48) + 1 in S1, S2, S3:

– The ﬁrst component is j + 2;

– The second component carries values in {a, b, c}, where we write clause
Cj as ±xa ∨ ±xb ∨ ±xc. Speciﬁcally, the tuple j(cid:48) + 1 in relations S1,
S2, and S3 have values a, b, and c respectively; and the tuple j(cid:48) in
relations S1, S2, and S3 have values c, a, b respectively.

– The third component carries values in {l−, l+}. In relation S1, we give
value l+ to tuple j(cid:48) + 1 and value l− to tuple j(cid:48) if the ﬁrst variable
of Cj is positive, and we do the reverse if it is negative. We do the
same in relations S2 and S3 depending on the polarity of the second
and third variables of Cj, respectively.

46

The intuition for the clause check gadget is that, for each 1 (cid:54) j (cid:54) n,
the tuples at levels j(cid:48) and j(cid:48) + 1 check that clause Cj is satisﬁed by the
valuation chosen in the variable choice gadget. Speciﬁcally, if we consider
the order constraints on the two elements from the same group (i.e., second
component) which are implied by the order chosen for this variable in the
variable choice gadget, the construction ensures that these order constraints
plus the comparability relations of the chains imply a cycle (that is, an
impossibility) iﬀ the clause is violated by the chosen valuation.

• For the tuples with positions from 2m + 2n + 1 to 3m + 2n (the “closing
gadget”), the deﬁnition is like the opening gadget but replacing e by s,
namely:

– The ﬁrst component is n + 3 for all tuples in S1 and 0 for all tuples

in S2 and S3 (which again do not join with R);
– The second component is i for the i-th tuple in S1;
– The third component is e for all these tuples.

The intuition for the closing gadget is that it ensures that accumulation in
each group ends with value e.

We deﬁne the candidate possible world to consist of a list relation of n tuples;
the i-th tuple carries value i as its ﬁrst component (group identiﬁer) and the
acceptation value from the monoid M as its second component (accumulation
value). The reduction that we described is clearly in PTIME, so all that remains
is to show correctness of the reduction.

To do so, we ﬁrst describe the result of evaluating Γ ··= Q(cid:48)(R, S1, S2, S3) on the
relations described above. Intuitively, it is just like Π2,3(σ.2(cid:54)=“0”(S1 ∪ S2 ∪ S3)))),
but with the following additional comparability relations: all tuples in all chains
whose ﬁrst component carried a value i are less than all tuples in all chains whose
ﬁrst component carried a value j > i. In other words, we add comparability
relations across chains as we move from one “ﬁrst component” value to the
next. The point of this is that it forces us to enumerate the tuples of the chains
in a way that “synchronizes” across all chains whenever we change the ﬁrst
component value. Observe that, in keeping with Lemma 4, the width of Γ has a
constant bound, namely, 3.

Let us now show the correctness of the reduction. For the forward direction,
consider a valuation ν that satisﬁes the 3-SAT instance. Construct the linear
extension of Γ as follows.

• For the opening gadget, enumerate all tuples of S1 in the prescribed order.

Hence, the current accumulation result in all m groups is s.

• For the variable choice gadget, for all i, enumerate the i-th tuples of S1 and
S2 of the gadget in an order depending on ν(xi): if ν(xi) is 1, enumerate
ﬁrst the tuple of S1 and then the tuple of S2, and do the converse if
ν(xi) = 0. Hence, for all 1 (cid:54) i (cid:54) m, the current accumulation result in
group i is sl−l+ if ν(xi) is 1 and sl+l− otherwise.

47

• For the clause check gadget, we consider each clause in order, for 1 (cid:54) j (cid:54) n,
maintaining the property that, for each group 1 (cid:54) i (cid:54) n, the current
accumulation result in group i is of the form s(l−l+)∗ if ν(xi) = 1 and
s(l+l−)∗ otherwise.
Fix a clause Cj, let j(cid:48) ··= 2n + j + 1 as before, and study the tuples j(cid:48) and
j(cid:48) + 1 of S1, S2, S3. As Cj is satisﬁed under ν, let xd be the witnessing
literal (with d ∈ {a, b, c}), and let d(cid:48) be the index (in {1, 2, 3}) of variable d.
Assume that xd occurs positively; the argument is symmetric if it occurs
negatively. By deﬁnition, ν(xd) = 1, and by construction tuple j(cid:48) in
relation S1+(d(cid:48)+1 mod 3) carries value l− and it is in group d. Hence, we
can enumerate it and group d now carries a value of the form s(l−l+)∗l−.
Now, letting xe be the 1 + (d(cid:48) + 1 mod 3)-th variable of {xa, xb, xc}, the
two elements of group e (tuple j(cid:48) + 1 of S1+(d(cid:48)+1 mod 3) and tuple j(cid:48) of
S1+(d(cid:48)+1 mod 3)) both had all their predecessors enumerated; so we can
enumerate them in the order that we prefer to satisfy the condition on the
accumulation values; then we enumerate likewise the two elements in the
remaining group in the order that we prefer, and last we enumerate the
second element of group d; so we have satisﬁed the invariants.

• Last, for the closing gadget, we enumerate all tuples of S1 and we have

indeed obtained the desired accumulation result.

This concludes the proof of the forward direction.

For the backward direction, consider any linear extension of Γ. Thanks to
the order constraints of Γ, the linear extension must enumerate tuples in the
following order.

• First, all tuples of the opening gadget.

• Then, all tuples of the variable choice gadget. We use this to deﬁne a
valuation ν: for each variable xi, we set ν(xi) = 1 if the tuple of S1 in
group i was enumerated before the one in group S2, and we set ν(xi) = 0
otherwise.

• Then, for each 1 (cid:54) j (cid:54) n, in order, tuples 2n + j + 1 of S1, S2, S3.

Observe that, for each value of j, just before we enumerate these tuples, it
must be the case that the current accumulation value for every variable xi
is of the form s(l−l+)∗ if ν(xi) = 1, and s(l+l−)∗ otherwise. Indeed, ﬁxing
1 (cid:54) i (cid:54) n, assume the case where ν(xi) = 1 (the case where ν(xi) = 0 is
symmetric). In this case, the accumulation state for xi after the variable
choice gadget was sl−l+, and each pair of levels in the clause check gadget
made us enumerate either ε (variable xi did not occur in the clause) or one
of l−l+ or l+l− (variable xi occurred in the clause); as the 3-SAT instance
was preprocessed to ensure that each variable occurred only at most once
in each clause, this case enumeration is exhaustive. Hence, the only way
to obtain the correct accumulation result is to always enumerate l−l+, as

48

if we ever do the contrary the accumulation result can never satisfy the
regular expression that it should satisfy.

• Last, all tuples of the closing gadget.

What we have to show is that the valuation ν thus deﬁned indeed satisﬁes
the formula of the 3-SAT instance. Indeed, ﬁx 1 (cid:54) j (cid:54) n and consider clause Cj.
Let Si be the ﬁrst relation where the linear extension enumerated a tuple for the
clause check gadget of Cj, and let xd be its variable (where d is its group index).
If ν(xd) = 1, then the observation above implies that the label of the enumerated
element must be l−, as otherwise the accumulation result cannot be correct.
Hence, by construction, it means that variable xd must occur positively in Cj,
so xd witnesses that ν satisﬁes Cj. If ν(xd) = 0, the reasoning is symmetric.
This concludes the proof in the backwards direction, so we have established
correctness of the reduction, which concludes the proof.

By contrast, it is not hard to see that the CERT problem for PosRAaccGBy
reduces to CERT for the same query without group-by, so it is no harder than
the latter problem, and all CERT tractability results from Section 6 extend.

Theorem 51. Theorems 32, 43, and 45 extend to the PosRAaccGBy problem
when imposing the same restrictions on query operators, accumulation, and input
po-relations. Speciﬁcally:

• CERT is in PTIME for any ﬁxed PosRAaccGBy query that performs accu-

mulation in a cancellative monoid.

• For any PosRAaccGBy query not using the ×DIR operator and with a ﬁnite
accumulation operator, POSS and CERT are in PTIME on po-databases of
bounded width.

• For any PosRAaccGBy query not using any product operator and with a
ﬁnite and position-invariant accumulation operator, POSS and CERT are
in PTIME on po-databases whose relations have either bounded width or
bounded ia-width.

To prove this, we show the following auxiliary result.

Lemma 52. For any PosRAaccGBy query Q ··= accumGroupByh,⊕,P (Q(cid:48)) and
family D of po-databases, the CERT problem for Q on input po-databases from D
reduces in PTIME to the CERT problem for accumh,⊕(R) (where R is a relation
name), on the family D(cid:48) of po-databases mapping the name R to a subset of a
po-relation of {Q(cid:48)(D) | D ∈ D}.

Proof. To prove that, consider an instance of CERT for Q, deﬁned by an input po-
database D of D and candidate possible world L. We ﬁrst evaluate Γ(cid:48) ··= Q(cid:48)(D)
in PTIME. Now, for each tuple value t in ΠP (Γ(cid:48)), let Γt be the restriction of Γ(cid:48)
to the elements matching this value; note that the po-database mapping R to Γt
is indeed in the family D(cid:48). We solve CERT for accumh,⊕(R) on each R (cid:55)→ Γt in

49

PTIME with the candidate possible world obtained from L by extracting the
accumulation value for that group, and answer YES to the original CERT instance
iﬀ all these invocations answer YES. As this process is clearly in PTIME, it just
remains to show correctness of the reduction.

For the forward direction, assume that each of the invocations answers YES,
but the initial instance to CERT was negative. Consider two linear extensions
of Γ(cid:48) that achieve diﬀerent accumulation results and witness that the initial
instance was negative, and consider a group t where these accumulation results
for these two linear extensions diﬀer. Considering the restriction of these linear
extensions to that group, we obtain the two diﬀerent accumulation values for
that group, so that the CERT invocation for Γt should not have answered YES.
For the backward direction, assume that the invocation for tuple t does
not answer YES, then considering two witnessing linear extensions for that
invocation, and extending them two linear extensions of Γ(cid:48) by enumerating other
tuples in an indiﬀerent way, we obtain two diﬀerent accumulation results for Q
which diﬀer in their result for t. This concludes the proof.

This allows us to show Theorem 51.

Proof. We consider all tractability results of Section 6 in turn, and show that
they extend to PosRAaccGBy queries, under the same restrictions on operators,
accumulation, and input po-relations.

First, we consider the tractability of CERT for accumulation in a cancellative
monoid (Theorem 32). As this result holds for any input po-database, tractability
for PosRAaccGBy follows directly from Lemma 52.

Second, we consider the tractability of CERT for PosRAacc

LEX queries with a
ﬁnite accumulation operator on po-databases of bounded width (Theorem 43).
The result extends because, for any family D of po-databases whose po-relations
have width at most k for some k ∈ N, we know by Lemma 4 that the result
Q(cid:48)(D) for D ∈ D also has width depending only on Q(cid:48) and on k, and we know
that restricting to a subset of Q(cid:48)(D) (namely, each group) does not increase the
width (this is like the case of selection in the proof of Lemma 4). Hence, the
family D(cid:48) also has bounded width, and we can concludes using Lemma 52.

Third, we consider the tractability of CERT for PosRAacc

no× queries with a ﬁnite
and position-invariant accumulation operator on po-databases whose relations
have either bounded width or bounded ia-width (Theorem 45). The result
extends because, by Lemma 25 and subsequent observations, the result Q(cid:48)(D)
for D ∈ D is a union of a po-relation of bounded width and of a po-relation
with bounded ia-width. Restricting to a subset (i.e., a group), this property is
preserved (as in the case of selection in the proof of Lemma 4 and of Lemma 26),
which allows us to conclude using Lemma 52.

7.2. Duplicate Elimination

We last study the problem of consolidating tuples with duplicate values. To
this end, we deﬁne a new operator, dupElim, and introduce a semantics for it.

50

The main problem is that tuples with the same values may be ordered diﬀerently
relative to other tuples. To mitigate this, we introduce the notion of id-sets.

Deﬁnition 53. Given a totally ordered po-relation (ID, T, <), a subset ID (cid:48)
of ID is an indistinguishable duplicate set (or id-set) if for every id 1, id 2 ∈ ID (cid:48),
we have T (id 1) = T (id 2), and, for every id ∈ ID\ID (cid:48), we have id < id 1 iﬀ
id < id 2, and id 1 < id iﬀ id 2 < id .

Example 54. Consider the totally ordered relation Γ1 ··= Πhotelname (Hotel ),
with Hotel as in Figure 1. The two “Mercure” tuples are not an id-set: they
disagree on their ordering with “Balzac”. Consider now the totally ordered
relation Γ2 ··= Πhotelname (Hotel 2): the two “Mercure” tuples are an id-set. Note
that a singleton is always an id-set.

We deﬁne a semantics for dupElim on a totally ordered po-relation Γ =
(ID, T, <) via id-sets. First, check that for every tuple value t in the image of T ,
the set {id ∈ ID | T (id ) = t} is an id-set in Γ. If this holds, then we call Γ
safe, and set dupElim(Γ) to be the singleton {L} of the only possible world of
the restriction of Γ obtained by picking one representative element per id-set
(clearly L does not depend on the chosen representatives). Otherwise, we call Γ
unsafe and say that duplicate consolidation has failed ; we then set dupElim(Γ)
to be an empty set of possible worlds. Intuitively, duplicate consolidation tries
to reconcile (or “synchronize”) order constraints for tuples with the same values,
and fails when it cannot be done.

Example 55. In Example 54, we have dupElim(Γ1) = ∅ but dupElim(Γ2) =
(Balzac, Mercure).

We then extend dupElim to po-relations by considering all possible results of
duplicate elimination on the possible worlds, ignoring the unsafe possible worlds.
If no possible worlds are safe, then we completely fail.

Deﬁnition 56. For any list relation L, we let ΓL be a po-relation such that
pw (ΓL) = {L}. For Γ a po-relation, let dupElim(Γ) ··= (cid:83)
L∈pw(Γ) dupElim(ΓL).
We say that dupElim(Γ) completely fails if we have dupElim(Γ) = ∅, i.e.,
dupElim(ΓL) = ∅ for every L ∈ pw(Γ).

Example 57. Consider the totally ordered po-relation Restaurant from Fig-
ure 1, and a totally ordered po-relation Restaurant 2 whose only possible world is
(Tsukizi, Gagnaire). Let Q ··= dupElim(Πrestname (Restaurant) ∪ Restaurant 2).
Intuitively, Q combines restaurant rankings, using duplicate consolidation to
collapse two occurrences of the same name to a single tuple. The only possible
world of Q is ( Tsukizi, Gagnaire, TourArgent), since duplicate elimination fails
in the other possible worlds: indeed, this is the only possible way to combine the
rankings.

We next show that the result of dupElim can still be represented as a po-

relation, up to complete failure (which may be eﬃciently identiﬁed).

We ﬁrst deﬁne the notion of quotient of a po-relation by value equality.

51

Deﬁnition 58. For a po-relation Γ = (ID, T, <), we deﬁne the value-equality
quotient of Γ as the directed graph GΓ = (ID (cid:48), E), where

• ID (cid:48) is the quotient of ID by the equivalence relation id 1 ∼ id 2 ⇔ T (id1) =

T (id2), i.e., it is a set of equivalence classes that are subsets of ID;

• The edge set E is deﬁned by setting (id (cid:48)
2 and there are id 1 ∈ id (cid:48)

1 (cid:54)= id (cid:48)

1 and id 2 ∈ id (cid:48)

1, id (cid:48)

id (cid:48)

2) ∈ E for id (cid:48)

1, id (cid:48)

2 ∈ ID (cid:48) iﬀ

2 such that id 1 < id 2.

We claim that cycles in the value-equality quotient of Γ precisely characterize

complete failure of dupElim.

Proposition 59. For any po-relation Γ, dupElim(Γ) completely fails iﬀ GΓ has
a cycle.

Proof. Fix an input po-relation Γ = (ID, T, <). We ﬁrst show that the existence
1, . . . , id (cid:48)
of a cycle implies complete failure of dupElim. Let id (cid:48)
1 be a simple
cycle of GΓ. For all 1 (cid:54) i (cid:54) n, there exist id 1i, id 2i ∈ id (cid:48)
1 such that id 2i < id 1(i+1)
(with the convention id 1(n+1) = id 11) and the T (id 2i) are pairwise distinct.

n, id (cid:48)

Let L be a possible world of Γ and let us show that dupElim fails on any
po-relation ΓL that represents L, i.e., ΓL = (ID L, TL, <L) is totally ordered and
pw (ΓL) = {L}. Assume by contradiction that for all 1 (cid:54) i (cid:54) n, id (cid:48)
i forms an
id-set of ΓL. Let us show by induction on j that for all 1 (cid:54) j (cid:54) n, id 21 (cid:54)L id 2j,
where (cid:54)L denotes the non-strict order deﬁned from <L in the expected fashion.
The base case is trivial. Assume this holds for j and let us show it for j + 1.
Since id 2j < id 1(j+1), we have id 21 (cid:54) id 2j <L id 1(j+1). Now, if id 2(j+1) <L id 21,
then id 2(j+1) <L id 21 <L id 1(j+1) with T (id 2(j+1)) = T (id 1(j+1)) (cid:54)= T (id 21), so
this contradicts the fact that id (cid:48)
j+1 is an id-set. Hence, as L is a total order, we
must have id 21 (cid:54)L id 2(j+1), which proves the induction case. Now the claim
proved by induction implies that id 21 (cid:54)L id 2n, and we had id 2n < id 11 in Γ and
therefore id 2n <L id 11, so this contradicts the fact that id (cid:48)
1 is an id-set. Thus,
dupElim fails in ΓL. We have thus shown that dupElim fails in every possible
world of Γ, so that it completely fails.

j

1, . . . , id (cid:48)

Conversely, let us assume that GΓ is acyclic. Consider a topological sort
of GΓ as id (cid:48)
n. For 1 (cid:54) j (cid:54) n, let Lj be a linear extension of the poset
(id (cid:48)
). Let L be the concatenation of L1, . . . Ln. We claim L is a linear
j,<|id (cid:48)
extension of Γ such that dupElim does not fail in ΓL = (ID L, TL, <L); this
latter fact is clear by construction of L, so we must only show that L obeys the
comparability relations of Γ. Now, let id 1 < id 2 in Γ. Either for some 1 (cid:54) j (cid:54) n
we have id 1, id 2 ∈ id (cid:48)
j, and then the tuple for id 1 precedes the one for id 2 in Lj
and id (cid:48)
by construction, so we have t1 <L t2; or they are in diﬀerent classes id (cid:48)
j2
j1
and this is reﬂected in GΓ, which means that j1 < j2 and id 1 <L id 2. Hence, L
is a linear extension, which concludes the proof.

We can now state and prove the result.

Theorem 60. For any po-relation Γ, we can test in PTIME if dupElim(Γ)
completely fails; if it does not, then we can compute in PTIME a po-relation Γ(cid:48)
such that pw(Γ(cid:48)) = dupElim(Γ).

52

Proof. We ﬁrst observe that GΓ can be constructed in PTIME, and that testing
that GΓ is acyclic is also done in PTIME. Thus, using Proposition 59, we can
determine in PTIME whether dupElim(Γ) fails.

If dupElim(Γ) does not fail, then we let GΓ = (ID (cid:48), E) and construct the
relation Γ(cid:48) that will stand for dupElim(Γ) as (ID (cid:48), T (cid:48), <(cid:48)), where T (cid:48)(id (cid:48)) is
the unique T (cid:48)(id ) for id ∈ id (cid:48) and <(cid:48) is the transitive closure of E, which is
antisymmetric because GΓ is acyclic. Observe that the underlying bag relation
of Γ(cid:48) has one identiﬁer for each distinct tuple value in Γ, but has no duplicates.
Now, it is easy to check that pw (Γ(cid:48)) = dupElim(Γ). Indeed, any possible
world L of Γ(cid:48) can be achieved in dupElim(Γ) by considering, as in the proof of
Proposition 59, some possible world of Γ obtained following the topological sort
of GΓ deﬁned by L. This implies that pw (Γ(cid:48)) ⊆ dupElim(Γ).

Conversely, for any possible world L of Γ, dupElim(ΓL) (for ΓL a po-relation
that represents L) fails unless, for each tuple value, the occurrences of that tuple
value in ΓL is an id-set. Now, in such an L, as the occurrences of each value
are contiguous and the order relations reﬂected in GΓ must be respected, L is
deﬁned by a topological sort of GΓ (and some topological sort of each id-set
within each set of duplicates), so that dupElim(ΓL) can also be obtained as the
corresponding linear extension of Γ(cid:48). Hence, we have dupElim(Γ) ⊆ pw (Γ(cid:48)),
proving their equality and concluding the proof.

Last, we observe that dupElim can indeed be used to undo some of the eﬀects

of bag semantics.

Proposition 61. For any po-relation Γ, we have dupElim(Γ∪Γ) = dupElim(Γ):
in particular, one completely fails iﬀ the other does.

Proof. Let GΓ be the value-equality quotient of Γ and G(cid:48)
Γ be the value-equality
quotient of Γ ∪ Γ. It is easy to see that these two graphs are identical: any edge
of GΓ witnesses the existence of the same edge in G(cid:48)
Γ, and conversely any edge in
G(cid:48)
Γ must correspond to a comparability relation between two tuples of one of the
copies of Γ (and also in the other copy), so that it also witnesses the existence
of the same edge in Γ. Hence, by Proposition 59, one duplicate elimination
operation completely fails iﬀ the other does. Further, by Theorem 60, we have
indeed the equality that we claimed.

We can also show that most of our previous tractability results Sections 4–6
still apply when the duplicate elimination operator is added. We ﬁrst clarify the
semantics of query evaluation when complete failure occurs: given a query Q in
PosRA extended with dupElim, and given a po-database D, if complete failure
occurs at any occurrence of the dupElim operator when evaluating Q(D), then
we set pw (Q(D)) ··= ∅, pursuant to our choice of deﬁning query evaluation
on po-relations as yielding all possible results on all possible worlds. If Q is
a PosRAacc query extended with dupElim, we likewise say that its possible
accumulation results are ∅.

This implies that for any PosRA query Q extended with dupElim, for any
input po-database D, and for any candidate possible world v, the POSS and CERT

53

problems for Q are vacuously false on instance (D, v) if complete failure occurs
at any stage when evaluating Q(D). The same holds for PosRAacc queries.

Theorem 62. Theorems 20, 32, 43 and Proposition 48 extend to PosRA and
PosRAacc where we allow dupElim (but impose the same restrictions on query
operators, accumulation, and input po-relations). Speciﬁcally:

• For any ﬁxed k ∈ N and ﬁxed PosRALEX query Q which may additionally
use dupElim, the POSS problem for Q in in PTIME on po-databases of
bounded width.

• For any PosRAacc query Q which may additionally use dupElim and where
accumulation is performed in a cancellative monoid, the CERT problem
for Q is in PTIME.

• For any PosRAacc

LEX query Q which may additionally use dupElim and where
the accumulation operator is ﬁnite, the POSS and CERT problems are in
PTIME on po-databases of bounded width.

• For any PosRA query which may additionally use the dupElim operator,
the problems select-at-k, top-k, and tuple-level comparison are in
PTIME.

To prove this result, observe that these four results are proved by ﬁrst
evaluating the query result in PTIME using Proposition 2. So we can still
evaluate the query in PTIME, using in addition Theorem 60. Either complete
failure occurs at some point in the evaluation, and we can immediately solve
POSS and CERT by our initial remark above, or no complete failure occurs and
we obtain in PTIME a po-relation Γ on which to solve POSS and CERT. Hence,
in what follows, we can assume that no complete failure occurs at any stage.

It is then immediate that Theorem 32 and Proposition 48 still apply, because
they did not make any assumptions on the po-relation Γ on which they applied.
As for Theorems 20 and 43, the only assumption that they made on Γ is that its
width was constant. Hence, we can conclude the proof of Theorem 62 from the
following width preservation result.

Lemma 63. For any constant k ∈ N and po-relation Γ of width (cid:54) k, if
dupElim(Γ) does not completely fail, then it has width (cid:54) k.

Proof. It suﬃces to show that to every antichain A of dupElim(Γ), there is an
antichain A(cid:48) of the same cardinality in Γ. Construct A(cid:48) by picking a member of
each of the classes of A. Assume by contradiction that A(cid:48) is not an antichain,
hence, there are two tuples t1 < t2 in A(cid:48), and consider the corresponding classes
id 1 and id 2 in A. By our characterization of the possible worlds of dupElim(Γ)
in the proof of Theorem 60 as obtained from the topological sorts of the value-
equality quotient GΓ of Γ, as t1 < t2 implies that (id 1, id 2) is an edge of GΓ,
we conclude that we have id 1 < id 2 in A, contradicting the fact that it is an
antichain.

54

We have just shown in Theorem 62 that our tractability results still apply
when we allow the duplicate elimination operator. Furthermore, if in a set-
semantics spirit we require that the query output has no duplicates, POSS and
CERT are always tractable (as this avoids the technical diﬃculty of Example 17).

Theorem 64. For any PosRA query Q, POSS and CERT for dupElim(Q) are in
PTIME.

Proof. Let D be an input po-relation, and L be the candidate possible world
(a list relation). We compute the po-relation Γ(cid:48) such that pw (Γ(cid:48)) = Q(D) in
PTIME using Proposition 2 and the po-relation Γ ··= dupElim(Γ(cid:48)) in PTIME
using Theorem 60. If duplicate elimination fails, then we vacuously reject for POSS
and CERT. Otherwise, by the deﬁnition of dupElim, the resulting po-relation Γ
is such that each tuple value is realized exactly once. Note that we can reject
immediately if L contains multiple occurrences of the same tuple, or does not
have the same underlying set of tuples as Γ; so we assume that L has the same
underlying set of tuples as Γ and no duplicate tuples.

The CERT problem is in PTIME on Γ by Theorem 32, so we need only study
the case of POSS, namely, decide whether L ∈ pw (Γ). Let ΓL be a po-relation
that represents L. As ΓL and Γ have no duplicate tuples, there is only one way
to match each identiﬁer of ΓL to an identiﬁer of Γ. Build Γ(cid:48)(cid:48) from Γ by adding,
for each pair id i <L id i+1 of consecutive tuples of ΓL, the order constraint
id (cid:48)(cid:48)
i+1 on the corresponding identiﬁers in Γ(cid:48)(cid:48). We claim that L ∈ pw (Γ) iﬀ
the resulting Γ(cid:48)(cid:48) is a po-relation, i.e., its transitive closure is still antisymmetric,
which can be tested in PTIME by computing the strongly connected components
of Γ(cid:48)(cid:48) and checking that they are all trivial.

i <(cid:48)(cid:48)id (cid:48)(cid:48)

To see why this works, observe that, if the result Γ(cid:48)(cid:48) is a po-relation, it is
a total order, and so it describes a way to achieve L as a linear extension of Γ
because it does not contradict any of the comparability relations of Γ. Conversely,
if L ∈ pw (Γ), assuming to the contrary the existence of a cycle in Γ(cid:48)(cid:48), we observe
that such a cycle must consist of order relations of Γ and ΓL, and the order
relations of Γ are reﬂected in ΓL as it is a linear extension of Γ, so we deduce
the existence of a cycle in ΓL, which is impossible by construction. Hence, we
have reached a contradiction, and we deduce the desired result.

Discussion. The introduced group-by and duplicate elimination operators
have some shortcomings: the result of group-by is in general not representable
by po-relations, and duplicate elimination may fail. These are both consequences
of our design choices, where we capture only uncertainty on order (but not on
tuple values) and design each operator so that its result corresponds to the result
of applying it to each individual world of the input (see further discussion in
Section 8). Avoiding these shortcomings is left for future work.

8. Comparison With Other Formalisms

We next compare our formalism to previously proposed formalisms: query
languages over bags (with no order); a query language for partially ordered

55

multisets; and other related work. To our knowledge, however, none of these
works studied the possibility or certainty problems for partially ordered data, so
that our technical results do not follow from them.

Standard bag semantics. A natural desideratum for our semantics on
(partially) ordered relations is that it should be a faithful extension of the bag
semantics for relational algebra. We ﬁrst consider the BALG1 language on
bags [18] (the “ﬂat fragment” of their language BALG on nested relations).
+ the fragment of BALG1 that includes the standard
We denote by BALG1
extension of positive relational algebra operations to bags: additive union, cross
product, selection, and projection. We observe that, indeed, our semantics
faithfully extends BALG1
+: query evaluation commutes with “forgetting” the
order. Formally, for a po-relation Γ, we denote by bag(Γ) its underlying bag
relation, and deﬁne likewise bag(D) for a po-database D as the database of the
underlying bag relations. For the following comparison, we identify both ×DIR
and ×LEX with the × of [18] (as both our product operations yield the same bag
as output, for any input), and we identify our union with the additive union
of [18]. The following then trivially holds.

Proposition 65. For any PosRA query Q and a po-relation D, bag(Q(D)) =
Q(bag(D)), where Q(D) is deﬁned according to our semantics and Q(bag(D))
is deﬁned by BALG1
+.

Proof. There is an exact correspondence in terms of the output bags between
additive union and our union; between cross product and ×DIR and ×LEX; between
our selection and that of BALG1
+, and similarly for projection (as noted before
the statement of Proposition 65 in the main text, a technical subtlety is that
the projection of BALG can only project on a single attribute, but one can
encode “standard” projection on multiple attributes). The proposition follows
by induction on the query structure.

The full BALG1 language includes additional operators such as bag intersec-
tion and subtraction, which are non-monotone and as such may not be expressed
in our language: it is also unclear how they could be extended to our setting (see
further discussion in “Algebra on pomsets” below). On the other hand, BALG1
does not include aggregation, and so PosRAacc and BALG1 are incomparable in
terms of expressive power.

A better yardstick to compare against for accumulation could be the work
of [19]: they show that their basic language BQL is equivalent to BALG, and then
further extend the language with aggregate operators, to deﬁne a language called
N RLaggr on nested relations. On ﬂat relations, N RLaggr captures functions
that cannot be captured in our language: in particular the average function AVG
is non-associative and thus cannot be captured by our accumulation function
(which anyway focuses on order-dependent functions, as POSS/CERT are trivial
otherwise). On the other hand, N RLaggr cannot test parity (Corollary 5.7 in [19])
whereas this is easily captured by our accumulation operator. We conclude that

56

N RLaggr and PosRAacc are incomparable in terms of captured transformations
on bags, even when restricted to ﬂat relations.

Algebra on pomsets. We now compare our work to algebras deﬁned
on pomsets [20, 21], which also attempt to bridge partial order theory and
data management (although, again, these works do not study possibility and
certainty). Pomsets are labeled posets quotiented by isomorphism (i.e., renaming
of identiﬁers), like po-relations. Beyond similarities in the language design, a
major conceptual diﬀerence between our formalism and that of [20, 21] is that
their work focuses on processing connected components of the partial order graph,
and their operators are tailored for that semantics. As a consequence, their
semantics is not a faithful extension of bag semantics, i.e., their language would
not satisfy the counterpart of Proposition 65 (see, for instance, the semantics of
duplicate elimination in [20]). By contrast, we manipulate po-relations that stand
for sets of possible list relations, and our operators are designed accordingly,
unlike those of [20], where transformations take into account the structure
(connected components) of the entire poset graph. Because of this choice, [20]
introduces non-monotone operators that we cannot express, and can design a
duplicate elimination operator that cannot fail. Indeed, the possible failure of
our duplicate elimination operator is a direct consequence of its semantics of
operating on each possible world, possibly leading to contradictions.

If we consequently disallow duplicate elimination in both languages for the
sake of comparison, then the resulting fragment Pom-Algεn of the language
of [20] can yield only series-parallel outputs (Proposition 4.1 of [20]), unlike
PosRA queries whose output order may be arbitrary. To formalize this, we
need the notion of a realizer [5] of a poset P = (V, <): this is a set of total
orders (V, <1), . . . , (V, <n) such that, for every x, y ∈ V , we have x < y iﬀ
x <i y for all i. We can use realizers to express arbitrary po-relations using the
×DIR-product, as is shown by rephrasing in our context an existing result on
partial orders (Theorem 9.6 of [22], see also [23]).

Lemma 66. Let n ∈ N, and let (P, <P ) be a poset that has a realizer (L1, . . . , Ln)
of size n. Then P is isomorphic to a subset Γ(cid:48) of Γ = [(cid:54)l] ×DIR · · · ×DIR [(cid:54)l],
with n factors in the product, for some integer l ∈ N (the order on Γ(cid:48) being the
restriction on that of Γ).

Proof. We deﬁne Γ by taking l ··= |P |, and we identify each element x of P to
f (x) ··= (nx
1 , . . . , nx
n), where nx
i is the position where x occurs in Li. Now, for any
i < ny
i for all 1 (cid:54) i (cid:54) n (that is, x <Li y), hence
x, y ∈ P , we have x <P y iﬀ nx
iﬀ f (x) <Γ f (y): this is because there are no two elements x (cid:54)= y and 1 (cid:54) i (cid:54) n
such that the i-th components of f (x) and of f (y) are the same. Hence, taking
Γ(cid:48) to be the image of f (which is injective), Γ(cid:48) is indeed isomorphic to P .

This implies that PosRA queries can yield arbitrary po-relations as output.

Proposition 67. For any po-relation Γ, there is a PosRA query Q with no
inputs such that Q() = Γ.

57

Proof. We ﬁrst show that for any poset (P, <), there exists a PosRADIR query Q
such that the tuples of Γ(cid:48) ··= Q() all have unique values and the underlying poset
of Γ(cid:48) is (P, <). Indeed, we can take d to be the order dimension of P , which
is necessarily ﬁnite [5], and then, by deﬁnition, P has a realizer of size d. By
Lemma 66, there is an integer l ∈ N such that Γ(cid:48)(cid:48) ··= [(cid:54)l] ×DIR · · · ×DIR [(cid:54)l] (with
n factors in the product) has a subset S isomorphic to (P, <). Hence, letting ψ
be a tuple predicate such that σψ(Γ(cid:48)(cid:48)) = S (which can clearly be constructed by
enumerating the elements of S), the query Q(cid:48) ··= σψ(Γ(cid:48)(cid:48)) proves the claim, with
Γ(cid:48)(cid:48) expressed as above.

Now, to prove the desired result from this claim, build Q from Q(cid:48) by taking its
join (i.e., ×LEX-product, selection, projection) with a union of singleton constant
expressions that map each unique tuple value of Q(cid:48)() to the desired value of the
corresponding tuple in the desired po-relation Γ. This concludes the proof.

We conclude that Pom-Algεn does not subsume PosRA.

Incompleteness in databases. Our work is inspired by the ﬁeld of in-
complete information management, which has been studied for various mod-
els [24, 12], in particular relational databases [25]. This ﬁeld inspires our design
of po-relations and our study of possibility and certainty [13, 26]. However,
uncertainty in these settings typically focuses on whether tuples exist or on what
their values are (e.g., with nulls [27], including the novel approach of [28, 29];
with c-tables [25], probabilistic databases [30] or fuzzy numerical values as
in [31]). To our knowledge, though, our work is the ﬁrst to study possible
and certain answers in the context of order-incomplete data. Combining order
incompleteness with standard tuple-level uncertainty is left as a challenge for
future work. Note that some works [32, 33, 29] use partial orders on relations to
compare the informativeness of representations. This is unrelated to our partial
orders on tuples.

Ordered domains. Another line of work has studied relational data man-
agement where the domain elements are (partially) ordered [34, 35, 36, 37, 38].
This is in particular the case in works aiming to query sequences or support
[37, 38], which however do not consider uncertainty and
iteration (see e.g.
consequently neither partial order). However, our goal, setting and perspective
are diﬀerent: we see order on tuples as part of the relations, and as being
constructed by applying our operators; these works see order as being given
outside of the query, hence do not study the propagation of uncertainty through
queries. Also, queries in such works can often directly access the order relation
[36, 39, 37]. Some works also study uncertainty on totally ordered numerical
domains [31, 40], while we look at general order relations.

Temporal databases. Temporal databases [41, 42] consider order on facts,
but it is usually induced by timestamps, hence total. A notable exception
is [43] which considers that some facts may be more current than others, with

58

constraints leading to a partial order. In particular, they study the complexity
of retrieving query answers that are certainly current, for a rich query class. In
contrast, we can manipulate the order via queries, and we can also ask about
aspects beyond currency, as shown throughout the paper (e.g., via accumulation).

Using preference information. Order theory has been also used to
handle preference information in database systems [44, 45, 46, 47, 48], with
some operators being the same as ours, and for rank aggregation [49, 44, 50], i.e.,
retrieving top-k query answers given multiple rankings. However, such works
typically try to resolve uncertainty by reconciling many conﬂicting representations
(e.g., via knowledge on the individual scores given by diﬀerent sources and a
function to aggregate them [49], or a preference function [47]). In contrast, we
focus on maintaining a faithful model of all possible worlds without reconciling
them, studying possible and certain answers in this respect.

Computational social choice. The notion of preferences has been studied
in the domain of computational social choice to determine the possible outcomes
of an election given partial preference information expressed by voters [51]. In
this setting, the notions of possible winners and necessary winners have been
introduced to summarize the possible outcomes, and they have been connected
to the notion of possible and necessary answers of database queries [52]. The
complexity of these problems has been studied, with a dichotomy result that
classiﬁes its complexity depending on the aggregation used [51, 53, 54, 55].
However, the expressiveness of this computational social choice framework is
incomparable to that of our framework. Speciﬁcally, their framework only studies
possible and necessary answers in terms of achieving a maximal score computed
as a sum of numerical values following some positional scoring rule, whereas
our framework can perform accumulation in arbitrary monoids and on top of
positive relational algebra queries. Conversely, there is no apparent way in our
framework to encode accumulation following positional scoring rules, as we would
need to apply accumulation to sum the candidate scores, and then look at the
top answers according to a diﬀerent order on the result.

9. Conclusion

This paper introduced an algebra for order-incomplete data. We have studied
the complexity of possible and certain answers for this algebra, have shown the
problems to be generally intractable, and identiﬁed several tractable cases.

A prime motivation for our work is to provide a semantics for a fragment
of SQL (namely, SPJU+aggregates) in presence of partially ordered data. We
see our work as a ﬁrst step in this respect, and our choice of operators for the
algebra is by no means the only possible one. In future work we plan to study
the incorporation of additional operators, including in particular constructors
of the (partial) order based on the tuple values. We will also investigate how
to combine order-uncertainty with uncertainty on values, and study additional

59

semantics for dupElim (to avoid the pitfalls of the proposed semantics which we
discussed above).

In connection with the choice of operators, a natural question is whether one
may achieve a completeness result. We have shown (Proposition 67) that our
language is complete in terms of “individual outputs”, i.e., that PosRA can be
used to construct any po-relation using only the built-in constant relations and
operators. A more challenging goal is to design a language that is complete in
terms of transformations, i.e. that may capture all functions over po-relations in
some class. This is another intriguing topic for further investigation.

Last, many open questions remain about the complexity of POSS, e.g., we
do not know whether POSS is tractable when the accumulation monoid is a
ﬁnite group. Ideally, we would want to establish a dichotomy result for the
complexity of POSS, and a complete syntactic characterization of cases where
POSS is tractable: this is investigated further in a follow-up work involving the
ﬁrst author [56].

Acknowledgments. We are grateful to Marzio De Biasi, to P´alv¨olgyi
D¨om¨ot¨or, and to Mikhail Rudoy, from cstheory.stackexchange.com, for help-
ful suggestions. We are also grateful to the anonymous reviewers for their
feedback that helped improve this paper. This research was partially supported
by the Israeli Science Foundation (grant 1636/13), the Blavatnik ICRC, and
Intel.

References

[1] S. Abiteboul, R. Hull, V. Vianu, Foundations of databases, Addison-Wesley,

1995.

[2] A. Amarilli, M. L. Ba, D. Deutch, P. Senellart, Possible and certain answers

for queries over order-incomplete data, in: Proc. TIME, 2017.

[3] L. S. Colby, E. L. Robertson, L. V. Saxton, D. V. Gucht, A query language

for list-based complex objects, in: PODS, 1994.

[4] L. S. Colby, L. V. Saxton, D. V. Gucht, Concepts for modeling and querying
list-structured data, Information Processing & Management 30 (1994).

[5] B. Schr¨oder, Ordered Sets: An Introduction, Birkh¨auser, 2003.

[6] D. R. Fulkerson, Note on Dilworth’s decomposition theorem for partially

ordered sets, in: Proc. Amer. Math. Soc, 1955.

[7] R. P. Dilworth, A decomposition theorem for partially ordered sets, Annals

of Mathematics (1950).

[8] A. Brandst¨adt, V. B. Le, J. P. Spinrad, Posets, in: Graph Classes. A Survey,

SIAM, 1987.

60

[9] R. P. Stanley, Enumerative Combinatorics, Cambridge University Press,

1986.

[10] J. M. Howie, Fundamentals of semigroup theory, Oxford: Clarendon Press,

1995.

[11] M. Lenzerini, Data integration: A theoretical perspective, in: PODS, 2002.

[12] L. Libkin, Data exchange and incomplete information, in: PODS, 2006.

[13] L. Antova, C. Koch, D. Olteanu, World-set decompositions: Expressiveness

and eﬃcient algorithms, in: ICDT, 2007.

[14] M. K. Warmuth, D. Haussler, On the complexity of iterated shuﬄe, J.

Comput. Syst. Sci. 28 (1984).

[15] M. R. Garey, D. S. Johnson, Computers And Intractability. A Guide to the

Theory of NP-completeness, W. H. Freeman, 1979.

[16] R. Fraˆıss´e, L’intervalle en th´eorie des relations; ses gen´eralisations, ﬁltre
intervallaire et clˆoture d’une relation, North-Holland Math. Stud. 99 (1984).

[17] J.-E. Pin, Syntactic semigroups,

in: Handbook of Formal Languages,

Springer, 1997.

[18] S. Grumbach, T. Milo, Towards tractable algebras for bags, J. Comput.

Syst. Sci. 52 (1996).

[19] L. Libkin, L. Wong, Query languages for bags and aggregate functions, J.

Comput. Syst. Sci. 55 (1997).

[20] S. Grumbach, T. Milo, An algebra for pomsets, in: ICDT, 1995.

[21] S. Grumbach, T. Milo, An algebra for pomsets, Inf. Comput. 150 (1999).

[22] T. Hiraguchi, On the dimension of orders, Sci. rep. Kanazawa Univ. 4

(1955).

[23] O. Øre, Partial order, in: Theory of Graphs, AMS, 1962.

[24] P. Barcel´o, L. Libkin, A. Poggi, C. Sirangelo, XML with incomplete

information, J. ACM 58 (2010).

[25] T. Imieli´nski, W. Lipski, Incomplete information in relational databases, J.

ACM 31 (1984).

[26] W. Lipski, Jr., On semantic issues connected with incomplete information

databases, TODS 4 (1979).

[27] E. F. Codd, Extending the database relational model to capture more

meaning, TODS 4 (1979).

61

[28] L. Libkin, Incomplete data: What went wrong, and how to ﬁx it, in: PODS,

2014.

[29] L. Libkin, SQL’s three-valued logic and certain answers, in: ICDT, 2015.

[30] D. Suciu, D. Olteanu, C. R´e, C. Koch, Probabilistic Databases, Synthesis
Lectures on Data Management, Morgan & Claypool Publishers, 2011.

[31] M. A. Soliman, I. F. Ilyas, Ranking with uncertain scores, in: ICDE, 2009.

[32] P. Buneman, A. Jung, A. Ohori, Using powerdomains to generalize relational

databases, TCS 91 (1991).

[33] L. Libkin, A semantics-based approach to design of query languages for

partial information, in: Semantics in Databases, 1998.

[34] N. Immerman, Relational queries computable in polynomial time,

Inf.

Control 68 (1986).

[35] W. Ng, An extension of the relational data model to incorporate ordered

domains, TODS 26 (2001).

[36] R. van der Meyden, The complexity of querying indeﬁnite data about

linearly ordered domains, J. Comput. Syst. Sci. 54 (1997).

[37] A. J. Bonner, G. Mecca, Sequences, datalog, and transducers, J. Comput.

Syst. Sci. 57 (1998) 234–259.

[38] N. Coburn, G. E. Weddell, A logic for rule-based query optimization in

graph-based data models, in: DOOD, 1993, pp. 120–145.

[39] M. Benedikt, L. Segouﬁn, Towards a characterization of order-invariant

queries over tame graphs, Journal of Symbolic Logic 74 (2009).

[40] M. A. Soliman, I. F. Ilyas, S. Ben-David, Supporting ranking queries on

uncertain and incomplete data, VLDBJ 19 (2010).

[41] J. Chomicki, D. Toman, Time in database systems,

in: Handbook of

Temporal Reasoning in Artiﬁcial Intelligence, Elsevier, 2005.

[42] R. T. Snodgrass, J. Gray, J. Melton, Developing time-oriented database

applications in SQL, Morgan Kaufmann, 2000.

[43] W. Fan, F. Geerts, J. Wijsen, Determining the currency of data, TODS 37

(2012).

[44] M. Jacob, B. Kimelfeld, J. Stoyanovich, A system for management and

analysis of preference data, VLDB Endow. 7 (2014).

[45] A. Arvanitis, G. Koutrika, PrefDB: Supporting preferences as ﬁrst-class

citizens in relational databases, IEEE TKDE 26 (2014).

62

[46] W. Kiessling, Foundations of preferences in database systems, in: VLDB,

2002.

[47] B. Alexe, M. Roth, W.-C. Tan, Preference-aware integration of temporal

data, PVLDB 8 (2014).

[48] K. Stefanidis, G. Koutrika, E. Pitoura, A survey on representation, com-
position and application of preferences in database systems, TODS 36
(2011).

[49] R. Fagin, A. Lotem, M. Naor, Optimal aggregation algorithms for middle-

ware, in: PODS, 2001.

[50] C. Dwork, R. Kumar, M. Naor, D. Sivakumar, Rank aggregation methods

for the Web, in: WWW, 2001.

[51] K. Konczak, J. Lang, Voting procedures with incomplete preferences, in:

IJCAI-05 Workshop on Advances in Preference Handling, 2005.

[52] B. Kimelfeld, P. G. Kolaitis, J. Stoyanovich, Computational social choice

meets databases, in: Proc. IJCAI, 2018.

[53] L. Xia, V. Conitzer, Determining possible and necessary winners given

partial orders, JAIR 41 (2011).

[54] N. Betzler, B. Dorn, Towards a dichotomy for the possible winner problem
in elections based on scoring rules, J. Comput. Syst. Sci. 76 (2010).

[55] D. Baumeister, J. Rothe, Taking the ﬁnal step to a full dichotomy of
the possible winner problem in pure scoring rules, Information Processing
Letters 112 (2012).

[56] A. Amarilli, C. Paperman, Topological sorting under regular constraints,

in: ICALP, 2018.

63

