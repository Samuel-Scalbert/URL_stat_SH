The Complexity of Counting Problems Over Incomplete
Databases
Marcelo Arenas, Pablo Barceló, Mikaël Monet

To cite this version:

Marcelo Arenas, Pablo Barceló, Mikaël Monet. The Complexity of Counting Problems Over
ACM Transactions on Computational Logic, 2021, 22 (4), pp.1-52.
Incomplete Databases.
￿10.1145/3461642￿. ￿hal-03356951￿

HAL Id: hal-03356951

https://hal.science/hal-03356951

Submitted on 28 Sep 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

1

The Complexity of Counting Problems
over Incomplete Databases

1
2
0
2

r
p
A
8
2

]

B
D
.
s
c
[

2
v
0
3
3
6
0
.
1
1
0
2
:
v
i
X
r
a

MARCELO ARENAS∗, Universidad Católica & IMFD Chile
PABLO BARCELÓ†, Universidad Católica & IMFD Chile
MIKAËL MONET, Univ. Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

We study the complexity of various fundamental counting problems that arise in the context of incomplete
databases, i.e., relational databases that can contain unknown values in the form of labeled nulls. Specifically,
we assume that the domains of these unknown values are finite and, for a Boolean query 𝑞, we consider the
following two problems: given as input an incomplete database 𝐷, (a) return the number of completions of 𝐷
that satisfy 𝑞; or (b) return the number of valuations of the nulls of 𝐷 yielding a completion that satisfies 𝑞.
We obtain dichotomies between #P-hardness and polynomial-time computability for these problems when 𝑞 is
a self-join–free conjunctive query, and study the impact on the complexity of the following two restrictions:
(1) every null occurs at most once in 𝐷 (what is called Codd tables); and (2) the domain of each null is the same.
Roughly speaking, we show that counting completions is much harder than counting valuations: for instance,
while the latter is always in #P, we prove that the former is not in #P under some widely believed theoretical
complexity assumption. Moreover, we find that both (1) and (2) can reduce the complexity of our problems.
We also study the approximability of these problems and show that, while counting valuations always has a
fully polynomial-time randomized approximation scheme (FPRAS), in most cases counting completions does
not. Finally, we consider more expressive query languages and situate our problems with respect to known
complexity classes.

CCS Concepts: • Theory of computation → Complexity theory and logic; Incomplete, inconsistent,
and uncertain databases; • Mathematics of computing → Approximation algorithms.

Additional Key Words and Phrases: Incomplete databases, closed-world assumption, counting complexity,
Fully Polynomial-time Randomized Approximation Scheme (FPRAS).

1 INTRODUCTION

Context. In the database literature, incomplete databases are often used to represent missing
information in the data; see, e.g., [1, 37, 52]. These are traditional relational databases whose active
domain can contain both constants and nulls, the latter representing unknown values [30]. There
are many ways in which one can define the semantics of such a database, each being equally
meaningful depending on the intended application. Under the so called closed-world assumption [1,
45], a standard, complete database 𝜈 (𝐷) is obtained from an incomplete database 𝐷 by applying a
valuation 𝜈 which replaces each null ⊥ in 𝐷 with a constant 𝜈 (⊥). The goal is then to reason about
the space formed by all valuations 𝜈 and completions 𝜈 (𝐷) of 𝐷.

Decision problems related to querying incomplete databases have been well studied already.
Consider for instance the problem Certainty(𝑞( ¯𝑥)) which, for a fixed query 𝑞( ¯𝑥), takes as input
an incomplete database 𝐷 and a tuple ¯𝑎 and asks whether ¯𝑎 is an answer to 𝑞 for every possible
completion of 𝐷. By now, we have a deep understanding of the complexity of these kind of decision

∗Also with Department of Computer Science & Institute for Mathematical and Computational Engineering, School of
Engineering, Pontificia Universidad Católica de Chile.
†Also with Institute for Mathematical and Computational Engineering, School of Engineering and Faculty of Mathematics,
Pontificia Universidad Católica de Chile.

Authors’ addresses: Marcelo Arenas, Universidad Católica & IMFD Chile, marenas@ing.puc.cl; Pablo Barceló, Universidad
Católica & IMFD Chile, pbarcelo@uc.cl; Mikaël Monet, Univ. Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000
Lille, France, mikael.monet@inria.fr.

 
 
 
 
 
 
1:2

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

problems for different choices of query languages, including conjunctive queries (CQs) and FO
queries [2, 30]. However, having the answer to this question is sometimes of little help: what if it is
not the case that 𝑞 is certain on 𝐷? Can we still infer some useful information? This calls for new
notions that could be used to measure the certainty with which 𝑞 holds, notions which should be
finer than those previously considered. This is for instance what the recent work in [38] does by
introducing a notion of best answer, which are those tuples ¯𝑎 for which the set of completions of 𝐷
over which 𝑞( ¯𝑎) holds is maximal with respect to set inclusion.

A fundamental complementary approach to address this issue can be obtained by considering
some counting problems related to incomplete databases; more specifically, determining the number
of completions/valuations of an incomplete database that satisfy a query 𝑞. These problems are
relevant as they tell us, intuitively, how close is 𝑞 from being certain over 𝐷, i.e., what is the level of
support that 𝑞 has over the set of completions/valuations of 𝐷. Surprisingly, such counting problems
do not seem to have been studied for incomplete databases. A reason for this omission in the
literature might be that, in general, it is assumed that the domain over which nulls can be interpreted
is infinite, and thus incomplete databases might have an infinite number of completions/valuations.
However, in many scenarios it is natural to assume that the domain over which nulls are interpreted
is finite, in particular when dealing with uncertainty in practice [4, 6, 7, 11, 23, 46]. By assuming
this we can ensure that the number of completions and valuations are always finite, and thus that
they can be counted. This is the setting that we study.

Problems studied. We focus on the problems #Comp(𝑞) and #Val(𝑞) for a Boolean query 𝑞,
which take as input an incomplete database 𝐷 together with a finite set dom(⊥) of constants for
every null ⊥ occurring in 𝐷, and ask the following: How many completions, resp., valuations, of 𝐷
satisfy 𝑞? More formally, a valuation of 𝐷 is a mapping 𝜈 that associates to every null ⊥ of 𝐷 a
constant 𝜈 (⊥) in dom(⊥). Then, given a valuation 𝜈 of 𝐷, we denote by 𝜈 (𝐷) the database that is
obtained from 𝐷 after replacing each null ⊥ with 𝜈 (⊥), and we call such a database a completion.
Besides, in this article we consider set semantics, that is, we remove repeated tuples from 𝜈 (𝐷).
For #Comp(𝑞) we count all databases of the form 𝜈 (𝐷) such that 𝑞 holds in 𝜈 (𝐷). Instead, for
#Val(𝑞) we count the number of valuations 𝜈 such that 𝑞 holds in 𝜈 (𝐷). It is easy to see that these
two values can differ, as a completion might be obtained from two different valuations, i.e., there
might exist two distinct valuations 𝜈, 𝜈 ′ such that 𝜈 (𝐷) = 𝜈 ′(𝐷). We think that both problems are
meaningful: while #Comp(𝑞) determines the support for 𝑞 over the databases represented by 𝐷,
we have that #Val(𝑞) further refines this by incorporating the support for a particular completion
that satisfies 𝑞 over the set of valuations for 𝐷.

We deal with the data complexity of the problems #Comp(𝑞) and #Val(𝑞), focusing on obtaining
dichotomy results for them in terms of counting complexity classes, as well as studying the
existence of randomized algorithms that approximate their results under probabilistic guarantees.
For the dichotomies, we concentrate on self-join-free Boolean conjunctive queries (sjfBCQs). This
assumption simplifies the mathematical analysis, while at the same time defines a setting which is
rich enough for many of the theoretical concepts behind these problems to appear in full force.
Notice that a similar assumption is used in several works that study counting problems over
probabilistic and inconsistent databases; see, e.g., [18, 40]. To simplify further the presentation,
in the bulk of the article we mainly consider self-join–free Boolean conjunctive queries that do
not contain constants; however, we explain later (in Section 7) how our results can be extended to
queries that can contain constants and free variables.

To refine our analysis, we study two restrictions of the problems #Comp(𝑞) and #Val(𝑞) based
on natural modifications of the semantics, and analyze to what extent these restrictions simplify
our problems. For the first restriction we consider incomplete databases in which each null occurs

The complexity of counting problems over incomplete databases

1:3

Counting valuations

Counting completions

Non-uniform Uniform

Non-uniform Uniform

Naïve

𝑅(𝑥, 𝑥)
𝑅(𝑥) ∧ 𝑆 (𝑥)

Codd

𝑅(𝑥) ∧ 𝑆 (𝑥)

𝑅(𝑥, 𝑥)
𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦)
𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦)

𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦)
𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦)

𝑅(𝑥)

𝑅(𝑥)

𝑅(𝑥, 𝑥)
𝑅(𝑥, 𝑦)

𝑅(𝑥, 𝑥)
𝑅(𝑥, 𝑦)

Table 1. Our dichotomies for counting valuations and completions of sjfBCQs. For each of the eight cases, if
an sjfBCQ 𝑞 contains a pattern mentioned in that case, then the problem is #P-hard (and #P-complete for
counting valuations, as well as for counting completions over Codd tables). In turn, for each case if an sjfBCQ
𝑞 does not have any of the patterns mentioned in that case, then the problem is in FP.

Naïve

Codd

FPRAS for counting valuations

Non-uniform Uniform
Always
Always

FPRAS for counting completions
Non-uniform Uniform
Never

Only when 𝑞 has
only unary atoms
?

Always

Always

Never

Table 2. Our results on the existence of FPRAS for solving the problems studied in the article (assuming
NP ≠ RP).

exactly once, which corresponds to the well-studied setting of Codd tables – as opposed to naive
tables where nulls are allowed to have multiple occurrences. We denote the corresponding prob-
lems by #ValCd (𝑞) and #CompCd (𝑞). For the second restriction, we consider uniform incomplete
databases in which all the nulls share the same domain – as opposed to the basic non-uniform
setting in which all nulls come equipped with their own domain. We denote the corresponding
problems by #Valu (𝑞) and #Compu(𝑞). When both restrictions are in place, we denote the problems
by #Valu
Cd

(𝑞) and #Compu
Cd

(𝑞).

Our dichotomies for exact counting. We provide complete characterizations of the complex-
ity of counting valuations and completions satisfying a given sjfBCQ 𝑞, when the input is a Codd
table or a naive table, and is a non-uniform or a uniform incomplete database (hence we have eight
cases in total). Our eight dichotomies express that these problems are either tractable or #P-hard,
and that the tractable cases can be fully characterized by the absence of certain forbidden patterns
in 𝑞. In essence, a pattern is simply an sjfBCQ which can be obtained from 𝑞 by deleting atoms and
occurrences of variables (the exact definition of this notion is given in Section 3). Our characteriza-
tions are presented in Table 1. By analyzing this table we can draw some important conclusions as
explained next.

#Comp(𝑞) and #Val(𝑞) are computationally difficult: For very few sjfBCQs 𝑞 the aforementioned
problems can be solved in polynomial time. Take as an example the uniform setting over naive
tables. Then #Valu(𝑞) is #P-hard as long as 𝑞 contains the pattern 𝑅(𝑥, 𝑥), or 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦),
or 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦). That is, as long as there is an atom in 𝑞 that contains a repeated variable 𝑥, or
a pair (𝑥, 𝑦) of variables that appear in an atom and both 𝑥 and 𝑦 appear in some other atoms in 𝑞.
By contrast, for this same setting, #Compu(𝑞) is #P-hard as long as 𝑞 contains the pattern 𝑅(𝑥, 𝑦)
or 𝑅(𝑥, 𝑥), that is, as long as there is an atom in 𝑞 that is not of arity one.

1:4

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

#Val(𝑞) is always easier than #Comp(𝑞): In all of the possible versions of our problem, the tractable
cases for #Val(𝑞) are a strict superset of the ones for #Comp(𝑞). For instance, #Compu
(∃𝑥∃𝑦 𝑅(𝑥, 𝑦))
Cd
is hard, while #Valu
Cd

(∃𝑥∃𝑦 𝑅(𝑥, 𝑦)) is tractable.

Even counting completions is hard: While counting the total number of valuations for an incom-
plete database can always be done in polynomial time, observe from Table 1 that the problem
#Compu
(∃𝑥∃𝑦 𝑅(𝑥, 𝑦)) is #P-hard, and thus that simply counting the completions of a uniform
Cd
Codd table with a single binary relation 𝑅 is #P-hard. Moreover, we show that in the non-uniform
case a single unary relation suffices to obtain #P-hardness.

Codd tables help but not much: We show that counting valuations is easier for Codd tables than
for naive tables. In particular, there is always an sjfBCQ 𝑞 such that counting the valuations that
satisfy 𝑞 is #P-hard, yet it becomes tractable when restricted to the case of Codd tables. However,
for counting completions, both in the uniform and non-uniform setting, the sole restriction to
Codd tables presents no benefits: for every sjfBCQ 𝑞, we have that #Comp(𝑞) (resp., #Compu(𝑞))
is #P-hard if and only if #CompCd (𝑞) (resp., #Compu
Cd
Non-uniformity complicates things: All versions of our problems become harder in the non-uniform
setting. This means that in all cases there is an sjfBCQ 𝑞 for which counting valuations is tractable
on uniform incomplete databases, but becomes #P-hard assuming non-uniformity, and the same
holds for counting completions.

(𝑞)) is #P-hard.

Our dichotomies for approximate counting. Although #Val(𝑞) can be #P-hard, we prove
that good randomized approximation algorithms can be designed for this problem. More precisely,
we give a general condition under which #Val(𝑞) admits a fully polynomial-time randomized
approximation scheme [33] (FPRAS). This condition applies in particular to all unions of Boolean
conjunctive queries. Remarkably, we show that this no longer holds for #Comp(𝑞); more precisely,
there exists an sjfBCQ 𝑞 such that #Comp(𝑞) does not admit an FPRAS under a widely believed
complexity theoretical assumption. More surprisingly, even counting the completions of a uniform
incomplete database containing a single binary relation does not admit an FPRAS under such an
assumption (and in the non-uniform case, a single unary relation suffices). Generally, for sjfBCQs,
we obtain seven dichotomies for our problems between polynomial-time computability of exact
counting and non admissibility of an FPRAS. The only case that we did not completely solve is that
of #Compu
(𝑞). Our dichotomies for approximate counting are illustrated in Table 2.
Cd

Beyond #P. It is easy to see that the problem of counting valuations is always in #P, provided
that the model checking problem for 𝑞 is in P. This is no longer the case for counting completions,
and in fact we show that, under a complexity theoretical assumption, there is an sjfBCQ 𝑞 for which
#Compu(𝑞) is not in #P. This does not hold if restricted to Codd tables, however, as we prove that
#CompCd (𝑞) is always in #P when the model checking problem for 𝑞 is in P.

For reasons that we explain in the article, a suitable complexity class for the problem #Comp(𝑞)
is SpanP, which is defined as the class of counting problems that can be expressed as the number
of different accepting outputs of a nondeterministic Turing machine running in polynomial time.
While we have not managed to prove that there is an sjfBCQ 𝑞 for which #Comp(𝑞) is SpanP-
complete, we show that this is the case for the problem of counting completions for the negation
of an sjfBCQ, even in the uniform setting; that is, we show that #Compu (¬𝑞) is SpanP-complete
for some sjfBCQ 𝑞. Finally, we also show that SpanP is the right complexity class for counting
valuations of queries for which model checking is in NP.

Extension to queries with constants and free variables. As we said already, for pedagogical
reasons we mostly present our results by considering queries that are Boolean and that do not have

The complexity of counting problems over incomplete databases

1:5

constants. In Section 7 however, we explain how to extend these results to the case of queries that
have free variables and that can contain constants. For the case of a query 𝑞( ¯𝑥) with free variables ¯𝑥,
our counting problems are defined in the expected way; for instance the problem #Val(𝑞( ¯𝑥)) takes as
input an incomplete database 𝐷, a tuple of constants ¯𝑎 of same arity as ¯𝑥, and it outputs the number
of valuations 𝜈 of 𝐷 such that ¯𝑎 in an answer to 𝑞( ¯𝑥) on 𝜈 (𝐷). We then extend our dichotomies
and approximation results in this setting.

The current article extends the conference article [8] in the following ways:
• In [8] we left open the dichotomy for #Valu
Cd

(𝑞), i.e., for counting valuations of sjfBCQs for
Codd tables under the uniform setting. We close this case here, by finding one more hard
pattern (namely, the pattern ∃𝑥, 𝑦 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦)) and showing that the problem can be
solved in polynomial time for all other queries.

• We added Section 7 which explains how our framework can be extended to handle queries

with constants and free variables;

• Proposition 6.3, which establishes the NP-completeness of checking if a set of facts is a

possible completion of an incomplete database, is new;

• Finally, full proofs of most results are included in the body of the article.

Organization of the article. We start with the main terminology used in the article in Section 2,
and then present in Section 3 our four dichotomies on #Val(𝑞) when 𝑞 is an sjfBCQ, and the input
incomplete database can be Codd or not, and the domain can be uniform or not. We then establish the
four dichotomies on #Comp(𝑞) in Section 4. In Section 5, we study the approximability complexity
of our problems. We then give in Section 6 some general considerations about the exact complexity
of the problem #Comp(𝑞) going beyond #P. We explain in Section 7 how to extend our results to
queries with constants and free variables. In Section 8, we discuss related work and explain the
differences with the problems considered in this article. Last, we provide some conclusions and
mention possible directions for future work in Section 9.

2 PRELIMINARIES

Relational databases and conjunctive queries. A relational schema 𝜎 is a finite non-empty
set of relation symbols written 𝑅, 𝑆, 𝑇 , . . . , each with its associated arity, which is denoted by
arity(𝑅). Let Consts be a countably infinite set of constants. A database 𝐷 over 𝜎 is a set of facts of
the form 𝑅(𝑎1, . . . , 𝑎arity(𝑅) ) with 𝑅 ∈ 𝜎, and where each element 𝑎𝑖 ∈ Consts. For 𝑅 ∈ 𝜎, we denote
by 𝐷 (𝑅) the subset of 𝐷 consisting of facts over 𝑅. Such a set is usually called a relation of 𝐷.

A Boolean query 𝑞 is a query that a database 𝐷 can satisfy (written 𝐷 |= 𝑞) or not (written 𝐷 ̸|= 𝑞).
If 𝑞 is a Boolean query, then ¬𝑞 is the Boolean query such that 𝐷 |= ¬𝑞 if and only if 𝐷 ̸|= 𝑞. A
Boolean conjunctive query (BCQ) over 𝜎 is an FO formula of the form

∃ ¯𝑥 (cid:0)𝑅1( ¯𝑥1) ∧ . . . ∧ 𝑅𝑚 ( ¯𝑥𝑚)(cid:1),

(1)

where all variables are existentially quantified, and where for each 𝑖 ∈ [1, 𝑚], we have that 𝑅𝑖 is a
relation symbol in 𝜎 and ¯𝑥𝑖 is a tuple of variables with | ¯𝑥𝑖 | = arity(𝑅𝑖 ). To avoid trivialities, we will
always assume that 𝑚 ⩾ 1, i.e., the query has at least one atom, and also that arity(𝑅𝑖 ) ⩾ 1 for all
atoms. Observe that we do not allow constants to appear in the query (but we will come back to
this issue in Section 7). For simplicity, we typically write a BCQ 𝑞 of the form (1) as

and it will be implicitly understood that all variables in 𝑞 are existentially quantified. As usual, we de-
fine the semantics of a BCQ in terms of homomorphisms. A homomorphism from 𝑞 to a database 𝐷 is a

𝑅1( ¯𝑥1) ∧ . . . ∧ 𝑅𝑚 ( ¯𝑥𝑚),

1:6

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

(𝜈 (⊥1), 𝜈 (⊥2))
𝜈 (𝐷)

(𝑎, 𝑎)

(𝑎, 𝑏)

(𝑏, 𝑎)

(𝑏, 𝑏)

(𝑐, 𝑎)

(𝑐, 𝑏)

𝑆

𝑎
𝑎

𝑏
𝑎

𝑆

𝑎
𝑎

𝑏
𝑎

𝑆

𝑎
𝑏
𝑎

𝑏
𝑎
𝑎

𝑆

𝑎
𝑏

𝑏
𝑎

𝑆

𝑎
𝑐
𝑎

𝑏
𝑎
𝑎

𝑆

𝑎
𝑐

𝑏
𝑎

𝜈 (𝐷) |= 𝑞?

Yes

Yes

Yes

No

Yes

No

Fig. 1. The six valuations of the (non-uniform) incomplete database 𝐷 = (𝑇 , dom) with 𝑇 =
{𝑆 (𝑎, 𝑏), 𝑆 (⊥1, 𝑎), 𝑆 (𝑎, ⊥2)} from Example 2.2, and their corresponding completions. The Boolean conjunctive
query 𝑞 is ∃𝑥 𝑆 (𝑥, 𝑥).

mapping from the variables in 𝑞 to the constants used in 𝐷 such that {𝑅1(ℎ( ¯𝑥1)), . . . , 𝑅𝑚 (ℎ( ¯𝑥𝑚))} ⊆
𝐷. Then, we have 𝐷 |= 𝑞 if there exists a homomorphism from 𝑞 to 𝐷. A self-join–free BCQ (sjfBCQ)
is a BCQ such that no two atoms use the same relation symbol.

Incomplete databases. Let Nulls be a countably infinite set of nulls (also called labeled or
marked nulls in the literature), which is disjoint with Consts. An incomplete database over schema 𝜎
is a pair 𝐷 = (𝑇 , dom), where 𝑇 is a database over 𝜎 whose facts contain elements in Consts ∪ Nulls,
and where dom is a function that associates to every null ⊥ occurring in 𝐷 a subset dom(⊥)
of Consts. Intuitively, 𝑇 is a database that can mention both constants and nulls, while dom tells us
where nulls are to be interpreted. Following the literature, we call 𝑇 a naive table [30].

An incomplete database 𝐷 = (𝑇 , dom) can represent potentially many complete databases,
via what are called valuations. A valuation of 𝐷 is simply a function 𝜈 that maps each null ⊥
occurring in 𝑇 to a constant 𝜈 (⊥) ∈ dom(⊥). Such a valuation naturally defines a completion
of 𝐷, denoted by 𝜈 (𝑇 ), which is the complete database obtained from 𝑇 by substituting each
null ⊥ appearing in 𝑇 by 𝜈 (⊥). It is understood, since a database is a set of facts, that 𝜈 (𝑇 ) does
not contain duplicate facts. By paying attention to completions of incomplete databases that are
generated exclusively by applying valuations to them, we are sticking to the so called closed-world
semantics of incompleteness [1, 45]. This means that the databases represented by an incomplete
database 𝐷 = (𝑇 , dom) are not open to adding facts that are not “justified” by the facts in 𝑇 .

Example 2.1. Let 𝐷 = (𝑇 , dom) be the incomplete database consisting of the naive table 𝑇 =
{𝑆 (⊥1, ⊥1), 𝑆 (𝑎, ⊥2)}, and where dom(⊥1) = {𝑎, 𝑏} and dom(⊥2) = {𝑎, 𝑐}. Let 𝜈1 be the valuation
mapping ⊥1 to 𝑏 and ⊥2 to 𝑐. Then 𝜈1(𝑇 ) is {𝑆 (𝑏, 𝑏), 𝑆 (𝑎, 𝑐)}. Let 𝜈2 be the valuation mapping
both ⊥1 and ⊥2 to 𝑎. Then 𝜈2(𝑇 ) is {𝑆 (𝑎, 𝑎)}. On the other hand, the function 𝜈 mapping ⊥1 and ⊥2
□
to 𝑏 is not a valuation of 𝐷, because 𝑏 ∉ dom(⊥2).

When every null occurs at most once in 𝑇 , then 𝐷 is what is called a Codd table [16]; for instance,
the incomplete database in Example 2.1 is not a Codd table because ⊥1 occurs twice. We also
consider uniform incomplete databases in which the domain of every null is the same. Formally, a
uniform incomplete database is a pair 𝐷 = (𝑇 , dom), where 𝑇 is a database over 𝜎 and dom is a
subset of Consts. The difference now is that a valuation 𝜈 of 𝐷 must simply satisfy 𝜈 (⊥) ∈ dom for
every null of 𝐷.

We will often abuse notation and use 𝐷 instead of 𝑇 ; for instance, we write 𝜈 (𝐷) instead of 𝜈 (𝑇 ),

or 𝑅(𝑎, 𝑎) ∈ 𝐷 instead of 𝑅(𝑎, 𝑎) ∈ 𝑇 , or again 𝐷 (𝑅) instead of 𝑇 (𝑅).

The complexity of counting problems over incomplete databases

1:7

Counting problems on incomplete databases. We will study two kinds of counting problems
for incomplete databases: problems of the form #Val(𝑞), that count the number of valuations 𝜈 that
yield a completion 𝜈 (𝐷) satisfying a given BCQ 𝑞, and problems of the form #Comp(𝑞), that count
the number of completions that satisfy 𝑞. The query 𝑞 is assumed to be fixed, so that each query
gives rise to different counting problems, and we are considering the data complexity [53] of these
problems.

Before formally introducing our problems, let us observe that they are well defined if we assume
that the set of constants to which a null can be mapped to is finite. Hence, for the (default) case of
an incomplete database 𝐷 = (𝑇 , dom), we assume that dom(⊥) is always a finite subset of Consts.
Similarly, for the case of a uniform incomplete database 𝐷 = (𝑇 , dom), we assume that dom is
a finite subset of Consts. Finally, given a Boolean query 𝑞, we use notation sig(𝑞) for the set of
relation symbols occurring in 𝑞. With these ingredients, we can define our problems for the (default)
case of incomplete naive tables and a Boolean query 𝑞.

PROBLEM :
INPUT :
OUTPUT : Number of valuations 𝜈 of 𝐷 with 𝜈 (𝐷) |= 𝑞

#Val(𝑞)
An incomplete database 𝐷 over sig(𝑞)

PROBLEM :
INPUT :
OUTPUT : Number of completions 𝜈 (𝐷) of 𝐷 with

#Comp(𝑞)
An incomplete database 𝐷 over sig(𝑞)

𝜈 (𝐷) |= 𝑞

We also consider the uniform variants of these problems, in which the input 𝐷 is a uniform
incomplete database over sig(𝑞), and the restriction of these problems where the input is a Codd
table instead of a naive table. We then use the terms #Valu (𝑞), #Compu(𝑞) when restricted to the
uniform case, #ValCd (𝑞), #CompCd (𝑞) when restricted to Codd tables, and #Valu
(𝑞)
Cd
when both restrictions are applied.

(𝑞), #Compu
Cd

As we will see, even though the problems #Val(𝑞) and #Comp(𝑞) look similar, they are of
a different computational nature; this is because two distinct valuations can produce the same
completion of an incomplete database. We illustrate this phenomenon in the following example.

Example 2.2. Let 𝑞 be the Boolean conjunctive query ∃𝑥 𝑆 (𝑥, 𝑥), and 𝐷 be the (non-uniform)
incomplete database 𝐷 = (𝑇 , dom), with 𝑇 = {𝑆 (𝑎, 𝑏), 𝑆 (⊥1, 𝑎), 𝑆 (𝑎, ⊥2)}, dom(⊥1) = {𝑎, 𝑏, 𝑐}
and dom(⊥2) = {𝑎, 𝑏}. We have depicted in Figure 1 the six valuations of 𝐷 together with the
completions that they define. Out of these six valuations 𝜈, only four are such that 𝜈 (𝐷) |= 𝑞, so we
have #Val(𝑞)(𝐷) = 4. Moreover, there are only 3 distinct completions of 𝐷 that satisfy 𝑞 – because
□
the first two are the same – so #Comp(𝑞)(𝐷) = 3.

Counting complexity classes. Given two problems 𝐴, 𝐵, we write 𝐴 ⩽p

T 𝐵 when 𝐴 reduces
to 𝐵 under polynomial-time Turing reductions. When both 𝐴 and 𝐵 are counting problems, we
write 𝐴 ⩽p
par 𝐵 when 𝐴 can be reduced to 𝐵 under polynomial-time parsimonious reductions, i.e.,
when there exists a polynomial-time computable function 𝑓 that transforms an input 𝑥 of 𝐴 to an
input 𝑓 (𝑥) of 𝐵 such that 𝐴(𝑥) = 𝐵(𝑓 (𝑥)). We say that a counting problem is in FP when it can be
solved in polynomial time. We will consider the counting complexity class #P [50] of problems that
can be expressed as the number of accepting paths of a nondeterministic Turing machine running
in polynomial time. Following [50, 51], we define #P-hardness using Turing reductions. It is clear
that FP ⊆ #P. Moreover, this inclusion is widely believed to be strict. Therefore, proving that a

1:8

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

counting problem is #P-hard implies that it cannot be solved in polynomial time under such an
assumption.

3 DICHOTOMIES FOR COUNTING VALUATIONS
In this section, for a fixed sjfBCQ q, we study the complexity of the problem of computing, given as
input an incomplete database 𝐷, the number of valuations 𝜈 of 𝐷 such that 𝜈 (𝐷) satisfies 𝑞. Recall
that we have four cases to consider for this problem depending on whether we focus on naive
or on Codd tables, where nulls are restricted to appear at most once, and whether we focus on
non-uniform or uniform incomplete databases, where nulls are restricted to have the same domain.
Our specific goal then is to understand whether the problem is tractable (in FP) or #P-hard in these
scenarios, depending on the shape of 𝑞.

To this end, the shape of an sjfBCQ 𝑞 will be characterized by the presence or absence of certain
specific patterns. In the following definition, we introduce the necessary terminology to formally
talk about the presence of a pattern in a query.

Definition 3.1. Let 𝑞, 𝑞′ be sjfBCQs. We say that 𝑞′ is a pattern of 𝑞 if 𝑞′ can be obtained from 𝑞
by using an arbitrary number of times and in any order the following operations: deleting an atom,
deleting an occurrence of a variable, renaming a relation to a fresh one, renaming a variable to a
fresh one, and reordering the variables in an atom.1
□

Example 3.2. Recall that we always omit existential quantifiers in Boolean queries. Then we
have that 𝑞′ = 𝑅 ′(𝑢, 𝑢, 𝑦) ∧ 𝑆 ′(𝑧) is a pattern of 𝑞 = 𝑅(𝑢, 𝑥, 𝑢) ∧ 𝑆 ′(𝑦, 𝑦) ∧ 𝑇 (𝑥, 𝑠, 𝑧, 𝑠). Indeed,
𝑞′ can be obtained from 𝑞 by deleting atom 𝑇 (𝑥, 𝑠, 𝑧, 𝑠), renaming 𝑅(𝑢, 𝑥, 𝑢) as 𝑅 ′(𝑢, 𝑥, 𝑢) to ob-
tain 𝑅 ′(𝑢, 𝑥, 𝑢) ∧ 𝑆 ′(𝑦, 𝑦), reordering the variables in 𝑅 ′(𝑢, 𝑥, 𝑢) to obtain 𝑅 ′(𝑢, 𝑢, 𝑥) ∧ 𝑆 ′(𝑦, 𝑦),
renaming variable 𝑦 into 𝑧 to obtain 𝑅 ′(𝑢, 𝑢, 𝑥) ∧ 𝑆 ′(𝑧, 𝑧), deleting the second variable occurrence
□
in 𝑆 ′(𝑧, 𝑧) to obtain 𝑅 ′(𝑢, 𝑢, 𝑥) ∧ 𝑆 ′(𝑧), and finally renaming variable 𝑥 into 𝑦 to obtain 𝑞′.

We point out that in Definition 3.1, the important parts are those about deleting atoms and
variable occurrences. The parts about reordering variable occurences inside an atom and about
renaming relations and variables to fresh ones have obviously no effect on the complexity of the
problem2; these are only here to allow us to formally say, for instance, that “𝑅(𝑥) is a pattern
of 𝑅(𝑦)”, or that “𝑆 (𝑥, 𝑢, 𝑥) is a pattern of 𝑇 (𝑤, 𝑧, 𝑧)” (as these are, in essence, the same queries).

In the following general lemma, we show that if 𝑞′ is a pattern of 𝑞, then each of the problems
considered in this section is as hard for 𝑞 as it is for 𝑞′. Recall in this result that unless stated
otherwise, our problems are defined for naive tables under the non-uniform setting.

Lemma 3.3. Let 𝑞, 𝑞′ be sjfBCQs such that 𝑞′ is a pattern of 𝑞. Then we have #Val(𝑞′) ⩽p
Moreover, the same results hold if we restrict to Codd tables, and/or to the uniform setting.

par #Val(𝑞).

Proof. We first present the proof for #Val(𝑞′) ⩽p

par #Val(𝑞), that is, for naive tables in the non-
uniform setting. First of all, observe that we can assume without loss of generality that we did not
reorder the variables in the atoms nor renamed relation names or variables by fresh ones, because,
as mentioned above, this does not change the complexity of the problem.3 We can then write 𝑞 as

1We remind the reader that we assume all sjfBCQs to contain at least one atom and that all atoms must contain at least one
variable.
2This is in particular because the conjunctive queries we consider have no self-joins (otherwise, reordering variables inside
an atom could change the complexity).
3Formally, one can first check that we can assume without loss of generality that 𝑞′ was obtained from 𝑞 by first deleting
some atoms and variable occurences to obtain a query 𝑞′′, and then performing some renamings and variable reorderings
to obtain 𝑞′ (that is, we can always push the renaming and reordering parts at the end of the transformation). But then,
since #Val(𝑞′′) and #Val(𝑞′) are obviously the same problem, we can assume 𝑞′ = 𝑞′′.

The complexity of counting problems over incomplete databases

1:9

), where 1 ⩽ 𝑗1 < . . . < 𝑗𝑝 ⩽ 𝑚 and 𝑥 ′
𝑗𝑘

𝑅1 (𝑥1) ∧ . . . ∧ 𝑅𝑚 (𝑥𝑚) and 𝑞′ as 𝑅 𝑗1 (𝑥 ′
is
) ∧ . . . ∧ 𝑅 𝑗𝑝 (𝑥 ′
𝑗𝑝
𝑗1
obtained from 𝑥 𝑗𝑘 by deleting some variable occurrences but not all4, and the other atoms have
been deleted. Let 𝐷 ′ be an incomplete database input of #Val(𝑞′). Let 𝐴 be the set of constants that
are appearing in 𝐷 ′ or are in a domain of some null occurring in 𝐷 ′. For 1 ⩽ 𝑘 ⩽ 𝑝, we construct
the relation 𝐷 (𝑅 𝑗𝑘 ) from the relation 𝐷 ′(𝑅 𝑗𝑘 ). Let us assume that 𝑥 𝑗𝑘 is the tuple (𝑥1, . . . , 𝑥𝑟 ) (with
some variables possibly being equal). We initialize 𝐷 (𝑅 𝑗𝑘 ) to be empty, and then for every tuple 𝑡 ′
in 𝐷 ′(𝑅 𝑗𝑘 ) we add to 𝐷 (𝑅 𝑗𝑘 ) all the tuples 𝑡 that can be obtained from 𝑡 ′ in the following way for
1 ⩽ 𝑖 ⩽ 𝑟 :

a) If 𝑥𝑖 is a variable occurrence that has not been deleted from 𝑥 𝑗𝑘 , then copy the element
(constant or null) of 𝑡 ′ corresponding to that variable occurrence to the 𝑖-th position of 𝑡;
b) Otherwise, if 𝑥𝑖 is a variable occurrence that has been deleted from 𝑥 𝑗𝑘 , then fill the 𝑖-th

position of 𝑡 with every possible constant from 𝐴.

Then we construct the relations 𝐷 (𝑅𝑖 ) where 𝑅𝑖 does not appear in 𝑞′ (this can happen if we have
deleted the atom 𝑅𝑖 (𝑥𝑖 )) by filling it with every possible 𝑅𝑖 -fact over 𝐴. We leave the domains of all
nulls unchanged. The whole construction can be performed in polynomial time (this uses the fact
that 𝑞 is assumed to be fixed, so that the arities of the relations mentioned in 𝑞 are fixed). Hence, it
only remains to be checked that #Val(𝑞′)(𝐷 ′) = #Val(𝑞)(𝐷), that is, that the reduction works and is
indeed parsimonious. It is clear that the valuations of 𝐷 ′ are exactly the same as the valuations of 𝐷
(because they have the same sets of nulls). Hence it is enough to verify that for every valuation 𝜈,
we have 𝜈 (𝐷 ′) |= 𝑞′ if and only if 𝜈 (𝐷) |= 𝑞. Let ℎ′ be a homomorphism from 𝑞′ to 𝜈 (𝐷 ′) witnessing
that 𝜈 (𝐷 ′) |= 𝑞′ (i.e., we have ℎ′(𝑞) ⊆ 𝜈 (𝐷 ′)). Then ℎ′ can clearly be extended in the expected
way into a homomorphism ℎ from 𝑞 to 𝜈 (𝐷): this is in particular thanks to the fact that we filled
the missing columns with every possible constant. Conversely, let ℎ be a homomorphism from 𝑞
to 𝜈 (𝐷) witnessing that 𝜈 (𝐷) |= 𝑞. Then the restriction ℎ′ of ℎ to the variables occurring in 𝑞′ is
such that ℎ(𝑞′) ⊆ 𝜈 (𝐷 ′), hence we have 𝜈 (𝐷 ′) |= 𝑞′. This concludes the proof for the case of naive
tables in the non-uniform setting. For the cases of Codd tables and/or for the uniform setting, the
reduction is exactly the same. Indeed, the domains of the nulls are unchanged, and it is clear that
□
the presented construction preserves the property of being a Codd table.

The idea is then to show the #P-hardness of our problems for some simple patterns, which then
we combine with Lemma 3.3 and with some tractability proofs to obtain the desired dichotomies.
Our findings are summarized in the first two columns of Table 1 in the introduction. We first focus
on the two dichotomies for the non-uniform setting in Section 3.1, and then we move to the case of
uniform incomplete databases in Section 3.2. We explicitly state when a #P-hardness result holds
even in the restricted setting in which there is a fixed domain over which nulls are interpreted.
In other words, when there is a fixed domain 𝐴 such that the incomplete databases used in the
reductions are of the form 𝐷 = (𝑇 , dom) and dom(⊥) ⊆ 𝐴, for each null ⊥ of 𝑇 .

3.1 The complexity on the non-uniform case
In this section, we study the complexity of the problems #Val(𝑞) and #ValCd(𝑞), providing dichotomy
results in both cases. We start by proving the #P-hardness results needed for these dichotomies.
We first show that #Val(𝑅(𝑥, 𝑥)) is #P-hard by actually proving that hardness holds already in the
uniform case.

Proposition 3.4. #Valu (𝑅(𝑥, 𝑥)) is #P-hard. This holds even in the restricted setting in which all

nulls are interpreted over the same fixed domain {1, 2, 3}.

4See Footnote 1.

1:10

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

Proof. We reduce from the problem of counting the number of 3-colorings of a graph 𝐺 = (𝑉 , 𝐸),
which is #P-hard [32]. For every node 𝑣 ∈ 𝑉 we have a null ⊥𝑣, and for every edge {𝑢, 𝑣 } ∈ 𝐸 we
have the facts 𝑅(⊥𝑣, ⊥𝑢) and 𝑅(⊥𝑢, ⊥𝑣). The domain of the nulls is {1, 2, 3}. It is then clear that the
number of valuations of the constructed database that do not satisfy 𝑅(𝑥, 𝑥) is exactly the number
of 3-colorings of 𝐺. Since the total number of valuations can be computed in PTIME, this concludes
□
the reduction.

The next pattern that we consider is 𝑅(𝑥) ∧ 𝑆 (𝑥). This time, we can show #P-hardness of the

problem even for Codd databases.

Proposition 3.5. #ValCd(𝑅(𝑥) ∧ 𝑆 (𝑥)) is #P-hard.
Proof. We start by recalling the setting of consistent query answering under key constraints.
Intuitively, in this case we are given a set Σ of keys and a database 𝐷 that does not necessarily
satisfy Σ. Then the task is to reason about the set of all repairs of 𝐷 with respect to Σ [9]. In our
context, this means that one wants to count the number of repairs of 𝐷 with respect to Σ that
satisfy a given CQ 𝑞. When 𝑞 and Σ are fixed, we call this problem #Repairs(𝑞, Σ); see, e.g., [40].
We formalize these notions below.

Here we focus on the case when Σ is a set of primary keys. Recall that this means that each
relation name 𝑅 ∈ 𝜎 of arity 𝑛 comes equipped with its own key, i.e., key(𝑅) = 𝐴, where 𝐴 = ∅ or
𝐴 = [1, . . . , 𝑝] for some 𝑝 ∈ {1, . . . , 𝑛}. Henceforth, 𝐷 is inconsistent with respect to Σ if there is a
relation name 𝑅 ∈ 𝜎 and facts 𝑅( ¯𝑎), 𝑅( ¯𝑏) ∈ 𝐷 with ¯𝑎 ≠ ¯𝑏 such that
𝜋𝐴 ( ¯𝑎) = 𝜋𝐴 ( ¯𝑏).

key(𝑅) = 𝐴 and

In this case we say that the pair (𝑅( ¯𝑎), 𝑅( ¯𝑏)) is key-violating. Let us define a block in a database 𝐷
with respect to a set Σ of primary keys to be any maximal set 𝐵 of facts from 𝐷 such that the facts
in 𝐵 are pairwise key-violating. A repair of 𝐷 with respect to Σ is a subset 𝐷 ′ of 𝐷 that is obtained
by choosing exactly one tuple from each block of 𝐷 with respect to Σ.

Let us consider a schema 𝜎 with two binary relations 𝑅 ′ and 𝑆 ′, such that key(𝑅 ′) = key(𝑆 ′) = {1}.
That is, the first attribute of both 𝑅 ′ and 𝑆 ′ defines a key over such relations. We define this set of
keys over 𝜎 to be Σ. Also, let 𝑞 = ∃𝑥, 𝑦, 𝑧 (𝑅 ′(𝑦, 𝑥) ∧ 𝑆 ′(𝑧, 𝑥)). For simplicity, we write the pair (𝑞, Σ)
as 𝑅 ′(y, 𝑥) ∧ 𝑆 ′(z, 𝑥). The problem #Repairs(𝑅 ′(y, 𝑥) ∧ 𝑆 ′(z, 𝑥)), which given a database 𝐷 ′ over
schema 𝜎 aims at computing the number of repairs of 𝐷 ′ under Σ that satisfy 𝑞, is known to be
#P-complete [40].5

Now, observe that the #P-hardness of #ValCd(𝑅(𝑥) ∧ 𝑆 (𝑥)) easily follows from the hardness of
the problem #Repairs(𝑅 ′(y, 𝑥) ∧𝑆 ′(z, 𝑥)). In fact, let 𝐷 ′ be a database with binary relation 𝑅 ′, 𝑆 ′. We
construct an incomplete Codd database 𝐷 with unary relations 𝑅, 𝑆 as follows. For every constant 𝑎
that appears in the first attribute of 𝑅 ′, we have a tuple 𝑅(⊥) in 𝐷, where ⊥ is a fresh null, and
we set dom(⊥) = {𝑏 | 𝑅 ′(𝑎, 𝑏) ∈ 𝐷 ′}. For every constant 𝑎 that appears in the first attribute of 𝑆 ′,
we have a tuple 𝑆 (⊥) in 𝐷, where ⊥ is a fresh null, and we set dom(⊥) = {𝑏 | 𝑆 ′(𝑎, 𝑏) ∈ 𝐷 ′}. It is
then clear that the number of repairs of 𝐷 ′ that satisfy 𝑅 ′(y, 𝑥) ∧ 𝑆 ′(z, 𝑥) is equal to the number of
valuations of 𝐷 that satisfy 𝑅(𝑥) ∧ 𝑆 (𝑥), thus concluding the proof. We point out here that another
proof of Proposition 3.5, that uses different techniques, can be found in the conference version of
□
the article [8] (the proof that we presented here is shorter).

Already with Propositions 3.5 and 3.4, we have all the relevant hard patterns for the non-uniform

setting. We start by proving our dichotomy result for naive tables, which is our default case.

5To see that [40] establishes the hardness of 𝑞 = 𝑅′ (y, 𝑥) ∧ 𝑆′ (z, 𝑥), first apply their rewrite rule R7 (from Fig. 6) to
obtain 𝑞′ = 𝑅′ (y, 𝑥) ∧ 𝑆′ (x, 𝑥), then apply rewrite rule R10 to obtain 𝑞′′ = 𝑅′ (y, 𝑥) ∧ 𝑆′ (x, 𝑎). Then, 𝑞′′ is #P-hard by
Lemma 19, and so is 𝑞 by Lemma 7.

The complexity of counting problems over incomplete databases

1:11

Theorem 3.6 (dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥, 𝑥) or 𝑅(𝑥) ∧ 𝑆 (𝑥) is a pattern of 𝑞, then

#Val(𝑞) is #P-complete. Otherwise, #Val(𝑞) is in FP.

Proof. The #P-hardness part of the claim follows from the last two propositions and from
Lemma 3.3. We explain why the problems are in #P right after this proof. When 𝑞 does not have
any of these two patterns then all variables have exactly one occurrence in 𝑞. This implies that
every valuation 𝜈 of 𝐷 is such that 𝜈 (𝐷) satisfies 𝑞 (except when one relation is empty, in which
case the result is simply zero). We can then compute the total number of valuations in FP by simply
□
multiplying the sizes of the domains of every null in 𝐷.

Notice that in this theorem, the membership of #Val(𝑞) in #P can be established by considering a
nondeterministic Turing Machine 𝑀 that, with input a non-uniform incomplete database 𝐷, guesses
a valuation 𝜈 of 𝐷 and verifies whether 𝜈 (𝐷) satisfies 𝑞. This machine works in polynomial time as
we can verify whether 𝜈 (𝐷) satisfies 𝑞 in polynomial time (since 𝑞 is a fixed FO query). Then given
that #Val(𝑞)(𝐷) is equal to the number of accepting runs of 𝑀 with input 𝐷, we conclude that
#Val(𝑞) is in #P. Obviously, the same idea works for codd tables, that is, #ValCd(𝑞) is also in #P. But
with this restriction we obtain more tractable cases, as shown by the following dichotomy result.

Theorem 3.7 (dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥) ∧ 𝑆 (𝑥) is a pattern of 𝑞, then #ValCd (𝑞) is

#P-complete. Otherwise, #ValCd(𝑞) is in FP.

Proof. We only need to prove the tractability claim, since hardness follows from Proposition 3.5
and Lemma 3.3. We will assume without loss of generality that 𝐷 contains no constants, as we can
introduce a fresh null with domain {𝑐} for every constant 𝑐 appearing in 𝐷, and the result is again
a Codd table, and this does not change the output of the problem. Let 𝑞 be 𝑅1( ¯𝑥1) ∧ . . . ∧ 𝑅𝑚 ( ¯𝑥𝑚).
Observe that since 𝑞 does not have 𝑅(𝑥) ∧ 𝑆 (𝑥) as a pattern then any two atoms cannot have a
variable in common. But then, since 𝐷 is a Codd table we have

#ValCd (𝑞)(𝐷) =

𝑚
(cid:214)

𝑖=1

#ValCd (𝑅𝑖 ( ¯𝑥𝑖 ))(𝐷 (𝑅𝑖 )).

Hence it is enough to show how to compute #ValCd(𝑅𝑖 ( ¯𝑥𝑖 ))(𝐷 (𝑅𝑖 )) for every 1 ⩽ 𝑖 ⩽ 𝑚. Let ¯𝑡1, . . . , ¯𝑡𝑛
be the tuples of 𝐷 (𝑅𝑖 ). Let us write 𝜌 (¯𝑡 𝑗 ) for the number of valuations of the nulls appearing in ¯𝑡 𝑗
𝑗=1 𝜌 (¯𝑡 𝑗 ), so
that do not match ¯𝑥𝑖 . Clearly, #ValCd (𝑅𝑖 ( ¯𝑥𝑖 ))(𝐷 (𝑅𝑖 )) = (cid:206)
we only have to show how to compute 𝜌 (¯𝑡 𝑗 ) for 1 ⩽ 𝑗 ⩽ 𝑛. Since we can easily compute the total
number of valuations of ¯𝑡 𝑗 , it is enough to show how to compute the number of valuations of ¯𝑡 𝑗
that match ¯𝑥𝑖 . For every variable 𝑥 that appears in ¯𝑥𝑖 , compute the size of the intersection of the
domains of the corresponding nulls in ¯𝑡 𝑗 , and denote it 𝑠𝑥 . Then the number of valuations of ¯𝑡 𝑗 that
match ¯𝑥𝑖 is simply (cid:206)𝑥 appears in ¯𝑥𝑖
□
𝑠𝑥 . This concludes the proof.

⊥ appears in 𝐷 (𝑅𝑖 ) |dom(⊥)| − (cid:206)𝑛

At this stage, we have completed the first column of Table 1, and we also know that 𝑅(𝑥, 𝑥) is a
hard pattern in the uniform setting for naive tables (but not for Codd tables, by Theorem 3.7). In
the next section, we treat the uniform setting.

3.2 The complexity on the uniform case
In this section, we study the complexity of the problems #Valu(𝑞) and #Valu
Cd
dichotomy results in both cases.

(𝑞), again providing

3.2.1 Naïve tables. We start our investigation with the case of naive tables. In Proposition 3.4, we
already showed that #Valu(𝑅(𝑥, 𝑥)) is #P-hard. In the following proposition, we identify two other
simple queries for which this problem is still intractable.

1:12

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

Proposition 3.8. #Valu(𝑅(𝑥) ∧𝑆 (𝑥, 𝑦) ∧𝑇 (𝑦)) and #Valu(𝑅(𝑥, 𝑦) ∧𝑆 (𝑥, 𝑦)) are both #P-hard. This
holds even in the restricted setting in which all nulls are interpreted over the same fixed domain {0, 1}.
Proof. We reduce both problems from the problem of counting the number of independent sets
in a graph (denoted by #IS), which is #P-complete [44]. We start with #Valu(𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦)).
Let 𝑞 = 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦) and 𝐺 = (𝑉 , 𝐸) be a graph. Then we define an incomplete database 𝐷
as follows. For every node 𝑣 ∈ 𝑉 , we have a null ⊥𝑣, and the uniform domain is {0, 1}. For every
edge {𝑢, 𝑣 } ∈ 𝐸, we have facts 𝑆 (⊥𝑢, ⊥𝑣) and 𝑆 (⊥𝑣, ⊥𝑢) in 𝐷. Finally, we have facts 𝑅(1) and 𝑇 (1)
in 𝐷. For a valuation 𝜈 of the nulls, consider the corresponding subset 𝑆𝜈 of nodes of 𝐺, given
by 𝑆𝜈 = {𝑡 ∈ 𝑉 | 𝜈 (⊥𝑡 ) = 1}. This is a bijection between the valuations of the database and the
node subsets of 𝐺. Moreover, we have that 𝜈 (𝐷) ̸|= 𝑞 if and only if 𝑆𝜈 is an independent set of 𝐺.
Since the total number of valuations of 𝐷 is 2 |𝑉 |, we have that the number of independent sets
of 𝐺 is equal to 2|𝑉 | − #Valu (𝑞)(𝐷). Hence, we conclude that #IS ⩽p
T #Valu(𝑞). The idea is similar
for #Valu (𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦)): we encode the graph with the relation 𝑆 in the same way, and this time
□
we add the fact 𝑅(1, 1).

As shown in the following result, it turns out that the three aforementioned patterns are enough
to fully characterize the complexity of counting valuations for naive tables in the uniform setting.

Theorem 3.9 (dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥, 𝑥) or 𝑅(𝑥)∧𝑆 (𝑥, 𝑦)∧𝑇 (𝑦) or 𝑅(𝑥, 𝑦)∧𝑆 (𝑥, 𝑦)

is a pattern of 𝑞, then #Valu (𝑞) is #P-complete. Otherwise, #Valu (𝑞) is in FP.

The #P-completeness part of the claim follows directly from what we have proved already.
Here, the most challenging part of the proof is actually the tractability part. We only present a
simple example to give an idea of the proof technique, and defer the full proof to Appendix A.1.
We will use the following definition. Given 𝑛, 𝑚 ∈ N, let us write surj𝑛→𝑚 for the number of
surjective functions from {1, . . . , 𝑛} to {1, . . . , 𝑚}. By an inclusion–exclusion argument, one can
(cid:1) (𝑚 − 𝑖)𝑛 (for instance, see [3]). It is clear that this can be
show that surj𝑛→𝑚 = (cid:205)𝑚−1
computed in FP, when 𝑛 and 𝑚 are given in unary.

𝑖=0 (−1)𝑖 (cid:0)𝑚

𝑖

Example 3.10. Let 𝑞 be the sjfBCQ 𝑅(𝑥) ∧ 𝑆 (𝑥), and 𝐷 be an incomplete database over rela-
tions 𝑅, 𝑆. Notice that 𝑞 does not have any of the patterns mentioned in Theorem 3.9. We will show
that #Valu(𝑞) is in FP. Since 𝑞 contains only two unary atoms we can also assume without loss of
generality that the input 𝐷 is a Codd table (otherwise all valuations are satisfying).

Since we can compute in FP the total number of valuations, it is enough to show how to compute
the number of valuations of 𝐷 that do not satisfy 𝑞. Let dom be the uniform domain, 𝑑 be its
size, 𝑛𝑅 (resp., 𝑛𝑆 ) be the number of nulls in 𝐷 (𝑅) (resp., in 𝐷 (𝑆)) and 𝐶𝑅 (resp., 𝐶𝑆 ) be the set of
constants occurring in 𝐷 (𝑅) (resp., in 𝐷 (𝑆)), with 𝑐𝑅 (resp., 𝑐𝑆 ) its size. We can assume without loss
of generality that 𝐶𝑅 ∩ 𝐶𝑆 = ∅, as otherwise all the valuations are satisfying, and this is computable
in PTIME. Furthermore, we can also assume that 𝐶𝑅 ∪𝐶𝑆 ⊆ dom, since we can remove the constants
that are not in dom, as these can never match.

Let 𝑀 := dom \ (𝐶𝑅 ∪ 𝐶𝑆 ), and 𝑚 its size (i.e., with our assumptions we have 𝑚 = 𝑑 − 𝑐𝑅 − 𝑐𝑆 ).
Fix some subsets 𝑀 ′ ⊆ 𝑀 and 𝑅 ′ ⊆ 𝐶𝑅. The quantity surj𝑛𝑅 →|𝑀′ |+ |𝑅′ | then counts the number of
valuations of the nulls of 𝐷 (𝑅) that span exactly 𝑀 ′ ∪ 𝑅 ′. Moreover, letting 𝜈𝑅 be a valuation of the
nulls of 𝐷 (𝑅) that spans exactly 𝑀 ′ ∪ 𝑅 ′, the quantity (𝑑 − 𝑐𝑅 − |𝑀 ′|)𝑛𝑆 is the number of ways to
extend 𝜈𝑅 into a valuation 𝜈 of all the nulls of 𝐷 so that 𝜈 (𝐷) ̸|= 𝑞: indeed, every null of 𝐷 (𝑆) can
take any value in dom \ (𝐶𝑅 ∪ 𝑀 ′). The number of valuations of 𝐷 that do not satisfy 𝑞 is then
(keeping in mind that a null in 𝐷 (𝑅) cannot take a value in 𝐶𝑆 ):
∑︁

surj𝑛𝑅 →|𝑀′ |+|𝑅′ | × (𝑑 − 𝑐𝑅 − |𝑀 ′|)𝑛𝑆

𝑀′ ⊆𝑀
𝑅′ ⊆𝐶𝑅

The complexity of counting problems over incomplete databases

and since the summands only depends on the sizes of 𝑀 ′ and 𝑅 ′, this is equal to

(cid:19)

(cid:18) 𝑚
𝑚′

(cid:19) (cid:18)𝑐𝑅
𝑟 ′

∑︁

0⩽𝑚′⩽𝑚
0⩽𝑟 ′⩽𝑐𝑅

surj𝑛𝑅 →𝑚′+𝑟 ′ × (𝑑 − 𝑐𝑅 − 𝑚′)𝑛𝑆

This last expression can clearly be computed in PTIME.6

1:13

□

3.2.2 Codd tables. We conclude this section by turning our attention to the case of Codd tables.
Notice that none of the results proved so far provides a hard pattern in this case. We identify in the
following proposition a simple query for which the problem is intractable.

Proposition 3.11. #Valu
Cd

(𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦)) is #P-hard.

Proof. We reduce from the problem of counting the number of independent sets of a bipartite
(simple) graph, written #BIS, which is #P-hard [44]. Let 𝐺 = (𝑋 ⊔ 𝑌, 𝐸) be a bipartite graph.
Without loss of generality, we can assume that |𝑋 | = |𝑌 | = 𝑛; indeed, if |𝑋 | < |𝑌 | then we could
simply add |𝑌 | − |𝑋 | isolated nodes to complete the graph, which simply multiplies the number of
independent sets by 2|𝑌 |−|𝑋 |. Also, observe that counting the number of independent sets of 𝐺 is
the same as counting the number of pairs (𝑆1, 𝑆2) with 𝑆1 ⊆ 𝑋, 𝑆2 ⊆ 𝑌 , such that (𝑆1 × 𝑆2) ∩ 𝐸 = ∅.
We will call such a pair an independent pair. For 0 ⩽ 𝑖, 𝑗 ⩽ 𝑛, let 𝑍𝑖,𝑗 be the number of independent
pairs (𝑆1, 𝑆2) such that |𝑆1| = 𝑖 and |𝑆2| = 𝑗. It is clear that (★) the number of independent sets of 𝐺
is then #BIS(𝐺) = (cid:205)0⩽𝑖,𝑗 ⩽𝑛 𝑍𝑖,𝑗 . The idea of the reduction is to construct in polynomial time (𝑛 + 1)2
incomplete databases 𝐷𝑎,𝑏 for 0 ⩽ 𝑎, 𝑏 ⩽ 𝑛 such that, letting 𝐶𝑎,𝑏 be the number of valuations 𝜈
of 𝐷𝑎,𝑏 with 𝜈 (𝐷𝑎,𝑏) ̸|= 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦), the values of the variables 𝑍𝑖,𝑗 and 𝐶𝑖,𝑗 form a linear
system of equations AZ = C, with A an invertible matrix. This will allow us, using (𝑛 + 1)2 calls to
an oracle for #Valu
(𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧𝑇 (𝑦)), to recover the 𝑍𝑖,𝑗 values, and then to compute #BIS(𝐺)
Cd
using (★). We now explain how we construct 𝐷𝑎,𝑏 from 𝐺 for 0 ⩽ 𝑎, 𝑏 ⩽ 𝑛, and define A. First, we
fix an arbitrary linear order 𝑥1, . . . , 𝑥𝑛 of 𝑋 , and similarly 𝑦1, . . . , 𝑦𝑛 for 𝑌 . The database 𝐷𝑎,𝑏 has
constants 𝑎𝑖 for 1 ⩽ 𝑖 ⩽ 𝑛, and has a fact 𝑆 (𝑎𝑖, 𝑎 𝑗 ) whenever (𝑥𝑖, 𝑦 𝑗 ) ∈ 𝐸. It has nulls ⊥1, . . . , ⊥𝑎
and facts 𝑅(⊥𝑖 ) for 1 ⩽ 𝑖 ⩽ 𝑎 (if 𝑎 = 0 there are no such nulls and facts), and nulls ⊥′
1, . . . , ⊥′
𝑏
𝑖 ) for 1 ⩽ 𝑖 ⩽ 𝑏; in particular, this is a Codd table. The uniform domain of the nulls
and facts 𝑇 (⊥′
is {𝑎𝑖 | 1 ⩽ 𝑖 ⩽ 𝑛}. Given a valuation 𝜈 of 𝐷𝑎,𝑏, let 𝑃 (𝜈) be the pair of subsets of 𝑉 defined by

𝑃 (𝜈)

def
= ({𝑥𝑖 | ∃1 ⩽ 𝑘 ⩽ 𝑎 s.t. 𝜈 (⊥𝑘 ) = 𝑎𝑖 }, {𝑦𝑖 | ∃1 ⩽ 𝑘 ⩽ 𝑏 s.t. 𝜈 (⊥′

𝑘 ) = 𝑎𝑖 })

One can then easily check that the following two claims hold:

• For every valuation 𝜈 of 𝐷𝑎,𝑏, we have that 𝜈 (𝐷𝑎,𝑏) ̸|= 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦) iff 𝑃 (𝜈) is an

independent pair of 𝐺;7

• For every independent pair (𝑆1, 𝑆2) of 𝐺, there are exactly surj𝑎→|𝑆1 | × surj𝑏→|𝑆2 | valuations 𝜈

such that 𝑃 (𝜈) = (𝑆1, 𝑆2).

But then, we have 𝐶𝑎,𝑏 = (cid:205)0⩽𝑖,𝑗 ⩽𝑛 (surj𝑎→𝑖 × surj𝑏→𝑗 )𝑍𝑖,𝑗 . In other words, we have the linear
def
system of equations AZ = C, where A is the (𝑛 + 1)2 × (𝑛 + 1)2 matrix defined by A(𝑎,𝑏),(𝑖,𝑗)
=
surj𝑎→𝑖 × surj𝑏→𝑗 . This matrix is the Kronecker product A′ ⊗ A′ of the (𝑛 + 1) × (𝑛 + 1) matrix with
def
= surj𝑎→𝑖 . Since A′ is a triangular matrix with non-zero coefficients on the diagonal,
entries A′
𝑎,𝑖
□
it is invertible, hence so is A, which concludes the proof.

6Note that in the sum we do not need to specify that 𝑚′ + 𝑟 ′ ⩽ 𝑛𝑅 , as when 𝑎 < 𝑏 we have surj𝑎→𝑏 = 0.
7This observation, and in fact the idea of reducing from #BIS, is due to Antoine Amarilli.

1:14

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

Note that in Proposition 3.8, we proved that #Valu(𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦)) is #P-hard in the
general case where naive tables are allowed. Hence, the hardness of that query for naive tables
was in fact a consequence of Proposition 3.11. However, we decided to provide a separate proof for
Proposition 3.8, because in this case intractability holds already when nulls are interpreted over
the fixed domain {0, 1}, whereas we do not know if this is true for Codd tables.

The second pattern that we show is hard for #Valu for Codd tables is 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦). Again,
notice that we already showed this query to be hard in the case of naive tables (as Proposition 3.8),
even for a fixed domain of {0, 1}. In the case of Codd tables, hardness still holds, but the proof is
more complicated and uses domains of unbounded size (which is why we provide separate proofs).
We show:

Proposition 3.12. #Valu
Cd

(𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦)) is #P-hard.

def
= |𝐴|, and 𝑛𝐵

Proof. Let 𝑞 be the query 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦). We reduce from the problem of counting the number
of matchings of a 2-3–regular bipartite graph, which is #P-complete [14, 55]. Let 𝐺 = (𝐴 ⊔ 𝐵, 𝐸)
be a 2-3–regular bipartite graph, with the nodes in 𝐴 having degree 3 and those in 𝐵 having
def
= |𝐵|. Notice that since 𝐺 is 2-3–regular we have that 𝑛𝐵 = 3𝑛𝐴
degree 2, and let 𝑛𝐴
2 .
We say that a set 𝑆 ⊆ 𝐸 of edges of 𝐺 is an 𝐴-semimatching if every node 𝑎 of 𝐴 is adjacent
to at most 1 edge of 𝑆; formally, for every 𝑎 ∈ 𝐴 we have |{𝑒 ∈ 𝑆 | 𝑎 ∈ 𝑒}| ⩽ 1. The type of
an 𝐴-semimatching 𝑆 is the number 𝑐 of nodes in 𝐵 that are adjacent to exactly 2 edges of 𝑆;
formally, 𝑐 def
|{𝑒 ∈ 𝑆 | 𝑏 ∈ 𝑒}| = 2}|. For 0 ⩽ 𝑐 ⩽ 𝑛𝐵, we write 𝑇𝑐 for the number
of 𝐴-semimatchings of 𝐺 of type 𝑐. Observe then that 𝑇0 is simply the number of matchings of 𝐺.
The idea of the reduction is then as follows. We will construct databases 𝐷𝑘 for 0 ⩽ 𝑘 ⩽ 𝑛𝐵 such that,
letting 𝐶𝑘 be the number of valuations 𝜈 of 𝐷𝑘 such that 𝜈 (𝐷𝑘 ) ̸|= 𝑞, the values of the variables 𝑇𝑘
and 𝐶𝑘 form a system of linear equations AT = C, with A and invertible matrix. This will allow
us, using 𝑛𝐵 + 1 calls to and oracle for #Valu
(𝑞), to recover the values 𝑇𝑘 , and thus to obtain 𝑇0
Cd
in polynomial time, that is, the number of matchings of 𝐺. We now explain how to construct the
database 𝐷𝑘 for 0 ⩽ 𝑘 ⩽ 𝑛𝐵. In what follows we use the convention that {1, . . . , 𝑘 } = ∅ when 𝑘 = 0.
The database 𝐷𝑘 contains the following facts:

= |{𝑏 ∈ 𝐵 |

(1) One fact 𝑅(𝑎, ⊥𝑎) for every 𝑎 ∈ 𝐴;
(2) One fact 𝑆 (⊥𝑏, 𝑏) for every 𝑏 ∈ 𝐵;
(3) One fact 𝑆 (⊥𝑎′, 𝑎′) for every 𝑎 ∈ 𝐴 where 𝑎′ is a fresh constant. In particular, observe that

there are 𝑛𝐴 such facts. In what follows we will write 𝐴′ def

= {𝑎′ | 𝑎 ∈ 𝐴}.

2) for every (𝑎1, 𝑎2) ∈ 𝐴 × 𝐴 with 𝑎1 ≠ 𝑎2;

(4) One fact 𝑆 (𝑎1, 𝑎′
(5) One fact 𝑆 (𝑎, 𝑖) for every (𝑎, 𝑖) ∈ 𝐴 × {1, . . . , 𝑘 };
(6) One fact 𝑆 (𝑢, 𝑣) for every (𝑢, 𝑣) ∈ (𝐴 ∪ 𝐵)2 such that {𝑢, 𝑣 } is not in 𝐸.
(7) One fact 𝑅(𝑢, 𝑣) for every (𝑢, 𝑣) ∈ (𝐴′ ∪ 𝐵)2.

And finally, the (uniform) domain for all the nulls is dom def

= 𝐴 ∪ 𝐵 ∪ 𝐴′ ∪ {1, . . . , 𝑘 }. Note that
this is indeed a Codd database. Now, let us compute 𝐶𝑘 , the number of valuations 𝜈 of 𝐷𝑘 such
that 𝜈 (𝐷𝑘 ) ̸|= 𝑞. For such a valuation 𝜈 of 𝐷𝑘 such that 𝜈 (𝐷𝑘 ) ̸|= 𝑞, observe that (★) for every 𝑎 ∈ 𝐴
it holds that 𝜈 (⊥𝑎) is either 𝑎′ or is one of the nodes in 𝐵 that is a neighbor of 𝑎; this is because
otherwise, the facts from (4-6) would make the query be satisfied. Then, for a valuation 𝜈 of 𝐷𝑘
def
such that 𝜈 (𝐷𝑘 ) ̸|= 𝑞, let us define SM(𝜈)
= {{𝑎, 𝑏} | (𝑎, 𝑏) ∈ (𝐴 × 𝐵) ∩ 𝑅(𝜈 (𝐷𝑘 ))}. Because of (★),
observe that SM(𝜈) is a subset of 𝐸, and that it is in fact an 𝐴-semimatching. We can then partition

The complexity of counting problems over incomplete databases

1:15

the valuations 𝜈 of 𝐷𝑘 with 𝜈 (𝐷𝑘 ) ̸|= 𝑞 according to the type of SM(𝜈) as follows:

{𝜈 | 𝜈 is a valuation of 𝐷𝑘 with 𝜈 (𝐷𝑘 ) ̸|= 𝑞} =

(cid:196)

0⩽𝑐 ⩽𝑛𝐵

(cid:196)

(cid:196)

{𝜈 }.

𝑆: 𝑆 is an 𝐴-semimatching
of 𝐺 of type 𝑐

𝜈: 𝜈 valuation of 𝐷𝑘
𝜈 (𝐷𝑘 )̸|=𝑞
SM(𝜈)=𝑆

(2)
Fix an 𝐴-semimatching 𝑆 of 𝐺 of type 𝑐 ∈ {0, . . . , 𝑛𝐵 }, and let us count how many valuations 𝜈
of 𝐷𝑘 there are such that 𝜈 (𝐷𝑘 ) ̸|= 𝑞 and SM(𝜈) = 𝑆. First of all, observe that for such a valuation 𝜈,
the value of 𝜈 (⊥𝑎) for every 𝑎 ∈ 𝐴 is forced: it is 𝑎′ if 𝑎 is adjacent to no edge of 𝑆, and otherwise it
is 𝑏 for the unique {𝑎, 𝑏} ∈ 𝑆. Therefore we have to count how many possibilities there are for the
remaining nulls, those of the form ⊥𝑎′ and ⊥𝑏 from facts (2-3). We have:

• For a null ⊥𝑏 such that 𝑏 is adjacent to two edges of 𝑆, there are 𝑛𝐴 + 𝑘 − 2 possible values in

order to not satisfy the query. Note that there are 𝑐 such nulls ⊥𝑏.

• For a null ⊥𝑎′ such that 𝑎 is not adjacent to an edge in 𝑆 (so that we know that 𝜈 (⊥𝑎) = 𝑎′),
there are 𝑛𝐴 + 𝑘 − 1 possible values in order to not satisfy the query. For a null ⊥𝑏 such that 𝑏
is adjacent to exactly one edge {𝑎, 𝑏} of 𝑆 (i.e., we have 𝜈 (⊥𝑎) = 𝑏) there are again 𝑛𝐴 + 𝑘 − 1
possible values to not satisfy the query. Observe that in total there are 𝑛𝐴 − 2𝑐 such nulls ⊥𝑎′
or ⊥𝑏, because 𝑆 is an 𝐴-semimatching.

• For a null ⊥𝑎′ such that 𝑎 is adjacent to an edge in 𝑆 (so that we know that 𝜈 (⊥𝑎) ≠ 𝑎′)
there are 𝑛𝐴 + 𝑘 possibilities, and similarly for a null ⊥𝑏 such that 𝑏 is not adjacent to
an edge in 𝑆 there are 𝑛𝐴 + 𝑘 possible values. By the previous two items, in total there
are 𝑛𝐴 + 𝑛𝐵 − 𝑐 − (𝑛𝐴 − 2𝑐) = 𝑛𝐵 + 𝑐 such nulls ⊥𝑎′ or ⊥𝑏.

Therefore, there are exactly (𝑛𝐴 + 𝑘 − 2)𝑐 (𝑛𝐴 + 𝑘 − 1)𝑛𝐴−2𝑐 (𝑛𝐴 + 𝑘)𝑛𝐵 +𝑐 valuations 𝜈 of 𝐷𝑘 such
that 𝜈 (𝐷𝑘 ) ̸|= 𝑞 and SM(𝜈) = 𝑆. Since this depends only on the type of the 𝐴-semimatching 𝑆 (and
not on 𝑆 itself), we obtain from Equation 2 that

𝐶𝑘 = |{𝜈 | 𝜈 is a valuation of 𝐷𝑘 with 𝜈 (𝐷𝑘 ) ̸|= 𝑞}|

∑︁

=

0⩽𝑐 ⩽𝑛𝐵

𝑇𝑐 × (𝑛𝐴 + 𝑘 − 2)𝑐 (𝑛𝐴 + 𝑘 − 1)𝑛𝐴−2𝑐 (𝑛𝐴 + 𝑘)𝑛𝐵 +𝑐 .

That is, we have the linear system of equations AT = C, with A𝑘,𝑐 = (𝑛𝐴 + 𝑘 − 2)𝑐 (𝑛𝐴 +
𝑘 − 1)𝑛𝐴−2𝑐 (𝑛𝐴 + 𝑘)𝑛𝐵 +𝑐 for 0 ⩽ 𝑐, 𝑘 ⩽ 𝑛𝐵. But observe that we have A = DV, with D being
the diagonal (𝑛𝐵 + 1) × (𝑛𝐵 + 1) matrix with entries (𝑛𝐴 + 𝑘 − 2)𝑛𝐴 (𝑛𝐴 + 𝑘)𝑛𝐵 , and V being
the (𝑛𝐵 + 1) × (𝑛𝐵 + 1) Vandermonde matrix with coefficients (𝑛𝐴+𝑘−2) (𝑛𝐴+𝑘)
for 0 ⩽ 𝑘 ⩽ 𝑛𝐵. Hence
to show that A is invertible, we only need to argue that the coefficients of this Vandermonde matrix V
def
= (𝑛𝐴+𝑥−2) (𝑛𝐴+𝑥)
are all distinct. But for the function 𝑓𝑛𝐴 (𝑥)
(𝑛𝐴+𝑥−1) 3 ,
(𝑛𝐴+𝑥−1) 2
so that 𝑓𝑛𝐴 is strictly increasing on [0, 𝑛𝐵] (we assume 𝑛𝐴 ⩾ 2 without loss of generality), so that
□
all the coefficients are indeed distinct. This concludes the proof.

, one can check that 𝑓 ′

𝑛𝐴 (𝑥) =

(𝑛𝐴+𝑘−1) 2

2

As we show next, the patterns from Propositions 3.12 and 3.11 are the only hard patterns

for #Valu
Cd

. The following is then the last dichotomy of this section.

Theorem 3.13 (dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦) or 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦) is a

pattern of 𝑞, then #Valu
Cd

(𝑞) is #P-complete. Otherwise, #Valu
Cd

(𝑞) is in FP.

We only need to show the tractability part of that claim, as hardness follows from Propositions 3.12
and 3.11 and Lemma 3.3. First of all, observe that we can assume without loss of generality that
the sjfBCQ 𝑞 is connected. This is because 𝑞 has no self-join and the database 𝐷 is Codd, so,

1:16

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

letting 𝑞1, . . . , 𝑞𝑡 be the connected components of 𝑞, and letting 𝐷𝑖 be the database 𝐷 restricted to
the relations appearing in 𝑞𝑖 , we have that

#Valu

Cd (𝑞)(𝐷) =

#Valu

Cd (𝑞𝑖 )(𝐷𝑖 ).

𝑡
(cid:214)

𝑖=1
Second, notice that, for a connected sjfBCQ 𝑞, not containing any of these two patterns is
equivalent to the following: there exists a variable 𝑥 such that all atoms of 𝑞 contain variable 𝑥,
and for any two atoms of 𝑞, the only variable that they have in common is 𝑥. In other words, 𝑥
is in every atom and every other variable occurs in only one atom. For instance 𝑅1(𝑥, 𝑦, 𝑦) ∧
𝑅2(𝑥, 𝑥, 𝑧, 𝑧, 𝑧, 𝑢, 𝑢) ∧ 𝑅3(𝑥, 𝑥, 𝑣, 𝑡, 𝑡) is such a query. We now provide an example of a connected
query with only two atoms.

Example 3.14. We consider the query 𝑞 = 𝑅(𝑥, 𝑥, 𝑦, 𝑦) ∧ 𝑆 (𝑥, 𝑥). Let 𝐷 be an incomplete Codd
database over relations 𝑅, 𝑆, with uniform domain dom of size 𝑑. In this proof we will use sym-
bols 𝑎, 𝑎1, 𝑎2, . . . to denote a constant or a null, and symbols 𝑐, 𝑐1, 𝑐2, . . . to denote constants. Moreover,
unless stated otherwise, these symbols can refer to the same constant (but not to the same null
because 𝐷 is a Codd database). A fact that contains only constants is called a ground fact. Further-
more, since that database is Codd we will always represent a null with ⊥, being understood that
they are all distinct.

We start with a few simplifications. First, we assume wlog that 𝐷 does not contain ground
facts that already satisfy the query. Second, we assume wlog that 𝐷 does not contain facts of the
form 𝑅(𝑎, 𝑎′, 𝑐, 𝑐 ′) or 𝑅(𝑐, 𝑐 ′, 𝑎, 𝑎′) or 𝑆 (𝑐, 𝑐 ′) where 𝑐 and 𝑐 ′ are distinct constants. Indeed, because 𝐷
is Codd and such a fact 𝑓 can never be part of a match, we could simply remove 𝑓 from 𝐷 and
multiply the end result by the appropriate value (namely, 𝑑𝑡 where 𝑡 is the number of nulls of 𝑓 ).
Last, we assume wlog that for any fact of the form 𝑅(𝑎, 𝑎′, 𝑐, ⊥) or 𝑅(𝑎, 𝑎′, ⊥, 𝑐) or 𝑅(⊥, 𝑐, 𝑎, 𝑎′)
or 𝑅(𝑐, ⊥, 𝑎, 𝑎′) or 𝑆 (𝑐, ⊥) or 𝑆 (⊥, 𝑐), we have 𝑐 ∈ dom; indeed otherwise, those facts can never be
part of a match and we could again remove them and multiply the result by the appropriate value.
Next, we need to introduce some notation. For a fact 𝑓 of 𝐷, the type of 𝑓 is the word in {0, 1}arity(𝑓 )
that has a 1 in position 𝑖 iff the 𝑖-th element of 𝑓 is a null. For instance the type of 𝑅(⊥, ⊥, 𝑐, ⊥)
is 1101 and that of 𝑆 (𝑐, 𝑐) is 00. Observe that there are a fixed number of possible types, because
the query is fixed. For a constant 𝑐 and fact 𝑓 of 𝐷, we say that 𝑓 is 𝑐-determined if 𝑓 contains the
constant 𝑐 at a position for variable 𝑥. For instance 𝑅(⊥, 𝑐, 𝑐 ′, ⊥) is 𝑐-determined and so is 𝑆 (𝑐, 𝑐).
A fact 𝑓 that contains only nulls on the positions for 𝑥 is called free. With the simplifications of
the last paragraph, a fact of 𝐷 is either free or it is 𝑐-determined for a unique constant 𝑐. Let t be a
type of 𝐷 (for 𝑅 or for 𝑆). We say that t is free if it has only 1s in the positions corresponding to
variable 𝑥; in other words, if it is the type of a free fact. Otherwise we say that t is determined.
For a constant 𝑐 and determined type t, we write 𝑛𝑅,𝑐,t (resp., 𝑛𝑅,𝑐,t) the number of 𝑅-facts (resp.,
of 𝑆-facts) of 𝐷 that are 𝑐-determined of type t. For a free type t of 𝑅 (resp., of 𝑆) we write 𝐹𝑅,t (resp.,
𝐹𝑆,t) for the set of free 𝑅-facts (resp., of free 𝑆-facts) and f𝑅,t (resp.,ft) for its size. Let 𝑓 be a fact that
is 𝑐-determined. We write 𝛼 𝑓 for the number of valuations 𝜈 of the nulls in 𝑓 such that 𝑓 matches
the corresponding atom in 𝑞. For instance if 𝑓 is 𝑅(⊥, 𝑐, 𝑐 ′, ⊥) or again 𝑅(𝑐, 𝑐, 𝑐 ′, 𝑐 ′) then 𝛼 𝑓 = 1,
while if 𝑓 is 𝑅(𝑐, 𝑐, ⊥, ⊥) then 𝛼 𝑓 = 𝑑.8 Similarly we let 𝛽𝑓 denote the number of valuations 𝜈 of the
nulls in 𝑓 such that 𝑓 does not match the corresponding atom in 𝑞; which is then equal to 𝑑𝑡 − 𝛼 𝑓 ,
for 𝑡 the number of nulls in 𝑓 . Observe that 𝛼 𝑓 and 𝛽𝑓 depend only on the type t of 𝑓 . Hence
we will write 𝛼t and 𝛽t instead. Let 𝑓 be a free fact. We let 𝛼 𝑓 be the number of valuations of

8When 𝑓 is a ground fact – such as 𝑅 (𝑐, 𝑐, 𝑐′, 𝑐′) – we recall the mathematical convention that there exists a unique function
with emtpy domain, hence a unique valuation of the nulls of 𝑓 .

The complexity of counting problems over incomplete databases

1:17

the nulls in 𝑓 that are not on a position for variable 𝑥 that match the corresponding part of the
atom in 𝑞. For instance if 𝑓 is 𝑅(⊥, ⊥, 𝑐 ′, ⊥) then 𝛼 𝑓 = 1 and if 𝑓 is 𝑅(⊥, ⊥, ⊥, ⊥) then 𝛼 𝑓 = 𝑑. We
def
= 𝑑𝑡 − 𝑑𝛼 𝑓 where 𝑡 is the number of nulls, which correspond to the number of
also define 𝛽𝑓
valuations of the nulls in 𝑓 such that the ground fact obtained does not match its corresponding
atom. Again, since 𝛼 𝑓 and 𝛽𝑓 depend only on the free type t of 𝑓 , we will write 𝛼t and 𝛽t instead. It
is clear that we can compute all values 𝛼 𝑓 ,𝑐 and 𝛽𝑓 ,𝑐 , for every determined fact 𝑓 and constant 𝑐
of 𝐷, and values 𝛼 𝑓 for every free fact in polynomial time. Last, we fix a linear order 𝑐1, . . . , 𝑐𝑛 on
the constants 𝑐𝑖 such that there exists a fact of 𝐷 that is 𝑐𝑖 -determined.

Next, we explain how we can compute in FP the number of valuations of 𝐷 that do not satisfy 𝑞.
To do so, we will first define some quantities, and then show that we can compute these quantities
in polynomial time using a dynamic programming approach. One of these quantities will be the
number of valuations of 𝐷 that do not satisfy 𝑞, which is what we want to compute. The quantities
that we will define are of the form 𝑉 (params), where params consist of the following parameters
(†):

(a) one parameter 𝑣 whose range is 0 . . . 𝑛;
(b) one parameter 𝑞𝑅,t for every free type t ∈ {0, 1}4 of 𝑅, with range 0 . . . f𝑅,t;
(c) one parameter 𝑟𝑅 with range 0, . . . , 𝑛;
(d) one parameter 𝑟𝑆 with range 0, . . . , 𝑟𝑅;
We now explain what the quantity 𝑉 (params) with these parameters represent. To that end, we

define the incomplete database 𝐷 (params) to be the database that contains only

• all of the facts that are 𝑐𝑖 -determined for 1 ⩽ 𝑖 ⩽ 𝑣 (if 𝑣 = 0 then 𝐷𝑣 contains no determined

facts);

• for every free type t of 𝑅, 𝐷 (params) contains 𝑞𝑅,t free 𝑅-facts of 𝐷 of type t (it doesn’t matter

which ones, say the first 𝑞𝑅,t ones);

• 𝐷 (params) contains all the free 𝑆-facts of 𝐷.
(Note that parameters (c) and (d) are not used to define the database but we still write 𝐷 (params).)
The quantity 𝑉 (params) is then defined to be the number of valuations 𝜈 of database 𝐷 (params)
such that 𝜈 (𝐷 (params)) ̸|= 𝑞 and such that the following holds: (1) for every 1 ⩽ 𝑖 ⩽ 𝑟𝑆 and free
fact 𝑓 of 𝑅 or of 𝑆, the ground fact 𝜈 (𝑓 ) does not match the corresponding atom in 𝑞 with variable 𝑥
mapped to 𝑐𝑖 (this condition is empty if 𝑟𝑆 = 0); and (2) for every 𝑟𝑆 + 1 ⩽ 𝑖 ⩽ 𝑟𝑅 and every free
fact 𝑓 of 𝑅, the ground fact 𝜈 (𝑓 ) does not match 𝑅(𝑥, 𝑥, 𝑦, 𝑦) with variable 𝑥 mapped to 𝑐𝑖 (this
condition is empty if 𝑟𝑅 = 𝑟𝑆 ). By definition we then have that, when 𝑣 = 𝑛, 𝑞𝑅,t = f𝑅,t for every
free type t of 𝑅 – so that 𝐷 (params) is equal to 𝐷 –, 𝑟𝑅 = 0 and 𝑟𝑆 = 0 then 𝑉 (params) is then
equal to #Valu
(𝑞)(𝐷). Observe that there are a fixed number of parameters in params (because
Cd
the query is fixed), and that the possible values of these parameters are polynomial in the size of
the input. We explain how compute the values 𝑉 (params) by dynamic programming.

Base case. Our base case will be when 𝑣 is equal to zero (and the other parameters are arbitrary
as in (†)); in other words, the database 𝐷 (params) does not contain any determined facts, it
contains only free facts. We have to compute the number of valuations of 𝐷 (params) that do
not satisfy the query and such that (1) and (2) hold. We do so as follows. We guess a subset 𝑆𝑅
of dom \ {𝑐1, . . . , 𝑐𝑟𝑅 }; this will be the set of constants 𝑐 such that 𝑅(𝑐, 𝑐, 𝑐 ′, 𝑐 ′) ∈ 𝜈 (𝐷 (params)) for
some 𝑐 ′. We also guess a subset 𝑆𝑆 of dom \ (cid:0){𝑐1, . . . , 𝑐𝑟𝑆 } ∪ 𝑆𝑅 (cid:1); this will be the set of constants 𝑐
such that 𝑆 (𝑐, 𝑐) ∈ 𝜈 (𝐷 (params)) (observe that 𝑆𝑅 and 𝑆𝑆 are disjoint; this is in order to avoid
satisfying the query). To “achieve” these subsets, we for each free type t of 𝑅 guess a subset 𝑊𝑅,t of
the free facts of 𝑅 of type t; these will be the 𝑅-facts 𝑓 of type t such that 𝜈 (𝑓 ) matches 𝑅(𝑥, 𝑥, 𝑦, 𝑦)
with a constant in 𝑆𝑅 for variable 𝑥. Similarly we for each free type t of 𝑆 guess a subset 𝑊𝑆,t of the

1:18

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

free facts of 𝑆 of type t; these will be the 𝑆-facts 𝑓 of type t such that 𝜈 (𝑓 ) matches 𝑆 (𝑥, 𝑥) with a
constant in 𝑆𝑆 for variable 𝑥. To ensure that these subsets are indeed enough to cover 𝑆𝑅 and 𝑆𝑆 , we
surjectively assign each of the corresponding facts a constant in 𝑆𝑅 (for 𝑅-facts) or 𝑆𝑆 (for 𝑆-facts).
For such facts 𝑓 , we then choose one of the 𝛼t valuations of 𝑓 that ensure that the ground fact
obtained satisfies the correspoinding atom of the query; crucially, this quantity depends only on
the type of 𝑓 . For the remaining (free) facts 𝑓 , we choose one of the 𝛽t valuations of 𝑓 that ensure
that the ground facts obtained do not satisfy the corresponding atom of the query. In the end we
obtain that 𝑉 (params) is equal to the following expression:

∑︁

∑︁

∑︁

· · ·

∑︁

∑︁

∑︁

· · ·

𝛾

(3)

𝑆𝑅 ⊆dom\{𝑐1,...,𝑐𝑟𝑅 }

𝑆𝑆 ⊆dom\(cid:0) {𝑐1,...,𝑐𝑟𝑆 }∪𝑆𝑅(cid:1)
where t1 . . . tJ are all the free types of 𝑅, t′
1

first 𝑞𝑅,ti

free 𝑅-facts of type ti, and where, letting 𝑧 def

𝑊𝑅,t1 ⊆𝑄𝑅,t1

𝑊𝑅,tJ

⊆𝑄𝑅,tJ

𝑊𝑅,t′
1

⊆𝐹𝑆,t′
1

𝑊𝑅,t′
K

⊆𝐹𝑆,t′
K

. . . t′
K

are all the free types of 𝑆, 𝑄𝑅,ti
𝑖=1 |𝑊𝑅,ti | and 𝑧 ′ def
= (cid:205)𝐽
= (cid:205)𝐾

is the set of the

𝑖=1 |𝑊𝑆,t′

i

|, we have

𝛾 = surj𝑧→|𝑆𝑅 | × surj𝑧′→|𝑆𝑆 | × (cid:0)

𝐽
(cid:214)

𝑖=1

𝛼 |𝑊𝑅,ti
ti

|

𝛽 |𝑄𝑅,ti
ti

|−|𝑊𝑅,ti

|

(cid:1) × (cid:0)

𝐾
(cid:214)

𝑖=1

𝛼

|𝑊𝑆,t′
i
t′
i

|

𝛽

|𝐹𝑆,t′
i
t′
i

|−|𝑊𝑆,t′
i

|

(cid:1).

Obviously, we cannot compute the expression in 3 in polynomial time, since we are summing
over subsets of the input facts. However, because 𝛾 depends only on the sizes of all these sets, we
can express 𝑉 (params) as

∑︁

∑︁

∑︁

· · ·

∑︁

∑︁

· · ·

∑︁

𝛿,

(4)

0⩽𝑠𝑅 ⩽𝑑−𝑟𝑅

0⩽𝑠𝑆 ⩽𝑑−𝑟𝑆 −𝑠𝑅

0⩽𝑤𝑅,t1

0⩽𝑤𝑅,tJ

⩽𝑞𝑅,tJ

0⩽𝑤𝑅,t′
1

⩽f𝑅,t′
1

0⩽𝑤𝑅,t′
K

⩽f𝑅,t′
K

where, letting again 𝑧 def

= (cid:205)𝐽

𝑖=1 𝑤𝑅,ti

= (cid:205)𝐾

𝑖=1 𝑤𝑆,t′

i

, we have

⩽𝑞𝑅,t1
and 𝑧 ′ def

𝛿 =surj𝑧→𝑠𝑅 × surj𝑧′→𝑠𝑆 × (cid:0)

𝐽
(cid:214)

𝑖=1

𝛼 𝑤𝑅,ti
ti

𝛽𝑞𝑅,ti
ti

−𝑤𝑅,ti

(cid:1) × (cid:0)

×

(cid:18)𝑑 − 𝑑𝑅
𝑠𝑅

(cid:19) (cid:18)𝑑 − 𝑟𝑆 − 𝑠𝑅
𝑠𝑆

(cid:19)

× (cid:0)

𝐽
(cid:214)

𝑖=1

(cid:19)

(cid:18)𝑞𝑅,ti
𝑤𝑅,ti

(cid:1) × (cid:0)

𝐾
(cid:214)

𝑖=1

𝐾
(cid:214)

𝛼

𝑖=1
(cid:18) f𝑆,t′
𝑤𝑆,t′

i

i

(cid:19)

(cid:1).

𝑤𝑆,t′
i
t′
i

−𝑤𝑆,t′
i

(cid:1)

𝛽

f𝑆,t′
i
t′
i

But then, because the expression 4 contains a fixed number of nested sums (this number depends
only on the query 𝑞), and because indices and summands are polynomial, this quantity can be
computed in polynomial time. This concludes the base case, that was when 𝑣 = 0.

Inductive case. Next we explain how we can compute the quantities 𝑉 (params) (with the pa-
rameters params as in (†)) in polynomial time from quantities 𝑉 (params′) with a strictly smaller
value for parameter (a). Hence we assume that parameter 𝑣 is ⩾ 1. The idea is to get rid of the 𝑐𝑣-
determined facts of 𝐷 (params), by partitioning the valuations of 𝐷 (params) that do not satisfy 𝑞
and satisfy (1) and (2) into
(A) those valuations 𝜈 that do not satisfy the query and satisfy (1) and (2) and such that no 𝑐𝑣-
determined 𝑅-fact or free 𝑅-fact 𝑓 of 𝐷 (params) is such that 𝜈 (𝑓 ) matches 𝑅(𝑥, 𝑥, 𝑦, 𝑦) with
variable 𝑥 mapped to 𝑐𝑣; and

(B) those valuations 𝜈 that do not satisfy the query and satisfy (1) and (2) and such that at least one
𝑐𝑣-determined 𝑅-fact or free 𝑅-fact 𝑓 of 𝐷 (params) is such that 𝜈 (𝑓 ) matches 𝑅(𝑥, 𝑥, 𝑦, 𝑦)

The complexity of counting problems over incomplete databases

1:19

with variable 𝑥 mapped to 𝑐𝑣 (and thus, no 𝑐𝑣-determined 𝑆-fact or free 𝑆-fact 𝑓 of 𝐷 (params)
is such that 𝜈 (𝑓 ) matches 𝑆 (𝑥, 𝑥) with variable 𝑥 mapped to 𝑐𝑣).

To compute valuations in (A), we choose for each 𝑅-fact 𝑓 that is 𝑐𝑣-determined one of the 𝛽𝑓 ,𝑐𝑣
valuations of its nulls that is such that 𝜈 (𝑓 ) does not match 𝑅(𝑥, 𝑥, 𝑦, 𝑦), we disallow the free
facts of 𝑅 to have valuations that would match on 𝑐𝑣 by increasing 𝑟 𝑅 by one, and we choose any
valuation for the 𝑐𝑣-determined facts of 𝑆 (since we know that they will not be part of a match).
Formally, letting 𝑡𝑓 be the number of nulls of a fact 𝑓 , we have the expression

𝐴 = (cid:0) (cid:214)

𝛽𝑓 (cid:1) × (cid:0) (cid:214)

𝑑𝑡𝑓 (cid:1) × 𝑉 (params′)

𝑐𝑣 -determined
𝑅-fact 𝑓
where params′ is equal to params except that 𝑣 ′ = 𝑣 − 1 and 𝑟 ′

𝑐𝑣 -determined
𝑆-fact 𝑓

𝑅 + 1. This can be computed
in polynomial time if we know the value 𝑉 (params′). For valuations in (B), we do as follows.
We choose exactly which subset of the 𝑐𝑣-determined and free facts of 𝑅 will match 𝑅(𝑥, 𝑥, 𝑦, 𝑦)
with 𝑥 = 𝑐𝑣 by partioning according to the types, for the remaining 𝑐𝑣-determined 𝑅-facts we
choose one of the 𝛽 valuations that do not match on 𝑐𝑣, for the remaining free facts of 𝑅 we disallow
to match on 𝑐𝑣 by increasing 𝑟 𝑅 by one, for each 𝑐𝑣-determined fact 𝑓 of 𝑆 we choose one of the 𝛽𝑓 ,𝑐𝑣
valuations of 𝑓 that are such that 𝜈 (𝑓 ) is not 𝑆 (𝑐𝑣, 𝑐𝑣), and for the free facts of 𝑆 we disallow
matching on 𝑐𝑣 by increasing 𝑟𝑆 by one. Formally, letting t1, . . . , tJ be the types of the 𝑐𝑣-determined
be the free types of 𝑅 we obtain an expression of the form
𝑅-facts and t′
1

𝑅 = 𝑟 ′

, . . . , t′
J

𝐵 =

∑︁

· · ·

∑︁

∑︁

∑︁

· · ·

𝛾 × 𝛿 × 𝑉 (params′)

(5)

⩽𝑛𝑅,𝑐𝑣 ,t1
where 𝛾 is equal to 1 if (cid:205)𝐽

0⩽ℎt1

0⩽ℎtJ
𝑖=1 ℎti + (cid:205)𝐾

⩽𝑛𝑅,𝑐𝑣 ,tJ
𝑖=1 ℎt′

i

0⩽ℎ′
t′
1

⩽𝑞𝑅,t′
1

0⩽ℎ′
t′
K

⩽𝑞𝑅,t′
K

⩾ 1 and to 0 otherwise (in order to match on 𝑐𝑣 in 𝑅), 𝛿

is

𝐽
(cid:214)

(cid:0)

𝑖=1

(cid:19)

(cid:18)𝑛𝑅,𝑐𝑣,ti
ℎti

𝛼ℎti
ti

𝛽𝑛𝑅,𝑐𝑣 ,ti
ti

−ℎti

(cid:1) × (cid:0)

𝐽
(cid:214)

𝑖=1

i

(cid:18)𝑞𝑅,t′
ℎ′
t′
i

(cid:19)

𝛼

ℎ′
t′
i

t′
i

(cid:1) × (cid:0) (cid:214)

𝛽𝑓 (cid:1),

𝑐𝑣 -determined
𝑆-fact 𝑓

t

;

𝑅,t − ℎ′

𝑅,t = 𝑞′

𝑅 = 𝑟𝑅 + 1;
𝑆 = 𝑟𝑆 + 1.

and where params′ is equal to params except that:
• we have 𝑣 ′ = 𝑣 − 1;
• for every free type t of 𝑅, we have 𝑞′
• we have 𝑟 ′
• we have 𝑟 ′
The crucial point to see that expressions A and B indeed compute what we want is that we
do not need to remember exactly which susbsets of constants are disallowed to match for the
free facts, but we only need to remember their numbers (this is what allows us to use a dynamic
programming approach); and similarly for the free facts of 𝑅, we only need to remember how many
we have left at each stage of each type, but not their precise subsets. Again, if we know the values
of 𝑉 (params′) where in params′ parameter 𝑣 ′ is equal to 𝑣 − 1 then we can compute in polynomial
time the value 𝑉 (params) = 𝐴 + 𝐵. Thus, we can compute all values 𝑉 (params) in polynomial
□
time, and this concludes this example.

The proof in this example can be extended as-is to any connected sjfBCQ containing only two
atoms and having only one variable (𝑥) that joins. We claim that the same idea works for an arbitrary
number of atoms, which concludes Theorem 3.13. Since a full proof is technically tedious and does
not provide new insights, we omit it here.

1:20

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

4 DICHOTOMIES FOR COUNTING COMPLETIONS
In this section, we study the complexity of the problems of counting completions satisfying
an sjfBCQ 𝑞, in the four cases that can be obtained by considering naive or Codd tables and non-
uniform or uniform domains. We will again use the notion of pattern as introduced in Definition 3.1.
Our first step is to observe that Lemma 3.3, which we used in the last section for the problems or
counting valuations, extends to the problems of counting completions.

Lemma 4.1. Let 𝑞, 𝑞′ be sjfBCQs such that 𝑞′ is a pattern of 𝑞. Then we have that #Comp(𝑞′) ⩽p
par
#Comp(𝑞). Moreover, the same results hold if we restrict to the case of Codd tables, and/or to the
uniform setting.

Proof. The reduction is exactly the same as the one of Lemma 3.3. To show that this reduc-
tion works properly for counting completions, it is enough to observe that for every pair of
valuations 𝜈1, 𝜈2 of 𝐷 ′ (or of 𝐷, since 𝐷 and 𝐷 ′ have exactly the same set of nulls), we have
□
that 𝜈1(𝐷 ′) = 𝜈2(𝐷 ′) iff 𝜈1(𝐷) = 𝜈2(𝐷).

We will then follow the same general strategy as in the last section, i.e., prove hardness for some
simple patterns and combine these with Lemma 4.1 and tractability proofs to obtain dichotomies.
Our findings are summarized in the last two columns of Table 1 in the introduction. We start in
Section 4.1 with the non-uniform cases and continue in Section 4.2 with the uniform cases. Again,
we explicitly state when a #P-hardness result holds even in the restricted setting in which there is
a fixed domain over which nulls are interpreted.

4.1 The complexity on the non-uniform case
Here, we study the complexity of the problems #Comp(𝑞) and #CompCd (𝑞), providing dichotomy
results in both cases. In fact, it turns out that these problems are #P-hard for all sjfBCQs. To prove
this, it is enough to show that the problem #CompCd (𝑅(𝑥)) is hard, that is, even counting the
completions of a single unary table is #P-hard in the non-uniform setting.

Proposition 4.2. #CompCd (𝑅(𝑥)) is #P-hard.

Proof. We provide a polynomial-time parsimonious reduction from the problem of counting
the vertex covers of a graph, which we denote by #VC. Let 𝐺 = (𝑉 , 𝐸) be a graph. We construct
a Codd table 𝐷 using a single unary relation 𝑅 such that the number of completions of 𝐷 equals
the number of vertex covers of 𝐺. For every edge 𝑒 = {𝑢, 𝑣 } of 𝐺, we have one null ⊥𝑒 with
dom(⊥𝑒 ) = {𝑢, 𝑣 } and the fact 𝑅(⊥𝑒 ). Let 𝑎 be a fresh constant. For every node 𝑢 ∈ 𝑉 we have a
null ⊥𝑢 with dom(⊥𝑢) = {𝑢, 𝑎} and the fact 𝑅(⊥𝑢). Last, we add the fact 𝑅(𝑎). We now show that
the number of completions of 𝐷 equals the number of vertex covers of 𝐺.

Let VC(𝐺) be the set of vertex covers of 𝐺. For a valuation 𝜈 of 𝐷, define the set 𝑆𝜈 := {𝑢 ∈ 𝑉 |
𝑅(𝑢) ∈ 𝐷 }. Since the fact 𝑅(𝑎) is in every completion of 𝐷, it is clear that the number of completions
of 𝐷 is equal to |{𝑆𝜈 | 𝜈 is a valuation of 𝐷 }|. We claim that VC(𝐺) = {𝑆𝜈 | 𝜈 is a valuation of 𝐷 },
which shows that the reduction works. (⊆) Let 𝐶 ∈ VC(𝐺), and let us show that there exists a
valuation 𝜈 of 𝐷 such that 𝑆𝜈 = 𝐶. For a null of the form ⊥𝑒 with 𝑒 = {𝑢, 𝑣 } ∈ 𝐸, assuming wlog
that 𝑢 ∈ 𝐶, we define 𝜈 (⊥𝑒 ) to be 𝑢. For a null of the form ⊥𝑢 with 𝑢 ∈ 𝑉 , we define 𝜈 (⊥𝑢) to
be 𝑢 if 𝑢 ∈ 𝐶 and 𝑎 otherwise. It is then clear that 𝑆𝜈 = 𝐶. (⊇) Let 𝜈 be a valuation of 𝐷, and let
us show that 𝑆𝜈 is a vertex cover. Assume by contradiction that there is an edge 𝑒 = {𝑢, 𝑣 } such
that 𝑒 ∩ 𝑆𝜈 = ∅. By definition of 𝐷, we must have 𝜈 (⊥𝑒 ) ∈ {𝑢, 𝑣 }, so that one of 𝑢 or 𝑣 must be in 𝑆𝜈 ,
hence a contradiction. Therefore, we conclude that #VC ⩽p
□

par #CompCd (𝑅(𝑥)).

The complexity of counting problems over incomplete databases

1:21

Recall from Section 2 that, to avoid trivialities, we assume all sjfBCQs to contain at least one
atom and that all atoms have at least one variable. Using Lemma 4.1, this allows us to obtain the
following dichotomy result.

Theorem 4.3 (Dichotomy). For every sjfBCQ 𝑞, it holds that #Comp(𝑞) and #CompCd (𝑞) are #P-

hard.

Notice here that we do not claim membership in #P; in fact, we will come back to this issue in
Section 6 to show that this is unlikely to be true for naive tables. However, we can still show that
membership in #P holds for Codd tables. We then obtain:

Theorem 4.4 (Dichotomy). For every sjfBCQ 𝑞, the problem #CompCd (𝑞) is #P-complete.
Proof. Hardness is from Theorem 4.3. To show membership in #P we will actually prove a more
general result in Section 6.1. There, we show that for every Boolean query 𝑞 such that 𝑞 has model
□
checking in P the problem #CompCd (𝑞) is in #P. This in particular applies to all sjfBCQs.

4.2 The complexity on the uniform case
We now investigate the complexity of #Compu(𝑞) and #Compu
(𝑞). Recall that in the non-uniform
Cd
case, even counting the completions of a single unary table is a #P-hard problem. This no longer
holds in the uniform case, as we will show that #Compu (𝑞) is in FP for every sjfBCQ that is defined
over a schema consisting exclusively of unary relation symbols.

Such a positive result, however, cannot be extended much further. In fact, we show next
that 𝑅(𝑥, 𝑥) and 𝑅(𝑥, 𝑦) are hard patterns, both for naive and Codd tables (and, thus, we also
conclude that the problem of counting the completions of a single binary Codd table is a #P-hard
problem). We start with the case of naive tables, for which hardness even holds when nulls are
interpreted over the fixed domain {0, 1}.

Proposition 4.5. The problems #Compu (𝑅(𝑥, 𝑥)) and #Compu (𝑅(𝑥, 𝑦)) are both #P-hard, even

when nulls are interpreted over the same fixed domain {0, 1}.

Proof. We reduce from #IS, the problem of counting the number of independent sets of a graph.
Let 𝐺 = (𝑉 , 𝐸) be a graph. We will construct an incomplete database 𝐷 containing a single binary
predicate 𝑅 such that each completion of 𝐷 satisfies 𝑅(𝑥, 𝑥) and the number of completions of 𝐷
is 2 |𝑉 | + #IS(𝐺), thus establishing hardness for the two queries. For every node 𝑢 ∈ 𝑉 , we have a
null ⊥𝑢 with dom(⊥𝑢) = {0, 1}. We then construct the naive table 𝐷 as follows:

• for every node 𝑢 ∈ 𝑉 we add to 𝐷 the fact 𝑅(𝑢, ⊥𝑢);
• then for every edge {𝑢, 𝑣 } ∈ 𝐸, we add the facts 𝑅(⊥𝑢, ⊥𝑣) and 𝑅(⊥𝑣, ⊥𝑢) to 𝐷; and
• last, we add the facts 𝑅(0, 0), 𝑅(0, 1), 𝑅(1, 0), and 𝑅(⊥, ⊥), where ⊥ is a fresh null.

It is clear that every completion of 𝐷 satisfies 𝑅(𝑥, 𝑥) (thanks to the fact 𝑅(⊥, ⊥)). Let us now count
the number of completions of 𝐷. First, we observe that, thanks to the facts of the form 𝑅(𝑢, ⊥𝑢), for
𝑢 ∈ 𝑉 , for every two valuations 𝜈, 𝜈 ′ that do not assign the same value to the nulls of the form ⊥𝑢,
it is the case that 𝜈 (𝐷) ≠ 𝜈 (𝐷 ′). We then partition the completions of 𝐷 into those that contain
the fact 𝑅(1, 1), and those that do not contain 𝑅(1, 1). Because of the facts of the form 𝑅(𝑢, ⊥𝑢),
for 𝑢 ∈ 𝑉 , and thanks to the fact 𝑅(⊥, ⊥) which becomes 𝑅(1, 1) when we assign 1 to ⊥, there are
exactly 2 |𝑉 | completions of 𝐷 that contain 𝑅(1, 1). Moreover, it is easy to see that there are #IS(𝐺)
valuations 𝜈 of 𝐷 that assign 0 to ⊥ and that yield a completion not containing 𝑅(1, 1). Indeed, one
can check that a valuation of 𝐷 that assigns 0 to ⊥ yields a completion not containing 𝑅(1, 1) if
and only if the set {𝑢 ∈ 𝑉 | 𝜈 (⊥𝑢) = 1} is an independent set of 𝐺. Therefore, we conclude that the
number of completions of 𝐷 is indeed 2 |𝑉 | + #IS(𝐺), and therefore that #IS ⩽p
T #Compu(𝑞), where 𝑞
□
can be 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦).

1:22

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

Next, we prove hardness of the same queries for Codd tables (but in this case we do not know if
harness holds when nulls are interpreted over a fixed domain, as our proof will use domains of
unbounded size). We will reduce from the problem of counting the number of induced pseudoforests
of a graph, as defined next.

Definition 4.6. A graph 𝐺 is a pseudoforest if every connected component of 𝐺 contains at most
one cycle. Let 𝐺 = (𝑉 , 𝐸) be a graph. For 𝑆 ⊆ 𝐸, let us denote by 𝐺 [𝑆] the graph (𝑉 ′, 𝑆), where 𝑉 ′
is the set of nodes of 𝐺 that appear in some edge of 𝑆. The problem #PF is the problem that takes
as input a graph 𝐺 = (𝑉 , 𝐸) and outputs the number of edge sets 𝑆 ⊆ 𝐸 such that 𝐺 [𝑆] is a
pseudoforest.

Using techniques from matroid theory, the authors of [26] have shown that #PF is #P-hard on
graphs. We explain in Appendix B.1 how their proof actually shows hardness of this problem for
bipartite graphs (which we need); formally, we have:

Proposition 4.7 (Implied by [26]). The problem #PF restricted to bipartite graphs is #P-hard.

To prove that the reduction that we will present is correct, we will also need the following
folklore lemma about pseudoforests. We recall that an orientation of an undirected graph 𝐺 = (𝑉 , 𝐸)
is a directed graph that can be obtained from 𝐺 by orienting every edge of 𝐺. Equivalently, one can
see such an orientation as a function 𝑓 : 𝐸 → 𝑉 that assigns to every edge in 𝐺 a node to which it
is incident. We then have:

Lemma 4.8. A graph 𝐺 is a pseudoforest if and only if there exists an orientation of 𝐺 such that

every node has outdegree at most 1.

Proof. Folklore, see, e.g., [22, 27, 36].

Using the hardness of #PF on bipartite graphs, we are able show hardness of #Compu
Cd

and #Compu
Cd

(𝑅(𝑥, 𝑦)) as follows.

□

(𝑅(𝑥, 𝑥))

Proposition 4.9. The problems #Compu
Cd

(𝑅(𝑥, 𝑥)) and #Compu
Cd

(𝑅(𝑥, 𝑦)) are both #P-hard.

Proof. We reduce both problems from #PF on bipartite graphs. Let 𝐺 = (𝑈 ⊔ 𝑉 , 𝐸) be a bipartite
graph. We will construct a uniform Codd table 𝐷 over binary relation 𝑅 such that (1) all the
completions of 𝐷 satisfy both queries; and (2) the number of completions of 𝐷 is equal to #PF(𝐺),
thus establishing hardness. For every (𝑡, 𝑡 ′) ∈ (𝑈 ∪ 𝑉 )2 \ 𝐸, we add to 𝐷 the fact 𝑅(𝑡, 𝑡 ′); we call
these the complementary facts. For every 𝑢 ∈ 𝑈 we add to 𝐷 the fact 𝑅(𝑢, ⊥𝑢) and for every 𝑣 ∈ 𝑉
the fact 𝑅(⊥𝑣, 𝑣). Finally, we add to 𝐷 a fact 𝑅(𝑓 , 𝑓 ) where 𝑓 is a fresh constant. The uniform domain
of the nulls if dom = 𝑈 ∪𝑉 . It is clear that 𝐷 is a Codd table and that every completion of 𝐷 satisfies
both queries (thanks to the fact 𝑅(𝑓 , 𝑓 )), so (1) holds. We now prove that (2) holds. First of all, observe
that a completion 𝜈 (𝐷) of 𝐷 is uniquely determined by the set of edges {(𝑢, 𝑣) ∈ 𝐸 | 𝑅(𝑢, 𝑣) ∈ 𝜈 (𝐷)}:
this is because 𝜈 (𝐷) already contains all the complementary facts. For a set 𝑆 ⊆ 𝐸 of edges, let
us define 𝐷𝑆 to be the complete database that contains all the complementary facts and all the
facts 𝑅(𝑢, 𝑣) for (𝑢, 𝑣) ∈ 𝑆 (note that 𝐷𝑆 is not necessarily a completion of 𝐷). We now argue that
for every set 𝑆 ⊆ 𝐸, we have that 𝐷𝑆 is a completion of 𝐷 if and only if 𝐺 [𝑆] is a pseudoforest,
which would conclude the proof. By Lemma 4.8 we only need to show that 𝐷𝑆 is a completion
of 𝐷 if and only if 𝐺 [𝑆] admits an orientation with maximum outdegee 1. We show each direction
in turn. (⇒) Assume 𝐷𝑆 is a completion of 𝐷, and let 𝜈 be a valuation witnessing this fact, i.e.,
such that 𝜈 (𝐷) = 𝐷𝑆 . First, observe that we can assume without loss of generality that (★) for
every 𝑒 = (𝑢, 𝑣) ∈ 𝑆, we have either 𝜈 (⊥𝑢) = 𝑣 or 𝜈 (⊥𝑣) = 𝑢 but not both. Indeed, if we had
both then we could modify 𝜈 into 𝜈 ′ by redefining, say, 𝜈 ′(⊥𝑢) to be 𝑢, and we would still have

The complexity of counting problems over incomplete databases

1:23

that 𝜈 ′(𝐷) = 𝐷𝑆 (because 𝑅(𝑢, 𝑢) is already present in 𝐷: it is a complementary fact). We now
define an orientation 𝑓𝜈 : 𝑆 → 𝑈 ∪ 𝑉 of 𝐺 [𝑆] from 𝜈 as follows. Let 𝑒 = (𝑢, 𝑣) ∈ 𝑆. Then: if we
have 𝜈 (⊥𝑢) = 𝑣 we define 𝑓𝜈 ((𝑢, 𝑣)) to be 𝑣, i.e., we orient the (undirected) edge (𝑢, 𝑣) from 𝑢 to 𝑣.
Else, if we have 𝜈 (⊥𝑣) = 𝑢 we define 𝑓𝜈 ((𝑢, 𝑣)) to be 𝑢, i.e., we orient the (undirected) edge (𝑢, 𝑣)
from 𝑣 to 𝑢. Observe that by (★) 𝑓𝜈 is well defined. It is then easy to check that the maximal outdegree
of the directed graph defined by 𝑓𝜈 is 1: this is because for every 𝑢 ∈ 𝑈 (resp., 𝑣 ∈ 𝑉 ), there is only
one fact in 𝐷 of the form 𝑅(𝑢, null) (resp., 𝑅(null, 𝑣)), namely, the fact 𝑅(𝑢, ⊥𝑢) (resp., 𝑅(⊥𝑣, 𝑣)). (⇐)
Let 𝑓 : 𝑆 → 𝑈 ∪ 𝑉 be an orientation of 𝐺 [𝑆] with maximum outdegree 1. Let 𝜈 𝑓 be the valuation
of 𝐷 defined from 𝑓 as follows: for every 𝑢 ∈ 𝑈 (resp., 𝑣 ∈ 𝑉 ), if there is an edge (𝑢, 𝑣) ∈ 𝑆 such
that 𝑓 ((𝑢, 𝑣)) = 𝑣 (resp., such that 𝑓 ((𝑢, 𝑣)) = 𝑢), then define 𝜈 𝑓 (⊥𝑢) to be 𝑣 (resp., define 𝜈 𝑓 (⊥𝑣) to
be 𝑢). Observe that there can be at most one such edge because 𝑓 has maximum outdegree 1, so this
is well defined. If there is no such edge, define 𝜈 𝑓 (⊥𝑢) to be 𝑢 (resp., define 𝜈 𝑓 (⊥𝑣) to be 𝑣). Since all
edges in 𝑆 are given an orientation by 𝑓 , it is clear that for every (𝑢, 𝑣) ∈ 𝑆 we have 𝑅(𝑢, 𝑣) ∈ 𝜈 𝑓 (𝐷).
Moreover, since 𝜈 𝑓 (𝐷) contains all the complementary facts, we have that 𝜈 𝑓 (𝐷) = 𝐷𝑆 , which
□
shows that 𝐷𝑆 is a completion of 𝐷 and concludes this proof.

As we show next, these two patterns suffice to characterize the complexity of #Compu(𝑞)

and #Compu
Cd

(𝑞).

Theorem 4.10 (Dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦) is a pattern of 𝑞, then

#Compu(𝑞) and #Compu
Cd

(𝑞) are #P-hard. Otherwise, these problems are in FP.

From what precedes, we only have to prove the tractability part of that claim, and this for
naive tables. To this end, we define a conjunction of basic singletons sjfBCQ to be an sjfBCQ of the
form 𝐶1(𝑥1) ∧ . . . ∧ 𝐶𝑚 (𝑥𝑚), where each 𝐶𝑖 (𝑥𝑖 ) is a conjunction of unary atoms over the same
variable 𝑥𝑖 (here the 𝑥𝑖 are pairwise distinct). Since 𝑞 does not contain the pattern 𝑅(𝑥, 𝑥) nor the
pattern 𝑅(𝑥, 𝑦), observe that 𝑞 must in fact be a conjunction of basic singletons sjfBCQ. The main
difficulty is to decompose the computation in such a way that we do not count the same completion
twice. Moreover, the fact that the database is naive and not Codd, and the fact that constants can
appear everywhere, complicate a lot the description of the algorithm. For these reasons, we provide
in the next section an example that gives the intuition of the general proof, and defer the general
proof to Appendix B.2.

Note that, as in the last section, we do not claim membership in #P in the statement of Theo-
rem 4.10. However, and also as in the last section, we can show that these problems are in #P for
Codd tables, which allows us to obtain our last dichotomy for exact counting.

Theorem 4.11 (Dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦) is a pattern of 𝑞, then

#Compu
Cd

(𝑞) is #P-complete. Otherwise, this problem is in FP.

Proof. Hardness follows from Theorem 4.10, while membership in #P follows from the result
□

proven in Section 6.1.

4.3 Example of tractability for Theorem 4.10
In this section, we prove that for the query 𝑞 def
(𝑞) is in FP.
Observe that 𝑞 is a conjunction of basic singletons query, and that it is always satisfied (as long as
the database is not empty). We will show that #Compu(𝑞) is in FP. Let 𝐶𝑅𝑆, 𝐶𝑅, 𝐶𝑆 (resp, 𝑁𝑅𝑆, 𝑁𝑅, 𝑁𝑆 )
be the sets of constants (resp., nulls) that occur respectively: in 𝑅 and in 𝑆, only in 𝑅, only in 𝑆,
and denote 𝑐𝑅𝑆, 𝑐𝑅, 𝑐𝑆 (resp., 𝑛𝑅𝑆, 𝑛𝑅, 𝑛𝑆 ) their sizes. Let dom be the uniform domain of the nulls,
and let 𝑑 be its size. First of all, observe that we can assume without loss of generality that 𝐶 def
=
𝐶𝑅𝑆 ∪ 𝐶𝑅 ∪ 𝐶𝑆 ⊆ dom, as otherwise we could simply remove the facts of 𝐷 that are over constants

= 𝑅(𝑥) ∧ 𝑆 (𝑦), the problem #Compu
Cd

1:24

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

dom

𝐶𝑅𝑆

𝐼𝑅𝑆

𝐶𝑅

𝐶𝑆

𝐼𝑅

𝐼𝑆

Fig. 2. How the sets dom, 𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆, 𝐶𝑅𝑆, 𝐶𝑅 and 𝐶𝑆 from Claim 4.12 are allowed to intersect when they
satisfy (★). The sets themselves and the intersections can be empty.

that are not in dom and this would not change the result. Let 𝑐 = 𝑐𝑅𝑆 + 𝑐𝑅 + 𝑐𝑆 . The next two claims
explain how we can decompose the computation in a way that we do not count a same completion
twice (Claim 4.12), and that we count all the possible completions (Claim 4.13).

Claim 4.12. For a triplet (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) of subsets of dom satisfying the conditions (★) 𝐼𝑅 ⊆ dom \ 𝐶,
𝐼𝑆 ⊆ dom \ (𝐶 ∪ 𝐼𝑅), and 𝐼𝑅𝑆 ⊆ dom \ (𝐶𝑅𝑆 ∪ 𝐼𝑅 ∪ 𝐼𝑆 ), let us define 𝑃 (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) to be the complete
database consisting of the following facts:
(1) 𝑅(𝑎) and 𝑆 (𝑎) for 𝑎 ∈ 𝐶𝑅𝑆 ∪ 𝐼𝑅𝑆 ;
(2) 𝑅(𝑎) for 𝑎 ∈ 𝐼𝑅 ∪ (𝐶𝑅 \ 𝐼𝑅𝑆 );
(3) 𝑆 (𝑎) for 𝑎 ∈ 𝐼𝑆 ∪ (𝐶𝑆 \ 𝐼𝑅𝑆 );

Then, for any two such triplets of sets (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) and (𝐼 ′
databases 𝑃 (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) and 𝑃 (𝐼 ′

𝑅𝑆 ) are distinct.

𝑅, 𝐼 ′

𝑆, 𝐼 ′

𝑅, 𝐼 ′

𝑆, 𝐼 ′

𝑅𝑆 ) that are different, the complete

Proof. To help the reader, we have drawn in Figure 2 how the sets can intersect. If we have 𝐼𝑅𝑆 ≠
𝑆, 𝐼 ′
𝑅, 𝐼 ′
𝑅𝑆 )
𝑅 with 𝑎 ∈ 𝐼𝑅 and 𝑎 ∉ 𝐼 ′
𝑅 then one
𝑅𝑆 ) does not. Hence let us assume
□

𝑅𝑆 with 𝑎 ∈ 𝐼𝑅𝑆 and 𝑎 ∉ 𝐼 ′
𝐼 ′
does not. So let us assume now that 𝐼𝑅𝑆 = 𝐼 ′
can check that 𝑃 (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) contains the fact 𝑅(𝑎) while 𝑃 (𝐼 ′
𝑅. Using the same reasoning we obtain that 𝐼𝑆 = 𝐼 ′
that 𝐼𝑅 = 𝐼 ′

𝑅𝑆 , then 𝑃 (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) contains both facts 𝑅(𝑎) and 𝑆 (𝑎), while 𝑃 (𝐼 ′

𝑅, 𝐼 ′
𝑆 , thus completing the proof.

𝑅𝑆 . If we have 𝐼𝑅 ≠ 𝐼 ′
𝑆, 𝐼 ′

Our next step is to show that every completion of 𝐷 is of the form 𝑃 (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) for some

triplet (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) satisfying (★):

Claim 4.13. For every completion 𝐷 ′ of 𝐷, there exist a triplet (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) satisfying (★) such

that 𝐷 ′ = 𝑃 (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ).
Proof. We define:
• 𝐼𝑅

def
= 𝐷 ′(𝑅) \ (𝐶𝑅 ∪ 𝐷 ′(𝑆)); where we see 𝐷 ′(𝑅) as the set of constants occurring in relation 𝑅

of 𝐷 ′.
def
= 𝐷 ′(𝑆) \ (𝐶𝑆 ∪ 𝐷 ′(𝑅));
def
= (𝐷 ′(𝑅) ∩ 𝐷 ′(𝑆)) \ 𝐶𝑅𝑆 .

• 𝐼𝑆
• 𝐼𝑅𝑆

Then one can easily check that (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) satisfies (★) and that 𝐷 ′ = 𝑃 (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ).

□

The complexity of counting problems over incomplete databases

1:25

By combining these two claims, we have that the result that we wish to compute (which, we
recall, is simply the total number of completions of 𝐷, because any valuation satisfies the query) is
equal to

∑︁

∑︁

∑︁

check(𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 )

where check(𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 )

def
=

𝐼𝑅 ⊆dom\𝐶

𝐼𝑆 ⊆dom\(𝐶∪𝐼𝑅 )
𝐼𝑅𝑆 ⊆dom\(𝐶𝑅𝑆 ∪𝐼𝑅 ∪𝐼𝑆 )
(cid:40)1 if 𝑃 (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) is a possible completion of 𝐷
0 otherwise

.

Next, we show that the value of check(𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) can be computed in polynomial time and
actually only depends on the sizes of these sets. In order to show this, we will use the following:

Claim 4.14. We have check(𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) = 1 if and only if the following conditions hold:
(1) if 𝑛𝑅 ⩾ 1 and |𝐶𝑅 ∪ 𝐶𝑅𝑆 ∪ 𝐼𝑅𝑆 | = 0, then we have |𝐼𝑅 | ≠ 0. Intuitively, this means that the value

of a null in 𝑁𝑅 cannot be “absorbed” by 𝐶𝑅 ∪ 𝐶𝑅𝑆 ∪ 𝐼𝑅𝑆 .

(2) if 𝑛𝑆 ⩾ 1 and |𝐶𝑆 ∪ 𝐶𝑅𝑆 ∪ 𝐼𝑅𝑆 | = 0, then we have |𝐼𝑆 | ≠ 0. (Same reasonning for nulls in 𝑁𝑆 .)
(3) if 𝑛𝑅𝑆 ⩾ 1 and |𝐶𝑅𝑆 | = 0, then we have |𝐼𝑅𝑆 | ≠ 0. (Same reasonning for nulls in 𝑁𝑅𝑆 .)
(4) the following system of equations, whose variables are natural numbers between 0 and 𝑑, has a

solution:

𝑧 {𝑁𝑅 }
𝑁𝑅
𝑧 {𝑁𝑆 }
𝑁𝑆

+ 𝑧 {𝑁𝑅,𝐶𝑆 }
𝑁𝑅
+ 𝑧 {𝑁𝑆 ,𝐶𝑅 }
𝑁𝑆

⩽ 𝑛𝑅

⩽ 𝑛𝑅

⩽ 𝑐𝑅

⩽ 𝑐𝑆

⩾ |𝐼𝑅 |

⩾ |𝐼𝑆 |

+ 𝑧 {𝑁𝑅,𝑁𝑆 }
𝑁𝑅
+ 𝑧 {𝑁𝑆 ,𝑁𝑅 }
𝑁𝑆
𝑧 {𝐶𝑅,𝑁𝑆 }
𝐶𝑅
𝑧 {𝐶𝑆 ,𝑁𝑅 }
𝐶𝑆
𝑧 {𝑁𝑅 }
𝑁𝑅
𝑧 {𝑁𝑆 }
𝑁𝑆
, 𝑧 {𝐶𝑅,𝑁𝑆 }
𝐶𝑅

𝑛𝑅𝑆 + min(𝑧 {𝑁𝑅,𝐶𝑆 }

𝑁𝑅

, 𝑧 {𝐶𝑆 ,𝑁𝑅 }
𝐶𝑆

) + min(𝑧 {𝑁𝑅,𝑁𝑆 }

𝑁𝑅

, 𝑧 {𝑁𝑆 ,𝑁𝑅 }
𝑁𝑆

) + min(𝑧 {𝑁𝑆 ,𝐶𝑅 }

𝑁𝑆

) ⩾ |𝐼𝑅𝑆 |

Proof. We prove the claim informally by explaining the main ideas, because a formal proof
would be too long and not that interesting. Conditions (1-3) are easily checked to be necessary. We
now explain why condition (4) is also necessary. Suppose that 𝑃 (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) is a completion of 𝐷.
Observe that (†) to obtain the constants in 𝐼𝑅𝑆 , we had to use some or all of the following:

• the nulls in 𝑁𝑅𝑆 ; or
• the nulls in 𝑁𝑅 together with those in 𝑁𝑆 ; or
• the nulls in 𝑁𝑅 together with the constants in 𝐶𝑆 ; or
• the nulls in 𝑁𝑆 together with the constants in 𝐶𝑅.
But then, to obtain 𝑃 (𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) as a completion, we must have used three disjoint (possibly
empty) sets 𝑍 {𝑁𝑅 }
⩽ 𝑑,
we have done the same for the nulls in 𝑁𝑆 and we also used a subset of the constants of 𝐶𝑅 (and 𝐶𝑆 )
in such a way that, according to (†):

of the nulls in 𝑁𝑅 of sizes 0 ⩽ 𝑧 {𝑁𝑅 }

, 𝑍 {𝑁𝑅,𝑁𝑆 }
𝑁𝑅

, 𝑍 {𝑁𝑅,𝐶𝑆 }
𝑁𝑅

, 𝑧 {𝑁𝑅,𝑁𝑆 }
𝑁𝑅

, 𝑧 {𝑁𝑅,𝐶𝑆 }
𝑁𝑅

𝑁𝑅

𝑁𝑅

• the nulls in 𝑍 {𝑁𝑅 }

have been used to obtain the set 𝐼𝑅 (which, we recall, is the set of constants
that occur only in 𝑅 and that are not in 𝐶𝑅). Note that only the nulls in 𝑁𝑅 could have been
used to obtain constants in 𝐼𝑅. This is what the fifth equation expresses.

𝑁𝑅

• the nulls in 𝑍 {𝑁𝑅,𝐶𝑆 }

have values in 𝑍 {𝐶𝑆 ,𝑁𝑅 }

, which gives us constants in 𝐼𝑅𝑆 . Observe that

𝑁𝑅

at maximum we could obtain min(𝑧 {𝑁𝑅,𝐶𝑆 }

, 𝑧 {𝐶𝑆 ,𝑁𝑅 }
𝐶𝑆

) constants in this manner.

𝐶𝑆

𝑁𝑅

1:26

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

𝑁𝑅

𝐶𝑅

𝑁𝑆

• the nulls in 𝑍 {𝑁𝑅,𝑁𝑆 }

and those in 𝑍 {𝑁𝑅,𝑁𝑆 }

have common values, which gives us constants

in 𝐼𝑅𝑆 . Again, observe that we can get at most min(𝑧 {𝑁𝑅,𝑁𝑆 }

• the nulls in 𝑍 {𝑁𝑆 ,𝐶𝑅 }

have values in 𝑍 {𝐶𝑅,𝑁𝑆 }

) constants using these.
, which gives us constants in 𝐼𝑅𝑆 . Observe that

, 𝑧 {𝑁𝑆 ,𝑁𝑅 }
𝑁𝑆

𝑁𝑅

𝑁𝑅

𝑁𝑆

at maximum we could obtain min(𝑧 {𝑁𝑆 ,𝐶𝑅 }

, 𝑧 {𝐶𝑅,𝑁𝑆 }
𝐶𝑅

) constants in this manner.

The first 4 equations express the partitioning process, and the last equation then expresses that by
combining all these constants we indeed obtained the whole set 𝐼𝑅𝑆 .

We now explain why conditions (2-4) are sufficient. If |𝐼𝑅 |, |𝐼𝑆 | and 𝐼𝑅𝑆 are all ⩾ 1 then condition (4)
is sufficient, because we can use the nulls and constants as explained above, and we have enough
of them to obtain the sets 𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 . We explain what happens when 𝐼𝑅 = ∅ for instance. In that
case, condition (1) ensures us that we have either 𝑛𝑅 = 0 or 𝐶𝑅 ∪ 𝐶𝑅𝑆 ∪ 𝐼𝑅𝑆 ≠ ∅. If we have 𝑛𝑅 = 0
then it is fine, since the only nulls that could be used to fill 𝐼𝑅 are those in 𝑁𝑅. If we have 𝑛𝑅 ⩾ 1
and 𝐶𝑅 ∪ 𝐶𝑅𝑆 ∪ 𝐼𝑅𝑆 ≠ ∅ then we can use these to absorb the values of the nulls in 𝑁𝑅, and we are
fine (i.e., we will be able to obtain 𝐼𝑅 = ∅). We leave it to the reader to complete the small gaps in
□
this proof.

Using this, we have that the value of check(𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) only depends on the sizes of 𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 , and

moreover can be computed in polynomial time

Claim 4.15. The value of check(𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) only depends on |𝐼𝑅 |, |𝐼𝑆 |, |𝐼𝑅𝑆 |, 𝑛𝑅, 𝑛𝑆, 𝑛𝑅𝑆, 𝑐𝑅, 𝑐𝑆, 𝑐𝑅𝑆 ,

and can be computed in FP.

Proof. The fact that this value only depends on the sizes of these sets is simply by inspection of
the conditions in Claim 4.14. Conditions (1-3) can obviously be checked in PTIME. The fact that
condition (4) can be checked in PTIME is because we can test all possible assignments between 0
and 𝑑 for all these variables and see if there is one assignment that satisfies the equations; indeed,
□
observe that the number of variables is fixed because the query is fixed.

But then, we can express the result as follows

∑︁

0⩽𝑖𝑅,𝑖𝑆 ,𝑖𝑅𝑆 ⩽𝑑

(cid:18)𝑑 − 𝑐
𝑖𝑅

(cid:19) (cid:18)𝑑 − 𝑐 − 𝑖𝑅
𝑖𝑆

(cid:19) (cid:18)𝑑 − 𝑐𝑅𝑆 − 𝑖𝑅 − 𝑖𝑆
𝑖𝑅𝑆

(cid:19)

× check(𝑖𝑅, 𝑖𝑆, 𝑖𝑅𝑆 )

and we can evaluate this expression as-is in FP because computing check(𝐼𝑅, 𝐼𝑆, 𝐼𝑅𝑆 ) ∈ {0, 1} is in
PTIME by the last claim. This concludes this (long) example.

5 APPROXIMATING THE NUMBERS OF VALUATIONS AND COMPLETIONS
As we saw in the previous sections, counting valuations and completions of an incomplete database
are usually intractable problems. However, this does not necessarily rule out the existence of efficient
approximation algorithms for such counting problems, in particular if some source of randomization
is allowed. In this section, we investigate this question by focusing on the well-known notion of
Fully Polynomial-time Randomized Approximation Scheme (FPRAS) for counting problems [33].
Formally, let Σ be a finite alphabet and 𝑓 : Σ∗ → N be a counting problem. Then 𝑓 is said to have
an FPRAS if there is a randomized algorithm A : Σ∗ × (0, 1) → N and a polynomial 𝑝 (𝑢, 𝑣) such
that, given 𝑥 ∈ Σ∗ and 𝜀 ∈ (0, 1), algorithm A runs in time 𝑝 (|𝑥 |, 1/𝜀) and satisfies the following
condition:

Pr(cid:0)|𝑓 (𝑥) − A (𝑥, 𝜀)| ⩽ 𝜀 𝑓 (𝑥)(cid:1) ⩾

3
4

.

Observe that the property of having an FPRAS is closed under polynomial-time parsimonious
reductions, that is, if we have an FPRAS for a counting problem 𝐴 and for counting problem 𝐵 we
have that 𝐵 ⩽p

par 𝐴, then we also have an FPRAS for 𝐵.

The complexity of counting problems over incomplete databases

1:27

In the following sections, we investigate the existence of FPRAS for the problems of counting
valuations and completions of an incomplete database. The overall picture that we obtain is shown
in Table 2. We first deal with counting valuations in Section 5.1, where we show a general condition
under which this problem has an FPRAS (which will apply, in particular, to all Boolean conjunctive
queries). Then, in Section 5.2, we show that the situation is quite different for counting completions,
as in most cases this problem does not admit an FPRAS.

5.1 Approximating the number of valuations
To prove the main result of this section, we need to consider the counting complexity class SpanL [5].
Given a finite alphabet Σ, an NL-transducer 𝑀 over Σ is a nondeterministic Turing Machine with
input and output alphabet Σ, a read-only input tape, a write-only output tape (where the head
is always moved to the right once a symbol in Σ is written on it, so that the output cannot be
read by 𝑀), and a work-tape of which, on input 𝑥, only the first 𝑐 · log(|𝑥 |) cells can be used for
a fixed constant 𝑐 > 0 (so that the space used by 𝑀 is logarithmic). Moreover, 𝑦 ∈ Σ∗ is said to
be an output of 𝑀 with input 𝑥, if there exists an accepting run of 𝑀 with input 𝑥 such that 𝑦 is
the string in the output tape when 𝑀 halts. Then a function 𝑓 : Σ∗ → N is said to be in SpanL if
there exists an NL-transducer 𝑀 over Σ such that for every 𝑥 ∈ Σ∗, the value 𝑓 (𝑥) is equal to the
number of distinct outputs of 𝑀 with input 𝑥. In [5], it was proved that SpanL ⊆ #P, and also that
this inclusion is strict unless NL = NP.

Very recently, the authors of [10] have shown that every problem in SpanL has an FPRAS.

Theorem 5.1 ([10, Corollary 3]). Every problem in SpanL has an FPRAS.

By using this result, we can give a general condition on a Boolean query 𝑞 under which #Val(𝑞)
has an FPRAS, as this condition ensures that #Val(𝑞) is in SpanL. More precisely, a Boolean query 𝑞
is said to be monotone if for every pair of (complete) databases 𝐷, 𝐷 ′ such that 𝐷 ⊆ 𝐷 ′, if 𝐷 |= 𝑞,
then 𝐷 ′ |= 𝑞. Moreover, 𝑞 is said to have bounded minimal models if there exists a constant 𝐶𝑞
(that depends only on 𝑞) satisfying that for every (complete) database 𝐷, if 𝐷 |= 𝑞, then there
exists 𝐷 ′ ⊆ 𝐷 such that 𝐷 ′ |= 𝑞 and the number of facts in 𝐷 ′ is at most 𝐶𝑞. Finally, the model
checking problem for 𝑞, denoted by MC(𝑞), is the problem of deciding, given a (complete) database 𝐷,
whether 𝐷 |= 𝑞. Then 𝑞 is said to have a model checking in a complexity class C if MC(𝑞) ∈ C.
With this terminology, we can state the main result of this section.

Proposition 5.2. Assume that a Boolean query 𝑞 is monotone, has model checking in nondeter-

ministic linear space, and has bounded minimal models. Then #Val(𝑞) is in SpanL.

Proof. Let 𝐷 be the input incomplete database, with the domains for each null. First, the machine
guesses a subset 𝐷 ′ ⊆ 𝐷 of size ⩽ 𝐶𝑞, such that each fact of 𝐷 ′ is over a relation symbol that appears
in 𝑞. Observe that 𝐷 ′ contains at most |𝐷 ′| × arity(𝑞) ⩽ 𝐶𝑞 × arity(𝑞) distinct nulls, and that this
is a constant. The machine then guesses and remembers a valuation 𝜈 of 𝐷 ′ and computes 𝜈 (𝐷 ′).
The encoding size ||𝜈 (𝐷 ′)|| of 𝜈 (𝐷 ′) is 𝑂 (log |𝐷 |), so the machine can check in nondeterministic
linear space whether 𝜈 (𝐷 ′) |= 𝑞, and stops and rejects in the branches that fail the test. Then, the
machine reads the input tape left to right and for every occurrence of a null ⊥ (appearing in 𝐷)
that it finds, it does the following:

• It checks whether ⊥ appears before on the input tape and if so it simply continues;
• Else if ⊥ does not appear before on the input tape but appears in 𝐷 ′ then the machine

writes 𝜈 (⊥) on its output tape;

• Else if ⊥ does not appear before on the input tape and does not appear in 𝐷 ′ then it guesses
a value for it and writes that value on the output tape (but it does not remember that value).

1:28

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

It is easy to see that this procedure can be carried out by a logspace nondeterministic transducer,
so we only need to show that the distinct outputs of the machine correspond exactly to the distinct
valuations 𝜈 of 𝐷 such that 𝜈 (𝐷) |= 𝑞. Since the machine writes values for nulls in order of first
appearance on the input tape, it is clear that every valuation is outputted exactly once. Let 𝜈 be a
valuation that is outputted, and let 𝐷 ′ be the subdatabase such that 𝜈 (𝐷 ′) |= 𝑞. Since 𝜈 (𝐷 ′) ⊆ 𝜈 (𝐷)
and 𝑞 is monotone, we have 𝜈 (𝐷) |= 𝑞. Inversely, let 𝜈 be a valuation of 𝐷 such that 𝜈 (𝐷) |= 𝑞, and
let us show that it must be outputted. Since 𝜈 (𝐷) |= 𝑞 and 𝑞 has bounded minimal models, there
exists 𝐷𝜈 ⊆ 𝜈 (𝐷) of size ⩽ 𝐶𝑞 such that 𝐷𝜈 |= 𝑞. But 𝐷𝜈 is 𝜈 (𝐷 ′) for some 𝐷 ′ ⊆ 𝐷 of size ⩽ 𝐶𝑞.
Then it is clear that one of the branches of the machine has guessed 𝐷 ′ and then 𝜈 |𝐷′ and then has
□
written 𝜈 on the output tape.

In particular, given that a union of Boolean of conjunctive queries satisfies the three proper-
ties of the previous proposition, we conclude from Theorem 5.1 that #Val(𝑞) can be efficiently
approximated by using a randomized algorithm if 𝑞 is a union of BCQs.9

Corollary 5.3. If 𝑞 is a union of BCQs, then #Val(𝑞) has an FPRAS (and the same holds if restricted

to the uniform setting and/or to Codd tables).

We prove in the next section that the good properties stated in Proposition 5.2 do not hold for

counting completions.

5.2 Approximating the number of completions
In this section, we prove that the problem of counting completions of an incomplete database is much
harder in terms of approximation than the problem of counting valuations. In this investigation,
two randomized complexity classes play a fundamental role. Recall that RP is the class of decision
problems 𝐿 for which there exists a polynomial-time probabilistic Turing Machine 𝑀 such that:
(a) if 𝑥 ∈ 𝐿, then 𝑀 accepts with probability at least 3/4; and (b) if 𝑥 ∉ 𝐿, then 𝑀 does not accept 𝑥.
Moreover, BPP is defined exactly as RP but with condition (b) replaced by: (b’) if 𝑥 ∉ 𝐿, then 𝑀
accepts with probability at most 1/4. Thus, BPP is defined as RP but allowing errors for both the
elements that are and are not in 𝐿. It is easy to see that RP ⊆ BPP. Besides, it is known that RP ⊆ NP,
and this inclusion is widely believed to be strict. Finally, it is not known whether BPP ⊆ NP
or NP ⊆ BPP, but it is widely believed that NP is not included in BPP.

The non-uniform case. Recall that #IS is the problem of counting the number of independent
sets of a graph. This problem will play a fundamental role when showing non-approximability of
counting completions in the non-uniform case. More precisely, the following is known about the
approximability of #IS.

Theorem 5.4 ([20, Theorem 3.1]). The problem #IS does not admit an FPRAS unless NP = RP.

In the proof of Proposition 4.2, we considered the problem #VC of counting the number of
vertex covers of a graph 𝐺 = (𝑉 , 𝐸), and showed that #VC ⩽p
par #CompCd (𝑅(𝑥)). By observing
that 𝑆 ⊆ 𝑉 is an independent set of 𝐺 if and only if 𝑉 \ 𝑆 is a vertex cover of 𝐺, we can conclude
that #IS(𝐺) = #VC(𝐺) and, thus, the same reduction from the proof of Proposition 4.2 establishes
that #IS ⩽p
par #CompCd (𝑅(𝑥)). Therefore, from the fact that the reduction in Lemma 4.1 is also
parsimonious and preserves the property of being a Codd table, and the fact that the existence of
an FPRAS is closed under polynomial-time parsimonious reductions, we obtain the following result
from Theorem 5.4.

9As a matter of fact, this holds even for the larger class of unions of BCQs with inequalities (that is, atoms of the form
𝑥 ≠ 𝑦), as such queries also satisfy the aforementioned three properties.

The complexity of counting problems over incomplete databases

1:29

Theorem 5.5 (Dichotomy). For every sjfBCQ 𝑞, it holds that #CompCd (𝑞) does not admit an

FPRAS unless NP = RP (and, hence, the same holds for #Comp(𝑞)).10

The uniform case. Recall that from Theorem 4.10, we know that if an sjfBCQ 𝑞 contains neither
𝑅(𝑥, 𝑥) nor 𝑅(𝑥, 𝑦) as a pattern, then #Compu(𝑞) is in FP. Thus, the question to answer in this
section is whether #Compu (𝑞) and #Compu
(𝑞) can be efficiently approximated if 𝑞 contains any
Cd
of these two patterns. For the case of naive tables, we will give a negative answer to this question.
Notice that, this time, our reduction from #IS in Proposition 4.5 is not parsimonious, so we cannot
use Theorem 5.4 as we did for the non-uniform case. Instead, we will rely on the following well-
known fact: if there exists a BPP algorithm for a problem that is NP-complete, then NP ⊆ BPP,
which in turn implies that NP = RP [34].

Proposition 5.6. Neither #Compu (𝑅(𝑥, 𝑥)) nor #Compu(𝑅(𝑥, 𝑦)) admits an FPRAS unless NP =
RP. This holds even in the restricted setting in which all nulls are interpreted over the same fixed
domain {1, 2, 3}.

Proof. Let 𝐺 = (𝑉 , 𝐸) be a graph. First, we explain how to construct an incomplete database 𝐷
containing a single binary relation 𝑅, with uniform domain {1, 2, 3}, and such that (a) all completions
of 𝐷 satisfy both queries; (b) if 𝐺 is 3-colorable then 𝐷 has 8 completions; and (c) if 𝐺 is not 3-
colorable then 𝐷 has 7 completions. For every node 𝑢 ∈ 𝑉 we have a null ⊥𝑢. The database 𝐷
consists of the following three disjoint sets of facts:

• For every edge {𝑢, 𝑣 } ∈ 𝐸, we have the two facts 𝑅(⊥𝑢, ⊥𝑣) and 𝑅(⊥𝑣, ⊥𝑢); we call these the

coding facts.

facts;

• We have the facts 𝑅(1, 2), 𝑅(2, 1), 𝑅(2, 3), 𝑅(3, 2), 𝑅(1, 3), and 𝑅(3, 1); we call these the triangle

• We have six fresh nulls ⊥1, ⊥′

1, ⊥2, ⊥′
𝑖 ⩽ 3; we call these the auxiliary facts;

• Last, we have a fact 𝑅(𝑐, 𝑐), where 𝑐 is a fresh constant.

2, ⊥3, ⊥′

3 and the facts 𝑅(⊥𝑖, ⊥′

𝑖 ) and 𝑅(⊥′

𝑖, ⊥𝑖 ) for 1 ⩽

It is clear that all the completions of 𝐷 satisfy both queries (thanks to the fact 𝑅(𝑐, 𝑐)), so we only
need to prove (b) and (c). Observe that a candidate completion of 𝐷 can be equivalently seen as an
undirected graph, possibly with self-loops, over the nodes {1, 2, 3} (we omit the fact 𝑅(𝑐, 𝑐) since it is
in every completion) and that contains the triangle. Thanks to the auxiliary facts, it is easy to show
that all such graphs with at least one self-loop can be obtained as a completion of 𝐷. For instance,
the completion that is triangle with a self-loop only on 1 can be obtained by assigning 1 to all the
nulls in the coding facts, assigning 1 to ⊥1, ⊥′
3. There are 7
such completions in total. Then, the completion whose graph is the triangle with no self-loops is
obtainable if and only if 𝐺 is 3-colorable (we assign a 3-coloring to the nulls in the coding facts, and
assign 1 to ⊥𝑖 and 2 to ⊥′
𝑖 for every 𝑖 ∈ {1, 2, 3}). This indeed proves (b) and (c). Next, we show that
any FRPAS with 𝜀 = 1/16 for counting the number of completions of 𝐷 would yield a BPP algorithm
to solve 3-colorability, thus implying NP = RP since 3-colorability is an NP-complete problem.

1, ⊥2 and ⊥3 and assigning 2 to ⊥′

2 and ⊥′

Let A be an FPRAS for #Compu (𝑞), with 𝑞 being 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦), and let us define a BPP
algorithm B for 3-colorability using A. On input graph 𝐺, algorithm B does the following. First,
it computes in polynomial time the naive table 𝐷 as described above. Then B calls A with in-
put (𝐷, 1/16), and if A (𝐷, 1/16) ⩾ 7.5, then B accepts, otherwise B rejects. We now prove that B is
indeed a BPP algorithm for 3-colorability. Assume first that 𝐺 is 3-colorable. Then by (b) and by def-
inition of what is an FPRAS, we have that Pr(cid:0)|8 − A (𝐷, 1/16)| ⩽ 8/16(cid:1) ⩾ 3
4 . This implies in particular
that Pr(cid:0)A (𝐷, 1/16) ⩾ 8 − 8/16(cid:1) ⩾ 3
4 . Since 8 − 8/16 = 7.5 we conclude that if 𝐺 is 3-colorable, then B
10Again, we remind the reader that, to avoid trivialities, we assume all sjfBCQs to contain at least one atom and all atoms to
have at least one variable.

1:30

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

accepts with probability at least 3/4. Next, assume that 𝐺 is not 3-colorable. Then by (c) we have
4 . This implies in particular that Pr(cid:0)A (𝐷, 1/16) ⩽ 7 + 7/16(cid:1) ⩾ 3
that Pr(cid:0)|7 − A (𝐷, 1/16)| ⩽ 7/16(cid:1) ⩾ 3
4 .
Since 7 + 7/16 < 7.5, this implies in particular that Pr(cid:0)A (𝐷, 1/16) < 7.5(cid:1) ⩾ 3
4 . From this, we conclude
that if 𝐺 is not 3-colorable, then B rejects with probability at least 3/4. This concludes the proof of
□
the proposition.

By observing again that the reduction in Lemma 4.1 is parsimonious, and that the existence of an
FPRAS is closed under parsimonious reductions, we obtain that #Compu (𝑞) cannot be efficiently
approximated if 𝑞 contains 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦) as a pattern.

Theorem 5.7 (Dichotomy). Let 𝑞 be an sjfBCQ. If 𝑞 has 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦) as a pattern, then
#Compu(𝑞) does not admit an FPRAS unless NP = RP. Otherwise, this problem is in FP (by Theo-
rem 4.10).

We do not know if this result still holds for Codd tables, or if it is possible to design an FPRAS in

this setting. We leave this question open for future research.

6 ON THE GENERAL LANDSCAPE: BEYOND #P
Recall that, when studying the complexity of counting completions for sjfBCQs in Section 4, we did
claim that these problems are in #P for Codd tables, but that we did not claim so for naive tables.
The goal of this section is then threefold. First, we want to prove that the problem of counting
completions in indeed in #P for Codd tables. Second, we want to give formal evidence that we
indeed could not show membership in #P for naive tables. Third, we want to identify a counting
complexity class that is more appropriate to describe the complexity of #Comp(𝑞). We deal with
these three objectives in the next three sections.

6.1 Membership in #P of #CompCd (𝑞)
In this section, and as promised in the proofs of Propositions 4.4 and 4.11, we show that for any
Boolean query 𝑞, if the model checking problem for 𝑞 (denoted MC(𝑞), recall the definition from
Section 5.1) is in P then the problem of counting completions for 𝑞 under Codd tables is in #P.

Proposition 6.1. If a Boolean query 𝑞 has the property that model checking is in P, then we have

that #CompCd (𝑞) is in #P.

We recall that a fact that contains only constants is a ground fact. To show Proposition 6.1,
we first prove that we can check in polynomial time if a given set of ground facts is a possible
completion of an incomplete database:

Lemma 6.2. Given as input an incomplete Codd table 𝐷 and a set 𝑆 of ground facts, we can decide

in polynomial time whether there exists a valuation 𝜈 of 𝐷 such that 𝜈 (𝐷) = 𝑆.

Proof. For every fact 𝑓 of 𝐷, let us denote by 𝑃 (𝑓 ) the set of ground facts that can be obtained
from 𝑓 via a valuation (𝑃 (𝑓 ) can be {𝑓 } if 𝑓 is already a ground fact). The first step is to check that
for every fact 𝑓 of 𝐷, it holds that (★) 𝑃 (𝑓 ) ∩ 𝑆 ≠ ∅. If this is not the case, then we know for sure
that for every valuation 𝜈 of 𝐷 we will have 𝜈 (𝐷) ⊈ 𝑆, so that we can safely reject. Next, we build
the bipartite graph 𝐺𝐷,𝑆 defined as follows: the nodes in the left partition of 𝐺𝐷,𝑆 are the facts of 𝐷,
the nodes in the right partition are the facts in 𝑆, and we connect a fact 𝑓 of 𝐷 with all the ground
facts in the right partition that are in 𝑆 ∩ 𝑃 (𝑓 ). It is clear that we can construct 𝐺𝐷,𝑆 in polynomial
time. We then compute in polynomial time the size 𝑚 of a maximum-cardinality matching of 𝐺𝐷,𝑆 ,
for instance using [21]. It is clear that we have 𝑚 ⩽ |𝑆 |. At this stage, we claim that there exists
a valuation 𝜈 of 𝐷 such that 𝜈 (𝐷) = 𝑆 if and only if 𝑚 = |𝑆 |. We prove this by analysing the two
possible cases:

The complexity of counting problems over incomplete databases

1:31

• If 𝑚 < |𝑆 |, then let us show that there is no such valuation. Indeed, assume by way of
contradiction that such a valuation 𝜈 exists. Let 𝐵 be a subset of 𝐷 of minimal size such
that 𝜈 (𝐵) = 𝑆. It is clear that such a subset exists, and moreover that its size is exactly |𝑆 |. But
then, consider the set 𝑀 of edges of 𝐺𝐷,𝑆 defined by 𝑀 def
= {(𝑓 , 𝜈 (𝑓 )) | 𝑓 ∈ 𝐵}. Then 𝑀 is a
matching of 𝐺𝐷,𝑆 of size |𝑆 |, contradicting the fact that 𝑚 is the size of a maximum-cardinality
matching.

• If 𝑚 = |𝑆 |, let us show that such a valuation exists. Let 𝑀 be a matching of 𝐺𝐷,𝑆 of size |𝑆 |.
It is clear that every node corresponding to a ground fact 𝑓 ∈ 𝑆 is incident to (exactly) one
edge of 𝑀; let us denote that edge by 𝑒𝑓 . Moreover, since 𝑀 is a matching, the mapping that
at the other end of 𝑒𝑓 is injective. Hence, we can
associates to a ground fact 𝑓 ∈ 𝑆 the fact 𝑓 ′
𝑓
define 𝜈 (⊥) of every null ⊥ occurring in such a fact 𝑓 ′
𝑓 ∈ 𝐷 to be the unique constant such
that 𝜈 (𝑓 ′
𝑓 ) = 𝑓 holds, and for every other fact 𝑓 ′ in 𝐷 not incident to an edge in 𝑀, we chose
a value for its nulls so that 𝜈 (𝑓 ′) ∈ 𝑆, which we can do thanks to (★). It is then clear that we
have 𝜈 (𝐷) = 𝑆.

But then, we can simply accept if 𝑚 = |𝑆 | and reject otherwise.

□

We can now prove Proposition 6.1:

Proof of Proposition 6.1. We define a non-deterministic turing machine 𝑀𝑞 such that, given as
input an incomplete Codd table 𝐷, its number of accepting computation paths is exactly the number
of completions of 𝐷 that satisfy 𝑞. First, compute in polynomial time the set 𝐴 def
= (cid:208)𝑓 ∈𝐷 𝑃 (𝑓 ),
where 𝑃 (𝑓 ) is defined just as in Lemma 6.2. Then, the machine 𝑀𝑞 guesses a subset 𝑆 of 𝐴. It then
checks in polynomial time if 𝑆, when seen as a database, satisfies 𝑞, and rejects if it is not the case.
Then, using Lemma 6.2, it checks in polynomial time whether there exists a valuation 𝜈 of 𝐷 such
that 𝜈 (𝐷) = 𝑆, and accepts iff this is the case. It is then clear that 𝑀𝑞 satisfies the conditions, which
□
shows that #CompCd(𝑞) is in #P.

In the next two sections, all upper bounds will be proved for the most general scenario of non-
uniform naive tables, while all lower bounds will be proved for the most restricted scenario of
uniform naive tables with a fixed domain.

6.2 Non-membership in #P of #Comp(𝑞)
We now want to show that #P is not the right complexity class for problems of the form #Comp(𝑞),
over naive tables. One could try to show membership in #P of #Comp(𝑞) as we did in the proof of
Proposition 6.1; that is, guess a set of ground facts, then check in polynomial time that it satisfies
the query and that it is a possible completion of the incomplete database. However, this proof
strategy does not work, as we show next that checking if a set of ground fact is a completion of an
incomplete database is an NP-complete problem. Moreover, this holds already for a fixed schema
containing only a binary relation and for a fixed set of ground facts.

Proposition 6.3. The exist a set 𝑆 of ground facts over binary relation 𝑅 such that the following is

NP-complete: given as input an incomplete database 𝐷 over 𝑅, decide if 𝑆 is a completion of 𝐷.

Proof. We reduce from 3-colorability. Given a graph 𝐺, we build the same incomplete data-
base 𝐷 as in the proof of Proposition 5.6, and the (fixed) set of ground facts is the triangle, that
is, 𝑆 = {𝑅(1, 2), 𝑅(2, 1), 𝑅(2, 3), 𝑅(3, 2), 𝑅(1, 3), 𝑅(3, 1)}. Then, as in that proof, we have that 𝑆 is a
□
completion of 𝐷 if and only if 𝐺 is 3-colorable.

This does not, however, constitute a proof that #Comp(𝑞) is not in #P (but it is a good hint).
To prove that #Comp(𝑞) is unlikely to be in #P, we need to define the complexity class SPP

1:32

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

introduced in [24, 28, 42]. Given a nondeterministic Turing Machine 𝑀 and a string 𝑥, let accept𝑀 (𝑥)
(resp., reject𝑀 (𝑥)) be the number of accepting (resp., rejecting) runs of 𝑀 with input 𝑥, and let
gap𝑀 (𝑥) = accept𝑀 (𝑥) − reject𝑀 (𝑥). Then a language 𝐿 is said to be in SPP [24] if there exists a
polynomial-time nondeterministic Turing Machine 𝑀 such that: (a) if 𝑥 ∈ 𝐿, then gap𝑀 (𝑥) = 1;
and (b) if 𝑥 ∉ 𝐿, then gap𝑀 (𝑥) = 0. It is conjectured that NP ⊈ SPP as, for example, for every
known polynomial-time nondeterministic Turing Machine 𝑀 accepting an NP-complete problem,
the function gap𝑀 is not bounded. In the following proposition, we show how this conjecture helps
us to reach our second goal.

Proposition 6.4. There exists an sjfBCQ 𝑞 such that #Compu(𝑞) is not in #P unless NP ⊆ SPP.
The proof of this result relies on the proof of Theorem 6.6, in the next section (we presented the
results in this order for narrative purposes). We will then defer its presentation until the proof of
Theorem 6.6 is given.

6.3 An appropriate counting complexity class for #Comp(𝑞): SpanP
To meet our third goal, we need to introduce one last counting complexity class. The class SpanP [35]
is defined exactly as the class SpanL introduced in Section 5.1, but considering polynomial-time
nondeterministic Turing machines with output, instead of logarithmic-space nondeterministic
Turing machines with output. It is straightforward to prove that #P ⊆ SpanP. Besides, it is known
that #P = SpanP if and only if NP = UP [35].11 Therefore, it is widely believed that #P is properly
included in SpanP. The following easy observation can be seen as a first hint that SpanP is a good
alternative to describe the complexity of counting completions.

Observation 6.5. If 𝑞 is a Boolean query such that MC(𝑞) is in P, then #Comp(𝑞) is in SpanP.
Notice that this result applies to all sjfBCQs and, more generally, to all FO Boolean queries.
In fact, this results applies to even more expressive query languages such as Datalog [1]. More
surprisingly, in the following theorem we show that #Compu(𝑞) can be SpanP-complete for an FO
query 𝑞 and, in fact, already for the negation of an sjfBCQ.

Theorem 6.6. There exists an sjfBCQ 𝑞 such that #Compu (¬𝑞) is SpanP-complete under

polynomial-time parsimonious reductions.

To prove this result, we will use the problem of counting the number of satisfying assignments
of a 3-CNF formula that are distinct in the first 𝑘 variables, that we denote by #k3SAT. Formally,
the problem #k3SAT takes as input a 3-CNF formula 𝐹 on variables {𝑥1, . . . , 𝑥𝑛 } and an integer
1 ⩽ 𝑘 ⩽ 𝑛, and outputs the number of assignments of the first 𝑘 variables that can be extended to a
satisfying assignment of 𝐹 . This problem is shown to be SpanP-complete in [35]:

Proposition 6.7 ([35, Section 6]). #k3SAT is SpanP complete (under polynomial-time parsimo-

nious reductions).

We are ready to prove Theorem 6.6.

Proof of Theorem 6.6. Notice that we only need to show hardness for a fixed sjfBCQ 𝑞. We
reduce from #k3SAT to #Compu (¬𝑞), for a fixed sjfBCQ 𝑞 to be defined. Let 𝐹 be a 3-CNF on
variables {𝑥1, . . . , 𝑥𝑛 }, and 1 ⩽ 𝑘 ⩽ 𝑛. We first explain how we build the incomplete database 𝐷,
and we will define the sjfBCQ 𝑞 after. For every variable 𝑥𝑖 , 1 ⩽ 𝑖 ⩽ 𝑛, we have a null ⊥𝑥𝑖 , and the
11Recall that UP is the class Unambiguous Polynomial-Time introduced in [49], and that 𝐿 ∈ UP if and only if there exists
a polynomial-time nondeterministic Turing Machine 𝑀 such that if 𝑥 ∈ 𝐿, then accept𝑀 (𝑥) = 1, and if 𝑥 ∉ 𝐿, then
accept𝑀 (𝑥) = 0.

The complexity of counting problems over incomplete databases

1:33

(uniform) domain is {0, 1}. For (𝑎, 𝑏, 𝑐) ∈ {0, 1}3, we have a relation 𝐶𝑎𝑏𝑐 of arity 3, and we fill it with
every tuple of the form 𝐶𝑎𝑏𝑐 (𝑎′, 𝑏 ′, 𝑐 ′) with (𝑎′, 𝑏 ′, 𝑐 ′) ∈ {0, 1}3 such that 𝑎 = 𝑎′∨𝑏 = 𝑏 ′∨𝑐 = 𝑐 ′ holds;
hence for every (𝑎, 𝑏, 𝑐) ∈ {0, 1}3 there are exactly 7 facts of this form. For every clause 𝐾 = 𝑙1 ∨𝑙2 ∨𝑙3
of 𝐹 with 𝑙1, 𝑙2, 𝑙3 being literals over variables 𝑦1, 𝑦2, 𝑦3, letting (𝑎1, 𝑎2, 𝑎3) ∈ {0, 1}3 be the unique
tuple such that 𝑎𝑖 = 1 iff 𝑙𝑖 is a positive literal, we add to 𝐶𝑎1𝑎2𝑎3 the fact 𝐶𝑎1𝑎2𝑎3 (⊥𝑦1, ⊥𝑦2, ⊥𝑦3). Last,
we have a binary relation 𝑆 that we fill with the tuples 𝑆 (𝑖, ⊥𝑥𝑖 ) for 1 ⩽ 𝑖 ⩽ 𝑘. The sjfBCQ 𝑞 then
simply says that there exists a tuple that appears in all the relations 𝐶𝑎𝑏𝑐 :

𝑞 = ∃𝑥∃𝑦 𝑆 (𝑥, 𝑦) ∧ ∃𝑥∃𝑦∃𝑧

(cid:18) (cid:219)

(cid:19)

𝐶𝑎𝑏𝑐 (𝑥, 𝑦, 𝑧)

(𝑎,𝑏,𝑐) ∈ {0,1}3

(6)

Note that we added the seemingly useless query ∃𝑥∃𝑦 𝑆 (𝑥, 𝑦) to 𝑞 because the set of relations in 𝐷
has to be a subset of the set of relations occurring in 𝑞 (indeed, this is how we defined our problems
in Section 2). We now show that the number of completions of 𝐷 that do not satisfy 𝑞 is equal to
the number of assignments of the first 𝑘 variables that can be extended to a satisfying assignment
of 𝐹 , thus establishing that #Compu (¬𝑞) is SpanP-hard (under polynomial-time parsimonious
reductions). First, observe that the assignments of the variables are in bijection with the valuations
of the nulls of 𝐷. One can then readily observe the following:

• If 𝑞 is falsified in a completion of 𝐷, it can only be because there does not exist a tuple that
occurs in all the relations; this is because the query ∃𝑥∃𝑦 𝑆 (𝑥, 𝑦) is always satisfied by any
completion of 𝐷.

• For every assignment of the variables, letting 𝜈 be the corresponding valuation of the nulls,
there exists a tuple that is in all relations 𝐶𝑎𝑏𝑐 of 𝜈 (𝐷) if and only if that assignment is
not satisfying for 𝐹 . Indeed, this happens if and only if there exists a relation 𝐶𝑎𝑏𝑐 such
that 𝜈 (𝐷)(𝐶𝑎𝑏𝑐 ) contains exactly 8 facts.

• For every two valuations 𝜈, 𝜈 ′ such that the corresponding assignments are not satisfying the
formula, we have that 𝜈 (𝐷) ≠ 𝜈 ′(𝐷) if and only if 𝜈 and 𝜈 ′ differ on the first 𝑘 variables. This
is because, by the previous item, each relation 𝐶𝑎𝑏𝑐 contains exactly the 7 ground tuples that
we initially put in 𝐷.

By putting it all together, we obtain that the reduction works as expected.

□

This theorem gives evidence that SpanP is the right class to describe the complexity of counting
completions for FO queries (and even for queries with model checking in polynomial time). It is
important to notice that SpanP-hardness is proved in Theorem 6.6 by considering parsimonious
reductions. This is a delicate issue, because from the main result in [48], it is possible to conclude that
every counting problem that is #P-hard (even under polynomial-time parsimonious reductions) is
also SpanP-hard under polynomial-time Turing reductions, so a more restrictive notion of reduction
has to be used when proving that a counting problem is SpanP-hard [35].

Before continuing, we prove Proposition 6.4.

|

Proof of Proposition 6.4. Let 𝑞 be the sjfBCQ defined in Equation (6) in the proof of The-
(𝑎, 𝑏, 𝑐) ∈ {0, 1}3} consists of 10 relation symbols,
orem 6.6. Its schema 𝜎 = {𝑆 } ∪ {𝐶𝑎𝑏𝑐
with 𝑆 being binary and each 𝐶𝑎𝑏𝑐 being ternary. Let us denote by #Compu(𝜎) the problem
that takes as input an incomplete database over schema 𝜎 and outputs its number of comple-
tions. The first part of our proof is to reduce #Compu(𝜎) to #Compu(𝑞); formally, we claim
that #Compu(𝜎) ⩽p
par #Compu(𝑞). Indeed, let 𝐷 be an incomplete database over schema 𝜎, that is
an input of #Compu (𝜎). We construct in polynomial time an incomplete database 𝐷 ′ over the same
schema such that #Compu (𝜎)(𝐷) = #Compu(𝑞)(𝐷 ′), thus establishing the parsimonious reduction.

1:34

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

Let 𝑓 be a fresh constant that does occurs neither in 𝐷 nor in the domain of some null. Then the rela-
tion 𝐷 ′(𝑆) is the same as the relation 𝐷 (𝑆), plus a fact 𝑆 (𝑓 , 𝑓 ). Moreover, for every (𝑎, 𝑏, 𝑐) ∈ {0, 1}3,
the relation 𝐷 ′(𝐶𝑎𝑏𝑐 ) consists of all the facts in 𝐷 (𝐶𝑎𝑏𝑐 ), plus a fact 𝐶𝑎𝑏𝑐 (𝑓 , 𝑓 , 𝑓 ). It is easy to
see that 𝐷 and 𝐷 ′ have the same number of completions. Moreover, thanks to the facts that
use the constant 𝑓 , we have that every completion of 𝐷 ′ satisfies 𝑞. Therefore, we indeed have
that #Compu(𝜎)(𝐷) = #Compu (𝑞)(𝐷 ′). This proves that #Compu (𝜎) ⩽p

par #Compu (𝑞).

For the second part of the proof, we need to introduce the complexity class GapP. This class
consists of function problems that can be expressed as the difference of two functions in #P [24, 29].
It is known that if the inclusion SpanP ⊆ GapP holds, then we have that NP ⊆ SPP [39].12 With
this, we are able to prove the proposition. Assume that #Compu(𝑞) is in #P. Then, by the first part
of the proof we have that #Compu(𝜎) ∈ #P as well (because #P is closed under polynomial-time
parsimonious reductions). Now, observe that for every incomplete database 𝐷 over 𝜎, the following
holds:

#Compu(¬𝑞)(𝐷) = #Compu (𝜎)(𝐷) − #Compu (𝑞)(𝐷).
But then this means that #Compu (¬𝑞) is in GapP (since both problems in the right hand side are
in #P). Since #Compu(¬𝑞) is SpanP-complete by Theorem 6.6 under polynomial-time parsimonious
reductions, and since GapP is closed under polynomial-time parsimonious reductions, this would
□
indeed imply that SpanP ⊆ GapP and, hence, that NP ⊆ SPP.

We conclude this section by considering an even more general scenario where queries have
model checking in NP. Interestingly, in this case SpanP is again the right class to describe the
complexity not only of counting completions, but also of counting valuations.

Theorem 6.8. If 𝑞 is a Boolean query with MC(𝑞) ∈ NP, then both #Val(𝑞) and #Comp(𝑞) are in
SpanP. Moreover, there exists such a Boolean query 𝑞 for which #Valu(𝑞) is SpanP-complete under
polynomial-time parsimonious reductions (and for #Compu(𝑞), we can even take 𝑞 to be the negation
of an sjfBCQ, hence with model checking in P, as given by Theorem 6.6).

Proof. It is straightforward to prove that these problems are in SpanP. The part in between
parenthesis has been shown in theorem 6.6. Thus, we need to prove that #Valu(𝑞) is SpanP-hard for
a fixed Boolean query 𝑞 such that MC(𝑞) ∈ NP, under polynomial-time parsimonious reductions.
To do this, we will reduce from the SpanP-complete problem #HamSubgraphs, defined as follows.
Let 𝐺 = (𝑉 , 𝐸) be a undirected graph, and let 𝑆 ⊆ 𝑉 . The subgraph of 𝐺 induced by 𝑆, denoted
by 𝐺 [𝑆], is the graph with set of nodes 𝑆 and set of edges {{𝑢, 𝑣 } ∈ 𝐸 | 𝑢, 𝑣 ∈ 𝑆 }, We recall that a
graph 𝐺 is Hamiltonian when there exists a cycle in 𝐺 that visits every node of 𝐺 exactly once. The
problem #HamSubgraphs takes as input a simple graph 𝐺 = (𝑉 , 𝐸) and an integer 𝑘, and outputs
the number of induced subgraphs 𝐺 [𝑆] with |𝑆 | = 𝑘 such that 𝐺 [𝑆] is Hamiltonian.

Proposition 6.9 ([35, Section 6]). #HamSubgraphs is SpanP-complete (under polynomial-time

parsimonious reductions).

Next we show that #HamSubgraphs ⩽p

par #Valu(𝑞), for a fixed Boolean query 𝑞 (to be defined).
Let 𝐺 = (𝑉 , 𝐸) be an undirected graph. We first explain how we construct the incomplete database 𝐷,
and we will then define the query 𝑞. The schema contains two binary relation symbols 𝑅,𝑇 and one
unary relation symbol 𝐾. Fix a linear order 𝑎1, . . . , 𝑎𝑛 of the nodes of 𝐺. For every edge {𝑢, 𝑣 } ∈ 𝐸
we have the facts 𝑅(𝑢, 𝑣) and 𝑅(𝑣, 𝑢). For 1 ⩽ 𝑖 ⩽ 𝑛 we have a fact 𝑇 (𝑎𝑖, ⊥𝑖 ), and the domain of
12In fact, the class GapSpanP is defined in [39], where it is proved that a function 𝑓 is in GapSpanP if and only if 𝑓 = 𝑔 − ℎ,
where ℎ, 𝑔 are functions in SpanP. Then it is shown in [39, Corollary 3.5] that the inclusion GapSpanP ⊆ GapP implies
that NP ⊆ SPP. But if we have that SpanP ⊆ GapP, then we also have that GapSpanP ⊆ GapP as GapP is closed under
subtraction and, therefore, we conclude that NP ⊆ SPP as desired.

The complexity of counting problems over incomplete databases

1:35

the nulls is {0, 1}. For 1 ⩽ 𝑗 ⩽ 𝑘 we have a fact 𝐾 ( 𝑗). Observe that 𝐷 is a Codd table. We now
define the Boolean query 𝑞, which will be a sentence in existential second-order logic (∃SO) over
relational signature 𝑅,𝑇 , 𝐾. Before doing so, we explain the main idea: intuitively, 𝑞 will check
that there are exactly 𝑘 facts of the form 𝑇 (𝑎𝑖, 1) in the relation 𝑇 and that, letting 𝑆 be the set
of nodes 𝑣 such that 𝑇 (𝑣, 1) is in relation 𝑇 , the induced subgraph 𝐺 [𝑆] is Hamiltonian. This will
indeed ensure that we have #Valu(𝑞)(𝐷) = #HamSubgraphs(𝐺, 𝑘), thus completing this reduction,
which is parsimonious and can be performed in polynomial-time. The query is

𝑞 = ∃𝑆 𝜓1(𝑆) ∧ 𝜓2 (𝑆)
where 𝑆 is a unary second order variable and the formula 𝜓1(𝑆) states that (a) the elements 𝑠 of 𝑆 are
exactly all the elements such that 𝑇 (𝑠, 1) holds, and that (b) there are exactly the same number of
elements in 𝑆 as there are elements 𝑗 for which 𝐾 ( 𝑗) holds. It is clear that (a) can be expressed in FO.
Moreover, (b) can be expressed in ∃SO by asserting the existence of a binary second-order relation 𝑈
that represents a bijective function from 𝑆 to the elements in 𝐾. Then 𝜓2 (𝑆) is a formula that asserts
that 𝐺 [𝑆] is Hamiltonian. Since this is a property in NP, 𝜓2(𝑆) can be expressed in ∃SO by Fagin’s
theorem (see, e.g., [31]). This shows that the reduction is correct. Finally, the fact that MC(𝑞) is in
□
NP again follows from Fagin’s theorem. This concludes the proof.

7 EXTENSIONS TO QUERIES WITH CONSTANTS AND FREE VARIABLES
So far, we have only considered our counting problems for queries that are Boolean and that do not
contain constants. In this section we explain how our framework can be adapted to queries with
constants and with free variables. Specifically, we will explain how one can obtain dichotomies for
self-join–free conjunctive queries with constants and free variables.

Before that, we have to formally define our counting problems for a query with free variables.
Let 𝑞( ¯𝑥) be a query with free variables ¯𝑥. For a tuple of constants ¯𝑡 of appropriate arity, we
write 𝑞(¯𝑡) the Boolean query obtained by substituting the variables ¯𝑥 with the constants ¯𝑡. The
problem #Val(𝑞( ¯𝑥)) then takes as input an incomplete database 𝐷 over relations sig(𝑞( ¯𝑥)), a tuple
of constants ¯𝑡, and returns the number of valuations 𝜈 of 𝐷 such that 𝜈 (𝐷) |= 𝑞(¯𝑡). We write this
output #Val(𝑞( ¯𝑥))(𝐷, ¯𝑡). The problem #Comp(𝑞( ¯𝑥)) is defined similarly.

We first explain in Section 7.1 how to obtain dichotomies for self-join-free conjunctive query with
free variables and constants, assuming we have dichotomies for self-join–free Boolean conjunctive
queries with constants. In section 7.2, we then explain how to obtain dichotomies for the later case.

7.1 Dealing with free variables
Suppose in this section that we have a dichotomy between #P-hardness and FP of our counting
problems, for every sjfBCQ that is allowed to contain constants. We then show how to obtain
dichotomies, for every self-join–free CQ that is allowed to have constants and free variables. To
this end, we will need the following definition. Let 𝑞( ¯𝑥) be a self-join-free CQ with free variables ¯𝑥,
and let ¯𝑡 and ¯𝑡 ′ be two tuples of constants with appropriate arity. We say that ¯𝑡 and ¯𝑡 ′ are equivalent
with respect to 𝑞( ¯𝑥) if one can go from 𝑞(¯𝑡) to 𝑞( ¯𝑡 ′) by iteratively renaming constants into fresh
constants. For instance, if 𝑞(𝑥1, 𝑥2) is ∃𝑦 𝑅(𝑦, 𝑐, 𝑥1, 𝑥2) ∧ 𝑆 (𝑐 ′, 𝑥), then (𝑐, 𝑐 ′′) is equivalent to (𝑐, 𝑐 ′′′),
and (𝑐 ′′, 𝑐 ′′′) and (𝑐 ′′′, 𝑐 ′′) are also equivalent. It is clear that, if 𝑞( ¯𝑥) is fixed, this defines an
equivalence relation that has only finitely many classes. Furthermore, it is also clear that if ¯𝑡 and ¯𝑡 ′ are
equivalent with respect to 𝑞( ¯𝑥) then the problems #Val(𝑞(¯𝑡)) and #Val(𝑞( ¯𝑡 ′)) (resp., #Comp(𝑞(¯𝑡))
and #Comp(𝑞( ¯𝑡 ′))) have the same complexity. We can now show what we wanted. In what follows,
hardness refers to #P-hardness (but it is not important for the proof).

Lemma 7.1. Assume that the following is true: for every sjfBCQ 𝑞 that is allowed to have constants,
the problem #Val(𝑞) is either hard or is tractable. Then the following is also true: for every self-join–free

1:36

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

conjunctive query 𝑞( ¯𝑥), the problem #Val(𝑞( ¯𝑥)) is either hard or is tractable. This holds also for
counting completions, and when restricted to Codd tables and/or to the uniform setting.

Proof. We only deal with counting valuations for the naive and non-uniform case, as the other
cases are similar. We prove the following for any self-join–free CQ 𝑞( ¯𝑥), which implies the claim:
if there exists a tuple of constants ¯𝑡 such that #Val(𝑞(¯𝑡)) is hard, then #Val(𝑞( ¯𝑥)) is hard as well,
otherwise #Val(𝑞( ¯𝑥)) is tractable. We start with the “if” direction. Let ¯𝑡 be a tuple of constants
such that #Val(𝑞(¯𝑡)) is hard. By definition, it is clear that, for any incomplete database 𝐷, we have
that #Val(𝑞(¯𝑡))(𝐷) = #Val(𝑞( ¯𝑥))(𝐷, ¯𝑡); this shows hardness of #Val(𝑞( ¯𝑥)). Now for the “otherwise”
direction. Let ¯𝑡1, . . . , ¯𝑡𝑘 be representatives of the finitely many equivalence classes of the equivalence
relation defined above. We have access to oracles for #Val(𝑞( ¯𝑡1)), . . . , #Val(𝑞( ¯𝑡𝑘 )). Let 𝐷, ¯𝑡 be an
input of #Val(𝑞( ¯𝑥)). We then simply recognize (in constant time since the query if fixed) to which ¯𝑡𝑖
the tuple ¯𝑡 is equivalent with respect to 𝑞( ¯𝑥), and call the appropriate oracle.
□

(Notice that this idea actually works for conjunctive queries (with self-joins), or even unions of
conjunctive queries.) Hence, the problem becomes that of obtaining dichotomies for self-join–free
Boolean conjunctive queries that can contain constants. We explain in the next section how this
can be done.

7.2 Dealing with constants
In this section, we simply write “an sjfBCQ” to mean an sjfBCQ that can contain some constants. To
the best of our knowledge, there is no general reduction that allows us to easily obtain dichotomies
for the case with constants from the case where queries do not have constants. Hence, the strategy to
obtain dichotomies will be the same as in Section 3; namely, we will again use the notion of pattern to
find a set of hard patterns, and then show that when a query does not have any of the hard patterns
then the problem is tractable. The notion of pattern for an sjfBCQ that can contain constants is
the same as the one we used in Definition 3.1, but we simply add the possibility of deleting an
occurrence of a constant. For instance the query 𝑅(𝑥, 𝑐) is a pattern of the query 𝑅(𝑥, 𝑥, 𝑐, 𝑐, 𝑐 ′) (in
this section all variables are existentially quantified, since we consider only Boolean queries). The
main property of patterns that we used then extends in this setting, as shown next.

Lemma 7.2. Let 𝑞, 𝑞′ be sjfBCQs such that 𝑞′ is a pattern of 𝑞. Then we have #Val(𝑞′) ⩽p

par #Val(𝑞).
Moreover, the same results hold if we restrict to Codd tables, and/or to the uniform setting, and/or to
counting completions.

Proof. The reduction is exactly the same as that of Lemma 3.3, the only difference being that,
when we delete an occurrence of a constant 𝑐, we simply fill the corresponding columns of every
□
tuple with this constant.

Next, we prove dichotomies for counting valuations for the non-uniform setting, for naive and
Codd databases. For Codd databases, it turns out that there is no new hard pattern that involves
constants, so the dichotomy is the same as for sjfBCQs without constants. Formally:

Theorem 7.3 (dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥) ∧ 𝑆 (𝑥) is a pattern of 𝑞, then #ValCd (𝑞) is

#P-complete. Otherwise, #ValCd(𝑞) is in FP.

Proof. The proof is exactly as the proof of Theorem 3.7, with the following modification: we
let 𝜌 (¯𝑡 𝑗 ) be the number of valuations of the nulls appearing in ¯𝑡 𝑗 that do not match the corresponding
□
atom of 𝑞; and clearly, this can again be computed in polynomial time.

For naive tables however, we find two new hard patterns that involve constants, as shown next.

The complexity of counting problems over incomplete databases

1:37

Proposition 7.4. Let 𝑐, 𝑐 ′ be two distinct constants. The problems #Val(𝑅(𝑐, 𝑐)) and #Val(𝑅(𝑐, 𝑐 ′))

are both #P-hard.

Proof. We only explain for #Val(𝑅(𝑐, 𝑐 ′)), as the other case is analogous. The reduction is similar
to that used in Proposition 3.8, but we reduce from counting the number of independent sets in
bipartite graphs (in Proposition 3.8 we did not need the graphs to be bipartite). Let 𝐺 = (𝑈 ⊔ 𝑉 , 𝐸)
be a bipartite graph. We have one null ⊥𝑢 for every node 𝑢 ∈ 𝑈 with domain dom(⊥𝑢) = {0, 𝑐},
and one null ⊥𝑣 for every node 𝑢 ∈ 𝑉 with domain dom(⊥𝑣) = {0, 𝑐 ′}. For every edge (𝑢, 𝑣) ∈ 𝐸
we have a fact 𝑅(⊥𝑢, ⊥𝑣) in 𝐷. Then it is clear that the number of valuations of 𝐷 that do not
contain 𝑅(𝑐, 𝑐 ′) is equal to the number of independent sets of 𝐺, thus establishing hardness. (Note
□
that for 𝑅(𝑐, 𝑐), we do not need the graph to be bipartite for the reduction to work.)

We then claim that these are the only additional patterns that are necessary to obtain a dichotomy

for #Val(𝑞) for sjfBCQs with constants.

Theorem 7.5 (dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥, 𝑥) or 𝑅(𝑥) ∧ 𝑆 (𝑥) or 𝑅(𝑐, 𝑐) or 𝑅(𝑐, 𝑐 ′)

for 𝑐 ≠ 𝑐 ′ is a pattern of 𝑞, then #Val(𝑞) is #P-complete. Otherwise, #Val(𝑞) is in FP.

The #P-hardness part of the claim follows from Lemma 7.2 and Propositions 3.4 and 3.5 and 7.4.
We now show the tractability claim. First, observe that not having any of these patterns means the
following: every variable in 𝑞 has exactly one occurrence and every atom of 𝑞 contains at most
one constant (but notice that the same constant can appear in multiple atoms). But then, because
the database is Codd and because 𝑞 has no self-joins, by multiplying by the appropriate factor,
the problem #Val(𝑞) reduces to the problem #Val(𝑞′) where 𝑞′ is an sjfBCQ of the form 𝑅1(𝑐1) ∧
𝑅2(𝑐2) ∧ . . . ∧ 𝑅𝑘 (𝑐𝑘 ), where the constants 𝑐1, . . . 𝑐𝑘 are not necessarily distinct. We give next an
example proof that the problem is tractable for such a simple query.

= {⊥𝑅

= {⊥𝑅𝑆

1 , . . . , ⊥𝑅𝑆

Example 7.6. Let 𝑞 be the query 𝑅(𝑐) ∧ 𝑆 (𝑐 ′) with 𝑐 ≠ 𝑐 ′, and 𝐷 be an incomplete naive database.
We explain how to compute #Val(¬𝑞)(𝐷) (the number of valuations that do not satisfy the query)
in FP. This is enough, since the total number of valuations can clearly be computed in FP. First of all,
we can assume without loss of generality that 𝐷 does not contain ground atoms that already satisfy
the query. Then, let 𝐵𝑅𝑆 def
𝑛𝑅𝑆 } be the set of nulls that occur in both 𝐷 (𝑅) and 𝐷 (𝑆),
𝐵𝑅 def
1 , . . . , ⊥𝑅
𝑛𝑅 } be the set of nulls that occur in 𝐷 (𝑅) but not in 𝐷 (𝑆), and 𝐵𝑆
𝑛𝑆 }
be the set of nulls that occur in 𝐷 (𝑆) but not in 𝐷 (𝑅). Let 𝐷 ′ be the database that contains only
the facts 𝑅(⊥) and 𝑆 (⊥) for ⊥ ∈ 𝐵𝑅𝑆 . Notice that the number of valuations of the nulls in 𝐵𝑅 such
that no null has value 𝑐 is (cid:206)𝑛𝑅
𝑖 ) \ {𝑐}|, and that the number of valuations of the nulls
in 𝐵𝑅 such that some null has value 𝑐 is then (cid:206)𝑛𝑅
𝑖=1 |dom(⊥𝑅
𝑖 ) \ {𝑐}|, and a similar
expression can be obtained for the valuations of the nulls in 𝐵𝑆 and constant 𝑐 ′. Then, by case
analysis of whether some null in 𝐵𝑅 has value 𝑐 or not, and whether some null in 𝐵𝑆 has value 𝑐 ′ or
not, we obtain that #Val(¬𝑞)(𝐷) = 𝐴 + 𝐵 + 𝐶, where

𝑖=1 |dom(⊥𝑅

𝑖=1 |dom(⊥𝑅

𝑖 )| − (cid:206)𝑛𝑅

1, . . . , ⊥𝑆

def
= {⊥𝑆

𝐴 = (cid:0)

𝑛𝑅(cid:214)

𝑖=1

|dom(⊥𝑅

𝑖 )| −

𝑛𝑅(cid:214)

𝑖=1

|dom(⊥𝑅

𝑖 ) \ {𝑐}|(cid:1) ×

𝑛𝑆(cid:214)

𝑖=1

|dom⊥𝑆

𝑖 | \ {𝑐 ′}| ×

𝑛𝑅𝑆(cid:214)

𝑖=1

|dom⊥𝑅𝑆
𝑖

\ {𝑐 ′}|

is the number of valuations of 𝐷 that do not satisfy 𝑞 and such that some null in 𝐵𝑅 has value 𝑐,

𝐵 =

𝑛𝑅(cid:214)

𝑖=1

|dom(⊥𝑅

𝑖 )| \ {𝑐}| × (cid:0)

𝑛𝑆(cid:214)

𝑖=1

|dom(⊥𝑆

𝑖 )| −

𝑛𝑆(cid:214)

𝑖=1

|dom(⊥𝑆

𝑖 ) \ {𝑐 ′}|(cid:1) ×

𝑛𝑅𝑆(cid:214)

𝑖=1

|dom⊥𝑅𝑆
𝑖

\ {𝑐})

1:38

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

is the number of valuations of 𝐷 that do not satisfy 𝑞 and such that no null in 𝐵𝑅 has value 𝑐 and

some null in 𝐵𝑆 has value 𝑐 ′, and

𝐶 =

𝑛𝑅(cid:214)

𝑖=1

|dom(⊥𝑅

𝑖 ) \ {𝑐}| ×

𝑛𝑆(cid:214)

𝑖=1

|dom(⊥𝑆

𝑖 ) \ {𝑐 ′}| × #Val(¬𝑞)(𝐷 ′)

is the number of valuations of 𝐷 that do not satisfy 𝑞 and such that no null in 𝐵𝑅 has value 𝑐
and no null in 𝐵𝑆 has value 𝑐 ′. Hence, we only have to explain how to compute #Val(¬𝑞)(𝐷 ′)
in polynomial time. For 𝑘 ∈ {0, . . . , 𝑛𝑅𝑆 }, let 𝐷 ′
be the database containing only the facts of 𝐷 ′
𝑘
over the nulls ⊥𝑅𝑆
. We then define the quantities 𝑉 (𝑆, 𝑘), for 𝑆 ∈ {{𝑐}, {𝑐 ′}, {𝑐, 𝑐 ′}, ∅}
and 𝑘 ∈ {0, . . . , 𝑛𝑅𝑆 } to be the number of valuations of 𝐷𝑘 that do not satisfy 𝑞 and such that no
null has a value that is in 𝑆. Notice then that 𝑉 (∅, 𝑛𝑅𝑆 ) = #Val(¬𝑞)(𝐷 ′). For an element 𝑎 and
set 𝐴, we write [𝑎 ∈ 𝐴] to mean 1 if 𝑎 ∈ 𝐴 and 0 otherwise. But then we can easily compute the
quantities 𝑉 (𝑆, 𝑘) by dynamic programming using the following relations:

1 , . . . , ⊥𝑅𝑆
𝑘

𝑉 (∅, 𝑘) =[𝑐 ∈ dom(⊥𝑅𝑆

𝑘 )] × 𝑉 ({𝑐}, 𝑘 − 1)

+ [𝑐 ′ ∈ dom(⊥𝑅𝑆
+ |dom(⊥𝑅𝑆

𝑘 )] × 𝑉 ({𝑐 ′}, 𝑘 − 1)
𝑘 ) \ {𝑐, 𝑐 ′}| × 𝑉 (∅, 𝑘 − 1)

𝑉 ({𝑐, 𝑐 ′}, 𝑘) = |dom(⊥𝑅𝑆

𝑘 ) \ {𝑐, 𝑐 ′}| × 𝑉 ({𝑐, 𝑐 ′}, 𝑘 − 1)

and

and

𝑉 ({𝑐}, 𝑘) =[𝑐 ′ ∈ dom(⊥𝑅𝑆

𝑘 )] × 𝑉 ({𝑐, 𝑐 ′}, 𝑘 − 1)
𝑘 ) \ {𝑐, 𝑐 ′}| × 𝑉 ({𝑐, 𝑐 ′}, 𝑘 − 1)

+ |dom(⊥𝑅𝑆

and a similar relation for 𝑉 ({𝑐 ′}, 𝑘).

□

The proof for the general case is simply a tedious generalization of the proof for this example,

and is not very interesting, so we omit it.

Therefore, by combining Theorems 7.3 and 7.5 with Lemma 7.1, we obtain dichotomies for
counting valuations of self-join–free conjunctive queries that can contain constants and free
variable, for the non-uniform setting for both naive and Codd tables. It is likely that dichotomies
can be obtained for counting valuations in the uniform setting by using the same methodology, but
we do not pursue this further as our goal in this section is not to be exhaustive but rather to give
the main ideas to be able to handle free variables and constants.

For counting completions, the reader can check that the pattern 𝑅(𝑐) is hard for #CompCd (so
that in this case again all queries are hard), and that for #Compu
, any query that contains an atom
Cd
that is not unary is again hard (it is evident from the proof of Proposition 4.9). By combining these
observations with Lemma 7.1 and with the tractability proof for #Compu (which can be shown
to extend in this case), we obtain four dichotomies for counting completions for self-join–free
conjunctive queries that can contain constants and free variables.

Last, we point out that by using the same methodology, one also can extend our results on
approximations to the case of queries containing constants and free variables (since the relevant
reductions are parsimonious).

The complexity of counting problems over incomplete databases

1:39

8 RELATED WORK
There are two main lines of work that must be compared to what we do in this article. In both cases
the goal is to go beyond the traditional notion of certain answers that so far had been used almost
exclusively to deal with query answering over uncertain data. We discuss them here, explain how
they relate to our problems and what are the fundamental differences.

Best answers and 0-1 laws for incomplete databases. Libkin has recently introduced a frame-
work that can be used to measure the certainty with which a Boolean query holds on an incomplete
database, and also to compare query answers (for a non-Boolean query) [38]. For a Boolean query 𝑞,
incomplete database 𝐷, and integer 𝑘, he defines the quantity 𝜇𝑘 (𝑞, 𝐷) as |Supp𝑘 (𝑞,𝐷) |
, where 𝑉 𝑘 (𝐷)
denotes the set of valuations of 𝐷 with domain {1, . . . , 𝑘 }, and Supp𝑘 (𝑞, 𝐷) denotes the set of
valuations 𝜈 ∈ 𝑉 𝑘 (𝐷) such that 𝜈 (𝐷) |= 𝑞; hence, 𝜇𝑘 (𝑞, 𝐷) represents the relative frequency of
valuations 𝜈 in {1, . . . , 𝑘 } for which the query is satisfied. He then shows that, for a very large class
of queries (namely, generic queries), the value 𝜇𝑘 (𝑞, 𝑑) always tends to 0 or 1 as 𝑘 tends to infinity
(and the same results holds when considering completions instead of valuations). This means that,
intuitively, over an infinite domain the query 𝑞 is either almost certainly true or almost certainly
false.

|𝑉 𝑘 (𝐷) |

He also studies the complexity of finding best answers for a non Boolean query 𝑞. As mentioned
in the introduction, a tuple 𝑎 is a better answer than another tuple 𝑏 when for every valuation 𝜈
of 𝐷, if we have 𝑏 ∈ 𝑞(𝜈 (𝑑)) then we also have 𝑎 ∈ 𝑞(𝜈 (𝑑)). A best answer is then an answer
such that there is no other answer strictly better than it (under inclusion of the sets of satisfying
valuations). He studies the complexity of comparing answers under this semantics, and that of
computing the set of best answers (see also [25]).

There are several crucial differences between this previous work and ours. First, Libkin does
not study the complexity of computing 𝜇𝑘 (𝑞, 𝑑). We do this under the name #Valu(𝑞); moreover,
we also study the setting in which the domains are not uniform. Second, knowing that a tuple
is the best answer might not tell us anything about the size of its “support”, i.e., the number of
valuations that support it. In particular, a best answer is not necessarily an answer which has the
biggest support. Finally, under the semantics of better answers it does not matter if we look at the
completions or at the valuations (i.e., a tuple is a best answer with respect to inclusion of valuations
iff it is the best answer with respect to completions); while we have shown that it does matter for
counting problems.

Counting problems for probabilistic databases and consistent query answering. Re-
markably, counting problems have received considerable attention in other database scenarios
where uncertainty issues appear. As mentioned in the introduction, this includes the settings of
probabilistic databases and inconsistent databases. In the former case, uncertainty is represented
as a probability distribution on the possible states of the data [19, 47]. There, query answering
amounts to computing a weighted sum of the probabilities of the possible states of the data that
satisfy a query 𝑞. We call this problem Prob(𝑞). In the case of inconsistent databases, we are given
a set Σ of constraints and a database 𝐷 that does not necessarily satisfy Σ; cf. [9, 12, 13]. Then the
task is to reason about the set of all repairs of 𝐷 with respect to Σ [9]. In our context, this means
that one wants to count the number of repairs of 𝐷 with respect to Σ that satisfy a given query 𝑞.
When 𝑞 and Σ are fixed, we call this problem #Repairs(𝑞, Σ).

Both Prob(𝑞) and #Repairs(𝑞, Σ) have been intensively studied already. To start with, counting
complexity dichotomies have been obtained for the problem #Repairs(𝑞, Σ); e.g., [40] gives a
dichotomy for this problem when 𝑞 is an sjfBCQ and 𝜎 consists of primary keys, and [41] extends
this result to CQs with self-joins but only for unary keys constraints. We also mention [15], where

1:40

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

the problem of counting repairs such that a particular input tuple is in the result of the query
on the repair is studied. A seemingly close counting problem for probabilistic databases is the
problem Prob(𝑞) over block independent disjoint (BIDs) databases. We do not define it formally here,
but counting repairs under primary keys can be seen as a special case of this problem, where the
tuples in a “block” all have the same probability, and where the sum of the probabilities sum to 1 (and
in BIDs this sum is allowed to be < 1, meaning that a block can be completely erased). Dichotomies
for this problem have been obtained in [18] for sjfBCQs. Counting complexity dichotomies for
other models of probabilistic databases also exist; e.g., for tuple-independent probabilistic databases
in which each fact is assigned an independent probability of being part of the actual dataset.
Interestingly, dichotomies in this case hold for arbitrary unions of BCQs, and thus not just for
sjfBCQs [19].

In some cases, one can use a problem of the form #Repairs(𝑞, Σ) (or Prob(𝑞)) to show the
hardness of a problem of the form #Val(𝑞′). For instance, in Section 3.1 we used the #P-hardness
of #Repairs(𝑅 ′(y, 𝑥) ∧ 𝑆 ′(z, 𝑥)) to prove that of #ValCd(𝑅(𝑥) ∧ 𝑆 (𝑥)). In general however, the
problems #Repairs(𝑞, Σ) and Prob(𝑞) seem to be unrelated to our problems, for the following
reasons. First, in our setting the nulls can appear anywhere, so there is no notion of primary keys
here; hence it seems unlikely that one can design a generic reduction from the problem of counting
valuations/completions to the problem of counting repairs. In fact, it would perfectly make sense
to study our counting problems where we add constraints such as functional dependencies. Second,
in the BID and counting repairs problems, each “valuation” (repair) gives a different complete
database, while in our case we have seen that this is not necessarily the case. In particular, problems
of the form #Comp(𝑞) have no analogues in these settings, whereas we have seen that they behave
very differently in our setting.

Concerning approximation results, it is known that the problems #Repairs(𝑞, Σ) and Prob(𝑞)
admit an FPRAS in some important settings. In particular, when 𝑞 is a union of BCQs, this holds for
#Repairs(𝑞, Σ) when Σ is a set of primary keys [15], and for Prob(𝑞) over BID and tuple-independent
probabilistic databases [18]. We observe here that this is reminescent of our Corollary 5.3, which
shows that problems of the form #Val(𝑞) have an FPRAS for every union of BCQs.

9 FINAL REMARKS
Our work aims to be a first step in the study of counting problems over incomplete databases.
The main conclusion behind our results is that the counting problems studied in this article are
particularly hard from a computational point of view, especially when compared to more positive
results obtained in other uncertainty scenarios; e.g., over probabilistic and inconsistent databases.
As we have shown, a particularly difficult problem in our context is that of counting completions,
even in the uniform setting where all nulls have the same domain. In fact, Proposition 4.9 shows
that this problem is #P-hard even in very restricted scenarios, and Proposition 5.6 that it cannot be
approximated by an FPRAS. It seems then that the only way in which one could try to tackle this
problem is by developing suitable tractable heuristics, without provable quantitative guarantees,
but that work sufficiently well in practical scenarios. An example of this could be developing
algorithms that compute “under-approximations” for the number of completions of a naive table
satisfying a certain sjfBCQ 𝑞. Notice that a related approach has been proposed by Console et al.
for constructing under-approximations of the set of certain answers by applying methods based on
many-valued logics [17].

We plan to continue working on several interesting problems that are left open in this article. First
of all, we would like to pinpoint the complexity of #Comp(𝑞) when 𝑞 is an sjfBCQ; in particular,
whether this problem is SpanP-complete for at least one such a query. We also want to study
whether the non-existence of FPRAS for #Compu(𝑞) established in Proposition 5.6 continues to

The complexity of counting problems over incomplete databases

1:41

hold over Codd tables. We would also like to develop a more thorough understanding of the role
of fixed domains in our dichotomies. In several cases, that we have explicitly stated, our lower
bounds hold even if nulls in tables are interpreted over a fixed domain. Still, in some cases we do not
know whether this holds. These include, e.g., Proposition 3.11, Proposition 4.2, and Proposition 4.9.
Finally, it would also be interesting to study these counting problems under bag semantics (instead
of the set semantics used in this article), or consider arbitrary conjunctive queries as opposed to
only self-join–free ones.

ACKNOWLEDGMENTS
We thank Antoine Amarilli for suggesting to use #BIS in the proof of Proposition 3.11, as well as
the anonymous reviewers for their careful proofreading. This work was partially funded by ANID
- Millennium Science Initiative Program - Code ICN17_002. Arenas is funded by Fondecyt grant
1191337 and Barceló by Fondecyt grant 1200967.

REFERENCES
[1] Serge Abiteboul, Richard Hull, and Victor Vianu. 1995. Foundations of databases. Vol. 8. Addison-Wesley Reading.

http://webdam.inria.fr/Alice/

[2] Serge Abiteboul, Paris Kanellakis, and Gösta Grahne. 1991. On the representation and querying of sets of possible worlds.
Theoretical computer science 78, 1 (1991), 159–187. https://www.sciencedirect.com/science/article/pii/0304397551900072

[3] Adam. 2013. Number of surjective functions. https://math.stackexchange.com/a/615136/378365
[4] Parag Agrawal, Anish Das Sarma, Jeffrey Ullman, and Jennifer Widom. 2010. Foundations of uncertain-data integration.

Proceedings of the VLDB Endowment 3, 1-2 (2010), 1080–1090. http://ilpubs.stanford.edu:8090/846/2/main.pdf

[5] Carme Álvarez and Birgit Jenner. 1993. A very hard log-space counting class. Theoretical Computer Science 107, 1

(1993), 3–30. https://www.sciencedirect.com/science/article/pii/030439759390252O

[6] Periklis Andritsos, Ariel Fuxman, and Renee J Miller. 2006. Clean answers over dirty databases: A probabilistic approach.
In 22nd International Conference on Data Engineering (ICDE’06). IEEE, 30–30. ftp://ftp.cs.toronto.edu/csrg-technical-
reports/513/tr513.pdf

[7] Lyublena Antova, Christoph Koch, and Dan Olteanu. 2009. 10(106) worlds and beyond: efficient representation and
processing of incomplete information. The VLDB Journal 18, 5 (2009), 1021–1040. https://arxiv.org/abs/cs/0606075
[8] Marcelo Arenas, Pablo Barceló, and Mikaël Monet. 2020. Counting Problems over Incomplete Databases. In Proceedings
of the 39th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems. 165–177. https://arxiv.org/abs/
1912.11064

[9] Marcelo Arenas, Leopoldo Bertossi, and Jan Chomicki. 1999. Consistent query answers in inconsistent databases.
In Proceedings of the eighteenth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems. 68–79.
http://marenas.sitios.ing.uc.cl/publications/pods99.pdf

[10] Marcelo Arenas, Luis Alberto Croquevielle, Rajesh Jayaram, and Cristian Riveros. 2019. Efficient logspace classes for
enumeration, counting, and uniform generation. In Proceedings of the 38th ACM SIGMOD-SIGACT-SIGAI Symposium
on Principles of Database Systems. 59–73. https://arxiv.org/abs/1906.09226

[11] Omar Benjelloun, Anish Das Sarma, Alon Halevy, Martin Theobald, and Jennifer Widom. 2008. Databases with
uncertainty and lineage. The VLDB Journal 17, 2 (2008), 243–264. http://ilpubs.stanford.edu:8090/811/1/2007-26.pdf
[12] Leopoldo Bertossi. 2011. Database repairing and consistent query answering. Synthesis Lectures on Data Management

3, 5 (2011), 1–121. https://www.cs.ubc.ca/~laks/cpsc504/dc-leo.pdf

[13] Leopoldo Bertossi. 2019. Database repairs and consistent query answering: Origins and further developments. In
Proceedings of the 38th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems. 48–58. https:
//dl.acm.org/citation.cfm?id=3322190

[14] Jin-Yi Cai, Pinyan Lu, and Mingji Xia. 2012. Holographic reduction, interpolation and hardness. Computational
Complexity 21, 4 (2012), 573–604. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.145.8882&rep=rep1&
type=pdf

[15] Marco Calautti, Marco Console, and Andreas Pieris. 2019. Counting database repairs under primary keys revisited. In
Proceedings of the 38th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems. 104–118. https:
//core.ac.uk/download/pdf/224804156.pdf

[16] T Codd. 1975. Understanding relations (installment# 7). FDT Bull. of ACM Sigmod 7 (1975), 23–28.
[17] Marco Console, Paolo Guagliardo, and Leonid Libkin. 2016. Approximations and refinements of certain answers via

many-valued logics. In KR. 349–358. https://homepages.inf.ed.ac.uk/libkin/papers/kr16.pdf

1:42

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

[18] Nilesh Dalvi, Christopher Re, and Dan Suciu. 2011. Queries and materialized views on probabilistic databases. J.

Comput. System Sci. 77, 3 (2011), 473–490. https://www-cs.stanford.edu/~chrismre/papers/jcss-probdb.pdf

[19] Nilesh Dalvi and Dan Suciu. 2013. The dichotomy of probabilistic inference for unions of conjunctive queries. Journal

of the ACM (JACM) 59, 6 (2013), 1–87. https://homes.cs.washington.edu/~suciu/jacm-dichotomy.pdf

[20] Martin Dyer, Alan Frieze, and Mark Jerrum. 2002. On counting independent sets in sparse graphs. SIAM J. on Computing

31, 5 (2002), 1527–1541. http://yaroslavvb.com/papers/dyer-on.pdf

[21] Jack Edmonds. 1965. Paths, trees, and flowers. Can. J. of Math. 17 (1965), 449–467. https://math.nist.gov/~JBernal/p_t_

f.pdf

[22] Genghua Fan, Yan Li, Ning Song, and Daqing Yang. 2015. Decomposing a graph into pseudoforests with one having
bounded degree. Journal of Combinatorial Theory, Series B 115 (2015), 72–95. https://www.sciencedirect.com/science/
article/pii/S0095895615000581

[23] Wenfei Fan, Floris Geerts, Xibei Jia, and Anastasios Kementsietsidis. 2008. Conditional functional dependencies for
capturing data inconsistencies. ACM Transactions on Database Systems (TODS) 33, 2 (2008), 1–48. https://www.inf.ed.
ac.uk/publications/online/0949.pdf

[24] Stephen A Fenner, Lance J Fortnow, and Stuart A Kurtz. 1994. Gap-definable counting classes. J. Comput. System Sci.

48, 1 (1994), 116–148. https://www.sciencedirect.com/science/article/pii/S0022000005800248

[25] Amélie Gheerbrant and Cristina Sirangelo. 2019. Best answers over incomplete data: Complexity and first-order
rewritings. In the Twenty-Eighth International Joint Conference on Artificial Intelligence (IJCAI 2019). https://www.ijcai.
org/proceedings/2019/236

[26] Omer Giménez and Marc Noy. 2006. On the complexity of computing the Tutte polynomial of bicircular matroids. Com-
binatorics, Probability and Computing 15, 3 (2006), 385–395. https://www.cambridge.org/core/journals/combinatorics-
probability-and-computing/article/on-the-complexity-of-computing-the-tutte-polynomial-of-bicircular-
matroids/8B45505EDDDF91337E62D45B143EC5E5

[27] Logan Grout and Benjamin Moore. 2019. On decomposing graphs into forests and pseudoforests. arXiv preprint

arXiv:1904.12435 (2019). https://arxiv.org/abs/1904.12435

[28] Sanjay Gupta. 1991. The power of witness reduction. In 1991 Proceedings of the Sixth Annual Structure in Complexity

Theory Conference. IEEE, 43–59. https://ieeexplore.ieee.org/abstract/document/160242

[29] Sanjay Gupta. 1995. Closure properties and witness reduction. J. Comput. System Sci. 50, 3 (1995), 412–432. https:

//www.sciencedirect.com/science/article/pii/S002200008571032X

[30] Tomasz Imielinski and Witold Lipski Jr. 1984. Incomplete Information in Relational Databases. Journal of the ACM

(JACM) 31, 4 (1984), 761–791. https://cs.uwaterloo.ca/~david/cs848s14/il84.pdf

[31] Neil Immerman. 2012. Descriptive complexity. Springer Science & Business Media. https://people.cs.umass.edu/

~immerman/book/ch0_1_2.pdf

[32] François Jaeger, Dirk L Vertigan, and Dominic JA Welsh. 1990. On the computational complexity of the Jones and Tutte
polynomials. In Mathematical Proc. of the Cambridge Phil. Soc., Vol. 108. Cambridge University Press, 35–53. https:
//www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/on-
the-computational-complexity-of-the-jones-and-tutte-polynomials/0EA052341269A2816C36B15380B8AA02
[33] Mark R Jerrum, Leslie G Valiant, and Vijay V Vazirani. 1986. Random generation of combinatorial structures from
a uniform distribution. Theoretical computer science 43 (1986), 169–188. http://www2.stat.duke.edu/~scs/Courses/
Stat376/Papers/ConvergeRates/RandomizedAlgs/JerrumValiantVaziraniTCS1986.pdf

[34] Ker-I Ko. 1982. Some observations on the probabilistic algorithms and NP-hard problems. Inform. Process. Lett. 14, 1

(1982), 39–43. https://www.sciencedirect.com/science/article/pii/0020019082901399

[35] Johannes Köbler, Uwe Schöning, and Jacobo Torán. 1989. On counting and approximation. Acta Informatica 26, 4

(1989), 363–379. https://www.researchgate.net/publication/226508658_On_counting_and_approximation

[36] Łukasz Kowalik. 2006. Approximation scheme for lowest outdegree orientation and graph density measures. In
International Symposium on Algorithms and Computation. Springer, 557–566. https://www.mimuw.edu.pl/~kowalik/
papers/orient.pdf

[37] Leonid Libkin. 2014. Incomplete data: what went wrong, and how to fix it. In Proceedings of the 33rd ACM SIGMOD-
SIGACT-SIGART symposium on Principles of database systems. 1–13. https://homepages.inf.ed.ac.uk/libkin/papers/
pods14.pdf

[38] Leonid Libkin. 2018. Certain answers meet zero-one laws. In Proceedings of the 37th ACM SIGMOD-SIGACT-SIGAI
Symposium on Principles of Database Systems. 195–207. https://homepages.inf.ed.ac.uk/libkin/papers/pods18.pdf
[39] Meena Mahajan, Thomas Thierauf, and N. V. Vinodchandran. 1994. A note on SpanP functions. Inf. Process. Lett. 51, 1

(1994), 7–10. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.24.9933&rep=rep1&type=pdf

[40] Dany Maslowski and Jef Wijsen. 2013. A dichotomy in the complexity of counting database repairs. J. Comput. System

Sci. 79, 6 (2013), 958–983. https://www.sciencedirect.com/science/article/pii/S0022000013000214

The complexity of counting problems over incomplete databases

1:43

[41] Dany Maslowski and Jef Wijsen. 2014. Counting database repairs that satisfy conjunctive queries with self-joins. In

ICDT. 155–164. http://www.openproceedings.org/ICDT/2014/paper_17.pdf

[42] Mitsunori Ogiwara and Lane A. Hemachandra. 1993. A complexity theory for feasible closure properties. J. Comput.

Syst. Sci. 46, 3 (1993), 295–325. https://www.sciencedirect.com/science/article/pii/002200009390006I

[43] James Oxley. 2003. What is a matroid. Cubo Matemática Educacional 5, 3 (2003), 179–218. https://www.math.lsu.edu/

~oxley/survey4.pdf

[44] J Scott Provan and Michael O Ball. 1983. The complexity of counting cuts and of computing the probability that a

graph is connected. SIAM J. Comput. 12, 4 (1983), 777–788. https://epubs.siam.org/doi/abs/10.1137/0212053

[45] Raymond Reiter. 1978. On closed world data bases. Springer US, 55–76. https://pdfs.semanticscholar.org/d82a/

786f460a5d5c2c6d97aa60f0ead0e70dc67e.pdf

[46] Anish Das Sarma, Omar Benjelloun, Alon Halevy, Shubha Nabar, and Jennifer Widom. 2009. Representing uncertain
data: models, properties, and algorithms. The VLDB Journal 18, 5 (2009), 989–1019. http://ilpubs.stanford.edu:
8090/924/1/uncertainData.pdf

[47] Dan Suciu, Dan Olteanu, Christopher Ré, and Christoph Koch. 2011. Probabilistic databases. Morgan & Claypool.

https://www.morganclaypool.com/doi/abs/10.2200/S00362ED1V01Y201105DTM016

[48] Seinosuke Toda and Osamu Watanabe. 1992. Polynomial-time 1-Turing reductions from# PH to# P. Theoretical
Computer Science 100, 1 (1992), 205–221. https://www.sciencedirect.com/science/article/pii/030439759290369Q
[49] Leslie G. Valiant. 1976. Relative complexity of checking and evaluating. Inf. Process. Lett. 5, 1 (1976), 20–23. https:

//www.sciencedirect.com/science/article/pii/0020019076900971

[50] Leslie G Valiant. 1979. The complexity of computing the permanent. Theoretical computer science 8, 2 (1979), 189–201.

https://core.ac.uk/download/pdf/82500417.pdf

[51] Leslie G. Valiant. 1979. The complexity of enumeration and reliability problems. SIAM J. Comput. 8, 3 (1979), 410–421.

https://www.math.cmu.edu/~af1p/Teaching/MCC17/Papers/enumerate.pdf

[52] Ron van der Meyden. 1998. Logical approaches to incomplete information: A survey. In Logics for databases and

information systems. Springer, 307–356. https://link.springer.com/chapter/10.1007/978-1-4615-5643-5_10

[53] Moshe Y Vardi. 1982. The complexity of relational query languages. In Proceedings of the fourteenth annual ACM
symposium on Theory of computing. 137–146. http://www.dis.uniroma1.it/~degiacom/didattica/semingsoft/SIS05-
06/materiale/1-query-congiuntive/riferimenti/vardi-1982.pdf

[54] Dominic Welsh. 1999. The Tutte polynomial. Random Structures & Algorithms 15, 3-4 (1999), 210–228. https:
//onlinelibrary.wiley.com/doi/pdf/10.1002/(SICI)1098-2418(199910/12)15:3/4%3C210::AID-RSA2%3E3.0.CO;2-R
[55] Mingji Xia, Peng Zhang, and Wenbo Zhao. 2007. Computational complexity of counting problems on 3-regular planar

graphs. Theoretical Computer Science 384, 1 (2007), 111–125. https://core.ac.uk/download/pdf/82063901.pdf

[56] Thomas Zaslavsky. 1982. Bicircular geometry and the lattice of forests of a graph. The Quarterly Journal of Mathematics
33, 4 (1982), 493–511. https://academic.oup.com/qjmath/article-abstract/33/4/493/1498307?redirectedFrom=PDF

1:44

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

Appendix

A PROOFS FOR SECTION 3 (DICHOTOMIES FOR COUNTING VALUATIONS)

A.1 Proof of Theorem 3.9
In this section we prove the tractability claim of the following dichotomy theorem.

Theorem 3.9 (dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥, 𝑥) or 𝑅(𝑥)∧𝑆 (𝑥, 𝑦)∧𝑇 (𝑦) or 𝑅(𝑥, 𝑦)∧𝑆 (𝑥, 𝑦)

is a pattern of 𝑞, then #Valu (𝑞) is #P-complete. Otherwise, #Valu (𝑞) is in FP.

First, to characterize the queries that do not have these patterns, we will use the notion of

connectivity graph of an sjfBCQ 𝑞:

Definition A.1. Let 𝑞 be an sjfBCQ. The connectivity graph of 𝑞 is the graph 𝐺𝑞 = (𝑉 , 𝐸) with
labeled edges, where 𝑉 is the set of atoms of 𝑞, and for every two atoms 𝑅( ¯𝑥𝑖 ), 𝑆 ( ¯𝑦𝑖 ) of 𝑞, if they
share a variable then we have an edge between the corresponding nodes of 𝐺𝑞, that edge being
labeled with the variables in ¯𝑥𝑖 ∩ ¯𝑦𝑖 .

Example A.2. Figure 3 shows the connectivity graph of the query

𝑅1(𝑥1, 𝑥1, 𝑦1, 𝑡1), 𝑅2(𝑥1, 𝑦1, 𝑡2), 𝑆1(𝑥2, 𝑡3), 𝑆2(𝑥2, 𝑡4), 𝑆3(𝑥2),𝑇1(𝑥3),𝑇2(𝑥3),𝑇3(𝑥3),𝑇4(𝑥3, 𝑡5).

□

𝑅1(𝑥1, 𝑥1, 𝑦1, 𝑡1)

𝑆1(𝑥2, 𝑡3)

𝑥1, 𝑦1

𝑥2

𝑅2(𝑥1, 𝑦1, 𝑡2)

𝑆2(𝑥2, 𝑡4)

𝑥2

𝑥2

𝑆3(𝑥2)

𝑥3

𝑇1(𝑥3)

𝑇4(𝑥3, 𝑡5)

𝑥3

𝑥3

𝑥3

𝑥3

𝑇2(𝑥3)

𝑇3(𝑥3)

𝑥3

Fig. 3. The connectivity graph 𝐺𝑞 of the sjfBCQ 𝑞 from Example A.2.

The following is then readily observed:

Lemma A.3. Let 𝑞 be an sjfBCQ that does not contain any of the patterns mentioned in Theorem 3.9.
Then for every connected component 𝐶 of 𝐺𝑞, 𝐶 is a clique and there exists a variable such that all
edges of 𝐶 are labeled by exactly that variable.

Proof. First, observe that every edge of 𝐺𝑞 must be labeled by exactly one variable, as otherwise
the query 𝑞 would contain the pattern 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦). Let 𝐶 be a connected component of 𝐺𝑞.
Then we have:

• 𝐶 is a clique. Indeed, assume by contradiction that 𝐶 is not a clique. Then, since 𝐶 is connected
and is not a clique, we can find 3 nodes 𝐴1(𝑥), 𝐴2 (𝑥 ′), 𝐴3(𝑥 ′′) such that 𝐴1(𝑥) is adjacent
to 𝐴2(𝑥 ′), 𝐴2(𝑥 ′) is adjacent to 𝐴3(𝑥 ′′), and 𝐴1(𝑥) is not adjacent to 𝐴3(𝑥 ′′). Let 𝑋 be 𝑥 ∩ 𝑥 ′
and 𝑌 be 𝑥 ′ ∩ 𝑥 ′′, i.e., the labels on the two corresponding edges of 𝐶. By definition of 𝐺𝑞
and since 𝐴1(𝑥) is not adjacent to 𝐴3(𝑥 ′′), we must have 𝑋 ∩ 𝑌 = ∅. But 𝑋 and 𝑌 are not
empty (again by definition of 𝐺𝑞), so by picking 𝑥 in 𝑋 and 𝑦 in 𝑌 we see that 𝑞 contains the
pattern 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦), a contradiction.

The complexity of counting problems over incomplete databases

1:45

• There exists a variable that labels every edge of 𝐶. Indeed, since every edge of 𝐺𝑞 is labeled
by exactly one variable, and since 𝐶 is a clique, if it was not the case then again we could
find the pattern 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦) in 𝑞.

This concludes the proof.

□

For instance, the query from Example A.2 does not satisfy this criterion, since the edge in
the first connected component of 𝐺𝑞 is labeled by two variables. However if we consider the
query 𝑆1(𝑥2, 𝑡3), 𝑆2(𝑥2, 𝑡4), 𝑆3 (𝑥2),𝑇1(𝑥3),𝑇2(𝑥3),𝑇3(𝑥3),𝑇4(𝑥3, 𝑡5) (i.e., we remove the first connected
component), then it satisfies the criterion.

We will also use the general fact that for an sjfBCQ 𝑞, we can assume wlog that 𝑞 does not

contain variables that occur only once:

Lemma A.4. Let 𝑞 be an sjfBCQ, and let 𝑞′ be the sjfBCQ obtained from 𝑞 by deleting all the

variables that have only one occurrence in 𝑞. Then #Valu(𝑞) ⩽p

T #Valu(𝑞′).

Proof. Let 𝐷 be an incomplete database input of #Valu(𝑞). Let 𝑆 be set of nulls ⊥ such that:
• ⊥ occurs in a column corresponding to a variable that has been deleted; and
• ⊥ does not occur in a column corresponding to a variable that has not been deleted.

Then, letting 𝐷 ′ be the database obtained from 𝐷 by projecting out the columns corresponding
to the deleted variables, it is clear that we have #Valu(𝑞)(𝐷) = #Valu(𝑞′)(𝐷 ′) × (cid:206)
⊥∈𝑆 |dom(⊥)|,
where dom is the uniform domain of the nulls. We note here that this lemma is also true in the
□
non-uniform setting.

By Lemma A.3 and Lemma A.4, it is enough to show the tractability of #Valu (𝑞) when 𝑞 is of
the form 𝐶1(𝑥1) ∧ . . . ∧ 𝐶𝑚 (𝑥𝑚), where each 𝐶𝑖 (𝑥𝑖 ) is what we call a basic singleton query, i.e., is
a conjunction of unary atoms over the same variable 𝑥𝑖 . We call such an sjfBCQ a conjunction of
basic singletons. For instance,

𝑆1(𝑥2), 𝑆2(𝑥2), 𝑆3(𝑥2),𝑇1(𝑥3),𝑇2(𝑥3),𝑇3(𝑥3),𝑇4(𝑥3)

is such a query, with 𝑚 = 2. We will use the following:

Lemma A.5. Let 𝑞 = 𝐶1(𝑥1) ∧ . . . ∧𝐶𝑚 (𝑥𝑚) be a conjunction of basic singletons sjfBCQ, and let 𝐷 be
def
= |{𝜈 valuation of 𝐷 | 𝜈 (𝐷) ̸|= (cid:212)𝑖 ∈𝑆 𝐶𝑖 (𝑥𝑖 )}|.

an incomplete database. For 𝑆 ⊆ [𝑚], we define 𝑁𝑆 (𝐷)
Then we have #Valu(𝑞)(𝐷) = (cid:205)𝑆 ⊆ [𝑚] (−1) |𝑆 |𝑁𝑆 (𝐷).

Proof. Direct, by inclusion–exclusion.

□

Hence, and remembering that we consider data complexity, it is enough to show how to com-
pute 𝑁𝑆 (𝐷) for every 𝑆 ⊆ [𝑚]. The main difficulties in computing 𝑁𝑆 (𝐷) is that the relations can
have nulls in common (since we consider naive tables), and that they may also have constants; this
makes it technically painful to express a closed-form expression for 𝑁𝑆 (𝐷). We explain how to do
it next, thus finishing the proof of Theorem 3.9.

Proposition A.6. Let 𝑞 = 𝐶1(𝑥1) ∧ . . . ∧ 𝐶𝑚 (𝑥𝑚) be a conjunction of basic singletons sjfBCQ
and 𝑆 ⊆ [𝑚]. Then, given an incomplete database 𝐷 as input, we can compute 𝑁𝑆 (𝐷) in polynomial
time.

Proof. First, observe that to compute 𝑁𝑆 (𝐷) we can assume without loss of generality that
the input database 𝐷 only contains facts over relation names that occur in some 𝐶𝑖 (𝑥𝑖 ), for 𝑖 ∈ 𝑆.
Indeed, 𝑁𝑆 (𝐷) counts the valuations 𝜈 of 𝐷 that do not satisfy any of the 𝐶𝑖 (𝑥𝑖 ) for 𝑖 ∈ 𝑆, so that for
any 𝑗 ∉ 𝑆 we do not care if 𝜈 satisfies 𝐶 𝑗 (𝑥 𝑗 ) or not; hence, we could simply multiply the result by

1:46

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

the appropriate factor. Therefore, we can assume that 𝑆 is [𝑚]. We now need to fix some notation.
Let us write the conjunction of basic singleton sjfBCQ 𝑞 as

= (cid:205)𝑚

𝑅1(𝑥1) ∧ . . . ∧ 𝑅𝑚1 (𝑥1) ∧ 𝑅𝑚1+1(𝑥2) ∧ . . . ∧ 𝑅𝑚1+𝑚2 (𝑥2) ∧ . . . ∧ 𝑅(cid:205)𝑚−1

𝑖=1 𝑚𝑖 (𝑥𝑚) ∧ . . . ∧ 𝑅(cid:205)𝑚
and let 𝐾 be the number of atoms in 𝑞, that is, 𝐾 def
𝑖=1 𝑚𝑖 . Let dom be the uniform domain of
the nulls occurring in 𝐷 and 𝑑 its size. For s ⊆ [𝐾], we write 𝐶s the set of constants that occur in
each of the relations 𝐷 (𝑅𝑖 ) for 𝑖 ∈ s but in none of the others, and write 𝑐s the size of that set. We
call such a set a block of constants. Similarly for the nulls, we write 𝑁s the set of nulls that occur in
each of the relations 𝐷 (𝑅𝑖 ) for 𝑖 ∈ s but in none of the others (and we call this a block of nulls),
and 𝑛s for its size. We can assume wlog that:
(a) For every 1 ⩽ 𝑖 ⩽ 𝑚, there is no constant that occurs in every 𝐷 (𝑅) for 𝑅 a relation name
in 𝐶𝑖 (𝑥𝑖 ). Indeed otherwise any valuation would satisfy 𝐶𝑖 (𝑥𝑖 ), thus 𝑁 [𝑚] (𝐷) would simply
be 0.

𝑖=1 𝑚𝑖 (𝑥𝑚)

(b) Every constant 𝑐 appearing in 𝐷 is in dom. Indeed otherwise, with the last item, this constant
would have no chance to be part of a match, so we could simply remove it (i.e., remove all
tuples of the form 𝑅(𝑐) from 𝐷).
For a subset 𝐴 ⊆ dom, let us write 𝐴∁ def
of dom, we denote by I (𝑍 ) the set

= dom \ 𝐴. Finally, for a set 𝑍 = {𝐴1, . . . , 𝐴𝑙 } of subsets

I (𝑍 )

def
= {

𝑙
(cid:217)

𝑖=1

𝐵𝑖 | (𝐵1, . . . , 𝐵𝑙 ) ∈ {𝐴1, 𝐴∁

1 } × . . . × {𝐴𝑙, 𝐴∁

𝑙 }}

We now explain informally how we can compute 𝑁 [𝑚] (𝐷). Let 𝐿 = s1, . . . , s2𝐾 be an arbitrary
linear order of the set of subsets of [𝐾]. We will define by induction on 𝑖 ∈ [2𝐾 ] an expression
computing 𝑁 [𝑚] (𝐷), which will be a nested sum of the form

∑︁

sums1

𝑓s1 ×

(cid:18) ∑︁

sums2

𝑓s2 × (cid:0) . . . (

∑︁

sums2𝐾

(cid:19)

𝑓s2𝐾 ) . . . (cid:1)

(7)

where each sums𝑖 sums over the possible images 𝐴s𝑖 of the nulls in 𝑁s𝑖 by a valuation, and 𝑓s𝑖
def
= |𝐴s𝑖 |, i.e., the number of valuations 𝜈 of 𝑁s𝑖 with image

, where 𝑎s𝑖

will simply be surj𝑛s𝑖 →𝑎s𝑖
exactly 𝐴s𝑖 . But there are two technicalities:

• First, we need to ensure that each basic singleton query 𝐶𝑖 (𝑥𝑖 ) of 𝑞 will not be satisfied. In
, . . . , 𝐵 |I (𝑍𝑖−1 |)
)
si
is included in one of the sets in I (𝑍𝑖−1), where 𝑍𝑖−1 contains all
for 𝑗 < 𝑖. We iteratively build that sum from the

order to do that, sums𝑖 will actually sum over all the possible partitions (𝐵1
si
of 𝐴s𝑖 , where each of the 𝐵 𝑗
the blocks of constants and all the other 𝐵𝑟
sj

s𝑖

def
= {dom} ∪ {𝐶s | s ⊆ [𝐾]}. This will allow us to avoid

outside to the inside, starting with 𝑍0
summing over the 𝐵 𝑗
si

that would render a basic singleton query true.
• Second, as is, such a sum is obviously not going to be computable in PTIME, as we are
summing over subsets of dom. To fix this, observe that the value of the subsum for s𝑖 actually
only depends on the sizes of the sets in 𝑍𝑖−1. Hence, iterating from the outside to the inside,
whenever sums𝑖 contains a sum of the form, say, 𝐵𝑘
for 𝑗 < 𝑖, we can replace this with a
si
, and add to 𝑓s𝑖 a factor of (cid:0)𝑏𝑘′
sum over 0 ⩽ 𝑏𝑘
si

(cid:1). Now, because of how 𝑍0 is defined, and

⊆ 𝐵𝑘′
sj

⩽ 𝑏𝑘′
sj

because of how I works, all the initial numbers in the first sum are either |dom \ (cid:208)𝐾
or one of the numbers 𝑐s for s ⊆ [𝐾]. These can all be computed in polynomial time.

𝑖=1 𝐶 {𝑖 } |

sj
𝑏𝑘
si

The complexity of counting problems over incomplete databases

1:47

The resulting expression then indeed evaluates to 𝑁 [𝑚] (𝐷), and is in a form that allows us to
directly compute it in polynomial time (but non-elementary in the query). This concludes the proof
□
of Proposition A.6.

B PROOFS FOR SECTION 4 (DICHOTOMIES FOR COUNTING COMPLETIONS)

B.1 Proof for Proposition 4.7
In this section we explain how to obtain the following hardness result.

Proposition 4.7 (Implied by [26]). The problem #PF restricted to bipartite graphs is #P-hard.

This result is proven for (non-necessarily bipartite) graphs in [26] using techniques from matroid
theory, in particular using the notions of bicircular matroid of a graph and of Tutte polynomial of a
matroid. We did not find a way to show that the result holds on bipartite graphs without explaining
their proof for general graphs, and we did not find a way to explain the proof for general graphs
without introducing these concepts. Therefore, we need to define these concepts here. We have
tried to keep this exposition as brief as possible, but more detailed introductions to matroid theory
and to the Tutte polynomial can be found in [43, 54]. First, we define what is a matroid.

Definition B.1. A matroid 𝑀 = (𝐸, I) is a pair where 𝐸 is a finite set (called the ground set) and I
is a set of subsets of 𝐸 whose elements are called independent sets and that satisfies the following
properties:
Non emptiness. I ≠ ∅;
Heritage. For every 𝐴′ ⊆ 𝐴 ⊆ 𝐸, if 𝐴 ∈ I then 𝐴′ ∈ I;
Independent set exchange. For every 𝐴, 𝐵 ∈ I, if |𝐴| > |𝐵| then there exists 𝑥 ∈ 𝐴 \ 𝐵 such

that 𝐵 ∪ {𝑥 } ∈ I.

In a matroid 𝑀 = (𝐸, I), an independent set 𝐴 ∈ I is called a basis if every strict superset 𝐴 ⊊
𝐴′ ⊆ 𝐸 is not in I. Notice that, thanks to the independent set exchange property, all bases of 𝑀
have the same number of elements. The rank of 𝑀 is defined as the number of elements in any
basis of 𝑀. Given a matroid 𝑀 = (𝐸, I) and 𝐴 ⊆ 𝐸, we can define the submatroid of 𝑀 generated
by 𝐴 to be 𝑀𝐴 = (𝐴, I ′), where for 𝐴′ ⊆ 𝐴 we have 𝐴′ ∈ I ′ iff 𝐴′ ∈ I (one should check that this
is indeed a matroid). The rank function rk𝑀 : {𝐴 | 𝐴 ⊆ 𝐸} → N of 𝑀 is then defined with rk𝑀 (𝐴)
being the rank of the matroid 𝑀𝐴. We will now omit the subscript in rk𝑀 as this will not cause
confusion. We are ready to define the Tutte polynomial of a matroid.

Definition B.2. Let 𝑀 = (𝐸, I) be a matroid. The Tutte polynomial of 𝑀, denoted T(𝑀; 𝑥, 𝑦), is

the two-variables polynomial defined by

T(𝑀; 𝑥, 𝑦) =

∑︁

(𝑥 − 1)rk(𝑀)−rk(𝐴) (𝑦 − 1) |𝐴 |−rk(𝐴)

𝐴 ⊆𝐸
We will use the following observation:

Observation B.3. Let 𝑀 = (𝐸, I) be a matroid. Then T(𝑀; 2, 1) = |I|, i.e., evaluating the Tutte

polynomial of a matroid at point (2, 1) simply counts its number of independent sets.

Proof. We have T(𝑀; 2, 1) = (cid:205)𝐴 ⊆𝐸 0 |𝐴 |−rk(𝐴) . We recall the convention that 00 = 1, and the fact
that 0𝑘 = 0 for 𝑘 > 0. Observe then that we always have rk(𝐴) ⩽ |𝐴|, and that we have rk(𝐴) = |𝐴|
□
if and only if 𝐴 ∈ I, which proves the claim.

Next, we define what is called the bicircular matroid of a graph 𝐺 = (𝑉 , 𝐸). Recall from Defini-

tion 4.6 the definition of the induced subgraph 𝐺 [𝑆] for 𝑆 ⊆ 𝐸.

1:48

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

Definition B.4. Let 𝐺 = (𝑉 , 𝐸) be a graph and I = {𝑆 ⊆ 𝐸 | 𝐺 [𝑆] is a pseudoforest}. Then one
can check that (𝐸, I) is a matroid [56]. This matroid is called the bicircular matroid of 𝐺, and is
denoted by 𝐵(𝐺).

Notice then that the problem #PF is exactly the same as the problem of computing, given
as input a graph 𝐺, the quantity T(𝐵(𝐺); 2, 1). We now explain the steps used in [26] to prove
that computing T(𝐵(𝐺); 2, 1) is #P-hard for graphs. The starting point of our explanation is that
computing T(𝐵(𝐺); 1, 1) is #P-hard.

Proposition B.5 ([26, Corollary 4.3]). The problem of computing, given a graph 𝐺, the quan-

tity T(𝐵(𝐺); 1, 1) is #P-hard.

Second, let us define the following univariate polynomial: for a graph 𝐺, let 𝑃𝐺 (𝑥) be

𝑃𝐺 (𝑥) = T(𝐵(𝐺); 𝑥, 1).

Notice that this is indeed a polynomial and that its degree is at most |𝐸| (the degree is exactly |𝐸|
iff 𝐺 is itself a pseudoforest). If we could compute efficiently the coefficients of 𝑃𝐺 , then we could in
particular compute the value 𝑃𝐺 (1) = T(𝐵(𝐺); 1, 1), which is #P-hard by the previous proposition.
We recall that to compute the coefficients of a polynomial of degree 𝑛, it is enough to know its
value on 𝑛 + 1 distinct points; in fact, given these values in 𝑛 + 1 distinct points, it is possible to
efficiently compute the coefficients of the polynomial by using standard interpolation techniques
(for example, by using Lagrange polynomials).

We need one last definition.

Definition B.6. Let 𝐺 be a graph. For 𝑘 ∈ N, let s𝑘 (𝐺) be the graph obtained from 𝐺 by replacing

each edge of 𝐺 by a path of lenght 𝑘; this graph is called the 𝑘-stretch of 𝐺.

Then, using a result attributed to Brylawski (see [32]), the authors of [26] obtain that, “up to a

trivial factor”, we have

A careful inspection of [32] reveals13 that, in fact, we have

T(𝐵(s𝑘 (𝐺)); 2, 1) ≃ T(𝐵(𝐺); 2𝑘, 1).

T(𝐵(s𝑘 (𝐺)); 2, 1) = (2𝑘 − 1) |𝐸 |−rk𝐵 (𝐺 ) (𝐸) × T(𝐵(𝐺); 2𝑘, 1).

Notice that rk𝐵 (𝐺) (𝐸) is the size (number of edges) of a pseudoforest of 𝐺 that is maximal by
inclusion of edges, which we can compute in polynomial time.14

With this, the authors of [26] can conclude the proof that computing T(𝐵(𝐺); 2, 1) is hard for
(non-necessarily bipartite) graphs, i.e., that #PF is #P-hard. Indeed, given as input 𝐺 = (𝑉 , 𝐸), we
can construct in polynomial time the graphs s𝑘 (𝐺) for |𝐸| + 1 distinct values of 𝑘, then use oracle
calls to obtain the numbers T(𝐵(s𝑘 (𝐺)); 2, 1), which gives us the value of 𝑃𝐺 on |𝐸| + 1 distinct
points. With that we can recover the coefficients of 𝑃𝐺 and compute 𝑃𝐺 (1) = T(𝐵(𝐺); 1, 1) as
argued above, thus proving hardness for general graphs. To obtain hardness for bipartite graphs,
it is enough to observe that when 𝑘 is even then the 𝑘-stretch of 𝐺 is bipartite (even if 𝐺 is not
bipartite). Hence, to obtain a proof of Proposition 4.7 for bipartite graphs, we can simply change
that proof and specify that we make |𝐸| + 1 calls to the oracle T(𝐵(s𝑘 (𝐺)); 2, 1) for |𝐸| + 1 disctinct
even values of 𝑘.

13To be precise, we use Equations (7.1) and (7.2) of [32] with 𝑥 = 1, 𝑦 = 0, and Equation (2.2) with 𝑥 = 2, 𝑦 = 1.
14This is because, since 𝐵 (𝐺) is a matroid, any two such pseudoforests have the same number of edges. We can then simply
start from the empty subgraph and iteratively add edges until it is not possible to add an edge such that the resulting graph
is a pseudoforest. This also relies on the fact that we can check in polynomial time whether a graph is a pseudoforest.

The complexity of counting problems over incomplete databases

1:49

B.2 Proof of Theorem 4.10
In this section we prove the tractability part of the following:

Theorem 4.10 (Dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦) is a pattern of 𝑞, then

#Compu(𝑞) and #Compu
Cd

(𝑞) are #P-hard. Otherwise, these problems are in FP.

Let 𝑞 be an sjfBCQ not containing any of these two patterns. Then, as observed in Section 4.2, 𝑞
is a conjunction of basic singletons query. Let 𝜎 = {𝑅1, . . . , 𝑅𝑙 } be the set of relation symbols of 𝑞,
and 𝐷 be an incomplete database over these relations, with dom the uniform domain of the nulls
and 𝑑 its size. For every s ⊆ 𝜎, s ≠ ∅, let:

• 𝐶s be the set of constants that occur in all relations of s and in none of the others; 𝑐s be its

size;

• 𝑁s be the set of nulls that occur in all relations of s and in none of the others; 𝑛s be its size.
We also define 𝑐 as (cid:205)
∅≠s⊆𝜎 𝑐s. We can assume wlog that 𝐶s ⊆ dom for all ∅ ≠ s ⊆ 𝜎, otherwise we
can simply remove from 𝐷 the corresponding facts. Let 𝐿 def
= 2𝑙 − 1, and let s1, . . . , s𝐿 be an arbitrary
linear order of {s ⊆ 𝜎 | s ≠ ∅} (for instance, by non-decreasing size). We will follow the same
steps as in the example of Section 4.3. The following lemma is the generalization of Claim 4.12, and
explains how we can guide the computation so that we do not count the same completion twice:

Lemma B.7. For a tuple (𝐼s1, . . . , 𝐼s𝐿 ) of subsets of dom satisfying (★)
𝐶s′

𝐼s ⊆ (dom \ (𝐶 ∪

𝐼s′)) ∪

(cid:216)

(cid:216)

∅≠s′ ⊆𝜎
s′≠s
for every s ∈ (s1, . . . , s𝐿) (in other words, all the sets 𝐼s are mutually disjoint subsets of dom, and a
set 𝐼s can only contain a constant 𝑏 ∈ 𝐶 if 𝑏 is in one of the sets 𝐶s′ for which s′ is striclty included
in s), let us define 𝑃 (𝐼s1, . . . , 𝐼s𝐿 ) to be the complete database consisting of the following facts, for
every ∅ ≠ s ⊆ 𝜎:

∅≠s′⊊s

s𝐿 ).

, . . . , 𝐼 ′

, . . . , 𝐼 ′

, . . . , 𝐼 ′

s⊋s′ 𝐼s′
, . . . , 𝐼 ′

. Then (wlog) there exists 𝑎 ∈ 𝐼s \ 𝐼 ′
s

s𝐿 ) satisfying (★) and that are distinct, we

• 𝑅(𝑎) for every 𝑅 ∈ s and 𝑎 ∈ 𝐼s or 𝑎 ∈ 𝐶s \ (cid:208)
Then, for every two such tuples (𝐼s1, . . . , 𝐼s𝐿 ) and (𝐼 ′
s1
have that 𝑃 (𝐼s1, . . . , 𝐼s𝐿 ) ≠ 𝑃 (𝐼 ′
s1
s𝐿 ). Assume that 𝑃 = 𝑃 ′, and let us
Proof. Let us write 𝑃 = 𝑃 (𝐼s1, . . . , 𝐼s𝐿 ) and 𝑃 ′ = 𝑃 (𝐼 ′
s1
s𝐿 ). Assume by way of contradiction that for some ∅ ≠ s ⊆ 𝜎 we
show that (𝐼s1, . . . , 𝐼s𝐿 ) = (𝐼 ′
s1
have 𝐼s ≠ 𝐼 ′
. By the definition of 𝑃, we have that 𝑃 contains all
s
the facts 𝑅(𝑎) for 𝑅 ∈ s. Let us show that 𝑃 does not contain any fact 𝑅(𝑎) for 𝑅 ∉ s. Otherwise,
assume that 𝑃 contains 𝑅(𝑎) with 𝑅 ∉ s. Then there exists s′ ⊆ 𝜎 such that 𝑅 ∈ s′ and such
that 𝑎 ∈ 𝐼s′ ∪ (𝐶s′ \ (cid:208)
s′⊋s′′ 𝐼s′′). Since s does not contain 𝑅 while s′ does, we have s′ ⊈ s. But then
by (★) we have that 𝐼s and 𝐼s′ ∪ 𝐶s′ are disjoint, which is a contradiction because 𝑎 is supposed to
be in both 𝐼s and 𝐼s′ ∪ (𝐶s′ \ (cid:208)
s′⊋s′′ 𝐼s′′). Therefore, it is indeed the case that 𝑃 does not contain
any fact 𝑅(𝑎) for 𝑅 ∉ s. Now, if 𝑃 ′ contains a fact 𝑅(𝑎) for some 𝑅 ∉ 𝜎 then we are done since
this would imply 𝑃 ≠ 𝑃 ′, a contradiction. Hence we can assume that 𝑃 ′ does not contain any
fact 𝑅(𝑎) for 𝑅 ∉ 𝜎. We will now prove that 𝑃 ′ does not contain all the facts 𝑅(𝑎) for 𝑅 ∈ 𝜎, thus
establishing a contradiction (because 𝑃 does, so we would have 𝑃 ≠ 𝑃 ′) and concluding this proof.
Assume by contradiction that 𝑃 ′ contains all the facts 𝑅(𝑎) for 𝑅 ∈ s. First of all, observe that we
have 𝑎 ∉ 𝐶s because by (★) we have that 𝐼s and 𝐶s are disjoint, and we know that 𝑎 ∈ 𝐼s. Hence,
the only way in which 𝑃 ′ could contain all the facts 𝑅(𝑎) for 𝑅 ∈ s is if there exist s′
1, . . . , s′
𝑘
𝑗 = s and such that for every 1 ⩽ 𝑗 ⩽ 𝑘 we
with 𝑘 ⩾ 1 and s′
have that (i) 𝑎 ∈ 𝐼s′ 𝑗 ∪ (𝐶s′ 𝑗 \ (cid:208)
s′ 𝑗 ⊋s′′ 𝐼s′′). Observe that there must exist 1 ⩽ 𝑗1, 𝑗2 ⩽ 𝑘 such that s′
𝑗1

𝑗 ⊊ s for 1 ⩽ 𝑗 ⩽ 𝑘 such that (cid:208)1⩽ 𝑗 ⩽𝑘 s′

1:50

Marcelo Arenas, Pablo Barceló, and Mikaël Monet

𝑗2 are incomparable by inclusion (otherwise, since all s𝑗 are strictly included in s, their union
and s′
and 𝐼s′ 𝑗2 ∪ 𝐶s′ 𝑗2
could not be equal to s). Also observe that by (★) we have that the sets 𝐼s′ 𝑗1 ∪ 𝐶s′ 𝑗1
must be disjoint. But then (i) applied to 𝑗1 and 𝑗2 gives a contradiction (namely, these two sets are
□
not disjoint since they both contain 𝑎). This finishes the proof.

This next Lemma generalizes Claim 4.13 and tells us that by summing over all such tuples (𝐼s1, . . . , 𝐼s𝐿 )

we cannot miss a completion of 𝐷:

Lemma B.8. Let 𝐷 ′ be a completion of 𝐷. Then there exists a tuple (𝐼s1, . . . , 𝐼s𝐿 ) of subsets of dom

satisfying (★) such that 𝐷 ′ = 𝑃 (𝐼s1, . . . , 𝐼s𝐿 ).

Proof. For ∅ ≠ s ⊆ 𝜎, let us define 𝐷s to be the set of constants that occur in all relation of s
def
= 𝐷s \ 𝐶s. It is then routine
□

and in none of the others. Define the set 𝐼s for ∅ ≠ s ⊆ 𝜎 as follows: 𝐼s
to check that (𝐼s1, . . . , 𝐼s𝐿 ) satisfies (★) and is such that 𝐷 ′ = 𝑃 (𝐼s1, . . . , 𝐼s𝐿 ).

Lemma B.7 and B.8 allows us to express the result as

∑︁

. . .

∑︁

. . .

∑︁

check(𝐼s1, . . . , 𝐼s𝐿 )

(8)

𝐼s1 ⊆dom\𝐶

𝐼s𝑗 ⊆ (dom\(𝐶∪(cid:208)1⩽𝑘 < 𝑗 𝐼s𝑘 ))∪(cid:208)

𝐶s′
where check(𝐼s1, . . . , 𝐼s𝐿 ) ∈ {0, 1} is defined by

∅≠s′⊊s

𝐼s𝐿 ⊆dom\(𝐶s𝐿 ∪(cid:208)1⩽𝑘 <𝐿 𝐼s𝑘 )

check(𝐼s1, . . . , 𝐼s𝐿 )

def
=

(cid:40)1 if 𝑃 (𝐼s1, . . . , 𝐼s𝐿 ) is a completion of 𝐷 that satisfies 𝑞
0 otherwise

.

As such we cannot evaluate this expression in P. The next step is to show that the value
of check(𝐼s1, . . . , 𝐼s𝐿 ) only depends on (|𝐼s1 |, . . . , |𝐼s𝐿 |), which would allow us to rewrite the result as

∑︁

(cid:214)

(cid:18)𝑑 − 𝑐 − (cid:205)1⩽𝑘< 𝑗 𝑖s𝑘 + (cid:205)

0⩽𝑖s1 ,...,𝑖s𝐿

⩽𝑑

1⩽ 𝑗 ⩽𝐿

𝑖s𝑗

∅≠s′⊊s

(cid:19)

𝐶s′

× check(𝑖s1, . . . , 𝑖s𝐿 )

(9)

We give here the necessary and sufficient conditions for 𝑃 (𝐼s1, . . . , 𝐼s𝐿 ) to be a completion of 𝐷

that satisfies 𝑞.

Lemma B.9. We have check(𝐼s1, . . . , 𝐼s𝐿 ) = 1 if and only if the following conditions hold:
(1) for every basic singleton query 𝐶𝑖 (𝑥) of 𝑞, letting s be its sets of relation symbols, there exists s ⊆

s′ ⊆ 𝜎 such that we have |𝐼s′ | ⩾ 1 or 𝑐s′ ⩾ 1.

(2) for every ∅ ≠ s ⊆ 𝜎, if 𝑛s ⩾ 1 and | (cid:208)
s′ ⊇s
(3) consider the following system of equations, with integer variables between 0 and 𝑑:

𝐼s′ | = 0 then |𝐼s| ≠ 0.

𝐶s′ ∪ (cid:208)

s′⊋s

• for every two sets 𝐴, 𝐴′ of subsets of {∅ ≠ s ⊆ 𝜎 }, we have a variable 𝑧𝐴,𝐴′
𝑁s

for every s ∈ 𝐴 and
for every s ∈ 𝐴′. For instance if 𝜎 = {𝑅, 𝑆,𝑇 , 𝑈 } and if 𝐴 = {{𝑅, 𝑆 }, {𝑆,𝑇 }}

a variable 𝑧𝐴,𝐴′
𝐶s
and 𝐴′ = {{𝑈 }} we have the variables
𝑧 { {𝑅,𝑆 },{𝑆,𝑇 } },{ {𝑈 } }
𝑁{𝑅,𝑆 }

𝑁{𝑆,𝑇 }

and 𝑧 { {𝑅,𝑆 },{𝑆,𝑇 } },{ {𝑈 } }

and 𝑧 { {𝑅,𝑆 },{𝑆,𝑇 } },{ {𝑈 } }

𝐶{𝑈 }

.

𝑁{𝑆,𝑇 }

The intuition is that we will use 𝑧 { {𝑅,𝑆 },{𝑆,𝑇 } },{ {𝑈 } }
with 𝑧 { {𝑅,𝑆 },{𝑆,𝑇 } },{ {𝑈 } }
of the constants
in 𝐶 {𝑈 } in order to obtain constants in 𝐼 {𝑅,𝑆,𝑇 ,𝑈 }. Let us write 𝑉 this set of variables. (we note
here that we are using sligthly different notation than for the example in Section 4.3; this is for
readability reasons only.)

of the nulls in 𝑁 {𝑆,𝑇 } and with 𝑧 { {𝑅,𝑆 },{𝑆,𝑇 } },{ {𝑈 } }

of the nulls in 𝑁 {𝑅,𝑆 } and combine them

𝑁{𝑅,𝑆 }

𝐶{𝑈 }

The complexity of counting problems over incomplete databases

1:51

• Now, for every ∅ ≠ s ⊆ 𝜎 we have the constraint

as well as the constraint

𝑧𝐴,𝐴′
𝑁s

⩽ 𝑛s

𝑧𝐴,𝐴′
𝑁s

⩽ 𝑐s

∑︁

𝑧𝐴,𝐴′
𝑁s

∈𝑉

∑︁

𝑧𝐴,𝐴′
𝐶s

∈𝑉

intuitively expressing that we do not use more nulls and constants than there are available.

• for every ∅ ≠ s ⊆ 𝜎 we have a constraint

∑︁

𝐴,𝐴′ ⊆ { ∅≠s⊆𝜎 }
𝐴∪𝐴′=s

𝑧𝐴,𝐴′
∗

⩾ 𝐼s

min
∈𝑉

𝑧𝐴,𝐴′
∗

intuitively meaning that we have allocated the groups of nulls and constants in a way that
allows us to fill the set 𝐼s.

Then this system of equations must have a solution.

Proof. The idea is the same as in Claim 4.14. The only difference is that we added condition (1),
□

which ensures that the guessed completion indeed satisfies the query.

As in the example of Section 4.3, this implies that the value of check(𝐼s1, . . . , 𝐼s𝐿 ) only depends
on (|𝐼s1 |, . . . , |𝐼s𝐿 |) and can be computed in FP (by testing all assignments of the 𝑧∗
∗ variables; because
the schema is fixed so there are only a fixed number of such variables). But then we can compute
the result in FP by evaluating the expression 9, which finishes the proof.

