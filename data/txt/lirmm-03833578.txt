Deciding Hyperproperties Combined with Functional
Specifications
Raven Beutner, David Carral, Bernd Finkbeiner, Jana Hofmann, Markus

Krötzsch

To cite this version:

Raven Beutner, David Carral, Bernd Finkbeiner, Jana Hofmann, Markus Krötzsch. Deciding Hy-
perproperties Combined with Functional Specifications. LICS 2022 - 37th Annual ACM/IEEE Sym-
posium on Logic in Computer Science, Aug 2022, Haifa, Israel. pp.1-13, ￿10.1145/3531130.3533369￿.
￿lirmm-03833578￿

HAL Id: lirmm-03833578

https://hal-lirmm.ccsd.cnrs.fr/lirmm-03833578

Submitted on 20 Sep 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution 4.0 International License

Deciding Hyperproperties Combined
with Functional Specifications
David Carral
LIRMM, Inria, University of
Montpellier, CNRS
France

Raven Beutner
CISPA Helmholtz Center for
Information Security
Germany

Bernd Finkbeiner
CISPA Helmholtz Center for
Information Security
Germany

2
2
0
2

y
a
M
0
3

]

O
L
.
s
c
[

1
v
8
3
1
5
1
.
5
0
2
2
:
v
i
X
r
a

Jana Hofmann
CISPA Helmholtz Center for
Information Security
Germany

Markus Krötzsch
Technische Universität Dresden
Germany

Abstract
We study satisfiability for HyperLTL with a ∀∗∃∗ quantifier
prefix, known to be highly undecidable in general. HyperLTL
can express system properties that relate multiple traces (so-
called hyperproperties), which are often combined with trace
properties that specify functional behavior on single traces.
Following this conceptual split, we first define several safety
and liveness fragments of ∀∗∃∗ HyperLTL, and character-
ize the complexity of their (often much easier) satisfiability
problem. We then add LTL trace properties as functional
specifications. Though (highly) undecidable in many cases,
this way of combining “simple” HyperLTL and arbitrary LTL
also leads to interesting new decidable fragments. This sys-
tematic study of ∀∗∃∗ fragments is complemented by a new
(incomplete) algorithm for ∀∃∗-HyperLTL satisfiability.

CCS Concepts: • Theory of computation → Logic and
verification; Modal and temporal logics.
Keywords: Hyperproperties, HyperLTL, Satisfiability

ACM Reference Format:
Raven Beutner, David Carral, Bernd Finkbeiner, Jana Hofmann,
and Markus Krötzsch. 2022. Deciding Hyperproperties Combined
with Functional Specifications. In 37th Annual ACM/IEEE Sym-
posium on Logic in Computer Science (LICS) (LICS ’22), August 2–
5, 2022, Haifa, Israel. ACM, New York, NY, USA, 19 pages. https:
//doi.org/10.1145/3531130.3533369

1 Introduction
Hyperproperties are properties that relate multiple execu-
tion traces of a system [13] and comprise a range of relevant
properties from many areas of computer science. Examples
are symmetry, optimality, robustness, and noninterference.
The most prominent logic for expressing hyperproperties

LICS ’22, August 2–5, 2022, Haifa, Israel
© 2022 Copyright held by the owner/author(s).
This is the author’s version of the work. It is posted here for your personal
use. Not for redistribution. The definitive Version of Record was published in
37th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS) (LICS
’22), August 2–5, 2022, Haifa, Israel, https://doi.org/10.1145/3531130.3533369.

is HyperLTL [12], which extends LTL with trace quantifica-
tion. Generalized noninterference [33], for example, states
that high-security inputs do not influence the input-output
behavior observable by a low-security user, which can be
expressed in HyperLTL as follows.

∀𝜋∀𝜋 ′∃𝜋 ′′.

(cid:16) (cid:219)

(𝑎𝜋 ↔ 𝑎𝜋 ′′) ∧

(cid:219)

(𝑎𝜋 ′ ↔ 𝑎𝜋 ′′)

(cid:17)

𝑎 ∈𝐿out ∪𝐿in

𝑎 ∈𝐻in

The formula states that for every two traces 𝜋, 𝜋 ′, there exists
a trace 𝜋 ′′ that combines the low-security inputs and outputs
on 𝜋 and the high-security inputs on 𝜋 ′.

In this paper, we study the satisfiability problem of Hyper-
LTL. For LTL, satisfiability is PSPACE-complete [39]. For hy-
perproperties, satisfaction cannot be decided by analyzing
single traces in isolation, making formal reasoning challeng-
ing. Deciding satisfiability in the ∃∗∀∗ fragment of HyperLTL
is already EXPSPACE-complete [19]; and deciding hyperprop-
erties with a ∀∗∃∗ trace quantifier alternations is, in gen-
eral, strongly undecidable, namely Σ1
1-complete [24]. The
∀∗∃∗ fragment contains many relevant properties like gen-
eralized noninterference, program refinement, and software
doping [15, 33]. However, positive results for this important
fragment have been very rare and were only obtained by
heavy restrictions on the use of temporal operators or by
assuming finite models [32] (see related work below). Algo-
rithms, even if incomplete, are similarly missing.

In this work, we address these shortcomings by studying
ways of solving satisfiability of ∀∗∃∗ HyperLTL specifica-
tions. We identify simple yet expressive fragments of ∀∗∃∗
with better computational properties, where our approach
derives interesting fragments in two steps. First, we split
a specification into hyperproperty and trace property, so
that we can focus on “simple” hyperproperties. Second, to
find such simple hyperproperties, we systematically study
fragments of temporal safety and temporal liveness hyper-
properties. This work towards new decidable fragments is
complemented by a new (incomplete but often successful)
algorithm that is applicable to arbitrary ∀∃∗ specifications.

 
 
 
 
 
 
LICS ’22, August 2–5, 2022, Haifa, Israel

Beutner et al.

Splitting in Hyperproperties and Trace Properties. So
far, all HyperLTL decidability results were obtained by con-
sidering HyperLTL specifications in isolation. Most of the
time, however, specifications refer to a specific system. The
hyperproperty itself is often relatively simple (like the non-
interference property above) and only gets difficult to sat-
isfy given a specification of the functional behavior of the
system.1 The following example highlights this interplay
between functional property and hyperproperty.

Example 1.1. Consider a system of agents that send and re-
ceive data. Each trace describes the behavior of a single agent.
We want the system to satisfy the following hyperproperty.

𝜑 (cid:66) ∀𝜋∃𝜋 ′.

(send𝜋 ∧ rec𝜋 ′)

The formula states that each agent eventually sends its in-
formation and that there exists some agent receiving it. The
formula on its own is easily satisfiable already by a one-trace
model. In addition to the hyperproperty we add the simple
functional specification (trace property)

𝜓 (cid:66) (¬rec) U (rec ∧

¬rec) ∧ (rec ↔ send)

which expresses that each agent receives data exactly once
and sends it forth in the next step. Every model that satisfies
the combination of 𝜑 and 𝜓 needs to be infinite. Automat-
ically checking satisfiability is thus complex as we cannot
◁
iteratively search for models of bounded (finite) size.

A satisfiability checker that distinguishes between a func-
tional specification and hyperproperties could be used to
sanity-check whether a hyperproperty is satisfiable in com-
bination with the specification of the system at hand.

Temporal Safety and Temporal Liveness. The classifi-
cation into safety and liveness has a long tradition in the
study of trace properties, where especially safety often al-
lows for easier algorithms. For our analysis, we define anal-
ogous fragments: a HyperLTL formula is temporal safety
(resp. temporal liveness) if its LTL body describes a safety
(resp. liveness) property. We study the relationship to the
existing notations of hypersafety and hyperliveness defined
by Clarkson and Schneider [13]. Guided by our insights into
the complete fragments, we derive several more specific
classes of temporal safety and liveness properties, for which
satisfiability is easier to decide.

Main Results. Our results are summarized in Table 1,
where each line represents a class of HyperLTL properties,
and the columns distinguish whether or not additional (arbi-
trarily complex) LTL specifications are allowed. All hardness
results for ∀∗∃∗ fragments, except in the NEXP cases, already
hold for ∀∃∗. The restriction to temporal safety makes the
satisfiability of HyperLTL drop from Σ1
1 to coRE, which we
1Of course, we can incorporate the LTL property in the HyperLTL formula:
we conceptually divide the specification into a (complicated) trace property
and a (simple) hyperproperty.

Table 1. Deciding satisfiability of HyperLTL specifications.
All results, expect for decidability (dec.), denote complete-
ness. Our notation is found in Section 2.3, e.g., ∀∗∃∗.
∗)
is the class of ∀∗∃∗ formulas whose LTL body uses a single

(

operator with optional

operators in its scope.

l
a
r
o
p
m
e
T

y
t
e
f
a
S

l
a
r
o
p
m
e
T

s
s
e
n
e
v
i
L

complete fragment

∀∗∃∗.
∀∗∃∗.
(

∀∗∃∗.

∗

∗)

complete fragment
∀∃∗. det-liveness

∀∃∗.

∗)
∀∗∃∗. ∧ · · · ∧

(

no LTL spec. with LTL spec.
Σ1
coRE [Thm. 3.7]
1 [Thm. 3.11]
NEXP [Thm. 3.12] NEXP [Thm. 3.12]
Σ1
NEXP [Lem. 3.13]
1 [Thm. 3.11]
Σ1
1 [Thm. 3.11]
coRE [Lem. 3.10]
Σ1
Σ1
1 [Thm. 4.2]
1 [Thm. 4.2]
Σ1
1 [Cor. 4.15]
trivial [Prop. 4.14]
dec. [Thm. 4.5]
NP [Lem. 4.4]
Σ1
1 [Thm. 4.11]
NP [Lem. 4.4]

show by an effective reduction to satisfiability of first-order
logic. While still undecidable, this enables the use of com-
mon first-order techniques such as resolution, tableaux, and
related methods [36]. Hardness already holds for simple for-
mulas consisting only of a single with s in its scope. If we
add (non-safety) functional specifications, hardness jumps
back to Σ1
1. In contrast to temporal safety properties, the
class of temporal liveness HyperLTL formulas is of analyti-
cal complexity, even without additional LTL specifications.
However, again in contrast to
∗), formulas from the
(
∗) fragment are decidable, even when combined
∀∃∗.
with an arbitrary LTL specification. This is the first Hyper-
LTL decidability result for formulas that can enforce models
with infinitely many traces. The class also contains the spec-
ification from Example 1.1. This decidability result is tight in
the sense that already conjunctions of multiple eventualities
are analytical again.

(

Finally, to complement our decidability results, we propose
a general approximation algorithm to find the largest model
for specifications consisting of a HyperLTL formula and an
LTL formula. Our experimental evaluation shows that our
algorithm performs significantly better than approaches that
iteratively search for models of bounded size [20, 32] and
can even show unsatisfiability for many formulas (which is
impossible in bounded approaches).

Structure. The remainder of this paper is structured as
follows. We give some basic preliminaries and introduce
HyperLTL in Section 2. We study the fragment of temporal
safety in Section 3. We begin this study with the full frag-
ment, and then gradually decrease in expressiveness all the
way to the fragment containing only
operators. We then
move to temporal liveness in Section 4. Analogous to the
safety case, we begin with the full fragment, gradually de-
creasing to the fragment of pure eventualities, for which we
establish decidability. Finally, in Section 5, we describe our

Deciding Hyperproperties Combined with Functional Specifications

LICS ’22, August 2–5, 2022, Haifa, Israel

approximation for finding the largest models and report on
experimental results in Section 6.

Related Work. In recent years, many logics to express hy-
perproperties have been developed. Most approaches extend
existing logics with trace or path quantification, examples
besides HyperLTL are HyperCTL∗ [13], HyperQPTL [35],
HyperPDL-Δ [26], and HyperATL∗ [6]. Monadic first-order
logics can be extended by adding a special equal-level predi-
cate [22] or using different types of quantifiers [4]. Recently,
hyperproperties have also been obtained via a team seman-
tics for trace logics [29, 42]. Apart from plain temporal logics,
there are also hyperlogics for hyperproperties that are asyn-
chronous [5, 11, 27], quantitative [21], or probabilistic [1, 16].
HyperLTL remains the most used among the proposed
hyperlogics. Its satisfiability problem is known to be challeng-
ing: if we define fragments based on quantifier prefixes (but
with an arbitrary body), then ∃∗∀∗ is the most general frag-
ment for which satisfiability is still decidable (and EXPSPACE-
complete), whereas ∀∃∗ already leads to undecidability [19].
In fact, the ∀∗∃∗ fragment is already satisfiability-complete:
any HyperLTL formula can be effectively translated into
equisatisfiable ∀∗∃∗ formula [32]. Analyzing the case of (un-
restricted) HyperLTL in more detail, Fortin et al. show satisfi-
ability to be Σ1
1-complete, and therefore above all problems in
the arithmetic hierarchy [24]. In a more fine-grained analysis,
Mascle and Zimmermann show that the problem becomes
decidable if one only considers models of a bounded size or
if, for selected quantifier prefixes, temporal operators are
not nested [32]. In particular, ∀∃∗ properties using only
s) are decidable (and always have a finite
and
model), as no “diagonal” comparison between trace positions
is possible [32]. The satisfiability of the logics HyperQPTL
and HyperCTL∗, which both subsume HyperLTL, has been
studied as well [14].

(without

2 Preliminaries
We assume a fixed, finite set of atomic propositions AP and
write Σ (cid:66) 2AP . Given a symbol 𝜋, we write AP𝜋 for the set
{𝑎𝜋 | 𝑎 ∈ AP }. A trace 𝑡 is an element in Σ𝜔 . For 𝑖 ∈ N,
𝑡 (𝑖) denotes the 𝑖th element in 𝑡 (starting with the 0th) and
𝑡 [𝑖, ∞] is the suffix of a trace starting in point in time 𝑖. For
a finite trace 𝑢 ∈ Σ∗ and an infinite trace 𝑡 ∈ Σ𝜔 , 𝑢 is a prefix
of 𝑡 (written 𝑢 ⋖ 𝑡) if for every 0 ≤ 𝑖 < |𝑢 |, 𝑢 (𝑖) = 𝑡 (𝑖). A
trace property 𝑃 is a set of traces, whereas a hyperproperty
𝐻 is a set of sets of traces [13].

2.1 Trace Properties and LTL
Linear temporal logic (LTL) defines trace properties by com-
bining temporal operators with boolean connectives. Its syn-
tax is defined by the following grammar.

𝜓 (cid:66) 𝑎 | ¬𝜓 | 𝜓 ∧ 𝜓 | 𝜓 | 𝜓 U 𝜓

where 𝑎 ∈ AP. We also use the standard Boolean connectives
∧, →, ↔ and constants ⊤, ⊥, as well as the derived LTL
𝜓 (cid:66)
𝜓 (cid:66) ⊤ U 𝜓 , and globally
operators eventually
¬ ¬𝜓 . The semantics of LTL is defined as usual.

𝑡 |= 𝑎
𝑡 |= ¬𝜓
𝑡 |= 𝜓1 ∧ 𝜓2
𝑡 |= 𝜓
𝑡 |= 𝜓1 U 𝜓2

iff 𝑎 ∈ 𝑡 (0)
iff 𝑡 ̸|= 𝜓
iff 𝑡 |= 𝜓1 and 𝑡 |= 𝜓2
iff 𝑡 [1, ∞] |= 𝜓
iff ∃𝑖. 𝑡 [𝑖, ∞] |= 𝜓2 and ∀𝑗 < 𝑖. 𝑡 [ 𝑗, ∞] |= 𝜓1
Safety and liveness properties are prominent classes of
trace properties [2]. Safety properties are characterized by
the fact that each violation is caused after a finite time. Live-
ness properties characterize that something good happens
eventually.

Definition 2.1. A property 𝑃 is safety if it holds that for
every trace 𝑡 ∉ 𝑃, there exists a 𝑢 ⋖ 𝑡 such that for every 𝑡 ′
with 𝑢 ⋖ 𝑡 ′, we have 𝑡 ′ ∉ 𝑃. A property 𝑃 is liveness if for
every 𝑢 ∈ Σ∗, there exists a 𝑡 ∈ Σ𝜔 with 𝑢 ⋖ 𝑡 and 𝑡 ∈ 𝑃.

2.2 Hyperproperties and HyperLTL
HyperLTL [12] extends LTL with explicit quantification over
traces, thereby lifting it from a logic expressing trace prop-
erties to one expressing hyperproperties [13]. Let V be a set
of trace variables. We define HyperLTL formulas with the
following grammar.

𝜑 (cid:66) ∃𝜋 . 𝜑 | ∀𝜋 . 𝜑 | 𝜙
𝜙 (cid:66) 𝑎𝜋 | ¬𝜙 | 𝜙 ∧ 𝜙 |

𝜙 | 𝜙 U 𝜙

Here, 𝜋 ∈ V and 𝑎 ∈ AP. We consider only closed formulas,
i.e., formulas where for each atom 𝑎𝜋 the trace variable 𝜋 is
bound by some trace quantifier. The semantics of HyperLTL
is given with respect to a set of traces 𝑇 and a trace assign-
ment Π, which is a partial mapping Π : V ⇀ Σ𝜔 . For 𝜋 ∈ V
and 𝑡 ∈ 𝑇 , we write Π[𝜋 ↦→ 𝑡] for the trace assignment
obtained by updating the value of 𝜋 to 𝑡. We write Π[𝑖, ∞]
for the assignment Π[𝑖, ∞] (𝜋) (cid:66) Π(𝜋) [𝑖, ∞].

Π |=𝑇 𝑎𝜋
Π |=𝑇 ¬𝜙
Π |=𝑇 𝜙1 ∧ 𝜙2
Π |=𝑇
Π |=𝑇 𝜙1 U 𝜙2

𝜙

Π |=𝑇 ∃𝜋 . 𝜑
Π |=𝑇 ∀𝜋 . 𝜑

iff 𝑎 ∈ Π(𝜋)(0)
iff Π ̸|=𝑇 𝜙
iff Π |=𝑇 𝜙1 and Π |=𝑇 𝜙2
iff Π[1, ∞] |=𝑇 𝜙
iff ∃𝑖. Π[𝑖, ∞] |=𝑇 𝜙2 and

∀𝑗 < 𝑖. Π[ 𝑗, ∞] |=𝑇 𝜙1
iff ∃𝑡 ∈ 𝑇 . Π[𝜋 ↦→ 𝑡] |=𝑇 𝜑
iff ∀𝑡 ∈ 𝑇 . Π[𝜋 ↦→ 𝑡] |=𝑇 𝜑

We say that 𝑇 is a model of 𝜑 (written 𝑇 |= 𝜑) if ∅ |=𝑇 𝜑,
where ∅ denotes the empty trace assignment.

Remark 2.2. HyperLTL is closed under conjunction (and,
more generally, under any boolean combination). For two

LICS ’22, August 2–5, 2022, Haifa, Israel

Beutner et al.

HyperLTL formulas 𝜑1, 𝜑2, we therefore write 𝜑1 ∧ 𝜑2 for
some HyperLTL formula expressing the conjunction of 𝜑1, 𝜑2.
𝑏𝜋 ) can be
For examples (∀𝜋∃𝜋 ′.
◁
expressed as ∀𝜋∀𝜋 ′∃𝜋 ′′.

(𝑎𝜋 ↮ 𝑎𝜋 ′)) ∧ (∀𝜋 .

(𝑎𝜋 ↮ 𝑎𝜋 ′′) ∧ 𝑏𝜋 ′.

Analogous to trace properties, we can characterize hyper-
properties as hypersafety and hyperliveness [13]. We lift the
prefix relation ⋖ to sets of traces: a set 𝑈 ⊆ Σ∗ of finite traces
is a prefix of a set 𝑇 ⊆ Σ𝜔 (written 𝑈 ⋖𝑇 ) if, for every 𝑢 ∈ 𝑈 ,
there exists a 𝑡 ∈ 𝑇 such that 𝑢 ⋖ 𝑡.

Definition 2.3. A hyperproperty 𝐻 is hypersafety if for ev-
ery 𝑇 ⊆ Σ𝜔 with 𝑇 ∉ 𝐻 , there exists a finite set 𝑈 ⊆ Σ∗ with
𝑈 ⋖ 𝑇 such that, for every 𝑇 ′ ⊆ Σ𝜔 with 𝑈 ⋖ 𝑇 ′, we have
𝑇 ′ ∉ 𝐻 . A property 𝐻 is hyperliveness if for every finite set
𝑈 ⊆ Σ∗, there exists 𝑇 ⊆ Σ𝜔 with 𝑈 ⋖ 𝑇 and 𝑇 ∈ 𝐻 .

Intuitively, a violation of a hypersafety property can be
explained by the finite interaction of finitely many traces.
Conversely, a hyperproperty is hyperliveness, if such a set
can always be extended to a set satisfying the property.

2.3 Specifications and Notation
We study the combination of ∀∗∃∗ HyperLTL formulas and
arbitrary LTL formulas, and call such pairs specifications.

Definition 2.4. A specification is a pair (𝜓, 𝜑) where 𝜓 is an
LTL formula and 𝜑 a HyperLTL formula. We say that (𝜓, 𝜑)
is satisfiable iff there exists a non-empty set of traces 𝑇 ⊆ Σ𝜔
such that ∀𝑡 ∈ 𝑇 . 𝑡 |= 𝜓 and 𝑇 |= 𝜑.

In general, we write (𝜓, 𝜑) for specifications with arbi-
trary LTL and HyperLTL formulas. We use the following
notation for fragments of specifications. We write (⊤, 𝜑)
to indicate that no LTL formula is given or, equivalently,
the trace specification is true. We represent the quantifier
prefix of the HyperLTL property using regular expressions.
For example, ∀∃∗ is a prefix consisting of a single univer-
sal quantifier followed by any number of existential quan-
tifiers. We write 𝑄 ∗ for an arbitrary prefix. The body of a
HyperLTL formula is structured based on the use of temporal
operators. We allow propositional (temporal-operator-free)
formulas as conjuncts if not stated otherwise Consider the
following example. A ∀∗∃∗.
∗) formula is of the form
(
∀𝜋1 . . . ∀𝜋𝑛∃𝜋𝑛+1 . . . ∃𝜋𝑛+𝑚. ( 𝜙) ∧ 𝜙 ′, where 𝜙 may con-
tain (potentially nested)
operators and 𝜙 ′ does not contain
any temporal operators. Analogously, a formula in ∀∗∃∗.
describes formulas as the one above but 𝜙 may not contain
uses a conjunction of two

s. A formula in ∀∗∃∗. ∧

eventualities (also without

s).

2.4 Complexity of Undecidable Problems
Many problems considered in this paper are highly undecid-
able. To enable precise quantification of “how undecidable”,
we briefly recall the arithmetic and analytical hierarchy. We
only provide a brief overview and refer to [37] for details.

The arithmetic hierarchy contains all problems (languages)
that can be expressed in first-order arithmetic over the natu-
ral numbers. It contains the class of recursively enumerable
(RE) and co-enumerable problems (coRE) in its first level. The
class Σ1
1 (sitting in the analytical hierarchy) contains all prob-
lems that can be expressed with existential second-order
quantification (over sets of numbers) followed by a first-
order arithmetic formula. Analogously, the class Π1
1 contains
all problems expressible using universal second-order quan-
tification. Consequently, both Σ1
1 (strictly) contain
the entire arithmetic hierarchy.

1 and Π1

2.5 Machines
As a basic model of computation to show hardness we use
two-counter machines. A nondeterministic 2-counter machine
(2CM) consists of a finite set of instructions 𝑙1, . . . 𝑙𝑛, which
modify two counters 𝑐1, 𝑐2. Each instruction 𝑙𝑖 is of one of
the following forms, where 𝑥 ∈ {1, 2} and 1 ≤ 𝑖, 𝑗, 𝑘 ≤ 𝑛.
1) 𝑙𝑖 : 𝑐𝑥 (cid:66) 𝑐𝑥 + 1; goto {𝑙 𝑗, 𝑙𝑘 }
2) 𝑙𝑖 : 𝑐𝑥 (cid:66) 𝑐𝑥 − 1; goto {𝑙 𝑗, 𝑙𝑘 }
3) 𝑙𝑖 : if 𝑐𝑥 = 0 then goto 𝑙 𝑗 else goto 𝑙𝑘
4) 𝑙𝑖 : halt
Here, goto {𝑙 𝑗, 𝑙𝑘 } indicates that the machine nondetermin-
istically chooses between instructions 𝑙 𝑗 and 𝑙𝑘 . A config-
uration of a 2CM is a tuple (𝑙𝑖, 𝑣1, 𝑣2), where 𝑙𝑖 is the next
instruction to be executed, and 𝑣1, 𝑣2 ∈ N denote the values
of the counters. The initial configuration of a 2CM is (𝑙1, 0, 0).
The transition relation between configurations is defined as
expected. Decrementing a counter that is already 0 leaves
the counter unchanged. A 2CM halts if a configuration with
a halt instruction is reached. Deciding if a machine has a
halting computation is RE-complete and deciding if it has an
infinite computation is coRE-complete [34]. An infinite com-
putation is recurring if it visits instruction 𝑙1 infinitely many
times. Deciding if a machine has a recurring computation, is
Σ1
1-hard [3, 23].

3 Temporal Safety
In this section, we study the satisfiability problem of tem-
poral safety HyperLTL formulas. We begin by defining tem-
poral safety and argue why, compared to hypersafety, it is
the more suitable fragment in the context of satisfiability.
Subsequently, we show that temporal safety specifications
improve the general Σ1
1-hardness of ∀∗∃∗ hyperproperties
[24] to coRE-complete. We obtain this result by a reduction
to satisfiability of first-order logic. In the next step, we inves-
tigate the combination of temporally safe hyperproperties
with arbitrary functional trace specifications given in LTL.
The complexity jumps again to Σ1
1-completeness, perhaps
surprisingly already for very basic ∀∃∗ formulas only us-
as temporal operator. We, therefore, analyze the
ing one
remaining fragments for decidability results and establish
s as temporal operators
that hyperproperties that only use

Deciding Hyperproperties Combined with Functional Specifications

LICS ’22, August 2–5, 2022, Haifa, Israel

are NEXPTIME-complete, even when adding arbitrary LTL
specifications. The same holds for hyper-invariants (using

) without an LTL specification.

3.1 Hypersafety and Temporal Safety
The safety fragment of LTL is one of the most successful
fragments of temporal logics as it is amendable to easier
monitoring and verification than arbitrary 𝜔-regular proper-
ties [30]. The concept of a safety property (i.e., every viola-
tion is caused after a finite time) naturally extends to hyper-
properties, giving the general class of hypersafety (cf. Defi-
nition 2.3) [13]. However, hypersafety is not well suited for
a systematic study of the decidability of hyperproperties.
Deciding if a property is hypersafety is already highly unde-
cidable and deciding if a hypersafety property is satisfiable
is directly reducible to LTL satisfiability.

1-hard.

Proposition 3.1. Deciding if a HyperLTL formula 𝜑 is hy-
persafety is Π1
Proof. As shown in [18, Thm. 23], for any HyperLTL formula
𝜑 we can effectively construct a formula 𝜑 ′ such that 𝜑 is
unsatisfied iff 𝜑 ′ is hypersafety. As HyperLTL unsatisfiability
is Π1
□

1-hard [24], the hardness follows.

Proposition 3.2. Given a HyperLTL formula 𝜑 that is hy-
persafety, satisfiability of 𝜑 is decidable in PSPACE.

Proof. As hypersafety properties are closed under subsets
[13], 𝜑 is satisfiable iff it is satisfiable by a single trace model.
Therefore, we can collapse all quantifiers in 𝜑 to universal
ones, giving an equisatisfiable (but not equivalent) ∀∗ for-
mula for which satisfiability is decidable in PSPACE [19]. □

Instead of focusing on hypersafety, we study the satisfia-
bility problem for a broader fragment of formulas which we
call temporally safe.

Definition 3.3. A HyperLTL formula 𝑄𝜋1 . . . 𝑄𝜋𝑛. 𝜙 is tem-
poral safety if 𝜙 (interpreted as an LTL formula over AP𝜋1 ∪
. . . ∪ AP𝜋𝑛 ) describes a safety property.

Similar to the case of LTL [30], the safety restriction on the
body of the HyperLTL formula allows for easier verification
(see, e.g., [7, 8]). We argue that temporal safety is also an
interesting fragment to study in the context of satisfiability.
First, compared with hypersafety, it is decidable whether
a formula is temporally safe, as safety is recognizable for
LTL [38]. Second, the next two propositions show that tem-
poral safety defines an expressive fragment: it subsumes all
∀∗∃∗ hypersafety properties.

Proposition 3.4. For any ∀∗ hypersafety property, there ex-
ists an equivalent ∀∗ property that is temporally safe.

Proof. Let 𝜑 = ∀𝜋1 . . . 𝜋𝑛. 𝜙 be the hypersafety property. For
any function 𝑓 : {1, . . . , 𝑛} → {1, . . . , 𝑛} (of which there are
𝑛𝑛 many) we define the formula 𝜙 [𝑓 ] as the formula obtained

by replacing each trace variable 𝜋𝑖 for 1 ≤ 𝑖 ≤ 𝑚 with 𝜋𝑓 (𝑖) .
Define 𝜑 ′ (cid:66) ∀𝜋1 . . . 𝜋𝑛. 𝜙 ′ where
(cid:219)

𝜙 ′ (cid:66)

𝜙 [𝑓 ]

𝑓 :{1,...,𝑛 }→{1,...,𝑛 }
It is easy to see that 𝜑 ≡ 𝜑 ′ (using the semantics of universal
quantification). We claim that 𝜙 ′ expresses a safety property
when interpreted as trace property over AP𝜋1 ∪ · · · ∪ AP𝜋𝑛 .
Take any trace 𝑡 over AP𝜋1 ∪ · · · ∪AP𝜋𝑛 with 𝑡 ̸|= 𝜙 ′ (as in the
definition of safety, cf. Definition 2.1). Let 𝑇 = {𝑡1, . . . , 𝑡𝑛 }
be the set obtained by splitting 𝑡 into 𝑛 traces, i.e., 𝑡𝑖 is a
trace over AP that copies the assignments to AP𝜋𝑖 on 𝑡. By
construction of 𝑇 we get 𝑇 ̸|= 𝜑 ′ and, as 𝜑 ≡ 𝜑 ′ is hypersafety,
we get a finite set of finite traces 𝑈 ⋖𝑇 such that no extension
of 𝑈 satisfies 𝜑. We assume that 𝑈 = {𝑢1, . . . , 𝑢𝑛 } where 𝑢𝑖 ⋖𝑡𝑖
for each 𝑖. This assumption is w.l.o.g., as we can replace
multiple prefixes of the same 𝑡𝑖 by the longest among those
prefixes, and add an arbitrary prefix of each 𝑡𝑖 that previously
had no prefix in 𝑈 . We further assume, again w.l.o.g., that
all 𝑢𝑖 s have the same length, say 𝑘. Now define 𝑢 as the
finite trace (of length 𝑘) over AP𝜋1 ∪ · · · ∪ AP𝜋𝑛 , where the
assignment to AP𝜋𝑖 is taken from 𝑢𝑖 . As 𝑢𝑖 ⋖ 𝑡𝑖 for each 𝑖,
we get 𝑢 ⋖ 𝑡. It remains to argue that 𝑢 is a bad prefix of
𝜙 ′. Let 𝑡 ′ be any trace with 𝑢 ⋖ 𝑡 ′. We, again, split 𝑡 ′ into
𝑛 } satisfies 𝑈 ⋖ 𝑇 ′, so
traces 𝑡 ′
𝑇 ′ ̸|= 𝜑. By the semantics of universal quantification, there
thus exists a 𝑓 such that [𝜋1 ↦→ 𝑡 ′
𝑓 (𝑛) ] ̸|= 𝜙
, . . . , 𝜋𝑛 ↦→ 𝑡 ′
𝑛] ̸|= 𝜙 [𝑓 ]. This implies that
and so [𝜋1 ↦→ 𝑡 ′
□
𝑡 ′ ̸|= 𝜙 [𝑓 ] in the LTL semantics so 𝑡 ′ ̸|= 𝜙 ′ as required.

𝑛. Now 𝑇 ′ (cid:66) {𝑡 ′

1, . . . , 𝜋𝑛 ↦→ 𝑡 ′

1, . . . , 𝑡 ′

1, . . . , 𝑡 ′

𝑓 (1)

Remark 3.5. We do not claim that every ∀∗ hypersafety
property is temporally safe. Instead, Proposition 3.4 only
states that there exists an equivalent temporally safe prop-
(𝑎𝜋 ∧ ¬𝑎𝜋 ′) is unsatisfiable and
erty. For example, ∀𝜋∀𝜋 ′.
(𝑎𝜋 ∧ ¬𝑎𝜋 ′) is not a safety prop-
thus hypersafety but
◁
erty.

Proposition 3.6. For any ∀∗∃∗ hypersafety property, there
exists an equivalent ∀∗ property that is temporally safe.

Proof. Let 𝜑 = ∀𝜋1 . . . 𝜋𝑛∃𝜋 ′
𝑚. 𝜙 be hypersafety. For a
1 . . . 𝜋 ′
function 𝑔 : {1, . . . , 𝑚} → {1, . . . , 𝑛} we define the formula
𝜙 [𝑔] as the formula obtained by replacing each trace variable
𝑖 for 1 ≤ 𝑖 ≤ 𝑚 with 𝜋𝑔 (𝑖) . Now define:
𝜋 ′

𝜑 ′ (cid:66) ∀𝜋1 . . . 𝜋𝑛.

(cid:220)

𝜙 [𝑔]

𝑔:{1,...,𝑚 }→{1,...,𝑛 }

We claim that 𝜑 ≡ 𝜑 ′. Showing that 𝜑 ′ implies 𝜑 is easy as
the disjunction gives an explicit witness for the existential
quantifiers. For the other direction, assume 𝑇 |= 𝜑 for some
model 𝑇 . Let 𝑡1, . . . , 𝑡𝑛 ∈ 𝑇 be arbitrary. As 𝜑 is a hypersafety
property and {𝑡1, . . . , 𝑡𝑛 } ⊆ 𝑇 , we get that {𝑡1, . . . , 𝑡𝑛 } |= 𝜑. In
particular, if we bind each 𝜋𝑖 to 𝑡𝑖 (in 𝜑), we get witness traces
𝑚 ∈ {𝑡1, . . . , 𝑡𝑛 } for the existential quantifiers in 𝜑.
𝑡 ′
1, . . . , 𝑡 ′
Now define 𝑔 by mapping each 1 ≤ 𝑗 ≤ 𝑚 to 𝑖 ∈ {1, . . . , 𝑛}

LICS ’22, August 2–5, 2022, Haifa, Israel

Beutner et al.

𝑗 = 𝑡𝑖 . The trace assignment [𝜋1 ↦→ 𝑡1, . . . , 𝜋𝑛 ↦→ 𝑡𝑛]
with 𝑡 ′
satisfies 𝜙 [𝑔]. As we can find such a 𝑔 for every 𝑡1, . . . , 𝑡𝑛 ∈ 𝑇 ,
we get that 𝑇 |= 𝜑 ′ as required. As 𝜑 ′ is a ∀∗ formula, we can
□
conclude using Proposition 3.4.

While temporal safety subsumes ∀∗∃∗ hypersafety, it is a
strictly larger fragment as shown by the following formula.

(cid:0)∃𝜋 . 𝑎𝜋 (cid:1) ∧ (cid:0)∀𝜋 .
(cid:0)∀𝜋∃𝜋 ′.

(𝑎𝜋 → ¬𝑎𝜋 )(cid:1)∧

(𝑎𝜋 ↔ 𝑎𝜋 ′)(cid:1)
Every model of this property must contain infinitely many
traces. Hypersafety properties, on the other hand, are closed
under subsets and are therefore always satisfiable by a single
trace model (if satisfiable at all) [13].

3.2 Temporal Safety without Functional

Specifications

Having established that temporal safety spans a broad spec-
trum of properties, we now establish that the general analyt-
ical hardness of HyperLTL [24] drops to coRE-completeness
for temporal safety.

Theorem 3.7. The satisfiability problem of temporally safe
HyperLTL is coRE-complete.

We show the upper bound of Theorem 3.7 by giving an
effective translation from temporally safe HyperLTL to first-
order logic using the fact that satisfiability of first-order
logic is coRE-complete [25]. Our translation enables the ap-
plication of first-order satisfiability solvers in the realm of
hyperproperties.

Definition 3.8. A safety automaton over alphabet Σ is a
tuple A = (𝑄, 𝑞0, 𝛿) where 𝑄 is a finite set of states, 𝑞0 ∈ 𝑄
the initial state, and 𝛿 ⊆ 𝑄 ×Σ×𝑄 is the transition relation. A
trace 𝑡 ∈ Σ𝜔 is accepted by A if there exists some infinite run
𝑟 ∈ 𝑄𝜔 such that 𝑟 (0) = 𝑞0 and for all 𝑖, (𝑟 (𝑖), 𝑡 (𝑖), 𝑟 (𝑖 + 1)) ∈
𝛿. For every safety trace property 𝜙, there exists a safety
automaton that accepts 𝜙 [30].

Proposition 3.9. The satisfiability problem of temporally
safe HyperLTL is in coRE.
Proof. Let 𝜑 = 𝑄1𝜋1 . . . 𝑄𝑛𝜋𝑛. 𝜙 be a temporally safe Hyper-
LTL formula. Let A𝜙 = (𝑄𝜙, 𝑞0,𝜙, 𝛿𝜙 ) be a safety automaton
over Σ (cid:66) 2AP𝜋1 ∪···∪AP𝜋𝑛 that accepts 𝜙 (when interpreted
as an LTL formula over AP𝜋1 ∪ · · · ∪ AP𝜋𝑛 ). We define in
the following an equisatisfiable first-order formula Θ, which
can be computed from 𝜑. For readability, we use two-sorted
first-order logic, which is equisatisfiable to standard first-
order logic. We use two sorts: Trace, which contains trace
variables, and TimePoint, which contains time variables. We
use the constant 𝑖0 : TimePoint to indicate the initial time
point. The predicate Succ(·, ·) over TimePoint × TimePoint
encodes the successor relation on time. For each 𝑎 ∈ AP,
we use a predicate 𝑃𝑎 (·, ·) over Trace × TimePoint to indicate

that on trace 𝑡, 𝑎 holds at point in time 𝑖. For each state
𝑞 ∈ 𝑄𝜙 we use a predicate State𝑞 over Trace𝑛 × TimePoint.
Informally, State𝑞 (𝑥1, . . . , 𝑥𝑛, 𝑖) indicates that a run of A on
traces 𝑥1, . . . , 𝑥𝑛 is in state 𝑞 at timepoint 𝑖.

We first ensure that each point in time has a successor

and that the set of traces is non-empty.

(cid:66) ∀𝑖 : TimePoint. ∃𝑖 ′ : TimePoint. Succ(𝑖, 𝑖 ′)

𝜙succ
𝜙non-empty (cid:66) ∃𝑥 : Trace. ⊤

For each state 𝑞 ∈ 𝑄𝜙 , we construct a formula 𝜌𝑞 (over free
variables 𝑥1, . . . , 𝑥𝑛), describing that, for any choice of traces
and at any point in time, there is a transition in A.

𝜌𝑞 (cid:66) ∀𝑖, 𝑖 ′ : TimePoint. State𝑞 (𝑥1, . . . , 𝑥𝑛, 𝑖) ∧ Succ(𝑖, 𝑖 ′)

→

(cid:220)

(cid:16) (cid:219)

𝑃𝑎 (𝑥 𝑗, 𝑖) ∧

(cid:219)

¬𝑃𝑎 (𝑥 𝑗, 𝑖) ∧

(𝑞,𝜎,𝑞′) ∈𝛿𝜙

𝑎𝜋 𝑗 ∈𝜎

𝑎𝜋 𝑗 ∉𝜎
(cid:17)

State𝑞′ (𝑥1, . . . , 𝑥𝑛, 𝑖 ′)

Now, Θ is defined as follows

Θ (cid:66) 𝑄1𝑥1 : Trace. . . . 𝑄𝑛𝑥𝑛 : Trace. 𝜙succ ∧ 𝜙non-empty
𝜌𝑞 ∧ State𝑞0 (𝑥1, . . . , 𝑥𝑛, 𝑖𝑜 ).

(cid:219)

∧

𝑞 ∈𝑄

The last conjunct ensures that all trace tuples chosen by the
quantifiers have an infinite run in A starting in the initial
state and in the initial time point. If Θ is satisfiable, we can
construct a trace assignment by setting the propositions
based on the evaluation of 𝑃𝑎 (·, ·) in a satisfying first-order
model of Θ and vice versa. A detailed proof can be found in
□
Appendix A.

To complement the upper bound, we show coRE-hardness
by reducing the complement of the halting problem of deter-
ministic Turing machines. The proof shows that already a
single with nested

suffices for coRE-hardness.

Lemma 3.10. The satisfiability problem is coRE-hard for
specifications (⊤, 𝜑) where 𝜑 is of the form ∀∃∗.

∗).

(

Proof sketch. We encode the non-termination of determinis-
tic Turning machines, which is coRE-hard. Each trace rep-
resents a configuration of the machine and the ∀∃ formula
demands that each configuration encoded in trace 𝜋 has a
successor configuration on some trace 𝜋 ′. As the transitions
of a TM can be checked locally, we can encode a successor
configuration by comparing every three consecutive posi-
tions on 𝜋 and 𝜋 ′, which is possible with a single globally.
□
We give a detailed proof in Appendix A.

This completes the proof of Theorem 3.7.

3.3 Temporal Safety with Functional Specifications
We now investigate satisfiability for the combination of tem-
porally safe HyperLTL formulas and LTL properties. If the
LTL specification is safety, we can simply merge the trace

Deciding Hyperproperties Combined with Functional Specifications

LICS ’22, August 2–5, 2022, Haifa, Israel

property with the temporally safe hyperproperty, maintain-
ing the applicability of Theorem 3.7. The situation changes
if we allow non-safety trace properties.

.

1-complete for

Theorem 3.11. The satisfiability problem is Σ1
specifications (𝜓, 𝜑) where 𝜑 is of the form ∀∃∗.
Proof sketch. Membership in Σ1
1 follows from [24]. For hard-
ness, we encode recurring computations of nondeterministic
two-counter machines. We represent each configuration by
encoding the current instruction and two atomic proposi-
tions c1, c2 that hold exactly once, i.e., counter 𝑥 has value 𝑣
if c𝑥 occurs in the 𝑣th position. To ensure a recurring com-
putation, we add a third counter 𝑡 that decreases in each
step. When it reaches 0, the trace must encode the initial
instruction, at which point 𝑡 is reset to any value. The key
idea of the proof is that each trace in the model represents
two consecutive configurations, which are encoded over dis-
joint copies of AP (for 𝑖 ∈ {1, 2}, AP𝑖 = {𝑎𝑖
| 𝑎 ∈ AP}). In
LTL, we can express that the second configuration encoded
in a trace is a successor of the first configuration in that
trace. Furthermore, we express in LTL that the value of 𝑡
either decreases or the initial instruction is executed. In the
HyperLTL property we ensure the existence of the initial
configuration, and state that for each trace 𝜋, there exist a
𝜋 ′ such that the second configuration on 𝜋 equals the first
on 𝜋 ′. We can express the latter as

∀𝜋∃𝜋 ′. (cid:211)𝑎 ∈AP

𝜋 ↔ 𝑎1
𝑎2
𝜋 ′.

The resulting specification is satisfiable if and only if the
machine has a recurring computation. We give a detailed
□
proof in Appendix A.

operator suffices to jump to Σ1

3.4 Propositional Hyperproperties and Invariants
As we have seen, with arbitrary LTL properties present, a
1. This leaves hyper-
single
properties expressed using only s as the only sub-analytical
fragment. We settle the precise complexity of the resulting
problem to be NEXPTIME-complete.

Theorem 3.12. The satisfiability problem is NEXPTIME-com-
plete for specifications (𝜓, 𝜑) where 𝜑 is of the form 𝑄 ∗.
∗.
Hardness holds already for 𝜓 = ⊤, a ∀∗∃∗ prefix, and no
s.
Proof sketch. To show containment, we nondeterministically
guess a set of finite traces 𝑀 ⊆ Σ𝑘 , where 𝑘 is the number
of
operators in the formula. We then verify that each
trace in 𝑀 can be extended to one satisfying 𝜓 and that
𝑀 is a model of the hyperproperty. For the lower bound,
we reduce the acceptance of an exponential-time bounded
nondeterministic Turing machine to a HyperLTL formula.
Our encoding is a ∀∗∃∗-formula, which does not contain any
temporal operators (not even ) and no trace property. Each
trace in our model encodes a piece of information (𝑠, 𝑝, 𝛾, 𝑞),
where 𝑠, 𝑝 ∈ N, 𝛾 is a tape symbol of the TM, and 𝑞 either
a state of the TM or ⊥. The tuple (𝑠, 𝑝, 𝑡, 𝑞) encodes that

in time-step 𝑠 and at position 𝑝, the tape content is 𝛾, and
either the head is at position 𝑝 and the machine is in state
𝑞, or the head is not at position 𝑝 (if 𝑞 = ⊥). As the TM
is time (and thus space) bounded, 𝑠 and 𝑝 are bound by 2𝑛
for some 𝑛. We show that we can express in HyperLTL that
the information encoded in a given model defines a valid
accepting run of the TM. The resulting formula is satisfiable
iff TM has an accepting computation. As we can never refer
to all exponentially many positions explicitly, we use ∀∗∃∗
formulas to encode a counter that references all positions.
□
We give a formal proof in the Appendix A.
We note that HyperLTL without temporal operators has
a strong connection to quantified boolean formulas (QBF),
the validity of which is a standard PSPACE-complete problem
[40]. In contrast to QBF, where the quantifier structure spans
the polynomial hierarchy, our proof shows that in Hyper-
LTL, the ∀∗∃∗ fragment suffices to show NEXPTIME-hardness
(refuting a conjecture in [32] that temporal-operator-free
HyperLTL is equivalent to QBF). The reason is that Hyper-
LTL satisfiability asks for the existence of some model for
which the formula holds (which is related to the more general
second-order QBF problem [31]).

If we forgo the additional trace property, we can also show
the following lemma. Hardness already holds if we disallow
propositional formulas outside of the

.

Lemma 3.13. The satisfiability problem is NEXPTIME-com-
plete for specifications (⊤, 𝜑) where 𝜑 is of the form ∀∗∃∗.
.
Proof. A property 𝜑 = ∀𝑛∃𝑚. ( 𝜙) ∧ 𝜙 ′ (where 𝜙, 𝜙 ′ do not
contain any temporal operators) is satisfiable iff ∀𝑛∃𝑚. 𝜙 ∧𝜙 ′
is satisfiable. The result then follows using Theorem 3.12. □

4 Temporal Liveness
The natural counterparts of safety properties are liveness
properties, which postulate that “something good happens
eventually”. Similar to the case of hypersafety, hyperliveness
as a fragment is not well-suited when studying satisfiability:
any hyperliveness property is, by definition, satisfiable. Anal-
ogously to our study of temporal safety, we instead study
HyperLTL properties whose body is a liveness property.

Definition 4.1. A HyperLTL formula 𝑄𝜋1 . . . 𝑄𝜋𝑛. 𝜙 is a
temporal liveness property if 𝜙 (interpreted as an LTL formula
over AP𝜋1 ∪ · · · ∪ AP𝜋𝑛 ) describes a liveness property.

We examine the temporal liveness fragment following
the structure of Section 3 and point out analogous results
wherever possible. As in Section 3, we first examine the
entire class of temporal liveness and then gradually restrict
this class to obtain new decidability results.

4.1 Hyperliveness and Temporal Liveness
As opposed to the safety case (cf. Proposition 3.6), temporal
liveness and hyperliveness are incomparable. In temporal
liveness, we can easily express falsity via ∀𝜋∀𝜋 ′.
(𝑎𝜋 ∧

LICS ’22, August 2–5, 2022, Haifa, Israel

Beutner et al.

¬𝑎𝜋 ′), which is not hyperliveness. Conversely, the property
(𝑎𝜋 ↮ 𝑎𝜋 ′) is hyperliveness (as we can always add
∀𝜋∃𝜋 ′.
more witness traces) but not expressible in temporal liveness.

an equisatisfiable ∀2∃∗ HyperLTL formula [32, Thm. 5], so
Theorem 4.3 shows that deciding temporal liveness can be
used to decide full HyperLTL.

1-hard.
1-hard for ∀∃∗

4.2 General Temporal Liveness
Analogous to Theorem 3.7, we consider the full fragment of
temporal liveness. Different from the fragment of temporal
safety, the class of temporal liveness is already Σ1

Theorem 4.2. The satisfiability problem is Σ1
temporal liveness HyperLTL formulas.

To prove Theorem 4.2, we show a stronger result: we
can effectively reduce every ∀∗∃∗ HyperLTL property to an
equisatisfiable temporal liveness property.

Theorem 4.3. Let (𝜓, 𝜑) be a specification where 𝜑 is of the
form ∀𝑛∃𝑚. 𝜙, and 𝜓 and 𝜙 are arbitrary but satisfiable LTL
formulas. Then there is an effectively computable specifica-
tion (𝜓 ′, 𝜑 ′) such that 𝜓 ′ is an LTL liveness property, 𝜑 ′ is a
∀𝑛∃𝑚 temporal liveness property, and (𝜓, 𝜑) and (𝜓 ′, 𝜑 ′) are
equisatisfiable.
Proof. The idea is to move the start position of the formula
under a
operator. We introduce a fresh atomic proposi-
tion † and ensure that all traces satisfy the liveness prop-
erty
¬†
holds (the last time that † is true) is then the “start posi-
tion” to evaluate the formula. Let 𝜑 = 𝑄 ∗. 𝜙 where 𝑄 ∗ =
∀𝜋1 . . . 𝜋𝑛∃𝜋𝑛+1 . . . 𝜋𝑛+𝑚 is the quantifier prefix of 𝜑. Define

¬†). The unique position where † ∧

(† ∧

𝜑 ′ (cid:66) 𝑄 ∗.

(cid:20) 𝑛+𝑚
(cid:219)

𝑖=1

(cid:104)

†𝜋𝑖 ∧

(cid:21)

(cid:105)

∧ 𝜙

¬ †𝜋𝑖

𝑛+𝑚
(cid:219)

𝑖=1

In similar fashion, we define 𝜓 ′ (cid:66) († ∧ (
¬†) ∧𝜓 ). It is
easy to see that both the LTL body of 𝜑 ′ and 𝜓 ′ are liveness
properties. Here it is crucial that we assumed that 𝜓 and 𝜙
are satisfiable.

We now claim that (𝜓, 𝜑) is satisfiable if and only if (𝜓 ′𝜑 ′)
is satisfiable. For the first direction, assume that 𝑇 is a model
for (𝜓, 𝜑). The model with † added to the first step of all
traces satisfies (𝜓 ′, 𝜑 ′). For the other direction, let 𝑇 be a
model of (𝜓 ′, 𝜑 ′). We assume w.l.o.g. that there is no subset
𝑇 ′ ⊊ 𝑇 such that 𝑇 ′ is also a model for (𝜓 ′, 𝜑 ′). The property
enforces that for any traces 𝑡1, . . . , 𝑡𝑛+𝑚, where 𝑡𝑛+1, . . . , 𝑡𝑛+𝑚
are the witness traces for 𝑡1, . . . , 𝑡𝑚, † holds for the last time
at a common time point. As 𝑇 ′ is minimal, every trace serves
as a witness for some other traces. Therefore the last position
where † holds is the same for all traces in 𝑇 ′. Let 𝑖 be this
□
position. Then {𝑡 [𝑖, ∞] | 𝑡 ∈ 𝑇 ′} is a model of (𝜓, 𝜑).

By Theorem 3.11, satisfiability of ∀∃∗ HyperLTL is Σ1
1-
hard (note that we transform any specification (𝜓, ∀𝑛∃𝑚. 𝜙)
with 𝑛 ≥ 1 into a specification (⊤, ∀𝑛∃𝑚. 𝜙 ′) by integrating
the trace property into the body of the HyperLTL formula).
Theorem 4.3 thus gives a proof of Theorem 4.2. More gener-
ally, every HyperLTL formula can be effectively reduced to

4.3 Simple Liveness Properties
The general class of temporal liveness thus does not define
an “easier” fragment of HyperLTL. As in the case of safety
properties, we study the precise boundary at which the jump
to Σ1
1 occurs by restricting to simpler forms of temporal
liveness. Analogously to the case of invariants (described
with ), we study eventualities (

).

(

Lemma 4.4. The satisfiability problem is NP-complete for
specifications (⊤, 𝜑) where 𝜑 is of the form ∀∗∃∗.
∗) ∧
∗) and no propositional formulas occur outside of the
· · · ∧ (
operators. Hardness already holds for a single eventuality.
Proof sketch. We collapse all universal quantifiers in 𝜑 and
thereby reduce satisfiability of (⊤, 𝜑) to boolean satisfiability.
□
We give a detailed proof in Appendix B.
Note that if we allow properties where propositional for-
mulas occur outside of the
operators, the complexity
jumps back to NEXPTIME (see Lemma B.1). It is worth to con-
trast this result with the analogous findings for simple tempo-
rally safe formulas. Lemma 4.4 shows that when adding an
operator around a propositional formula, the problem drops
from NEXPTIME (Theorem 3.12) to NP. This is in contrast
operators, which remains NEXPTIME-complete
to adding
(Lemma 3.13). Invariants with nested
and propositional
conjuncts are undecidable (Lemma 3.10), whereas eventual-
operators and propositional conjuncts
ities with nested
remain decidable (see Lemma B.1).

4.4 Eventualities with Functional Specifications
Surprisingly, the sharp contrast between
continues
if we add functional specifications as LTL trace properties.
, the resulting problem directly jumps to full analytical
For
hardness (cf. Theorem 3.11). For
, we now show that the
problem remains decidable. Our result reads as follows.

and

Theorem 4.5. The satisfiability problem is decidable for spec-
ifications (𝜓, 𝜑) where 𝜑 is of the form ∀∃∗.

∗).

(

This result is interesting for two reasons. First, it outlines
. Second, it defines a
the precise difference between
new decidable class that contains many properties of interest.
In particular, formulas of the fragment can enforce infinite
models.2 For example, the specification in Example 1.1 falls
in this newly identified fragment.

and

The remainder of this subsection provides a proof for
Theorem 4.5. We introduce necessary concepts along the
way.

2Existing decidability results for HyperLTL consider fragments that, if
satisfiable, are satisfiable by a finite set of traces of bounded size. This
includes the ∃∗ ∀∗ fragment studied in [19] and the decidable fragments
identified in [32].

Deciding Hyperproperties Combined with Functional Specifications

LICS ’22, August 2–5, 2022, Haifa, Israel

4.4.1 Eliminating Nexts. We first show how to eliminate
the

operators in 𝜑.

𝑟0

𝑟1

𝑟2

𝑟3

𝑟4

W

(

Lemma 4.6. Let (𝜓, 𝜑) be a specification where 𝜑 is of the
form ∀𝑛∃𝑚.
∗). There exists an effectively computable
specification (𝜓 ′, 𝜑 ′) where 𝜑 ′ is the of the form ∀𝑛∃𝑚.
such
that (𝜓, 𝜑) and (𝜓 ′, 𝜑 ′) are equisatisfiable.
Proof sketch. Let 𝜑 = ∀𝑛∃𝑚. ( 𝜙) ∧ 𝜙 ′. We eliminate
op-
erators in 𝜙 by letting traces range over tuples. Instead of
considering traces in Σ𝜔 , we consider traces in (Σ𝑘 )𝜔 , where
𝑘 is the lookahead needed to evaluate 𝜙 (which is upper
s in 𝜙). For each trace 𝑡 ∈ Σ𝜔 ,
bounded by the number of
we define 𝑡 ′ ∈ (Σ𝑘 )𝜔 by 𝑡 ′(𝑖) (cid:66) (𝑡 (𝑖), 𝑡 (𝑖 + 1), . . . , 𝑡 (𝑖 + 𝑘)).
s.
This reduces the evaluation of 𝜙 to a formula without
We also modify the LTL formula (which is allowed to con-
tain
operators) to assert that the tuples in each tuple trace
are consistent, i.e., for each step 𝑖 if 𝑡 (𝑖) = (𝑙1, . . . , 𝑙𝑘 ) then
𝑡 (𝑖 + 1) = (𝑙2, . . . , 𝑙𝑘, 𝑙𝑘+1). A detailed proof can be found in
□
Appendix B.
Using Lemma 4.6, we can assume that in Theorem 4.5, the
HyperLTL formula 𝜑 contains a single
as the only tem-
poral operator. For now, we make two further assumptions:
First, we assume that 𝜑 contains only a single ∃ quantifier,
and, second, we assume that there are no additional proposi-
tional conjuncts outside the
𝜙 where
𝜙 contains no temporal operators. We begin by translating
the trace property 𝜓 into a Büchi automaton.

. So let 𝜑 = ∀𝜋∃𝜋 ′.

Definition 4.7. A state-labeled Büchi automaton over al-
phabet Σ is a tuple A = (𝑄, 𝑄0, 𝛿, 𝐹, 𝐿), where 𝑄 is a fi-
nite set of states, 𝑄0 ⊆ 𝑄 the initial states, 𝛿 ⊆ 𝑄 × 𝑄 the
transition relation, 𝐹 ⊆ 𝑄 the set of accepting states, and
𝐿 : 𝑄 → Σ a state labeling function. An accepting run 𝑟 of
A is an infinite sequence 𝑟 ∈ 𝑄𝜔 such that 1) 𝑟 (0) ∈ 𝑄0,
2) (𝑟 (𝑖), 𝑟 (𝑖 + 1)) ∈ 𝛿 for every 𝑖, and 3) 𝑟 (𝑖) ∈ 𝐹 for in-
finitely many 𝑖. The trace 𝐿(𝑟 ) ∈ Σ𝜔 associated to a run is
defined by 𝐿(𝑟 )(𝑖) (cid:66) 𝐿(𝑟 (𝑖)). For a set 𝑋 ⊆ 𝑄, we define
Step A (𝑋 ) (cid:66) {𝑞 ∈ 𝑄 | ∃𝑞′ ∈ 𝑋 . (𝑞′, 𝑞) ∈ 𝛿 } as all states
reachable in one step from 𝑋 and ReachA (𝑛) as all states
reachable in 𝑛 steps from a state in 𝑄0.

Note that we use state-labeled automata (as opposed to
transition-labeled automata) to simplify our construction.
Let A𝜓 = (𝑄𝜓 , 𝑄0,𝜓 , 𝛿𝜓 , 𝐹𝜓 , 𝐿𝜓 ) be a (state-labeled) Büchi
automaton over 2AP accepting 𝜓 [41]. A state 𝑞 ∈ 𝑄𝜓 is non-
empty if there exists an accepting infinite run starting in 𝑞.
W.l.o.g., we assume that A𝜓 only includes non-empty states,
as we can remove all empty states without changing the
language of A𝜓 . Detecting if a state is non-empty can be
done easily using, e.g., nested depth-first search.

4.4.2 Models for ∀∃. Intuitively, our decidability result
can be derived as follows. Assume we had a model 𝑇 of (𝜓, 𝜑).
Let 𝑅 ⊆ 𝑄𝜔
be a set of accepting runs of A𝜓 associated to 𝑇 ,
𝜓
i.e., 𝑇 = {𝐿𝜓 (𝑟 ) | 𝑟 ∈ 𝑅}. As we consider a ∀∃ formula, we

W

F

B

B

W

F

F

W

B

· · ·

Figure 1. Model for ∀𝜋 . ∃𝜋 ′.
indicate the witness points for the

operator.

𝜙 formulas. Dashed boxes

can arrange the runs in 𝑅 as a sequence: we choose 𝑟0, 𝑟1, . . . ∈
𝑅 (not necessarily distinct) such that, for each 𝑖, 𝑟𝑖+1 serves
𝜙.
as a witness for 𝑟𝑖 , i.e., [𝜋 ↦→ 𝐿𝜓 (𝑟𝑖 ), 𝜋 ′ ↦→ 𝐿𝜓 (𝑟𝑖+1)] |=
We say 𝑛0, 𝑛1, . . . are witness points if [𝜋 ↦→ 𝐿𝜓 (𝑟𝑖 ), 𝜋 ′ ↦→
𝐿𝜓 (𝑟𝑖+1)] [𝑛𝑖, ∞] |= 𝜙 for every 𝑖, i.e., the 𝑛𝑖 point to a step
at which the eventuality holds. The trace arrangement is
depicted in Figure 1 (ignoring the blue smaller nodes and
gray edges for now). For each 𝑖, the dashed box denotes the
witness point 𝑛𝑖 where 𝑟𝑖 and 𝑟𝑖+1 satisfy 𝜙.

As an intermediate step, we describe an infinite-state
Büchi system (a Büchi automaton without labels) that guesses
such a “linear” model of (𝜓, 𝜑). The states of the system are
triples (𝑞, 𝑏, 𝑛), where 𝑞 ∈ 𝑄𝜓 is a state in A𝜓 , 𝑏 ∈ {⇛, ⇚}
gives a running direction, and 𝑛 ∈ N. Each state (𝑞, 𝑏, 𝑛) ad-
ditionally satisfies 𝑞 ∈ ReachA𝜓 (𝑛). The initial states of the
system are all states (𝑞0, ⇛, 0) with 𝑞0 ∈ 𝑄0,𝜓 . In each step,
the system has three options: it can either run forwards,
run backwards, or claim to have found a witness. In a for-
ward step (F-step), the automaton moves from (𝑞, ⇛, 𝑛) to
(𝑞′, ⇛, 𝑛 + 1), where (𝑞, 𝑞′) ∈ 𝛿𝜓 . Similarly, in a backwards
step (B-step), it runs from (𝑞, ⇚, 𝑛 + 1) to (𝑞′, ⇚, 𝑛), where
(𝑞′, 𝑞) ∈ 𝛿𝜓 . Note that in the backwards step, we always
ensure that 𝑞′ ∈ ReachA𝜓 (𝑛). Lastly, the system can claim
to have found a witness (W-step): if in state (𝑞, 𝑏, 𝑛), it can
select any 𝑞′ ∈ ReachA𝜓 (𝑛) such that 𝐿𝜓 (𝑞) × 𝐿𝜓 (𝑞′) |= 𝜙.
Afterwards, the system continues in state (𝑞′, 𝑏 ′, 𝑛), where
𝑏 ′ ∈ {⇛, ⇚} is chosen nondeterministically. Call the result-
ing system S. We claim the following.

Lemma 4.8. S has an infinite run that uses W-steps infinitely
often if and only if (𝜓, 𝜑) is satisfiable.
Proof. We sketch both directions. For the “if” direction, as-
sume there is a model for (𝜓, 𝜑). We can arrange a subset of
this model as depicted in Figure 1. Let 𝑟0, 𝑟1, . . . , with 𝑟𝑖 ∈ 𝑄𝜔
𝜓
be the sequence of accepting runs in A𝜓 and 𝑛𝑖 the witness
points. Traversing the graph as shown by the small blue
states in Figure 1 creates a run of S. We start in (𝑟0(0), ⇛, 0)
and move forward (using F-steps) until the counter reaches
𝑛0. At this point, we take the W-step from (𝑟0(𝑛0), ⇛, 𝑛0) to

LICS ’22, August 2–5, 2022, Haifa, Israel

Beutner et al.

(𝑟1(𝑛0), 𝑏, 𝑛0) and run towards counter value 𝑛1. If 𝑛1 < 𝑛0,
we set the running direction 𝑏 to ⇚ and otherwise to ⇛.
We continue this procedure to construct an infinite run. For
the example situation depicted in Figure 1, the resulting run
would start with:

(𝑟0(0), ⇛, 0)

F
−→ (𝑟0(1), ⇛, 1)

W
−−→ (𝑟1(1), ⇛, 1)

F
−→ (𝑟1(2), ⇛, 2)

W
−−→ (𝑟2(3), ⇚, 3)

F
−→ (𝑟1(3), ⇛, 3)
The resulting sequence is a run of S and uses W-steps infin-
itely many times.

B
−→ (𝑟2(2), ⇚, 2)

W
−−→ · · ·

For the “only if” direction, assume an infinite run 𝑟 =
(𝑞0, 𝑏0, 𝑚0) → (𝑞1, 𝑏1, 𝑚1) → · · · of S. We split 𝑟 into infin-
itely many finite segments 𝑥0, 𝑥1, . . . , by splitting each time 𝑟
takes a W-step. In the example run above we would get 𝑥0 =
(𝑟0(0), 0)(𝑟0(1), 1), 𝑥1 = (𝑟1(1), 1)(𝑟1(2), 2)(𝑟1(3), 3), . . .. In
𝑖 ) . . . (𝑞𝑘𝑖
, 𝑛𝑘𝑖
general, let 𝑥𝑖 be the sequence (𝑞0
𝑖 , 𝑛0
𝑖 ). From 𝑥𝑖 ,
of A𝜓 starting in a state
we construct a finite run 𝑟𝑖 ∈ 𝑄 ∗
𝜓
𝑖 ) = 𝑞 𝑗
in 𝑄0,𝜓 such that for every 0 ≤ 𝑗 ≤ 𝑘𝑖 , 𝑟𝑖 (𝑛 𝑗
𝑖 . Using
the fact that for each (𝑞, 𝑏, 𝑛) in S, we have 𝑞 ∈ ReachA𝜋 (𝑛),
this is always possible. It is crucial that we cannot reverse
directions between two W-steps. The finite 𝑟𝑖 ends in a
state in A𝜓 , so by the assumption that all states are non-
empty, we can extend it into an infinite accepting run. The
□
set {𝐿𝜓 (𝑟0), 𝐿𝜓 (𝑟1), . . .} is a model of (𝜓, 𝜑).

𝑖

4.4.3 From Infinite State to Pushdown. The construc-
tion of S requires infinitely many states as we need to carry
the natural number 𝑛 to ensure valid B and W steps (which
need access to ReachA𝜓 (𝑛)). We show next that we can re-
place this infinite state space by a finite pushdown system.

Definition 4.9. A Büchi pushdown system is a tuple P =
(𝑄, Γ, 𝑄0, 𝛾0, 𝛿, 𝐹 ), where 𝑄 is a finite set of states, Γ the finite
stack alphabet, 𝑄0 ⊆ 𝑄 initial states, 𝛾0 ∈ Γ the initial stack
symbol, 𝛿 ⊆ (𝑄 × Γ+) × (𝑄 × Γ∗) a finite transition relation,
and 𝐹 ⊆ 𝑄 a set of accepting states. The system operates on
configuration ⟨𝑞, 𝛼⟩, where 𝑞 ∈ 𝑄 and 𝛼 ∈ Γ∗. A transition
⟨𝑞, 𝛼⟩ ⇝ ⟨𝑞′, 𝛼 ′⟩ ∈ 𝛿 describes that the system, if in state 𝑞
and 𝛼 ∈ Γ+ is a prefix of the current stack, pops 𝛼, pushes
𝛼 ′ ∈ Γ∗ to the stack and moves to state 𝑞′. An accepting
run is an infinite sequence of configurations that starts in
⟨𝑞0, [𝛾0]⟩ for some 𝑞0 ∈ 𝑄0, respects 𝛿, and visits states in 𝐹
infinitely many times. It is decidable in polynomial time if a
Büchi pushdown system has an accepting run [10].

We replace S with a pushdown system P. Conceptually,
we represent a state (𝑞, 𝑏, 𝑛) in S by the pushdown configu-
ration with state (𝑞, 𝑏) and stack content [ReachA𝜓 (𝑛), . . . ,
ReachA𝜓 (0)], i.e., the length of the stack is 𝑛 + 1 and the
𝑖th element are all states reachable in 𝑖 steps. The states
in the pushdown system thus have the form (𝑞, 𝑏) with
𝑞 ∈ 𝑄𝜓 , 𝑏 ∈ {⇛, ⇚} and the stack alphabet is 2𝑄𝜓 . The
initial stack symbol is 𝛾0 (cid:66) 𝑄0,𝜓 and the initial states are
{(𝑞0, ⇛) | 𝑞0 ∈ 𝑄0,𝜓 }. The transitions are of the following
form:

(F)

(𝑞, 𝑞′) ∈ 𝛿𝜓
(cid:10)(𝑞, ⇛), [𝐴](cid:11) ⇝ (cid:10)(𝑞′, ⇛), [Step A𝜓 (𝐴), 𝐴](cid:11)

(B)

𝑞′ ∈ 𝐴2

(𝑞′, 𝑞) ∈ 𝛿𝜓

(cid:10)(𝑞, ⇚), [𝐴1, 𝐴2](cid:11) ⇝ (cid:10)(𝑞′, ⇚), [𝐴2](cid:11)

𝑞′ ∈ 𝐴

(W)

𝐿𝜓 (𝑞) × 𝐿𝜓 (𝑞′) |= 𝜙
(cid:10)(𝑞, 𝑏), [𝐴](cid:11) ⇝ (cid:10)(𝑞′, 𝑏 ′), [𝐴](cid:11)

𝑏, 𝑏 ′ ∈ {⇛, ⇚}

Note the close correspondence with the transitions in S. In
particular, in F-steps, we compute ReachA𝜓 (𝑛 + 1) based on
ReachA𝜓 (𝑛). In B-steps, the stack provides access to all states
that are reachable, and thus guarantees the invariant that
𝑞 ∈ ReachA𝜓 (𝑛) for each state (𝑞, 𝑏, 𝑛) in S. It is not hard to
see that P has a run that uses W-steps infinitely often iff S
has a run that uses W-steps infinitely often. Combined with
Lemma 4.8 we thus get:

Lemma 4.10. P has an accepting run that uses W-steps in-
finitely often if and only if (𝜓, 𝜑) is satisfiable.

Lastly, we can easily translate a Büchi pushdown system
with transition-based acceptance (as in P) to state-based
acceptance (as in Definition 4.9). Using the decidability of
pushdown systems [10], we thus get that the satisfiability of
(𝜓, 𝜑) is decidable. Note that our proof gives an elementary
upper bound of 2EXPTIME (for ∀∃ properties).3

4.4.4 Propositional Conjuncts and ∀∃∗. We can now
lift the two assumptions we made earlier. As a first extension,
we modify our construction to also support formulas of the
form ∀𝜋∃𝜋 ′.( 𝜙) ∧ 𝜙 ′. To do so, we keep track of the first
state of the run we are currently considering. In a W-step,
we then only select a witness state 𝑞′ that stems from an
initial state which satisfies the propositional requirement
𝜙 ′ when combined with the initial state of the current run.
We can access the set of all such states by keeping track of
the set of states reachable from every individual state (by
changing the stack alphabet to functions 𝑄𝜓 → 2𝑄𝜓 ).

As a second extension, we can show decidability for a ∀∃𝑚
prefix by moving to alternating Büchi pushdown systems
(defined as expected, see [10] for details). For ∀∃𝑚, we can
no longer arrange the traces of a model in a linear sequence
(as depicted in Figure 1) and instead use 𝑚-ary trees labeled
by traces such that the children of a node correspond to
witness traces of that trace. In a W-step from a state (𝑞, 𝑏),
we now select 𝑚 states 𝑞1, . . . , 𝑞𝑚 (whereas we previously
picked only 𝑞′) such that 𝑞 together with 𝑞1, . . . , 𝑞𝑚 satisfy
𝜙. Afterwards, we need to find a new witnesses for each
of the 𝑞𝑖 . We accomplish this by introducing a universal
transition that branches into states (𝑞𝑖, 𝑏𝑖 ) for each 1 ≤ 𝑖 ≤
𝑚 (leaving the stack unchanged as before). The F and B
3The size of 𝑄𝜓 is at most exponential in 𝜓 [41], so the size of the stack
alphabet of P (which is 2𝑄𝜓 ) is at most double exponential in 𝜓 . As deciding
the emptiness of a Büchi pushdown system is polynomial, the 2EXPTIME
upper bound follows.

Deciding Hyperproperties Combined with Functional Specifications

LICS ’22, August 2–5, 2022, Haifa, Israel

step stay purely nondeterministic. The resulting alternating
pushdown system has an accepting run (which now has
the form of a tree) iff (𝜓, 𝜑) is satisfiable. As emptiness of
alternating pushdown systems is still decidable (albeit only
in exponential time) [10], we get a proof of Theorem 4.5 for
the full ∀∃∗-fragment. For the ∀∃∗-fragment, our proof gives
an elementary upper bound of 3EXPTIME.

4.5 Conjunctions of Eventualities
We show that Theorem 4.5 is tight in the sense that already
a conjunction of eventualities combined with an arbitrary
trace property is undecidable (and even Σ1

1-hard).

(cid:26)

1-hard for spec-

Theorem 4.11. The satisfiability problem is Σ1
ifications (𝜓, 𝜑) where 𝜑 is of the form ∀∃∗. ∧ ∧ .
Proof. We encode the problem of whether a nondeterministic
2CM with instructions 𝑙1, . . . , 𝑙𝑛 has a recurring computation
[3, 23]. Let AP = (cid:208)𝑥 ∈ {1,2,𝑡 }{
𝑥, ■𝑥, isZero𝑥 } ∪ {l1, . . . , l𝑛 }.
(cid:26)
Each trace encodes a configuration of the machine as follows.
The current value of counter 𝑥 ∈ {1, 2} is encoded as a
𝑥 }{■𝑥 }∅𝜔 such that the (unique) step at which
trace in ∅∗{
𝑥 holds indicates the current value of 𝑐𝑥 . We later use
(cid:26)
proposition ■𝑥 (which always holds the step after
𝑥 ) to
encode the update of the counter. The proposition isZero𝑥
holds exactly if the counter is zero. The current instruction
is encoded by propositions {l1, . . . , l𝑛 }, of which exactly one
holds globally along a trace. Finally, to ensure a recurring
computation, we use a third counter 𝑡, which is encoded
analogously to the counters above and counts down the
steps to the next visit to 𝑙1. It is easy to see that we can
encode the validity of a configuration in an LTL formula 𝜓 .
For 𝑥 ∈ {1, 2, 𝑡 } we ensure a valid counter via

(cid:26)

(¬

𝑥 ∧¬■𝑥 ) U (cid:0)(

(cid:26)

𝑥 ∧ ¬■𝑥 )
(cid:26)
∧ (■𝑥 ∧ ¬

𝑥 ∧¬■𝑥 )(cid:1)

(cid:0)

(cid:26)

(cid:26)

(cid:26)

𝑥 ) ∧

(¬
and ensure correct placement of isZero𝑥 by (
isZero𝑥 ) ∨
( ¬isZero𝑥 ) together with isZero𝑥 ↔
𝑥 . Finally, we as-
sert that the propositions {l1, . . . , l𝑛 } are set correctly via
l𝑖 ∧ (cid:211)𝑗≠𝑖 ¬l𝑗 (cid:1). In the hyperproperty, we encode that
(cid:212)𝑖
there exists a trace representing the initial configuration as
follows (note that we allow counter 𝑡 to have any value):
𝜑init (cid:66) ∃𝜋 .(l1)𝜋 ∧ (isZero1)𝜋 ∧ (isZero2)𝜋
Lastly, we express that each trace has a successor. For each
instruction 𝑙𝑖 , we write 𝑐 (𝑙𝑖 ) ∈ {1, 2} for the counter that
is changed or tested in instruction 𝑙𝑖 . We define 1 (cid:66) 2 and
2 (cid:66) 1 for the other counter. We then define

𝜑 (cid:66) ∀𝜋∃𝜋 ′.

(cid:104) (cid:220)

(l𝑖 )𝜋 ∧ exec(𝑙𝑖 )

(cid:105)

∧

𝑖 ∈ {1,...,𝑛 }

(cid:104) (cid:220)

(l𝑖 )𝜋 ∧ (

(cid:26)

𝑖 ∈ {1,...,𝑛 }
(cid:0)(isZero𝑡 )𝜋 ∧ (l1)𝜋 (cid:1) ∨ (cid:0)(

(cid:104)

𝑐 (𝑙𝑖 ) )𝜋 ∧ (

𝑐 (𝑙𝑖 ) )𝜋 ′

(cid:105)

∧

(cid:26)
𝑡 )𝜋 ∧ (■𝑡 )𝜋 ′ (cid:1) (cid:105)
(cid:26)

.

Here, exec(𝑙𝑖 ) denotes that the action or test of instruction
𝑙𝑖 is performed on 𝑐 (𝑙𝑖 ). For example, if 𝑙𝑖 = (cid:2)𝑐𝑥 (cid:66) 𝑐𝑥 +
1; goto{𝑙 𝑗, 𝑙𝑘 }(cid:3), we define exec(𝑙𝑖 ) as

(cid:0)(l𝑗 )𝜋 ′ ∨ (l𝑘 )𝜋 ′ (cid:1) ∧ (■𝑥 )𝜋 ∧ (

𝑥 )𝜋 ′.

(cid:26)
Note that (■𝑥 )𝜋 ∧ (
𝑥 )𝜋 ′ encodes that the counter 𝑥 is in-
creased. For a decrement operation, we can replace this with
𝑥 )𝜋 . If 𝑙𝑖 = (cid:2)if 𝑐𝑥 = 0 then goto 𝑙 𝑗 else
(■𝑥 )𝜋 ′ ∧ (
goto 𝑙𝑘 (cid:3), we define exec(𝑙𝑖 ) as

(cid:26)

(cid:26)

𝑥 )𝜋 ′ ∧ (cid:0)(isZero𝑥 )𝜋 → (l𝑗 )𝜋 ′ (cid:1)

𝑥 )𝜋 ∧ (

(
(cid:26)
∧ (cid:0)¬(isZero𝑥 )𝜋 → (l𝑘 )𝜋 ′ (cid:1).

(cid:26)

In 𝜑, the first conjunct thus encodes that the counter 𝑐 (𝑙𝑖 ) is
updated and/or tested as required by 𝑙𝑖 . The second conjunct
states that the counter that is not involved in 𝑙𝑖 is left un-
changed. As the current instruction is set consistently along
a trace, both eventualities refer to the same instruction. Fi-
nally, the third conjunct ensures that the counter 𝑡 either
decreases or is already zero, at which point the current in-
struction is 𝑙1. In case the 𝑡-counter is zero, it can be reset
to any value on 𝜋 ′. This ensures a recurring computation of
the machine. It is easy to see that (𝜓, 𝜑init ∧ 𝜑) is satisfiable
iff the 2CM has a recurring computation (note that 𝜑init ∧ 𝜑
is a ∀∃2-formula).
□

While Theorem 4.11 requires three conjunctions of eventu-
alities to show Σ1
1-hardness, already two eventualities suffice
to show undecidability. To do so, we can encode the non-
termination of a 2CM (avoiding the 𝑡 counter). This further
underlines the tightness of Theorem 4.5.

Lemma 4.12. The satisfiability problem is undecidable for
specifications (𝜓, 𝜑) where 𝜑 is of the form ∀∃∗. ∧ .

Example 4.13. Using similar ideas as in Theorem 4.11, we
can encode that a one-counter machine has an infinite com-
putation with only a single eventuality (as we only need
to ensure that the single counter is updated consistently).
Combined with Theorem 4.5, we derive that we can decide
the existence of an infinite computation in a one-counter
machine. While this is long known (see, e.g., [28]), it never-
theless emphasizes that our newly identified decidable class
◁
is broader than it seems at first glance.

4.6 Deterministic Liveness
Livness for trace properties (cf. Definition 2.1) and hyper-
liveness (cf. Definition 2.3) already imply that a property is
satisfiable. As demonstrated by Theorem 4.2, the same does
not hold for temporal liveness hyperproperties. We can, how-
ever, identify a fragment within temporal liveness for which
the intuition that liveness implies satisfiability transfers to
the realm of hyperproperties. We say an LTL property 𝜙 is a
deterministic liveness property if it is a liveness property and
can be recognized by a deterministic Büchi automaton.

LICS ’22, August 2–5, 2022, Haifa, Israel

Beutner et al.

Proposition 4.14. HyperLTL formulas of the form 𝜑 = ∀∃∗. 𝜙
where 𝜙 is a deterministic liveness property are always satisfi-
able and have a finite model.
Proof sketch. In a deterministic automaton describing a live-
ness property, any reachable state has a path to an accepting
state. We use this to iteratively construct a model. The full
□
proof can be found in Appendix B.
Note that the same does not hold if we consider more
than one universal quantifier. As an example, the formula
(𝑎𝜋 ∧ ¬𝑎𝜋 ′) is a
∀𝜋∀𝜋 ′.
deterministic liveness property. If we consider determinis-
tic liveness in combination with trace properties, we again
obtain a jump to Σ1

(𝑎𝜋 ∧ ¬𝑎𝜋 ′) is unsatisfiable but

1-hardness.

Corollary 4.15. Satisfiability is Σ1
1-hard for specifications
of the form (𝜓, 𝜑) where 𝜑 is of the form ∀∃∗. 𝜙 and 𝜙 is a
deterministic liveness property.
Proof. Follows directly from Theorem 4.11 as conjunctions
□
of eventualities are deterministic liveness.

4.7 Overview: Liveness vs Safety
Our results provide a clear picture of the (un)decidability
boundaries within fragments of HyperLTL. In particular, our
systematic study allows a direct comparison between tempo-
ral safety and temporal liveness. For the full fragment, tempo-
ral liveness already subsumes satisfiability of full HyperLTL,
which contrasts strongly with the much cheaper (albeit still
undecidable) problem for temporal safety. This changes if
we consider simpler fragments. Here, the
fragment is
drastically better behaved in terms of complexity and even
admits large decidable fragments for cases where the safety
counterpart already exhibits full analytical hardness.

5 Finding Largest Models
To complement the decidability results from the previous
sections, we propose a new (incomplete) algorithm to detect
(un)satisfiability of ∀∃∗ HyperLTL formulas. So far, the only
available algorithm checks for finite models of bounded size
and then iteratively increases the bound [20, 32]. Such an
approach finds smallest models and cannot determine un-
satisfiability. The key insight for our algorithm is that ∀∃∗
formulas are closed under union, therefore, a formula 𝜑 is
satisfiable iff there is a (unique) largest model satisfying 𝜑.
To find such models algorithmically, we iteratively eliminate
choices for the ∃∗ quantifiers that admit no witness trace
when chosen for the ∀ quantifier. Thereby, we do not only
find largest models but can also detect unsatisfiability. Our
incremental elimination is closely related to a recent algo-
rithm used in the context of finite-trace properties (which
was developed independently) [9].

For presentation reasons, we present the algorithm for ∀∃
formulas. Our implementation (see Section 6) supports full
∀∃∗ properties.

Algorithm 1 Algorithm that searches for the largest model
of a ∀∃ property. Initially, A is a Büchi automaton that ac-
cepts the body the HyperLTL property.

1: procedure findModel(A)
if L (A ∀) = ∅ then
2:
return UNSAT;
3:

4:
5:

6:
7:

if L (A ∃) ⊆ L (A ∀) then

return SAT, model: L (A ∀);
Anew (cid:66) A ∩ A ∀
𝜋 ′;
findModel(Anew);

5.1 Algorithm
For a Büchi automaton A over AP𝜋 ∪ AP𝜋 ′, we define A ∀
and A ∃ as the automata (over AP) that (existentially) project
A on the alphabet AP𝜋 and AP𝜋 ′, respectively. Now let a
HyperLTL formula 𝜑 = ∀𝜋∃𝜋 ′. 𝜙 be given and let A𝜙 be
an automaton over AP𝜋 ∪ AP𝜋 ′ accepting 𝜙. In particular,
accepts all words for which there exists a witness trace
A ∀
𝜙
for the existential quantifier. Our algorithm is depicted in
Algorithm 1. Initially, we call findModel(A𝜙 ).

The first candidate is A = A𝜙 . If L (A ∀) = ∅, i.e., no trace
has a witness trace in A, 𝜑 is unsatisfiable. If all potential
witness traces in L (A ∃) are contained in L (A ∀) (so they
have a witness trace themself), 𝜑 is satisfiable and L (A ∀)
is a model. If neither is the case, we refine A by removing
all traces whose ∃ component is not in L (A ∀). We define
Anew as the intersection A ∩ A ∀
𝜋 ′ is A ∀ with
the alphabet changed from AP to AP𝜋 ′. We can compute
Anew via a standard intersection construction on Büchi au-
tomata. Note that Anew might again contain witness traces
that themselves have no witness trace, so we recurse.

𝜋 ′ where A ∀

5.2 Correctness
The algorithm maintains the following invariants.

Lemma 5.1. In every iteration of the algorithm it holds that
L (Anew) ⊆ L (A), and for any trace set𝑇 with𝑇 |= ∀𝜋∃𝜋 ′. 𝜙,
𝑇 ⊆ L (A ∀).

Using Lemma 5.1 it is easy to see the following.

Proposition 5.2. Given a formula 𝜑 = ∀𝜋∃𝜋 ′. 𝜙, if Algo-
rithm 1 terminates with UNSAT, the formula is unsatisfiable.
If it terminates with SAT and model L (A ∀), then L (A ∀) is
the unique largest model of 𝜑.

To generalize to ∀∃∗, we intersect the universal projection
with each of the projections on existentially quantified posi-
tions. Models for ∀∗∃∗-properties are, in general, not closed
under union, so our algorithm does not extend beyond ∀∃∗.

6 Implementation and Experiments
We have implemented the algorithm described in Section 5
in a tool called LMHyper (short for Largest Model of Hy-
perLTL). LMHyper reads both a ∀∃∗ HyperLTL formula 𝜑 and

Deciding Hyperproperties Combined with Functional Specifications

LICS ’22, August 2–5, 2022, Haifa, Israel

Table 2. Comparison of LMHyper and MGHyper on 100 ran-
dom formulas generated with randltl [17]. Size refers to
the size of the AST, 𝑝 is the percentage of solved formulas,
𝑡 the average time spent on solved cases in milliseconds,
and #Iter is the average number of iterations (number of
recursive calls) used by LMHyper. The timeout is set to 5sec.

Size

15
16
17
18
19
20

MGHyper
𝑡
𝑝

95% 40
93% 39
95% 39
92% 38
95% 40
97% 42

LMHyper
𝑡

#Iter

𝑝

100% 235
99% 239
100% 221
100% 201
100% 180
100% 215

0.38
0.44
0.43
0.39
0.43
0.27

Table 3. Comparison of LMHyper and MGHyper on hand-
crafted specifications. We give the result (✓ if the speci-
fication is satisfiable and ✗ if it is unsatisfiable), the time in
ms, and the number of iterations needed by LMHyper. The
timeout is set to 5min.

Problem

Inf
Example 1.1
Enforce-2
Enforce-3
Enforce-5
Unsat-3
Unsat-5
Unsat-9

MGHyper
Res
𝑡

LMHyper

Res

𝑡

#Iter

TO
-
-
TO
✓ 444
TO
-
TO
-
TO
-
TO
-
TO
-

✓
✓
✓
✓
✓
✗
✗
✗

350
232
262
334
491
777
1363
1681

1
1
0
0
0
3
5
9

LTL formula 𝜓 and searches for an (un)satisfiability proof
for (𝜓, 𝜑). Internally, we represent the current candidate as a
generalized Büchi automaton and use spot [17] to perform
automata operations. The only other available tool for ∀∃∗
HyperLTL satisfiability is MGHyper [20], which implements
the incremental approach to find models of bounded size.

6.1 Random Benchmarks
We compare LMHyper against MGHyper on random formulas
where we sample the LTL body of a formula using randltl
[17]. The results are given in Table 2. On our benchmarks,
LMHyper usually takes longer than MGHyper but can handle
a larger percentage of formulas. We observe that randomly
generated HyperLTL formulas are, in most cases, satisfiable
by a model with a single trace, as the atomic propositions
are seldom shared between different trace variables. This
explains the high success rate of MGHyper (see [20]) even
though MGHyper cannot prove unsatisfiability.

6.2 Infinite and Large Models
We compiled a small number of more interesting proper-
ties that do not have single-trace models. Our results are
depicted in Table 3. The Inf specification expresses that a
model has infinitely many traces. Example 1.1 is the exam-
ple from the introduction. The Enforce-𝑛 specification en-
forces a model that has at least 𝑛 traces. It is defined as
∀𝜋∃𝜋1 . . . 𝜋𝑛. (cid:211)𝑖≠𝑗
(𝑎𝜋𝑖 ↮ 𝑎𝜋 𝑗 ). The Unsat-𝑛 specifica-
tions are unsatisfiable. Their definition is a trace property
¬𝑎) ∧ 𝑛 ¬𝑎 combined with the
𝜓 (cid:66) (¬𝑎) U (𝑎 ∧
hyperproperty 𝜑 (cid:66) ∀𝜋∃𝜋 ′.
(𝑎𝜋 ∧ 𝑎𝜋 ′). The formula is
designed such that Algorithm 1 requires 𝑛 iterations to dis-
cover unsatisfiability. MGHyper times out for most of the ex-
amples; even on simple properties like Enforce-3. In contrast,
LMHyper can verify properties enforcing many traces in a sin-
gle iteration because the number of iterations is independent
of the number of traces in a model. As expected, Unsat-𝑛
is unsatisfiable and LMHyper requires multiple iterations to
show this.

7 Conclusion
We have studied the satisfiability problem for ∀∗∃∗ Hyper-
LTL formulas in combination with LTL formulas describ-
ing functional behavior. To obtain results below the gen-
eral Σ1
1 complexity of HyperLTL, we have focused on sim-
pler hyperproperties belonging to the classes of temporal
safety and temporal liveness as well as fragments thereof.
We have shown that temporal safety is an expressive class
that is very well suited for satisfiability studies and enjoys
coRE-completeness. In combination with general LTL prop-
erties, already very simple formulas like invariants cause
Σ1
1-completeness. The temporal liveness class, on the other
hand, is Σ1
1-complete in general but contains non-trivial frag-
ments that are decidable, even in combination with arbitrary
LTL formulas.

We have shown that functional specifications given in
LTL play a significant role in the undecidability of general
hyperproperties. The main open question for future work is
whether further decidable fragments can be found by restrict-
ing the operator structure of the functional specification.

Acknowledgments
All authors are partially supported by the German Research
Foundation (DFG) in project 389792660, TRR 248 (Center for
Perspicuous Systems). M. Krötzsch is additionally supported
by the Bundesministerium für Bildung und Forschung (BMBF)
in project ScaDS.AI (Center for Scalable Data Analytics and
Artificial Intelligence), and by the Center for Advancing Elec-
tronics Dresden (cfaed). R. Beutner, B. Finkbeiner and J. Hof-
mann are additionally supported by the European Research
Council (ERC) in project OSARES (No. 68330). R. Beutner
and J. Hofmann carried out this work as members of the
Saarbrücken Graduate School of Computer Science.

LICS ’22, August 2–5, 2022, Haifa, Israel

Beutner et al.

References
[1] Erika Ábrahám, Ezio Bartocci, Borzoo Bonakdarpour, and Oyendrila
Dobe. 2020. Probabilistic Hyperproperties with Nondeterminism. In
International Symposium on Automated Technology for Verification and
Analysis, ATVA 2020 (Lecture Notes in Computer Science, Vol. 12302).
Springer. https://doi.org/10.1007/978-3-030-59152-6_29

[2] Bowen Alpern and Fred B. Schneider. 1985. Defining Liveness. Inf.
Process. Lett. 21, 4 (1985). https://doi.org/10.1016/0020-0190(85)90056-0
[3] Rajeev Alur and Thomas A. Henzinger. 1994. A Really Temporal Logic.

J. ACM 41, 1 (1994). https://doi.org/10.1145/174644.174651

[4] Ezio Bartocci, Thomas Ferrère, Thomas A. Henzinger, Dejan Nickovic,
and Ana Oliveira da Costa. 2022. Flavors of Sequential Information
Flow. In International Conference on Verification, Model Checking, and
Abstract Interpretation, VMCAI 2022 (Lecture Notes in Computer Science,
Vol. 13182). Springer. https://doi.org/10.1007/978-3-030-94583-1_1
[5] Jan Baumeister, Norine Coenen, Borzoo Bonakdarpour, Bernd
Finkbeiner, and César Sánchez. 2021. A Temporal Logic for Asynchro-
nous Hyperproperties. In International Conference on Computer Aided
Verification, CAV 2021 (Lecture Notes in Computer Science, Vol. 12759).
Springer. https://doi.org/10.1007/978-3-030-81685-8_33

[6] Raven Beutner and Bernd Finkbeiner. 2021. A Temporal Logic for
Strategic Hyperproperties. In International Conference on Concurrency
Theory, CONCUR 2021 (LIPIcs, Vol. 203). Schloss Dagstuhl.
https:
//doi.org/10.4230/LIPIcs.CONCUR.2021.24

[7] Raven Beutner and Bernd Finkbeiner. 2022. Prophecy Variables for
Hyperproperty Verification. In IEEE Computer Security Foundations
Symposium, CSF 2022. IEEE.

[8] Raven Beutner and Bernd Finkbeiner. 2022. Software Verification
of Hyperproperties Beyond 𝑘-Safety. In International Conference on
Computer Aided Verification, CAV 2022 (Lecture Notes in Computer
Science). Springer.

[9] Borzoo Bonakdarpour and Sarai Sheinvald. 2022. Finite-Word Hyper-

languages. arXiv:2201.01670 [cs.FL]

[10] Ahmed Bouajjani, Javier Esparza, and Oded Maler. 1997. Reachability
Analysis of Pushdown Automata: Application to Model-Checking. In
International Conference on Concurrency Theory, CONCUR 1997 (Lecture
Notes in Computer Science, Vol. 1243). Springer. https://doi.org/10.1007/
3-540-63141-0_10

[11] Laura Bozzelli, Adriano Peron, and César Sánchez. 2021. Asynchronous
Extensions of HyperLTL. In Annual ACM/IEEE Symposium on Logic in
Computer Science, LICS 2021. IEEE. https://doi.org/10.1109/LICS52264.
2021.9470583

[12] Michael R. Clarkson, Bernd Finkbeiner, Masoud Koleini, Kristopher K.
Micinski, Markus N. Rabe, and César Sánchez. 2014. Temporal Logics
for Hyperproperties. In International Conference on Principles of Secu-
rity and Trust, POST 2014 (Lecture Notes in Computer Science, Vol. 8414).
Springer. https://doi.org/10.1007/978-3-642-54792-8_15

[13] Michael R. Clarkson and Fred B. Schneider. 2008. Hyperproperties.
In IEEE Computer Security Foundations Symposium, CSF 2008. IEEE.
https://doi.org/10.1109/CSF.2008.7

[14] Norine Coenen, Bernd Finkbeiner, Christopher Hahn, and Jana Hof-
mann. 2019. The Hierarchy of Hyperlogics. In Annual ACM/IEEE
Symposium on Logic in Computer Science, LICS 2019. IEEE. https:
//doi.org/10.1109/LICS.2019.8785713

[15] Pedro R. D’Argenio, Gilles Barthe, Sebastian Biewer, Bernd Finkbeiner,
Is Your Software on Dope? - Formal
and Holger Hermanns. 2017.
Analysis of Surreptitiously "enhanced" Programs. In European Sympo-
sium on Programming, ESOP 2017 (Lecture Notes in Computer Science,
Vol. 10201). Springer. https://doi.org/10.1007/978-3-662-54434-1_4
[16] Rayna Dimitrova, Bernd Finkbeiner, and Hazem Torfah. 2020. Proba-
bilistic Hyperproperties of Markov Decision Processes. In International
Symposium on Automated Technology for Verification and Analysis,
ATVA 2020 (Lecture Notes in Computer Science, Vol. 12302). Springer.
https://doi.org/10.1007/978-3-030-59152-6_27

[17] Alexandre Duret-Lutz, Alexandre Lewkowicz, Amaury Fauchille,
Thibaud Michaud, Etienne Renault, and Laurent Xu. 2016. Spot
2.0 - A Framework for LTL and 𝜔-Automata Manipulation. In In-
ternational Symposium on Automated Technology for Verification and
Analysis, ATVA 2016 (Lecture Notes in Computer Science, Vol. 9938).
https://doi.org/10.1007/978-3-319-46520-3_8

[18] Bernd Finkbeiner, Lennart Haas, and Hazem Torfah. 2019. Canonical
Representations of k-Safety Hyperproperties. In IEEE Computer Secu-
rity Foundations Symposium, CSF 2019. IEEE. https://doi.org/10.1109/
CSF.2019.00009

[19] Bernd Finkbeiner and Christopher Hahn. 2016. Deciding Hyperprop-
erties. In International Conference on Concurrency Theory, CONCUR
2016 (LIPIcs, Vol. 59). Schloss Dagstuhl. https://doi.org/10.4230/LIPIcs.
CONCUR.2016.13

[20] Bernd Finkbeiner, Christopher Hahn, and Tobias Hans. 2018. MGHy-
per: Checking Satisfiability of HyperLTL Formulas Beyond the ∃∗ ∀∗
Fragment. In International Symposium on Automated Technology for
Verification and Analysis, ATVA 2018 (Lecture Notes in Computer Science,
Vol. 11138). Springer. https://doi.org/10.1007/978-3-030-01090-4_31
[21] Bernd Finkbeiner, Christopher Hahn, and Hazem Torfah. 2018. Model
Checking Quantitative Hyperproperties. In International Conference
on Computer Aided Verification, CAV 2018 (Lecture Notes in Computer
Science, Vol. 10981). Springer. https://doi.org/10.1007/978-3-319-96145-
3_8

[22] Bernd Finkbeiner and Martin Zimmermann. 2017. The First-Order
Logic of Hyperproperties. In Symposium on Theoretical Aspects of
Computer Science, STACS 2017 (LIPIcs, Vol. 66). Schloss Dagstuhl. https:
//doi.org/10.4230/LIPIcs.STACS.2017.30

[23] Michael J. Fischer and Richard E. Ladner. 1979. Propositional Dynamic
Logic of Regular Programs. J. Comput. Syst. Sci. 18, 2 (1979). https:
//doi.org/10.1016/0022-0000(79)90046-1

[24] Marie Fortin, Louwe B. Kuijer, Patrick Totzke, and Martin Zimmer-
mann. 2021. HyperLTL Satisfiability is Σ1
1-complete, HyperCTL* Satis-
fiability is Σ2
1-complete. In International Symposium on Mathematical
Foundations of Computer Science, MFCS 2021 (LIPIcs, Vol. 202). Schloss
Dagstuhl. https://doi.org/10.4230/LIPIcs.MFCS.2021.47
[25] Kurt Gödel. 1929. Über die vollständigkeit des logikkalküls.
[26] Jens Oliver Gutsfeld, Markus Müller-Olm, and Christoph Ohrem. 2020.
Propositional Dynamic Logic for Hyperproperties. In International
Conference on Concurrency Theory, CONCUR 2020 (LIPIcs, Vol. 171).
Schloss Dagstuhl. https://doi.org/10.4230/LIPIcs.CONCUR.2020.50

[27] Jens Oliver Gutsfeld, Markus Müller-Olm, and Christoph Ohrem. 2021.
Automata and fixpoints for asynchronous hyperproperties. Proc. ACM
Program. Lang. 5, POPL (2021). https://doi.org/10.1145/3434319
[28] Christoph Haase, Stephan Kreutzer, Joël Ouaknine, and James Wor-
rell. 2009. Reachability in Succinct and Parametric One-Counter
Automata. In International Conference on Concurrency Theory, CON-
CUR 2009 (Lecture Notes in Computer Science, Vol. 5710). Springer.
https://doi.org/10.1007/978-3-642-04081-8_25

[29] Andreas Krebs, Arne Meier, Jonni Virtema, and Martin Zimmermann.
2018. Team Semantics for the Specification and Verification of Hyper-
properties. In International Symposium on Mathematical Foundations
of Computer Science, MFCS 2018 (LIPIcs, Vol. 117). Schloss Dagstuhl.
https://doi.org/10.4230/LIPIcs.MFCS.2018.10

[30] Orna Kupferman and Moshe Y. Vardi. 1999. Model Checking of Safety
Properties. In International Conference on Computer Aided Verification,
CAV 1999 (Lecture Notes in Computer Science, Vol. 1633). Springer. https:
//doi.org/10.1007/3-540-48683-6_17

[31] Martin Lück. 2016. Complete Problems of Propositional Logic for the

Exponential Hierarchy. CoRR abs/1602.03050 (2016).

[32] Corto Mascle and Martin Zimmermann. 2020. The Keys to Decidable
HyperLTL Satisfiability: Small Models or Very Simple Formulas. In
EACSL Annual Conference on Computer Science Logic, CSL 2020 (LIPIcs,
Vol. 152). Schloss Dagstuhl. https://doi.org/10.4230/LIPIcs.CSL.2020.29

Deciding Hyperproperties Combined with Functional Specifications

LICS ’22, August 2–5, 2022, Haifa, Israel

[33] Daryl McCullough. 1988. Noninterference and the composability
of security properties. In IEEE Symposium on Security and Privacy,
Oakland, SP 1988. IEEE. https://doi.org/10.1109/SECPRI.1988.8110
[34] Marvin Lee Minsky. 1967. Computation. Prentice-Hall Englewood

Cliffs.

[35] Markus N. Rabe. 2016. A temporal logic approach to Information-flow

control. Ph. D. Dissertation. Saarland University.

[36] John Alan Robinson and Andrei Voronkov (Eds.). 2001. Handbook of

Automated Reasoning. MIT Press.

[37] Hartley Rogers Jr. 1987. Theory of recursive functions and effective

computability. MIT press.

[38] A Prasad Sistla. 1994. Safety, liveness and fairness in temporal logic.

Formal Aspects of Computing 6, 5 (1994).

[39] A Prasad Sistla and Edmund M Clarke. 1985. The complexity of propo-

sitional linear temporal logics. J. ACM 32, 3 (1985).

[40] Larry J. Stockmeyer. 1976. The Polynomial-Time Hierarchy. Theor.
Comput. Sci. 3, 1 (1976). https://doi.org/10.1016/0304-3975(76)90061-X
[41] Moshe Y. Vardi and Pierre Wolper. 1994. Reasoning About Infinite
Computations. Inf. Comput. 115, 1 (1994). https://doi.org/10.1006/inco.
1994.1092

[42] Jonni Virtema, Jana Hofmann, Bernd Finkbeiner, Juha Kontinen, and
Fan Yang. 2021. Linear-Time Temporal Logic with Team Semantics:
Expressivity and Complexity. In IARCS Annual Conference on Founda-
tions of Software Technology and Theoretical Computer Science, FSTTCS
2021 (LIPIcs, Vol. 213). Schloss Dagstuhl. https://doi.org/10.4230/LIPIcs.
FSTTCS.2021.52

A Additional Material For Section 3
Definition A.1. A nondeterministic Turing machine is a
tuple 𝑇 = (𝑄, 𝑄0, Γ, 𝛿, 𝐹 ) where 𝑄 is a finite set of states,
𝑄0 ⊆ 𝑄 the initial states, Γ a finite alphabet, 𝛿 ⊆ (𝑄 × Γ) ×
(𝑄 × Γ × {𝐿, 𝑅}) the transition relation and 𝐹 ⊆ 𝑄 a set of
accepting states. A transition ((𝑞, 𝑎), (𝑞′, 𝑎′, 𝑑)) ∈ 𝛿 means
that the if the TM is in state 𝑞 and reads 𝑎, it updates its
state to 𝑞′, writes 𝑎′, and moves either to the left (𝑑 = 𝐿)
or the right (𝑑 = 𝑅). We assume a dedicated blank symbol
# ∈ Γ. In an initial configuration for a finite word 𝑤 ∈ Γ (not
containing #), the head is at position 0, the state is in some
state in 𝑄0 and the tape contains 𝑤 (followed by infinitely
many #). We say that a TM accepts the empty word if there
is a run starting in an initial configuration that eventually
visits a configuration where the state is in 𝐹 . A TM is deter-
ministic if 𝑄0 = {𝑞0} and for each (𝑞, 𝑎), there exists at most
one successor in 𝛿.

Proposition 3.9. The satisfiability problem of temporally
safe HyperLTL is in coRE.
Proof. We already gave the construction of a FOL formula Θ
in the proof sketch in the main part (in Section 3). Here we
only show its correctness, i.e., we show that the FOL formula
Θ and HyperLTL formula 𝜑 are equisatisfiable.

Assume Θ is satisfiable and fix a first-order model. Let the
set 𝑋 be the set of elements from the Trace domain which
may be assigned to some variable 𝑥𝑖 in any possible evalua-
tion of the quantifiers. We iteratively construct a trace for
any element of 𝑋 . To do so, let 𝑖0, 𝑖1, . . . be a fixed sequence
of element from TimePoint such that Succ(𝑖 𝑗, 𝑖 𝑗+1) for any
𝑗 ∈ N and 𝑖0 is the constant described above. This sequence

might not be unique and elements might occur several times
but we need to fix one such sequence to obtain well-defined
traces. For each element 𝑣 ∈ 𝑋 , we define a trace 𝑡𝑣 ∈ Σ𝜔 ,
by setting 𝑡𝑣 (𝑛) (cid:66) {𝑎 | 𝑃𝑎 (𝑣, 𝑖𝑛)} for every 𝑛 ∈ N, where
we write 𝑃𝑎 (𝑣, 𝑖𝑛) whenever this holds in the fixed firs-order
model of Θ. It is easy to see that 𝑇 (cid:66) {𝑡𝑣 | 𝑣 ∈ 𝑋 } is a
model of 𝜑. This holds as Θ minims the quantification in 𝜑,
so whenever a quantifier is instantiated with 𝑣 ∈ 𝑋 , we use
trace 𝑡𝑣 ∈ 𝑇 for the respective quantifier in 𝜑. By construc-
tion of 𝜌𝑞 we ensure that A𝜙 has an accepting run on all
tuples of 𝑛 traces chosen in the quantifier prefix.

For the other direction, assume that 𝜑 is satisfiable by
trace set 𝑇 , which we choose as domain for sort Trace. For
TimePoints, we choose the set of natural numbers with 𝑖0 = 0.
We set 𝑃𝑎 (𝑡, 𝑖) to true iff 𝑎 ∈ 𝑡 [𝑖]. For every assignment of
𝑡1, . . . 𝑡𝑛 to the trace variables, we fix a run through A and
set State𝑞 (𝑡1, . . . , 𝑡𝑛, 𝑖) to true iff the the run is in state 𝑞 in
□
step 𝑖. The resulting structure satisfies 𝜙.

Lemma 3.10. The satisfiability problem is coRE-hard for
specifications (⊤, 𝜑) where 𝜑 is of the form ∀∃∗.

∗).

(

Proof. We reduce from the non-halting problem of determin-
istic Turing machines on the empty word, which is coRE
complete. We assume, w.l.o.g., that the tape of the Turing
machine is left-bounded and only takes a step to the left
when it is possible. We encode the position of the head with
a proposition ℎ. Throughout the construction, we maintain
the invariant on all relevant traces that ℎ is set exactly once
on the trace. We cannot encode this property directly as it
would require to nest multiple
operators. We encode the
alphabet Γ and the set of states 𝑄 with sets of atomic propo-
sitions, one for each symbol and enforce that in each step,
exactly one for each set holds, for 𝑆 = Γ or 𝑆 = 𝑄:

∀𝜋 .

(cid:16) (cid:220)

(cid:0)𝑎𝜋 ∧

(cid:219)

¬𝑏𝜋 (cid:1)(cid:17)

𝑎 ∈𝑆

𝑎≠𝑏 ∈𝑆

We fix the current state to be the one that holds in the posi-
tion of the head. Initially, the TM is in state 𝑞0, the head at
position 0, and the tape is blank. We require that the initial
configuration is present in the set:

∃𝜋 . ℎ𝜋 ∧ 𝑞0

𝜋 ∧ (#𝜋 ∧ ¬ℎ𝜋 )

Now we encode the possible transitions with a ∀𝜋∃𝜋 ′ for-
mula. We ensure that if the configuration encoded by 𝜋 is a
valid one (i.e., ℎ only holds once), then the successor config-
uration is also valid. For correct transitions, all positions on
𝜋 ′, which are not left or right of the head in 𝜋, must remain
unchanged. Second, the head must move either left or right
and the symbol and state propositions are only allowed to

LICS ’22, August 2–5, 2022, Haifa, Israel

Beutner et al.

change in the position of the old head.

(cid:18)

𝜓LxorR (cid:66)

(¬ℎ𝜋 ∧ (¬ℎ𝜋 ∧ ¬ℎ𝜋 )) →

(cid:18)

∧ ℎ𝜋 →

¬ℎ𝜋 ′ ∧ (ℎ𝜋 ′ ⊕

(cid:19)

𝑎𝜋 ↔ 𝑎𝜋 ′

(cid:219)

𝑎 ∈AP

ℎ𝜋 ′)

(𝑎𝜋 ↔ 𝑎𝜋 ′) ∧

(𝑎𝜋 ↔ 𝑎𝜋 ′)(cid:1)

(cid:19)

∧ (cid:0) (cid:219)
𝑎 ∈Γ

Now we translate each transition (𝑞, 𝑎), (𝑞′, 𝑎′, 𝐿) ∈ 𝛿 as
follows. If the head moves right instead of left, we change
the position of the

operator accordingly.

𝜓trans1 (cid:66) (ℎ𝜋 ∧ 𝑎𝜋 ∧ 𝑞𝜋 ) → ℎ𝜋 ′ ∧ 𝑞′
The final transition formula is the following:

𝜋 ′ ∧ 𝑎′
𝜋 ′

∀𝜋 . ∃𝜋 ′.

(𝜓LxorR ∧ (𝜓trans1 ∨ 𝜓trans2 ∨ · · · ))

We only encode transitions where 𝑞′ ∉ 𝐹 , i.e. only those
transitions that do not make the TM halt. The conjunction
of the above formulas can be easily transformed into a ∀∃2
formula with a single
operators in
. Now, the TM has an infinite non-halting run
the scope of
iff the conjunction of the above formulas has a satisfying
model. The trace set might not only contain the witness-
ing run but also non-valid configurations or non-reachable
□
configurations, which we can just ignore.

and only non-nested

.

1, c𝑖

𝑛, c𝑖

1, . . . , l𝑖

1-complete for

Theorem 3.11. The satisfiability problem is Σ1
specifications (𝜓, 𝜑) where 𝜑 is of the form ∀∃∗.
Proof. Membership in Σ1
1 follows from [24]. We reduce from
the recurring computation problem of nondeterministic two-
counter machines. The key idea is to use LTL formulas
over pairs of encoded configurations and use the hyperprop-
erty only to ensure that every second component matches
with some first component of another trace. We thus set
AP = AP 1 ∪ AP 2 and each AP𝑖 = {l𝑖
2, t𝑖 }. The
counter values for counter 𝑐1, 𝑐2 are encoded by two atomic
propositions c1 and c2 which hold exactly once, i.e., counter
𝑥 has value 𝑣 if c𝑥 occurs in the 𝑣th position. We use 𝑛 atomic
propositions for the instructions, and require that in the first
position, exactly one instruction label holds. Note that all of
the above requirements for a valid configuration are easily
expressible in LTL. To ensure that the computation visits the
initial instruction 𝑙1 infinitely often, we use a proposition t,
which must also hold exactly once and decreases with every
computation step. When 𝑡 is in position 0, l1 must hold. We
1 ∨ (t2 ↔ t1). We also en-
encode this requirement as l1
code that each trace denotes an update step of the 2CM. For
example instruction 𝑙𝑖 = (cid:2)𝑐1 (cid:66) 𝑐1 + 1 goto {𝑙 𝑗, 𝑙𝑘 }(cid:3) can be
encoded as:
𝑖 → (cid:2)
1
l

2
1
2) ∧ (c
2 ↔ c

2
2
2
𝑗 ∨ l
1)) ∧ (l

1
1 ↔ c

((c

𝑘 )(cid:3)

Decrement instructions are analogous. Instructions of the
form 𝑙𝑖 = (cid:2)if 𝑐1 = 0 then goto 𝑙 𝑗 else goto 𝑙𝑘 (cid:3) can be

encoded as.
(cid:104)

1
𝑖 →
l

2
1
𝑗 ) ∧ (¬c
1 → l
(c

2
1
𝑘 ) ∧
1 → l

(cid:219)

𝑥 ∈1,2

1
𝑥 ↔ c

2
𝑥 )

(c

(cid:105)

We then take the conjunction over the resulting formulas
for each instruction.

What is left to state is the hyperproperty 𝜑, which matches

second components to first components.
𝜋 ↔ 𝑎1
𝑎2
𝜋 ′

∀𝜋 . ∃𝜋 ′. (cid:219)
𝑎 ∈AP
Additionally, the initial configuration must be present in the
first component of a trace.

∃𝜋 . (c

1
1)𝜋 ∧ (c

1
1
1)𝜋
2)𝜋 ∧ (l

The resulting specification (𝜓, 𝜑) is satisfiable iff the 2CM
has a recurring computation starting in the initial state. The
formula 𝜑 is from the ∀∃2 fragment and uses only a single
□

without nested temporal operators.

Theorem 3.12. The satisfiability problem is NEXPTIME-com-
plete for specifications (𝜓, 𝜑) where 𝜑 is of the form 𝑄 ∗.
∗.
Hardness holds already for 𝜓 = ⊤, a ∀∗∃∗ prefix, and no
s.
Proof. Let 𝜑 = 𝑄 ∗. 𝜙. For membership in NEXPTIME, let 𝑘
be the lookahead needed to evaluate 𝜙, which is upper-
bounded the number of
operators occurring in 𝜙. Now
define 𝑀 ⊆ Σ𝑘 as all finite traces 𝜏 of length 𝑘 such that 𝜏 can
be extended to a trace satisfying 𝜓 . 𝑀 can be constructed in
exponential time by converting 𝜓 to a Büchi automaton and
checking if each 𝜏 ∈ 𝑀 has an accepting run in linear time.
We then nondeterministically guess a subset 𝑀 ′ ⊆ 𝑀 and
verify that 𝑀 ′ |= 𝜑 which can easily be done in nondetermin-
istic exponential time, giving the desired NEXPTIME-upper
bound.

To show hardness we reduce the acceptance of a time-
bounded nondeterministic Turing machine on the empty
word to a HyperLTL formula (our construction does not re-
quire any temporal operators, not even s). Consequently,
only the first position of each trace is relevant. Let 𝑇 =
(𝑄, 𝑄0, Γ, 𝛿, 𝐹 ) be a exponential time-bounded nondetermin-
istic TM. As our formula uses no s, only the first position is
relevant so we can see each trace as a propositional evalua-
tion over AP. The idea is that each trace in the model encodes
a piece of information of an accepting run of 𝑇 . Such a piece
of information is a tuple (𝑠, 𝑝, 𝛾, 𝑞) where 𝑠, 𝑝 ∈ N, 𝛾 ∈ Γ and
𝑞 ∈ 𝑄 ∪ {⊥}. The information encodes that in time-step 𝑠
and at position 𝑝, the tape content is 𝛾 and the head is at that
position and the machine in state 𝑞 if 𝑞 ∈ 𝑄 or the head is
not at that position (if 𝑞 = ⊥). As 𝑇 is time (and thus space)
bounded, 𝑠 and 𝑝 are bound by 2𝑛 for some 𝑛.

In our formula we now use propositions (cid:174)s = s1, . . . , s𝑛 to
encode a time step and (cid:174)p = p1, . . . , p𝑛 to encode a position
on the tape (both as a binary counter). Moreover, for each
state 𝑞 ∈ 𝑄 ∪ {⊥} and each letter 𝛾 ∈ Γ, we introduce an
atomic proposition 𝑞 and 𝛾. In each evaluation exactly one

Deciding Hyperproperties Combined with Functional Specifications

LICS ’22, August 2–5, 2022, Haifa, Israel

of the tape-content propositions holds and at most one state-
proposition holds (if none holds, the head is at a different
step).

Using HyperLTL, we specify that the information encoded
in the traces is consistent and forms an accepting run of the
TM:
(1) At most one of the state-propositions and exactly one of
the tape-propositions holds:

(cid:220)

∀𝜋 . (cid:169)
(cid:173)
𝛾 ∈Γ
(cid:171)

(cid:219)

𝛾𝜋 ∧

𝛾 ≠𝛾 ′ ∈Γ

¬𝛾 ′

𝜋 (cid:170)
(cid:174)
(cid:172)

(cid:219)

∧

𝑞≠𝑞′ ∈𝑄

¬(𝑞𝜋 ∧ 𝑞′
𝜋 )

(2) If two traces agree in time step and position they also
agree on tape content, state (and thus head position):

∀𝜋∀𝜋 ′.

(cid:32) 𝑛
(cid:219)

𝑖=1

(s𝑖

𝜋 ↔ s𝑖

𝜋 ′) ∧ (p𝑖

𝜋 ↔ p𝑖

𝜋 ′)

(cid:33)

→

(𝑞𝜋 ↔ 𝑞𝜋 ′) ∧

(cid:219)

𝛾 ∈Γ

(cid:219)

(cid:169)
(cid:173)
𝑞 ∈𝑄
(cid:171)

(𝛾𝜋 ↔ 𝛾𝜋 ′)(cid:170)
(cid:174)
(cid:172)

(3) The TM state (and therefore also head position) agrees
across all traces that are in the same time step. Phrased
differently, for any two different traces that agree on the step
and the automaton state, are already equal. Here we write
𝜋 = 𝜋 ′ to mean that 𝜋 and 𝜋 ′ agree (in the first position)

𝑛
(cid:219)
∀𝜋∀𝜋 ′. (cid:169)
(cid:173)
(cid:171)

𝑖=1

(s𝑖

𝜋 ↔ s𝑖

𝜋 ′) ∧

(cid:219)

𝑞 ∈𝑄

(𝑞𝜋 ↔ 𝑞𝜋 ′)(cid:170)
(cid:174)
(cid:172)

→ 𝜋 = 𝜋 ′

(4) The initial configuration of the TM is in the model. We
cannot encode this with existential quantification directly,
as we would need to refer to exponentially many positions
and therfiore also exponentially many traces. Instead, we
express it as a ∀∃ property. We use syntactic sugar and write
(cid:174)p𝜋 = (cid:174)p𝜋 ′ + 1 to indicate that the binary counter increases
by one position. This can easily be encoded in propositional
logic in quadratic size. For a constant 𝑐 we write (cid:174)p𝜋 = 𝑐 to
denote the binary counter given by (cid:174)p equals 𝑐. We express
the desired property as a conjunction of the following two
formulas. The first formula is given by:

∃𝜋 . (cid:174)s𝜋 = 0 ∧ (cid:174)p𝜋 = 0 ∧ #𝜋 ∧

(cid:220)

𝑞𝜋

𝑞 ∈𝑄0

Which expresses that at step 0 at least the very first position
is filled with # and the head is at that poistion (in an initial
state). The second information propagates this information
to all remaining positions in the first step:
∀𝜋∃𝜋 ′.(cid:0)(cid:174)s𝜋 = 0 ∧ (cid:174)p𝜋 ≠ 2𝑛 − 1(cid:1) →

(cid:0)(cid:174)s𝜋 ′ = 0 ∧ (cid:174)p𝜋 ′ = (cid:174)p𝜋 + 1 ∧ #𝜋 ′ (cid:1)

Note that (3) already implies that the position is set consis-
tently in the same step, so we do not need to require that
⊥𝜋 ′ holds.

(5) The model encodes valid steps of the TM. As the tran-
sitions of a TM are local, it is sufficient to compare three
consecutive tape positions with the same three tape posi-
tions in the next step. Thus, for every three traces that share
the same time step and encode consecutive positions, there
exists three traces on the next time step with the same posi-
tions such that the step is possible in the TM. The resulting
∀3∃3 formula then consists of a finite conjunction over those
valid “transitions triples” of 𝑇 . We do not give the formula
explicitly, as the notation gets clustered.
(6) The TM is eventually in an accepting state which we can
express via ∃𝜋 . (cid:212)𝑞 ∈𝐹 𝑞𝜋 .

Note that because of the explicit step count (via (cid:174)s), each
model directly encodes a unique run of the TM. In particular,
there can not be spurious facts that do not hold on the de-
fined run of the TM. Consequently, we get that the resulting
formula is satisfiable iff TM has a 2𝑛-time bounded accepting
run. The reduction outlined above can be done in logspace,
□
giving the desired NEXPTIME-hardness.

B Additional Material for Section 4
Lemma 4.4. The satisfiability problem is NP-complete for
specifications (⊤, 𝜑) where 𝜑 is of the form ∀∗∃∗.
∗) ∧
∗) and no propositional formulas occur outside of the
· · · ∧ (
operators. Hardness already holds for a single eventuality.

(

𝜙.

Proof. We first consider the case where we have only a single
eventuality. Let 𝜑 = ∀𝜋1 . . . 𝜋𝑛∃𝜋𝑛+1 . . . 𝜋𝑛+𝑚.

s operators. We assume that in 𝜙 the

We claim that we can actually assume that 𝜙 contains
no
s occur di-
rectly in from of atomic proportions, i.e., 𝜙 is a boolean
formula over atoms of the form 𝑛 𝑎𝜋𝑖 . Transforming a for-
mula in this form is possible in polynomial time. Now let
𝑘 be the lookahead needed to evaluate 𝜙 (which is upper
s in 𝜙). We define 𝜙 ′ as the
bounded by the number of
formula over AP 0 ∪ · · · ∪ AP𝑘 (where AP𝑖 = {𝑎𝑖
| 𝑎 ∈
AP }) obtained from 𝜙 by replacing each atom 𝑛 𝑎𝜋𝑖 with
the atomic proposition (𝑎𝑛)𝜋𝑖 . As 𝜙 occurs under a
, it is
𝜙 is satisfiable
easy to see that ∀𝜋1 . . . 𝜋𝑛∃𝜋𝑛+1 . . . 𝜋𝑛+𝑚.
iff ∀𝜋1 . . . 𝜋𝑛∃𝜋𝑛+1 . . . 𝜋𝑛+𝑚.

𝜙 ′ is satisfiable.

So let us assume in the following that 𝜙 contains no tem-
poral operators, i.e., 𝜙 is a propositional boolean formula
over AP𝜋1 ∪ · · · ∪ AP𝜋𝑛+𝑚 . We claim that 𝜑 is satisfiable iff

𝑛
(cid:219)

(cid:219)

𝜁 (cid:66) 𝜙 ∧

(𝑎𝜋𝑖 ↔ 𝑎𝜋1)

𝑖=2

𝑎 ∈AP
is satisfiable (viewed as a propositional formula). For the
left to right direction, assume that 𝜑 is satisfiable by 𝑇 . We
now pick any 𝑡 ∈ 𝑇 and instantiate all universal quanti-
fiers with 𝑡. Then let 𝑡𝑛+1, . . . , 𝑡𝑛+𝑚 ∈ 𝑇 , be witness traces
for the existential quantification. So [𝜋1 ↦→ 𝑡, . . . , 𝜋𝑛 ↦→
𝜙. Let 𝑛 ∈ N be
𝑡, 𝜋𝑛+1 ↦→ 𝑡𝑛+1, . . . , 𝜋𝑛+𝑚 ↦→ 𝑡𝑛+𝑚] |=
such that [𝜋1 ↦→ 𝑡, . . . , 𝜋𝑛 ↦→ 𝑡, 𝜋𝑛+1 ↦→ 𝑡𝑛+1, . . . , 𝜋𝑛+𝑚 ↦→
𝑡𝑛+𝑚] [𝑛, ∞] |= 𝜙. We construct an assignment 𝛼 : AP𝜋1 ∪

LICS ’22, August 2–5, 2022, Haifa, Israel

Beutner et al.

· · ·∪AP𝜋𝑛+𝑚 → B as follows: For each 𝑎𝜋𝑖 we define 𝛼 (𝜋𝑖 ) (cid:66)
𝑡 (𝑛)(𝑎) if 1 ≤ 𝑖 ≤ 𝑛 and 𝛼 (𝜋𝑖 ) (cid:66) 𝑡𝑖 (𝑛)(𝑎) if 𝑛 +1 ≤ 𝑖 ≤ 𝑛 +𝑚.
It is easy to see that 𝛼 satisfies 𝜁 (note that all universally
quantified copies are chosen by 𝑡 so (cid:211)𝑛
𝑖=2 (cid:211)𝑎 ∈AP (𝑎𝜋𝑖 ↔ 𝑎𝜋1)
holds trivially).

For the reverse, assume that 𝜁 is satisfiable and let 𝛼 be a
satisfying variable assignment over AP𝜋1 ∪ · · · ∪ AP𝜋𝑛+𝑚 . We
construct a model with 𝑛 + 𝑚 traces 𝑡1, . . . , 𝑡𝑛+𝑚 as follows:
For every indices 𝑖1, . . . , 𝑖𝑛 ∈ {1, . . . , 𝑛 + 𝑚} we choose 𝑚 dis-
tinct indices 𝑗1, . . . , 𝑗𝑚 ∈ {1, . . . , 𝑛 +𝑚} that are also different
from all 𝑖1, . . . , 𝑖𝑛 (this is possible as we fixed 𝑛 + 𝑚 traces).
Now fix some fresh position 𝑛 ∈ N and ensure that [𝜋1 ↦→
𝑡𝑖1, . . . , 𝜋𝑛 ↦→ 𝑡𝑖𝑛, 𝜋𝑛+1 ↦→ 𝑡 𝑗1 . . . 𝜋𝑛+𝑚 ↦→ 𝑡 𝑗𝑚 ] [𝑛, ∞] |= 𝜙.
This is always possible as we can use 𝛼 to construct the as-
signments of all involved traces at position 𝑘. Here it is cru-
cial that we added the second conjunct (cid:211)𝑛
𝑖=2 (cid:211)𝑎 ∈AP (𝑎𝜋𝑖 ↔
𝑎𝜋1 ) to 𝜁 as this ensures that we construct a position at
which the property holds even if 𝑡𝑖1, . . . , 𝑡𝑖𝑛 are not distinct.
We iterate this for every of the finitely many elements in
{1, . . . , 𝑛 + 𝑚}𝑛 (always choosing a fresh position 𝑛), thereby
defining a model of 𝜑.

To show NP-hardness, we can easily reduce from propo-
sitional SAT problem: A formula 𝜁 over AP is satisfiable iff
𝜁𝜋 is satisfiable (we write 𝜁𝜋 for 𝜁 when replacing all
∃𝜋 .
atoms 𝑎 with 𝑎𝜋 ).

To handle multiple eventualities, reuse the above proof.
Let 𝜑 = ∀∗∃∗.
𝜙1 ∧ · · · ∧ 𝜙𝑛. We again assume, w.l.o.g.,
that each 𝜙𝑖 contains no s. We introduce a different copy
of AP𝑖 for the 𝑖th
-subformula, the
operator. In each
propositional variables are exchanged accordingly, i.e., let 𝜙 ′
𝑖
be 𝜙𝑖 where the atomic propositions from AP are replaced
with those from AP𝑖 . It is easy to see that 𝜑 is satisfiable iff
𝑛) is satisfiable, as we can simply fulfill
∀∗∃∗.
□
all eventualities at different timepoints.

1 ∧ · · · ∧ 𝜙 ′

(𝜙 ′

Lemma B.1. The satisfiability problem is NEXPTIME-complete
for specifications (⊤, 𝜑) where 𝜑 is of the form ∀∗∃∗.
∗) ∧
∗) (and we do allow propositional formulas occur
· · · ∧ (
outside of the

operators).

(

Proof. We prove this lemma by combining Lemma 4.4 and
Theorem 3.12. The crux is that we can separate the proposi-
. Assume we are given a for-
tional formulas outside the
mula 𝜑 = ∀∗∃∗. ( 𝜙1)∧· · ·∧( 𝜙𝑛)∧𝜙 ′ where 𝜙1, . . . , 𝜙𝑛, 𝜙 ′
contain only s. It it easy to see that 𝜑 is satisfiable iff both
∀∗∃∗. ( 𝜙1) ∧ · · · ∧ ( 𝜙𝑛) and ∀∗∃∗. 𝜙 ′ are satisfiable. The
former is decidable in NP (see Lemma 4.4) and the latter in
NEXPTIME (see Theorem 3.12), so the NEXPTIME upper bound
follows. For the lower bound, we can directly use the hard-
ness shown in Theorem 3.12 and ignore the ability to use
formulas.

□

Lemma 4.6. Let (𝜓, 𝜑) be a specification where 𝜑 is of the
form ∀𝑛∃𝑚.
∗). There exists an effectively computable

(

specification (𝜓 ′, 𝜑 ′) where 𝜑 ′ is the of the form ∀𝑛∃𝑚.
that (𝜓, 𝜑) and (𝜓 ′, 𝜑 ′) are equisatisfiable.
Proof. Let 𝜑 = ∀𝑛∃𝑚.
evaluate 𝜙 (which is upper bounded by the number of
in 𝜙). Similar to the proof of Lemma 4.4 we eliminate
using letting traces range over tuples.

𝜙. Let 𝑘 be the lookahead needed to
s
s by

such

AP𝑖 = {𝑎𝑖

We construct a formula 𝜙 ′ over AP 0 ∪ · · · ∪ AP𝑘 (where
| 𝑎 ∈ AP }) as follows: We assume that in 𝜙 the
s occur directly in from of atomic proportions, i.e., 𝜙 is a
boolean formula over atoms of the form 𝑛 𝑎𝜋𝑖 . Transform-
ing a formula in this form is possible in polynomial time.
We then define 𝜙 ′ as the formula over AP 0 ∪ · · · ∪ AP𝑘 ob-
tained from 𝜙 by replacing each atom 𝑛 𝑎𝜋𝑖 with the atomic
proposition (𝑎𝑛)𝜋𝑖 .

The traces we consider now range over letters from AP 0 ∪
· · · ∪ AP𝑘 , i.e., over the window of the next 𝑘 + 1 steps. In the
LTL part of the specification we assert that this window is
consistent, i.e., the 𝑖 + 1th state (evaluation over AP𝑖+1 equals
the evaluation of the 𝑖th state in the next step). We define 𝜓 ′
as

𝜓 ′ (cid:66) 𝜓0 ∧

𝑘−1
(cid:219)

(cid:219)

(cid:0)𝑎𝑖+1 ↔ 𝑎𝑖 (cid:1)

𝑖=0

𝑎 ∈AP
where 𝜓0 is obtained from 𝜓 by replacing each proposition
𝑎 ∈ AP with 𝑎0 ∈ AP 0. We define 𝜑 ′ = ∀𝑛∃𝑚.
𝜙 ′. It is easy
□
to see that (𝜓, 𝜑) and (𝜓 ′, 𝜑 ′) are equisatisfiable.

Proposition 4.14. HyperLTL formulas of the form 𝜑 = ∀∃∗. 𝜙
where 𝜙 is a deterministic liveness property are always satisfi-
able and have a finite model.

Proof. Let 𝜑 = ∀𝜋1∃𝜋2 . . . 𝜋𝑚+1. 𝜙 and let A𝜙 be a determin-
istic Büchi automaton for 𝜙 over AP𝜋1 ∪ · · · ∪ AP𝜋𝑚+1. For
finite traces 𝑢1, . . . , 𝑢𝑚+1 of the same length (say 𝑘), we de-
fine zip(𝑢1, . . . , 𝑢𝑚+1) as the finite trace (of length 𝑘) over
AP𝜋1 ∪ · · · ∪ AP𝜋𝑚+1 that combines 𝑢1, . . . , 𝑢𝑚+1, i.e., the eval-
uation of AP𝜋𝑖 is copied from 𝑡𝑖 . The crucial property we
use is that for a deterministic liveness property, we can al-
ways revisit an accepting state even after having read an
arbitrary finite word. We claim that there always exists a
finite model of size at most 𝑚 + 1. For any 𝑖 ∈ {1, . . . , 𝑚 +
1} define 𝑓 (𝑖) as the vector (1, . . . , 𝑖 − 1, 𝑖 + 1, . . . , 𝑚 + 1)
(which has length 𝑚). We iteratively constructs a model
as follows: Initially, we set 𝑢1, . . . , 𝑢𝑚+1 = 𝜖. For each 𝑗 =
0, 1, 2, . . . let 𝑖 = ( 𝑗%(𝑚 + 1)) + 1 (this way we consider each
𝑖 ∈ {1, . . . , 𝑚 + 1} infinitely many times) and ( 𝑗1, . . . , 𝑗𝑚) =
𝑓 (𝑖). We now extend each of the traces in 𝑇 by some fi-
𝑚+1 of the same length such
nite, non-empty word 𝑢 ′
that zip(𝑢𝑖𝑢 ′
𝑗𝑚 ) reaches an accepting state
in A𝜙 . As A𝜙 is a deterministic liveness automaton this is
always possible.

, . . . , 𝑢 𝑗𝑚𝑢 ′

1, . . . , 𝑢 ′

𝑖 , 𝑢 𝑗1𝑢 ′
𝑗1

Let 𝑡1, . . . 𝑡𝑚+1 be the infinite traces constructed in the
limit. It is easy to see that 𝑇 = {𝑡1, . . . , 𝑡𝑚+1} is a model of 𝜑.
In the limit, this constructs traces of infinite length which

Deciding Hyperproperties Combined with Functional Specifications

LICS ’22, August 2–5, 2022, Haifa, Israel

serve as a model for 𝜑. For each trace 𝑡𝑖 , the traces with
index determined by 𝑓 (𝑖) can be chosen as witness traces
for existential quantification. By construction, the (unique)
run of A𝜙 on the resulting tuple of traces is accepting. □

C Additional Material for Section 5
Lemma 5.1. In every iteration of the algorithm it holds that
L (Anew) ⊆ L (A), and for any trace set𝑇 with𝑇 |= ∀𝜋∃𝜋 ′. 𝜙,
𝑇 ⊆ L (A ∀).

Proof. Initially, the property obviously holds as A encodes 𝜑
and every trace which occurs in any satisfying trace set must
have a run through A as the ∀ trace. It remains to show that
Anew does not exclude traces that occur in satisfying 𝑇 . The
new),
construction ensures that if 𝑡 ∈ L (A ∀) but 𝑡 ∉ L (A ∀
then there exists no witness trace 𝑡 ′ such that 𝑡𝜋 ∪𝑡 ′
𝜋 ′ ∈ L (A)
and 𝑡 ′ ∈ L (A ∀). By induction, L (A) is a superset of the
union of all satisfying trace sets, therefore, there can be no
□
𝑇 such that 𝑡 ∈ 𝑇 and 𝑇 |= ∀𝜋∃𝜋 ′. 𝜙.

