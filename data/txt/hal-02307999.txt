Monadic Datalog, Tree Validity, and Limited Access
Containment
Michael Benedikt, Pierre Bourhis, Georg Gottlob, Pierre Senellart

To cite this version:

Michael Benedikt, Pierre Bourhis, Georg Gottlob, Pierre Senellart. Monadic Datalog, Tree Validity,
and Limited Access Containment. ACM Transactions on Computational Logic, 2020, 21 (1), pp.6:1-
6:45. ￿10.1145/3344514￿. ￿hal-02307999￿

HAL Id: hal-02307999

https://inria.hal.science/hal-02307999

Submitted on 9 Oct 2019

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Monadic Datalog, Tree Validity,
and Limited Access Containment

MICHAEL BENEDIKT, The University of Oxford, United Kingdom
PIERRE BOURHIS, CRIStAL, CNRS, University of Lille & Inria, France
GEORG GOTTLOB, The University of Oxford, United Kingdom
PIERRE SENELLART, DI ENS, ENS, CNRS, PSL University & Inria & LTCI, Télécom Paris, IP Paris, France

We reconsider the problem of containment of monadic datalog (MDL) queries in unions of conjunctive
queries (UCQs). Prior work has dealt with special cases of the problem, but has left the precise complexity
characterization open. In addition, the complexity of one important special case, that of containment under
access patterns, was not known before. We start by revisiting the connection between MDL/UCQ containment
and containment problems involving regular tree languages. We then present a general approach for getting
tighter bounds on the complexity of query containment, based on analysis of the number of mappings of
queries into tree-like instances. We give two applications of the machinery. We first give an important special
case of the MDL/UCQ containment problem that is in EXPTIME, and use this bound to show an EXPTIME
bound on containment under access patterns. Secondly we show that the same technique can be used to get a
new tight upper bound for containment of tree automata in UCQs. We finally show that the new MDL/UCQ
upper bounds are tight. We establish a 2EXPTIME lower bound on the MDL/UCQ containment problem,
resolving an open problem from the early 1990s. This bound holds for the MDL/CQ containment problem as
well. We also show that changes to the conditions given in our special cases can not be eliminated, and that in
particular slight variations of the problem of containment under access patterns become 2EXPTIME-complete.

Additional Key Words and Phrases: Access patterns, binding patterns, deep Web, monadic datalog, query
containment

ACM Reference Format:
Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart. 2019. Monadic Datalog, Tree Validity,
and Limited Access Containment. ACM Trans. Comput. Logic 21, 1, Article 6 (October 2019), 51 pages. https:
//doi.org/10.1145/3344514

1 INTRODUCTION

Context. Datalog represents a standard model for querying data with recursion. The basic prob-
lems of evaluation, equivalence, and containment of datalog thus have been the object of study for
several decades. Shmueli [31] showed that containment (and equivalence) of datalog is undecidable.
Decidable subclasses were subsequently isolated [11, 14], focusing on restricting the form of recur-
sion used. Chaudhuri and Vardi [17, 19] provide an extensive study of the containment of datalog
queries in non-recursive datalog queries, showing in particular that the problem is decidable. They
also show that it is 2EXPTIME-complete to decide containment of a datalog query within a union
of conjunctive queries (UCQ).

In this article we focus on monadic datalog (MDL) – the fragment in which all intensional
predicates are unary. Cosmodakis, Gaifman, Kanellakis, and Vardi [22] showed that containment
of monadic datalog queries is in 2EXPTIME, and is EXPTIME-hard, leaving open the question of a
tight bound. In another article, Chaudhuri and Vardi [18] prove a co-NEXPTIME upper bound for
containment of a unary MDL query (i.e., a query with one output variable) in a union of connected

Authors’ addresses: Michael Benedikt, The University of Oxford, Oxford, United Kingdom; Pierre Bourhis, CRIStAL, CNRS,
University of Lille & Inria, Lille, France; Georg Gottlob, The University of Oxford, Oxford, United Kingdom; Pierre Senellart,
DI ENS, ENS, CNRS, PSL University & Inria & LTCI, Télécom Paris, IP Paris, Paris, France.

2019. 1529-3785/2019/10-ART6
https://doi.org/10.1145/3344514

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6

6:2

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

unary conjunctive queries. Their co-NEXPTIME upper bound does not apply to Boolean queries,
and, in fact, we will show that the problem is 2EXPTIME-hard even for Boolean conjunctive queries.
Since the work of Chaudhuri and Vardi, the “fine structure” of the containment problem between
recursive and non-recursive queries has remained mysterious. What computation can one code
up in an MDL/UCQ containment problem (or, even, in an MDL/CQ containment problem)? What
features of recursive queries make the containment problem hard? A better understanding of
these issues can shed light on a number of other questions, e.g., containment of UC2RPQs [15] in
non-recursive queries. The problem gained additional importance from the question of querying
under limited access patterns [6, 13]: a schema with limited access patterns specifies that certain
relations can only be accessed via lookups, providing values for a fixed set of input positions. The
input values cannot be guessed, but instead must either be in a particular set of known “seed
values”, or be the outputs of earlier accesses. Thus, given any instance I of the schema, there is a
corresponding subset of the facts in the instance, denoted here by AccFacts
, that can be obtained
via use of the accesses.

I
(

)

Example 1.1. Consider a schema with relations as follows: there is a binary relation R

x, y
,
)
(
having an access aR that requires a value for both positions; given inputs v, w the access returns
true exactly when R
having an access aU that requires no
input: hence a call to aU will return all values of U . The accessible facts from this schema can be
seen to be all facts of the form U

c, d
(
The containment problem for limited access patterns is the following: given two queries Q and Q ′

. There is also a unary relation U

and all facts R

where c, d

v, w
(

x
(

c
(

U .

∈

)

)

)

)

and a schema with limited access patterns, is it true that, for every instance I , Q
Q ′(

I
AccFacts
(

?
))

I
AccFacts
(

(

)) ⊆

y R

and Q ′ =
Example 1.2. In the example schema above, consider queries Q =
x
. These are certainly not equivalent, but are equivalent over the accessible data
∃
)
for this schema: indeed, the only way to access facts from relation R is to first access U , implying
that all facts of the form R
are accessible.

that are accessible are such that both U

x, y
(

x, y
(

and U

x
∃

y R

x
(

) ∧

U

∃

∃

)

a
(

)

b
(

)

a, b
(

)

It was noticed early on [27] that the problem of containment of unions of conjunctive queries
under access patterns is a special case of monadic datalog containment in a UCQ. First, the problem
can be seen to be equivalent to:

I
(

I
(

Q ′

I Q

∀

)) ⊆

AccFacts
(
One direction of the equivalence is immediate from monotonicity of UCQs, since Q ′(
I
Q ′(
I
can modify it by replacing I with AccFacts
, giving a counterexample to the above.
)
(

)) ⊆
. For the other direction, given a counterexample to containment under access patterns, we
)

Assuming each relation mentioned in the query has at least one access method (this is without
can be defined
, and the latter can in turn be defined by an
)

loss of generality, since containment is trivial otherwise), the query Q ′(
by restricting Q ′ to the values that occur in AccFacts
I
(
MDL program, using the rules:

I
AccFacts
(

AccFacts

I
(

))

)

xj ) ←
AccValues
(
whenever there is an access with input positions m1 . . . mk .

AccValues

xm1) ∧ · · · ∧
(

) ∧

R

(

x

xmk )
AccValues
(

Thus containment under access limitations is a special case of MDL/UCQ containment. But again
the only upper bound observed for containment under access patterns was the 2EXPTIME bound
of Chaudhuri and Vardi.

Another problem closely related to the MDL/UCQ containment problem is boundedness of MDL,
i.e., determining whether the evaluation of a MDL program reaches a fixpoint after a fixed, data-
independent, number of iterations. Though boundedness of Datalog programs is undecidable in

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:3

general, it was shown in [22] that it is decidable for MDL, though the precise complexity was
not assessed. As shown in [7] (Claim 40 of the extended version), containment of MDL in a UCQ
reduces to MDL boundedness.

Contributions. In this work, we will ascertain both the exact complexity of MDL/UCQ contain-
ment, and the exact complexity of limited-access containment. We will also settle some questions on
the complexity of query validity problems on trees: this is the problem of determining, given a tree
schema (e.g. given as an automaton or DTD) and a query, whether the schema implies the query.
We will show that monadic datalog containment and tree validity problems are tightly connected.
We start by introducing a new upper bound technique, revisiting the 2EXPTIME upper bound
for containment of Chaudhuri and Vardi. We will refine the main two tools used there: reduction to
tree-shaped models, and counting the number of different types of nodes in the models. We present
a property of a class of instances, the Unique Mapping Condition, that suffices to show that the
number of types reduces from doubly-exponential to exponential. We then show that whenever
this condition holds, containment in UCQs goes down to EXPTIME.

We give two settings where the Unique Mapping Condition holds. The first is that of “almost
globally extensionally limited” MDL (AGEMDL) queries over general relational instances: we limit
the number of occurrences of an extensional predicate in the program. We show that containment
under limited access in the case of a single-access per relation reduces to GEMDL containment
in a UCQ. Thus our EXPTIME bounds apply to this case. We show that this reduction can be
bootstrapped to give the same bounds for the general limited-access containment problem.

A second application is when the models are trees. We show that the UMC for this case gives us

new upper bounds on the validity problem of tree automata in UCQs.

We then turn to lower bounds. We first show that all of our upper bounds on tree validity are
tight. The key ingredient is an adaptation of a 2EXPTIME-hardness argument due to Bjorklund,
Martens and Schwentick [8–10]. We then give reductions from tree validity problems to MDL
and limited access containment problems to show that the upper bounds we provide for these
problems are tight as well. In particular, we show that containment of MDL in CQs (and hence,
UCQs) is 2EXPTIME-complete. This resolves the main open question from [18] and also implies
that MDL boundedness is 2EXPTIME-hard, as noted in [7]. Since containment of MDL in a CQ is a
special case of monadic datalog containment, it also shows that monadic datalog containment is
2EXPTIME-complete, closing the gap in the bounds of [22]. We finally use the technique to show
that when we move to a slightly broader collection of MDL programs, compared to those arising
from limited access containment, we get a 2EXPTIME-complete query containment problem.

Organization. Section 2 contains the basic definitions. Section 3 reviews prior work and summa-
rizes the main results in detail. Section 4 defines the main new subclasses for which tighter upper
bounds can be provided, and then gives our new upper bound proofs. Section 5 deals with lower
bounds, showing that all previously given upper bounds are tight. Section 6 discusses related work,
while Section 7 gives conclusions, open issues, and future directions.

Limitations. For simplicity, we do not consider two important variants of the MDL/UCQ contain-
ment problem and of limited-access containment. First, we assume that all queries do not contain
any constants, i.e., that all relation atoms are made up of variables. Though the general MDL/UCQ
problem is known to also be in 2EXPTIME in the presence of constants [3, 4], constants typically
do affect the complexity of containment problems, as they make it easier to code hardness proofs.
Second, contrarily to some of the limited-access literature [6, 13], we assume that our queries work
over relational databases in which there are no restrictions on the values that occur in a column.
The alternative would be to allow a schema to specify a type or abstract domain for each attribute.

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:4

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

Though we do not consider abstract domains, the corresponding constraints could easily be coded
by a disjunction of conjuncts, so we believe our results on limited-access containment of UCQs
would not be affected.

2 BACKGROUND
We introduce in this section the main notions studied in this article (some from the literature, others
introduced in this work), along with some general preliminary results. We go over the following
concepts: monadic datalog and query containment (Section 2.1); expansion trees of monadic datalog
queries (Section 2.2); tree validity problems (Section 2.3); querying under limited access constraints
(Section 2.4).

2.1 Monadic Datalog Containment

Basics. A relational signature σ consists of a set of relation symbols (or simply relations), each
with an associated arity. For a relation R any number i < arity
is referred to as a position of R.
R
(
An instance I for the signature σ interprets each relation symbol in the signature of arity k by
a set of k-tuples, where the values are taken in some infinite set of values (independent of the
in the interpretation of a relation symbol R by I , we say that
instance). For every tuple
v1, . . . , vn)
the active domain of the instance I , i.e., the set of
R
(
values appearing in I .
An atom over a relational signature σ is an expression R

where R is a k-ary predicate
of σ and the xi ’s are variables (from some countable set). We refer to xi as “the variable at position i”
of the atom. We emphasize that an atom never refers to a domain constant.

I
is a fact of I . We denote by dom
(

v1, . . . , vn)
(

x1 . . . xn)
(

)

)

We consider the following two simple positive query languages over σ : (a) conjunctive queries
(CQs); (b) unions of conjunctive queries (UCQs). They are respectively defined as the fragments of
first-order logic over σ consisting of, respectively, (a) existentially quantified conjunctions of atoms;
(b) disjunctions of CQs. A conjunctive query is connected if its Gaifman graph (whose vertices are
the variables of the query and where there is an edge between two variable if they appear in the
same atom) is connected. A subquery of a CQ is a subset of its atoms; a subquery of a UCQ is a
subquery of one of its conjuncts (in particular, a subquery is always a CQ).

Datalog. A datalog program [1] over σ consists of:
(i) A set of rules of the form A

φ, where φ is a conjunction of atoms over σ , and A is an
atom over σ . We say A is the head and φ the body of the rule. We require that every variable
occurring in the head of a rule r also occurs in its body.

←

(ii) A distinguished predicate Goal of σ which occurs in the head of a rule, referred to as the goal

predicate.

The relational symbols that do not occur in the head of any rule are the input or extensional
predicates, while the others are intensional predicates. Similarly, the extensional (resp., intensional)
signature of a program is the set of extensional (resp., intensional) predicates used by the program.
Monadic datalog (MDL) denotes the sublanguage where all intensional predicates are monadic
(unary), except for the goal predicate which can be either unary or nullary (in the latter case, we
say that the program is Boolean).

For a datalog program P, an intensional predicate R of P, and an instance I interpreting the input
R, I

, as the union of the relations Pk (
predicates, we define the evaluation of R on I , denoted R
I
)
(
=
defined via the following process, starting with P0(
:
∅
Let I k be the expansion of I with Pk (
for all intensional R.

R, I

R, I

•

)

)

)

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:5

•

x1 . . . xl )
(
the body of r , let Pk +1(
is the active domain of I .

If r is a rule with R
x, w
φ
(
)
I
dom
(
)
Let then Pk +1(

)

in the head, w the variables of r not present in the head, and
where

be defined by:

c, w

w φ

r, I

I k

c

I
dom
(

l
)

|

{

∈

=
|

∃

(

)}

)

•

denote the union of Pk +1(

R, I
Finally, the query result of P on I , denoted P
, is the evaluation of the goal predicate of P on I .
)
We often assume P is Boolean, in which case the result of the program on I is the Boolean “true”
holds in I , and we simply say that I is a model of P or that I satisfies P. We alternatively
iff Goal
refer to a datalog query, rather than to a datalog program, to emphasize that we are only interested
in the evaluation on the goal predicate.

over all r with R in the head.

r, I

I
(

()

)

Under these semantics, it is easy to check that any UCQ can be transformed in linear-time into

an equivalent MDL query, that does not involve any intensional predicate apart from Goal.

Containment. The main problem we deal with in this work is the classical notion of query

containment [1].

Definition 2.1. Let Q and Q ′ be two queries over a signature σ . We say Q is contained in Q ′,

I
(

I
Q ′(

.

denoted Q

Q ′, if, for any instance I over σ , Q

)

⊑

) ⊆
Above we have defined containment in terms of the evaluation of Q over all instances, finite
and infinite. But a simple (and well-known) argument shows that this coincides with containment
when only finite instances are considered. If there is an instance I and tuple t such that t
I
,
)
(
is guaranteed by a finite collection of facts I0 in I . Thus I0
I
t (cid:60) Q ′(
witnesses that Q is not contained in Q ′ over finite instances. Given this equivalence, throughout
this work we will assume that instances are finite. For finite instances I , there will be a finite k such
Goal, I
that the evaluation of datalog Q will be Pk +1(

for Goal the goal predicate.

, then the fact that t

I
(

Q

Q

∈

∈

)

)

)

Example 2.2. Consider the following MDL program P that determines whether there is a path in a
graph G from a node marked with the unary predicate S to one marked with the unary predicate T :

Goal
() ←
y
(
x
(

) ←

) ←

T

x
) ∧
(
x, y
G
(
x
(

R

)

Reachable

Reachable

) ∧

Reachable

)
Reachable

x
(

x
(

)

x
∃

∃
x R

y R

x
(
x
(

) ∧
T

G

x
(

x, y
(

) ∧

T

y
(
)
y ′ G

x ′

x ′, y ′
(

Now consider the UCQs:

Q1 :
Q2 :

(∃
∃
Q2: indeed, if I is the instance made of the facts R

We have that P (cid:64) Q1 but P

, I is
)
a model of P, but not a model of Q1. And in any model of P, either the first rule defining Reachable
is used, and then the second disjunct of Q2 holds, or only the second rule defining Reachable is
used, and then the first disjunct of Q2 holds.

)) ∨ (∃

and T

a
(

a
(

) ∧

))

⊑

)

We focus on containment for Boolean queries in the remainder of the paper. However, our results

apply to the unary case as well, thanks to the following:

Proposition 2.3. There are polynomial time one-to-one reductions in both directions between the

containment of Boolean MDL queries in Boolean UCQs and that of MDL queries in UCQs.

Proof. Given a containment problem for Boolean MDL query Q1 in UCQ Q2, we can create a
unary containment problem by adding an additional unary intensional predicate U to the signature.
We create a new unary MDL query that returns the content of U whenever Q1 is true. We similarly
create a new UCQ by adding a conjunct U

to all CQs.

x
(

)

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:6

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

In the other direction, given unary MDL Q1 and UCQ Q2, we again add a unary predicate to the
signature. We create a new Boolean MDL query Q ′1 that holds if Q1 intersected with the unary
predicate is non-empty, and similarly for Boolean UCQ Q ′2 derived from Q2. It is easy to see that
containment is preserved by this reduction, since if Q1 is not contained in Q2 on some instance I one
can expand to the larger signature by choosing the unary predicate to be the symmetric difference
of Q1 and Q2 on I .
□

The direction from non-Boolean to Boolean in the proposition above implies that lower bounds
on Boolean containment of MDL into UCQ applies to unary MDL as well. The other direction is
used to transfer upper bounds. Our upper bounds will be proven for several restricted classes of
Boolean MDL. The analogous definitions for non-Boolean MDL will be obvious, and all of these
classes will easily be seen to be preserved by the transformation from above. Hence the argument
above implies that these upper bounds also apply to the corresponding non-Boolean problem.

Note that this simple argument does not apply to the results of Chaudhuri and Vardi [18] on
containment of connected unary MDL queries into a union of unary connected queries, since
connectedness is not preserved by the reduction.

Relying on Proposition 2.3, we will only consider Boolean queries in the rest of this paper.
Because of this, note that we can assume that variables are not reused across conjuncts of a UCQ.

2.2 Monadic Expansion Trees
Before discussing the complexity of the containment problem, we introduce the notion of monadic
expansion tree of a Boolean MDL query that will be used in various proofs throughout the paper.
Monadic expansion trees are inspired by the notion of expansion trees of [18, 19]; a monadic
expansion tree is not a special case of an expansion tree, but a refinement of this notion that adds
structure to it exploiting the fact that the datalog query is monadic. Monadic expansion trees can
also be seen as a special kind of tree decomposition [30].

Definition 2.4. A monadic expansion tree over some signature σ is an instance I over σ , together
. Every node n of T
is associated with a set of
)
n
. In addition, all nodes except for the root are
(
, called the output element of the node n. We require that:
)
n
(

I
with a finite, rooted, ordered, unranked tree T
(
facts of I , called the bag of n and denoted bag
associated with an element v from dom
a
) ∈
(
I
T
(
∈

I
(
I appears in a bag
)
, every value a appearing in atoms of bag

n
) ∈
(
I
element of n or the output element of one of n’s children in T
;
)
(

(i) every fact R
(ii) for every n

is either the output

(iii) for every non-root n
(iv) the output elements of nodes are all distinct.
We denote a node n by a pair
))
a monadic expansion tree I is the maximal number of children of any node in T

with parent n′, the output element of v appears in bag

consisting of its output value and bag of facts. The rank of

v, bag
(

for some n

n′)
;
(

dom

n
(

n
(

I
(

I
(

I
(

T

T

∈

∈

)

)

)

)

)

)

;

I
(

.
)

Example 2.5. Consider the following monadic expansion tree

over the same signature as

in Example 2.2. It is represented as its tree T

(with the root to the left):

I, T
(

I
(

))

c
(

T
{

b,
(
This tree happens to have no branching (i.e., it has rank 1). The corresponding instance is I =
a
, verifying requirement (i). It is easy to check that the other requirements
(

a, b
(

b, c
(

b, c
(

,T
)

a,
(

G
{

G
{

c,
(

S
{

a
(

c
(

)})

)})

)})

)}

)}

, G
a, b
, G
S
{
)
(
)
are satisfied.

I
(

)

Note that, for each domain element a, the nodes of a monadic expansion tree containing a form
a connected subtree of size at most 2: indeed, requirement (ii) implies that any bag containing a
must be the bag n that has a as output element – which is unique by requirement (iv) – or the

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:7

parent of n (if n is not the root). Together with the other conditions, this means that a monadic
expansion tree is a special kind of tree decomposition [30].

A fundamental fact is that there always exists a monadic expansion tree that is a witness for
non-containment of a monadic datalog query in a UCQ. A similar result appears in various other
places in the literature, such as [23, Theorem 5.2], [18, Proposition 3.7], or [13, Theorem 1] in the
specific setting of limited access containment. One distinction of the result presented here with
respect to those works is that our definition of monadic expansion tree enforces a stricter structure,
in particular through the use of output elements associated to nodes, that we will need, further on,
to prove upper bounds on the containment problem.

Proposition 2.6. Let Q be an MDL query with at most k atoms in the body of each rule, and at
most p intensional predicates. Let Q ′ be a UCQ over the extensional signature of Q. If Q is not contained
I, T
in Q ′, there exists a monadic expansion tree
k facts per bag, such that I
I
(
(
satisfies Q

, with at most p

Q ′.

))

×

∧ ¬

Proof. This proof is based on the notion of expansion tree of a datalog query, as defined in
Section 2.4 of [18]. An expansion tree of a Boolean MDL query Q, as defined in that work, is a
finite tree where each node is labeled by an instantiated rule r of Q. We will assume that this
instantiation does not introduce any spurious equalities. Specifically, we fix for each node n of the
tree a one-to-one mapping φn from the variables of the rule to some set of variables. We annotate
the node n with the instantiated rule φ
. Furthermore, if a node is labeled with an instantiation of
)
a rule r , it has a child for each intensional predicate atom A appearing in r . The label of that child
is a rule r ′ with A in the head, with the variables of A mapped to the same variables as in r , and
other variables of r mapped to fresh variables. The root of the tree is labeled with a rule that has
the goal predicate as its head.

r
(

t
For any expansion tree t of an MDL query Q, we let Πext(

be the set of all extensional atoms
appearing in nodes of t. A critical observation made in [18] is that Q is equivalent to the infinite
t
disjunction of the Πext(
being seen as a conjunctive
query, where we conjoin all atoms and existentially quantify all variables. In particular, if some
instance I0 satisfies Q
and, of
course, we still have I0 ̸|

t
, with t an expansion tree of Q, each Πext(
Q ′, then there exists an expansion tree t such that I0 |

= Πext(
t

∧ ¬
= Q ′.

)

)

)

)

Example 2.7. Returning to the Datalog program in Example 2.2, where we label the rules: r1 :

() ←
. One expansion tree would have r1 at the root, r2 instantiated as Reachable
R
as the only child of the root, and r3 instantiated as Reachable

) ←

) ∧

)

)

, r2 : Reachable

y
(

G

x, y
(

Reachable

T

x
(

) ∧

Goal
R
x
)
(
z
Reachable
)
(
of the instantiation of r2.

x
(

x
(

z
(

, r3 : Reachable
G
x
(
z
(

x
) ←
(
x, z
) ←
) ∧
(
as a leaf child
)

) ←

Reachable

So far, we have not used the fact that Q is monadic. We do so now, by first arguing that we can
choose t such that there are no two nodes n and n′ in t, with n a strict ancestor of n′, sharing the
same head atom R
). If there were
such nodes, the subtree rooted at n could be replaced by the subtree rooted at n′, resulting in a new
expansion tree whose set of atoms is a subset of that of t, and that I0 thus still models. This remark
is similar to Proposition 3.15 of [18], which is also about the monadic case.

with the same variable x (or having the same head atom Goal

x
(

()

)

Moreover, we show how to turn t into a DAG structure G such that no two nodes n and n′ have
with the same variable x, or the same atom Goal
the same head atom R
. For this purpose, an
n′ iff n and n′ have the same
equivalence relation
head atom. We fix an arbitrary representative of the equivalence class of every node n, denoted
φ
n′))
.
(
Since we assumed no two equivalent nodes could be strict descendants of each other, G is acyclic.

x
(
is associated with the nodes of t such that n
≡

. We then transform t into a graph G where each edge
)

is turned into an edge

n, n′)
(

, φ
)

φ
(

n
(

n
(

()

≡

)

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:8

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

.

)

)

We now build a monadic expansion tree

G
similarly to the way we defined Πext(
G
We can define Πext(
, as the conjunctive query formed of
)
t
all extensional atoms of the rules annotating nodes of the graph. Note that Πext(
is contained in
since the set of atoms of G is a subset of that of t. This means our original I0 is still a model
Πext(
G
)
G
of Πext(
from a “canonical model” of G. Let ν be a
G
Πext(
one-to-one mapping from the variables of G to constants. We let I (cid:66) ν
and define the
of I for some variable x. We construct a new node nc
tree T
with c as output element, and let bag
contain all extensional facts associated by ν to the atoms of
the nodes of G having x in their head atom. Similarly, we construct one node r whose bag contains
all extensional facts associated to atoms of nodes of G having Goal
as the head atom. For each
value d in a fact within the bag of a node n distinct from its output element if any exists, we put an
edge from n to nd . We will show that this structure is indeed a monadic expansion tree.

as follows. Consider a value c = ν

I, T
(

nc )
(

x
(

I
(

I
(

))

))

()

)

)

(

)

)

x
(

to itself through a node nν

We first argue that the underlying structure is a DAG rooted at r . By definition, there cannot
be an edge from a node n to itself, and there cannot be an edge to r . If there were a path from
with x (cid:44) y, it would mean that, in G, and thus in t,
a node nν
there would be a disconnected set of nodes with the same variable x in their head atom; this is in
contradiction with the definition of expansion trees.
I
(
whose bag involves a fact with ν

is not only a DAG, but a tree. We claim that for any variable x, there
I
apart from the bag whose output
is only one node of T
(
element is ν
. It will be the node corresponding to the parent of the topmost node of G whose
head atom refers to x; it is easy to see that, in G a node can only have several parents if parents
and child share the same head atom variable. We deduce that T

Second, we show that T

is a tree.

x
(

x
(

y
(

)

)

)

)

)

We now verify the properties required of monadic expansion trees:
I
(i) Every extensional atom in G is in some node n of G; it will thus be present in T
(

, either in
)
if the head of atom of n is of the form

, or in nν

the root bag r if the head atom of n is Goal
R

()

x
(

)

I
(

)

(ii) If a value d appears in a bag nc of T
(iii) A node nd cannot be a child of a node n in T
I
(iv) Nodes of T
)
(
of nodes are all distinct.

I
(

)

I
(

)

then, by construction either d = c, or nd is a child of nc .

are either the root or indexed by their output element, so that output elements

unless d appears in bag

n
(

;
)

Let us now verify that the maximum number of facts per bag is less than or equal to p

k. The
corresponding to some node n of G, a fact for
root bag r contains, for each intensional atom Goal
every extensional atom within n. Note that there are at most p intensional atoms and the number
of extensional atoms n is at most the number of atoms in the body of the rule, which is at most k.
Similarly, a bag nν
corresponding to some
node n of G, a fact for every extensional atom within n. Here we note that there are at most p atoms
of the form R
, and the number of extensional atoms in the rule is again at most k. We obtain the
x
(
desired bound.

contains, for each intensional atom of the form R

x
(

x
(

()

×

)

)

)

)

G
(

= Q and I
|

It only remains to show that I

= Q ′. The former is immediate: I is the extensional
̸|
part of ν
, which is a canonical model of G, when G is seen as a conjunctive query – and G can be
= Πext(
expanded into an expansion tree of Q. The latter comes from the fact that we showed I0 |
G
,
)
= Q ′, witnessed
which means that there exists a homomorphism ρ : Πext(
G
|
µ would be a homomorphism from Q ′ to I0, contradicting
by homomorphism µ, then ρ
◦
I0 ̸|
□

I0. If we had I

= Q ′.

) →

1
ν −

◦

Example 2.8. Consider, again, the monadic expansion tree of Example 2.5. It is actually a witness

of non-containment of the program P of Example 2.2 into the UCQ’s Q1 from Example 2.2.

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

x
(

.
)

Monadic Datalog, Tree Validity, and Limited Access Containment

6:9

2.3 Trees and Tree Validity
Our results for datalog containment will make use of trees in several ways. First, our upper bounds
will make use of techniques from tree automata, so we will need to review the definitions of several
flavors of automata. Second we will show a tight connection between datalog containment and
“universality” or “validity” problems for queries over trees: given a schema describing a set of trees
and a Boolean query over trees, does every tree satisfy the query? There are many variants of the
problem, depending on the exact signature of trees used. We will thus define several signatures
below.

Let Λ be a finite non-empty set of labels. We will consider the settings of both binary and
unranked trees. Many of our lower bounds will work in the restricted setting of binary trees. For
binary trees with labels from Λ, the following signature is natural.
The relational signature of ordered, labeled, binary trees, denoted

bin
Ch1,Ch2, contains the binary
S
predicates FirstChild, SecondChild, unary Root, Leaf predicates, and Labelα predicates for all
α

Λ.

∈
A tree T over
(i) the non-empty LabelT

∈
label of a node n, which is the α

α ’s for α

bin
Ch1,Ch2 is a relational instance such that:
S

Λ form a partition of dom
α );

Λ such that n

LabelT

∈

∈

(one can thus talk about the

T
(

)

∃

x, r
(

) ∨

(ii) FirstChildT and SecondChildT are one-to-one partial mappings with the same domain (the
set of internal nodes), whose complement is LeafT (the set of leaves), and with disjoint ranges;

x FirstChild

(iii) the inverses of FirstChildT and SecondChildT are one-to-one partial mappings;
x, x
(iv)
SecondChild
(
(v) RootT contains exactly one element (the root r of T ), and the following formula does not hold
.

does not hold;

SecondChild

x FirstChild

x, x
(

for r :

) ∨

∃

)

We denote as

bin
bin
Ch1,Ch2,Child,Child? ) the relational signature containing all
Ch1,Ch2,Child (resp.,
S
S
Ch1,Ch2 together with a binary Child relation (resp., binary Child and Child?
bin
S
bin
Ch1,Ch2,Child is a relational instance that verifies the same axioms as a tree
S
Ch1,Ch2, where ChildT is the disjoint union of FirstChildT and SecondChildT . A tree over
S
x = y

the relations of
relations). A tree T over
over
bin
Ch1,Ch2,Child,Child? has the additional requirement that
S
holds.

y Child?
∀

x, y
Child
(

x, y
(

) ↔ (

x
∀

) ∨

bin

)

Note that we omit the label alphabet Λ from notation such as

bound results concerning
lower bounds we will usually show hardness for any label set of size at least 2.

bin
Ch1,Ch2 and
S

bin
Ch1,Ch2 for readability. Our upper
S
bin
Ch1,Ch2,Child will hold for any label set Λ, while in our
S

x, r
(

)

The relational signature of unordered, labeled, unranked trees, denoted

the binary predicate Child together with the unary Root, Leaf, and Labelα . A tree over
a relational instance such that:
(i) the non-empty LabelT
Λ form a partition of dom
(ii) ChildT is a tree in the usual sense, whose root is the only element of RootT and whose leaves

α ’s for α

T
(

;
)

S

∈

are exactly the elements of LeafT .

We sometimes consider as special cases trees formed of a single node (i.e., trees such that

T
dom
(

|

)|

= 1); we call them root-only trees.

Example 2.9. Consider the simple abstract tree with a root labeled α and two children labeled β

and γ respectively represented here with the root at the top:

α

β

γ

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

unranked
Child

S

, is made out of
is

unranked
Child

6:10

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

In the four signatures introduced, this tree can be represented as the following collection of facts:

f

S

bin
Ch1,Ch2,Child

r
all four signatures Root
(
bin
FirstChild
Ch1,Ch2
FirstChild
FirstChild
Child?
(
r, f
Child
(

, Labelγ (
, Leaf
, Labelβ (
, Labelα (
s
r
)
)
)
)
r, s
, SecondChild
r, f
)
(
)
(
r, s
, Child
r, f
, Child
r, s
, SecondChild
r, f
(
)
(
)
(
)
(
r, s
, Child
r, f
, Child
r, s
, SecondChild
r, f
(
(
)
(
)
(
)
, Child?
, Child?
, Child?
r, s
r, f
f , f
(
)
(
)
)
r, s
, Child
(
)

bin
Ch1,Ch2,Child,Child?

, Leaf
)

unranked
Child

s, s
(

s
(

S

S

)

)

(

f

)

S

)
, Child?
)

r, r
(

,
)

We will consider several methods for defining families of trees, in particular tree automata and

document type definitions (DTDs). We define them formally in the binary case.

(

Ω, ∆0, ∆, F

is of the form
and F
run is accepting if for all leaves l labeled with α
and if n has left and right children n1 and n2 respectively and label α, then

Definition 2.10. A nondeterministic tree automaton on binary trees (or BNTA) over finite alphabet Λ
Ω,
, where Ω (the control states) is a finite set, ∆0 ⊂
)
Ω. A run ρ of a BNTA over a Λ-labeled binary tree is an assignment of states to nodes. A
∆0; the root is assigned a state in F ;
Λ,
, ρ
∆.
A deterministic tree automaton on binary trees (BDTA) over Λ is a BNTA in which for every

α, ρ
(

n2)
(

n1)
(

, α, ρ

Ω, ∆

)) ∈

)) ∈

n
(

Ω2

l
(

Λ

Λ

×

×

⊂

×

⊂

∈

ρ

(

q1, q2, a
(

) ∈

Ω2

×

Λ, there is at most one q such that

q1, q2, a, q
(

) ∈

∆.

The set of all binary trees having an accepting run of BNTA A is the language of A, noted L

.

A
)
(

Such a language is then said to be regular.

⊂

Λ

i⩽r Ωi

A nondeterministic tree automaton over ranked trees (NTARk) is defined similarly, but with
∆
Ω for some r . Such an automaton expects trees in which the outdegree of
each vertex is at most r . The notion of deterministic tree automaton over ranked trees (DTARk), the
language of such an automaton, and regularity of a language of ranked trees is defined analogously
to above.

(cid:208)

×

×

We will also make use of the corresponding notion of nondeterministic tree automaton over
unranked trees, NTAUnr and of a regular language for unranked trees, see [25]. We will not need to
know the definition of a NTAUnr, since most of the results involving NTAUnr will come from prior
work. We will use the following simple facts relating NTAUnr to their ranked counterparts:

•

•

A BNTA, and more generally an NTARk, is a special case of a NTAUnr, since we can enforce a
restriction on the rank with an automaton.
A witness for the non-emptiness of an NTAUnr A can always be taken to have rank polynomial
in the size of A. This can be shown by just “trimming” a witness.

Λ
where d is a function from Λ to 2(

if (i) for any node n labeled a, if n is a leaf then ε

A DTD for binary trees over Λ (BDTD) is a pair

d, l0)
}
(
giving the constraints over the labels of the children of a node; l0, an element of Λ, is the root label.
d, l0)
d
A binary tree t is accepted by a BDTD
a
)
(
(
and, otherwise, if b and c are the labels of the first and second children of n then
; (ii) the
)
root of t is labeled by l0. The set of all trees accepted by a BDTD D is the language of D, noted L
D
.
)
(
The standard notion of a DTD [28] is for unranked trees. For clarity and to keep a uniform notation
we refer to these as UDTDs. For these, d is a function from Λ to regular expressions over Λ. The
notion of acceptance of an unranked tree by a UDTD is standard, and we will not have need of it
here. We will need the well-known and simple fact that BDTDs can be turned into BNTAs accepting
the same language in linear time, and similarly for the unranked case.

b, c
(

a
(

) ∈

)∪{

∈

d

Λ

×

ε

Definition 2.11. A query on one of the signatures is valid over an automaton or DTD appropriate
for that signature (e.g., BNTA or BDTD for a signature for binary trees) if for all trees that satisfy
the schema, the query returns true. A query is valid with respect to a set of node labels if the query
returns true on all trees over that set of node labels.

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:11

2.4 Limited Access Patterns
An important area where monadic datalog programs arise is that of querying under access constraints
[6, 13, 24, 26, 29], also known as querying under limited access patterns, or, simply limited access
querying. We recall basic notions from these works.

Access methods. Given a relational schema, we consider a set of access methods

ACS =

{

AcM1 . . . AcMm }
AcMi )

of input positions
with each AcMi consisting of a source relation Rel
(
; intuitively, each access method allows one to put in a tuple
from the set of positions of Rel
(
and get as a result a set of matching tuples. A position of R that is not
of values for InputAtt
AcMi )
(
an input position of a method AcM is an output position of AcM. As mentioned in the introduction,
we assume that all attributes have the same domain; we do not consider separate abstract domains
per attribute.

and a set InputAtt

AcMi )
(

AcMi )

A combination of an access method and a binding to the input places of the accessed relation
will be referred to as an access. We will often write an access by adding “?” to the non-input places,
omitting the exact method: e.g., R
is an access (via some method) to R with the first place
bound to 3. If R does not have any output positions, we say that it is a Boolean access, and we
R. If R does not have any input
write for instance R
positions, we say that it is a free access. In particular, free accesses can serve to model some initial
facts (or some initial data values) that are known before making any access.

? for an access that checks whether

3, ?
)
(

3, 4
(

3, 4

) ∈

(

)

We also assume, following the literature,1 that each relation has exactly one access method –
allowing relations with no access would not make any difference in our setting, as they would
make queries using them unanswerable.

Given a set of access methods and an instance I over signature σ , we define a sequence of values
I
and a sequence of facts AccFactsk (

by mutual induction as follows:

)

I
AccValuesk (
)
I
AccValues0(
•
For k ⩾ 0:
•
I
AccFactsk (

=

;

∅

)

=

)
j1 ...jm }

{

σ#j1=v1∧···∧

#jm =vm (

Rel
(

AcM

))

I
(

;
)

For k ⩾ 0, AccValuesk+1(
I

•

I
We denote AccValues
(

)

(cid:216)AcM
ACS
∈
=InputAtt

I

(

AcM

v1,...,vm ∈

AccValuesk (
(cid:216)
)
= dom
I
AccFactsk (
(
I
, respectively, the fixpoint of these two sequences.
and AccFacts
)
(

.
))

) (cid:2)

)

(cid:3)

Containment under access constraints. We now give the formal definition of containment under

limited access patterns.

Definition 2.12. Let Q and Q ′ be two queries over the relational schema. Q is contained in Q ′

under the access methods of ACS if, for every instance, I Q

I
AccFacts
(

(

)) ⊆

AccFacts

Q ′(

I
(

.
))

Example 2.13. We consider again the same signature as in Example 2.1: a binary relation G and
two unary relations S and T . Assume that the access methods consist on a free access to relation R,
an access with input on the first position for relation G, and a Boolean access on relation T .

Then, under these access methods, the CQ

x T

∃

is contained in the UCQ :

x T

(∃

x
(

) ∧

R

x
(

x ′

)) ∨ (∃

∃

y ′
(

) ∧

G

x ′, y ′
(

))

.

x
(
)
y ′ T

1To the best of our knowledge, with the exception of [6], work on containment under limited access patterns has assumed
(at most) a single access per relation. Indeed, access patterns are usually defined to be attached to positions of a relation. See
Section 7 for a discussion of the importance of this assumption.

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:12

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

Indeed, the only way to make an access to relation T is for the value bound to be accessible,
which is only possible if it has been produced by the free access to relation R or by an access to
relation G, with first position bound to an accessible value.

As mentioned in the introduction, containment under limited accesses is strongly related to con-
tainment of monadic datalog queries [26], in a manner that we now explain. Assume that Q and Q ′
are Boolean UCQs. Then containment of Q in Q ′ under ACS can be reduced to the containment of
a monadic datalog query P in Q ′. We write Q =
i=1 φi (
conjunctions of atoms.
The monadic datalog query P makes use of an intensional predicate AccValues and is formed of
(cid:212)
the following rules:

with the φi (

xi )

xi )

k

Goal

() ←

φi (

xi ) ∧

xi,j )
AccValues
(

for 1 ⩽ i ⩽ k

(cid:219)j
x

(1)

(2)

xj ) ←
AccValues
(
i
for every 1 ⩽ ℓ ⩽ m, and output position j of AcMℓ.
(cid:219)

Rel
(

AcMℓ

) ∧

)(

InputAtt
(

AcMk )

∈

xi )
AccValues
(

Note that if we were to deal with abstract domains, these rules would change to include a

predicate AccValuesτ for each abstract domain τ .

Example 2.14. The monadic datalog program resulting of the rewriting of query

access methods of Example 2.13 is:

x T

∃

x
(

)

for the

Goal
() ←
y
AccValues
(
x
(

AccValues

) ←

) ←

T

x
(
) ∧
x, y
G
(
x
(

R

)

x
AccValues
(

)
x
AccValues
(

) ∧

)

Note that this is exactly the program of Example 2.2.

From the previous discussion and Proposition 2.6, we derive immediately:

Corollary 2.15. If a UCQ Q is not contained in a UCQ Q ′ under a set of access constraints, then
there exists a monadic expansion tree I that is a model of the MDL query P associated to Q under the
access constraints, such that I satisfies Q

Q ′.

∧ ¬

We now have all the necessary elements to state the main results proved in this work.

3 STATEMENT OF THE MAIN RESULTS
In this paper we study three problems of interest, with strong connections: containment of monadic
datalog, validity problems on trees, and containment of UCQs under access constraints.

Though the connection between monadic datalog and querying under limited accesses is well-
known [26], one major contribution of this work is to highlight the connection to tree validity
problems.

In Section 4, we present upper bounds, by providing a technique for giving EXPTIME upper
bounds on certain variations of both the tree validity problem and the query containment problems.
In our lower bound section (Section 5), we prove 2EXPTIME and EXPTIME lower bounds for
different variants of the tree validity problem. The technique here is to adapt ideas from [9]. We
then use a reduction from tree validity to MDL containment (given in the proof of Theorem 5.10)
that allows us to push the 2EXPTIME lower bound to the MDL containment problem, and another
reduction (given in the proof of Theorem 5.11) that allows us to push EXPTIME hardness from tree
validity to containment under access constraints.

Let us now briefly review the currently known bounds, as well as the results proved here, on

tree validity and query containment.

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:13

3.1 Results on Tree Validity Problems
We begin by overviewing results on tree validity that are either explicitly in prior work, can be
derived with little effort from prior work, or are easy to derive directly. The discussion here will be
quite abbreviated, but it does not concern the main results of the paper.

We first note that validity over all trees is tractable for CQs:

Proposition 3.1. Determining if a CQ is valid over all trees for a given label set can be done in

PTIME over

unranked
Child

,

bin
Ch1,Ch2,

bin
Ch1,Ch2,Child, and

S

S

bin
Ch1,Ch2,Child,Child? .
S

S

Proof. We claim a CQ Q is valid if and only if the following conditions are all satisfied:
(i) it does not contain any FirstChild, SecondChild, or Child atom;
(ii) either it does not contain any Labelα atom or
(iii) there are no (possibly identical) variables x1, x2 such that

|
is in the reflective transitive
symmetric closure of the set of pairs of variables appearing in a Child? atom, and such that
x1)
Root
(

appear in Q.
Indeed, if any of these conditions is not satisfied, Q is not valid:
(i) any root-only tree is a counterexample;
(ii) any tree with no node of that label is a counterexample;
(iii) any tree formed of a single chain of nodes of length greater than the number of Child? atoms

x1, x2)
(

and Leaf

x2)
(

= 1;

Λ

|

plus 1 is a counterexample.

Conversely, if T is an arbitrary tree and Q satisfies (i)–(iii), mapping every query variable of Q to
the root of the tree if the connected component of that variable does not include any Leaf atom,
and to an arbitrary leaf of the tree otherwise, yields a homomorphism. Indeed, we know that Q
contains only Root, Leaf, and Child? atoms, and that in each connected component of Q there
cannot be both a Root and Leaf atom.
□

S

unranked
Child

Apart from this very special case, the best upper bound known for the tree validity problems we
with respect
consider is 2EXPTIME. Indeed, in [8, Theorem 11], validity of a query over
to an NTAUnr was shown to be in 2EXPTIME for CQs. This 2EXPTIME upper bound actually holds
for all considered problems on tree validity. For most of our signatures, such a bound can be
obtained as follows. Convert the UCQ Q to an exponential-sized tree automaton (e.g., BNTA for
signatures appropriate to binary trees) AQ in exponential time. See, for example, [2, Proposition
B.1] for this conversion. Then using standard automata techniques [21] we can determinize AQ in
exponential time, complement it, and intersect it with the automaton representing the schema in
polynomial time. Finally, we can test the resulting automaton for emptiness in polynomial time.
bin
In the case of
Ch1,Ch2,Child,Child? to a positive
S
bin
existential query Q ′ over
Ch1,Ch2,Child. The query Q ′ can be converted in exponential time to an
S
alternating automaton over trees. The construction is a standard induction: the atoms are converted
to automata that work over trees with the free variables annotated on the tree. Conjunction and
disjunction are done using the closure properties of alternating automata, which allow positive
Boolean combinations in the transition function. Existential quantification can be assumed to
be outermost, and requires projecting out the annotations. This can be done by converting the
alternating automaton to a nondeterministic automaton in exponential time; for nondeterministic
automata the projection step is straightforward. Emptiness of alternating automata can be checked
in exponential time [21], which gives the 2EXPTIME bound.

bin
Ch1,Ch2,Child,Child? , we first convert a UCQ Q over
S

Let us now discuss existing lower bounds. The validity problem with respect to DTDs over
unranked
is
has been studied in [9]. [9, Theorem 12] shows that the validity problem for
Child
S
EXPTIME-hard for child-only tree-pattern queries. Given that one can convert these straightforwardly

unranked
Child

S

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:14

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

Table 1. Summary of results on the complexity of tree validity of CQs and UCQs, over various tree signatures
and with respect to DTDs, tree automata, or all trees

Previously known results [8, 9] and straightforward arguments from Section 3.1
(in particular, Proposition 3.1 for PTIME results)

Signature

CQ
(DTD or tree automaton)

UCQ
(DTD or tree automaton)

CQ
(all trees)

UCQ
(all trees)

unranked
Child
bin
Ch1,Ch2
bin
Ch1,Ch2,Child
bin
Ch1,Ch2,Child,Child?

S

S

S

S

EXPTIME-hard, in 2EXPTIME

EXPTIME-hard, in 2EXPTIME

PTIME

in 2EXPTIME

in 2EXPTIME

in 2EXPTIME

PTIME

in 2EXPTIME

EXPTIME-hard, in 2EXPTIME

EXPTIME-hard, in 2EXPTIME

PTIME

in 2EXPTIME

EXPTIME-hard, in 2EXPTIME

EXPTIME-hard, in 2EXPTIME

PTIME

in 2EXPTIME

Results proved in Sections 4 (upper bounds) and 5 (lower bounds).
We give references to statements proving the bounds;
lower bounds w.r.t. tree automata are transferred to lower bounds w.r.t. DTDs using Corollary 5.2.

Signature

unranked
Child

S

bin
Ch1,Ch2

S

bin
Ch1,Ch2,Child

S

bin
Ch1,Ch2,Child,Child?

S

CQ
(DTD or tree automaton)

UCQ
(DTD or tree automaton)

CQ
(all trees)

UCQ
(all trees)

EXPTIME-complete
(Cor. 4.21)
in EXPTIME
(Cor. 4.21)
EXPTIME-complete
(Cor. 4.21)
2EXPTIME-complete
(Thm 5.3)

EXPTIME-complete
(Cor. 4.21)
EXPTIME-complete
(Cor. 4.21, Thm 5.6)
EXPTIME-complete
(Cor. 4.21)
2EXPTIME-complete
(Thm 5.3)

PTIME

PTIME

PTIME

PTIME

EXPTIME-complete
(Cor. 4.21, Prop. 5.8)
EXPTIME-complete
(Cor. 4.21, Cor. 5.7)
EXPTIME-complete
(Cor. 4.21, Cor. 5.7)
2EXPTIME-complete
(Cor. 5.5)

to CQs, we obtain EXPTIME-hardness of the validity problem for CQs (and thus UCQs) with respect
to UDTD and NTAUnr.

Inspection of prior work easily shows the lower bound carries over to the

bin
Ch1,Ch2,Child signature
S
bin
and, consequently, to the
Ch1,Ch2,Child,Child? signature, as we now explain. Theorem 12 of [9] relies
S
on Theorem 11 in the same paper, whose proof involves a reduction from finding a winning strategy
in a game on tiling systems [20, Rectangle Tiling Game]. Critically, the number of possible moves
in this strategy is bounded, by the number of different tiles, which is fixed. Thus the trees involved
in the hardness proof are actually ranked. Now, we use a standard encoding of b-ranked trees
as binary trees where every node n with at most b children is replaced with a binary subtree of
whose leaves are the children of n. This means that, in the CQ, we replace
b
height exactly
log2(
⌈
every Child atom with a chain of
child atoms. In the DTD, we enumerate the bounded
number of possible words for the labels of children of every node label, and choose fresh node
labels for every such possible word and every position in the binary tree encoding the unranked
Child relation. It then becomes easy to transform the UDTD on unranked trees into a BDTD on
the encoded binary trees.

b
log2(
⌈

)⌉

)⌉

This concludes our discussion of the state of the art prior to our work. Table 1 (upper) summarizes
the results that can be derived from [9] and from the other arguments given so far in this section.
In the table, we have abbreviated “all trees in a given label set” by “all trees”.

In this work, we establish tight complexity bounds for the validity of CQs and UCQs over all four
bin
bin
tree signatures introduced (
Ch1,Ch2,Child,Child? ) with respect
Ch1,Ch2,Child, and
S
S
to DTDs, tree automata, and over all trees. The results are summarized in Table 1 (lower). The

bin
Ch1,Ch2,
S

unranked
Child

S

,

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:15

Table 2. Summary of results on the complexity of query containment. We give references to statements
proving the bounds, from Sections 4 (upper bounds) and 5 (lower bounds) or the literature.

Query containment setting

Containment

Upper bound Lower bound

2EXPTIME-complete
MDL in MDL
2EXPTIME-complete
MDL in UCQ
MDL in CQ
2EXPTIME-complete
UCQ in UCQ + access constraints EXPTIME-complete
EXPTIME-complete
AGEMDL in UCQ
2EXPTIME-complete
3-GEMDL in UCQ
2EXPTIME-complete
Datalog in UCQ

[22, Thm 7.2]
[22, Thm 7.2]
[22, Thm 7.2]
Cor. 4.28
Cor. 4.28
[22, Thm 7.2]
[19, Thm 5.12]

Thm 5.9
Thm 5.9
Thm 5.9
Thm 5.11
Cor. 5.12
Thm 5.10
[19, Thm 5.15]

results on validity over all trees refer to the combined complexity of the problem that takes as
input both the query and label set, determining if the query is valid for that label set. There is one
bin
exception where a tight bound is still open: the case of CQs over
Ch1,Ch2 with respect to BDTDs
S
or BNTAs. In all other cases (beyond the trivial PTIME case of CQs over all trees), we establish
bin
2EXPTIME-completeness (for
Ch1,Ch2,Child,Child? ) and EXPTIME-completeness (for the other three
S
signatures).

3.2 Results on Containment for MDL and Access Constraints
Recall that containment of MDL queries in UCQs is in 2EXPTIME by [22] (indeed, this holds also
for containment of two MDL queries [22] or for Datalog in UCQs [17, 19]). In this paper we show
that this problem is 2EXPTIME-hard, thus obtaining a tight characterization of its complexity.

In contrast, we show that containment of UCQs under access constraints is EXPTIME-complete.
Both the upper and lower bound here are non-trivial. We will also display a subset of MDL, AGEMDL,
that exhibits the same behavior. In an AGEMDL query, the goal predicate never occurs in the body
of a rule, and every extensional predicate has only one occurrence in a rule other than a rule for
the goal predicate. We will see that this restriction of MDL to obtain EXPTIME-completeness is
somewhat robust: if we allow a bounded number of occurrences of every extensional predicate
except of just one (we call k-GEMDL the corresponding fragment of MDL, where k is the bound),
the complexity of containment jumps back to 2EXPTIME-complete.

Table 2 summarizes these results and provides references to the corresponding theorems.

4 UPPER BOUNDS
In a first step, this section will introduce the main upper bound technique of the paper (Sections 4.1
to 4.3). It consists of machinery for showing that certain containment problems have exponential-
sized counterexamples, based on analysis of models that are monadic expansion trees.

We will then show (Section 4.4) that the machinery gives new bounds for tree validity problems.
We will also show (Section 4.5) that it can be used to obtain new bounds for containment under
access constraints, by reduction from a bound on the AGEMDL fragment of MDL, introduced there.

Our machinery revisits the argument showing the 2EXPTIME upper bound of containment of

arbitrary datalog queries in UCQs. This result is proved in [19], as Theorem 5.15 of that paper.

By Proposition 2.6, since we are dealing with monadic datalog queries here, we can restrict
ourselves to monadic expansion trees. We introduce in Section 4.1 a notion of “interface queries”
used to define a type over the nodes of a monadic expansion tree, called IQ-type (Definition 4.5). We
show that IQ-types are enough to characterize monadic expansion trees that are counterexamples

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:16

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

to containment, with the use of automata techniques (Theorem 4.10). This allows us to bound the
size of a minimal counterexample by the number of IQ-types (see Section 4.2). We show how this
yields a generic recipe for getting bounds on the containment problem, by highlighting a property
of some classes of instances (the unique mapping condition, see Section 4.3) that guarantees a bound
on the number of IQ-types.

4.1 IQ-types
How big does a monadic expansion tree that is a counterexample to containment of Q into Q ′
need to be? Clearly it needs to be big enough to witness satisfaction of Q, but the main issue is
how big it needs to be to witness non-satisfaction of Q ′. Intuitively, one only needs nodes that
represent the different kinds of behavior with respect to Q ′. A crude notion of “same behavior”
w.r.t. Q ′ would be to identify a node with the collection of subqueries that simultaneously hold at
that node. Such an abstraction would easily lead to a doubly-exponential bound on the size of a
counterexample to containment. Our main contribution in this section is a finer notion of similarity
that takes advantage of the restricted structure of monadic expansion trees. Intuitively, we do not
care about all subqueries that map to a node, but only about the way that the subqueries impact
what is happening at other nodes. Given a subinstance corresponding to a subtree of the monadic
expansion tree, we can capture that interaction by the restriction of the mapping of query variables
of Q ′ to the root of this subtree. We can thus think of fixing a “root interface”. Naively, our root
interface would require us to specify the mapping to the root bag completely. Instead we allow
ourselves to fix only two things: (1) the set of variables that map to the output element of the root;
(2) for each set of variables at a time, for each connected component of Q ′ disregarding this set of
variables, information about whether the corresponding query is satisfied in the subinstance. We
formalize this idea of satisfied “interface queries” through the notion of IQ-types.

4.1.1 Definitions. We recall that the tree structure associated with a monadic expansion tree is
denoted by T

I
(

.
)

I
Definition 4.1. Let I be a monadic expansion tree and n a node of T
(
at n is the set of facts contained in the bags of n and its descendants.

)

. The subinstance of I rooted

The queries defining IQ-types have to map the facts belonging to bags of descendants of a node

in a particular way, given by the notion of relative homomorphism below.

Definition 4.2. Let q′ be a conjunctive query and X a subset of the variables of q′. Let I be a
X, q′)
monadic expansion tree and n a node of T
(
to the subinstance rooted at n is a function from the variables of q′ to the active domain of the
subinstance rooted at n such that:

. A relative homomorphism h from the pair
)

I
(

(i) the set of variables mapped to the output element of n by h is equal to X ;
(ii) h
(iii) at least one of the facts of h

is included in the subinstance rooted at n;

is included in the bag of n.

q′)
(

q′)
(

Note that if X is non-empty, the third condition is trivially satisfied: a fact that includes a variable

in X is necessarily in the bag of n.

For connected queries, the existence of a homomorphism in the usual sense implies the existence

of a relative homomorphism:

Lemma 4.3. Let q′ be a connected conjunctive query. A monadic expansion tree I satisfies q′ if and
, a subset X of the variables of q′, and a relative homomorphism

only if there exist a node n
from

∈
to the subinstance rooted at n.

I
(

T

)

X, q′)
(

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:17

Proof. The “if” part is obvious: a relative homomorphism from

at n is in particular a homomorphism from q′ to I .

X, q′)
(

to the subinstance rooted

Let h be a homomorphism from q′ to I . Let n be the least common ancestor of all nodes of T

having in their bag a fact of h
the output element of n by h. Observe that one fact of h
connected, the bags containing facts of h
subtree. Therefore, h is a relative homomorphism from

I
)
(
. We let X be the (possibly empty) set of variables mapped to
is in the bag of n. Indeed, q′ being
; n is the root of this
to the subinstance rooted at n. □

q′)
(
form a connected subtree of T
X, q′)
(

q′)
(

q′)
(

I
(

)

In order to define IQ-types, we need a few further definitions. As explained above, IQ-types

define some root interface using a set of queries. The definition of these queries is given below.

Definition 4.4. Given a UCQ Q ′, and a subset X of the variables of Q ′, a subquery q′ of Q ′ covers X

if for each variable x in X , there exists an atom of q′ containing x.

A subquery q′ of Q ′ is closed relative to X if, whenever q′ contains one atom with a variable x
not in X then q′ contains all atoms of Q ′ containing x. (Recall that since we only consider Boolean
queries, we assume that a variable is not reused across CQs of a UCQ.)

A subquery q′ of Q ′ is connected relative to X iff for each atom α1 and α2 in q′, there exist two
variables x1 in α1 and x2 in α2, both not in X , such that there is a path of variables not in X from x1
to x2, where the path is in the graph connecting two variables if they co-occur in an atom of q′.
Note that we allow degenerate paths that consist of a single variable x1 = x2.

A maximal connected component of a query relative to X is a closed and connected subquery

relative to X that covers X .

Note that if the set of variables X is empty, a maximal connected component of Q ′ relative
be the set of maximal

Q
to X is a maximal connected component in the usual sense; we let MCC
(
connected components of a query Q.

)

We now use relative homomorphisms and maximal connected components to define types of a

node in a monadic expansion tree.

Definition 4.5. Let Q ′ be a UCQ. A pair

, where q′ is a subquery of Q ′ and X a subset of the
variables of Q ′, is a type element of Q ′ iff q′ is a maximal connected component of Q ′ relative to X .
is satisfied by a

Let I be a monadic expansion tree and n a node of T

. A type element

X, q′)
(

node n iff there exists a relative homomorphism from

n
The IQ-type of a node n with respect to Q ′, denoted by typeQ ′(

, is the set of all type elements

)

satisfied by n.

I
(
)
X, q′)
(

X, q′)
(
to the subinstance rooted at n.

This notion of IQ-type will be used to characterize instances that satisfy a given query.

Example 4.6. To illustrate the notion of type element, consider the query

Q ′ =

x
∃

y
∃

∃

z C

x
(

) ∧

R

x, y
(

) ∧

R

y, z
(

) ∧

C

z
(

)

We consider the following pairs consisting of a set of variables and a set of atoms from Q ′:
y, z
, R
x, y
R
(
)
(
, C
y, z
, R
x, y
)
(
)
(

T1 =
T2 =

x, z
,
}

)})
z
(

({
x
({

{
R

,
}

)})

{

We claim that both T1 and T2 are type elements of Q ′. We argue that the set of atoms of T1 is closed
and connected relative to the set of variables in T1, and similarly for T2. We give the argument
for T2, with the one for T1 being similar. T2 is connected relative to
since all pairs of atoms are
connected by a path of variables different from x: the two R atoms are connected through y, the
second R atom and the C atom through z, and the first R atom and the C atom through z and y. To
verify relative closedness of T2 we need only notice that T2 contains every atom containing z and
every atom containing y.

x
{

}

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:18

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

4.1.2 Composition Lemma. We now introduce an important lemma, the composition lemma,
critical to the soundness of our technique for finding monadic-expansion-tree counterexamples to
containment of bounded size.

Definition 4.7. Let I and I ′ be two monadic expansion trees and n and n′ two nodes of T

I
)
(
, respectively. A bijection φ from the values of n to the values of n′ is an output-isomorphism

I ′)
and T
(
iff

(i) it is an isomorphism, i.e., for each atom R
in n such that φ

a′1 . . . a′k )
(
= a′i for all 1 ⩽ i ⩽ k;

R

a1 . . . ak )
(

ai )
(

(ii) child ordering is preserved: if v is the output element of the jth child of n, then φ

in n′ there exists exactly one atom

is the

v
(

)

output element of the jth child of n′;

(iii) the output element of n maps to the output element of n′.
Two nodes n and n′ are output-isomorphic iff there exists an output-isomorphism from the values
of n to the values of n′.

We now state our composition lemma: the IQ-type of a node is determined by its bag of facts (up

to output-isomorphism) and the IQ-types of its children.

)

)

)

T

T

I
(

and n′ ∈

Lemma 4.8 (Composition Lemma). Let Q ′ be a UCQ, and I , I ′ two monadic expansion trees. Let
two nodes of these instances such that there is an output-isomorphism φ from
n
∈
n to n′. Assume that for all children nc of n and n′c of n′ with the output element of nc mapped by φ to
n′c)
the output element of n′c, typeQ ′(

n
. Then typeQ ′(

= typeQ ′(

= typeQ ′(

n′)
.

I ′)
(

nc)

v
(

Proof. We denote n1 . . . nk the children of n; n′1 . . . n′k the children of n′. We suppose that for
each 1 ⩽ i ⩽ k, the IQ-types of ni and n′i with respect to Q ′ are the same and that if v is the output
element of ni then φ

is the output element of n′i .

n′) ⊆

n
typeQ ′(

: for any subset of variables X of Q ′ and for any
We demonstrate that typeQ ′(
)
maximal connected component q′ of Q ′ relative to X , if there exists a relative homomorphism from
X, q′)
X, q′)
to the subtree rooted at n then there exists a relative homomorphism from
to the
(
(
subtree rooted at n′. The other direction is implied by the symmetry of the roles of n and n′.
Let X be a subset of the variables of Q ′ and q′ be a maximal connected component of Q ′ relative
X, q′)
to the subtree rooted at n. We need to create a
(
to the subtree rooted at n′.
For 1 ⩽ i ⩽ k we denote by q′i the maximal subquery mapped by h to the subinstance rooted at
A, let Xi be the

to X . Let h be a relative homomorphism from
homomorphism h′ from

ni . Let A be the set of integers i with 1 ⩽ i ⩽ k such that q′i is non-empty. For i
∈
subset of variables of q′i such that the image of Xi by h is the output element of ni .

X, q′)
(

We claim that

is a type element of Q ′, by exploiting the structure of monadic expansion

Xi, q′i )
(

q′i is closed relative to Xi : since every variable x of q′i not in Xi maps to values in the
subinstance rooted at ni , all atoms of q′ containing x are mapped to the subinstance rooted
at ni ;
q′i is connected relative to Xi , since q′ is connected relative to X and every path of atoms
between variables of q′i not in Xi must be entirely in the subinstance rooted at ni .

Furthermore, q′i covers Xi by definition of Xi . Hence,

is a type element of Q ′.

Let α be an atom mapped by h to the bag of n (such an α necessarily exists by the definition of
a relative homomorphism) and αi mapped by h to the subtree rooted at ni . Since q′ is connected
relative to X , there exists a path between α and αi , which translates into a path between h
and
h
that necessarily involves the output element of ni due to the monadic expansion tree structure
αi )
(
of the instance, and thus a fact within the bag of ni . We have thus shown that the restriction hi
to the subtree rooted at ni . In
of h to the variables of q′i is a relative homomorphism from

α
(

)

X, q′i )
(

Xi, q′i )
(

trees:

•

•

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:19

)

)

)

)

)

)

x
(

h
(

; if h

ni )

= typeQ ′(

n′i )

, there exists a homomorphism h′i

Xi, q′i ) ∈
ni )
typeQ ′(
. Since typeQ ′(
other words,
(
Xi, q′i )
to the subtree rooted at n′i .
from
(
as follows: if h
x
We then define h′(
x
(
)
:= h′i (
x
A, we set h′(
x
∈

x
, we set h′(

n
is a value of bag
(

is a value present in a subinstance rooted at some ni for
:= φ
i
. This definition is
well formed: the subinstances rooted at ni and nj do not share any common value, and any value
shared between the bag of n and the subinstance rooted at ni must be the output element of ni .
The requirement that φ preserves child ordering ensures that the output element of any ni in the
domain of φ is mapped to the output element of n′i . Thus we know that for any variable x
Xi ,
x
h′i (
Let α be any atom of q′. Since h is a relative homomorphism from
to the subtree rooted at
(and there is at least one such α) or in one of the subinstance rooted at one
n, h
)
= h′i (
of the ni for i
n′)
h
α
,
)
(
(
which is in the subinstance rooted at n′i . In addition, since φ is an output-isomorphism, the only
variables mapped to the output element of n′ by h′ are the variables mapped to the output element
of n by h, i.e., the set X . In other words, h′ is a relative homomorphism from
to the subtree
rooted at n′.
□

α
A. In the former case, h′(

α
. In the latter case, h′(

n
is either in bag
(

X, q′)
(

X, q′)
(

)) ∈

.
))

= φ

= φ

bag

α
(

α
(

h
(

x
(

x
(

))

∈

∈

)

)

)

)

4.1.3
From IQ-Types to Automata. We now explain how to see IQ-types as states of a tree automaton
operating on monadic expansion trees. This will allow us to see the containment problem in terms
of tree automata and derive upper bounds from there.

More specifically, IQ-types capture the “state” of a node in a monadic expansion tree with respect
to a query: they can be used as states in a deterministic ranked tree automaton that accepts monadic
expansion trees not satisfying a given query. Then, the number of IQ-types with respect to a given
query will have a direct impact on the size of the tree automaton, and from there on the complexity
of the containment problem. We emphasize that the ability to use IQ-types to form such an automaton
relies on some general properties such as the Composition Lemma, not on the fine details of IQ-types.
These details will come into play later – in Section 4.4 and Section 4.5, when we want to argue
that in certain situations we have a tighter bound on the number of IQ-types, and hence a tighter
bound on the size of the automaton.

d, σ
(

Let σ be a relational signature and d a positive integer. We denote by

expansion trees over σ with at most d facts in the bag of each node. We denote by B
output-isomorphism classes of nodes in the instances of
the size of B
choose at most d relation names among O
atoms, the number of which is in O
d
(
r + 1
output elements among these O
one needs to choose at most
)
(
rank of the tree. Since r is itself bounded by the number of constants, i.e., O
total bound on the size of B

the set of monadic
the set of
. Since the size of bags is bounded,
)
, one can
)
and, for each of the positions in the corresponding
d
σ
possible ones; then,
· |
(
|)
values, where r is the
σ
|)
· |
, we obtain a

σ
(|
, choose a constant among O
|)
d
(

is finite. Let us derive a bound on its size: to choose an element of B

d, σ
(

d, σ
(

d, σ

d
(

L(

L(

of:

· |

· |

|)

|)

d, σ

σ

σ

)

)

)

d, σ
(

)

(cid:17)
for some constant χ , i.e., simply exponential in d and in the size of σ .

(cid:17)

(cid:16)

(cid:16)

O

σ

d + O

|

|

d
(

σ

· |

|)

O

σ

d
(

· |

|)

= O

χ d

· |

σ

|

For each output-isomorphism class c of B

ˆc

=

d, σ
(

the finite set Γ
c
|
be used to abstract monadic expansion trees out. For I
d, σ
tree labeled by tags in Γ
I
(
(
corresponding to its output-isomorphism class c.

obtained from T

d, σ
(

. Γ

) }

B

∈

{

)

)

)

d, σ
(
d, σ
(

)

, we choose a distinct symbol ˆc and we consider
)
is used as an alphabet for the finite trees that will
the finite
by the symbol ˆc

)
by labeling each node of T

I
, we denote by Coded (

∈ L(

d, σ

)

I
(

)

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:20

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

Definition 4.9. Let σ be a signature,
is d-regular if

positive integer. We say
Γ

I
d, σ
I ⊆ L(
d, σ
I
I
Coded (
) |
(
A collection of monadic expansion trees is said to be regular if it is d-regular for some d.

a collection of monadic expansion trees over σ , and d a
over the alphabet

and there exists a DTARk A

recognizing exactly the set

)
∈ I }

I

{

I

)

.

I

Let

be a regular set of monadic expansion trees. Let Q ′ be a connected conjunctive query (we
will consider the case of arbitrary UCQs further on). We reduce the problem of validity of Q ′ over a
to the emptiness of a tree automaton. More precisely, we
regular set of monadic expansion trees
I
d, σ
build a deterministic ranked tree automaton AQ ′ over Γ
such that the intersection of AQ ′ and
)
(
= Q ′ }
A
. Intuitively, the states of AQ ′ are the
I
recognizes exactly the set
Coded (
̸|
which cover Q ′. We will use Lemma 4.8 to calculate the transition
types of nodes of instances of
function.

∈ I ∧

{
I

) |

I

I

I

The theorem below formalizes this intuition:

Theorem 4.10. Consider a signature σ , a positive integer d, and let

expansion trees recognized by the ranked deterministic tree automaton A
conjunctive query.

I

I

be a d-regular set of monadic
. Let Q ′ be a connected

There exists a DTARk AQ ′ over the alphabet Γ

I
Coded (
set of IQ-types with respect to Q ′ of nodes of some instances of

not satisfying Q ′. Moreover, the size of AQ ′ is in O

with I

∈ I

)

d, σ
(

, such that AQ ′ ∩
)
|Y|
.

A

I

(cid:0)

accepts the set of all
I
d ,σ
poly
is the
where
(

)

Y

(cid:1)
|Z|

d ,
poly
(

|

σ

,

|

Q ′ |)

|

.

Finally, if one is given a superset

of

Y

Z

, then we can compute AQ ′ in time O

Before we go into the details of the automaton, we classify the types that correspond to good
(cid:1)

(cid:0)

(accepting) and bad (rejecting) states.

Definition 4.11. Let Q ′ be a conjunctive query, Q ′′ a subquery of Q ′, and τ an IQ-type with
for some set of

X, qn)
. . .
respect to Q ′. We say that τ covers Q ′′ if τ contains type elements
(
variables X and subqueries q1 . . . qn that together contain each atom of Q ′′.

X, q1)
(

We note the following simple consequence of Lemma 4.3:

Proposition 4.12. A monadic expansion tree I satisfies a subquery Q ′′ of a connected conjunctive

query Q ′ iff it contains a node n whose IQ-type with respect to Q ′ covers Q ′′.

Proof. Clearly if τ covers Q ′′, then a monadic expansion tree I having a node with type τ must
satisfy Q ′′. Conversely, if I satisfies Q ′′, by Lemma 4.3 there is a set X , a node n, and a relative
to n. Let q1 . . . qn be the maximal connected components of Q ′′
homomorphism h from
X, qi )
to n, while each qi is
relative to X . Then h also serves as a relative homomorphism of each
(
X, qn)
X, q1)
closed and connected relative to X , hence is a valid type element. Thus
witness
(
(
that τ covers Q ′′.
□

Q ′′, X
(

. . .

)

Thus types that cover Q ′ will be the “bad states” of our automaton.

Proof of Theorem 4.10. We denote by

the set of IQ-types τ with respect to Q ′ of
such that Q ′ is not covered by τ . We will construct a deterministic
nodes of some instances of
automaton AQ ′ whose set of states is
Q ′ can be seen as leading directly to
Q ′. IQ-types not in
rejection (i.e., are not co-accessible), and thus need not be made explicit in a trimmed automaton.
Q ′ of types τ in
In the variant where we are given

, we will instead use the set

Q ′ ⊆ Y

Y¬

Y¬

Y¬

I

Z¬

Q ′ ⊇ Y¬

Z ⊇ Y

Z

that do not cover Q ′.
Since
σ
most
|
a label ˆα in Γ

d, σ

|

I ⊆ L(
places. The transition function δ takes as input a list l of at most d

, each node of an instance in
)

has at most d facts, each of which having at
and
is determined in the following manner. Let n be a node

types in

Y

· |

I

σ

|

d, σ
(

. The result of δ
)

l, ˆα
(

)

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:21

I

with output-isomorphism class α and having a list of children whose types
in an instance I of
X, Q ′)
is satisfied by n, the transition is not defined.
match those of l. If there exists an X such that
(
The outcome of the transition is the type τ of n, if τ does not cover Q ′; otherwise, the transition is
undefined. Lemma 4.8 guarantees that this transition function is well-defined: the type of a node
only depends on the types of the children of this node and its output-isomorphism class. We set all
states of the automaton to be final.
I
that AQ ′
Let I be an arbitrary instance in
. Let us show by induction on the structure of Coded (
if and only if Q ′ is not satisfied in the subinstance rooted
I
assigns a state τ to a node u of Coded (
and that, in the case where a state τ is assigned, τ = typeQ ′(
n
at the corresponding node n of T
.
)
Assume this is true for all descendant of a node of u coding a node n in T
. Assume now u is
)
assigned state τ (and thus, τ does not cover Q ′). It follows from the induction hypothesis that the
children have as their state assignment in the coded instance their type, and by definition of the
transition function, τ = typeQ ′(
. Since the subinstance rooted at n does not contain any node
n
)
whose IQ-type covers Q ′, according to Proposition 4.12, it does not satisfy Q ′. Conversely, the only
case where a transition is not defined at a node u is when there exists an X such that
is
satisfied by a node n coded by u.

X, Q ′)
(

I
(

I
(

I

)

)

)

. Thus I is in

We prove the equivalence between acceptance by A′Q ∩
I
not satisfying Q ′. First, let I be a monadic expansion tree having its code Coded (

I
AQ ′ and A
4.12, there exists a node n of T
state corresponding to τ , which is impossible, since no such states are in
states of our automaton. Conversely, let I be a monadic expansion tree in
inductive argument above shows that AQ ′ accepts I , and we know that A

and being the code of an instance of
accepted by
. Suppose by way of contradiction that I satisfies Q ′. Due to Proposition
whose type τ covers Q ′. But then AQ ′ would have to reach a
Q ′, which is the set of
not satisfying Q ′. The
also does.

I
(

A

I

I

I

)

)

Y¬
I
I

)

(cid:0)

· |

· |

σ

σ

|)

O

d
(

|Y|

= O

| × |Y|

Complexity bounds. First, it is easy to check that the size of AQ ′ is in O
d ,σ
poly
χ d
(

=
O
. Indeed, the size of the automaton is dominated by the
size of its transition function. This transition function takes a sequence of states of the automaton
and a symbol of the alphabet and returns a state of the automaton. The maximal length of the
sequence is equal to the rank of the instance, which is bounded by O
. Moreover, the states of
. Finally, each symbol of the alphabet
the automaton are the possible types of
d, σ
is an element of Γ
for
(
the size of the automaton.

, by definition. We finally obtain a bound of O

which is equal to

)| × |Y|

)| × |Y|

d, σ
(

d, σ
(

d
(

Y

d
(

I

· |

|)

B

B

σ

O

)

|)

|)

σ

· |

· |

(cid:0)

(cid:0)

(cid:1)

(cid:1)

(cid:1)

|

|

O

d
(

σ

I

Z

Z

Z

Z¬

Z¬

is O

2 |
(
, vk )

. The computation of

, the maximal size of a type in

Z
. Thus the set of states

Q ′ can be computed in the required time.

We now turn to the claims about computation time. Let

Z
We now discuss the transition function. For each symbol ˆα

be a superset of the IQ-types satisfied
in
and checking coverage
Q ′ can be done by enumerating the types in
of Q ′ by the type. The coverage check is polynomial in the type and Q ′. Thus the total time is
, and Q ′. The maximal size of a type
polynomial in the size of
Q ′ |)
in
, where k is in O

Γ
, for each list of states
)
∈
v1,
, we have to determine the type τ of a node in an instance I
(
τk . For one
of
fixed representative of this output-isomorphism class, we let v be the output element of the node,
B the set of facts, and we let vi be the output element of each child, 1 ⩽ i ⩽ k. We proceed by
constructing a small monadic expansion tree to determine the type τ . This mini-instance has a
node n with bag B and output element v (for technical reasons we cannot put n as the root of
the monadic expansion tree since the root is assumed not to have an output element, but we can
construct a dummy root node that serves no other purpose). We now explain how to construct the
k children of node n.

· · ·
with a bag in the equivalence class ˆα and having children with IQ-types τ1,

d, σ
(

d
(

· · ·

× |

I

|)

σ

(cid:0)

(cid:1)

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:22

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

Xi j, qi j )
(

For each 1 ⩽ i ⩽ k, we build a subinstance Ii as follows: For each type-element

of τi , we
build a mapping νi j from qi j as follows: for variable x appearing in qi j , if x is in Xi j then x is mapped
to vi , otherwise the variable is mapped to a fresh value. We define I ′i j to be an instance formed by
turning νi j into a homomorphism. Ii is the union of I ′i j for all j. The subinstance I is the union of
the Ii and B. We now define a tree decomposition of I . We let the root node have an empty bag and
child n with output element v and bag B. The children of n are ni for 1 ⩽ i ⩽ k, where ni has output
element vi and bag Ii . Clearly, ˆα is the code of the output-isomorphism class of n. Determining the
type of Q can be done by simply enumerating all type elements of
and determining which are
Q ′ |)
Q ′ | · |
satisfied by n, which can be done in time O
. The size of I is the size of B, plus
Q ′|)
an O
. Finally, the whole process of constructing a small monadic expansion tree
d, σ
has to be performed for every possible transition, i.e., O
□
(

Q ′ | · |

)| × |Z|

times.

(|Z| ·

d
(

|))

Z

2 |

d
(

2|

| ·

· |

| |

(|

B

σ

O

σ

· |

I

(cid:212)
(cid:211)

MCC
Q ′i )
(

General UCQs. Theorem 4.10 restricted attention to connected CQs. Now consider the case where
Q ′ =
i Q ′i is a general UCQ. For each i, Q ′i is a possibly disconnected CQ which we can write as
Q ′i =
q′i j . We first construct a deterministic automaton Ai j for each query q′i j as above.
q′i j ∈
Q ′i is not satisfied if and only if one of the q′i j is not satisfied. Thus,
j Ai j is a nondeterministic
ranked tree automaton that recognizes monadic expansion trees that do not satisfy Q ′i . Similarly, Q ′
is not satisfied if and only if none of the Q ′i is satisfied. Therefore if we consider AQ ′ =
j Ai j
j Ai j , we obtain a nondeterministic
and apply a product construction to the automata for each
ranked tree automaton recognizing monadic expansion trees that do not satisfy Q ′. Thus, for any
d-regular set of instances
, applying a product construction to AQ ′ ∩
gives an NTARk that
I
not satisfying Q ′. The construction of the union of the
I
accepts the set of all Coded (
∈ I
)
and in each
deterministic automata as a nondeterministic one can be done in time polynomial in
of the automata (just do the union of the transitions). The construction of the intersection amounts
to considering all possible combination of states and therefore raises the size of the automaton to
an exponent of

. Thus we have a generalization of Theorem 4.10:

with I

Q ′|

(cid:208)

(cid:208)

(cid:211)

(cid:212)

A

I

|

i

Q ′|
|

Theorem 4.13. Let σ be a signature, d a positive integer, and
trees recognized by the deterministic ranked tree automaton A

I
I

a d-regular set of monadic expansion
. Let Q ′ be an arbitrary UCQ.
d, σ
(

that AQ ′ ∩
in O
|Y|
.

I

(cid:0)

Then there exists a nondeterministic ranked tree automaton AQ ′ over the alphabet Γ

, such
not satisfying Q ′. Moreover, the size of AQ ′ is
is the set of IQ-types with respect to Q ′ of nodes of some instances of

with I

∈ I

)

)

A
I
d ,σ ,
poly
(

I
accepts the set of all Coded (
Y

where

Q ′ |)

|

Finally, if one is given a superset

(cid:1)

of

Y

Z

, then we can compute AQ ′ in time O

d ,
poly
(

|

σ

,

|

Q ′ |)

|

.

|Z|

4.2 IQ-Types and Containment of MDL in UCQs
How does the machinery of the last subsection help us? Let us first discuss how these arguments
can be used to reprove the 2EXPTIME upper bound on the containment of MDL in UCQs [19].

(cid:0)

(cid:1)

To determine whether an MDL query Q is not contained in a UCQ Q ′, we can check whether
there exists a monadic expansion tree satisfying Q and not satisfying Q ′ by Lemma 2.6. But we can
actually restrict the search of a witness to a subset of the monadic expansion tree satisfying Q.

Q

UQ(

First, we observe that a monadic datalog program is equivalent to an infinite union of conjunctive
. Second, we can consider special cases of monadic expansion trees I
queries, denoted by
of Q with the following property: there exists a conjunctive query q1 in
and a surjective
homomorphism from q1 onto I . An instance having the previous property is said to surjectively
satisfy Q. Indeed, a monadic expansion tree I of Q that does not satisfy Q ′ has to satisfy some CQ q1
, and all facts not necessary for the homomorphism from q1 to I can be removed from I
in
while keeping the monadic expansion tree structure and the non-satisfaction of Q ′.

UQ(

UQ(

Q

Q

)

)

)

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:23

There exists an integer d polynomial in Q such that the codes of monadic expansion trees
surjectively satisfying Q are in
. More precisely, the set of monadic expansion tree models
)
surjectively satisfying Q is regular and there exists a tree automaton AQ of size exponential in d
and in the sizes of σ and Q. This is an argument very similar to Proposition 5.9 of [19], except for
the difference in coding of the instances (the proof trees of [19] encoding their expansion trees vs
our coding of monadic expansion trees), which is not essential for the proof.

d, σ

L(

We can then apply Theorem 4.13 to compute AQ ′ and test the emptiness of AQ ∩

time in the size of the automata. In the general case of MDL containment in UCQs, if we take
Z
to be all IQ-types, we obtain a doubly exponential bound on the construction of AQ ′, yielding an
overall 2EXPTIME upper bound on the containment of MDL within a UCQ, as in [19].

AQ ′ in polynomial

We now introduce a special property of classes of instances that allow us to take

considerably smaller, yielding a better upper bound.

to be

Z

4.3 Unique Mapping Condition
As we shall see in Section 5, the 2EXPTIME upper bound obtained from our method for the
containment of arbitrary MDL query in UCQs is the best we can do, since the bound is tight. We
can do better if we can restrict to a class of instances that satisfies the Unique Mapping Condition:

Definition 4.14. For any conjunctive query Q ′, a class of monadic expansion trees

Q ′-Unique Mapping Condition (Q ′-UMC) if the following holds for any node n in an instance of

I

satisfies the
:

I

for any type elements

X2, q2)
⋆
of Q ′ satisfied at n, if there exists an
(
(
)
atom A appearing in both q1 and q2 referencing a variable x in both X1 and X2 then
X1 = X2 and q1 = q2.

X1, q1)
(

and

A class of monadic expansion trees has the Universal Unique Mapping Condition (
the Q ′-UMC for every conjunctive query Q ′.

∀

-UMC) if it has

The idea behind the name Unique Mapping Condition is that type elements represent ways in
which Q ′ can be partially mapped into an expansion tree. The UMC says that such mappings are
determined once we know one atom of Q ′ in the domain. The Q ′-UMC should shed more light on
the connectedness and maximality requirements imposed on IQ-types. It is easy to see that for a
disconnected query we will not have a unique mapping even for very restricted structures; and if
we do not look at connected queries that are somehow “maximal”, we cannot get uniqueness.

Example 4.15. In the definition of IQ-types (Definition 4.5), we required the subquery to be
a relative connected component: relatively closed and relatively connected. This restriction is
important for making the UMC non-trivial, and we illustrate this via two examples.

Consider the CQ Q ′1 =

∃
follows (with the root to the left):

y
∃

x
∃

z R

x, y
(

) ∧

R

y, z
(

)

I1)
and a monadic expansion tree I1, with T
(

as

∅)

c,
(
x, y
(

a
A
(
{

a,
(

R

a, b
(

)})
)})
)}
and the following subquery of Q ′1: q1 =

{

{

b,
(

R

b, c
(

}

x
{

. Both
have a relative homomorphism to the subinstance rooted at the node of T

X, Q ′1)
Consider X =
and
(
X, q1)
I
with bag
)
(
(
a, b
R
, and clearly they are different. But this does not contradict the UMC, since while the
)}
{
(
X,
X,
R
is not closed
pair
(
{
(
relatively to X : it has one atom containing y, and thus must have the other such atom in order to
be relatively closed.

is a type element, the pair

is not, since R

x, y
(

x, y
(

x, y
(

y, z
(

, R
)

x
∃

y R

)})

)})

∃

R

{

)

)

Now consider Q ′2 =

as follows:

x
∃

y
∃

z B

∃

x
(

) ∧

R

x, y
(

) ∧

S

x, z
(

)

, and a monadic expansion tree I2, with T

I2)
(

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:24

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

a
A
(
{

)}

a,
(

B

a
(

, R
)

a, b
(

, S
)

a, c
(

{

)})

c,
(

∅)

b,
(

∅)

)

∃

y B

x
∃

x, y
(

and q22 =

whose output element is a. We set X =
x, z
R
(

I
Let n be the node of T
, and consider two subqueries
)
(
of Q ′2: q21 =
z B
x
have a
) ∧
(
∃
relative homomorphism to the subinstance rooted at n in I2, and clearly they are different. But this
,
does not contradict the UMC, since neither
is a type
{
}
element. In this case, the reason is that neither subquery is connected relative to X . The definition
of relative connectedness would require the existence of variables x1 in B
that
x
are not in
, and that are connected by some path. But clearly such variables cannot exist, since
{
the only variable of B

X, q21)
(
,
x
B
x
(
}
({

X, q22)
(
x, z
(

x
}
{
. Both

and x2 in R

x, y
(

x, y
(

, R
)

x
({

, S
)

x
∃

is x.

and

nor

x
(

x
(

x
(

) ∧

)})

)})

B

S

{

}

)

)

)

x
(

)

Above we have given examples that have the UMC, due to the restrictions we have placed on
being a type element. We now show that even with these restrictions, it is possible for the UMC to
fail.

Example 4.16. Consider a monadic expansion tree of the following form (with the root to the

left):

a,
(

R

a, b
(

, R
)

b, a
(

, C
)

a
(

{

)})
)})
This is a valid monadic expansion tree for the MDL program:

{

b,
(

R

b, c
(

, R
)

c, b
(

, B
)

b
(

c,
(

C
{

c
(

)})

P1(
x
P2(
x
x
P3(

) ←

) ←

) ←

R

R

C

Consider again the query

x, y
(
x, y
(

R

R

y, x
(
y, x
(

) ∧

) ∧

C

B

x
(
x
(

) ∧

) ∧

P2(
y
y
P3(

)

)

) ∧

) ∧

x
(

)

x, y
(
from Example 4.6 along with the two pairs that were shown in Example 4.6 to be type elements
of Q ′:

y, z
(

Q ′ =

y
∃

x
∃

x
(

z C

z
(

) ∧

) ∧

) ∧

C

∃

R

R

)

y, z
, R
x, y
R
(
)
(
, C
y, z
, R
x, y
)
(
)
(
We claim that these two type elements witness the fact that the expansion tree above does not

T1 =
T2 =

x, z
,
}

)})
z
(

({
x
({

{
R

,
}

)})

{

satisfy the Q ′-UMC.

x
{

}

Indeed, note that both T1 and T2 are satisfied at the root of the expansion tree. In the case of T1,
the relative homomorphism witnessing this maps both z and x to the value a while mapping y
to b. For T2 the relative homomorphism maps x to a, y to b, and z to c (remember that z cannot be
mapped to a in the case of T2 as

is by definition the set of variables mapped to a).

Now, observe that T1 and T2 have an atom in common, and yet differ in their set of variables and

their set of atoms. Thus they witness the failure of the Q ′-UMC.

The takeaway here is that the presence of symmetries in both Q ′ and the expansion tree can

cause the UMC to fail.

The UMC is a semantic property which is not straightforward to check. However, in Sections 4.4
and 4.5, we will see two cases where the UMC holds: first, by restricting the classes of instances

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:25

we work with (to trees over specific signatures), and second by restricting the MDL program we
consider monadic expansion trees of.

We will show that the Unique Mapping Condition suffices to get better upper bounds. The

interest of the UMC is that it bounds the number of useful types:

Proposition 4.17. Let Q ′ be a UCQ. There exists a set

constructible in time O

of monadic expansion trees satisfying the Q ′-UMC:

Z

that for every set

I

2poly

(|

(

Q ′ |))

, such

n
typeQ ′(

)

.

)

Z ⊇

In particular, the size of

T
∈I (cid:216)n
(cid:216)I
I
(
∈
Q ′ |))
.
Proof. Let n be a node of an instance in
I
By

2poly
(|

is in O

|Z|

(

satisfying

⋆
)
(

and τ = typeQ ′(
n

)

.

⋆
)
(

, for every occurrence of a variable x within an atom A of Q ′, there can be at most one
X . In other words, the number of type elements
with X non-empty is bounded by the size of Q ′. Furthermore, the number of type
is at most the number of maximal connected components of Q ′, i.e., also

with A in q and x

X, q
(

, q

∈

)

type element of the form
of the form
elements of the form
bounded by

X, q
(

(∅

)

)

.

Q ′|
|
, i.e., there are at most O

In other words, choosing an element of
2poly
2poly
(|
(|
(
(
Q ′ |))
Z

can be constructed in O

2poly
(

Q ′ |))

(|

O

requires to choose at most 2

elements among

Q ′|

|

Z
Q ′ |))

elements in

.

Z

as well, for instance by first enumerating all possible type
elements of Q ′ (there are exponentially many pairs
with X a subset of the variables of Q ′
and q a subquery of Q ′, and one can check in polynomial type that such a pair is a type element),
and then constructing all types over these type elements that satisfy the constraints above.
□

X, q
(

)

|

|

, and

Together with Theorem 4.13, this proposition implies that one can compute in time exponential in
a deterministic ranked tree automaton such that the intersection with A
σ
d,
Q ′|
recognizes
that do not satisfy Q ′. Because the intersection of two tree automata
the codes of the instances in
is polynomial in their sizes and the emptiness of a tree automaton can be checked in linear time in
its size, we conclude:

I

I

|

Corollary 4.18. Let σ be a signature, d a positive integer, and Q ′ a UCQ over σ . Let

set of monadic expansion trees over σ with the Q ′-UMC and recognized by the tree automaton A
can be done in O
Then checking if Q ′ holds over all I

2poly
(|

Q ′ |

,d ,

A

σ

|

I

I

be a d-regular
.

∈ I

(|

I | ×

.
|))

4.4 Upper Bounds for Tree Validity
We now present our first application of the UMC and IQ-type technology developed over the last
few sections. It concerns the problem of tree validity introduced in Section 2.3, over the signatures

,

S

bin
Ch1,Ch2, and
S

unranked
Child
A tree I over one of these relational signatures can be associated with the bag and output element
in a canonical way, up to sibling ordering, as follows:

structure of a monadic expansion tree T

bin
Ch1,Ch2,Child.
S

T

form Child

(1) For each vertex v in I , there is a node nv whose output element is v.
I
nv )
(2) For each node nv ∈
, bag
(
)
(
v, x
v, x
v, x
, FirstChild
)
(
(
)
(
v1, v2)
I
(3) Two nodes nv1 and nv2 of T
are in parent-child relation iff Child
(
(
)
v1, v2)
holds in I .
or SecondChild
(
I
(4) Children of a given node nv ∈
are ordered in an arbitrary manner.
T
(

.
)

)

contains all unary facts about v, as well as every fact of the
, SecondChild

, FirstChild

v1, v2)
(

,

It is easy to verify that
is a monadic expansion tree. It has at most 4 facts per node for
bin
Ch1,Ch2 (the root bag contains one FirstChild, one SecondChild, one Label, and one Root fact), 6
S
where r is the rank of the tree.
for

bin
Ch1,Ch2,Child (same plus two Child facts), and r + 2 for
S

unranked
Child

I, T
(

I
(

S

))

I
(

)

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:26

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

We will show that the collection of such trees is an instance class that satisfies the UMC:

Theorem 4.19. Let σ be any of
I
(

unranked
Child
S
, where I is a tree over σ , satisfies the

bin
Ch1,Ch2,

I, T
(

pansion trees

S

S

))

,

-UMC.

∀

bin
Ch1,Ch2,Child. The collection of monadic ex-

Towards proving the theorem, first note the following:

Lemma 4.20. Let σ be any of

bin
bin
Ch1,Ch2,Child. Let q be a connected conjunctive
Ch1,Ch2,
S
query over σ , and I a tree over σ . Suppose h1 and h2 are two homomorphisms from q to I , and x and y
= r for some vertex r of I , and that all variables of q are
are variables of q. Assume h1(
x
= r then h2(
y
y
mapped by h1 and h2 to the subtree of I rooted at r . If h1(

S
= h2(
x

unranked
Child

= r .

S

)

)

)

)

,

Proof. If y = x, this is trivial.
Since q is connected and y (cid:44) x, there is a non-empty path of binary atoms A1 . . . An and a
sequence of variables x = x0, . . . xn = y with, for all 1 ⩽ i ⩽ n, xi
1 and xi distinct variables
co-occurring in Ai . Since the Ai ’s are binary, they have to be FirstChild, SecondChild, or Child
atoms; let us denote Ri the corresponding relation name. For 0 ⩽ i ⩽ n, let di be the depth of h1(
xi )
in the subtree of I rooted at r . We know that d0 = 0, and, for all 1 ⩽ i ⩽ n, we can compute di
from di

1:
, di = di
if Ai = Ri (
xi
−
xi, xi
, di = di
if Ai = Ri (
in the subtree of I rooted at r is computed in exactly the same way: d ′0 = 0
But the depth d ′i of h2(
and the same recurrence formulas as above hold. This means in particular that d ′n = dn = 0. Since r
y
is the only node at depth 0 in the subtree of I rooted at r , h2(
□

1, xi )
1)
−
xi )

1 + 1;
−
1.
1 −
−

= r .

•
•

−

−

)

Note that this lemma does not hold over

rem 4.19:

bin
Ch1,Ch2,Child,Child? . We are now ready to prove Theo-
S

, with output element the corresponding tree vertex vn. Let
)

Proof of Theorem 4.19. Let Q ′ be an arbitrary conjunctive query, I an instance of σ , and n a
I
be two
node of T
(
, with respective relative homomorphisms h1 and h2. We assume
n
type elements of Q ′ in typeQ ′(
)
there exists an atom A in both q1 and q2 referencing a variable in both X1 and X2. We need to show
that X1 = X2 and q1 = q2.

X2, q2)
(

X1, q1)
(

and

We first show q1 = q2. Let X be the intersection of X1 and X2. Let q

and q2 (i.e., the atoms in common), and q′ the maximal connected component of q
that contains A.

∩

∩

be the intersection of q1
relative to X

By way of contradiction, assume q1 (cid:44) q2. Without loss of generality, since q1 and q2 play the same
role, we can assume that there exists an atom A′ of q1 that is not in q2. Since q1 is connected relative
to X1, we know there is a path consisting of variables not in X1 such that consecutive variables
xi , xi+1 co-occur in an atom Ai of q1, with the path starting at a variable of A and terminating at a
variable of A′. We now consider j to be the least index such that the atom Aj+1 is not in q2, and such
that all variables x1, . . . , xj are not in X2. Thus, Aj , which contains variable xj+1 is in both q1 and q2,
and it is also in q′ since it is connected to A relative to X1 ∩
. Note that since xj+1 (cid:60) X1,
(cid:44) vn, by the definition of a relative homomorphism.
h1(
X2 (which
X2. Let x be any variable in X1 ∩
= vn. Note that both h1
= h2(
is non-empty, since q1 and q2 share a non-empty atom). Thus h1(
x
x
)
and h2 restrict to homomorphisms of the connected query q′, and these restrictions contain x and
= vn which is a
= h1(
xj+1. Applying Lemma 4.20 above to the query q′, we derive that h1(
x
is not vn. Hence
contradiction of the fact noted immediately above. Thus we can assume h2(

xj+1)
Suppose first that h2(

= vn, which means xj+1 ∈

xj+1)
xj+1)

xj+1)

X2 in q

∩

)

)

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:27

xj+1 is not in X2, by definition of relative homomorphism. But then, by closedness of the connected
component q2, Aj+1 should be in q2, which leads to a contradiction.

Thus we completed the argument that q1 is equal to q2.
A similar argument shows that X1 must be equal to X2, completing the uniqueness argument. As
y
X2. Let y be a variable of X1. Then h1(
above, let x be a variable of X1 ∩
. Moreover,
X1, q1)
is a type element satisfied in n, h1 must map into the
x
h2(
(
subinstance rooted at n. Similarly, h2 must map into the subinstance rooted at n. By Lemma 4.20
above, applied to q1 = q2 we infer h2(
= vn. Thus y is in X1. With the
= h2(
y
y
, and thus h2(
x
)
X1. Thus X1 is equal to X2.
same reasoning, we can demonstrate that X2 ⊆

= vn. Since h1 witnesses that

= vn = h1(
x

)

)

)

)

)

□

From the theorem above and Corollary 4.18, we get the following new bound, which in particular

(for

unranked
Child

S

) answers a question left open from [8].

Corollary 4.21. Validity of a UCQ over

automaton is in EXPTIME.

unranked
Child

S

,

bin
Ch1,Ch2, or

S

bin
Ch1,Ch2,Child with respect to a tree

S

Proof. Let us first consider the ranked case, i.e., σ =

d = 4 in the former case, d = 6 in the latter.

bin
Ch1,Ch2 or σ =
S

bin
Ch1,Ch2,Child. We pose
S

a binary tree automaton over σ .

Let Q be a UCQ over σ , and A =
)
From A, we build a binary tree automaton A′ =

Ω, ∆0, ∆, F

(

•

•

(

)

) ∈

Ω, ∆′0, ∆′, F

over the alphabet Γ

as follows:
be the output-isomorphism class of a bag with output
to ∆′0;

α, q
d, σ
∆0, let c
B
For every
(
∈
(
)
v
element v and facts Leaf
v
and Labelα (
(
)
)
q1, q2, α, q
d, σ
∆0, let C
B
For every
(
)
(
⊆
v, v1)
output element v, facts FirstChild
, FirstChild
(
v, v2)
(if σ =
v
Ch1,Ch2,Child), Labelα (
Child
S
(
are exactly two elements in C. For either of these elements c
q2, q1, ˆc, q
(

. We then add
be the output-isomorphism classes of bags with
bin
v, v1)
Ch1,Ch2,Child),
, Child
S
(
v
. There
, and a possible additional fact Root
(
)
q1, q2, ˆc, q
and
(

ˆc, q
(
v, v2)
(

C, we add

d, σ
(

(if σ =

to ∆′.

) ∈

bin

∈

)

)

)

)

)

for I a tree accepted by A. Additionally, A′ can be

I
By construction, A′ recognizes the set Coded (
constructed in time linear in A.

)

| ×

2poly
(|

Q ′ |))

bin
Ch1,Ch2 and
S

bin
Ch1,Ch2,Child can be done in time O
S

We now apply Corollary 4.18 to σ , d, Q ′, and the class of trees over σ whose monadic expansion
tree representation is recognized by A′, which has the Q ′-UMC by Theorem 4.19. We obtain that
=
checking if Q ′ holds over
O

(|
since d and σ are fixed. In other words, it is in EXPTIME.

A
(|
Finally we deal with the unranked case. We make use of the following easily-verified fact about
an automaton A over unranked trees: given a tree t that is accepted by A, there is a subtree t ′
(obtained by removing subtrees in t) which is a ranked tree of rank at most polynomial in A, such
that t ′ is also accepted by A. Applying this to a counterexample t to validity, we see that t is still a
counterexample to validity, since trimming preserves the negation of Q. Thus we have reduced to
the ranked case.
□

A′| ×

2poly
(|

Q ′ |

|))

,d ,

σ

|

Corollary 4.21 complements the theorem of Björklund et al. [9], which shows that the problem

of validity with respect to an NTA is hard for EXPTIME.

In the case of validity over all trees for

S
Proposition 4.22. Validity of a UCQ over

unranked
Child

, we can do better:

unranked
Child

S

with respect to all trees is in PSPACE.

Proof. Observe that a counterexample to validity for

can always be taken to be a single
path with no branching, by keeping one arbitrary branch from the root to a leaf: indeed, removing

S

unranked
Child

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:28

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

other branches amount to simply removing facts from the relational instance and therefore cannot
make a CQ true if it did not hold on the original instance (we cannot, on the other hand, shorten a
branch, as this amounts to adding new Leaf facts).

We can further assume each CQ in the UCQ is connected, since we can guess a connected
component of each CQ. A connected CQ specifies an interval of polynomial size in the path. Thus
we need a nondeterministic PSPACE algorithm which determines whether there is a path in which
a set S of k-sized intervals are omitted. We can do this by tracking the last k elements observed. □

4.5 Upper bounds for restricted MDL queries
We will apply the UMC to get another exponential decrease in the complexity. This time we deal
with general structures, but restrict the queries.

A monadic datalog query is globally extensionally restricted (GEMDL) if every extensional
predicate appears in only one rule, and occurs only once in that rule. An MDL query is almost
globally extensionally restricted (AGEMDL) if the goal predicate never occurs in the body of a rule,
and every extensional predicate has only one occurrence in a rule other than a rule for the goal
predicate.

Informally, AGEMDL queries allow UCQs built over intensional predicates, where extensional

predicates are partitioned into classes where each rule uses predicates in a particular class.

GEMDL and AGEMDL are simple syntactic restrictions of MDL whose properties will allow us
to apply the UMC. The main application of these restrictions are the ones that come from limited
access querying, in the specific case where access methods have at most one output position. Indeed,
consider again the rules in Equation (2) in Section 2.4, an encoding as an MDL program of the
unary predicate AccValues representing values that can be discovered via the access restrictions.
When there is at most one output position for every access method, there is only one rule for every
extensional predicate R, of the form:
xjk ) ←
R
AccValues
(
) ∧
These rules satisfy the GEMDL restriction.

xj1) ∧ · · · ∧
AccValues
(

xjm )
AccValues
(

x
(

Furthermore, evaluation of UCQ Q over accessible data can be done using a single additional
predicate (see Equation (1) in Section 2.4), with rules for every conjunct of Q, also enforcing all
variables are accessible.

Combining the GEMDL rules defining AccValues and the rules defining the goal predicate thus
results in an AGEMDL query. It follows that the question of containment of unions of conjunctive
queries under limited access patterns (recall Definition 2.12), where every access has a single output
position, can be expressed as the containment of an AGEMDL query in a UCQ. Formally:

Proposition 4.23. There is a polynomial-time reduction from containment of UCQs under limited
access patterns, where every access has at most one output position, to containment of AGEMDL in
UCQ.

We will get an EXPTIME bound for AGEMDL.
The key feature common to containment of GEMDL queries and the limited access containment
problem is that counterexamples have a stronger kind of tree-like instance, compared to simply
monadic expansion trees. A diversified tree-like instance is a monadic expansion tree in which: (i) for
each node n which is not the root, for each relation R, there exists at most one fact in bag
having
the relation name R; (ii) there is no value v that appears at the same position in two distinct facts
with the same relation name.

n
(

)

The first condition is a local one, saying roughly that we do not have self-joins within a bag
while the second one is global, saying self-joins across bags must not have the joined variable in
the same position. A figure showing a diversified tree-like instance is given in Fig. 1. The large

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:29

ellipses represent bags, with different relations represented by different shapes in a bag. The dark
circle represents a common value shared across and within bags.

We now have the following refinement of Proposition 2.6. Let Q be a union of conjunctive

queries.

Proposition 4.24. If an AGEMDL query Q is not contained in a UCQ Q ′, then there is a diversified
Q ′. Furthermore, the size of the bags of I can be taken to

tree-like instance I such that I satisfies Q
be polynomial in the size of Q.

∧ ¬

Proof. We reuse the construction presented in the proof of Proposition 2.6. We just have to

show the additional properties of a diversified tree-like instance.

Recall from Proposition 2.6 that our tree-like instance was derived from a graph G

nodes consisted of pairs, a head atom and a rule. Furthermore:

Q
(

, whose
)

G

has no two nodes n and n′ with the same head atom α
There exists an isomorphism ψ from the facts in the rules of G

Q
(

(†)

)

, where x is a variable.
x
)
(
to elements of I . For each
Q
)
(
such that y is the variable appearing in the

atom α appearing in a rule within a node m of G
head atom of m, ψ

Q
(
having ψ

)

)

)

)

)

I
(

I
(

x
(

y
(

α
(

and R

¯a1)
(

(2) Let R

)
(†)
)

as its output element.

appears in the node of T

are in a parent-child relationship. We assume that R

be two facts of I in two distinct non-root nodes n and n′ within T

I
(
, for each intensional predicate P and for each
(1) Let R be a relation name. Due to Property
having P
Q
variable x, there is at most one node of G
as head atom. Due to the AGEMDL
(
restriction, a rule associated with a non-root node has at most one atom in the body with
relation R. Thus, by construction of T
, the bag associated with each node has at most one
atom with relation R.
¯a2)
(

I
,
)
(
which share the value v. By definition of a tree-like instance, and by the fact proved above,
we must have that n′ and n of T
¯a1)
(
is in n. Let v and v ′ denote the output elements of n and n′ respectively,
is in n′ and R
¯a2)
(
and let m and m′ be the corresponding nodes of G
. We prove by contradiction that v does
Q
)
(
. We denote by x the variable mapped to v
¯a2)
not appear in the same position of R
(
by ψ and by x ′ the variable mapped to v ′ by ψ . Let ρ be the (necessarily unique) rule of Q
having an atom with the relation name R. There exist atoms αm in the body of the rule of m
¯a1)
and αm′ in the body of the rule associated to m′ such that ψ
.
(
Because v is the output element of n, by the second property of ψ listed above, x must appear
in the head atom of m, and similarly x ′ must appear in the head atom of m′. Both m and m′
have relation R in the associated rule, and thus by the AGEMDL property, the rule must be
= v,
¯a1)
the same, namely ρ. Because v appears in R
(
x appears in the same position in the atoms αm and αm′. Thus x ′ = x, and therefore m and
m′ have the same head atoms, as well as the same rules, hence they must be the same node
of G

. This contradicts the assumption that n and n′ were distinct.
)

at the same position and ψ

α ′m)
(

αm)
(

¯a1)
(

¯a2)
(

¯a2)
(

and R

and R

and ψ

Q
(

= R

= R

x
(

)

)

□

The technique generalizes to the containment problems arising from general access methods,

not only ones with a single output:

Proposition 4.25. If a UCQ Q is not contained in a UCQ Q ′ under access restrictions ACS then

there is a diversified tree-like instance I such that I satisfies Q

Q ′.

∧ ¬

Proof. The rules that come from limited access patterns with an arbitrary number of output
positions satisfy the following weakening of the AGEMDL condition: for any two rules that share
an extensional predicate in the body, the bodies are identical. One can easily see that the argument

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:30

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

Fig. 1. Diversified tree-like instance

in the proof of Proposition 4.24 applies to show that these rules also admit diversified tree-like
instances.
□

The following links diversified instances to the IQ-type machinery developed previously:

Theorem 4.26. The class of diversified tree-like instances satisfies the

-UMC.

∀

Proof. We need to show that the class of diversified tree-like instances satisfies the Q ′-UMC for
any conjunctive query Q ′. Let Q ′ be such a query, I a diversified tree-like instance, and n a node
of T

I
(

.
)

We will show the following:

) Let X be a subset of variables of Q ′ and q a subquery of Q ′. Take any x (cid:60) X of q and
(
‡
X, q
atom α of Q ′ but not of q that contains x, any relative homomorphism h from
)
(
to the subinstance rooted at n. Then there is at most one way of extending h into a
homomorphism h∗ from q∗ = q
α to the subinstance rooted at n, and of extending
X into a superset X ∗, such that h∗ is a relative homomorphism from
to the
subinstance rooted at n.

X ∗, q∗)
(

∧

We now prove

. Let β be an atom of q
that contains x; β exists since x is a variable of q. Let n′ be the node of the subinstance rooted at n
whose bag contains h

. We let X , q, x, α, h to be as in the statement of

(‡)

(‡)

β

. We distinguish two cases:
)

(

(1) h

)

x
α
is the output element v of n′. Since x (cid:60) X , n′ (cid:44) n. Since α contains x, it is clear h∗(
(
)
can only be mapped to the bag of n′ or to that of its parent n′′. It cannot be mapped to both,
as this would imply that there are two distinct facts with same relation name as α that both
contain v in the same position (the position of x in α), which is forbidden in diversified
tree-like instances. Within the only possible bag, there cannot be more than one possible
way to map α, as otherwise there would be two facts on the same relation within the same
bag, which is also forbidden in diversified tree-like instances.

(2) h

)

is not the output element of n′. Then h

x
x
must be the output element of one of the
(
(
children n′′ of n′. We then proceed exactly as in the previous case, the roles of n′ and n′′
being exchanged.

)

This completes the argument for the uniqueness of h∗. We turn to the second statement of
, concerning uniqueness of X ∗. Here we observe that if such an h∗ can be constructed, X ∗ is

(‡)

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:31

necessarily the set of variables mapped by h∗ to the output element of n, by the definition of relative
.
homomorphism. This concludes the proof of
(‡)

)

)

)

)

⋆
)
(

β

β

) ∈

Let

bag

(cid:44) h1(

= h2(
α

X2, q2)
(

in the definition of the unique

can be used to prove that the property

. Now, since I is a diversified tree-like instance, there can only be one fact in bag

be two type elements of Q ′ satisfied by n that share an atom α referencing
X1, q1)
to the
(
to the subinstance rooted
n
; similarly,
(
n
)
(
. In particular, none of the variables of α except

We now explain how
(‡)
mapping condition holds.
X1, q1)
X2, q2)
and
(
(
a variable x in X1 ∩
X2. By definition, there exist a relative homomorphism h1 from
subinstance rooted at n and a relative homomorphism h2 from
at n. Since α references a variable mapped by h1 to the output element of n, h1(
α
α
h2(
n
bag
) ∈
(
having same relation name as α, so h1(
α
)
X2 can be mapped to the output element by h1 or h2.
those in X1 ∩
Now, assume by way of contradiction that q1 (cid:44) q2 or X1 (cid:44) X2. Then, without loss of generality
since q1 and q2 play symmetrical roles, we can assume there exists an atom β in q1 such that either β
. Since q1 is connected relative to X1, there is a path x1 . . . xk of variables
is not in q2 or h2(
not in X1 from a variable x1 of α to a variable xk of β in the graph of co-occurrences of variables in
atoms of q1. Let γ1 = α, γ2 . . . γk+1 = β be the corresponding atoms on this path and let γi+1 with
1 ⩽ i ⩽ k be the first atom on this path such that either γi+1 is not in q2 or h2(
γi+1)
.
Let X be the subset of variables of q = γ1 ∧ · · · ∧
γi that are mapped to the output element of n
X2. Since q2 is closed relative to X2 and xi (cid:60) X2, it means
both by h1 and by h2, i.e., that are in X1 ∩
that γi+1, which also contains x1, is in q2. We thus must have h2(
(cid:44) h1(
(‡)
to X , q, xi , γi+1: indeed, xi (cid:60) X since xi (cid:60) X1. But then, the restriction h of h1 to the variables of q
(which is also the restriction of h2 to the variables of q) is a relative homomorphism from
to
the subinstance rooted at n. Therefore,
tells us that there is at most one way to extend h and X
into h∗ from q∗ = q
γi+1 to the subinstance rooted at n and of extending X into a superset X ∗
X ∗, q∗)
such that h∗ is a relative homomorphism from
to the subinstance rooted at n. But the
(
restriction of h1 to the variables of q∗, and the restriction of h2 to the variables of q∗ are two relative
homomorphisms (for some sets X ′1 ⊆
X2) that also extend h in the same sense. They must
γi+1)
thus coincide and h1(
□

X1, X ′2 ⊆
, which is a contradiction.

. We then apply

(cid:44) h1(

= h2(

γi+1)

γi+1)

γi+1)

γi+1)

X, q
(

(‡)

∧

)

)

Note that an atom α determines a unique set of variables X , so the key is that, in this restricted

setting, we have only one way to select which variables map to the output element of the root.

The last thing we need to apply our UMC machinery to diversified instances is to note that this

class of tree-like instances can be captured with an exponential-sized automaton:

Lemma 4.27. The set of diversified tree-like instances satisfying a UCQ Q is d-regular for some d.
Further there is a ranked deterministic tree automaton AQ recognizing the codes of the diversified tree-
like instances satisfying Q which has size exponential in Q and can be constructed in time exponential
in Q.

Proof. First, we argue that the set of monadic expansion trees satisfying a UCQ Q is easily
recognizable by an exponential sized automaton. The properties of a monadic expansion tree are
easily enforced by the transition function of the automaton. The property of satisfying a UCQ is
checked by having a state for each subquery Q0 of Q supplemented with a homomorphism from a
subset of the variables in Q0 to the current node. Updating the state can be done with an exponential
sized transition function, and the automaton accepts if the full query Q is covered. The property of
being diversified is very simple to check, and the intersection of these two automata can be formed
in polynomial time.
□

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:32

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

From this lemma, Theorem 4.26, and Proposition 4.17, the number of IQ-types of the set of
diversified instances satisfying Q is bounded by an exponential function. Moreover, from Corollary
4.18 we get complexity bounds for AGEMDL and limited access containment:

Corollary 4.28. The containment of an AGEMDL query in a UCQ can be decided in EXPTIME.
The containment of two UCQs under limited access constraints can be decided in EXPTIME.

5 LOWER BOUNDS
We will now prove our lower bound results. Again, there is a tight connection between MDL
containment and tree validity problems. We will begin by showing lower bounds for the tree
validity problem, and then use these to get results for MDL and limited access containment.

5.1 Lower bounds for tree validity problems
We first prove lower bounds for tree validity problems matching the upper bounds of Section 4.4.
For generality, we show that the lower bounds hold for BDTDs (recall that they are more restrictive
than BNTAs) by first proving them for BNTAs and then applying the following lemma, which shows
that one can reduce NTA problems to DTD problems, by making runs explicit. This result was
stated by Björklund et al. (Lemma 18 of [10]) for unranked trees, who mention that it is implicit in
Takahashi’s work [32]. As in [10], we define the annotated tree language of a BNTA A with states Ω
over binary trees labeled with Λ as the set of trees in L
A
that are annotated by their accepting
(
)
runs. More formally, the annotated tree language of A is the set of trees t over Λ
Ω such that
t
is an accepting run of A on ΠΛ(
t
ΠΛ(

t
while ΠΩ(

A
)
(

) ∈

.
)

×

L

)

Lemma 5.1. Let A be a BNTA over binary trees with a single final state, and such that all trees
accepted by A have a common root label. Then there exists a BDTD DA, constructible in polynomial
time from A, that recognizes the annotated binary tree language of A.

Proof. Since our notion of DTDs is slightly different from the classical one (in particular, this
makes the construction cubic, not quadratic as in [10]), and since the statement of the result in [10]
misses the technical condition of imposing a single possible root label, we give the construction
explicitly.

Let A be a BNTA with alphabet Λ, states Ω, final state qf , input states ∆0 ⊆

Ω, and transition
Ω. Let ar be the common root label of all trees accepted by A. We construct
Ω as follows (note that this construction is cubic in
over the alphabet Λ

Λ

×

⊆

×

Λ
×
×
d, l0)
(

;
Λ and q

Ω2
relation ∆
the BDTD DA =
the size of A):
ar, qf )
l0 =
(
For α
∈
α, q
(

•
•

d

Ω,
∈
,
β1, q1)

)

=

β2, q2)) |
ε
} ∪ {
t
It is clear that a binary tree t is accepted by DA if and only if ΠΩ(
t
ΠΛ(

q1, q2, α, q
(

β1, β2 ∈

) ∈

{((

Λ,

∆

(

)

)

.

| (

) ∈

α, q

∆0}
is an accepting run of A on
□

Thus, as in [10], if we show that the validity problem is hard for BNTAs (even when all trees

have a common root label), we can deduce it is also hard for BDTDs using this reduction:

Corollary 5.2. Let Q be a UCQ on

bin
Ch1,Ch2,Child,Child? and A a BNTAs
S
S
such that all trees accepted by A have a common root label. One can construct in polynomial time a
UCQ Q ′ on the same signature and a BDTD D ′A such that Q ′ is valid over D ′A if and only if Q is valid
over A. Furthermore, if Q is a CQ, so is Q ′.

bin
Ch1,Ch2,Child, or

bin
Ch1,Ch2,

S

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:33

Proof. We would like to apply Lemma 5.1 to get the DTD and then rewrite the query appropri-
ately. We have two difficulties: first, we need to deal with the case where A does not have a single
final state, since Lemma a 5.1 requires this. Second even in the case where we have a single final
state, and hence could apply Lemma 5.1 and take D ′A (cid:66) DA, we have a difficulty translating from a
CQ to another CQ, since we would need disjunction to express the different possible labels of the
annotated tree that correspond to one label of the regular tree.
We take care of the final state problem first. We modify A =
q1, q2, α, qf ) | (
{(

, ∆0, ∆
qf }
∪
∪{
∆′, qf )
. A′ has a
F
}
∈
single final state, is constructible in time linear in A, and Q is valid over A′ if and only if Q is valid
over A.

where qf is a fresh state and ∆′ (cid:66)

to A′ (cid:66)
)
∆, α

Ω, ∆0, ∆, F

q1, q2, α, q

Ω
(
Λ, q

) ∈

∈

(

over

over

To address the second problem, we make the different annotations structurally adjacent to
the labels of the regular tree, rather than being extended labels. This technique is similar to that
used in the proof of Theorem 19 of [10] in the case of unranked trees. We construct the BDTD
DA =
Λ

d,
ar, qf ))
(
(
qf })
Ω
from A′ using Lemma 5.1, then we construct in polynomial time a modified
∪ {
× (
ar, qf, 0
d ′,
BDTD D ′A (cid:66)
from DA as follows. For every
(
(
Λ, q
qf }
Ω
α
∈
∪ {
α, q, 0
d ′(
(cid:66)
)
α, q, 1
d ′(
(cid:66)
)

α
d ′(
(cid:66)
)
d ′(⊥)
(cid:66)


α, q, 1
α,
{(
(
α1, q1, 0
{((
,
{(⊥
.
ε
}
{

))}
α2, q2, 0
,
(
)

α2, q2)) ∈
(

qf }) × {

u FirstChild

,
α1, q1)

ε
)} ∪ {

α, q
(

α, q
(

∪ {⊥}

)) | ((

}) ∪

⊥)}

0, 1

∪ {

× (

(cid:66)

)}

Ω

))

Λ

Λ

∈

∈

d

d

ε

(

:

|

x, t
(

)∧

t
∃

∃

•

Label

. We construct Q ′ as follows.
)

Furthermore, we rewrite Q as Q ′ by doing substitutions of atoms. Let S

t, u
FirstChild
(
) ∧
x, y
R
, for R
(
)
z, y
R
x
S
(
(
) ∧
Child?
x, y
(
)
x
is replaced with
Leaf
)
(
x
Labelα (

u
⊥(
FirstChild, SecondChild, Child
∈ {
y
S
(

}
Child?
z, y
(
z
Leaf
(
x, z
z FirstChild
(

z Child?
) ∧
∃
x, z
z SecondChild
(

;
) ∧
)
is replaced with

Λ is replaced with

) ∧
) ∧

x, z
(

for α

•
•
•

S
x
) ∧
(
) ∧
x
S
;
(
)
z
Labelα (

is replaced with

x
(

) ∧

∃

∃

∈

)

)

)

.

S

y
(

;
)

The resulting Q ′ is a CQ if Q is a CQ, the only atoms added reference relations existing in the current
signature, and the construction is polynomial-time. For a UCQ Q =
i Q ′i
where Q ′i is the CQ obtained by applying the substitutions above to Qi .
(cid:212)

We argue that Q ′ is valid over D ′A if and only if Q is valid over A′, i.e., if and only if Q is valid

i Qi , we write Q ′ =

(cid:212)

z SecondChild

∃

x, z
(

) ∧

over A.

L

Assume Q ′ is valid over D ′A and let T
Ω
× (

. There is therefore an accepting run of A on T ;
A′)
(
∈
corresponding to this run. We know that T ′ is
let T ′ be the annotated tree over Λ
qf })
∪ {
α, q
accepted by DA. From T ′ we construct T ′′ by replacing every subtree t with root labeled with
)
(
α, q, 0
, a first child labeled with q with no children, and
by a subtree formed of a root labeled with
(
)
α, q, 1
with the non-root part of t underneath, similarly transformed.
a second child labeled with
(
= Q ′i for
By construction, T ′′ ∈
and we know therefore that T ′′ |
D ′A)
(
some Q ′i . Let ν be a valuation of the variables of Q ′i on T ′′ that witnesses this. Observe that ν maps
variables x of Qi present in an atom of Qi to nodes n of T ′′ with label of the form

= Q ′, which means T ′′ |
α, q, 0
(
, n is the root of T ′′, which has a label

:
)
ar, qf, 0
.
)
(
, then the first child of n in T ′′ has α as

If the variable appears in Qi in an atom Root
x
If the variable appears in Qi in an atom Labelα (
α, q, 0
for some q as label.
label, which is only possible if n has
)
(
y, x
If the variable is of the form R
or R
x
or R
for
(
(
FirstChild, SecondChild, Child, Child?, Leaf
R

x, y
(

•
•

•

x
(

L

)

)

)

)

)

)

∈ {

}

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:34

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

then S
is only possible if n has

x
(

)

holds, which means that n has a first child whose first child is labeled with

, which

⊥

α, q, 0
(

)

for some α, q as label.

)

)

x
(

labeled by

α, q, 0
)
(

α, q
We consider the valuation ν ′ that maps variables x of Qi to the nodes of T ′ labeled by
that
(
were transformed when constructing T ′′ to the node ν
. Let now ν ′′ be the
valuation of variables of Qi to nodes of T corresponding to ν ′ on T ′ (remember that T ′ is just an
= Qi , i.e., T
annotated version of T ). Then ν is a witness that T
|
D ′A)
L
. Let T ′ be the tree obtained from T by
Conversely, assume Q is valid over A′ and let T
(
∈
α, q, 0
retaining only the nodes whose label is of the form
, attaching them to the closest retained
)
(
ancestor, and dropping the 0 in the label. This is a tree in the language of DA, i.e., an annotated tree
= Q,
of A′. We can thus project the states out and obtain a tree T ′′ ∈
= Qi for some i. Let ν be the valuation witnessing this, and let ν ′ the valuation from
meaning T ′′ |
corresponding to these nodes of T ′′ (via the
the variables of Qi to nodes of T of the form
α, q, 1
annotation given by T ′). Because T
D ′A)
)
(
(
nodes, we can extend ν ′ into a valuation of the variables of Q ′i that did not appear in Qi , to obtain a
witness that T
□

α, q, 0
(
and D ′A fully constrains the positions of α and

, for which we know T ′′ |

= Q.
|

A′)
(

∈

L

L

)

= Q ′i and thus T
|

= Q ′.
|

We can now prove the following result, which closely tracks Theorem 6 of [8].

Theorem 5.3. Given a CQ Q on

whether Q is valid over A.

bin
Ch1,Ch2,Child,Child? and a BDTD A, it is 2EXPTIME-hard to decide
S

Proof. First, thanks to Corollary 5.2, we prove the result for a BNTA instead of a BDTD.
We adapt the proof of Theorem 6 of [8, 10], which states that validity with respect to an NTA of
a CQ with child and descendant predicates over unranked trees is 2EXPTIME-hard. We adapt it by
moving from unranked trees to binary trees (with the changes that it implies in the definition of an
NTA), writing the output of the reduction given in [8, 10] using Child? instead of the descendant
predicate.

We give a self-contained presentation keeping the notation from [8, 10] as much as possible,

with notable departures highlighted in bold font throughout the proof.

An alternating Turing machine (ATM) is a tuple M =

As in [8], we reduce from the termination of an alternating EXPSPACE Turing Machine M, a
2EXPTIME-hard problem [16]. The next few paragraphs are taken in part from [8], with some
minor adjustments, as we need to introduce the same concepts.
Ω, Γ, ∆, q0)
qr}
is a finite set of states partitioned into universal states from Ω
, an
accepting state qa, and a rejecting state qr. The (finite) tape alphabet is Γ and includes a special
blank character ‘#’. The initial state of M is q0 ∈
Ω. The transition relation ∆ is a subset of
L, R, S
Ω
. The letters L, R, and S denote the directions left, right, and stay,
(
according to which the tape head is moved.

where Ω = Ω
qa}⊎{
, existential states from Ω

) × (

∃⊎{

× {

∀⊎

})

Ω

Ω

×

×

Γ

Γ

(

∃

∀

A configuration of an ATM M =

(
Z is the tape head position, and q

Ω, Γ, ∆, q0)

is finite (only finitely many symbols on the tape are non-blank). A configuration

, universal if q

Ω

∀

∈

, and is ‘#’ otherwise. A successor configuration

Γ∗ is the configuration

∈

)

∈

→

where τ : Z

τ , k, q
(

is a triple

Γ is the con-
Q is the current state. We assume that
τ , k, q
)
(
, accepting if q = qa, rejecting if q = qr. The initial
is the i-th character
where τ
i
(
)
τ ′, k ′, q′)
of a configuration
(
and one of the following three properties

τ , 0, q0)
(

= τ

Z

(

Γ

∈

})

\ {

figuration tape, k
1
τ −
#
is existential if q
configuration of M on a word w
of w if 1 ⩽ i ⩽
τ , k, q
(
holds:

w
|

Ω

∈

)

∃

|

is a configuration such that τ ′
Z
|

k

}

\{

k

|

\{

}

−

k ′ = k
1 and
k ′ = k
and
k ′ = k + 1 and

q, τ
(
q, τ
(
q, τ
(

k
(
k
(
k
(

, q′, τ ′(
k
)
, q′, τ ′(
k
)
, q′, τ ′(
k
)

, L
)
, S
)
, R
)

) ∈
) ∈
) ∈

∆;
∆;
∆.

•
•
•

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:35

An accepting computation tree for an ATM M on a word w

Γ∗ is a finite unranked tree labeled by
non-rejecting configurations of M such that: (1) if node v is labeled by an existential configuration C,
then v has one child, labeled by one of the successor configurations of C; (2) if v is labeled by a
universal configuration C, then v has one child for each successor configuration of C; (3) the root is
labeled by the initial configuration on w; and (4) all leaves are labeled by accepting configurations
(and accepting configurations only appear as leaves). An ATM M accepts a word w
Γ∗ if there
exists an accepting computation tree for M on w.

∈

∈

A
)
(

The overall idea of the proof of [8], that we closely adapt, is as follows. Let M be an ATM and
w a word of Γ∗ of length n. First, for technical reasons, we construct, in polynomial time an ATM
Mw which accepts the empty word if and only if M accepts w; this construction is straightforward.
Second, from Mw , we construct a BNTA A that checks most important properties of (suitably
encoded) computation trees of Mw , except their consistency w.r.t. the transition relation of Mw .
The consistency is tested by a query Q that we construct. To be precise, Q is satisfied by a tree T
in L
if and only if the transition relation of Mw is not respected by T . This means that Q is valid
w.r.t. A iff there does not exist a consistent, accepting computation tree for Mw . Since 2EXPTIME
bin
is closed under complementation, we conclude that validity of CQs on
Ch1,Ch2,Child,Child? with
S
respect to BNTAs (and thus to BDTDs) is 2EXPTIME-hard. We emphasize that the encoding of the
ATM would be straightforward if our query Q was allowed to be in non-recursive datalog, and
fairly simple even if Q was a UCQ. It is the fact that we want to show hardness for containment in
the case where Q is a CQ which motivates the subtleties in the encoding of [8], and we will inherit
these in the constructions below.

Without loss of generality, we assume that universal configurations of Mw always have
exactly two successor configurations. If they have less, we can just add transition(s) for
every universal state and tape symbol to an accepting state; if they have more, we can
introduce intermediary states to encode a conjunction as a tree of binary conjunctions,
with no change to tape symbol written or tape head move.

We do not give the nondeterministic tree automaton explicitly, but trees in its language will have
the shape represented by Fig. 2.2 The bold nodes are the nodes added to the trees of Fig. 3 and 4
of [10]. The labels of dashed edges indicate the number of nodes between a node and its ancestor.
This BNTA encodes trees that represent accepting computation trees of Mw .

Each configuration in an accepting computation is encoded by a subtree rooted by a node labeled
Conf (it was called CT in [8, 10]); the Conf-node for the initial configuration appears as the unique
child of a chain of ℓ nodes with dummy labels from the root for some integer ℓ that we will define
further (this chain of ℓ nodes is only needed for technical reasons). A Conf-node has two children
labeled r and NextConf. The subtree rooted at the r -node represents the configuration tape and
the subtree rooted by the NextConf-node has zero, one, or two Conf-children that we will
regard as zero, one, or two successor configurations depending upon whether the current
state is accepting, existential, or universal. That is, the links between r , Conf, and NextConf
nodes represent the “macro structure” of a run, the links between configurations.

A configuration tape can be viewed a complete binary tree of depth n, with leaves of the tree
containing information about 2n cells. A path in the tree encodes the binary address of a cell, with
the pattern of left and right children to the leaf encoding the address, and the label of the leaf
encoding the tape content. This complete binary tree, that we will refer to as the abstract tape tree, is
itself encoded for querying purposes underneath a configuration node r . We call this encoding the
physical tape tree. For 1 ⩽ i ⩽ n, a node in the physical tape tree with label s represents a node at

2Since our definition of BNTA requires a binary tree to be full, we need to add dummy nodes where needed,
with labels distinct from real nodes. This technicality has no impact, and we will ignore these nodes.

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:36

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

−

depth i in the abstract tape tree. Each such node representing a node at depth i, with 1 ⩽ i ⩽ n
1,
has for first child a node of label p that serves as a navigation widget indicating the sibling type
of this node in the tape tree (left or right). It has as second child a node of label TTCh (for
tape tree children), which in turn has for children two nodes with label s, encoding the two
children of the current encoded node in the abstract tape tree. The navigation widget is a p-labeled
node with a single x-child that has itself a single y-child. If the current encoded node in the tape
tree was a left child, x = 0 and y = 1; otherwise, x = 1 and y = 0. The root of the physical tree, r ,
corresponds to the root of the abstract tape tree; since the root of the abstract tape tree is neither a
left or right child, r does not need a navigation widget as a child. It therefore has two children, nodes
labeled with s encoding the two children of the root in the abstract tape tree. For a node at level n
of the abstract tape tree, the corresponding s-labeled node must have a navigation widget child
encoding whether it is a left or right child of its parent. But instead of a link to nodes representing
its children in the abstract tape tree, it must have a link to a node representing its content. Thus the
corresponding node in the physical tape tree has one child that is a p-labeled navigation widget,
and second child a c-node that encodes the content of the cell, which we describe immediately
below.

Γ

Γ

Γ

×

∆

Ω

∪ (

) ∪ (

In encoding the information about the content of a tape cell in a configuration, we again
follow [10]. In the abstract tape tree, this information consists of the symbols on basic cells,
symbol and transition followed on the current cell, and current symbol, previous state, previous
symbol on previous tape cells. This means each cell would be associated with an element of
Γ
: there are polynomially many such annotations, we refer to them in the
)
following as 1, . . . , k fixing an arbitrary order. As in [10], we want to impose a number of horizontal
constraints (constraints on the annotations of neighboring cells in a given configuration) and of
vertical constraints (constraints on the annotation of the same cell in successive configurations).
of integers 1 ⩽ i, j ⩽ k,
These constraints can be written as two sets of pairs H
respectively, indicating respectively whether j can appear to the right of i in a configuration, and
whether j can appear in the same cell as i in a successive configuration. We refer to [10] for the full
set of constraints required.

Mw )
(

Mw )
(

and V

×

×

In our physical tree representation, the content of a cell is not represented by a single label, but
by a chain of descendants. For each cell, the c-node has two children, labeled with m (for me) and f
(for forbidden), each having as descendants a chain of k nodes that can have labels either 0 or 1.
Only one node has label 1 under m, the one whose depth gives the current content of the cell; other
nodes under m have label 0. Under f , for a cell at position i in the tape, node at depth j has label 0
if and only if

, and label 1 otherwise.

V

In Fig. 2 we see a bird’s eye view of one of our encodings. In the box in the lower part of the
picture near the center of the page, we have highlighted the physical encoding of an abstract tape,
focusing on the physical encoding of the address structure while omitting the encoding of the cell
content. In the box closer to the left border we have zoomed in on the encoding of a tape cell’s
content.

As in [10], we can construct in polynomial time a BNTA that enforces that all physical trees have
the described form, including respect of horizontal constraints, initial configuration at the root and
accepting configuration at the leaves, but excluding vertical constraints. Indeed, vertical constraints
cannot (at least straightforwardly) be imposed on the tree as they relate nodes of the tree that
are very far apart – see [10] for how to encode horizontal constraints and the general structure.
Modifications needed because of our binary setting are minor. The language of this BNTA is exactly
the codes of accepting computation trees for Mw , except that vertical constraints may be violated.

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

i, j
(

) ∈

Mw )
(

Monadic Datalog, Tree Validity, and Limited Access Containment

6:37

⊥

ℓ

Conf

2n − 1

p

0

1

r

s

f

·

k

Conf

NextConf

NextConf

· · ·

Conf

· · ·

s

p

1

TTCh

· · ·

r

s

s

s

TTCh

· · ·

· · ·

0
physical tape tree

c

m

k

tape cell’s content

·

p

0

1

Fig. 2. General structure of trees in proof of Theorem 5.3; bold labels and counters highlight changes from
the proof of Theorem 6 of [8]

We will now construct a conjunctive query that holds if vertical constraints are violated. In what
for R a binary relation
1 R

the chain

R

follows, we denote by Ri
and i ⩾ 1.

x, y
(

)

x1 . . . xi
∃

−

We first need to construct a conjunctive query SameCell

that expresses that two s-nodes
encoding a node at depth n in the tape tree (i.e., at the bottom of the tape tree) correspond to the
same cell of successive configuration tapes. To do that, we will need the following subformulas:

xi
(

1, y
−

)

x, x1) ∧ · · · ∧
(
s1, s2)
(

•

•

•

r1, r2)
(

that expresses that r1 and r2 are each the root of a tree encoding a tape,
A formula Succ
with the configuration of r2 being a successor in the computation tree of that of r1. Formally:
Labelr (

r1, r2)
(

Succ

(cid:66)

r1) ∧
s1s2 Labelr (
∃
s1, r1) ∧
Child
(
∧

r2)
s2, r2) ∧
Child
(

Child2

s1, s2)
(

.

x, y

that expresses that x and y are s-nodes encoding a node at the i-th level
A formula Φi (
of two tape trees, such that the configuration of y is a successor in the computation tree of
the configuration of x:

)

)

(cid:66)

x, y

Φi (

r1, r2)
Succ
) ∧
(
Child2i −1
r2, y
)
(
holds and that, additionally, x and y are both
A formula Ψi (
does not hold if x is a first child
first children or both second children of their parents (Ψi (
and y a second child or vice versa); note that we could not use FirstChild and SecondChild

x
r1r2 Labels (
) ∧
∃
Child2i −1
∧

y
Labels (
r1, x
) ∧
(
x, y

that expresses that Φi (

x, y

x, y

)

)

)

.

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:38

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

Ψi (

x, y

here as it would require disjunction. We can, however, use the navigation widgets:
ty )
Label1(
Child(py, t ′
y )

pxpytxtyt ′
∃

py ) ∧
tx ) ∧
Label1(
Child(px , t ′
x )
∧

yz Φi (
∧

x t ′

x, y

) ∧

(cid:66)

)

Labelp (
x, px ) ∧
Child
(
Child?(t ′
x , tx )
Child(2i −1)+4

px ) ∧
Labelp (
y, py ) ∧
Child
(
Child?(t ′

y, ty )
Child(2i −1)+6

∧

∧

z, ty )
(

∧
z, tx ) ∧
(
Observe that when x and y are both first children, the tx and ty are grandchildren of the
p-node, and therefore at distance (2i − 1) + 3 of the r -node, so going up (2i − 1) + 4 times
brings us to the Conf-node of the current configuration, and going up (2i − 1) + 6 times
brings us to the Conf-node of the preceding configuration. Similarly, if x and y are both
second children, the tx and ty are children of the p-node, so going up (2i − 1) + 4 times brings
us to the parent of the Conf-node of the current configuration, and going up (2i − 1) + 6
times brings us to the parent of the Conf-node of the preceding configuration. This is one
of the two places where we need the chain of ℓ nodes at the root: otherwise, since
the initial configuration does not have a preceding configuration, we would not be
able to go high enough up in the tree to find the z node. Taking ℓ ⩾ 1 suffices.
Finally, SameCell

is written as:

•

SameCell

s1, s2)
(

x1 · · ·
∃

xn

1y1 · · ·

−

yn

1
−

s1, s2)
(
(cid:66)

Child2

(cid:219)1⩽i <n
∧

1
−
(cid:0)
Child2
xn
(
s1, s2) ∧
Ψn(

∧

−

xi, xi+1) ∧
(
Child2
Ψi (

yn
(
xi, yi )

.

1, s1) ∧

(cid:219)1⩽i <n

Child2

yi, yi+1)
(

(cid:1)

1, s2)

−

We can now use these subformulas in the following sentence, that expresses the final conjunctive
query Q. It checks whether the two same cells s1 and s2 of successive configurations violate
vertical constraints. Remember that the value of a cell is encoded under the m-node, while vertical
constraints are encoded under the f -node. A vertical constraint occurs when the (unique) position
of a 1-node under the m-descendant of s2 is equal to the position of a 1-node under the f -descendant
of s1.

Q (cid:66)

∃

∧

Child

s1, s2) ∧
s1s2t1t2 f1m2u1u2z SameCell
(
t1, f1) ∧
Child
(
f1) ∧
Labelf (
(Child?)k (f1, u1)
Child(2n−1+3)+k

s1, t1) ∧
Child
(
t2, m2)
Child
(
u1) ∧
m2) ∧
Label1(
Labelm(
(Child?)k (m2, u2)
∧
Child(2n−1+5)+k
z, u1) ∧
(

∧

∧

∧

s2, t2)
(

Label1(

u2)

z, u2)
(

.

This is the other place we need the chain of ℓ nodes at the root: otherwise, again, since
the initial configuration does not have a preceding configuration, we would not be able
to go high enough up in the tree to find the z node. Taking ℓ ⩾ k − 1 suffices.

The query Q can be constructed in polynomial time, and Q is valid over the BNTA previously
constructed if and only if the Turing machine Mw has no accepting (EXPSPACE) computation
tree.
□

This hardness result of CQ validity over trees satisfying a DTD actually implies hardness of UCQ
validity over all trees, thanks to the following argument, that shows that BDTD constraints can be
encoded by the negation of a union of conjunctive queries.

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:39

d, l0)
(

be a BDTD. Then one can construct in polynomial time a UCQ qτ over

Lemma 5.4. Let τ =
bin
Ch1,Ch2 such that for any binary tree t, t is accepted by τ iff t does not satisfy qτ .
S
= 2Λ
Proof. We denote by d c the function from Λ to 2Λ
Λ, d c
.
×
∈
)
and equal to false, e.g.,
)

Λ such that for any α
α
if ε
x
Labelα (
(

We denote by φα the query equal to

x Leaf

α
(

α
(

x
(

) ∧

d c

−

∃

∈

d

Λ

×

)

)

∃

x, x
x FirstChild
(
We define qτ as follows:

, otherwise.

)

x
xyz Labelα (

(∃
)

(cid:220)α
∈

d c
Λ (cid:220)(
β ,γ
)∈
φα

α

(

FirstChild

x, y
(

) ∧

y
Labelβ (

) ∧

x, z
SecondChild
(

) ∧

z
Labelγ (

))

) ∧

∨

Λ
(cid:220)α
∈

x
x Root
(

x
Labelα (

.

(∃
l0 }

∨
Λ
(cid:220)α
∈
−{
It is easy to check that t is accepted by the DTD τ iff t does not satisfy qτ .

) ∧

))

□

∨

qτ
□

Corollary 5.5. Deciding whether a UCQ on

bin
Ch1,Ch2,Child,Child? is valid is 2EXPTIME-hard.
S

Proof. We reduce the problem of Theorem 5.3 to the current problem. Let τ be a DTD and q be

a CQ on

bin
Ch1,Ch2,Child,Child? .
S

Thanks to Lemma 5.4, we can construct qτ in polynomial time such that t does not satisfy q

if and only if t

L

τ
(

)

∈

and t

= q.
̸|

In the restricted case where Child and Child? relations cannot be used in the query, we prove an
EXPTIME lower bound, which matches the upper bound of Corollary 4.21. This result is proved
in [9], in a slightly different setting, as the Child relation is allowed (because of this restriction, we
prove the hardness for UCQs instead of CQs).

bin
Ch1,Ch2 is valid over

S

Theorem 5.6. [Adapted from Theorem 10 of [9]] Deciding whether a UCQ on

a DTD, or whether a CQ on

bin
Ch1,Ch2,Child or

S

unranked
Child

S

is valid over a DTD, is EXPTIME-hard.

Proof. Theorem 10 of [9] shows the EXPTIME-hardness of CQ validity on

an NTA. The CQ used in the proof is of the form:

bin
Ch1,Ch2,Child over
S

Q (cid:66)

x1 . . .

∃

x1, x2) ∧ · · · ∧
xn Child
(
∃

xn
Child
(

1, xn) ∧

−

Labela(

x1) ∧

Labelb (

xn)

The setting of [9] is that of unranked trees, but the proof of Theorem 10 only uses binary trees.
They are not full binary trees, but they can easily be rendered full by adding nodes with dummy
labels as second children of nodes with a single child.

To move from NTAs to DTDs, we use Corollary 5.2 (in the same way, Theorem 12 of [9] states

the EXPTIME-hardness of CQ validity on

bin
Ch1,Ch2,Child over a DTD).
S

The only thing that remains to be proven is the EXPTIME-hardness of UCQ validity on

bin
Ch1,Ch2
over an NTA. This is easily done by observing that in the proof of Theorem 10 of [9] all but one
of the Child can be replaced by a FirstChild atom (the proof relies on the reduction from a tiling
game, and non-branching chains of nodes are used to encodes tiles and constraints, with branching
used only to encode choices of one of the player; the query matches nodes within the encoding
two successive tiles, thus with at most one branching on the second child).

We consider the query Q ′i , for 1 ⩽ i ⩽ n
xi, xi+1)
by an atom SecondChild
(
1
n
i=1 Q ′i , which is a formula with n
. We then let Q ′ (cid:66)
−

1, obtained by replacing in Q the i-th atom
by an atom
atoms (and thus

−
xi, xi+1)
, and all other atoms Child
(
2n
1
)
−

xi, xi+1)
Child
(
xi, xi+1)
FirstChild
(
of polynomial size in the size of Q).

S

(

(cid:212)

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:40

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

Then Q ′ can be used instead of Q in the proof of Theorem 10 of [9], and Q ′ is on

bin
Ch1,Ch2. □
S

bin
Note that this leaves the complexity of CQ validity on
Ch1,Ch2 over a DTD as an open problem.
S
Applying Lemma 5.4, we conclude from Theorem 5.6 the EXPTIME-hardness of UCQ containment

on

bin
Ch1,Ch2 and
S
Corollary 5.7. Deciding whether a UCQ is valid with respect to all trees on

bin
Ch1,Ch2,Child:
S

is EXPTIME-hard.

Note, however, that the case of UCQ validity over all trees on

bin
Ch1,Ch2 or

S

bin
Ch1,Ch2,Child

S

unranked
Child

S

is in PSPACE by Proposi-
is

unranked
Child

tion 4.22, and thus is not covered by Lemma 5.4. We can show that the problem over
complete for PSPACE.

S

Proposition 5.8. Deciding whether a UCQ is valid with respect to all trees on

hard. This holds even if the trees are restricted to have no branching (at most one child per node).

unranked
Child

S

is PSPACE-

Proof. We consider the problem of tiling a polynomial width grid. A solution to such a problem
can be coded as a path, where the label alphabet are the tiles and the path represents the concaten-
tation of the rows of the tiling. Given a tiling problem we can create in polynomial time a UCQ Q
such that the tiling problem has a solution if and only if a counterexample to validity of Q codes a
solution. The satisfaction of the horizontal constraint will correspond to one CQ of Q, while the
satisfaction of the vertical constraint will represent a second CQ.
□

5.2 Lower bounds for MDL and limited access containment
We now apply the prior results to get bounds on MDL and limited access containment.

We first show a 2EXPTIME lower bound for the problem of checking the containment of a
monadic datalog program in a CQ. This matches the general upper bound for the containment of a
datalog query within a union of CQs.

Theorem 5.9. MDL containment in a CQ is 2EXPTIME-hard.

Proof. We reduce from the problem of validity of a CQ on

which is 2EXPTIME-hard by Theorem 5.3.

bin
Ch1,Ch2,Child,Child? over a BNTA,
S

Let A =
(
as follows:

Ω, ∆0, ∆, F

)

be a BNTA and Q a conjunctive query. We build a monadic datalog program P

•
•

•

•

For every q
For every q

∈
∈

Ω, we have an intensional monadic predicate Pq.
F , we have a rule:

For every symbol α

For every symbol α

∈

∈

n
Pq′(

) ←

Goal

() ←

Λ, for every q

∈

.

)

) ∧

Root

r
Pq(
r
(
α
∆0(
, we have a rule:
)
l
Labelα (

Child?

) ∧

) ∧

) ←

l, l
(

Pq(
l
l
Leaf
(
Λ, for every q1, q2, q′ ∈
n1) ∧
n
Labelα (
FirstChild

Pq1(
) ∧
n, n1) ∧
(
n, n2) ∧
SecondChild
(
Child?

)
Ω such that q′ ∈
n2) ∧
Pq2(
n, n1) ∧
Child
(
n, n2) ∧
Child
(

Child?

n, n
(

)

n, n1) ∧
(
Child?
n, n2) ∧
(

.

∆

α, q1, q2)
(

, we have a rule:

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:41

We claim that this is a valid reduction of tree validity to MDL containment. In one direction,
given a counterexample to tree validity of Q, we can interpret the relations of the program in the
usual way, and this is easily seen to be a counterexample to containment of P in Q.

In the other direction, if there is a counterexample to containment of P in Q, then by the proof
of Proposition 2.6 there is a counterexample that is an expansion tree of the program P, with
the notion of expansion tree defined in [19]: see the proof of Proposition 2.6 for a review of the
notion of expansion tree. But one can see that an expansion tree of P must actually be a tree over
bin
Ch1,Ch2,Child,Child? . Further, the second rule guarantees that such a tree must satisfy that BNTA
S
A.
□

We now show a more elaborate result, which is that even for a restricted subset of MDL general-

izing AGEMDL, the problem of containment in a UCQ is 2EXPTIME-hard.

AGEMDL forbids a relation from occurring more than once outside of the goal predicate, which is
a strong restriction. A simple generalization is to consider the class of MDL queries where relations
can occur in a bounded number of rules. Let k-GEMDL be the class obtained by replacing “in
only one rule”, with “in at most k rules” in the definition of GEMDL (while still restricting to one
occurrence per rule). Thus, 3-GEMDL is the class of MDL queries such that:

(i) every extensional predicate appears in at most 3 rules;
(ii) every extensional predicate appears at most once in a rule.

We show that in the case of 3-GEMDL, the complexity jumps back up to 2EXPTIME, relying on
bin
Ch1,Ch2,Child,Child? . Because of space
S

our 2EXPTIME-hardness result for UCQ validity over trees of
constraints, the proof is deferred to an electronic appendix.

Theorem 5.10. 3-GEMDL containment in a UCQ is 2EXPTIME-hard.

We similarly show, by using a reduction from UCQ validity over trees of

bin
Ch1,Ch2 to UCQ con-
S
tainment under limited access patterns, EXPTIME-hardness of this latter problem: Again, because
of space constraints, the proof is deferred to an electronic appendix.

Theorem 5.11. The problem of UCQ containment under limited access patterns is EXPTIME-hard.

The hardness holds even if every access has at most one output position.

Theorem 5.11 implies, in particular, by Proposition 4.23:

Corollary 5.12. Containment of an AGEMDL query in a UCQ is EXPTIME-hard.

We have thus shown matching complexity lower bounds for the upper bounds of [33] on monadic
datalog containment and of Section 4.5 on AGEMDL containment in a UCQ, using reductions from
tree validity problems.

6 RELATED WORK

Monadic datalog containment. Special cases of the containment problem of monadic datalog in
UCQs have been studied in the past. As mentioned in the introduction, the Chaudhuri and Vardi
article [18] proved a co-NEXPTIME upper bound of containment of unary MDL queries in a union
of unary connected conjunctive queries. Their paper extends earlier work by Courcelle [23], who
noted the connection with graph decompositions, and by Chaudhuri and Vardi [17] (published in
journal form in [19]) that established complexity bounds for containment of general datalog queries
in non-recursive datalog queries. The proof technique in [18] does not extend to non-connected
unary queries, as our 2EXPTIME-completeness results for the general case show.

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:42

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

R

a, b
(

)

R

b, c
(

)

T

c
(

)

S

a
(

)

0

1

2

S

a
(

)

R

a, b
(

)

T

b
(

)

Fig. 3. Left: Example database in the crayfish-chase of query Q1 :
x
S
(
after applying the subtree replacement procedure in the proof of Lemma 5 of [13].

x, y
(

x
∃

y R

) ∧

∃

. Right: Same database
)

Segoufin and ten Cate [33] define the language UNFP which can express the conjunction of an
MDL query with a negated UCQ; they show that the satisfiability for this language is 2EXPTIME-
complete. An EXPTIME bound on satisfiability is shown for a fragment called Simple UNFP; the
fragment cannot express UCQs, much less the negation of a UCQ conjoined with an MDL query.
[3, 4] shows a 2EXPTIME upper bound for containment of datalog in positive queries with

constants.

Limited access containment. The problem of containment under access restrictions originates
from [12] and is examined further in [13]. The model allows constants in the users queries, and
also allows relations to be typed from a domain, which could have a fixed set of values. It restricts
to conjunctive queries, rather than UCQs as in earlier work.

Both papers claim a co-NEXPTIME bound for the problem, with the proof being sketched in [12]
and given in detail in [13]. The argument applies a technique similar to the one applied in our
work: one shows that if there is a counterexample instance for containment, it can be taken to be
tree-like (a “crayfish-chase instance” in the terminology of [13]). Then it is claimed that if there is
a tree-like instance, it can be truncated to have depth polynomially bounded; this is Lemma 5 of
[13]. The shrinking is done by repeatedly finding appropriate comparable nodes and replacing the
subtree of the upper node with the subtree of the lower node. It is thus analogous to showing that
exponential sized paths must have two nodes with the same automaton state.

Our results apply to access method containment for UCQs without constants, and provide an
EXPTIME bound, and thus are orthogonal to those in [13]. In addition, our bounds apply to other
classes of MDL containment problems where the polynomial depth property does not hold.

We also believe that there is a flaw in the proof of Lemma 5 of [13], already in the case of queries
without constants and with a single domain for all attributes. Indeed, consider a schema with one
binary relation R, with an access on its second position, and two unary relations S and T , with free
accesses on each. On this schema, consider the following queries:

Q1 :
Q2 :

x
∃
x
∃

y R

y R

∃

∃

x, y
(
x, y
(

) ∧

) ∧

S

S

x
(
x
(

)

) ∧

T

y
(

)

In Fig. 3 (left), we give an example database instance D that is in the crayfish-chase of Q1 (one
can verify that all properties of the crayfish-chase, in Definition 2 of [13], are satisfied). We are in
subcase (1b) of the proof of Lemma 5 of [13]: Q2 is connected, and there is more than one relation
(R and S) that can be on the smallest level (0) of the mapped facts of Q2 in a crayfish-chase of Q1.
Accordingly, we consider all paths in D from a node of level 0 to a leaf, and we consider the first
and last occurrences of every relation among R and S. Only the two atoms framed in Fig. 3 (left) are
of interest here. The proof then proceeds with shrinking the database, by applying the replacement
(see Definition 4 of [13]) of the subtree rooted at the upper node by the subtree rooted rooted at

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:43

the lower node, resulting in the database instance in Fig. 3 (right). The proof goes on by applying
further replacements to other cases of multiple occurrences of relations in the database, irrelevant
here as every relation appears only once. Now, observe that Q2 is satisfied in the resulting database
but not in the original database D, whereas Lemma 5 of [13] claims that the shrunk database after
subtree replacements cannot be satisfied by Q2 if the original database was not satisfied by Q2.

The problem comes from joins at level 0 of crayfish-chase database forests. We do not see how
the proof can be easily fixed, say by imposing that subtree replacement is only carried at levels
that are deep enough: it seems critical in the proof that subtree replacements of relations in Q2
are done at the occurrence of a relation that has the lowest-level possible, to ensure that newly
created joins with relations above this level do not change the satisfaction of Q2. Of course, these
comments do not amount to a disproof of the polynomial depth property claimed in the paper. We
leave this question for future work.

Our main upper bound technique originates from our work on limited access querying [6]. There
we showed a co-NEXPTIME bound for a particular kind of MDL/UCQ containment problem, using
a special case of the technique. Our upper bounds here are an abstraction of the idea in [6], relating
it to tree-like instances. Our lower bounds can be seen as exploring the limits of this method.
However [6] also contains some significant errors.

•

•

∧

,
∃

,
∨

A co2NEXPTIME lower bound for containment of positive queries (which extend UCQs by
to be freely mixed) under access patterns is claimed. The proof in [6] is
allowing
flawed, and in [4] a 2EXPTIME upper bound on this problem is proven. The latter is at odds
(relative to complexity-theoretic hypothesis) with the former.
A coNEXPTIME upper bound is claimed in [6] for containment of UCQs under general access
patterns. The proof given there only works for schemas with a single-access per relation.
The multiple access containment problem is open (see the discussion in Section 7).

Validity and containment problems on trees. Björklund et al. [8] study containment of tree automata
in UCQs with child and descendant. We make use of their lower bound technique in our first result,
while also refining one of their upper bounds in the absence of a descendant predicate.

Some of the results in this work were announced in the conference paper [5].

7 CONCLUSIONS AND FUTURE WORK
In this paper we have revisited the containment problem for recursive queries in UCQs. We started
by showing that the problem is hard for doubly-exponential time in general. We then analyzed the
phenomenon of tree-like models (monadic expansion trees) for recursive queries in more detail, and
give a parameter – the number of IQ classes – that controls the size of a minimal counterexample
to containment. We have shown that if a logic has models that are “very tree-like”, then the number
of distinct ways a CQ can map into the model is limited, and thus an exponential bound can be
shown on the number of IQ classes. We have applied this analysis to two logics and two collections
of instances – GEMDL and tree automata. But we believe that it can be applied to other fragments
of MDL.

Our results on limited access containment come with two main restrictions, and we discuss

lifting them here.

First we assume that there are no constants in the queries. This does not make any difference
in the 2EXPTIME upper bounds for general MDL containment in UCQs, but the assumption is
critical for our EXPTIME upper bounds. We believe that the addition of constants makes all of our
EXPTIME-complete problems into co-NEXPTIME-complete problems.

The second restriction is that there is a single access method per relation. Although this is a
standard assumption in the literature, it is easily seen to be unimportant for decidability of the

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

6:44

Michael Benedikt, Pierre Bourhis, Georg Gottlob, and Pierre Senellart

problem. Indeed, one still get a 2EXPTIME bound for limited access containment, either directly via
tree-like witnesses or by reduction to MDL containment. As with constants, the issue is whether
the EXPTIME bound carries over to this case. Although we conjecture that the EXPTIME bounds
carry over to this case, the problem is open at the time of writing.

ACKNOWLEDGMENT
Benedikt was funded by the EPSRC grants PDQ (EP/M005852/1), ED3 (EP/N014359/1), and DBOnto
(EP/L012138/1).

REFERENCES
[1] Serge Abiteboul, Richard Hull, and Victor Vianu. 1995. Foundations of Databases.
[2] Antoine Amarilli, Pierre Bourhis, and Pierre Senellart. 2015. Provenance Circuits for Trees and Treelike Instances

(Extended Version). CoRR abs/1511.08723.

[3] Michael Benedikt, Pierre Bourhis, and Clemens Ley. 2012. Querying Schemas with Access Paths. PVLDB (2012).
[4] Michael Benedikt, Pierre Bourhis, and Clemens Ley. 2015. Analysis of Schemas with Access Restrictions. ACM Trans.

Database Syst. 40, 1 (2015), 5.

[5] Michael Benedikt, Pierre Bourhis, and Pierre Senellart. 2012. Monadic Datalog Containment. In ICALP.
[6] Michael Benedikt, Georg Gottlob, and Pierre Senellart. 2011. Determining relevance of accesses at runtime. In PODS.
[7] Michael Benedikt, Balder ten Cate, Thomas Colcombet, and Michael Vanden Boom. 2015. The Complexity of Bounded-
ness for Guarded Logics. In LICS. Extended version available at https://www.cs.ox.ac.uk/people/michael.vandenboom/
papers/LICS15-gnfpb-long.pdf.

[8] Henrik Björklund, Wim Martens, and Thomas Schwentick. 2008. Optimizing Conjunctive Queries over Trees Using

Schema Information. In MFCS.

[9] Henrik Björklund, Wim Martens, and Thomas Schwentick. 2013. Validity of tree pattern queries with respect to

schema information. In MFCS.

[10] Henrik Björklund, Wim Martens, and Thomas Schwentick. 2016. Conjunctive query containment over trees using

schema information. Acta Informatica (2016).

[11] Piero A. Bonatti. 2004. On the decidability of containment of recursive datalog queries. In PODS.
[12] Andrea Calì and Diego Calvanese. 2006. Containment of Conjunctive Queries under Access Limitations. In SEBD.
[13] Andrea Calì and Davide Martinenghi. 2008. Conjunctive Query Containment under Access Limitations. In ER.
[14] Diego Calvanese, Giuseppe De Giacomo, and Moshe Y. Vardi. 2005. Decidable containment of recursive queries.

Theoretical Computer Science 336, 1 (2005).

[15] Diego Calvanese, Giuseppe De Giacomo, Maurizio Lenzerini, and Moshe Y. Vardi. 2000. Containment of Conjunctive

Regular Path Queries with Inverse. In KR.

[16] Ashok K. Chandra, Dexter Kozen, and Larry J. Stockmeyer. 1981. Alternation. J. ACM 28, 1 (1981).
[17] Surajit Chaudhuri and Moshe Y. Vardi. 1992. On the Equivalence of Recursive and Nonrecursive Datalog Programs. In

PODS.

[18] Surajit Chaudhuri and Moshe Y. Vardi. 1994. On the Complexity of Equivalence between Recursive and Nonrecursive

Datalog Programs. In PODS.

[19] Surajit Chaudhuri and Moshe Y. Vardi. 1997. On the Equivalence of Recursive and Nonrecursive Datalog Programs.

JCSS 54, 1 (1997).

[20] Bogdan S. Chlebus. 1986. Domino-Tiling Games. J. Comput. Syst. Sci. 32, 3 (1986), 374–392. https://doi.org/10.1016/

0022-0000(86)90036-X

[21] Hubert Comon, Max Dauchet, Rémi Gilleron, Florent Jacquemard, Denis Lugiez, Sophie Tison, and Marc Tommasi.

2002. Tree Automata Techniques and Applications. Available at http://www.grappa.univ-lille3.fr/tata/.

[22] Stavros S. Cosmadakis, Haim Gaifman, Paris C. Kanellakis, and Moshe Y. Vardi. 1988. Decidable Optimization Problems

for Database Logic Programs. In STOC.

[23] Bruno Courcelle. 1991. Recursive queries and context-free graph grammars. Theoretical Computer Science 78, 1 (1991).
[24] Oliver M. Duschka and Alon Y. Levy. 1997. Recursive Plans for Information Gathering. In IJCAI.
[25] Ferenc Gécseg and Magnus Steinby. 1997. “Tree Languages”. In Handbook of Formal Languages, G. Rozenberg and

A. Salomaa (Eds.). Vol. 3. Springer Verlag, Chapter 1, 1–68.

[26] Chen Li and Edward Chang. 2001. Answering Queries with Useful Bindings. TODS 26, 3 (2001), 313–343.
[27] Todd D. Millstein, Alon Y. Halevy, and Marc Friedman. 2003. Query containment for data integration systems. J.

Comput. System Sci. 66, 1 (2003), 20–39.

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

Monadic Datalog, Tree Validity, and Limited Access Containment

6:45

[28] Frank Neven. 2002. Automata Theory for XML Researchers. SIGMOD Record 31, 3 (2002), 39–46. https://doi.org/10.

1145/601858.601869

[29] Anand Rajaraman, Yehoshua Sagiv, and Jeffrey D. Ullman. 1995. Answering Queries Using Templates with Binding

Patterns. In PODS.

[30] Neil Robertson and Paul D. Seymour. 1986. Graph minors. II. Algorithmic aspects of tree-width. J. Algorithms 7, 3

(1986).

[31] Oded Shmueli. 1993. Equivalence of datalog queries is undecidable. J. Log. Program. 15, 3 (1993). https://doi.org/10.

1016/0743-1066(93)90040-N

[32] Masako Takahashi. 1975. Generalizations of Regular Sets and Their Application to a Study of Context-Free Languages.

Information and Control 27, 1 (1975), 1–36.

[33] Balder ten Cate and Luc Segoufin. 2011. Unary negation. In STACS.

ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.

APROOFOFTHEOREM5.10Theorem5.10.3-GEMDLcontainmentinaUCQis2EXPTIME-hard.Proof.WereducefromUCQvalidityovertreesofSbinCh1,Ch2,Child,Child?(seeCorollary5.5).Fortechnicalreasons,itwillbemoreconvenienttoreducefromhardnessofUCQvalidityovertreesofSbinCh1,Ch2,Child,Child?thathavemorethanonenode(i.e.,whoserootisnotaleaf).Sowestartbyshowingthatwecanassumethiswithoutlossofgenerality:ClaimA.1.UCQvalidityovertreesofSbinCh1,Ch2,Child,Child?reducestoUCQvalidityovertreesofSbinCh1,Ch2,Child,Child?withmorethanonenode.Proofoftheclaim.LetQbeaUCQwhichisaninstanceoftheformerproblem.Foreveryα∈Λ,weevaluateQoverthetreeconsistingonlyofarootwithlabelα.ThisevaluationcanbedoneintimelinearinQ:aCQistrueoversuchatreeiffitdoesnotincludeanyChildorβatomswithβ,α.Ifoneoftheseevaluationsreturnsfalse,wetakeforQ′thequery∃xRoot(x)∧Leaf(x);otherwisewetakeQ′BQ.ObservethatifQisvalidoveralltrees,thenitisinparticularvalidoverallroot-onlytreesandQ′=Qisvalidoveralltreeswithmorethanonenode.Conversely,ifQisnotvalidoveralltrees,eitherthereisaroot-onlytreethatdoesnotsatisfyQandthenQ′=Root(x)∧Leaf(x)isnotsatisfiedbyanytreewithmorethanonenode,orthereisatreewithmorethanonenodethatdoesnotsatisfyQandthenitdoesnotsatisfyQ′=Qeither.□NowletQbeaUCQoverSbinCh1,Ch2,Child,Child?whichisaninstancefortheUCQvalidityproblemovertreeswithmorethanonenode.Thegoalistoconstructa3-GEMDLqueryQ′1andaUCQQ′2overarelationalsignaturesuchthatQisvalidovertreesofSbinCh1,Ch2,Child,Child?ifandonlyifQ′1iscontainedinQ′2.Toachievethis,webuildaone-to-onecorrespondencebetweenbinarytreewitnessesofnon-validityofQandminimalmonadicexpansiontreewitnessesofnon-containmentofQ′1inQ′2.ThebinarytreewillbeencodedastheexpansiontreeofQ′1.ThetemptationwouldbetohaveaunarypredicateU(x)andanextensionalpredicateChild(x,y)witharule,suchasU(x)←Child(x,y),Child(x,z),U(y),U(z)whichwillgenerateabinaryexpansiontree.However,thisisproblematicfortworeasons:(1)The3-GEMDLrestrictionpreventsusfromhavingtwooccurrencesofthesameextensionalpredicate,suchasChildintheruleabove.(2)WeneedtoexpressQbyUCQQ′2overtheencodedstructure,andQusestheChild?predicateinadditiontoChild.NaivelyinliningChild?(x,y)asadisjunctionChild(x,y)∨(x=y)willleadtoanexponentialblowup.Toresolvethetwosourcesofdifficultyjustmentioned,wearegoingtousethefollowingrelationalsignature:•a7-aryrelationC;•unarypredicatesP3,P4,P5;•aunarypredicateLabIndαforeverylabelαofΛ;•aunarypredicateLeaf;•aunarypredicateRoot;TherelationCservestoconnectaparentnodepwithitstwochildrennodeqandr,inawaythatispicturedinFig.4andthatwewilldetailfurther.ThepositionsofChavethefollowingintendedmeaning:(i)thenodeidentifier;(ii)avalueusedtoconnectaparentwithitsfirstchild;(iii)avalueusedtoconnectafirstchildwithitssibling;(parent)C(p,u1,u2,u3,u4,u5,lp)(1stchild)C(q,u1,v2,v3,v4,v5,lq)(2ndchild)C(r,w1,v2,w3,w4,w5,lr)P3(u3)P4(v4)P5(w5)LabIndαp(lp)LabIndαq(lq)LabIndαr(lr)Fig.4.ExampleofcodingoftheChildrelationbetweenaparentnodepanditschildrenqandr(iv)avalueusedtodistinguishtheparentwhenconnectedtopredicateP3;(v)avalueusedtodistinguishthefirstchildwhenconnectedtopredicateP4;(vi)avalueusedtodistinguishthesecondchildwhenconnectedtopredicateP5;(vii)avalueusedtoconnecttoalabelpredicateLabIndα.Wenowdefinethe3-GEMDLqueryQ′1asfollows;ituses7unaryintensionalpredicatesU0...U6(intuitivelymeanttorepresenteachabstractdomainofapositionofC)aswellasagoalpredicate:U0(x)←Leaf(x)U0(x0)←C(x0,x1,x2,x3,x4,x5,x6)∧U1(x1)∧U3(x3)∧U6(x6)U1(x1)←C(x0,x1,x2,x3,x4,x5,x6)∧U0(x0)∧U2(x2)∧U4(x4)∧U6(x6)U2(x2)←C(x0,x1,x2,x3,x4,x5,x6)∧U0(x0)∧U5(x5)∧U6(x6)U3(x)←P3(x)U4(x)←P4(x)U5(x)←P5(x)U6(x)←LabIndα(x)foreveryα∈ΛGoal←Root(x0)∧U0(x0)WedefinethetranslationoftherelationsChild,Child?,FirstChild,SecondChild,andLabelα(forα∈Λ)overbinarytreesintoconjunctivequeriesChild′,Child?′,FirstChild′,SecondChild′,andLabel′α.ThesewillbeusedassubformulasoftheformulaQ′2thatwewillconstruct.Child′(x,y)B∃u1∃v2∃u3∃v4C(x,u1,_,u3,_,_,_)∧P3(u3)∧C(_,u1,v2,_,v4,_,_)∧P4(v4)∧C(y,_,v2,_,_,_,_)Child?′(x,y)B∃u1∃v2∃u3C(x,u1,_,u3,_,_,_)∧P3(u3)∧C(_,u1,v2,_,_,_,_)∧C(y,_,v2,_,_,_,_)FirstChild′(x,y)B∃u1∃u3∃v4C(x,u1,_,u3,_,_,_)∧P3(u3)∧C(y,u1,_,_,v4,_,_)∧P4(v4)SecondChild′(x,y)B∃u1∃v2∃u3∃v4∃w5C(x,u1,_,u3,_,_,_)∧P3(u3)∧C(_,u1,v2,_,v4,_,_)∧P4(v4)∧C(y,_,v2,_,_,w5,_)∧P5(w5)Label′α(x)B∃lC(x,_,_,_,_,_,l)∧LabIndα(l)(The“_”symbolsdenoteanonymousexistentiallyusedvariableswithasingleoccurrenceeach.)WefinallyconstructqueryQ′2byreplacinginQalloccurrencesofR(x,y)withtheR′(x,y)subformula,whereRstandsforChild,Child?,FirstChild,SecondChild,orLabelα.TheRootandLeafatomsareleftasis.WealsoaddtoQ′2thefollowingUCQs.Theirroleistoensurethattheinstancerepresentsatreestructure,byforbiddinganodetohavetwodifferentlabels,andforbiddingarootnodetohaveaparentortobealeaf:3•foreveryα,β∈Λwithα,β:ψα,β=∃x∃l∃l′C(x,_,_,_,_,_,l)∧LabIndα(l)∧C(x,_,_,_,_,_,l′)∧LabIndβ(l′);•ψRoot=∃r∃xRoot(r)∧Child′(x,r)∨∃rRoot(r)∧Leaf(r).Q′2isaUCQ,anditsconstructionisinpolynomialtime.WeshowthatcontainmentofQ′1inQ′2undertheaccessrestrictionsoftheschemaisequivalenttothevalidityofQoverbinarytreesofSbinCh1,Ch2,Child,Child?.Toproveonedirection,considerabinarytreeToverSbinCh1,Ch2,Child,Child?withmorethanonenodethatdoesnotsatisfyQ.WedefinetherelationalinstanceIofthetargetschemamadeof:•foreachleafnodepofT,afactLeaf(p);•foreachnodepofTwithchildrenqandrthefactsshownonFig.4(withallfreshvariablesexceptforp,q,r)–inthatfigureαsdenotesthelabelofnodes;•fortherootrofT,anadditionalfactRoot(r).NotethatsinceTisnotaroot-onlytree,everynodeiseitherachildoraparentnode,andthereforetherewillbeatleastoneCatomforeverynodeofT.Byconstruction,theinstanceIsatisfiesQ′1andisactuallyaminimalmonadicexpansiontreewitnessforQ′1:thisisduetothefactthatforeachnodexinthetreeT,onecanshowbyinductiononthetreestructurethattheMDLprogramQ′1producestheintensionalfactU0(x).Now,observethatforXinChild,Child?,FirstChild,SecondChild,X′(x,y)istrueinIifandonlyifX(x,y)istrueinT(inChild′,thesecondandthirdCatomscanunify;inChild?′allthreeCatomscanunify).Similarly,thetranslationofaLabelα,RootorLeafatomholdsinIifandonlyiftheoriginalatomholdsinT.Q′2isthereforefalseinI,whileQ′1holdsinI.ThusIisawitnesstonon-containment.Conversely,assumewehaveawitnessIofnon-containmentofQ′1inQ′2.ByProposition2.6,wecanassume,withoutlossofgenerality,Itobeamonadicexpansiontree.WealsoassumeItobeminimal,inthesensethatnosubinstanceofIremainsavalidmonadicexpansiontreeinstanceofQ′1notsatisfyingQ′2.WeconstructabinarytreeTfromIasfollows:•ThesetofnodesofTistheprojectionofContoitsfirstpositioninI;leavesarethecontentoftheLeafpredicateinI,whichisasubsetofthenodesthankstotheminimalityofI.ALeaf(x)factnotconnectedtothefirstpositionofaCfactcanbesafelyremovedfromI;sinceψRootisnotsatisfiedweknowthatthereisnoLeaf(x)factdirectlyconnectedtoaRoot(x)fact.•Anodeyisthefirst(resp.,second)childofanodexifandonlyifFirstChild′(x,y)(resp.,SecondChild′(x,y))holdsinI.3Forbiddingarootnodetobealeafisatechnicalrequirement,thatensureswehaveawaytoassignalabeltothisrootnode.•TherootofTistheuniquevalueinRootinI(theexistenceisgivenbythesatisfiabilityofQ′1.TheuniquenesscomesfromtheminimalityofI:ifIcontainstwoRoot(x)factswithdistinctx’s,oneofthemcanberemovedstillresultinginavalidmonadicexpansiontree).•Thelabelofagivennodexisgivenbytheuniqueαsuchthat∃u1∃u2∃u3∃u4∃u5∃lC(x,u1,u2,u3,u4,u5,l)∧LabIndα(l)holdsinI.Theexistenceofαisguaranteedbythefactthat,sincenoLeaf(x)factisdirectlyconnectedtoaRoot(x)fact,theonlywaytoproduceanintensionalU0(x)factistohaveaCfact,whichrequirestheexistenceofaLabIndfact.TheuniquenesscomesfromthefactIdoesnotsatisfyanyoftheψα,β’s.SincewewanttoviewTasatreeoverSbinCh1,Ch2,Child,Child?,weaddtoTallfactsforChildandChild?impliedbyFirstChildandSecondChild.Wearguethat,equivalently,Child(x,y)andChild?(x,y)areaddedtoTwheneverChild′(x,y)orChild?′(x,y)holdinI.Indeed,ifforexam-pleChild′(x,y)holds,eitherthesecondandthirdCpredicateinthedefinitionofChild′unify(whichmeansFirstChild′(x,y)holds)ortheydonot,inwhichcasetheU2(v2)intensionalfactrequiredmusthavebeencreatedbyarulethatimpliesthataP5(w5)factalsoexists,andthismeansSecondChild′(x,y)holds.ThereasoningissimilarforChild?′(x,y).ObservethatbythefactthatIisamonadicexpansiontreeandbyminimality,theinstanceIcontains,foreachnodexofT,oneortwoCfactswithxasfirstposition.Ifxisnotaleaft,thereisonefactwhichwouldbetheparentofanx;thiswouldbeconnectedtoaP3atom.Ifxisnottheroot,anotherfactwouldbeeitherafirstchildofx,connectedtoaP4atom,orasecondchild,connectedtoaP5atomintheschemaofFig.4.Keepinmindthattherootcannotbealeaf.Furthermore,becauseofthestructureoftheMDLprogramQ′1,thetreeT(I)whichwitnessesthatIisamonadicexpansiontreewillhavethefollowingproperty:ifChild′(x,y)holds,thenxisanoutputelementofabagthatisanancestorofthebagwhoseoutputelementisy.FollowingthedefinitionoftreesinSection2.3,wecheckthatTisindeedanordered,labeled,binarytree.(i)Wehavealreadyshownthateachnodehasexactlyonelabel.(ii)WehaveestablishedthatleafnodescouldnothaveaC(_,_,_,u3,_,_,_)factsuchthatP3(u3)holdsinI,whichmeanstheycannotbeaparentinT.Ontheotherhand,allinternalnodeshaveexactlyonefirstchildandonesecondchildinT.Similarly,afirstchildcannotbeasecondchild.(iii)Everynon-rootchildhasaCfactineitherfirstorsecondchildpositioninIandhasthusexactlyoneparentinT.(iv)Anodecannotbeachildofitself:ifChild′(x,y)holds,x,ysincetheyareoutputelementsofdifferentbags.(v)Wehavealreadyshownthattherootrisunique.TheformulaψRootguaranteesthatChild′(x,r)doesnothold,whichexactlymeansthatrdoesnothaveaparentinT.Finally,sinceIdoesnotsatisfyQ′2,TdoesnotsatisfyQ,whichconcludestheproof.□BPROOFOFTHEOREM5.11Theorem5.11.TheproblemofUCQcontainmentunderlimitedaccesspatternsisEXPTIME-hard.Thehardnessholdsevenifeveryaccesshasatmostoneoutputposition.Proof.LetQbeaunionofconjunctivequeriesovertreesofSbinCh1,Ch2.Weconstructinpolynomial-timetwoUCQsoversomeschemawithaccessmethods,suchthatcontainmentunderlimitedaccessholdsifandonlyifQisvalidoveralltrees.WethenconcludeusingCorollary5.7.WebuildaschemaSsuchthatanymonadicexpansiontreeencodesabinarytree.LetRbearelationofarity4suchthatthefirstpositionindicatestheparentrelation,thesecondandthirdpositionsindicatetheFirstChildandSecondChildrelations,andthelastpositionencodesthelabelofthenode.TheaccessmethodassociatedwithRhasasinputthelastthreepositionsandforoutputthefirstposition.LetRαforα∈Λbeasetofunaryrelations,witheachoftheserelationshavingafreeaccessmethod.LetRRootandRLeafbetwounaryrelations.ThefirstrelationhasaBooleanaccessmethod,whilethesecondrelationhasafreeaccessmethod.Notethateveryaccesshasatmostoneoutputposition.TherelationFirstChild(x,y)issimulatedbytheformulaφFirstChild(x,y)=∃z∃wR(x,y,z,w).TherelationSecondChild(x,y)issimulatedbytheformulaφSecondChild(x,y)=∃z∃wR(x,z,y,w).TherelationPα(x)issimulatedbytheformulaφα(x)=∃y∃z∃wR(x,y,z,w)∧Rα(w).TherelationRoot(x)issimulatedbytheformulaφRoot(x)=RRoot(x).TherelationLeaf(x)issimulatedbytheformulaφLeaf(x)=∃y∃z∃wR(x,y,z,w)∧RLeaf(y)∧RLeaf(z).Wedenotebyq2thequeryobtainedbyreplacinginQtherelationsofSbinCh1,Ch2bytheassociatedformulas.Thequeryq1isthedisjunctionofthefollowingforbiddenpatternsofthemonadicexpansiontree:(1)AvalueinthesecondorthirdpositionofRappearsintherelationsRα:(cid:220)α∈Λ[∃x∃y∃z∃w(R(x,y,z,w)∧Rα(y))∨(R(x,y,z,w)∧Rα(z))].(2)AvalueinthefourthpositionofRappearsintherelationRLeaforinthefirstpositionofanR-fact:∃x∃y∃z∃wR(x,y,z,w)∧(RLeaf(w)∨∃y′∃z′∃w′R(w,y′,z′,w′)).(3)AfactofRhasavalueinitssecondpositionappearinginRLeafandavalueinitsthirdpositionappearingasthefirstpositioninanotherRfact,andconverselywithsecondandthirdreversed:∃x∃y∃z∃w∃y′∃z′∃w′R(x,y,z,w)∧RLeaf(y)∧R(z,y′,z′,w′)∨R(x,y,z,w)∧RLeaf(z)∧R(y,y′,z′,w′).Weclaimthatq0=∃xφRoot(x)iscontainedinq1∧q2undertheaccessconstraintsiffQisvalidovertreesinSbinCh1,Ch2.LetusfirstassumeTisatreeonSbinCh1,Ch2thatdoesnotsatisfyqueryQ.WedefineItherelationalinstanceonSformedof:•foreachleafpofTwithlabelα,factsR(p,q,r,s),RLeaf(q),RLeaf(r),andRα(s)forsomefreshconstantsq,r,s;•foreachinternalnodepofTwithlabelαandchildrenqandr,factsR(p,q,r,s)andRα(s)forsomefreshconstants;•fortherootrofTafactRRoot(r).First,observethatAccFacts(I)=I.Indeed,allfactsoftheRLeafandRαareaccessiblesincetheserelationshaveafreeaccessmethod.Furthermore,theRfactassociatedtoeachleafisaccessibleusingtheRLeafandRαfactsasinputsoftheaccessmethodonR,andtheRfactassociatedtoaninternalnodeisaccessibleaslongastheRfactsassociatedwiththechildrenofthatnodeareaccessible.WecanthusshowbyinductiononthedepthofthetreethateveryRfactisaccessible.Similarly,theRRootfactisaccessibleoncetheRfactcorrespondingtotherootisaccessible.WethenshowthatI|=q0whileI̸|=q1∧q2,whichwillwitnessthatq0isnotcontainedinq1∧q2undertheaccessconstraints.ItisclearthatI|=q0.Now,observethatnoneoftheforbiddenpatternsofq1ispresentinI,whichmeansI̸|=q1.Now,IissimplyarelationalencodingofTand,byconstruction,I|=q2ifandonlyifT|=Q,whichwenownottohold.ThismeansI̸|=q1∧q2.Conversely,assumesomeinstanceIofSisawitnessofnon-containmentofq0inq1∧q2underaccessconstraints.Wecanassume,w.l.o.g.,Itobeamonadicexpansiontree(byCorollary2.15),andtobeminimalamongallmonadicexpansiontreeinstances;inparticular,theminimalityimpliesthatI=AccFacts(I).WeconstructatreeTonSbinCh1,Ch2inthefollowingmanner:•ThenodesofTarethevaluesinthefirstpositionoftherelationRinI.•Anodeqisfirst(resp.,second)childofanodepifandonlyifφFirstChild(p,q)(resp,φSecondChild(p,q))holds.•AnodepisaleafifφLeaf(p)holds.•AnodepistherootifRRoot(p)holds.•Thelabelofanodepistheαsuchthatφα(p)holds.AllthatremainstobeshownisthatTisindeedwell-defined.Oncethisisshown,sinceIisarelationalencodingofTandI|=q2ifandonlyifT|=Q,weconcludethatT̸|=QandthusthatQisnotvalidoveralltreesonSbinCh1,Ch2.So,followingthedefinitionoftreesinSection2.2,wecheckthatTisindeedanordered,labeled,binarytree.(i)SincethefourthpositionofRisaninputposition,foreveryRfactthereshouldbeafactthatprovidesthevalueinfourthpositionofthatfactinanoutputposition.Thepattern(2)ofq1preventsittobeanRLeaforRfact.TheonlyremainingpossibilityisthatofanRαfact,whichmeansforeverynodep,someφα(p)holds.SinceIisamonadicexpansiontreeandminimal,therecanonlybeonesuchRαfactforeveryRfact,andnotwoRfactscanhavethesamevalueinfirstposition.(ii)ForeveryRnode,bypattern(3)ofR,thevaluesinsecondandthirdpositioneitherbothcomefromanRLeaffact,orneithercomesfromanRLeaffact.Inthelattercase,bypattern(1)ofR,theycannotcomefromanRαfacteither,sotheymustbothcomefromtheoutputpositionofanRfact,whichmeansallnon-leafnodesindeedhavetwochildnodes.(iii)SinceIisamonadicexpansiontree,notwoRfactscanhavethesamevalueinfirstposition,andeverynon-rootnodeindeedhasauniqueparent.(iv)Again,sinceIisamonadicexpansiontree,nonodecanbeachildofitself.(v)Sinceq0holds,thereisanRRootfactinI.ByminimalityofI,isitisunique.□