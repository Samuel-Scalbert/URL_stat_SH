Do Repeat Yourself: Understanding Suﬀicient
Conditions for Restricted Chase Non-Termination
Lukas Gerlach, David Carral

To cite this version:

Lukas Gerlach, David Carral. Do Repeat Yourself: Understanding Suﬀicient Conditions for Re-
stricted Chase Non-Termination. KR 2023 - 20th International Conference on Principles of Knowl-
edge Representation and Reasoning, Sep 2023, Rhodes, Greece. pp.301-310, ￿10.24963/kr.2023/30￿.
￿hal-04212137￿

HAL Id: hal-04212137

https://hal.science/hal-04212137

Submitted on 21 Sep 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Do Repeat Yourself:
Understanding Sufficient Conditions for Restricted Chase Non-Termination
(Technical Report)

Lukas Gerlach1 , David Carral2
1Knowledge-Based Systems Group, TU Dresden, Dresden, Germany
2LIRMM, Inria, University of Montpellier, CNRS, Montpellier, France
lukas.gerlach@tu-dresden.de, david.carral@inria.fr

Abstract

The disjunctive restricted chase is a sound and complete pro-
cedure for solving boolean conjunctive query entailment over
knowledge bases of disjunctive existential rules. Alas, this
procedure does not always terminate and checking if it does
is undecidable. However, we can use acyclicity notions (suf-
ficient conditions that imply termination) to effectively apply
the chase in many real-world cases. To know if these condi-
tions are as general as possible, we can use cyclicity notions
(sufficient conditions that imply non-termination). In this pa-
per, we discuss some issues with previously existing cyclicity
notions, propose some novel notions for non-termination by
dismantling the original idea, and empirically verify the gen-
erality of the new criteria.

1

Introduction

The (disjunctive) chase (Bourhis et al. 2016) is a sound
and complete bottom-up materialization procedure to rea-
son with knowledge bases (KBs) featuring (disjunctive ex-
istential) rules. In some cases, we can apply the chase to
determine if a conjunctive query or a fact is a consequence
of a KB under standard first-order semantics.
Example 1. Consider the KB K = ⟨R, D⟩ where R is the
rule set {(1–4)} and D is the database {Engine(d)}.
Engine(x) → (cid:0)∃v.IsIn(x, v) ∧ Bike(v)(cid:1) ∨ Spare(x)

(1)

Bike(x) → ∃w.Has(x, w) ∧ Engine(w)

IsIn(x, y) → Has(y, x)
Has(x, y) → IsIn(y, x)

(2)
(3)
(4)

In this case,

We can apply the chase procedure to verify if

the
fact Spare(c) follows from K.
the re-
set with
stricted chase produces a universal model
two models for K; namely, {Engine(d), Spare(d)} and
{Engine(d), IsIn(d, fv(d)), Bike(fv(d)), Has(fv(d), d)},
where fv(d)) is a fresh term introduced to satisfy the
existential quantifier in (1). Since the second model does
not contain Spare(d), this fact is not entailed by K.

Since boolean conjunctive query entailment is undecid-
able (Beeri and Vardi 1981), the chase may not always ter-
minate. Even worse, we cannot decide if the chase termi-
nates on a particular KB or if a rule set R is acyclic (Gogacz
and Marcinkowski 2014; Grahne and Onet 2018); that is, if

the chase terminates for every KB with R. We can still ver-
ify rule set termination in practice using acyclicity notions;
that is, sufficient conditions that imply termination (Fagin
et al. 2005; Marnette 2009; Kr¨otzsch and Rudolph 2011;
Cuenca Grau et al. 2013; Carral, Dragoste, and Kr¨otzsch
2017; Baget et al. 2014; Karimi, Zhang, and You 2021).
However, if an acyclicity notion is not able to classify a rule
set R as terminating, we never know if this notion is just not
“general enough” or if the rule set is indeed non-terminating.
To address this issue, we study cyclicity notions, which
imply non-termination. As a long-term motivation, these
approaches can also help to fix potential modelling mis-
takes. To the best of our knowledge, only one such notion
has been proposed for the restricted chase variant, namely
Restricted Model Faithful Cyclicity (RMFC). Alas, many
non-terminating rule sets with disjunctions are not classi-
fied as such by this notion (Carral, Dragoste, and Kr¨otzsch
2017). Worse still, the correctness proof of RMFC does not
hold in its presented form (see Section 7). Recently, Ger-
lach and Carral have also proposed Disjunctive Model Faith-
ful Cyclicity (DMFC) for the skolem chase. Note however
that a cyclicity notion for the skolem chase is not directly a
valid condition for restricted non-termination since the for-
mer variant terminates less often than the latter.

In this paper, our overarching goal is to improve our un-
derstanding of existing cyclicity notions such as RMFC and
DMFC. We reconsider the underlying ideas and dismantle
them into an extensible framework. We provide examples to
explain how these notions work and clarify why certain tech-
nical details are necessary. As more tangible contributions,
(i) we come up with novel cyclicity notions named restricted
prefix cyclicity (RPC) and deterministic RPC (DRPC), and
(ii) we empirically evaluate the generality of these two.

To this aim, the key points of the sections are as follows:1
S3. Cyclicity sequences that guarantee never-termination by

making use of g-unblockability.

S4. Checkable conditions that ensure g-unblockability.
S5. Cyclicity prefixes that allow cyclicity sequences.
S6. The notion (D)RPC that guarantees a cyclicity prefix.
S7. Detailed relations to DMFC and RMFC in particular.
S8. Empirical evaluation of the generality of (D)RPC.

1This report features additional proof details in the appendix.

2 Preliminaries
We define Preds, Funs, Cons, and Vars to be mutually dis-
joint, countably infinite sets of predicates, function symbols,
constants, and variables, respectively. Every s ∈ Preds ∪
Funs is associated with an arity ar(s) ≥ 1. The set Terms ⊇
Cons ∪ Vars contains f (t1, . . . , tn) for every n ≥ 1, every
f ∈ Funs with ar(f ) = n, and every t1, . . . , tn ∈ Terms.
For some X ∈ {Preds, Funs, Cons, Vars, Terms} and an
expression ϕ, we write X(ϕ) to denote the set of all elements
of X that syntactically occur in ϕ.

A term t /∈ Vars ∪ Cons is functional. For a term t;
let depth(t) = 1 if t is not functional, and depth(t) =
1 + max(depth(s1), . . . , depth(sn)) if t is of the form
f (s1, . . . , sn). We write lists t1, . . . , tn of terms as t and
often treat these as sets. A term s is a subterm of another
term t if t = s, or t is of the form f (s) and s is a subterm
of some term in s. For a term t, let subterms(t) be the set of
all subterms of t. A term is cyclic if it has a subterm of the
form f (s) with f ∈ Funs(s).

An atom is an expression of the form P(t) with P a pred-
icate and t a list of terms such that ar(P) = |t|. A fact is a
variable-free atom. For a formula υ, we write υ(x) to denote
that x is the set of all free variables that occur in υ.
Definition 1. A (disjunctive existential) rule is a constant-
and function-free first-order formula of the form

∀w, x.[β(w, x) →

(cid:95)n

i=1

∃yi.ηi(xi, yi)]

(5)

where n ≥ 1; w, x, y1, . . . , and yn are pairwise disjoint
lists of variables; (cid:83)n
i=1 xi = x; and β, η1, . . . , and ηn are
non-empty conjunctions of atoms.

We omit universal quantifiers when writing rules and of-
ten treat conjunctions as sets. The frontier of a rule ρ such
as (5) is the variable set frontier(ρ) = x. Moreover, let
body(ρ) = β, let headi(ρ) = ηi for every 1 ≤ i ≤ n, and
let branching(ρ) = n. The rule ρ is deterministic if n = 1,
generating if yi is non-empty for some 1 ≤ i ≤ n, and
datalog if it is deterministic and non-generating.

A (ground) substitution is partial function from vari-
ables to ground terms; that is, to variable-free terms. We
write [x1/t1, . . . , xn/tn] to denote the substitution mapping
x1, . . . , xn to t1, . . . , tn, respectively. For an expression ϕ
and a substitution σ, let ϕσ be the expression that results
from ϕ by uniformly replacing every syntactic occurrence
of every variable x by σ(x) if the latter is defined.

For a rule ρ such as (5), let σρ be the substitution mapping
y to f ρ
i,y(x) for every 1 ≤ i ≤ n and every y ∈ yi with f ρ
i,y
a fresh function symbol unique for ⟨ρ, i, y⟩. If y uniquely
identifies the tuple ⟨ρ, i, y⟩, we also write fy(x). (This is
the case in all our examples.) The skolemization sk(ρ) of ρ
is the expression β → ((cid:87)n
i=1 ηi)σρ. For every 1 ≤ i ≤ n,
let headi(sk(ρ)) = ηiσρ.

A trigger λ is a pair ⟨ρ, σ⟩ with ρ a rule and σ a substitu-
tion with domain Vars(body(ρ)). A trigger is loaded for a
fact set F if body(ρ)σ ⊆ F. It is obsolete for F if there is
a substitution τ that extends σ such that headi(ρ)τ ⊆ F for
some 1 ≤ i ≤ branching(ρ). Let outi(λ) = headi(sk(ρ))σ
for every 1 ≤ i ≤ branching(ρ), and out(λ) = {outi(λ) |
1 ≤ i ≤ branching(ρ)}.

Engine(d)

. . . , Spare(d)⟨(1), [x/d]⟩

. . . , IsIn(d, fv(d)), Bike(fv(d))⟨(1), [x/d]⟩

. . . , Has(fv(d), d)⟨(3), [x/d, y/fv(d)]⟩

Figure 1: Chase Tree for Example 1

Consider a rule set R. An R-term is a term defined using
the function symbols that occur in sk(R), some constants,
and some variables. A substitution is an R-substitution if its
range is a set of R-terms. An R-trigger is a trigger with a
rule from R and an R-substitution.

A fact set F satisfies a rule ρ if all triggers with ρ are not
loaded or obsolete for F. A knowledge base (KB) is a pair
K = ⟨R, D⟩ of a rule set R and a database D; that is, a
function-free fact set. The restricted chase on input K ex-
haustively applies the outputs of triggers that are loaded and
not obsolete in a tree with root D branching on disjunctions.

Restricted Chase We present a variant of the disjunctive
chase (Bourhis et al. 2016) where the application of rules is
restricted; that is, rules are only applicable if their heads are
not obsolete with respect to previously derived facts. More-
over, we impose an order of rule applications that prioritises
the application of (triggers with) datalog rules.
Definition 2. A chase tree T = ⟨V, E, fct, trg⟩ for a KB
⟨R, D⟩ is a directed tree where V is a set of vertices, E
is a set of edges, fct is a function mapping vertices to fact
sets, and trg is a function mapping every non-root vertex to
a trigger. Moreover, the following hold:
1. For the root r ∈ V of T , we have that fct(r) = D.
2. For every non-leaf vertex v ∈ V ; there is an R-trigger
λ = ⟨ρ, σ⟩ that is loaded and not obsolete for fct(v)
such that (i) the set fct(v) satisfies all datalog rules in
R if the rule in λ is not datalog, (ii) v has exactly n =
branching(ρ) children c1, . . . , cn (via E) with fct(ci) =
fct(v) ∪ outi(λ) and trg(ci) = λ for each 1 ≤ i ≤ n.
3. For every leaf vertex v ∈ V , the set fct(v) satisfies all of
the rules in R. For every R-trigger λ that is loaded for
fct(v) for some v ∈ V , there is a k ≥ 0 such that λ is
obsolete for fct(u) for each u ∈ V reachable from v by a
path of length k. That is, fairness.
We refer to fct(v) and trg(v) for some v ∈ V as the fact-
and trigger-label of v, respectively. Informally, we say that a
trigger (resp. a rule) is applied in a chase tree to signify that
some vertex in the tree is labelled with this trigger (resp. a
trigger with this rule).
Example 2. The KB from Example 1 only admits one chase
tree, which is depicted in Figure 1.

A branch of a chase tree T = ⟨V, E, fct, trg⟩ is a maximal
path in T starting at the root; that is, a vertex sequence B =
v1, v2, . . . where v1 is the root, ⟨vi, vi+1⟩ ∈ E for every
1 ≤ i < |B|, and the last element of B is a leaf if B is finite.
The result of T is the set {(cid:83)
v∈B fct(v) | B a branch of T };
chase results can be used to solve query entailment:

Proposition 1. Consider the result R of some (arbitrarily
chosen) chase tree of a K. Then, K entails a query γ = ∃y.β
iff F |= γ for every F ∈ R iff for every F ∈ R there is a
substitution σ with βσ ⊆ F.

Therefore, it is interesting to know if a rule set admits
finite chase trees. A rule set R terminates if every chase
tree of every KB with R is finite, it sometimes-terminates
if every KB with R admits a finite chase tree, and it never-
terminates if some KB with R that has no finite chase trees.
We use skolem function names to backtrack the facts
along which a term t appears in the chase;
that is, the
birth facts of t. For a constant c, let BirthFR(c) = ∅;
for a rule set R and an R-term t of the form f ρ
i,v(s), let
BirthFR(t) = outi(⟨ρ, σ⟩) ∪ (cid:83)
s∈s BirthFR(s) where σ is
a substitution with frontier(ρ)σ = s. For a trigger ⟨ψ, τ ⟩,
let BirthFR(⟨ψ, τ ⟩) = (cid:83)
x∈frontier(ψ) BirthFR(τ (x)). The
term-skeleton skeletonR(⟨ψ, τ ⟩) of
⟨ψ, τ ⟩ consists of
Terms(BirthFR(⟨ψ, τ ⟩)) and every constant c with c =
τ (x) for an x ∈ frontier(ψ).
Example 3. Let R = {(1), (2)} and λ = ⟨(2), [x/fv(d)]⟩.
We have BirthFR(λ) = {IsIn(d, fv(d)), Bike(fv(d))} and
skeletonR(λ) = {d, fv(d)}. (Note again that fv = f (1)

1,v.)

3 Cyclicity Sequences
In this section, we introduce the notion of a cyclicity se-
quence Λ for a KB K = ⟨R, D⟩ (see Definition 6) and show
that its existence implies that K only admits infinite chase
trees (see Theorem 1). Intuitively, Λ is an infinite sequence
of R-triggers that are applied in some (infinite) branch of ev-
ery chase tree of K. To identify these branches, we consider
the following notion from (Gerlach and Carral 2023b).
Definition 3. A head-choice for a rule set R is a func-
tion hc that maps every rule ρ ∈ R to an element of
{1, . . . , branching(ρ)}. For a rule ρ ∈ R and a trig-
ger λ with ρ, we write headhc(ρ) and outhc(λ) instead of
headhc(ρ)(ρ) and outhc(ρ)(λ), respectively. For a chase
tree T = ⟨V, E, fct, trg⟩ of a KB with R, we define
branch(T, hc) = v1, v2, . . . as the branch of T such that
fct(vi+1) = fct(vi) ∪ outhc(trg(vi+1)) for every 1 ≤ i <
|branch(T, hc)|; note that every branch starts with the root.
Cyclicity sequences must satisfy three requirements (see

Definition 6); let’s start with the first two:
Definition 4. Consider a KB K = ⟨R, D⟩, a head-choice hc
for R, and a sequence Λ = λ1, λ2, . . . of R-triggers.
• Let F0(K, hc, Λ) = D, and let Fi+1(K, hc, Λ) =

Fi(K, hc, Λ) ∪ outhc(λi+1) for every 0 ≤ i < |Λ|.

• The sequence Λ is loaded for K and hc if λi+1 is loaded

for Fi(K, hc, Λ) for every 0 ≤ i < |Λ|.

• The sequence Λ is growing for K and hc if, for every
0 ≤ i < |Λ|, there is some j > i and a term that oc-
curs in Fj(K, hc, Λ) but not in Fi(K, hc, Λ). Note that Λ
is infinite if this requirement is satisfied.
For some variants of the chase, existence of a loaded and
growing sequence of R-triggers for a KB and a head-choice
may suffice to witness non-termination. This is not the case
for the restricted chase:

Example 4. Consider the KB K = ⟨R, D⟩ from Exam-
ple 1, and the head-choice hc that maps every rule in R to
1. Moreover, consider the infinite sequence Λ = λ1, λ2, . . .
of triggers such that:
• Let t0 = d, let ti = fv(ti−1) for every odd i ≥ 1, and let

ti = fw(ti−1) for every even i ≥ 1.

• For every i ≥ 1; let λi = {(1), [x/ti−1]} if i is odd, and

λi = {(2), [x/ti−1]} otherwise.

The (infinite) sequence Λ is loaded and growing; however,
the KB K terminates! Note that this KB only admits one
chase tree, which is finite (see Example 2).

The issue in the previous example is that the second trig-
ger of Λ cannot be applied in any chase tree of K; this is
because we must apply datalog triggers with (3) before we
apply triggers with (2). To address this issue, we introduce a
third requirement for cyclicity sequences (see Definition 6):
Definition 5. Consider a KB K = ⟨R, D⟩, a head-choice hc
for R, and a sequence of R-triggers Λ = λ1, λ2, . . .
• An R-trigger λ is g-unblockable2 for K and hc if, for
every chase tree T = ⟨V, E, fct, trg⟩ and every v in
branch(T, hc) such that λ is loaded for fct(v), there is
some u in branch(T, hc) with outhc(λ) ⊆ fct(u). Intu-
itively, if λ is loaded for a vertex in the hc-branch of a
chase tree T of K, then its output according to hc eventu-
ally appears in this branch.

• If every trigger in Λ is g-unblockable, then this sequence

is g-unblockable for K and hc.
The sequence Λ in Example 4 is not g-unblockable be-
cause its second trigger does not satisfy this property. How-
ever, Λ is g-unblockable for a slightly different input KB:
Example 5. Consider the rule set R = {(1), (2)}; and the
database D, the head-choice hc, and the sequence Λ from
Example 4. Since R contains neither (3) nor (4), the se-
quence Λ is g-unblockable for ⟨R, D⟩ and hc. Note that the
KB ⟨R, D⟩ only admits one chase tree, which is infinite, and
hence, R is never-terminating.

We are ready to define cyclicity sequences:

Definition 6. A sequence Λ = λ1, λ2, . . . of R-triggers is a
cyclicity sequence of a KB K = ⟨R, D⟩ and a head-choice
hc if Λ is (infinite,) loaded, growing, and g-unblockable.
Note that Λ is infinite if it is growing.
Theorem 1. A rule set R never-terminates if there is a
cyclicity sequence for a KB with R and some head-choice.

Proof. Assume that there is a cyclicity sequence Λ =
λ1, λ2, . . . of some KB such as K = ⟨R, D⟩ and some
head-choice hc, and consider some chase tree T =
⟨V, E, fct, trg⟩ of ⟨R, D⟩ and the sequence branch(T, hc) =
v1, v2, . . . To show the theorem, we prove that the fact set
F(T, hc) = (cid:83)
i≥0 fct(vi) is infinite, which implies that both
branch(T, hc) and T are infinite. This holds by infinity of
(cid:83)
i≥0 Fi(K, hc, Λ) (since Λ is growing) and Fi(K, hc, Λ) ⊆
F(T, hc) for every i ≥ 0 (which follows by induction since
Λ is loaded and g-unblockable.)

2The “g-” prefix stands for “general-”; we introduce more spe-

cific unblockability notions in the following section.

4

Infinite Unblockable Sequences

Theorem 1 provides a blueprint to show never-termination
of a rule set R: One “simply” has to show that R admits
a cyclicity sequence (see Section 6). To show that such se-
quences exist, we have developed techniques to find infinite
sequences of triggers that are g-unblockable. This is a rather
challenging task; note that we cannot even decide if a single
trigger is g-unblockable (by reduction from fact entailment
(Beeri and Vardi 1981)):
Theorem 2. The problem of deciding if a trigger is g-
unblockable for a KB and a head-choice is undecidable.

In this section, we first discuss ways to detect if a trig-
ger is g-unblockable in some cases. Then, we devise strate-
gies to show that some infinite sequences of triggers are g-
unblockable, i.e. that unblockability “propagates”.

Detecting Unblockability To detect if a trigger λ is g-
unblockable, we make use of chase over-approximations be-
fore the application of λ:
Definition 7. Consider a rule set R, a head-choice hc,
and some R-trigger λ = ⟨ρ, σ⟩. A fact set F is an over-
approximation of R and hc before λ if there is a function h
over the set of terms such that (i) h(σ(x)) = σ(x) for each
x ∈ frontier(ρ) and, (ii) for every u ∈ branch(T, hc) in ev-
ery chase tree T = ⟨V, E, fct, trg⟩ of every KB ⟨R, D⟩ with
outhc(λ) ⊈ fct(u), we have that h(fct(u)) ⊆ F.

Intuitively, a chase over-approximation such as F above
for R and hc before λ is some sort of “upper-bound” of all
of the facts that can possibly occur in the label of a vertex
in the hc-branch if this label does not include the output of
λ. If λ is not obsolete for F, its output eventually appears in
the hc-branch of the chase:
Lemma 1. If λ is not obsolete for some over-approximation
of a rule set R and a head-choice hc before λ, then λ is
g-unblockable for hc and every KB with R.

Proof. To show the contrapositive, we assume that λ =
⟨ρ, σ⟩ is not g-unblockable for some ⟨R, D⟩ and hc. Then,
there exists a chase tree T = ⟨V, E, fct, trg⟩ of ⟨R, D⟩ and
hc such that (i) λ is loaded for some v ∈ branch(T, hc) and
(ii) outhc(λ) ⊈ fct(u) for every u ∈ branch(T, hc). More-
over, λ is obsolete for fct(w) for some w ∈ branch(T, hc)
by Definition 2. By Definition 7, we find h(fct(w)) ⊆ F for
every over-approximation F of R and hc before λ with term
mapping h. Then, ⟨ρ, h ◦ σ⟩ is obsolete for F; hence so is λ
since h ◦ σ and σ agree on all frontier variables of ρ.

Lemma 1 provides a strategy to detect g-unblockability
for a given trigger λ: Compute some over-approximation
F and then check if λ is obsolete for F. We consider two
alternative ways of computing these over-approximations:
Definition 8. For a trigger λ, let h⋆
λ be the function over
the set of terms that maps every t ∈ skeletonR(λ) to itself
and every other term to the special constant ⋆. Moreover,
let huc
λ be another such function that maps every functional
term f (t) /∈ skeletonR(λ) to a fresh constant cf , every term
in skeletonR(λ) and every constant of the form cf to itself,
and every other term to ⋆.

For a rule set R, a head-choice hc, some R-trigger λ =
λ }; let O(R, hc, λ, h) be the

⟨ρ, σ⟩, and some h ∈ {h⋆
minimal fact set that
1. contains every fact that can be defined using a predicate
occurring in R and constants in skeletonR(λ) ∪ {⋆},

λ, huc

2. includes BirthFR(λ), and
3. includes h(outhc(λ′)) for every R-trigger λ′ such that λ′
is loaded for O(R, hc, λ, h) and outhc(λ′) ̸= outhc(λ).
Moreover, we define O(R, λ, h) as the minimal fact set that
satisfies (1) and (2) above, and includes h((cid:83) out(λ′)) for
every R-trigger λ′ = ⟨ψ, τ ⟩ such that λ′ is loaded for
O(R, λ, h) and if ψ = ρ, then outi(λ′) ̸= outi(λ) for some
1 ≤ i ≤ branching(ρ).

Intuitively, O(R, λ, h) views outputs as if disjunctions

λ ) equals

were replaced by conjunctions in rules.
Example 6. For the rule set R = {(1), (2)}, the head-choice
hc1 : R → {1}, some constant d, and the trigger λ =
⟨(2), [x/fv(d)]⟩; the set O(R, hc1, λ, huc
{Engine(s), Bike(s), Spare(s), IsIn(s, t) | s, t ∈ {⋆, d}} ∪
BirthFR(λ) ∪ {IsIn(⋆, cv), Bike(cv), Has(⋆, cw),
Has(d, cw), Engine(cw), IsIn(cw, cv), Has(cv, cw)}.
In the above, we write cv and cw to refer to the fresh
constants unique for fv and fw, respectively. Note that
O(R, hc1, λ, huc
λ ) does not contain IsIn(d, cv) since huc
λ
maps fv(d) to itself, or Has(fv(d), cw) since this fact is in
the output of a trigger excluded by Item 3 in Definition 8.
The set O(R, λ, huc
λ ) and addi-
tionally contains Spare(cw). If we replace all occurrences
of cv and cw in O(R, hc1, λ, huc
λ )) with
⋆, we obtain O(R, hc1, λ, h⋆
Lemma 2. For a rule set R, a head-choice hc, an R-trigger
λ = ⟨ρ, σ⟩, and some h ∈ {h⋆
λ }; O(R, hc, λ, h) and
O(R, λ, h) are over-approximations of R and hc before λ.

λ ) (resp. O(R, λ, huc
λ)).

λ ) includes O(R, hc1, λ, huc

λ) (resp. O(R, λ, h⋆

λ, huc

Proof. We show a more general claim; namely, we con-
sider any h such that (a) h(σ(x)) = σ(x) for each x ∈
frontier(ρ), (b) h(f (h(s))) = h(f (s)) for every functional
term f (s), (c) h ◦ h = h, and (d) h maps every constant that
may occur in a database to a constant in skeletonR(λ)∪{⋆}.
Note that the above hold for h⋆

λ by Definition 8.

λ and huc

We show that O(R, hc, λ, h) is an over-approximation of
R and hc before λ. The first condition of Definition 7 holds
for h by assumption (a). For every u ∈ branch(T, hc) in
every chase tree T of every KB ⟨R, D⟩, we can verify the
second condition via induction on the path from the root of
T to u assuming that outhc(λ) ⊈ fct(u) and invoking (b-d).
For the second part of the claim, O(R, λ, h) is an over-
approximation of R and hc before λ since O(R, hc, λ, h) ⊆
O(R, λ, h) by Definition 8.

Using the over-approximations from Definition 8, we de-

fine two different types of unblockability:
Definition 9. Consider a rule set R and an R-trigger λ.
Then, λ is ⋆-unblockable for R if it features a datalog rule
or it is not obsolete for O(R, λ, h⋆
λ). Moreover, it is uc-
unblockable for R and some hc if it features a datalog rule
or it is not obsolete for O(R, hc, λ, huc

λ ).

Example 7. Consider the rule set R = {(1), (2)} and the
head-choice hc1 mapping all rules to 1. The trigger λ =
⟨(2), [x/fv(d)]⟩ is uc-unblockable for R and hc1; it is not
for R′ = R ∪ {(3)} and hc1. Note that O(R′, hc1, λ, huc
λ )
includes O(R, hc1, λ, huc
λ ) ∪ {Has(fv(d), d)} (among other
facts). Therefore, λ is obsolete for O(R′, hc1, λ, huc
λ ) but not
for O(R, hc1, λ, huc

λ ).

By Theorem 2, we cannot decide if a trigger λ is g-
unblockable. However, we can effectively check ⋆- or uc-
unblockability; both properties imply g-unblockability:

Lemma 3. If an R-trigger λ is ⋆-unblockable for a rule set
R, it is uc-unblockable for R and every head-choice. If λ
is uc-unblockable for R and some head-choice hc, then it is
g-unblockable for R and hc.

Proof. The first implication holds since O(R, λ, h⋆
λ) in-
cludes h(O(R, hc, λ, huc
λ )) with h the function that maps ev-
ery fresh constant in the range of huc
λ to ⋆. For the second,
note that a trigger λ with a datalog rule is g-unblockable. For
the non-datalog case, we can apply Lemmas 1 and 2.

By Lemma 3, a trigger is g-unblockable if it

is ⋆-
unblockable; we can also prove this directly with Lemmas 1
and 2. By Lemma 3, uc-unblockability is more general than
⋆-unblockability; the other direction does not hold:

Example 8. Consider the following rule set R:

R(x, y) → ∃u.R(y, u)
R(x, y) → ∃v.S(y, v)
R(x, y) → ∃w.T (y, w)
S(x, y) ∧ T (x, y) → R(x, y)

(6)
(7)
(8)
(9)

The trigger ⟨(6), [x/cy, y/fu(cy)]⟩ is uc-unblockable but
not ⋆-unblockable: We find S(fu(cy), ⋆), T (fu(cy), ⋆) and
therefore R(fu(cy), ⋆) in O(R, hc, λ, h⋆
λ). On the other
hand, we only find S(fu(cy), cv) and T (fu(cy), cw) but no
fact of the form R(fu(cy), . . . ) in O(R, hc, λ, huc

λ ).

Carral, Dragoste, and Kr¨otzsch and Gerlach and Carral
introduce similar notions to ⋆-unblockability in (2017) and
(2023b). Here, we not only present a more general criterion
(see Definition 9), but a blueprint to produce more compre-
hensive notions (see Definitions 7, 8 and Lemmas 1, 2).

Propagating Unblockability A key feature of uc/⋆-
unblockability is that these properties propagate across a re-
versible constant-mappings: (Gerlach and Carral 2023b)

Definition 10. A constant mapping g is a partial function
mapping constants to terms. For an expression ϕ, let g(ϕ)
be the expression that results from replacing all syntactic
occurrences of every constant c in the domain of g with g(c).
Consider a (possibly finite) set T of terms that contains
every subterm of every t ∈ T . A constant mapping g is
reversible for T if the following hold:

1. The function g is defined for every constant in T .
2. For every t, s ∈ T with t ̸= s, we have that g(t) ̸= g(s).
3. For every constant c ∈ T , every subterm s of g(c), and
every functional term u ∈ T ; we have that g(u) ̸= s.

Lemma 4. Consider a rule set R, a head-choice hc, an R-
trigger λ = ⟨ρ, σ⟩, and a constant mapping g reversible
for skeletonR(λ). If ⟨ρ, g ◦ σ⟩ is an R-trigger and ⟨ρ, σ⟩ is
uc/⋆-unblockable for R [and hc], then so is ⟨ρ, g ◦ σ⟩.

defined

and G′ of all
predicate
any

Consider
be
constants

Proof. We define g−1 as follows: For a term t, let g−1(t) =
s if there is a term s that occurs in skeletonR(λ) with g(s) =
t, g−1(t) = t otherwise if t is a constant that does not occur
in Cons(skeletonR(⟨ρ, g ◦ σ⟩)) (i.e. g−1 is the identity on
fresh constants introduced by huc
...), and g−1(t) = ⋆ other-
wise. Note that g−1 is well-defined because g is reversible
(cond. 2) for skeletonR(λ).
the sets F ′
using

that
in R and
can
the
and
Cons(skeletonR(⟨ρ, g ◦ σ⟩)) ∪ {⋆}, respectively. More-
over, consider the fact sets: F = BirthFR(λ) ∪ F ′ and
G = BirthFR(⟨ρ, g ◦ σ⟩) ∪ G′. Also, let the functions
⟨hF , hG⟩ be from {⟨h⋆

⟨ρ,g◦σ⟩⟩, ⟨huc
First claim: g−1(G) ⊆ F. Since g−1(G′) ⊆ F follows
trivially, we only show g−1(BirthFR(t)) ⊆ F for every t ∈
Terms(G) via induction over the structure of terms. If t is
a constant, then g−1(BirthFR(t)) = ∅; hence, the base case
trivially holds. Regarding the induction step, consider a term
t that is of the form f ψ

Cons(skeletonR(λ)) ∪ {⋆}

⟨ρ,g◦σ⟩⟩}.

λ , huc

λ, h⋆

facts

in

ℓ,y(s):

ℓ,z′(s)) = f ψ

Let z be the list of existentially quantified variables in
headℓ(ψ). Let τ be a substitution with frontier(ψ)τ = s.
Moreover, let H = headℓ(ψ)τ . We only need to show
that g−1(H) ⊆ F to verify the induction step. We ob-
serve: If g−1(f ψ
ℓ,z(s)) is functional for some z ∈ z, then
g−1(f ψ
ℓ,z′(g−1(s)) for each z′ ∈ z (†). Now,
we perform a case by case analysis on g−1(t): If g−1(t)
is a functional term, then g−1(H) = g−1(headℓ(ψ)τ ) =
headℓ(ψ)(g−1 ◦ τ ) ⊆ F (by †). If g−1(t) ∈ Cons \ {⋆},
then g−1(f ψ
ℓ,z(s)) must be a constant for every z ∈ z (by
†). Since g is reversible for skeletonR(λ) (cond. 3), g−1(s)
is also a constant (possibly ⋆) for every s ∈ s. Hence,
g−1(H) ⊆ F ′ ⊆ F. If g−1(t) = ⋆ and g−1(t′) is a constant
(or ⋆) for every t′ ∈ Terms(H), then g−1(H) ⊆ F ′ ⊆ F.
The remaining case of g−1(t) = ⋆ and g−1(t′) /∈ Cons for a
t′ ∈ Terms(H), contradicts reversibility of g (cond. 3) since
then, there must be a constant c with t′ ∈ subterms(g(c)).

Second claim: The set g−1(O(R, [hc, ]⟨ρ, g ◦ σ⟩, hG))
is a subset of O(R, [hc, ]λ, hF ).
There exists a fi-
triggers ⟨ψ1, τ1⟩, . . . , ⟨ψm, τm⟩ that yields
nite list of
O(R, [hc, ]⟨ρ, g ◦ σ⟩, hG) from G according to Definition 8.
With the first claim as a base case, we can show via induction
that the triggers ⟨ψ1, g−1 ◦ τ1⟩, . . . , ⟨ψm, g−1 ◦ τm⟩ can be
used in the construction of O(R, [hc, ]λ, hF ).

We conclude that ⟨ρ, g ◦ σ⟩ is uc/⋆-unblockable for R
[and hc] as follows: Suppose for a contradiction that
⟨ρ, g ◦ σ⟩ is not uc/⋆-unblockable. Then, ρ is not data-
log and ⟨ρ, g ◦ σ⟩ is obsolete for O(R, ⟨ρ, g ◦ σ⟩, h⋆
⟨ρ,g◦σ⟩)
[resp. O(R, hc, ⟨ρ, g ◦ σ⟩, huc
⟨ρ,g◦σ⟩)]. By the second claim
above, we obtain that λ is obsolete for O(R, λ, h⋆
λ) [resp.
O(R, hc, λ, huc
λ )]. Hence, λ is not uc/⋆-unblockable which
contradicts the premise of the lemma.

Condition 2 in Definition 10 admits an “inverse” of g on

term-level. Lemma 4 breaks without it:
Example 9. Consider the rule set R = {(10–13)} and the
head-choice hc1 mapping all rules to 1.

P (x, y) → ∃u.R(x, u) ∧ S(y, u)
R(x, y) → ∃v.T (y, v)

R(x, y) ∧ S(x, y) → T (y, x)
T (x, y) → P (y, y)

(10)
(11)
(12)
(13)

Consider the substitution σ = [x/cx, y/fu(cx, cy)]; the
trigger ⟨(11), σ⟩, which is uc-unblockable for R and hc1;
and the constant mapping g that maps cx and cy to
fv(fu(cx, cy)), which does not satisfy (2) in Definition 10
for T = skeletonR(⟨(11), σ⟩). Indeed, ⟨(11), g ◦ σ⟩ is not
uc-unblockable! Intuitively, rule (12) “blocks” rule (11) if
rule (10) is applied with a substitution that maps x and y to
the same term, which is the case for g ◦ σ.

Lemma 4 also breaks without condition 3:

Example 10. Consider the head-choice hc1 mapping all
rules to 1, and the rule set R containing the following:

A(x) → ∃u.P (x, u)
C(x) → ∃w.S(x, w)

B(x) → ∃v.Q(x, v)
Q(x, y) → T (x)

P (x, y) → T (y) ∨ ∃z.R(x, y, z)

(14)

The trigger ⟨(14), [x/c, y/fu(d)]⟩ is uc-unblockable; the
constant mapping g that maps c to fw(fv(fu(d))) and
d to itself satisfies conditions (1) and (2) in Defini-
tion 10 for T = skeletonR(⟨(14), [x/c, y/fu(d)]⟩). Con-
dition (3) is violated because fu(d) is a subterm of g(c) and
g(fu(d)) = fu(d). Indeed, ⟨(14), g ◦ [x/c, y/fu(d)]⟩ is not
uc-unblockable! Intuitively, this is because the birth facts
feature Q(fu(d), fv(fu(d))), which yields T (fu(d)), thus
“blocking” the trigger ⟨(14), [x/fw(fv(fu(d))), y/fu(d)]⟩.

5 Cyclicity Prefixes
Our high-level strategy to show that a rule set R never-
terminates is to find a cyclicity sequence (see Definition 6
and Theorem 1), which is challenging because it is infinite
by definition. Instead, we construct a cyclicity prefix for R,
which is finite and still yields a cyclicity sequence.

Intuitively, a cyclicity prefix is a (finite) list of uc-
unblockable triggers that, if subsequently applied to a start-
ing database D, produce an isomorphic copy of D that con-
tains at least one new term. We can then repeat the prefix
to obtain a cyclicity sequence. To limit the number of start-
ing databases, we only consider minimal databases for that
some trigger with a generating rule in R is loaded.
Definition 11. The rule-database of a rule ρ is the database
Dρ = body(ρ)σuc where σuc is a substitution that maps ev-
ery variable x to a fresh constant cx unique for x.

Assume that rule ρ can indeed be applied twice when
starting on Dρ and that the second application yields a cyclic
term. If the triggers applied in between the first and last ap-
plication of ρ are uc-unblockable, then this finite sequence
of triggers is a cyclicity prefix, which can be extended into a
cyclicity sequence by applying Lemma 4.

Definition 12. A cyclicity prefix for a rule set R, a head-
choice hc, and a rule ρ is a (finite) list of R-triggers Λ =
⟨ρ0, σ0⟩, . . . , ⟨ρn, σn⟩ such that:
• Both ρ0 = ρ and σ0 agrees with σuc on frontier(ρ).
• The sequence Λ is loaded for ⟨R, Dρ⟩ and hc.
• Each trigger ⟨ρi, σi⟩ with 1 ≤ i ≤ n is uc-unblockable

and ⟨ρ0, σ0⟩ is g-unblockable.

• Both ρn = ρ and outhc(⟨ρn, σn⟩) features a ρ-cyclic
term; that is, a term t that of the form f (s) with f ∈
Funs(sk(ρ)) and f ∈ Funs(s),

• The constant mapping gΛ with gΛ ◦ σ0 = σn exists and is
Λ ◦ σi⟩) for every 1 ≤ i ≤
Λ is the identity function
for every i ≥ 1.
Λ

reversible for skeletonR(⟨ρi, gj
n and every j ≥ 0. Note that g0
Λ = gΛ ◦ gi−1
over constants, and gi
We can extend a cyclicity prefix such as Λ above into an
infinite sequence of triggers that are defined via composition
with the constant-mapping gΛ; afterwards, we show that this
extension is a cyclicity sequence.
Definition 13. Given a cyclicity prefix Λ = ⟨ρ0, σ0⟩, . . . ,
⟨ρn, σn⟩ for a rule set R, a head-choice, and a rule in
R; let Λ∞ be the (infinite) sequence ⟨ρ0, σ0⟩, ⟨ρ1, σ1
1⟩,
1⟩, . . . , ⟨ρn, σ2
n⟩, ⟨ρ1, σ2
. . . , ⟨ρn, σ1
n⟩, . . . of R-triggers with
σj
i = gj−1
◦ σi for every 1 ≤ i ≤ n and j ≥ 1.
Example 11. The finite trigger sequence ⟨(1), [x/cx]⟩,
⟨(2), [x/fv(cx)]⟩, ⟨(1), [x/fw(fv(cx))]⟩ is a cyclicity prefix
for the rule set {(1), (2)}, head-choice hc1, and (1).
Theorem 3. If Λ is a cyclicity prefix for a rule set R, a head-
choice hc, and some ρ ∈ R; then Λ∞ is a cyclicity sequence
for ⟨R, Dρ⟩ and hc and hence, R never-terminates.

Λ

Proof. Assume that
there is a cyclicity prefix Λ =
⟨ρ0, σ0⟩, . . . , ⟨ρn, σn⟩ for R, ρ, and hc; and consider the
constant-mapping gΛ introduced in Definition 12. To prove
Theorem 3, we show that Λ∞ is a cyclicity sequence of the
KB K = ⟨R, Dρ⟩ and hc. Namely, we argue that Λ∞ is (a)
loaded, (b) growing, and (c) g-unblockable.
(a): We show that the trigger ⟨ρi, σj

i ⟩ is loaded in Λ∞
for every 1 ≤ i ≤ n via induction on j ≥ 1. The base
case holds since Λ is loaded. The induction step from j − 1
to j holds since gΛ(F(j−1)×n+i(K, hc, Λ∞)) is included in
Fj×n+i(K, hc, Λ∞).

(b): Since outhc(⟨ρn, σn⟩) features a ρ-cyclic term, there
is some x ∈ frontier(ρ) such that σn(x) = gΛ(σ0(x)) is
functional. Note that σ0(x) is a constant c, depth(c) = 0
and depth(gΛ(c)) ≥ 1. Furthermore, gΛ(c) features c as
a subterm. Hence, gk
Λ (c) for every k ≥ 1. But
then, by construction of Λ∞, gk
Λ(c) occurs in Fj(K, hc, Λ∞)
for some j ≥ 0. Thus, Λ must be growing.

Λ(c) > gk−1

(c): We already know by assumption that ⟨ρ0, σ0⟩ is g-
unblockable. We can show via induction over j ≥ 1 that
⟨ρi, σj
i ⟩ is uc/⋆-unblockable for every 1 ≤ i ≤ n. For the
base case with j = 1, the claim holds by assumption. For
the induction step from j to j + 1, the claim follows from
Lemma 4 since gλ is reversible for skeletonR(⟨ρi, σj
i ⟩). By
Lemma 3, the sequence Λ∞ is g-unblockable.

6 Novel Cyclicity Notions
Theorem 3 provides a blueprint to show non-termination of
a rule set R: One simply has to show that R admits a (fi-
nite) cyclicity prefix. In this section, we present two differ-
ent ways to do so, namely RPC and DRPC, which we then
use to define several cyclicity notions.

Restricted Prefix Cyclicity We introduce restricted
prefix-cyclicity as the most general notion that we can de-
fine using our previous considerations:

Definition 14. For a rule set R, a head-choice hc, and a
rule ρ ∈ R; let RPC(R, hc, ρ) be the fact set that includes
the database Dρ, the set outhc(⟨ρ, σuc⟩), and outhc(λ) for
every R-trigger λ = ⟨ψ, τ ⟩ such that

• there are no cyclic terms in the range of τ ,
• the trigger λ is loaded for RPC(R, hc, ρ),
• the trigger λ is uc-unblockable for R and hc, and
• the substitution σ is injective if ψ = ρ.

A rule set R is restricted prefix-cyclic (RPC) if there is
some head-choice hc, some (generating rule) ρ ∈ R, and
some ρ-cyclic term that occurs in RPC(R, hc, ρ).

The first restriction ensures that RPC(R, hc, ρ) is fi-
nite. The second and third are necessary by Definition 12.
Note that ⟨ρ, σuc⟩ also needs to be g-unblockable but it is
not uc-unblockable by definition. We show later that g-
unblockability for ⟨ρ, σuc⟩ still follows if we can find a ρ-
cyclic term. The fourth restriction ensures that we can find
a reversible constant mapping for the cyclicity-prefix. Ex-
ample 9 shows a rule set that is terminating but would be
wrongly marked as RPC if we omit the fourth restriction.

Theorem 4. If a rule set R is RPC, then it never-terminates.

Proof. By Definition 14, there exists a finite trigger se-
quence Λ = ⟨ρ, σuc⟩, λ1 = ⟨ρ1, σ1⟩, . . . , λn = ⟨ρn, σn⟩ that
yields a (first) ρ-cyclic term in RPC(R, hc, ρ) with ρn = ρ
and no cyclic term in the image of every substitution σi for
1 ≤ i ≤ n, and a constant mapping gΛ for that we find
gΛ ◦ σuc = σn. Furthermore, Λ is loaded for ⟨R, Dρ⟩ and
hc, and the triggers λ1, . . . , λn are uc-unblockable.

To prove that Λ is a cyclicity-prefix for R, hc, and
ρ, it only remains to show that (A) gΛ is reversible for
skeletonR(⟨ρi, gj
Λ ◦ σi⟩) for each 1 ≤ i ≤ n and j ≥ 0
and that (B) ⟨ρ, σuc⟩ is g-unblockable.

(A): Considering Definition 10, we show conditions (1),
(2), and (3). Since Cons(skeletonR(⟨ρi, gj
Λ ◦ σi⟩)) may
only feature constants from Dρ, (1) holds. For (2) and (3),
we make the following observations:

The substitutions of the triggers in Λ do not feature
cyclic terms. Hence, for every constant c in Dρ,
the
term gΛ(c) does not feature nested function symbols from
3 We show that, for any functional term t in
sk(ρ).
skeletonR(⟨ρi, gj
Λ ◦ σi⟩) (for any j and i), the term g(t)

3Consider the rule ρ = A(x) → ∃y, z.R(x, y) ∧ S(x, z).
Then, fy(fz(c)) features nested function symbols from sk(ρ) but
fw(fy(d), fz(c)) does not (assuming w occurs in another rule).

features nested function symbols from sk(ρ): Every non-
datalog trigger without functional terms in frontier posi-
tions is not uc-unblockable. Hence, t must have a sub-
term of the form f (c) such that f occurs in sk(ρ) and
c = σuc(frontier(ρ)). Also, for some x ∈ frontier(ρn),
gΛ(σuc(x)) is a functional term from outhc(⟨ρ, σuc⟩). Thus,
f (gΛ(c)) ∈ subterms(g(t)) features nested function sym-
bols from sk(ρ).

By Definition 14, gΛ ◦ σuc is injective and in turn gΛ is
injective on the constants in Dρ. We show (2) that gΛ(t) ̸=
gΛ(s) for every t, s in skeletonR(⟨ρi, gj
Λ ◦ σi⟩) with t ̸= s:
If t and s are constants, then gΛ(t) ̸= gΛ(s) since gΛ is
injective. If t is a constant and s is functional (or vice versa),
then gΛ(s) features nested function symbols from sk(ρ) and
gΛ(t) does not (or vice versa) by the above observations.
If t and s are functional terms of the form f (t) and h(s),
respectively, with f ̸= h; then gΛ(t) ̸= gΛ(s) holds.
If
t and s are functional terms (of finite depth) of the form
f (t1, . . . , tn) and f (s1, . . . , sn), respectively; then ti ̸= si
for some 1 ≤ i ≤ n since t ̸= s and we can recurse into one
of the cases for ti, si.

For (3), consider c ∈ Cons(skeletonR(⟨ρi, gj

Λ ◦ σi⟩)) ⊆
Cons(Dρ) and some s ∈ subterms(gΛ(c)). If there was a
functional term u ∈ skeletonR(⟨ρi, gj
Λ ◦ σi⟩) with gΛ(u) =
s, we obtain a contradiction from the above observations,
as s ∈ subterms(gΛ(c)) does not feature nested function
symbols from sk(ρ) but gΛ(u) = s does. Thus, (A) holds.

(B): In the remainder of the proof, we show that ⟨ρ, σuc⟩ is
g-unblockable for ⟨R, Dρ⟩ and hc. Suppose for a contradic-
tion that ⟨ρ, σuc⟩ is not g-unblockable. We obtain the contra-
diction by showing that ⟨ρ, gΛ ◦ σuc⟩ is not uc-unblockable.
There exists a chase tree T = ⟨V, E, fct, trg⟩ for
⟨R, Dρ⟩ and hc such that outhc(⟨ρ, σuc⟩) ⊈ fct(u) for
each u ∈ branch(T, hc). Note that ⟨ρ, σuc⟩ is loaded
for fct(v) for every v ∈ branch(T, hc) since it is loaded
for Dρ. There must exists a (first) w ∈ branch(T, hc)
such that ⟨ρ, σuc⟩ is obsolete for fct(w). Consider the
path v0, . . . , vm in T with v0 the root and vm = w.
Let ⟨ψ1, τ1⟩, . . . , ⟨ψm, τm⟩ = trg(v1), . . . , trg(vm). We
aim to show that h(outhc(⟨ψi, h ◦ gΛ ◦ τi⟩)) ⊆ O for ev-
ery 1 ≤ i ≤ m where h = huc
⟨ρ,gΛ◦σuc⟩ and O =
O(R, hc, ⟨ρ, gΛ ◦ σuc⟩, h). Then, we find that ⟨ρ, gΛ ◦ σuc⟩
is not uc-unblockable, i.e. the desired contradiction.

First, we find that h(gΛ(fct(v0)) = h(body(ρ)(gΛ ◦
σuc)) ⊆ O by making use of
the triggers in Λ:
We have that h(outhc(⟨ρ, σuc⟩)) = outhc(⟨ρ, σuc⟩) ⊆
BirthFR(⟨ρ, gΛ ◦ σuc⟩). Also, h(Dρ) is contained in the set
of all facts that can be defined using any predicate and con-
stants from Cons(skeletonR(⟨ρ, gΛ ◦ σuc⟩)) ∪ {⋆}. Since Λ
is loaded, we can now show that h(outhc(⟨ρi, h ◦ σi⟩)) ⊆ O
for every 1 ≤ i ≤ n.
It is important to realize that
outhc(⟨ρ, gΛ ◦ σuc⟩) ̸= outhc(⟨ρi, h ◦ σi⟩) by the fact that
λn is the first trigger to yield a ρ-cyclic term.

Now, h(outhc(⟨ψi, h ◦ gΛ ◦ τi⟩)) ⊆ O for 1 ≤ i ≤
m can be verified given that outhc(⟨ψi, h ◦ gΛ ◦ τi⟩) ̸=
outhc(⟨ρ, gΛ ◦ σuc⟩).
the case since
The latter
outhc(⟨ρ, σuc⟩) ⊈ fct(w). Therefore, ⟨ρ, gΛ ◦ σuc⟩ is not uc-
unblockable; contradiction.

is

In practice, it is infeasible to compute RPC member-
ship because of the exponential number of head-choices.
While this does not influence the complexity bounds (see
Theorem 7), this exponential effort manifests often in prac-
tice. Instead, we check RPCs that considers far fewer head-
choices but still explores a meaningful portion of the search
space by using each head-disjunct of each rule at least once:
Definition 15. For some i ≥ 1, let hci be the head-choice
such that, for every rule ρ:
If i ≤ branching(ρ), then
hci(ρ) = i. Otherwise, hci(ρ) = branching(ρ). For a rule
set R, let branching(R) be the smallest number such that
branching(R) ≥ branching(ρ) for every ρ ∈ R.

A rule set R is RPCs if there is some 1 ≤ i ≤
branching(R), some (generating) ρ ∈ R, and some ρ-cyclic
term that occurs in RPC(R, hci, ρ).

By Definitions 14 and 15, a rule set R is RPC if it is RPCs.

Therefore, the following follows from Theorem 4:
Theorem 5. If a rule set is RPCs, then it never-terminates.

Deterministic Restricted Prefix Cyclicity We introduce
deterministic RPC as a less general version of RPC; our goal
here is to produce a notion that is similar to RMFC (Carral,
Dragoste, and Kr¨otzsch 2017) (see Section 7). It is therefore
our baseline in the evaluation (see Section 8). For example,
the rule set {(1), (2)} is RPC but not DRPC.
Definition 16. For a rule set R and a deterministic rule
ρ ∈ R, let DRPC(R, ρ) be a fact set that includes the
database Dρ, the set out1(⟨ρ, σuc⟩), and out1(λ) for every
deterministic R-trigger λ = ⟨ψ, τ ⟩ such that
• there are no cyclic terms in the range of τ ,
• the trigger λ is loaded for DRPC(R, ρ),
• the trigger λ is ⋆-unblockable for R, and
• the substitution σ is injective if ψ = ρ.

A rule set R is deterministic restricted prefix-cyclic
(DRPC) if there is some deterministic (generating) rule ρ ∈
R and some ρ-cyclic term that occurs in DRPC(R, ρ).
Theorem 6. If a rule set R is DRPC, it never-terminates.

Proof. By Lemma 3, every ⋆-unblockable trigger is also
uc-unblockable for every head-choice. Therefore, we find
DRPC(R, ρ) ⊆ RPC(R, hc, ρ) for every deterministic rule
ρ ∈ R and every head-choice hc. Hence, if R is DRPC, it is
RPC (even RPCs) and the claim follows by Theorem 4.

Complexity The complexity of checking cyclicity is dom-
inated by the double-exponential number of (non-cyclic)
terms that may occur during the check. That is, check-
ing RPC, RPCs, or DRPC requires at most a double-
exponential number of steps of which each is possible in
double-exponential time. Hardness follows similarly to
MFA (Cuenca Grau et al. 2013, Theorem 8): We extend
Σ3 to Σ4 by adding a fresh atom Pψ(y) to the head of ev-
ery ψ ∈ Σ3 where y is the list of all body variables in ψ.
By this, we make sure that unblockability does not interfere
with the original proof idea. The set Ω is then defined as
Σ4 ∪ {ρ = R(w, x) ∧ B(x) → ∃y.R(x, y) ∧ A(y)}. We find
that ⟨Σ4, {A(a)}⟩ |= B(a) iff Ω is RPC, RPCs, or DRPC.
Theorem 7. Checking (D)RPC(s) is 2EXPTIME-complete.

7 Related Work
Our main goal in this paper is to develop very general cyclic-
ity notions for the disjunctive restricted chase. To the best of
our knowledge, the only such existing notion is restricted
model faithful cyclicity (RMFC), which was introduced by
Carral, Dragoste, and Kr¨otzsch in (2017). While trying to
extend RMFC, we noticed that the proof of Theorem 11 in
(2017), 4 which states that RMFC rule sets do not terminate,
is incorrect; correctness of the theorem remains open.
Example 12. Consider the rule set R = {(15–20)}.
Cl1(x) ∧ Cl2(y) → ∃u.Red(x, u) ∧ Red(y, u)
Cl1(x) ∧ Red(x, z) → ∃v.Gr(x, v) ∧ Blu(z, v)

Red(y, z) ∧ Blu(z, w) ∧ Gr(x, w) → Gr(y, y)
Red(y, z) ∧ Blu(z, w) ∧ Gr(x, w) → Blu(z, y)
Red(y, z) ∧ Blu(z, w) ∧ Gr(x, w) → Cl1(y)

(15)
(16)
(17)
(18)
(19)
(20)
By Definition 11 in (2017), the rule set R is RMFC be-
cause the fact set F(15) features a (15)-cyclic term. As per
the proof of Theorem 11 in (2017), the chase of ⟨R, I(15)⟩
should “contain infinitely many applications of (15)”. This
is not the case; in fact, the result of the only chase tree of
⟨R, I(15)⟩ is the set {F} of fact sets where:
F ={Cl1(cx), Cl2(cy), Red(cx, t), Red(cy, t), Gr(cx, s),

Cl2(y) ∧ Gr(y, w) → Cl2(w)

1,v (cx, t).

In the above, t = f (15)

Blu(t, s), Gr(cx, cx), Blu(t, cx), Gr(cy, cy), Blu(t, cy)}
1,u (cx, cy) and s = f (16)
The problem stems from issues with Lemma 10 in (2017),
which states that some triggers will eventually be applied if
they are loaded for some vertex in the chase.
Example 13. By Definition 10 in (2017), a trigger such as
λ = ⟨(16), [x/cy, z/f (15)
1,u (cx, cy)]⟩ with cx, cy ∈ Cons is
unblockable for the rule set R = {(15–20)}. One can verify
that Lemma 10 in (2017) does not hold for this trigger and
the KB ⟨R, {Cl1(cx), Cl2(cy)}⟩. To do so, simply note that
this trigger is loaded for the fact set F defined at the end
of Example 12; however, F does not include out1(λ). Also,
note that λ is not uc/⋆-unblockable.

We have sought to “repair” RMFC by introducing DRPC.
We believe that both coincide for most real-world rule sets.
Another point of reference for us is our previous work
(Gerlach and Carral 2023b), where we have introduced Dis-
junctive Model Faithful Cyclicity (DMFC) for the (disjunc-
tive) skolem chase. We reuse many key ideas (also for the
proofs) from this work, e.g. the main results for unblockabil-
ity and reversiblity. A necessary but straightforward change
is the definition of obsoleteness. While the idea of cyclic-
ity sequences and prefixes was used in the proofs in spirit, a
proper formalisation had not been presented. Furthermore,
uc-unblockability was not considered for DMFC. Let us also
stress that a cyclicity notion for the skolem chase is not a suf-
ficient condition for restricted non-termination. There are
(many) rule sets that terminate for the restricted chase but
not for the skolem chase.

4Henceforth, we simply use (2017) as an abbreviation of (Car-

ral, Dragoste, and Kr¨otzsch 2017).

8 Evaluation
We have made available all evaluation materials online5 in-
cluding source code, rule sets, result files, and scripts used
to obtain the counts. In our experiments, we make use of
a well-known sufficient condition for restricted chase termi-
nation to obtain an upper bound for the cyclicity notions.
Definition 17. A term is k-cyclic for some k ≥ 1 if it fea-
tures k + 1 nested occurrences of the same function symbol.
For instance, f (f (a)) is 1-cyclic but g(f (a), f (b)) is not.

A rule set R is RMFAk for some k ≥ 1 if there are no
k-cyclic terms in the fact set RMFA(R), which is introduced
in Definition 7 of (Carral, Dragoste, and Kr¨otzsch 2017).
Theorem 8. RMFAk rule sets (with k ≥ 1) terminate.

The above result follows from the proof of Theorem 7 in

(Carral, Dragoste, and Kr¨otzsch 2017).

Test Suite We consider rule sets from the evaluation of
(Gerlach and Carral 2023b), which were obtained from
OWL ontologies via normalization and translation; see
Section 6 in (Cuenca Grau et al. 2013) for more details.
OWL axioms with “at-most restrictions” and “nominals” are
dropped because their translation requires the use of equal-
ity. The ontologies come from the Oxford Ontology Repos-
itory (OXFD)6 and the Manchester OWL Corpus (MOWL)
(Matentzoglu et al. 2014). We ignore rule sets without gen-
erating rules since these are trivially terminating.

Results For every rule set R in our test suite; we checked
if R is RMFA2, DRPC, and RPCs using our implementa-
tions; we ran each check with a 4h timeout on a cloud in-
stance with 8 threads and 32GB of RAM (comparable to a
modern laptop). We present our results in Table 1. We split
the rule sets that are purely deterministic (∧) from the ones
containing disjunctions (∨). We further split by the number
of generating rules #∃ and present the total number of rule
sets # for each bucket. For example, in the third row of the
table, we indicate that there are 27 deterministic rule sets in
OXFD with at least 20 and at most 99 generating rules of
which 23 are RMFA2, 2 are DRPC, and 3 are RPCs When
conidering RMFA2 together with DRPC or RPCs, the per-
centages of rule sets that cannot be characterised as either
terminating or non-terminating drop from DRPC to RPCs.
For MOWL ∧, OXFD ∨, and MOWL ∨, the drops are from
5% to 3%, 37% to 6%, and 45% to 5%, respectively; for
OXFD ∧ the percentage is around 21% for both. Our im-
provements are significant on the datasets with disjunctions;
for these, RPC is considerably more general than DRPC,
(which we introduced as a replacement for RMFC).

While many of the non-classified rule sets simply result
from timeouts, there are 38 rule sets in OXFD for which both
RMFA2 and DRPC finished without capturing the rule set.
Analogously, with RPCs, we find 7 rule sets. For MOWL
the numbers are 1505 and 110. This indicates that there is
still room for improvement on the theoretical side but also
that timeouts are indeed a big issue, which happens often
when we consider large datasets.

5https://doi.org/10.5281/zenodo.8005904 Gerlach and Carral
6https://www.cs.ox.ac.uk/isg/ontologies/

#∃

# tot.

∧ 1–19
20–99
D
F
100–999
X
O
1–999

∧ 1–19
20–99
L
W
100-999
O
1–999
M

∨ 1–19
20–99
D
F
100–999
X
O
1–999

∨ 1–19
20–99
L
W
100-999
O
1–999
M

58
27
109
194

1139
269
363
1771

37
18
147
102

1361
894
1150
3405

RMFA2
58
23
61
142

866
228
271
1365

32
4
8
44

806
196
500
1502

DRPC

0
2
8
10

239
27
46
312

0
7
13
20

48
171
136
355

RPCs
0+0
2+1
8+1
10+2

239+12
27+5
46+21
312+38

0+5
7+7
13+20
20+32

48+405
171+496
136+470
355+1371

Table 1: Restricted Chase Termination: Generating Rule Sets

9 Conclusions and Future Work

We make three tangible contributions: (i) We define RPC; a
very general cyclicity notion tailored for rule sets with dis-
junctions. (ii) We discovered problems with RMFC and de-
fined DRPC as a “repaired” version of this notion. (iii) We
present an evaluation to demonstrate the usefulness of our
work. Beyond these three, we believe that our efforts pro-
vide a framework for interesting future work.

Extending Cyclicity Notions Despite the fact that RPC is
more general than existing criteria, there are many rule sets
in our evaluation that remain open; that is, rule sets cannot
be characterised as terminating or non-terminating.

Our work provides three different main strategies to
achieve possible extensions. The first one is to produce
“weaker” over-approximations and thus a more general
strategy to detect g-unblockability; even g-unblockability it-
self can be relaxed. The second is to generalize cyclicity
prefixes; perhaps by checking loadedness from slightly dif-
ferent databases. For instance, the rule set R from Exam-
ple 12 is neither DRPC nor RPC (as intended) but actually
it is never-terminating; note that ⟨R, {Cl1(c), Cl2(c)}⟩ does
not admit finite chase trees. The third one is to develop more
comprehensive search strategies to find cyclicity prefixes;
for instance, we can relax the condition in the first item of
Definition 14 to look a bit further.

Explaining Cyclicity
In many real-world use-cases, the
existence of infinite universal models highlights a modelling
mistake. We can use RPC and DRPC as methods to explain
the loss of termination. For instance, a cyclicity prefix as de-
fined in Section 5 constitutes a small and clear explanation
of one way of loosing termination. In the future, we aim
to automatically compute minimal sets of rules that can be
removed (or added!) to deactivate a cyclicity prefix.

the 41st International Colloquium on Automata, Languages,
and Programming (ICALP 2014), Denmark, Part II, vol-
ume 8573 of Lecture Notes in Computer Science, 293–304.
Springer.
Grahne, G., and Onet, A. 2018. Anatomy of the chase.
Fundamenta Informaticae 157(3):221–270.
Karimi, A.; Zhang, H.; and You, J. 2021. Restricted chase
termination for existential rules: A hierarchical approach
and experimentation. Theory and Practice of Logic Pro-
gramming 21(1):4–50.
Kr¨otzsch, M., and Rudolph, S. 2011. Extending decidable
existential rules by joining acyclicity and guardedness. In
Walsh, T., ed., Proceedings of the 22nd International Joint
Conference on Artificial Intelligence (IJCAI 2011), Spain,
963–968. IJCAI/AAAI.
Marnette, B. 2009. Generalized schema-mappings: from
In Paredaens, J., and Su, J.,
termination to tractability.
eds., Proceedings of
the 28th ACM SIGMOD-SIGACT-
SIGART Symposium on Principles of Database Systems
(PODS 2009), USA, 13–22. ACM.
Matentzoglu, N.; Tang, D.; Parsia, B.; and Sattler, U. 2014.
The manchester OWL repository: System description.
In
Horridge, M.; Rospocher, M.; and van Ossenbruggen, J.,
eds., Proceedings of the 13th International Semantic Web
Conference (ISWC 2014), Posters & Demonstrations Track,
Italy, volume 1272 of CEUR Workshop Proceedings, 285–
288. CEUR-WS.org.

Acknowledgements
Lukas is / has been funded by Deutsche Forschungsge-
meinschaft (DFG, German Research Foundation) in project
389792660 (TRR 248, Center for Perspicuous Systems), by
the Bundesministerium f¨ur Bildung und Forschung (BMBF,
Federal Ministry of Education and Research) under Euro-
pean ITEA project 01IS21084 (InnoSale, Innovating Sales
and Planning of Complex Industrial Products Exploiting Ar-
tificial Intelligence), by BMBF and DAAD (German Aca-
demic Exchange Service) in project 57616814 (SECAI,
School of Embedded and Composite AI), and by the Cen-
ter for Advancing Electronics Dresden (cfaed).

David is funded by the ANR project CQFD (ANR-18-

CE23-0003).

References
Baget, J.; Garreau, F.; Mugnier, M.; and Rocher, S. 2014.
Extending acyclicity notions for existential rules. In Schaub,
T.; Friedrich, G.; and O’Sullivan, B., eds., Proceedings
of the 21st European Conference on Artificial Intelligence
(ECAI 2014), Czech Republic, volume 263 of Frontiers in
Artificial Intelligence and Applications, 39–44. IOS Press.
Beeri, C., and Vardi, M. Y. 1981. The implication problem
for data dependencies. In Even, S., and Kariv, O., eds., Pro-
ceedings of the 8th International Colloquium on Automata,
Languages and Programming (ICALP 1981), Israel, volume
115 of Lecture Notes in Computer Science, 73–85. Springer.
Bourhis, P.; Manna, M.; Morak, M.; and Pieris, A.
2016. Guarded-based disjunctive tuple-generating depen-
dencies. ACM Transactions On Database Systems (TODS)
41(4):27:1–27:45.
Carral, D.; Dragoste, I.; and Kr¨otzsch, M.
2017. Re-
stricted chase (non)termination for existential rules with dis-
junctions. In Sierra, C., ed., Proceedings of the 26th Inter-
national Joint Conference on Artificial Intelligence (IJCAI
2017), Australia, 922–928. ijcai.org.
Cuenca Grau, B.; Horrocks, I.; Kr¨otzsch, M.; Kupke, C.;
Magka, D.; Motik, B.; and Wang, Z. 2013. Acyclicity
notions for existential rules and their application to query
answering in ontologies. Journal of Artificial Intelligence
Resesearch (JAIR) 47:741–808.
Fagin, R.; Kolaitis, P. G.; Miller, R. J.; and Popa, L. 2005.
Data exchange: semantics and query answering. Theoretical
Computer Science 336(1):89–124.
Gerlach, L., and Carral, D. 2023a. Do repeat yourself: Un-
derstanding sufficient conditions for restricted chase non-
termination: Evaluation materials. https://doi.org/10.5281/
zenodo.8005904.
2023b. General acyclicity
Gerlach, L., and Carral, D.
In
and cyclicity notions for the disjunctive skolem chase.
Williams, B.; Chen, Y.; and Neville, J., eds., Proceedings
of the Thirty-Seventh AAAI Conference on Artificial Intelli-
gence, 2023, USA, 6372–6379. AAAI Press.
Gogacz, T., and Marcinkowski, J. 2014. All-instances termi-
nation of chase is undecidable. In Esparza, J.; Fraigniaud,
P.; Husfeldt, T.; and Koutsoupias, E., eds., Proceedings of

A Proof of Theorem 1

We ellaborate on the last part of the proof:

Proof (Last part extended). To prove that F(T, hc) is infi-
nite, we verify that (A) (cid:83)
i≥0 Fi(K, hc, Λ) is infinite and that
(B) Fi(K, hc, Λ) ⊆ F(T, hc) for every i ≥ 0.

• Claim (A) follows from the fact that Λ is growing. This
requirement implies that, for every i ≥ 0, there is some
j > i such that Fi(K, hc, Λ) ⊂ Fj(K, hc, Λ).

• We show Claim (B) via induction on i ≥ 0. The base
case holds since F(T, hc) includes D = fct(v1). Re-
garding the induction step, consider some i ≥ 1 and
assume that the induction hypothesis holds; that is, that
F(T, hc) includes Fi−1(K, hc, Λ). Therefore, there is
some j ≥ 1 such that Fi−1(K, hc, Λ) ⊆ fct(vj) and
hence, λi is loaded for fct(vj). Since λi is g-unblockable,
outhc(λi) ⊆ fct(vk) for some k ≥ 1 and hence,
Fi(K, hc, Λ) ⊆ F(T, hc) since fct(vk) ⊆ F(T, hc).

B Proof of Theorem 2
Proof. We present a reduction from the undecidable prob-
lem of checking if a deterministic KB ⟨R, D⟩ entails a fact
P(c) (Beeri and Vardi 1981). Consider the head-choice hc1
that maps all rules to 1, and the rule set R′ = R∪{ρ} where
ρ = P(x) → ∃y.P(y); note that R and R′ are equivalent
since ρ is tautological. We show that ⟨R, D⟩ |= P(c) iff
λ = ⟨ρ, [x/c]⟩ is not g-unblockable for R′ and hc1:

The trigger λ is obsolete for a fact set when it is loaded.
Hence, if ⟨R, D⟩ entails P(c), then λ is not g-unblockable
for ⟨R′, D⟩ and hc1.
If ⟨R, D⟩ ̸|= P(c), then λ is never
loaded in any fact-label of a chase tree of ⟨R′, D⟩ and there-
fore trivially g-unblockable.

C Proof of Lemma 2
Proof (Second condition of Definition 7). Consider a chase
tree T = ⟨V, E, fct, trg⟩ of a KB ⟨R, D⟩. Moreover, con-
sider a vertex u ∈ branch(T, hc) in T such that outhc(λ) ⊈
fct(u). To verify the lemma, we show that h(fct(u)) ⊆
O(R, hc, λ, h). More precisely, we show via induction that
h(fct(ui)) ⊆ O(R, hc, λ, h) for every vertex ui in the path
u1, . . . , un in T that starts with the root and ends in u.

• The base case holds by Condition (d) for h. Note that

O(R, hc, λ, h) includes h(D) by (1) in Definition 8.

• Regarding the induction step, consider some i ≥ 2.
By induction hypothesis, h(fct(ui−1)) ⊆ O(R, hc, λ, h)
and hence, ⟨ψ, h ◦ τ ⟩ is loaded for O(R, hc, λ, h) where
trg(ui) = ⟨ψ, τ ⟩. Since outhc(λ) ⊈ fct(u), we have that
outhc(trg(ui)) ̸= outhc(λ). By Definition 8, we have that
h(outhc(⟨ψ, h ◦ τ ⟩)) ⊆ O(R, hc, λ, h).Therefore, by as-
sumptions (b-c), h(fct(ui)) ⊆ O(R, hc, λ, h) holds.

D Proof of Lemma 4
We elaborate on the first and second claims made in the main
part of the proof.

Proof (First claim extended). We show that g−1(G) is a sub-
set of F. Since g−1(G′) ⊆ F follows trivially, we only have
to show that g−1(BirthFR(t)) ⊆ F for every t ∈ Terms(G);
we do so via induction over the structure of terms. If t is a
constant, then g−1(BirthFR(t)) = ∅; hence, the base case
trivially holds. Regarding the induction step, consider a term
t that is of the form f ψ

ℓ,y(s):

a. By ind.-hyp.: g−1(BirthFR(s)) ⊆ F for every s ∈ s.
b. Let z be the list of existentially quantified variables in
headℓ(ψ). Let τ be a substitution with frontier(ψ)τ = s.
Moreover, let H = headℓ(ψ)τ .
c. By definition: BirthFR(t) = H ∪ (cid:83)
d. By (a) and (c): We only need to show that g−1(H) ⊆ F
to verify the induction step. In fact, g−1(H) ⊆ F follows
from (f), (g), (h), and (i), which amount to a comprehen-
sive case-by-case analysis.

s∈s BirthFR(s).

e. We observe: If g−1(f ψ

z, then g−1(f ψ

ℓ,z′(s)) = f ψ

ℓ,z(s)) is functional for some z ∈
ℓ,z′(g−1(s)) for each z′ ∈ z.

f. We show that g−1(H) ⊆ F if g−1(t) is a functional
In this case, g−1(H) = g−1(headℓ(ψ)τ ) =

term:
headℓ(ψ)(g−1 ◦ τ ) ⊆ F follows directly from (e).

g. We show that g−1(H) ⊆ F if g−1(t) ∈ Cons \ {⋆}:
If g−1(t) ∈ Cons \ {⋆}, then g−1(f ψ
ℓ,z(s)) is a con-
stant for every z ∈ z by (e). Since g is reversible for
skeletonR(λ), g−1(s) is also a constant (possibly ⋆) for
every s ∈ s. Therefore, g−1(H) ⊆ F ′ ⊆ F.

h. If g−1(t) = ⋆ and g−1(t′) is a constant (or ⋆) for every

t′ ∈ Terms(H), then g−1(H) ⊆ F ′ ⊆ F.

i. We show that assuming g−1(t) = ⋆ and g−1(t′) /∈ Cons
for some t′ ∈ Terms(H) results in a contradiction: Note
that t′ is necessarily functional because g−1(t′) is. By
(e), t′ can only occur in s. Therefore, we have that, t′ ̸= t
is a subterm of t such that g−1(t′) is functional.
At the same time, for t to occur in skeletonR(⟨ρ, g ◦ σ⟩),
there needs to be a constant c that occurs in the im-
age of σ restricted to frontier(ρ) such that t occurs in
BirthFR(g(c)).
Suppose for a contradiction that no such constant exists,
there exists a functional term u that occurs in the
i.e.
image of σ restricted to frontier(ρ) such that t occurs in
BirthFR(g(u)) but t does not occur in BirthFR(g(u′))
for any subterm u′ of u with u′
̸= u. Since g−1(t) is
not functional, t must occur in BirthFR(q) for a subterm
q of g(u) with q ̸= g(u) by (e). But then, there exists
a subterm u′ of u with u′ ̸= u that occurs in the image
of σ restricted to frontier(ρ) with g(u′) = q since u is
functional. Since t occurs in BirthFR(g(u′)), we obtain
the desired contradiction and know that a constant c of
the desired form must exist.
But then for c ∈ Cons(skeletonR(ρ, σ)), we have t′ ∈
subterms(g(c)) and there is a functional term g−1(t′) ∈

skeletonR(ρ, σ) with g(g−1(t′)) = t′, which contradicts
reversibility of g.

i=1 hG(Oi) with Oi =

Proof (Second claim extended). Namely, we show that
g−1(O(R, [hc, ]⟨ρ, g ◦ σ⟩, hG)) ⊆ O(R, [hc, ]λ, hF ). Con-
sider a finite list of triggers λ1, . . . , λm such that all of the
following hold:
• O(R, [hc, ]⟨ρ, g ◦ σ⟩, hG) = G ∪ (cid:83)m
(cid:83) out(λi) [resp. Oi = outhc(λi)].
• λi is loaded for G ∪ (cid:83)i−1
j=1 hG(Oj).
• Let ⟨ψi, τi⟩ = λi. We have ψi ̸= ρ or outk(⟨ρ, g ◦ σ⟩) ̸=
outk(λi) for some 1 ≤ k ≤ branching(ρ). [Resp.: We
have outhc(⟨ρ, g ◦ σ⟩) ̸= outhc(λi).]
We show that g−1(G ∪ (cid:83)i

j=1 hG(Oj)) is a subset of
O(R, [hc, ]λ, hF ) via induction over 0 ≤ i ≤ m. We have
already shown the base case with i = 0, i.e. g−1(G) ⊆ F ⊆
O(R, [hc, ]λ, hF ).

Assume for the induction hypothesis that g−1(G ∪
j=1 hG(Oj)) is a subset of O(R, [hc, ]λ, hF ) for some
i ≥ 1. To verify the induction step we only need to show
that g−1(hG(Oi+1)) ⊆ O(R, [hc, ]λ, hF ).

(cid:83)i

⟨ψi+1, τi+1⟩ = λi+1, we find
the trigger
a. For
the fact sets g−1(hG((cid:83) out(⟨ψi+1, τi+1⟩))) and
that
hF ((cid:83) out(⟨ψi+1, g−1 ◦ τi+1⟩)) are equal.
[Respec-
tively: The fact sets g−1(hG(outhc(⟨ψi+1, τi+1⟩))) and
hF (outhc(⟨ψi+1, g−1 ◦ τi+1⟩)) are equal.]

b. By ind.-hypothesis,

the trigger ⟨ψi+1, g−1 ◦ τi+1⟩ is

loaded for O(R, [hc, ]λ, hF ).

c. Assume for a contradiction that ψi+1 = ρ and that
for every 1 ≤ k ≤ branching(ρ), we obtain equal-
ity of outk(λ) and outk(⟨ψi+1, g−1 ◦ τi+1⟩).
[Resp.:
Assume that outhc(λ) = outhc(⟨ψi+1, g−1 ◦ τi+1⟩).]
the output equalities also hold for ⟨ρ, g ◦ σ⟩
Then,
and ⟨ψi+1, g ◦ g−1 ◦ τi+1⟩. Furthermore, the respective
outputs of ⟨ψi+1, g ◦ g−1 ◦ τi+1⟩ and ⟨ψi+1, τi+1⟩ are
equal. Therefore, we find a contradiction to the defini-
tion of λ1, . . . , λm above.

d. By (a), (b), and (c): the induction step holds.

E Proof of Theorem 3

We ellaborate on (a):

Proof ((a) extended). We show via induction over j ≥ 1 that
⟨ρi, σj
i ⟩ is loaded for every 1 ≤ i ≤ n. The base case with
j = 1 holds since Λ is loaded. We show the induction step
from j to j + 1. By induction hypothesis, ⟨ρi, σj
i ⟩ is loaded
for F(j−1)×n+i(K, hc, Λ∞). By construction, ⟨ρi, σj+1
⟩ is
loaded for gΛ(F(j−1)×n+i(K, hc, Λ∞)). Furthermore, we
have gΛ(F(j−1)×n+i(K, hc, Λ∞)) ⊆ Fj×n+i(K, hc, Λ∞)
by an inductive argument over the construction of Λ∞
with the base case of having gΛ(F1(K, hc, Λ∞)) ⊆

i

Fn+1(K, hc, Λ∞). Note that the latter holds since ρn =
ρ and gΛ ◦ σ0 = σn. Hence, ⟨ρi, σj+1
⟩ is loaded for
Fj×n+i(K, hc, Λ∞), which yields the induction step.

i

F Proof of Theorem 4

We ellaborate on the last part of (B):

Proof (last part of (B) extended). We show in more detail
that h(outhc(⟨ψi, h ◦ gΛ ◦ τi⟩)) ⊆ O for every 1 ≤ i ≤ m.
First, we show h(gΛ(fct(v0)) = h(body(ρ)(gΛ ◦ σuc)) ⊆ O
by making use of the triggers in Λ:

a. We have that h(outhc(⟨ρ, σuc⟩)) = outhc(⟨ρ, σuc⟩) ⊆
BirthFR(⟨ρ, gΛ ◦ σuc⟩). Also, h(Dρ) is contained in the
set of all facts that can be defined using any predicate and
constants from Cons(skeletonR(⟨ρ, gΛ ◦ σuc⟩)) ∪ {⋆}.
b. By (a) and since Λ is loaded, the trigger ⟨ρi, h ◦ σi⟩ is
loaded for h(Fi−1(⟨R, Dρ ∪ outhc(⟨ρ, σuc⟩)⟩, hc, Λ)) for
every 1 ≤ i ≤ n.

c. Since ⟨ρ, gΛ ◦ σuc⟩ is the first trigger that yields a ρ-cyclic
term, outhc(⟨ρ, gΛ ◦ σuc⟩) ̸= outhc(⟨ρi, h ◦ σi⟩) for ev-
ery 1 ≤ i ≤ n − 1.

d. By (a), (b), (c), we find h(outhc(⟨ρi, h ◦ σi⟩)) ⊆ O for
every 1 ≤ i ≤ n − 1, which with (b) concludes the claim.

Now, h(outhc(⟨ψi, h ◦ gΛ ◦ τi⟩)) ⊆ O for 1 ≤ i ≤ m.

h(body(ρ)(gΛ◦σuc))∪(cid:83)i−i

a. We find that each trigger ⟨ψi, h ◦ gΛ ◦ τi⟩ is loaded for
j=1 h(outhc(⟨ψj, h ◦ gΛ ◦ τj⟩)).
b. Since outhc(⟨ρ, σuc⟩) ⊈ fct(w), we necessarily have
that outhc(⟨ψi, τi⟩) ̸= outhc(⟨ρ, σuc⟩). But then also,
outhc(⟨ψi, h ◦ gΛ ◦ τi⟩) ̸= outhc(⟨ρ, gΛ ◦ σuc⟩).

c. The claim follows from (a), (b), and the first claim shown

in the previous enumeration.

G Proof of Theorem 7
Proof. Membership. The number of rules to consider is lin-
ear in R. The number of head-choices to consider is (at
most) exponential in R. The number of non-cyclic terms
and therefore the number of triggers that need to be consid-
ered for any rule and head-choice is double-exponentially
bounded in the size of R. In particular, checking that a trig-
ger is loaded and uc/⋆-unblockable takes at most double-
exponential time. All together, checking (D)RPC(s) requires
at most a double-exponential number of steps of which each
is possible in double-exponential time.

Hardness.

Following the hardness result for MFA
(Cuenca Grau et al. 2013, Theorem 8), we use a reduc-
tion from the problem of conjunctive query entailment over
weakly acyclic rule set R (which is called Σ in the origi-
nal proof). Let R′ be the weakly-acyclic rule set that results
from R such that R′′ = R′ ∪ {ρ = R(w, x) ∧ B(x) →
∃y.R(x, y) ∧ A(y)} is MFA iff ⟨R′, {A(a)}⟩ ̸|= B(a) ac-
cording to the construction by Cuenca Grau et al. In the
original proof R′ corresponds to Σ3 (Cuenca Grau et al.
2013, Theorem 8). In turn, the rule set R′′ corresponds to
Ω (Cuenca Grau et al. 2013, Lemma 7). Note that R′ is

weakly-acyclic and thus also MFA and that no atom with R
occurs in R′. We further extend every rule ψ ∈ R′ to obtain
R′′′ by adding a fresh atom Pψ(y) to the head of ψ where y
is the list of all universally quantified variables in ψ. Then,
similar to R′′, we set R′′′′ = R′′′ ∪ {ρ}. Again, R′′′ is
weakly-acyclic and MFA. Since R′′′′ is deterministic, we
consider the head-choice hc that maps all rules to 1.

already
Since R′′′

(D)RPC(s),
1,y(cx)) and A(f ρ

outhc(⟨ρ, σuc⟩)
includes
For
R(cx, f ρ
1,y(cx)).
is MFA,
there are no cyclic terms in the (D)RPC(s) construction
that do not feature a term from outhc(⟨ρ, σuc⟩). Therefore,
if ⟨R′′′, {A(a)}⟩ ̸|= B(a), then no other trigger for ρ is
loaded and thus, R′′′′ is not (D)RPC(s). For any other rule
ψ ∈ R′′′, the (D)RPC(s) construction fails because R′′′ is
MFA and ρ can never be applied because the predicate R
only occurs in ρ. Hence, R′′′′ is not (D)RPC(s). Otherwise,
if ⟨R′′′, {A(a)}⟩ |= B(a), we show that the sequence of
R′′′-triggers that can derive B(a) from A(a) can be used in
the construction of (D)RPC(s). Since R does not occur in
R′′′ and B only occurs in a rule head in R′′′, A(f ρ
1,y(cx))
the
is the only usable fact when starting to construct
chase derivation for (D)RPC(s). Hence, every trigger that
becomes loaded in the contruction features a functional
term in the image of its substitution. Since every rule in
R′′′ contains a head-atom featuring all universal variables,
each of the loaded triggers is also uc/⋆-unblockable. Since
R′′′ is MFA, every loaded trigger does not feature cyclic
terms. By that, we obtain, if ⟨R′′′, {A(a)}⟩ |= B(a), then
B(f ρ
1,y(cx)) occurs in the construction of (D)RPC(s). The
trigger ⟨ρ, [w/cx, x/f ρ
1,y(cx)]⟩ has an injective substitution.
Therefore we obtain a ρ-cyclic term in A(f ρ
1,y(cx)))
and thus, R′′′′ is (D)RPC(s).

1,y(f ρ

