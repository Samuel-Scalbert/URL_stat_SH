Skill Rating for Multiplayer Games Introducing
Hypernode Graphs and their Spectral Theory
Thomas Ricatte, Rémi Gilleron, Marc Tommasi

To cite this version:

Thomas Ricatte, Rémi Gilleron, Marc Tommasi. Skill Rating for Multiplayer Games Introducing
Hypernode Graphs and their Spectral Theory. Journal of Machine Learning Research, 2020, 21, pp.1
- 18. ￿hal-02566930￿

HAL Id: hal-02566930

https://inria.hal.science/hal-02566930

Submitted on 7 May 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Journal of Machine Learning Research 21 (2020) 1-18

Submitted 12/13; Revised 3/20; Published 4/20

Skill Rating for Multiplayer Games
Introducing Hypernode Graphs and their Spectral Theory

Thomas Ricatte
R´emi Gilleron
Marc Tommasi
Universit´e de Lille and Inria Lille Nord Europe
40, Av. Halley, 59650 Villeneuve d’Ascq, France

Editor: David Blei

thomas@ricatte.fr
remi.gilleron@univ-lille.fr
marc.tommasi@univ-lille.fr

Abstract

We consider the skill rating problem for multiplayer games, that is how to infer player
skills from game outcomes in multiplayer games. We formulate the problem as a minimiza-
tion problem arg mins sT ∆s where ∆ is a positive semideﬁnite matrix and s a real-valued
function, of which some entries are the skill values to be inferred and other entries are con-
strained by the game outcomes. We leverage graph-based semi-supervised learning (SSL)
algorithms for this problem. We apply our algorithms on several data sets of multiplayer
games and obtain very promising results compared to Elo Duelling (see Elo, 1978) and
TrueSkill (see Herbrich et al., 2006). As we leverage graph-based SSL algorithms and
because games can be seen as relations between sets of players, we then generalize the
approach. For this aim, we introduce a new ﬁnite model, called hypernode graph, deﬁned
to be a set of weighted binary relations between sets of nodes. We deﬁne Laplacians of hy-
pernode graphs. Then, we show that the skill rating problem for multiplayer games can be
formulated as arg mins sT ∆s where ∆ is the Laplacian of a hypernode graph constructed
from a set of games. From a fundamental perspective, we show that hypernode graph
Laplacians are symmetric positive semideﬁnite matrices with constant functions in their
null space. We show that problems on hypernode graphs can not be solved with graph
constructions and graph kernels. We relate hypernode graphs to signed graphs showing
that positive relations between groups can lead to negative relations between individuals.

Keywords: Hypergraphs, Graph Laplacians, Graph Kernels, Spectral Learning, Semi-
supervised Learning, Multiplayer Games, Skill Rating Algorithms.

1. Introduction

We consider the skill rating problem for multiplayer games such as team sports and online
games. We consider games between two teams where each team is composed of an arbitrary
number of players. We assume, as in Herbrich et al. (2006), that the skill of a team is a
weighted sum of the player skills. The problem is to infer individual player skills from a
limited number of game outcomes. The skills can then be used for match-making, skill
ranking or outcome prediction for new games.

Given a set of players and a set of games between teams of players, we model the
player skills and the game outcomes by real-valued functions. We show that the skill rating
problem is equivalent to solving a minimization problem arg mins sT ∆s where ∆ is a positive

c(cid:13)2020 Thomas Ricatte, R´emi Gilleron and Marc Tommasi.

License: CC-BY 4.0, see https://creativecommons.org/licenses/by/4.0/. Attribution requirements are provided
at http://jmlr.org/papers/v21/13-561.html.

Ricatte, Gilleron and Tommasi

1

2

3

1
2
1
2
2
1
3

1
1

1

1

2

2
1
3

4

5

6

G =






√

2
2
1
0

√

2
2
0
0

√

√

2 −
0
√
3
3

−1
0

2 −

√

2
−1
0






0
1
√
−

3
3

Figure 1: Left: a hypernode graph h with three hyperedges hblue = {{1, 2, 3}, {4, 5}},
hblack = {{4, 5}, {1, 6}} and hred = {{3}, {6}} where a hyperedge is represented
by a rectangle and nodes in a hypernode are connected to the same side of the
rectangle. Right : a gradient G of h which values are square root of the weights
and are positive for one hypernode and negative for the other. The matrix G can
be seen as an alternative deﬁnition of the hypernode graph h.

semideﬁnite matrix and some entries of s are constrained by the game outcomes. In order
to solve this problem, we propose two algorithms. The ﬁrst one is the semi-supervised
learning (SSL) algorithm presented in Zhu et al. (2003) originally designed for graph-based
SSL. The second one, also inspired from graph-based SSL, is to use a regression support
vector machine using the Moore-Penrose pseudoinverse ∆† of the matrix ∆ as a kernel.
In the experiments, we consider real data sets of multiplayer games (double tennis and
online games) and apply our method in a batch setting. We get very competitive results
with specialized algorithms such as Elo duelling (see Elo, 1978) and TrueSkill (see
Herbrich et al., 2006).

The above minimization problem can be solved by graph-based SSL algorithms because
its formulation is similar to the case of graphs where ∆ is a graph Laplacian. Here, the
positive semideﬁnite matrix ∆ expresses conditions on the players skills based on the game
outcomes, where each game can be considered as a binary relation between two sets of
players. Driven by these remarks, we introduce hypernode graphs as a ﬁnite model for
relations between sets and we show that our matrix ∆ is the Laplacian of such an hypernode
graph.

We deﬁne a hypernode graph to be a set of hyperedges. A hyperedge is a pair of disjoint
hypernodes, where a hypernode is a set of nodes. Every node of a hypernode is given a non
negative real-valued weight. Roughly speaking, a hypernode models a group, a hyperedge
models a relation between two groups, and individual weights correspond to the contribution
of each individual to the relation between the two groups. An example of hypernode graph
is shown in Figure 1. Hypernode graphs generalize over graphs because there is a one to one
correspondence between undirected graphs and hypernode graphs in which all hypernodes
are singleton sets.

We consider real-valued node functions over hypernode graphs and we assume an addi-
tive model where the hypernode valuation is the linear combination of its node valuations.
We assume that connected hypernodes tend to have similar values. For real-valued node
functions over discrete structures, the gradient is a discrete derivative that allows to mea-

2

Skill Rating for Multiplayer Games with Hypernode Graphs

sure such a similarity. Therefore, we deﬁne a gradient for hypernode graphs and we denote
by G the gradient matrix of a hypernode graph h. An example is shown in Figure 1. We
deﬁne the Laplacian ∆ of h to be ∆ = GT G. Then, the quantity f T ∆f measures the
smoothness of a real-valued node function f on the hypernode graph h. In other words,
f T ∆f is small when connected hypernodes have close values. Then, we show that a set of
multiplayer games can be modeled by a hypernode graph and that our algorithm for the
skill rating problem is ﬁnding a real-valued node function s minimizing Ω(s) = sT ∆s, where
∆ is the Laplacian of the constructed hypernode graph, under constraints on the s-values
for game outcomes.

One question raised by the introduction of our new framework is whether problems on
hypernode graphs can be solved using graphs. Indeed, for hypergraphs (a generalization of
graphs where a hyperedge is a set of nodes), it has been proved in Agarwal et al. (2006) that
the hypergraph Laplacians introduced at this time (other hypergraph Laplacians have been
deﬁned since (see Chan et al., 2018, and references within)), do not extend graph Laplacians
because learning based on a hypergraph Laplacian can be proved equivalent to learning on
a graph Laplacian using an adequate graph construction (such as clique expansion or star
expansion). This is not the case for hypernode graphs.
Indeed, we show that no graph
construction allows to deﬁne a set of smooth functions over the graph equal to the set of
smooth functions over a given hypernode graph. Thus, we state that hypernode graph
Laplacians strictly generalize over graph Laplacians.

It can be noted that the class of hypernode graph Laplacians strictly contains the class
of graph Laplacians and also contains the class of graph kernels (the Moore-Penrose pseu-
doinverse of a graph Laplacian). A convex linear combination of graph kernels (used in
multiple graph kernel learning as in Argyriou et al. (2005)) is not, in general, a graph kernel
but we prove that it is a hypernode graph kernel (the Moore-Penrose pseudoinverse of a
hypernode graph Laplacian). We conjecture that the class of hypernode graph Laplacians
is the smallest class closed by convex linear combinations which contains all graph kernels.

We also show that, for every hypernode graph, we can construct a signed graph with
adjacency matrix W and degree matrix D such that D−W is the Laplacian of the hypernode
graph. This shows that positive relations between groups can lead to negative relations
between individuals. Let us recall that, for arbitrary signed graphs, the matrix D − W can
be indeﬁnite. From a spectral theory perspective, hypernode graphs correspond to the class
of signed graphs such that D − W is positive semideﬁnite introduced by Koren et al. (2002)
for the problem of drawing graphs. Last, we study how to deﬁne a distance between nodes
in hypernode graphs and we leave open questions on connected components and random
walks in hypernode graphs.

2. Skill Rating for Multiplayer Games

We consider competitive games between two teams where each team is composed of an
arbitrary number of players. A ﬁrst objective is to compute the skills of individual players
from a batch of games with their outcomes. A second objective is to predict a game outcome
for a new game. In this section, we show how to model a batch of games and to infer player
skills that allow to predict game outcomes of new games.

3

Ricatte, Gilleron and Tommasi

2.1 Skill Rating as an Optimization Problem

Let us consider a set of players P = {1, . . . , n} and a set of games Γ = {1, . . . , m} together
with their respective game outcome. Each game is between two teams of an arbitrary
number of players. Let us also consider that a player i contributes to a game γ with a
positive real value cγ(i). Let us assume that each player has a skill s(i), we suppose an
additive model as in Herbrich et al. (2006) stating that the skill of a team is the weighted
sum of the skills of the players in the team. More formally, given two teams of players
A = {a1, a2, . . . , a(cid:96)} and B = {b1, b2, . . . , bk} playing game γ, then A is predicted to be the
winner if

(cid:96)
(cid:88)

cγ(ai)s(ai) >

k
(cid:88)

cγ(bi)s(bi) .

(1)

i=1
Equivalently, one can rewrite this inequality by introducing a positive real number oγ

i=1

on the right hand side such that

(cid:96)
(cid:88)

cγ(ai)s(ai) = oγ +

k
(cid:88)

cγ(bi)s(bi) ,

(2)

i=1
where the real number oγ quantiﬁes the game outcome.
In the case of a draw, there is
an equality between the team skills, thus the game outcome oγ is set to 0. Given a set of
games with their respective outcome, the goal is to infer a skill rating function s ∈ Rn that
respects as much as possible Equation (2) for every game. We deﬁne the cost of a game γ
with outcome oγ for a skill function s by

i=1

Cγ(s) = (cid:107)

(cid:96)
(cid:88)

i=1

cγ(ai)s(ai) − (cid:0)oγ +

k
(cid:88)

i=1

cγ(bi)s(bi)(cid:1)(cid:107)2 .

Consequently, given a set of games Γ and the corresponding game outcomes, the goal is to
ﬁnd a skill rating function s∗ that minimizes the sum of the diﬀerent costs:

s∗ = arg min

s

(cid:88)

γ∈Γ

Cγ(s) .

(3)

We now reformulate this problem as a SSL problem over a positive semideﬁnite matrix.
For this, let us deﬁne the matrix G ∈ Rm×(n+m), where n is the number of players and
m the number of games, as follows. Let γ ∈ Γ be a game between teams A and B where
A is supposed to be the winner, the γ-th row of G models game γ and is deﬁned by: for
1 ≤ i ≤ n, Gγ,i = cγ(ai) if ai ∈ A, Gγ,i = −cγ(ai) if ai ∈ B, and 0 otherwise (the player i is
not involved in the game γ); and, for 1 ≤ γ(cid:48) ≤ m, Gi,n+γ(cid:48) = −1 for γ = γ(cid:48) and 0 otherwise.
Then, it is easy to show that the skill rating problem (3) is equivalent to ﬁnd a real-

valued node function s ∈ R(n+m) solution of

minimize
s

sT ∆s

subject to for every game γ with outcome oγ, s(n + γ) = oγ

where ∆ = GT G. We can note that the matrix ∆ is positive semideﬁnite.

(4)

4

Skill Rating for Multiplayer Games with Hypernode Graphs

2.2 Regularizing the Optimization Problem

When the number of games is small, player skills can be deﬁned independently while satis-
fying the constraints and it will be irrelevant to compare them. In order to solve this issue,
we introduce in Equation 4 a regularization term based on the standard deviation σ(sp) of
players skills where sp = (s(1), . . . , s(n)). This allows us to reduce the spread of the player
skills and leads us to ﬁnd a real valued node function s ∈ R(n+m) solution of

minimize
s

sT ∆s + µσ(sp)2

subject to for every game γ with outcome oγ, s(n + γ) = oγ

(5)

where µ is a regularization parameter. That is, we control the spread of sp avoiding extreme
values for players involved in a small number of games. In order to apply SSL algorithms
over a positive semideﬁnite matrix, we propose to rewrite Problem 5.

First, let us recall that if s is the mean of the player skills vector sp, then, for all q ∈ R,
i=1(s(i) − q)2. Thus, Problem 5 is equivalent to

we have σ(sp)2 = 1
n

(cid:80)n

(cid:80)n

i=1(s(i) − s)2 ≤ 1
n
n
(cid:88)

sT ∆s +

µ
n

i=1

minimize
s∈R(n+m),q∈R

(s(i) − q)2

(6)

(7)

subject to

for every game γ with outcome oγ, s(n + γ) = oγ

(cid:113) µ

We now deﬁne the matrix Gµ ∈ R(m+n)×(n+m+1). The ﬁrst m rows of Gµ are the rows of
G with an additional null column. The last n rows of Gµ are deﬁned by, for every 1 ≤ i ≤ n,
n , and 0 otherwise. Note that the last n rows of
Gµ,(m+i,i) = −
Gµ allow to compute µ
µ Gµs.
n
Thus Problem 6 is equivalent to ﬁnding a real-valued node function s ∈ R(n+m+1) solution
of

i=1(s(i) − q)2 where s(n + m + 1) = q when computing sT GT

n , Gµ,(m+i,n+m+1) =

(cid:113) µ

(cid:80)n

minimize
s

sT ∆µs

subject to for every game γ with outcome oγ, s(n + γ) = oγ

where ∆µ = GT

µ Gµ is positive semideﬁnite.

Note that, assuming unitary contributions and a Gaussian distribution for skill ratings,
we can prove that the value of µ/n should have the same order of magnitude than the average
number of games played by a player. Indeed, this will allow us to obtain close expected
values for the two terms sT ∆s and µσ(sp)2. We follow this guideline in the experiments
presented below.

2.3 Inferring Skill Ratings and Predicting Game Outcomes

Problem 7 can be viewed as a SSL problem because the question is to predict player skills
(values s(i) for 1 ≤ i ≤ n) from known outcomes (values s(n + γ) for 1 ≤ γ ≤ m). We
propose two algorithms:

H-ZGL: as the matrix ∆µ is positive semideﬁnite, we can use the SSL algorithm presented
in Zhu et al. (2003). This algorithm was originally designed for graphs and solves
exactly Problem 7 by putting hard constraints on the outcome values. It should be
noted that the algorithm is parameter free.

5

Ricatte, Gilleron and Tommasi

H-SVR: another approach to solve the SSL problem is to use a regression algorithm. For
this, we consider the Moore-Penrose pseudoinverse ∆†
µ of the matrix ∆µ, we train a
regression support vector machine and predict player skills. The main parameter is
the soft margin parameter.

Given the player skills, we can deduce team skills, and ﬁnally predict game outcomes for
new games. For this, we suppose that we are given a training set Γl of games with known
outcomes together with a test set Γu of games for which game outcomes are hidden. The
goal is to predict game outcomes for the test set Γu. We follow the following protocol.

Algorithm 1 Predicting game outcomes
Input: a training set Γl of games and a test set Γu of games
1: Build, as described in Sections 2.1 and 2.2, the matrix ∆µ using game set Γl
2: Compute an optimal skill rating s∗ using H-ZGL or H-SVR for Problem 7
3: Compute the mean skill ¯s among players in Γl
4: for each game in Γu do
5:

Assign skills given by s∗ to players involved in Γl, and ¯s otherwise
Compare the team skills and predict the winner according to Equation 1

6:
7: end for

2.4 Experiments

In this section, we report experimental results for the inference of player skills and the
prediction of game outcomes for diﬀerent data sets in the batch setting described above.
Note that other works have considered the online setting as in Herbrich et al. (2006) or Elo
(1978).

Tennis Doubles

We consider a data set of tennis doubles collected between January 2009 and September
2011 from ATP tournaments (World Tour, Challengers and Futures). Tennis doubles are
played by two teams of two players. Each game has a winner (no draw is allowed). A game
is played in two or three winning sets. The ﬁnal score corresponds to the number of sets
won by each team during the game. The data set Γ consists in 10028 games with n = 1834
players.

Along the experimental process, given a proportion ρ, we draw randomly a training set
Γl of size ρ% of the number of games in Γ. The remaining games deﬁne the test set Γu. We
present in Figure 2 several statistics related to this process on the Tennis data set. First, it
can be noticed that many players have played a small number of games. Second, when the
number of games in the training set is small, half of the players are involved in games in
the test set. Therefore, the skill rating problem and the game outcome prediction problem
become far more diﬃcult to solve when few games are used for learning.

The experimental setting is deﬁned as follows. Let ρ be a proportion varying from 10%
to 90% by 10%. For every value of ρ, we repeat ten times: draw a random training set
Γl of size ρ% of the number of games in Γ; let the remaining games deﬁne the test set
Γu; infer player skills and predict game outcomes following Algorithm 1. We set all player

6

Skill Rating for Multiplayer Games with Hypernode Graphs

s
r
e
y
a
l
p

f
o

r
e
b
m
u
N

700
600
500
400
300
200
100
0

0 10 20 30 40 50 60
Played games

n
w
o
n
k

u
Γ

f
o

n
i

s
r
e
y
a
l
p

e
g
a
t
n
e
c
r
e
P

100
90
80
70
60
50
40

0.10.20.30.40.50.60.70.80.9
Proportion of games used for Γl

Figure 2: [left] Distribution of the number of players against the number of played games;
[right] Average percentage of players in Γu which are involved in some game in
Γl

contributions to 1. The game outcomes are set to be the diﬀerence between the number
of sets won by the two teams, thus the possible outcome values are 1, 2 or 3. Note that,
as there are only three outcome values, we can reduce the dimension of the matrix G from
n × (n + m) where m is the number of games to n × (n + 3). Thus the matrix ∆µ is a square
matrix of dimension n + 3 + 1 = 1838. As announced above, we choose the value of µ so
that µ/n is close to the average number of games played by a player in the training set.
The experiments presented in this section use µ/n = 16.

We report in Figure 3 prediction results using: Algorithm 1 with H-ZGL, Algorithm 1
with H-SVR, Elo Duelling, and Trueskill.1
It can be noted that Elo Duelling
performs poorly but Elo was designed for one against one games.
It should be noted
that we have done similar experiments for tennis singles. The results are not reported
here but they show that Elo Duelling and TrueSkill obtain similar results but are
outperformed by H-ZGL and H-SVR. For the data set of tennis doubles, it must be noted
that H-ZGL and H-SVR outperform TrueSkill for a small number of training games. Also,
H-ZGL outperforms TrueSkill whatever is the number of training games. On this set of
experiments H-ZGL outperforms H-SVR but it should be noted that H-ZGL is parameter
free and that we use H-SVR with the default soft margin parameter value.

Xbox Title Halo2

The Halo2 data set was generated by Bungie Studio during the beta testing of the XBox
title Halo2. It has been notably used in Herbrich et al. (2006) to evaluate the performance
of the TrueSkill algorithm. We consider the Small Teams data set with n = 4992 players
and 27536 games opposing up to 12 players in two teams which can have a diﬀerent size.
Each game can result in a draw or a win of one of the two teams. The proportion of draws
is 22.8%. As reported in Herbrich et al. (2006), the prediction of draws is challenging and

1. TrueSkill and Elo implementations are from Hamilton (2012). Results were double-checked using Lee
(2013b) and Lee (2013a). Parameters of Elo and TrueSkill are the default parameters of Hamilton
(2012) (K = 32 for Elo, µ0 = 25, β = 12.5, σ = 8.33 and τ = 0.25 for TrueSkill).

7

Ricatte, Gilleron and Tommasi

H-ZGL
Elo duelling
H-SVR
Trueskill

0.2

0.3

0.5
Proportion of games used for Γl

0.4

0.6

0.7

0.8

0.9

u
Γ

r
e
v
o

r
o
r
r
E
g
n
i
t
s
e
T

50

45

40

35

30

0.1

Figure 3: Predictive error for Double Tennis data set

it should be noted that TrueSkill and our algorithm fail to outperform a random guess
for the prediction of draw.

We consider the same experimental process. For the construction of the hypernode graph
in Algorithm 1, we ﬁx all players contributions in games to 1 and we again set the parameter
value µ/n to 16. In the optimization problem (7), the game outcomes are set to 1 when
the game has a winner and 0 otherwise because game scores vary depending on the type of
game. The matrix ∆µ has dimension n + 2 + 1 = 4995. We again compare the skill rating
algorithms H-ZGL, H-SVR, Elo Duelling and TrueSkill. The number of prediction
errors over game outcomes is computed assuming that a draw can be regarded as half a win,
half a loss as in Lasek et al. (2013). We present the experimental results in Figure 4. For a
proportion of 10% of games in the training set, H-ZGL, H-SVR and TrueSkill give similar
results while with larger training sets, our hypernode graph learning algorithms outperform
TrueSkill. Contrary to the previous experiment, H-SVR (with default parameter value)
outperforms H-ZGL.

3. Hypernode Graphs

In the previous section, we consider the skill rating problem as a SSL problem and we
express it as a minimization problem using a positive semideﬁnite matrix ∆ which expresses
conditions on the players skills based on the game outcomes. This allows us to use graph-
based SSL algorithms. As games can be considered as relations between sets of players,
there is a discrete structure underlying the skill-rating problem. The existing discrete
structure and the similarity with graph-based SSL motivate the work presented in this
section. Indeed, we now introduce hypernode graphs as a ﬁnite model for relations between
sets, we show that our matrix ∆ is the Laplacian of such an hypernode graph, and we show
that Problem 7 expresses the smoothness of a real-valued node function over the hypernode
graph with some constraints on node values.

8

Skill Rating for Multiplayer Games with Hypernode Graphs

u
Γ

r
e
v
o

r
o
r
r
E
g
n
i
t
s
e
T

55

50

45

40

35

30

0.1

H-ZGL
Elo duelling
H-SVR
Trueskill

0.2

0.3

0.5
Proportion of games used for Γl

0.7

0.6

0.4

0.8

0.9

Figure 4: Predictive error for Halo2 data set

3.1 Introducing Hypernode Graphs

The following deﬁnition is our contribution to the modeling of binary relationships between
sets of entities.

Deﬁnition 1 A hypernode graph h = (V, H) is a set of nodes V and a set of hyperedges
H. Each hyperedge h ∈ H is an unordered pair {sh, th} of two non empty and disjoint
hypernodes (a hypernode is a subset of V ). Each hyperedge h ∈ H has a weight function wh
mapping every node i in sh ∪ th to a positive real number wh(i) (for i /∈ sh ∪ th, we deﬁne
wh(i) = 0). Each weight function wh must satisfy the Equilibrium Condition deﬁned by

(cid:88)

i∈th

(cid:112)wh(i) =

(cid:88)

(cid:112)wh(i) .

i∈sh

(8)

We denote by n the number of nodes. We say that a node i belongs to a hyperedge h,
that we denote by i ∈ h, if wh(i) (cid:54)= 0. We deﬁne the degree of a node i by deg(i) = (cid:80)
h wh(i).
The degree of a node is positive when it belongs to at least one hyperedge. We deﬁne the
diagonal degree matrix by D = diag(deg(1), . . . , deg(n)).

√

An example of hypernode graph is shown in Figure 1. The hyperedge hblue links the
sets {1, 2, 3} and {4, 5}. The weights of hblue satisfy the Equilibrium condition: (cid:112)1/2 +
(cid:112)1/2 +
2. The hyperedge hblack links the sets {4, 5} and {1, 6} and satisﬁes
the Equilibrium condition. The hyperedge hred links the two singletons {3} and {6} with
equal weights, thus the hyperedge hred can be viewed as an edge with edge weight 1/3.

2 =

2 +

√

√

As noted in the previous example, when a hyperedge h is an unordered pair {{i}, {j}},
the Equilibrium Condition states that the weights wh(i) and wh(j) are equal. Therefore,
every hypernode graph such that all hyperedges are unordered pairs of singleton nodes can
be viewed as a graph with adjacency matrix W deﬁned by Wi,j = Wj,i = wh(i) = wh(j) for
every hyperedge {{i}, {j}}, and 0 otherwise. Conversely, every graph can be viewed as a
hypernode graph where every hypernode is a singleton set.

9

Ricatte, Gilleron and Tommasi

3.2 Laplacians and Kernels of Hypernode Graphs

We are interested in evaluating real-valued functions on nodes and on hypernodes. We
assume a weighted linear model such that any real-valued node function f can be extended
i∈u f (i)(cid:112)wh(i). Moreover, we will consider
to a hypernode u of a hyperedge h by f (u) = (cid:80)
an homophilic assumption stating that connected hypernodes tend to have similar values.
In order to implement this assumption, we introduce a gradient for hypernode graphs by

Deﬁnition 2 Let h = (V, H) be a hypernode graph and f be a real-valued node function,
the (hypernode graph) unnormalized gradient of h is a linear application, denoted by grad,
that maps every real-valued node function f into a real-valued hyperedge function grad(f )
deﬁned, for every h = {sh, th} in H, by

grad(f )(h) = f (th) − f (sh) =

f (i)(cid:112)wh(i) −

(cid:88)

i∈th

(cid:88)

i∈sh

f (i)(cid:112)wh(i) ,

(9)

where an arbitrary orientation of the hyperedges has been chosen. We denote by G ∈ Rp×n
the matrix of grad. The square n × n real-valued matrix ∆ = GT G is deﬁned to be the
unnormalized Laplacian of the hypernode graph h.

As suggested by an anonymous reviewer, a hypernode graph could be deﬁned by a

gradient matrix as shown in Figure 1.

It should be noted that the Laplacian ∆ does not depend on the arbitrary orientation
of the hyperedges chosen for deﬁning the gradient. Also, by deﬁnition, the Laplacian ∆
is positive semideﬁnite. Moreover, because of the deﬁnition of the additive model and
because of the Equilibrium Condition 8, the gradient of every constant node function is
the zero-valued hyperedge function. Consequently, we have 1 ∈ Null(∆) where Null(∆) is
the null space of ∆. Last, it could be noted that, when the hypernode graph is a graph
(all hypernodes are singleton sets), then the hypernode graph Laplacian is equal to the
unnormalized graph Laplacian.

The Laplacian allows to deﬁne the smoothness of a real-valued node function f over a

hypernode graph h to be Ω(f ) = f T ∆f .

Last, we deﬁne the hypernode graph kernel of a hypernode graph h to be the Moore-

Penrose pseudoinverse ∆† of the hypernode graph Laplacian ∆.

Because a hypernode graph Laplacian is positive semideﬁnite, we can leverage the spec-
tral learning algorithms deﬁned in Von Luxburg (2007), Zhou et al. (2005), and Zhu et al.
(2003) from graphs to hypernode graphs.

3.3 Modeling the Skill Rating Problem with Hypernode Graphs

In this section, we show how to model a batch of games by a hypernode graph and how the
problems (4) and (7) translate on the constructed hypernode graphs.

We consider a set of m games as in Section 2.1. The construction mimics the construction
of the previous section with the additional trick to add a new node in order to satisfy the
Equilibrium condition 8 for hyperedges. Indeed, we consider n + m + 1 nodes, n nodes for
the players, m nodes for the outcomes and one lazy node. We can deﬁne, for every game γ
a hyperedge h as follows.

10

Skill Rating for Multiplayer Games with Hypernode Graphs

1. The players of A deﬁne one of the two hypernodes of h, the weight of a player node i

is deﬁned to be c(i)2;

2. do the same construction for the second team B;

3. add the outcome node associated with γ to the set of nodes of the losing team, its

weight is set to 1;

4. add the lazy node to the set of nodes corresponding to the winning team, its weight

is chosen in order to ensure the Equilibrium condition for the hyperedge h.

This deﬁnes the hypernode graph h = (V, H). Then, it is easy to show that Problem 4
is equivalent to minimizing sT ∆s where ∆ is the Laplacian of h with constraints for game
outcomes and adding the additional constraint s(n + m + 1) = 0 for the lazy node.

For the regularization term, we deﬁne the hypernode graph hµ obtained from the hyper-
node graph h by adding a regularizer node and adding n hyperedges between every player
node and the regularizer node R with (node) weights set to µ/n. Then, it is easy to show
that Problem 7 is equivalent to minimizing sT ∆µs where ∆µ is the Laplacian of hµ with
constraints for game outcomes and adding the additional constraint s(n + m + 1) = 0 for
the lazy node.

Then as said before, we can leverage graph-based SSL algorithms and consider, for

instance, the algorithms H-ZGL and H-SVR of Section 2.3.

3.4 The Class of Hypernode Graphs Laplacians

Proposition 3 The class of hypernode graph Laplacians is the class of symmetric positive
semideﬁnite real-valued matrices M such that 1 ∈ Null(M ) (the null space of M ).

Proof As a consequence of Deﬁnition 2, every hypernode graph Laplacian M is a symmetric
positive semideﬁnite real-valued matrix such that 1 ∈ Null(M ). Conversely, let us consider
the following algorithm

Algorithm 2 Construction of a hypernode graph
Input: M ∈ Rn×n symmetric positive semideﬁnite such that 1 ∈ Null(M )
1: Set V to {1, . . . , n}; set H to ∅
2: Compute a square root decomposition M = GT G
3: for each row r of G do
4:

Create a new hyperedge h = {sh, th} with sh = th = ∅
for each node i ∈ V do
Deﬁne wh(i) = r(i)2
if r(i) < 0 then Add i to sh else if r(i) > 0 Add i to th end if

5:

6:

7:

end for
8:
9: Add h to H
10: end for
11: return The hypernode graph h = (V, H)

From a square root decomposition GT G of M , for each line of G, we deﬁne a hyperedge
h = {sh, th} where nodes in sh (respectively in th) have positive (respectively negative)

11

Ricatte, Gilleron and Tommasi

values in the line, and node weights are chosen to be squares of values in the line. Then,
the Equilibrium condition 8 is satisﬁed because 1 ∈ Null(M ). And it is easy to check that
G is a gradient matrix of h and, consequently, that M = GT G is the Laplacian of h.

As a consequence of Proposition 3, the class of hypernode graph Laplacians

• is closed under convex linear combination,

• is closed under pseudoinverse,

• and strictly contains the class of graph Laplacians and the class of graph kernels (a

graph kernel is the Moore-Penrose pseudoinverse of a graph Laplacian).

Linear combinations of graph kernels have been used for SSL (see for instance Argyriou
et al., 2005). Another consequence of Proposition 3 is that any convex linear combination of
graph kernels is a hypernode graph kernel (but not necessarily a graph kernel). To conclude
this section, we propose

Conjecture:
convex linear combination which contains all graph kernels.

The class of hypernode graph Laplacians is the smallest class closed by

The main point is to prove that every hypernode graph Laplacian is a convex linear
combination of graph kernels which is diﬃcult because a graph kernel has no simple analytic
form.

3.5 Hypernode Graph Laplacians Strictly Generalize Graph Laplacians

As said above, the class of hypernode graph Laplacians strictly contains the class of graph
Laplacians. But this does not allow us to claim that hypernode graph Laplacians provide
a gain of expressiveness over graph Laplacians. Indeed, it could be the case that through a
well chosen graph construction, the set of smooth functions f deﬁned on hypernode graphs
by f T ∆f = 0 could be made to coincide exactly with the set of smooth functions deﬁned on
graphs. The class of hypergraph Laplacians has been studied in that perspective of expres-
siveness. Indeed, it has been shown in Agarwal et al. (2006) that hypergraph Laplacians
such as the ∆B from Bolla (1993), ∆R from Rodr´ıguez (2003) and ∆ZHS from Zhou et al.
(2007) can be deﬁned as (restrictions of) graph Laplacians using a graph construction such
as the clique expansion (where each hyperedge is replaced by a clique graph with uniform
weights) or the star expansion (where, for every hyperedge, a new node is added and is
linked with all the nodes in the hyperedge).

While one can think of similar constructions for the case of hypernode graphs, we prove
that there does not exist a (ﬁnite) graph expansion of a hypernode graph which deﬁnes the
same set of smooth functions over the original set of nodes. The proof is based on the very
simple hypernode graph h shown in Figure 5. Note that a function is smooth over h if and
only if it satisﬁes

(f (1) + f (2) − f (3) − f (4))2 = 0 .

(C)

We show that

Proposition 4 There do not exist a ﬁnite graph g whose node set contains {1, 2, 3, 4} and
that satisﬁes the conditions:

12

Skill Rating for Multiplayer Games with Hypernode Graphs

1. All the smooth functions on g satisfy (C).
2. Any function that satisfy (C) can be extended to a smooth function on g.

Proof Let us deﬁne S = {1, 3} and denote by ∆ the Laplacian matrix of h. The indicator
vector 1S is in Null(∆) and, thus, deﬁne a smooth function on h. Let us consider a graph
ge = (Ne, Ee) whose nodeset Ne contains the nodeset N = {1, 2, 3, 4} and that satisﬁes the
two conditions presented in Proposition 4. We denote by ∆e the Laplacian matrix of ge.
Because of the second condition, the function 1S can be extended to a smooth function fe
on ge.

Since ge is a graph, we know that Null(∆e) is spanned by the indicator vectors of the
connected components of ge (see for instance Von Luxburg, 2007). Since fe(1) = 1S(1) (cid:54)=
fe(2) = 1S(2), 1 and 2 must be in diﬀerent components in ge. Note that the same holds
with fe(1) (cid:54)= fe(4), fe(3) (cid:54)= fe(2) and fe(3) (cid:54)= fe(4). By following a similar reasoning with
S = {1, 4}, we eventually deduce that the four original nodes 1, 2, 3 and 4 must be in
distinct components in ge.

Let us now consider the components C of ge that contains the node 1. As stated above,
e of C is smooth on

e(4) = 0. The indicator function f (cid:48)

e(3) = f (cid:48)

e(2) = f (cid:48)

we have necessarily f (cid:48)
ge but we have

(f (cid:48)

e(1) + f (cid:48)

e(2) − f (cid:48)

e(3) − f (cid:48)

e(4))2 = (1 + 0 − 0 − 0)2 (cid:54)= 0 .

Consequently, f (cid:48)
proof.

e does not satisfy (C), which violates the ﬁrst condition and concludes the

The ﬁrst condition in Proposition 4 ensures that smooth functions on g are related to
smooth functions over the original hypernode graph h. The second condition in Proposi-
tion 4 ensures that smooth functions on the original hypernode graph can be deﬁned from
smooth functions over expanded ﬁnite graphs. The combination of these two conditions
ensure that the problem of ﬁnding smooth functions on h can be rephrased as a graph
problem (ﬁnding the smooth functions on g and compute their restrictions to {1, 2, 3, 4}).
The fact that no graph g can satisfy both conditions at the same time for a simple hyper-
node graph h shows that smoothness properties over hypernode graphs can not be deﬁned
over undirected expanded graphs.

1

2

1

1

1

1

3

4

∆ =







1
1
−1 −1
−1 −1

1 −1 −1
1 −1 −1
1
1
1
1







Figure 5: A hypernode graph h and its Laplacian ∆

3.6 L-equivalent Hypernode Graphs and Signed Graphs

Let us consider a symmetric positive semideﬁnite real-valued matrix M such that 1 ∈
Null(M ), M is the Laplacian of a hypernode graph by Proposition 3. But, as the square

13

Ricatte, Gilleron and Tommasi

1

1

1

3

1
1

1

1

4

2
(cid:18)1 1 −1 −1
1

0 0 −1

(cid:19)

G =

1

0.5

2

0.5
0.5

2

(cid:32)

2
0.5
√
√
2
2 −
√
2
2 −

2
2
√
2
2

−
−

G =

3

4

√

2
0

(cid:33)

0
√
2

Figure 6: two L-equivalent hypernode graphs with their respective gradient which are

square root of the Laplacian ∆ shown in Figure 7.

∆ =







1
1
−1 −1
−1 −1

1 −1 −1
1 −1 −1
0
2
2
0







; W =







0 −1 1 1
1 1
−1
0 0
1
0 0
1

0
1
1







; D =







1 0 0 0
0 1 0 0
0 0 2 0
0 0 0 2



.





Figure 7: Laplacian matrix, pairwise weight matrix, and degree matrix for the two L-

equivalent hypernode graphs shown in Figure 6.

root decomposition is not unique, there are several hypernode graphs with the same Lapla-
cian that we called L-equivalent. Examples of L-equivalent hypernode graphs are given in
Figure 6. In order to study the L-equivalent relation and to decide whether a hypernode
graph is L-equivalent to a graph, we ﬁrst show that hypernode graphs are related to signed
graphs.

It is known that the Laplacian matrix ∆ of a graph can be written D − W where W
is the adjacency matrix of the graph and D is the corresponding degree matrix. Let us
consider a hypernode graph h with Laplacian ∆, we deﬁne the pairwise weight matrix W of
h by Wi,j = −∆i,j if i (cid:54)= j, and 0 otherwise. Note that the pairwise weight matrix coincides
with the classic adjacency matrix when the hypernode graph is a graph. Let us deﬁne the
degree of a node i to be deg(i) = (cid:80)
j∈V Wi,j and let us denote by D the diagonal matrix
of all deg(i). Then, because of the property 1 ∈ Null(M ) in Proposition 3, it is immediate
that, for every i, ∆i,i = (cid:80)
j∈V Wi,j. As a consequence, we have

Proposition 5 Let h = (V, H) be a hypernode graph, let W be the pairwise weight matrix
of h, and let D be the diagonal degree matrix of h. Then, the Laplacian of h is ∆ = D − W .

An example is shown in Figure 7. As a consequence of the above proposition, we can

leverage the pairwise weight matrix to characterize L-equivalent hypernode graphs by

Proposition 6 Two hypernode graphs are L-equivalent if and only if they have the same
pairwise weight matrix. Two L-equivalent hypernode graphs have the same degree matrix.

The pairwise weight matrix W contains in general negative weights and can be thus
interpreted as the adjacency matrix of a signed graph. Therefore, we deﬁne the reduced

14

Skill Rating for Multiplayer Games with Hypernode Graphs

-1

1

2

1
1
1
1

3

4

Figure 8: The reduced signed graph with adjacency matrix W of Figure 7 of the two L-

equivalent hypernode graphs shown in Figure 6.

signed graph of a hypernode graph h to be the signed graph ˜g with adjacency matrix W .
An example is shown in Figure 8. Then, we can show that

• the reduced signed graph of a graph g (viewed as a hypernode graph) is the graph g,

• a hypernode graph h is L-equivalent to a graph if and only if its reduced signed graph

is a graph,

• a signed graph with adjacency matrix W is the reduced signed graph of a hypernode

graph if and only if the matrix D − W is positive semideﬁnite.

The deﬁnition of the pairwise weight matrix may seem ad hoc to mimic the deﬁnition
of the Laplacian in the graph case. But, we can show that the pairwise weight matrix can
be deﬁned directly from the hypernode graph using the following formula

∀i (cid:54)= j, Wi,j =

(cid:88)

h∈H

P (h, i, j)(cid:112)wh(i)(cid:112)wh(j) ,

(10)

where P (h, i, j) = 1 if i and j belongs to two diﬀerent ends of h, P (h, i, j) = −1 if i and j
belongs to the same end of h, and 0 otherwise. The pairwise weight Wi,j can be interpreted
as a ﬂow measure between node i and j in the hypergraph. It is computed as a sum over all
the hyperedges involving nodes i and j. For every term in the sum, the quantity (cid:112)wh(i)
can be viewed as the cost of entering the hyperedge h at node i, the quantity (cid:112)wh(j) as
the cost of exiting the hyperedge h at node j, and P (h, i, j) as a sign depending whether i
and j are in the same end or in diﬀerent ends of the hyperedge.

3.7 Deﬁning a distance in Hypernode Graphs

We now study whether a distance can be deﬁned between nodes of a hypernode graph. Let
us consider a hypernode graph h = (V, H) with Laplacian ∆. Let ∆† be the Moore-Penrose
pseudo-inverse of ∆, let us deﬁne d by, for every i, j in V ,

d(i, j) =

(cid:18)(cid:113)

∆†

i,i + ∆†

j,j − 2∆†

i,j

(cid:19)

.

(11)

Because ∆† is symmetric positive semideﬁnite, we have

Proposition 7 d deﬁnes a pseudometric on h: it is positive, symmetric and satisﬁes the
triangle inequality (for all i, j, k the inequality d(i, j) ≤ d(i, k) + d(k, j) holds).

15

Ricatte, Gilleron and Tommasi

For the pseudometric d to be a distance, d should satisfy also the coincidence axiom:
d(i, j) = 0 ⇒ i = j. This is not true in general as d(1, 2) = 0 for the hypernode graph
in Figure 5. The intuition is that the nodes 1 and 2 can not be distinguished because the
smoothness condition is on the sum f (1) + f (2). Nevertheless we can show that

Proposition 8 When Null(∆) = Span(1), d deﬁnes a metric (or distance) on h.

Let us recall that, in the graph case, Proposition 7 holds and that Proposition 8 holds
when the graph is connected. By analogy with the case of graphs, the condition Null(∆) =
Span(1) can be viewed as an algebraic deﬁnition of a connected hypergraph. So far, we
have not found an alternative algorithmic deﬁnition of connected components in hypernode
graphs.

Finally, let us note that, in the graph case, for connected graphs, both d and d2 are
metrics while, for hypernode graphs, d2 does not satisfy the triangle inequality even if
Null(∆) = Span(1). We provide in Ricatte et al. (2015) a formulation of d2 in terms of
diﬀusion potentials but do not ﬁnd an interpretation of d2 using random walks in hypernode
graphs.

4. Conclusion

We have introduced a new model and new algorithms to learn from binary relations between
groups. We showed that our method obtained state-of-the-art results for skill rating in
multiplayer games. We are convinced that our method could be successfully applied to
other games where players have diﬀerent roles (such as team sports like basketball, american
football or baseball) by modeling roles with weights. From a machine learning perspective,
we believe that this model will open the way to solving new learning problems in networks
when relations between sets of nodes are meaningful. From a fundamental perspective, our
model is a strict generalization of graphs. Many theoretical studies remain to be done on
the spectral theory of hypernode graphs. Note that we leave open some questions such as
ﬁnding a characterization of the class of hypernode graphs, ﬁnding an algorithmic deﬁnition
of connected components, and how to interpret random walks and distances on hypernode
graphs. Also the study of directed hypernode graphs remains to be done from a machine
learning perspective.

Acknowledgments

The authors are very grateful to the referees for their constructive comments and to the
Editor David Blei for his unwavering support.

References

Sameer Agarwal, Kristin Branson, and Serge Belongie. Higher Order Learning with Graphs.
In Proceedings of the 23rd International conference on Machine learning (ICML-06),
pages 17–24, 2006.

16

Skill Rating for Multiplayer Games with Hypernode Graphs

Andreas Argyriou, Mark Herbster, and Massimiliano Pontil. Combining Graph Laplacians
for Semi-Supervised Learning. In Proceedings of the 19th Annual Conference on Neural
Information Processing Systems (NIPS-05), pages 67–74, 2005.

Marianna Bolla. Spectra, euclidean representations and clusterings of hypergraphs. Discrete

Mathematics, 117(1):19–39, 1993.

Hubert T.-H. Chan, Louis Anand, Zhihao Gavin Tang, and Chenzi Zhang. Spectral proper-
ties of hypergraph laplacian and approximation algorithms. Journal of the ACM (JACM),
65(3 - 15), 2018.

Arpad Emrick Elo. The Rating of Chess Players, Past and Present. Arco Publishing, 1978.

Scott Hamilton. PythonSkills: Implementation of the TrueSkill, Glicko and Elo Ranking

Algorithms. https://pypi.python.org/pypi/skills, 2012.

Ralf Herbrich, Tom Minka, and Thore Graepel. TrueSkillTM: A Bayesian Skill Rating
System. In Proceedings of the 20th Annual Conference on Neural Information Processing
Systems (NIPS-06), pages 569–576, 2006.

Yeruda Koren, Liran Carmel, and David Harel. ACE: a fast multiscale eigenvectors com-
In IEEE Symposium on Information Visualization

putation for drawing huge graphs.
(INFOVIS-02), pages 137–144, 2002.

Jan Lasek, Zolt´an Szl´avik, and Sandjai Bhulai. The predictive power of ranking systems
in association football. International Journal of Applied Pattern Recognition, 1(1):27–46,
2013.

Heungsub Lee. Python implementation of Elo: A rating system for chess tournaments.

https://pypi.python.org/pypi/elo/0.1.dev, 2013a.

Heungsub Lee. Python implementation of TrueSkill: The video game rating system. http:

//trueskill.org/, 2013b.

Thomas Ricatte, R´emi Gilleron, and Marc Tommasi. Hypernode Graphs for Learning from
Binary Relations between Groups in Networks. Research report, INRIA Lille, January
2015. URL https://hal.inria.fr/hal-01247103.

JA Rodr´ıguez. On the Laplacian spectrum and walk-regular hypergraphs. Linear and

Multilinear Algebra, 51(3):285–297, 2003.

Ulrike Von Luxburg. A tutorial on spectral clustering. Statistics and computing, 17(4):

395–416, 2007.

Dengyong Zhou, Jiayuan Huang, and Bernhard Sch¨olkopf. Learning from labeled and
unlabeled data on a directed graph. In Proceedings of the 22nd International conference
on Machine learning (ICML-05), pages 1036–1043, 2005.

Dengyong Zhou, Jiayuan Huang, and Bernhard Sch¨olkopf. Learning with hypergraphs:
Clustering, classiﬁcation, and embedding. In Proceedings of the 20th Annual Conference
on Neural Information Processing Systems (NIPS-06), pages 1601–1608, 2007.

17

Ricatte, Gilleron and Tommasi

Xiaojin Zhu, Zoubin Ghahramani, John Laﬀerty, et al. Semi-supervised learning using
gaussian ﬁelds and harmonic functions. In Proceedings of the 20th International conference
on Machine learning (ICML-03), pages 912–919, 2003.

18

