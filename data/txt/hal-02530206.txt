RDF graph summarization for first-sight structure
discovery
François Goasdoué, Pawel Guzewicz, Ioana Manolescu

To cite this version:

François Goasdoué, Pawel Guzewicz, Ioana Manolescu. RDF graph summarization for first-sight
￿10.1007/s00778-020-00611-y￿.
structure discovery. The VLDB Journal, 2020, 29 (5), pp.1191-1218.
￿hal-02530206v2￿

HAL Id: hal-02530206

https://inria.hal.science/hal-02530206v2

Submitted on 24 Aug 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

RDF GRAPH SUMMARIZATION FOR
FIRST-SIGHT STRUCTURE
DISCOVERY

FRANC¸ OIS GOASDOU´E, PAWE(cid:32)L GUZEWICZ,
AND IOANA MANOLESCU

Abstract. To help users get familiar with
large RDF graphs, RDF summarization
techniques can be used. In this work, we
study quotient summaries of RDF graphs,
that is: graph summaries derived from a
notion of equivalence among RDF graph
nodes. We make the following contri-
butions: (i) four novel summaries which
are often small and easy-to-comprehend,
in the style of E-R diagrams; (ii) eﬃ-
cient (amortized linear-time) algorithms
for computing these summaries either from
scratch, or incrementally, reﬂecting ad-
ditions to the graph; (iii) the ﬁrst for-
mal study of the interplay between RDF
graph saturation in the presence of an
RDFS ontology, and summarization; we
provide a suﬃcient condition for a highly
eﬃcient shortcut method to build the quo-
tient summary of a graph without sat-
urating it; (iv) formal results establish-
ing the shortcut conditions for some of
our summaries and others from the liter-
ature; (v) experimental validations of our
claim within a tool available online.

1. Introduction

The Resource Description Framework (RDF) is
the data model recommended by the W3C for data
publishing and sharing data. An RDF graph typ-
ically consists of data triples, stating that a sub-
ject has a property with a certain value, called ob-
ject. An RDF graph may also contain type triples,
stating that some resource has the W3C standard
rdf:type property (type for short) whose value is a
certain type (or, equivalently, class). Finally, an
RDF graph may also contain an ontology, describ-
ing relationships that hold between the properties
and classes present in the graph. For instance, u1
hasName “Julie”, u1 worksFor “ACME” describe
a resource whose identiﬁer (URI) is u1, while u1
type Person assigns it a type; we use quote-enclosed
strings to denote constants (also called literals).
An ontology associated to this sample dataset may
state e.g., that worksFor rdfs:domain Employee:
this means “anyone who works for something is of

Date: Accepted on April 1, 2020 for publication in

VLDB Journal.

1

type Employee”. As a consequence, u1 type Em-
ployee also holds in the above graph, although it is
not explicitly written there. Such a triple is called
implicit (or inferred, or entailed).

RDF graphs enable describing large and hetero-
geneous data sets, which may be hard to understand
by human users, and to analyze by machines. To
help address this diﬃculty, many RDF summariza-
tion techniques have been proposed in the litera-
ture [7], some of which draw upon graph summa-
rization techniques [29] proposed independently of
RDF. As stated in [7], RDF summarization tech-
niques fall into four classes: (i) structural meth-
ods are built considering ﬁrst and foremost the
graph structure, respectively the paths and sub-
graphs present in the graph; (ii) pattern mining
methods apply mining techniques to discover pat-
terns in the data and use the patterns as a summary
(synthesis) of the graph; (iii) statistical methods
aim at extracting from the graph a set of quan-
titative measures or statistics; ﬁnally (iv) hybrid
methods combine elements from more than one of
the previous classes. For what concerns summary
applications, these range from (RDF) graph index-
ing, query cardinality estimation, to helping users
formulate graph queries, graph visualization and ex-
ploration.

A large and useful class of structural graph sum-
maries are based on deﬁning an equivalence rela-
tion among graph nodes, and creating one summary
node for each equivalence class (set of nodes equiv-
alent to each other in the original graph). Then,
for every edge labeled p which goes from s to o
in the graph, the summary has an edge labeled p
from the summary node corresponding to the equiv-
alence class of s, to the node corresponding to the
equivalence class of p. Such summaries, also called
quotient summaries, have many good properties,
mainly due to the existence of a graph homomor-
phism from the original graph into its summary.
Quotient summaries proposed for general graphs in-
clude [21, 30, 22, 23, 10, 11].

Summarizing RDF graphs raises two new ques-
tions w.r.t. to prior (non-RDF) graph summariza-
tion setting: (i) how to take into account the types
that may be attached to the nodes (knowing that
a node may have no type, or one type, or several)?
On one hand, types bring an opportunity to de-
ﬁne node equivalence, since, intuitively, two nodes
having the same type(s) are likely similar in sole
way. On the other hand, they cannot be solely re-
lied upon, because many RDF graphs lack types
for many (or all) of their nodes; prior RDF sum-
mary quotients [37, 35, 5] answer this question in
diﬀerent ways; (ii) how should a summary reﬂect
the implicit triples that may hold in the graph due

2

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

to the presence of an ontology? Our prior poster
paper [8] is the only work to have addressed this so
far.

In this work, we make several theoretical and
practical contributions to the area of quotient RDF
graph summarization. Speciﬁcally:

(1) We formalize an RDF quotient summariza-
tion framework, taking into account RDF-
speciﬁc concepts such as ontologies.

(2) We introduce

two novel equivalence rela-
tions between RDF nodes, which rely on
the transitive co-occurrence of properties
on graph nodes. Based on them we de-
ﬁne two novel summaries called Weak and
Strong respectively, as well as two versions
thereof which give priorities to types (for
those nodes that have type information);
we call these summaries Typed Weak and
Typed Strong, respectively. The interest of
these new equivalence relations is that they
lead to summaries that are much more com-
pact (fewer nodes and edges) than quotient
summaries previously studied in the litera-
ture [21, 30, 22, 23, 10, 11, 37, 35, 5]. This
compactness comes at the price of some
loss of accuracy. Nevertheless, they do pre-
serve a signiﬁcant amount of information
In particular, for
from the input graph.
domain-speciﬁc graphs, describing applica-
tions from a speciﬁc area, our summaries
are very convenient data discovery tools: a
simple summary visualization helps learn a
lot about the graph structure. This is why
our work’s main target are domain-speciﬁc
graphs. For encyclopedic graphs, such as
DBPedia or YAGO, our quotients are very
likely to be more compact than some stud-
ied in prior work, but still too large for
human comprehension; non-quotient sum-
maries, e.g., based on pattern mining [7],
are more appropriate for such graphs.
(3) We are the ﬁrst to show that for a large
set of RDF equivalence relations, one can
build the quotient summary of an RDF
graph including its implicit triples, without
materializing them. Based on our frame-
work, we provide a novel suﬃcient condi-
tion for an RDF equivalence relation, which
enables building this through our so-called
shortcut method; its advantage is to reduce
very signiﬁcantly the summarization time.
We prove that our Weak and Strong sum-
maries satisfy this condition, whereas the
Typed Weak and Typed Strong ones do not;
we provide a set of similar results also on
previously studied equivalence relations.

(4) Our fourth contribution is a set of novel al-
gorithms for computing our summaries, in-
cluding incremental ones which are able to
reﬂect the addition of triples to the graph,
without re-traversing the rest of the graph.
All our algorithms have amortized linear
complexity in the size of the graph.

(5) We have implemented these algorithms
and summary visualizations in a system
called RDFQuotient, available online in
open source1.

Sample summary visualization Below, we show
an example where our summarization techniques
compress an RDF graph structure by many orders
of magnitude, while still supporting an informative
visualization.

Figure 1 shows the summary of a WatDiv [2]
benchmark graph of approximately 11 millions of
triples. This visualization reﬂects the complete
structure of the graph, using only 8 nodes and 24
edges, comparable to a simple Entity-Relationship
diagram. This summary reads as follows. (i) Non-
leaf graph nodes belong to one of the eight disjoint
entities, each represented by a summary node (box
in Figure 1) labeled N 1 to N 8. The number of
graph nodes in each entity appears in parenthesis af-
ter the label N i of their representative, e.g., 25000
(ii) Each entity represents either graph
for N 8.
nodes with types or without types.
In the ﬁrst
case, the most general types of the graph nodes,
according to which they have been grouped in the
entity, are given in bold underneath the entity la-
bel; these coincide with the original graph node
types when an ontology is not present. For in-
stance, all the 25000 graph nodes represented by
N 8 are (implicitly) of type ProductCategory due to
the ontology at hand; their distribution according
to their original typing is also shown, e.g., 807 are
of type ProductCategory0. An entity that does not
show types represents untyped graph nodes which
have been grouped according to the relationships
they have with others, using a novel transitive re-
lation of co-occurrence of their properties, which
we introduce in this paper. For instance, N 4 repre-
sents both the web pages of the products of N 8 and
these of the persons of N 7, because these web pages
can be home pages for both: there are homepage
edges from both N 8 to N 4 and from N 7 to N 4.
(iii) Graph nodes from an entity may have outgo-
ing properties whose values are leaf nodes in the
graph; the set of all such properties appears in the
corresponding summary node box, one property per
line. For each property, e.g., nationality for N 7,
the summary node speciﬁes how many graph nodes
represented by this entity have it (19924 in this
case), and how many distinct leaf nodes are tar-
(iv) Graph
get of these edges (25 in this case).

1https://rdfquotient.inria.fr

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

3

Figure 1. ER-style visualization built from one of our summaries.

nodes from an entity may have outgoing properties
whose values are non-leaf nodes in the graph. For
a−→ n2, where n1, n2 are non-leaf
each graph edge n1
graph nodes and a is the property (edge label), an
a-labeled edge in the summary goes from the repre-
sentative of n1 to that of n2. Next to a, that sum-
mary edge is also labeled with the number of graph
edges to which it corresponds. (v) Properties from a
small, ﬁxed vocabulary are considered metadata (as
opposed to data) and therefore are not used to split
graph nodes in entities, e.g., rdf-schema#comment
and rdf-schema#label in Figure 1. More such vi-
sualization summaries can be found online1; an ex-
ample leading from an RDF graph to its summary
and then such a visualization is worked out in the
paper. Most of the material presented here is new.
The exceptions are: Theorem 2 appeared without
proof in the poster [8]; our algorithms were outlined
in the demonstration [15].

Below, Section 2 recalls useful preliminaries, then
Section 3 introduces the novel notions of property
cliques, based on which we deﬁne our summaries.
Section 4, respectively, 5 extend this to graphs com-
prising type triples, respectively, ontologies. In Sec-
tion 6 we discuss summary visualization. Section 7
describes our summarization algorithms and Sec-
tion 8 presents our experiments. We then survey
related work and conclude. Proofs of the technical
results of this paper can be found in the Appendix.

Figure 2. Sample RDF graph.

2. Preliminaries

We recall here the starting points of our work:
RDF graphs (Section 2.1) and graph quotients (Sec-
tion 2.2).

2.1. Data graphs. An RDF graph is a set of triples
of the form s p o. A triple states that its sub-
ject s has the property p, and the value of that
property is the object o. We consider only well-
formed triples, as per the RDF speciﬁcation [38],
using uniform resource identiﬁers (URIs), typed or
untyped literals (constants) and blank nodes (un-
known URIs or literals). Blank nodes are essen-
tial features of RDF allowing to support unknown
URI/literal tokens. These are conceptually similar
to the labeled nulls or variables used in incomplete
relational databases [1], as shown in [16].

4

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

As our running example, Figure 2 shows a sam-
ple RDF graph G describing a university depart-
ment, including professors, graduate students, ar-
ticles they wrote, and courses they teach and/or
take. Here and in the sequel, nodes shown in gray
are classes (or types). Further, nodes whose labels
appear enclosed in quotes, e.g., “d1”, are literals,
while the others are URIs.
RDFS ontology. One can enhance the resource
descriptions comprised in an RDF graph by declar-
ing ontological constraints between the classes and
the properties they use. For instance, one may add
to the graph in Figure 2 the ontology O consisting
of the triples

GradStud rdfs:subClassOf Instructor
Professor rdfs:subClassOf Instructor

takes rdfs:range Course
takes rdfs:domain Student

advises rdfs:subPropertyOf knows

to state that graduate students, respectively pro-
fessors, are instructors, that anyone who takes a
course is a Student, what can be taken is a course,
and that advising someone entails knowing him or
her.

From ontological constraints and explicit triples,
implicit triples may be derived. For instance, from
G and O, it follows that p1 is of type Instructor,
which is modeled by the implicit triple p1 type In-
structor; we say this triple holds in G, even though
it is not explicitly part of it. Other implicit triples
obtained from this ontology based on G are: p2 type
Instructor, p2 type Student, and p1 knows p2. Given
a graph G (which may include a set of ontological
constraints, denoted O), the saturation of G, is ob-
tained by adding to G: (i) all the implicit triples de-
rived from G and O, then (ii) all the implicit triples
derived from those of step (i) and O, and so on, un-
til a ﬁxpoint, denoted G∞, is reached. These triples
are added based on RDF entailment rules from
the RDF standard. In this work, we consider the
widely-used RDFS entailment rules. They exploit
the simple RDFS ontology language, based on the
four standard properties illustrated above, which
we denote subClass, subProperty, domain and
range, to add new ontological constraints or facts.
The saturation G∞ of any graph G comprising RDFS
ontological constraints is ﬁnite, unique, and can be
computed in polynomial time, e.g., by leveraging a
database management system [16]. Crucially, G∞
materializes the semantics of G.
Terminology and notations. We call the triples
from G whose property is (rdf:)type type triples,
those whose property is among the standard four
RDFS ones schema triples, and we call all the other
data triples. We say a node is typed in G if the node
is the subject of at least one type triple in G.
In
the graph shown in Figure 2, p1 type Professor is a
type triple, hence the node p1 is typed, p1 advises
p2 is a data triple, while Professor rdfs:subClassOf
Instructor may be a schema triple. Further, we say

a URI from G is a class node if (i) it appears as
subject or object of a subClass triple, or an object
of range or domain triple; or (ii) it appears as the
object of a type triple; or (iii) it appears as a sub-
ject of a type triple with object rdfs:Class. We call
property node, a URI appearing (i) as subject or
object in subProperty triple, or as a subject of do-
main or range triple; or (ii) as a subject of rdf:type
triple with object rdf:Property. Together, the class
and property nodes are the schema nodes; all non-
schema nodes are data nodes. In Figure 2, Profes-
sor and GradStudent are class nodes. If we consider
the aforementioned ontology O, takes, advises and
knows are property nodes. Finally, the a’s, p’s, c’s
and d’s nodes are data nodes.

It is important to stress that not all nodes in an
RDF graph are typed, e.g., this is only true for p1
and p2 in Figure 2. Further, some nodes may have
several types, in particular due to saturation (e.g.,
p2 is of types GradStudent and Instructor) but not
only, e.g., p1 could also be of type ForeignStudent
etc.

2.2. Quotient RDF summaries. We recall here
quotient RDF summaries as deﬁned in prior work,
outline existing work in this area, and discuss their
limitations.

Given an RDF graph G and an equivalence rela-
tion2 ≡ over the nodes of G, the quotient of G by
≡, denoted G/≡, is the graph having (i) a node for
each equivalence class of ≡ (thus, for each set of
a−→ n2
equivalent G nodes); and (ii) for each edge n1
a−→ m2, where m1, m2 are the quo-
in G, an edge m1
tient nodes corresponding to the equivalence classes
of n1, n2 respectively. Quotients have several desir-
able properties from a summarization perspective:

Size guarantees:: By deﬁnition,

G/≡ is
guaranteed to have at most as many nodes
and edges as G. Some non-quotient sum-
maries, e.g., Dataguides [17], cannot guar-
antee this.

Property completeness:: Every property
(edge label) from G is present on some sum-
mary edges. This gives ﬁrst-time users of
the dataset a chance to decide, based on
their interest and envisioned application, if
In some
it is worth further investigation.
applications, e.g., when data journalists ex-
plore open data, or physicians look for a
rare diagnosis, it is important not to miss a
“weak signal”, encoded in RDF as a set of
triples using infrequent properties.

Structural homomorphism:: It is easy to
see that the function f associating to any

2An equivalence relation ≡ is a binary relation that is
reﬂexive, i.e., x ≡ x, symmetric, i.e., x ≡ y ⇒ y ≡ x, and
transitive, i.e., x ≡ y and y ≡ z implies x ≡ z for any x, y, z.

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

5

G node, its representative in G/≡ is a ho-
momorphism from G into its summary: any
subgraph of G is “projected” by f into a
subgraph of its quotient.

a−→ m1, G also comprises an edge n2

Quotient graph summaries include e.g., [30, 22,
10, 36, 25, 11, 13]; RDF quotient summaries are
described in [37, 35, 5].
Bisimilarity is behind most equivalence relations
used in these works. Two nodes n1, n2 are forward
bisimilar [21] (denoted ≡fw) iﬀ (i) for every G edge
a−→ m2, such
n1
that m1 and m2 are also (forward) bisimilar and
(ii) a similar statement holds, replacing n1, m1 with
n2, m2 and vice-versa. While forward bisimilarity
focuses on outgoing edges only, two nodes can also
be bisimilar w.r.t. their incoming edges, i.e., back-
ward bisimilar (denoted ≡bw). Backward similarity
of two nodes n1, n2 is recursively deﬁned similarly
a−→ n1 and
as above when considering G edges m1
a−→ n2. Finally, two nodes can be bisimilar based
m2
on both their incoming and outgoing edges, i.e., for-
ward and backward bisimilar (denoted ≡fb), when
they are both forward bisimilar and backward bisim-
ilar. We denote the bisimulation based summaries
G/fw (forward), G/bw (backward) and G/fb (forward
and backward), respectively. They have been stud-
ied, in particular for indexing and query processing,
in [37, 5, 35].
Leaf (resp. root) collapse An issue encountered
when summarizing only according to the properties
outgoing a node, e.g., ≡fw, is that the summary con-
siders equivalent (thus, collapses) all nodes lacking
outgoing edges, that is, all the leaves of G. Such leaf
nodes may have very little to do with each other.
For instance, on the WatDiv graph summarized in
Figure 1, all the values of award, numberOfPages,
keywords, email, faxNumber would be summarized
together, even though they are very diﬀerent. We
call this situation leaf collapse through summariza-
tion. symmetrically, a summary whose relation only
depends on nodes’ incoming properties, e.g., ≡bw,
automatically summarizes together all nodes with
no incoming edges, although again they may repre-
sent very diﬀerent things; we call this root collapse.
We argue that a good summary should not system-
atically collapse leaves (respectively, roots), but do
so only when they really are similar to each other.
Bisimulation summaries tend to be large, be-
cause bisimilarity is rare in heterogeneous graphs.
For instance, in Figure 2, none of p1, p2, . . . p5 is
bisimilar to the other, due to slight diﬀerences in
their properties; similarly, the courses c1, c2 and
c3 are not bisimilar, because c3 lacks a description,
c2 is the only one target of a “takes” triple etc.
Our experiments in Section 8 conﬁrm this on many
graphs.
Bounded bisimilarity To mitigate this problem,
k-bisimilarity was introduced [23]. For some integer

Figure 3. 1fb summary of the
RDF graph in Figure 2.

Figure 4. 1fw summary of the
RDF graph in Figure 2.

k, nodes are k-forward (and/or backward) bisimilar
iﬀ they are bisimilar within their k-bound neighbor-
hoods. One drawback of k-bisimilarity is that it re-
quires users to guess the k value leading to the best
compromise between compactness (favored by a low
k, e.g., if k = 0, all the graph nodes are equivalent,
and the summary has a single node) and structural
information in the summary (high k). RDF quo-
tients based on k-bisimilarity are studied in [37, 5].
It turns out that even 1-bisimilarity is rare in
heterogeneous graphs. For instance, Figure 3 shows
the 1fb summary of the sample graph in Figure 23.
Here and throughout this paper, summary nodes are
shown in rectangles and are labeled N1, N2 etc.;
we abridge property names to use w for wrote, a
for advises, te for teaches, ta for takes and cd for
coursedescr. Nodes N3, N4 and N8 represent, re-
spectively, p1, p2, p3; the three courses are repre-
sented by N1 and N6. This summary is almost as
complex as the input graph. Figure 4 shows the 1fw
summary of our sample G: it is smaller (only 5 nodes
and 10 edges, whereas the 1fb one has 8 nodes and
12 edges). However, as our experiments show, 1fw
summaries are still too large to be useful for visual-
ization. The 1fw summary, denoted ∼a in [5], is also
very similar to grouping nodes into “characteristic
sets” [18, 32]; they all suﬀer from the leaf collapse
issue described above. For instance, they summa-
rize together all articles and course descriptions (N2
in Figure 4).

To avoid too many characteristic sets (or, equiv-
alently, to reduce the number of summary nodes),
[32] proposes a cardinality-based heuristic method
which merges them into maximum r sets, for a user-
speciﬁed threshold r. We do not burden the user
with choosing such a threshold; as our experiments
show, some graphs are much more complex than

3The summaries shown in the Figures 3, 4 and 5 ignore
the type triples of G for readability and because they were
not used for summarization in the referenced works.

6

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

G
G∞

type
sc, sp

domain, range

≡S
≡W
G/S
G/W
≡TW

≡TS

G/TW

G/TS

(cid:108)

(Sec-

rdfs:range

RDF graph
the result of saturating G (Sec-
tion 2.1)
rdf:type (Section 2.1)
rdfs:subClassOf,
rdfs:subPropertyOf (Section 2.1)
rdfs:domain,
tion 2.1)
strong equivalence (Deﬁnition 2)
weak equivalence (Deﬁnition 3)
strong summary of G (Deﬁnition 5)
weak summary of G (Deﬁnition 4)
typed weak
tion 4.2)
typed
tion 4.2)
typed
weak
G(Deﬁnition 6)
typed strong summary of G (Sec-
tion 4.2)
strong
tion 7)

homomorphism (Deﬁni-

equivalence

equivalence

summary

strong

(Sec-

(Sec-

of

Table 1. Summary of the
notations used in the article.

Another limitation of prior work is not consid-
ering how summarization interacts with saturation,
and instead simply assuming that G is already sat-
urated. When this is not the case, obtaining the
summary of G∞ requires ﬁrst computing this satu-
ration, which may be costly in terms of computation
time and storage space.

To go beyond these limitations, in the sequel, we
introduce our novel equivalence relations, leading
to compact and informative quotient summaries of
RDF graphs, whether they are fully typed, have no
types at all, or are anywhere in between. Further,
we provide novel, advanced techniques for summa-
rizing a graph’s saturation without saturating it;
this can lead to speed-ups of orders of magnitude.
The notations we use in this work are compiled in
Table 1.

3. Data graph summarization

We ﬁrst consider graphs made of data triples
only. We deﬁne the novel notion of property cliques
in Section 3.1; building on them, we devise new
graph node equivalence relations and correspond-
ing graph summaries in Section 3.2. Summariza-
tion will be generalized to handle also type triples
in Section 4.

3.1. Data property cliques. Let us consider the
ways in which data properties (edge labels) are or-
ganized in a graph. The simplest relation is co-
occurrence, when a node is the source (or target) of
two edges carrying the two labels. However, as illus-
trated in Figure 2, two properties, such as wrote and

Figure 5. ∼ioa summary [5] of
the RDF graph in Figure 2.

others, thus it is not easy to set r, especially for
users not yet acquainted with the data, such as the
ones we target.

In [5], any RDF equivalence relation (thus, any
RDF quotient) considers all the leaf nodes, whether
URIs or literals, as equivalent, and represents them
by a single summary node denoted [0]. Thus, all
their summaries automatically suﬀer from the leaf
collapse issue. For instance, their 1fb equivalence
(denoted ∼ioa) leads to the summary shown in Fig-
ure 5. This may signiﬁcantly reduce the number of
summary nodes, since only one of them is a leaf.
However, as reported in [5] and veriﬁed in our ex-
periments, their bisimilarity-based summaries are
still too large for visualization.
Type-driven summarization The remaining
equivalence relations used in the literature to sum-
marize RDF graphs are (also) based on RDF types.
In [5], two nodes are ∼t-equivalent if they have
exactly the same types. This collapses all untyped
nodes in a single summary node, e.g., all but p1
and p2 in Figure 2, and ﬁve out of the eight nodes
in Figure 1 (N2, N3, N4, N5 and N6), even though
they are unrelated.

[5] also introduces ∼ioat, which considers two
nodes equivalent iﬀ they are 1fb equivalent and
they have exactly the same types. Thus, a ∼ioat
summary has at least as many nodes and edges as
the ∼ioa one; our experiments conﬁrm it is too large
to be used for ﬁrst-sight visualization.

To conclude, the equivalence relations used in

prior RDF quotient summaries are based on:

(1) Bisimilarity (possibly bounded to a max-
imum distance k), which leads to complex
summaries with very high numbers of nodes
and edges, unsuited for ﬁrst-sight discovery.
(2) Uni-directional bisimilarity (i.e., ≡fw, ≡bw
and their bounded variants), which suﬀer
from leaf or root collapse;

(3) Types alone:

this collapses all untyped
nodes, even when their data properties have
nothing to do with each other;

(4) Bisimilarity and having the same types; this
leads to summaries at least as large as those
based on bisimilarity alone.

Leaf collapse is also present in all the equivalences
of [5].

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

7

SC1
SC2
SC3

T C1
T C2
T C3
T C4
T C5

Source clique and nodes having this source clique:
{advises, takes, teaches, wrote}: p1, p2, p3, p4, p5
{coursedescr }: c1, c2, c3
∅: a1, a2
Target clique and nodes having this target clique:
{advises}: p2, p5
{teaches, takes}: c1, c2, c3
{coursedescr }: d1, d2
{wrote}: a1, a2
∅: p1, p3, p4
2. Source
Table
cliques of G nodes (Figure 2).

target

and

advises, may co-occur on one node, while another
one may have wrote and teaches. The main intu-
ition of our work is to consider all these properties
(wrote, advises, teaches) related, as they directly
or transitively co-occur on some nodes. Formally:

Deﬁnition 1.
cliques) Let p1, p2 be two data properties in G:

(Property relations and

(1) p1, p2 ∈ G are source-related iﬀ either: (i) a
data node in G is the subject of both p1 and
p2, or (ii) G holds a data node that is the
subject of p1 and of a data property p3, with
p3 and p2 being source-related.

(2) p1, p2 ∈ G are target-related iﬀ either: (i) a
data node in G is the object of both p1 and
p2, or (ii) G holds a data node that is the
object of p1 and of a data property p3, with
p3 and p2 being target-related.

A maximal set of data properties in G which are
pairwise source-related (respectively, target-related)
is called a source (respectively, target) property
clique.

In the graph in Figure 2, properties advises and
teaches are source-related due to p4 (condition (i)
in the deﬁnition). Similarly, advises and wrote are
source-related due to p1; consequently, teaches and
wrote are source-related (condition (ii)). Further,
the graduate student p2 teaches a course and takes
another, thus teaches, advises, wrote and takes are
all part of the same source clique. Table 2 shows
the target and source cliques of all data nodes from
Figure 2.

It is easy to see that the set of non-empty source
(or target) property cliques is a partition over the
data properties of G. Further, if a node n ∈ G is a
source of some data properties, they are all in the
same source clique; similarly, all the properties of
which n is a target are in the same target clique.

3.2. Strong and weak node equivalences.
Building on property cliques, we deﬁne two node
equivalence relations among the data nodes of a
graph G:

Deﬁnition 2. (Strong equivalence) Two data
nodes n1, n2 of G are strongly equivalent, denoted

Figure 6. Weak summary of the
RDF graph in Figure 2 (type
triples excluded).

n1 ≡S n2, iﬀ they have the same source and target
cliques.

Strongly equivalent nodes have the same struc-
ture of incoming and outgoing edges. In Figure 2,
nodes p1, p3 and p4 are strongly equivalent to each
other. Among these, note that p1 and p3 may seem
very dissimilar: p1 has the properties {wrote, ad-
vises} while p3 has only {teaches}. These nodes
are strongly equivalent due to the node p4 which
has a common outgoing property with p1, and one
with p3. Similarly, p2, p5 are strongly equivalent,
and so are c1, c2 and c3 etc. The transitivity built in
strong equivalence through the use of cliques allows
to recognize all these publication nodes as equiv-
alent, and avoid separating them (as ≡fb and ≡fw
do, recall Figures 3, 4 in Section 2.2). Thus, clique-
based equivalence avoids the pitfall of leading to too
many nodes for a readable visualization.

A second, weaker notion of node equivalence re-
quests only that equivalent nodes share the same
incoming or outgoing structure, i.e., they share the
same source clique or the same target clique. For-
mally:

Deﬁnition 3. (Weak equivalence) Two data
nodes n1, n2 are weakly equivalent, denoted n1 ≡W
n2, iﬀ: (i) they have the same non-empty source
or non-empty target clique, or (ii) they both have
empty source and empty target cliques, or (iii) they
are both weakly equivalent to another node of G.

It is easy to see that ≡W and ≡S are equivalence
relations and that strong equivalence implies weak
equivalence, noted ≡S⇒≡W.

In Figure 2, p1, . . . , p5 are weakly equivalent to
each other due to their common source clique SC1;
a1, a2 are weakly equivalent due to their common
target clique etc.

From the deﬁnitions above and the equivalence
notions recalled in Section 2.2, it follows that ≡1fb
is more restrictive than ≡S (≡1fb⇒≡S⇒≡W). How-
ever, ≡S and ≡W, which reﬂect outgoing and incom-
ing properties, are in general incomparable with
≡1fw and ≡1bw, which only outgoing, respectively,
incoming properties. The transitive aspect of prop-
erty cliques is a radical departure from previously
It
considered equivalence relations (Section 2).
gives ≡S and ≡W the ﬂexibility to accept as equiv-
alent structurally heterogeneous nodes, leading to
summaries which are both meaningful and compact.

8

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

Figure 7. Strong summary of the
RDF graph in Figure 2 (type
triples excluded).

Property nodes equivalence We make an im-
portant addition to the clique-based equivalences
introduced above. A property node (Section 2.1),
that is, a node (subject or object) labeled by an URI
which also appears as a property of a data node, is
only ≡W and ≡S to itself. Property nodes are pretty
rare, but they do occur in some RDF graphs; an ex-
ample would be the subject of a triple such as takes
deﬁnedBy studentOﬃcerX, where takes appears as
a data property in Figure 2. A triple comprising a
property node can be seen as a form of metadata,
which helps interpret/understand the graph’s data
triples. Thus, we consider that a property node is
only equivalent to itself.

3.3. Weak and strong summarization. Weak
summarization. The ﬁrst summary we deﬁne is
based on weak equivalence:

Deﬁnition 4. (Weak summary) The weak sum-
mary of a data graph G, denoted G/W, is its quotient
graph w.r.t. the weak equivalence relation ≡W.

The weak summary of the graph in Figure 2 is
depicted in Figure 6. N1 represents all the people
(p1 to p5), N2 represents the courses, N3 the articles
and N4 the course descriptions. Note the self-loop
from N1 to itself; it denotes that some nodes rep-
resented by N1 advise some nodes represented by
N1. This summary has only 4 nodes and 5 edges; it
is smaller (at most half as many edges) and much
easier to grasp than the 1fb, 1fw and ∼ioa ones,
shown in Section 2. At the same time, it conveys
the essential information that some nodes advise,
write, also they teach and take something that has
course descriptions.

Generally speaking, node Ni in the weak sum-
mary G/W of a graph G represents all the G nodes
whose outgoing (respectively, incoming) properties
are a subset of the outgoing (resp., incoming) prop-
erties of Ni.

The weak summary has the following important

property:

Proposition 1. (Unique data properties)
Each G data property appears exactly once in G/W.

We exploit this to eﬃciently build weak graph

summaries (Section 7).

We remark that the weak summary G/W of a
graph G has minimal size (in the number of edges)

among all the quotient summaries of G: every prop-
erty labeling a G edge appears exactly once in G/W,
while, by deﬁnition, it appears at least once in any
quotient summary (Section 2.2). Our experiments
show that |G/W| is typically 3 to 6 orders of magni-
tude smaller than |G|.

Strong summarization. Next, we introduce:

Deﬁnition 5. (Strong summary) The strong
summary of the graph G, denoted G/S, is its quotient
graph w.r.t. the strong equivalence relation ≡S.

The strong summary of the graph of Figure 2
is shown in Figure 7. Similarly to the weak sum-
mary (Figure 6), the strong one groups all courses
together, and all articles together. However, it sep-
arates the person node in two: those represented by
N1 advise those represented by N2. This is because
the target clique of p1, p3 and p4 is empty, while
the target clique of p2 and p5 is {advises} (Table 2).
Due to this ﬁner granularity, in G/S, several edges
may have the same label, e.g., there are two teaches
and two wrote edges in Figure 7, whereas in G/W,
as stated in Proposition 1, this is not possible. Our
experiments (Section 8) show that while G/S is often
somehow larger than G/W, it still remains many or-
ders of magnitude smaller than the original graph.
By deﬁnition of ≡S, equivalent nodes have the
same source clique and the same target clique. This
leads directly to the next result, exploited by our al-
gorithms for building strong summaries (Section 7):

Proposition 2. (Strong summary nodes and
G cliques) G/S has exactly one node for each source
clique and target clique of a same G data node.

From the strong to the weak summary. Be-
cause strong equivalence implies weak equivalence,
it follows that (G/S)/W = G/W. For instance, the
nodes N1 and N2 in Figure 7 have the same source
clique, thus the weak summary of the graph in Fig-
ure 7 is exactly the one in Figure 6. Hence, one can
get both G/W and G/S by building G/S and then weakly
summarizing it to also get G/W. This is (much) faster
than re-summarizing G, mainly because G/S is much
smaller than G. Another consequence is that G/W, in-
tuitively, compresses more (is more imprecise) than
4; we demonstrate this also through experiments
G/S
(Table 6 in Section 8).
Property node representation. Since property
nodes represent a form of metadata about the data
graph, we decide that in all our quotient summaries
they are always represented by themselves, i.e., a
node labeled with the same URI.
SameAs and generic properties. Some special
properties frequently used in RDF deserve a special

4One example among many: the W summary of a BSBM
1M graph has just one node, whereas the S summary has 5
and is quite informative (https://rdfquotient.inria.fr/
files/2019/11/bsbm1m_s_split_and_fold_leaves.png).

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

9

treatment. First, the standard owl:sameAs prop-
erty is used to denote that two URIs should be
considered as being “the same”; in particular, the
incoming/outgoing edges of one should also be con-
sidered as belonging to the other. To reﬂect this
special semantics, we extend our notion of clique
to treat the properties incoming/outgoing two nodes
connected by sameAs (directly or indirectly) as if
they occurred on the same node. This ensures that
any two nodes connected by sameAs have the same
source and target clique, thus they are weakly and
strongly equivalent. Second, some generic proper-
ties such as rdfs:label are sometimes used to an-
notate RDF nodes with very diﬀerent meaning.
Building cliques based on the co-occurrence of such
generic properties may consider too many nodes
equivalent. To avoid this, we build our cliques ig-
noring the triples whose properties are generic, con-
struct G/W or G/S accordingly, then, for each triple of
the form n1 rdfs:label t (where t is some text), we
add an edge N1 rdfs:label N2 to the weak or strong
summary, where N1 is the representative of n1, and
N2 is a new summary node, representing t.

4. Typed data graph summarization

We now discuss the summarization of graphs
with data and type triples. Types represent domain
knowledge that the data producers found meaning-
ful to describe it. However, some or all nodes of a
graph may lack types.

Only a few RDF graph summarization works ex-
plicitly considered type triples. The equivalence
relation ∼t introduced in [5] follows an approach
we call type-only: nodes are equivalent if they have
exactly the same types. This approach groups to-
gether all untyped nodes, which is problematic in
graphs such as the one summarized in Figure 1.
The same approach is taken in [27] which further
assumes that all non-leaf nodes are typed, a sup-
position not borne out in practice (see again Fig-
ure 1). A diﬀerent approach we term data-and-type
is taken in [5]: for two nodes to be equivalent, they
should both be equivalent according to a relation
that only reﬂects their data properties, and have
the same types. For instance, ∼ioat is based both
on having the same input and output properties
(∼ioa), and the same types. As explained in Sec-
tion 2, this splits graph nodes into many equivalence
classes (summary nodes), which is not desirable for
ﬁrst-sight visualization.

A better approach introduced in [5] to reﬂect
types in a quotient summary built from an equiv-
alence relation ≡ is as follows: ﬁrst, summarize G
ignoring type triples, and second, for each triple
n type C in G, add to G/≡ a triple N type C, where N
represents n in G/≡. We call this quotient summa-
rization approach data-then-type. It does not suﬀer

Figure 8. Weak summary of the
graph in Figure 2.

from the disadvantages of type-only nor data-and-
type. Instead, it allows to identify meaningful node
groups even in graphs where some or all the nodes
lack types.

Below, we start by formalizing the special treat-
ment we argue should be given to class and prop-
erty nodes in any RDF quotient summary. Based
on this, we extend the data-then-type approach to
our clique-based equivalence relations (Section 4.1),
then present another novel approach which we call
type-then-data. It gives priority to types when avail-
able, while still avoiding the pitfalls of type-only
and data-and-type summarization (Section 4.2).

Class node equivalence and representation.
To ensure quotient summaries preserve the applica-
tion knowledge encoded within the classes, proper-
ties and ontology of a graph, we decide that in any
equivalence relation ≡, any class node is only equiv-
alent to itself, and any class node is represented by
itself, and similarly for property nodes. Hence, a
typed data graph has the same class nodes, and the
same property nodes (Section 3), as its summary.

4.1. Data-then-type summarization. We ex-
tend the W, respectively S summaries to type triples,
by stating that they follow the data-then-type ap-
proach.

Figure 8 illustrates this for G/W; note that N1
is attached both Professor and GradStudent types.
Generally, a typed node Ni in a typed weak sum-
mary represents all
the G nodes whose incom-
ing/outgoing properties are included in those of Ni,
some of which may also have some of the types of
Ni; the G nodes represented by an untyped node Nj
are the same as in a weak summary.

Figure 9 shows the strong summary of our sample
graph when type triples are considered. Note that
the Professor type is attached to N1, the represen-
tative of p1, p3 and p4 (those who advise someone),
while GradStudent is attached to N5, representing
the advisees (p2 and p5).

4.2. Type-then-data summarization. This ap-
proach is novel. In contrast with data-then-types, it
considers that node types are more important when
deciding whether nodes are equivalent, however, it
still relies on data properties to summarize untyped
nodes. Thus, from an equivalence relation ≡ (based
on data properties alone), we derive a novel typed

10

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

Figure 9. Strong summary of the
graph in Figure 2.

Figure 10. Typed weak sum-
mary of the graph in Figure 2.

equivalence relation whereas two nodes are equiva-
lent if:

• both are typed, and they have the same set

of types;

• or, both are untyped, and they are equiva-

lent according to ≡.

For weak summarization, this approach leads to:
Deﬁnition 6. (Typed weak summary) Let ≡TW
(typed weak equivalence) be an equivalence rela-
tion that holds between two data nodes n1, n2 iﬀ
(i) n1, n2 have no types in G and n1 ≡W n2; or
(ii) n1, n2 have the same non-empty set of types
in G. The typed weak summary G/TW of a graph G
is denoted G/TW.

Figure 10 shows the typed weak summary of our
sample RDF graph. Unlike G/W (Figure 6), G/TW rep-
resents p1 by N1, separately from p3, because p3 is
of type Person, while p3 is untyped.

In a similar manner, we deﬁne typed strong
equivalence, denoted ≡TS, as in Deﬁnition 6 by re-
placing ≡W with ≡S, and denoting by G/TS the typed
strong summary of a graph G. In our example,
G/TS coincides with G/TW.
From the typed strong to typed weak sum-
mary. It is easy to see that if n1 ≡TS n2, then also
n1 ≡TW n2, therefore (G/TS)/TW = G/TW. This also al-
lows building G/TS and G/TW for almost the cost of
building G/TS alone, as this summary is small and
thus summarized quickly.

Summary equality. We now consider when two
of our summaries may coincide for a given graph G,
i.e., they are the same up to their data node labels
N1, N2 etc. To formalize this, we deﬁne:
Deﬁnition 7. (Strong isomorphism (cid:108)) A
strong isomorphism between two RDF graphs G1, G2,
noted G1 (cid:108) G2, is an isomorphism which is the iden-
tity for the class and property nodes.

We remark that

for visualization purposes,
strongly isomorphic summaries can be seen as iden-
tical, as they describe exactly the same structure.

5. Summarization of graphs with RDFS

ontologies

We now turn to the general case of an RDF graph

with an RDFS ontology.

First, observe that any summary of an RDF
graph has the same RDFS ontology as this graph.
This is because: (i) every property node is only rep-
resented by itself (Section 3.2), (ii) every class node
is represented by itself (Section 3.3), and (iii) by
deﬁnition of an RDF quotient, any ontology triple,
which only connects two class or property nodes, is
“copied” in the summary. We view ontology preser-
vation as a desirable feature, since the ontology has
crucial information about the meaning of the data5.
Second, we identify two ways in which an ontol-

ogy can impact summarization:

Through type generalization:: Type-

then-data summarization (Section 4.2)
groups nodes by their sets of types.
If
the ontology features triples of the form
c1 sc c2, it can be argued that c2 can be
used instead of c1 to summarize a resource
having the type c1. We study this in
Section 5.1.

Through implicit triples:: As

we

ex-
plained in Section 2, the semantics of an
RDF graph G includes its explicit triples,
but also its implicit triples which are not
in G, but hold in G∞ due to ontological
constraints (such as the triples p2 type
Instructor, p2 type Student, and p1 knows
p2 in Section 2.1). An interesting question,
then, is to determine the interplay between
saturation and summarization: how is the
summary of G∞ related to that of G, ﬁrst,
in general (for any quotient summary),
and then,
summaries we
the four
introduced? The rest of the section is
devoted to this topic.

for

5.1. Type-then-data
summarization using
most general types. The most commonly used
feature of RDFS ontologies is the subClass relation-
ship, stating that any resource of a type c1 is also
of the type c2; “subtype” and “supertype” are com-
monly used to denote c1 and c2 in such settings.
The subgraph consisting of the subClass triples of
a graph is typically acyclic (if a loop existed, all the
types involved in the loop would be equivalent for

5While we consider the ontology very important, our goal
is to bring the much more numerous data and type (non-
ontology) triples to a visually comprehensible size through
summarization. When present, the ontology may help visu-
alize the data; the ontology itself may be summarized etc.

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

11

all practical purposes and could be replaced with
any among them); we assume below that this is the
case, thus the types present in G can be organized in
a directed acyclic graph (DAG). While class nodes
are very often much fewer than data nodes, they
can still be too numerous for a small visualization
to include or reﬂect all of them. For instance, there
are more than 500 product types labeled Product-
Type1, ProductType2 etc. in a BSBM benchmark
graph of 100M triples, a WatDiv benchmark graph
of 10M triple comprises 14 product category types,
or the real-life DBLP dataset includes a dozen types
of scientiﬁc publications. Applying type-then-data
summarization to such a graph would lead to a high
number of nodes, one for each type; this appears
shortsighted, given that in these examples, a natu-
ral common supertype can be found, e.g., Product-
Type, ProductCategory, and Publication, respec-
tively.

To obtain compact type-then-data summaries
even in the presence of such ontologies, we adopt
the following practical solution:

• For each typed data node x ∈ G, let τ (x) be
the set of all types associated to x in G, and
τ (x) the set comprising the most general
supertypes of the types in τ (x)6, which can
be easily computed based on the subClass
triples.

• Then, type-then-data summarization
based on most general types uses τ (x)
instead of τ (x). This is how we obtained
the graph in Figure 1: there, N1 represents
all the nodes whose most general type set
comprises exactly http://db.uwaterloo.
ca/~galuc/wsdbm/Genre, and similarly for
N8 and the type http://db.uwaterloo.
ca/~galuc/wsdbm/ProductCategory.
This technique can be applied to both typed

weak and typed strong summarization.

5.2. Interactions between summarization and
saturation. First, does saturation commute with
summarization? In other words, is (G∞)/≡ strongly
isomorphic (Deﬁnition 7) to (G/≡)∞? Figure 11
shows that this is not always the case; sp denotes
the standard property RDFS rdfs:subPropertyOf
(Section 2.1). For a given graph G, the ﬁgure shows
its weak summary G/W and its saturation (G/W)∞, as
well as G∞ and its summary (G∞)/W. Here, satura-
tion leads to b edges outgoing both r1 and r2 which
makes them equivalent in G∞.
In contrast, sum-
marization before saturation represents them sepa-
rately; saturating the summary cannot unify them

6We exclude a few “standard” root types, such as
rdfs:Resource in RDF Schema or OWL:Thing, from the su-
pertype hierarchy, as these would not bring useful informa-
tion to summary users.

G

summarization

G/W

saturation

(G/W)∞

r1

saturation
r2
r2

b1

b2

G∞

r1

r2

x

y1
y2

z

b

a
b1

b2
c

sp
sp

a
b1

b2
c

sp
sp

b1

b2

a
b1
b
b
b2
c

sp
sp

b

b

b1

b2

y1

saturation
x
a
b1
b
b
b2
c

y2

z

(G∞)/W

a
b1
b
b2
c

b1

b2

sp
sp

b

b1

sp

b

sp

b2

Figure 11. Saturation and sum-
marization example.

Theorem 1

Theorem 2

G

∞

G∞

f1

f repr. fn. of summarizing G

G/≡

∞

f homomorph. by Theorem 1

(G/≡)∞

f2

(G∞)/≡

(cid:108) by Theorem 2

((G/≡)∞)/≡

Figure 12. Illustration for Theo-
rem 1 and Theorem 2.

as in (G∞)/W (recall from Section 2.1 that saturation
can only add edges in a graph).

While (G∞)/≡ and (G/≡)∞ are not strongly iso-
morphic in general, we establish that they always
relate as follows (see the diagram in Figure 12):

Theorem 1. (Summarization homomorphism)
Let G be an RDF graph, G/≡ its summary and f the
corresponding representation function from G nodes
to G/≡ nodes. Then f deﬁnes a homomorphism
from G∞ to (G/≡)∞.

Since (G/≡)∞ is homomorphic to G∞, would their
summaries coincide, i.e., be strongly isomorphic?
It turns out that this may hold or not depending
on the RDF equivalence relation under considera-
tion. When it holds, we call shortcut the follow-
ing three-step transformation aiming at obtaining
a summary strongly isomorphic to (G∞)/≡, instead
of (G∞)/≡ itself: ﬁrst summarize G; then saturate
its summary; ﬁnally, summarize it again in order to
build ((G/≡)∞)/≡:
Deﬁnition 8. (Shortcut) We say the shortcut
holds for a given RDF node equivalence relation ≡

12

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

iﬀ for any G, (G∞)/≡ and ((G/≡)∞)/≡ are strongly
isomorphic.

Note that from a practical viewpoint, hence for
visualization, (G∞)/≡ and ((G/≡)∞)/≡ are equiva-
lent as they diﬀer just in their data node IDs (e.g.,
N1, N2 etc. in Figure 1), which carry no particular
meaning.

Next, we establish one of our main contributions:
a suﬃcient condition under which for any quotient
summary based on an equivalence relation ≡ as dis-
cussed above (where class and property nodes are
preserved by summarization), the shortcut holds.
In particular, as we will demonstrate (Section 8),
the existence of the shortcut can lead to computing
(G∞)/≡ substantially faster by actually computing
((G/≡)∞)/≡.
Theorem 2. (Sufficient shortcut condition)
Let G/≡ be a summary of G through ≡ and f the
corresponding representation function from G nodes
to G/≡ nodes (see Figure 12).

If ≡ satisﬁes: for any RDF graph G and any pair
(n1, n2) of G nodes, n1 ≡ n2 in G∞ iﬀ f (n1) ≡ f (n2)
in (G/≡)∞, then the shortcut holds for ≡.

Figure 12 depicts the relationships between an
RDF graph G, its saturation G∞ and summarization
(G∞)/≡ thereof, and the RDF graphs that appear
at each step of the shortcut computation. The in-
tuition for the suﬃcient condition is the following.
On any path in Figure 12, saturation adds edges to
its input graph, while summarization “fuses” nodes
into common representatives. On the regular path
from G to (G∞)/≡, edges are added in the ﬁrst step,
and nodes are fused in the second. On the short-
cut (green) path, edges are added in the second
step, while nodes are fused in the ﬁrst and third
steps. The two paths starting from G can reach (cid:108)
results only if G nodes fused on the shortcut path are
also fused (when summarizing G∞) on the standard
path. In particular, the ﬁrst summarization along
the shortcut path should not make wrong node fu-
sions, that is, fusions not made when considering
the full G∞: such a “hasty” fusion can never be cor-
rected later on along the shortcut path, as neither
summarization nor saturation split nodes. Thus,
an erroneous fusion made in the ﬁrst summariza-
tion step irreversibly prevents the end of the short-
cut path from being (cid:108) to (G/≡)∞.

When the condition is met, summarizing G,
then saturating its summary, then summarizing the
graph thus obtained leads to (G∞)/≡ (up to data
node labels) without the need to saturate G. The
shortcut can be faster than saturating G then sum-
marizing the result, because the shortcut avoids
the cost to ﬁnd, store, and summarize the implicit
triples derived from G; it only deals with the implicit
triples derived from G/≡, which (depending on ≡)
may be much smaller than G.

C +
1
C1 : {a, b1}

C +
2
C2 : {b2, c}

{b}

C∞

Figure 13. Two source cliques
from the graph in Figure 11, their
saturations, and their enclosing
clique C∞ in G∞.

5.3. Shortcut results. In order to establish short-
cut results for our summaries, we start by investi-
gating how property cliques are impacted by satu-
ration.

In G∞, every G node has all the data properties
it had in G, therefore two data properties belong-
ing to a G clique are also in the same clique of G∞.
Further, if the schema of G comprises subProperty
constraints, a node may have in G∞ a data property
that it did not have in G. As a consequence, each
G∞ clique includes one or several cliques from G,
which may “fuse” by acquiring more properties due
to saturation with subProperty constraints. An ex-
ample is given in Figure 13, where C +
2 are
the saturations of the source cliques C1, C2, while
C∞ = {a, b1, b, b2, c} is a source clique of the graph
G∞ (also in Figure 11).

1 and C +

Based on Theorem 2 and the above observations,

we show:

Theorem 3. (W shortcut) The shortcut holds for
≡W.

For instance, on the graph in Figure 11, it is easy
to check that applying summarization on (G/W)∞ (as
prescribed by the shortcut) leads exactly to a graph
strongly isomorphic to (G∞)/W.

Showing Theorem 3 is rather involved; we do it
in several steps. First, based on a technical Lemma
(see Appendix E) , we show:

Lemma 1. (Property relatedness in W sum-
maries) Data properties are target-related (resp.
source-related) in (G/W)∞ iﬀ they are target-related
(resp. source-related) in G∞.

Based on the above Lemma and Theorem 1, we
establish the next result from which Theorem 3 di-
rectly follows:

Proposition 3. (Same cliques-W) G∞ and
(G/W)∞ have identical source clique sets, and identi-
cal target cliques sets. Further, a node n ∈ G∞ has
exactly the same source and target clique as fW(n)
in (G/W)∞.

Theorem 4. (S shortcut) The shortcut holds for
≡S.

We prove this based on counterparts of state-

ments established for G/W. First we show:

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

13

G

r1

a

b

y1
y2

b

r2
domain

a

C

x

G/TW

(G/TW)∞, ((G/TW)∞)/TW

a
b

N2

N3

N1

a

C

type

domain

N1

a
b

domain

C

a

N2

N3

C

G∞

type

domain

a

a
b

b

r1

r2

x

y1
y2

C

(G∞)/TW

type

domain

a

N4

N7

N5

N6
N8

a
b

b

Figure 14. Shortcut counter-example.

Lemma 2. (Property relatedness in S sum-
maries) Data properties are target-related (resp.
source-related) in (G/S)∞ iﬀ they are target-related
(resp. source-related) in G∞.

Then, from Theorem 1 and the above Lemma, we
obtain the next proposition from which Theorem 4
directly follows:
Proposition 4. (Same cliques-S) G∞ and
(G/S)∞ have identical source clique sets, and iden-
tical target clique sets. Further, a node n ∈ (G/S)∞
has exactly the same source and target clique as
fS(n) in (G/S)∞.

Finally, we have:

Theorem 5. (No shortcut for ≡TW) The short-
cut does not hold for ≡TW.

We prove this by exhibiting in Figure 14 a
counter-example. In G and G/TW, all data nodes are
untyped; only after saturation a node gains the type
C. Thus, in G/TW, one (untyped) node represents all
data property subjects; this is exactly a “hasty fu-
In (G/TW)∞,
sion” as discussed below Theorem 2.
this node gains a type, and in ((G/TW)∞)/TW, it is
represented by a single node. In contrast, in G∞, r1
is typed and r2 isn’t, leading to two distinct nodes
in (G∞)/TW. This is not strongly isomorphic with
(G/TW)∞ which, in this example, is strongly isomor-
phic to ((G/TW)∞)/TW. Thus, the shortcut does not
hold for ≡TW.
Theorem 6. (No shortcut for ≡TS) The short-
cut does not hold for ≡TS.

The graph in Figure 14 is also a shortcut counter-

example for TS.

Based on Theorem 2, we have also established:
Theorem 7. (Bisimilarity shortcut) The
shortcut holds for the forward (≡fw), backward
(≡bw), and forward-and-backward (≡fb) bisimilar-
ity equivalence relations (recalled in Section 2.2).

/TW

G/TS

/TS

G/TW

/TW

/TS

G

∞

(G∞)/TW

G∞

/TW

/TS

/fb

/S

/W

/W

/S

/fb

(G∞)/TS

G/fb

/S

G/S

/W

G/W

(G∞)/W

(G∞)/S

(G∞)/fb

∞

∞

∞

/W

(G/fb)∞ (G/S)∞ (G/W)∞

/S

/fb

Figure 15. Relations between
quotient summaries.

5.4. Relationships between summaries. From
the deﬁnition of weak and strong equivalence, it is
easy to show that (G/S)/W = G/W, i.e., one could com-
pute G/W by ﬁrst summarizing G into G/S, and then
applying weak summarization on this (typically
much smaller) graph; similarly, (G/TS)/TW = G/TW.
It is also the case that (G/W)/S = G/W, i.e., strong
summarization cannot compress a weak summary
further, and similarly (G/TW)/TS = G/TW. Figure 15
summarizes the main relationships between G, G∞,
our summaries and bisimilarity-based ones.

6. From summaries to visualizations

We now describe how to go from a quotient sum-
mary to a graphical visualization such as the one
illustrated in the Introduction.

6.1. Leaf and type inlining. For structurally
simple graphs like our sample G shown in Fig-
ure 2, quotient summaries have very few nodes and
edges, and any node-link visualization method can
be used. We explain here how we obtained our vi-
sualizations, illustrated in our online gallery 1.

To further simplify summaries, we apply leaf and
type inlining, as follows. We remove type edges; in-
stead, each type attached to a node in the summary
is shown in the box corresponding to the node, after
the node ID. Similarly, for each edge n a−→ m where
m is a leaf, we include a as an “attribute” of n,
and do not render m (we say it has been “inlined”
within n). A sizable part of an RDF graph’s nodes
are leaves; as we will show, inlining them into their
parent nodes greatly simpliﬁes the visualization.

Figure 16 illustrates inlining for the S summary
(Figure 9) of our sample graph. This summary is
extremely compact, yet rich with information; pro-
fessors, students, and courses are visible at a glance.
Articles have been inlined within their authors as
they were leaves in G/S. This simpliﬁcation can also
be seen as a small loss of information: Figure 16
does not immediately suggest that Professors may
have written articles together with GradStudents.
However, (i) only leaf nodes are folded and (ii) af-
ter a ﬁrst glance, users may pursue exploration by
other means (e.g., queries to check for such joint

14

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

Figure 16. Visualization result-
ing from leaf and type inlining on
the sample Strong summary from
Figure 9.

articles). Thus, we consider that inlining is overall
beneﬁcial, and systematically apply it on summaries
before visualization.

If type-then-data summarization is used based
on the most general types (Section 5.1), the most
general types are shown at the top of each typed
summary node (immediately under the node ID),
then the actual types of the graph nodes represented
by the summary node are shown one per line, under
the most general types. N1, N7 and N8 in Figure 1
illustrate this.

6.2. Summary statistics. If users are interested
(also) in a quantitative view of an RDF graph, our
summaries can also plot a set of statistics. We de-
scribe them below and illustrate them based on Fig-
ure 1. For each summary node Ni, we display:

• The number of G nodes represented by Ni,
in parenthesis after “Ni” in the correspond-
ing box, e.g., “N8 (25000)”;

• For each type c such that x τ c for some x
represented by Ni, the number of G nodes
represented by Ni which are of type c, e.g.,
http://db.uwaterloo.ca/~galuc/
wsdbm/ProductCategory0:807

• For each data property p such that (i) x p y
for some x represented by Ni and (ii) all the
objects of p triples whose subjects are rep-
resented by Ni are leaves in G, the number
of such p triples, and the number of distinct
targets of such triples. For instance, within
N8, “bookedition (847 → 6)” denotes that
there are 847 bookedition triples whose sub-
jects are represented by N8, and they reach
a total of 6 distinct objects (which are leaf
nodes).

For each summary edge Ni

a−→ Nj where a is a
data property, the number of x a y triples in G such
that x is represented by Ni and y is represented by
Nj. The label “hasGenre (58787)” on the edge from
N8 to N1 is an example of such an edge statistic.

All these statistics can be gathered by our sum-
mary construction algorithms (Section 7), at no ex-
tra computational cost.

6.3. Visualizing very large summaries. For a
very complex (e.g., encyclopedic) dataset, even the
graph obtained from inlining may have too many

If
nodes and edges for an eﬀective visualization.
it has several connected components (one per do-
main), each of them can be viewed separately. Oth-
erwise, it can be split into several, possibly over-
lapping subgraphs, using any graph decomposi-
tion strategy (for instance, minimize the number
of times the representatives of two nodes connected
in G appear in diﬀerent summary subgraphs etc.)
Information discovery in such graphs requires more
computational and cognitive eﬀort.

7. Summarization algorithms

We now present

summarization algorithms
which, given as input a graph G, construct G/W, G/S,
G/TW and G/TS. All our algorithms have an amortized
linear complexity in the size of G: they can be built
in just one or two passes over the data. Our incre-
mental algorithms, capable of reﬂecting additions
to G, into its previously computed summaries, are
the most involved.

7.1. Global data graph summarization. The
ﬁrst algorithms we present summarize only the data
triples through two graph traversals: one to learn
the equivalence relation7 and create the summary
nodes, the second to determine the representative
of each G node and, as a consequence, add triples
to the summary.
We start with our global W summarization algorithm
(Algorithm 1).
It exploits Proposition 1, which
guarantees that any data property occurs only once
in the summary. To each data property p encoun-
tered, it associates a summary node (integer) sp
which will be the (unique) source of p in the sum-
mary, and similarly a node tp target of p; these are
initially unknown, and evolve as G is traversed. Fur-
ther, it uses two maps op and ip that associate to
each data node n, the set of its outgoing, resp. in-
coming data properties. These are ﬁlled during the
ﬁrst traversal of G (step 1.) Steps 2. to 2.5 ensure
that for each node n having outgoing properties and
possibly incoming ones, sp for all the outgoing ones
are equal, and equal also to tp for all the incoming
ones. This is performed using a function fuse which,
given a set of summary nodes, picks one that will re-
place all of them. In our implementation, summary
nodes are assigned integer IDs, and fuse is simply
min; we just need fuse to be distributive over ∪,
i.e., fuse(A, (B ∪ C)) = fuse(fuse(A, B), fuse(A, C)).
Symmetrically, step 3.
ensures that the incom-
ing properties of nodes lacking outgoing proper-
ties (thus, absent from op) also have the same tar-
get. In Step 4., we represent s and o based on the
source/target of the property p connecting them.

7Our equivalence relations are deﬁned based on the
triples of a given graph G, thus when summarization starts,
we do not know whether any two nodes are equivalent; the
full equivalence relation is known only after inspecting all G
triples.

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

15

global-W(G)

global-S(G)

2.2.

1. For each s p o ∈ G, add p to op(s) and to
ip(o).
2. For each node n ∈ op:
2.1.

Let X ← fuse{sp | p ∈ op(n)}.
If X is undeﬁned, let X ←nextNode();
Let Y ← fuse{tp | p ∈ ip(n)}.
If Y is undeﬁned, let Y ←nextNode();
Let Z ← fuse(X, Y );
2.3.
For each p ∈ ip(n), let sp ← Z;
2.4.
2.5.
For each p ∈ op(n), let tp ← Z;
3. Repeat 2 to 2.5 swapping ip with op and
tp with sp;
4. For each s p o ∈ G: let fW(s) ← sp, fW(o) ←
tp;

Add fW(s) p fW(o) to G/W.
Algorithm 1: Global W summarization of a
graph

The fuse operations in 2. and 3. have ensured that,
while traversing G triples in 4., any data node n
is always represented by the same summary node
fW(n).
Our global S summarization algorithm (Algo-
rithm 2) uses two maps sc and tc which store for
each data node n, its source clique sc(n), and its
target clique tc(n), and for each data property p, its
source clique srcp and target clique trgp. Further,
for each (source clique, target clique) pair encoun-
tered during summarization, we store the (unique)
corresponding summary node. Steps 1.-1.2. build
the source and property cliques present in G and as-
sociate them to every subject and object node (in
sc and tc), as well as to any data property (in srcp
and trgp). For instance, on the sample graph in
Figure 2, these steps build the cliques in Table 2.
Steps 2-2.2. represent the nodes and edges of G.

The correctness of algorithms global-W and
global-S follows quite easily from their descriptions
and the summary deﬁnitions.

7.2. Incremental data graph summarization.
These algorithms are particularly suited for incre-
if new triples ∆+
mental summary maintenance:
G
are added to G, it suﬃces to summarize only ∆+
G ,
based on G/≡ and its representation function f≡, in
order to obtain (G∪∆+
G )/≡. Incremental algorithms
are considerably more complex, since various deci-
sions (assigning sources/targets to properties in W,
source/target cliques in S, node representatives in
both) must be repeatedly revisited to reﬂect newly
acquired information about G triples, as we shall
see.
Each incremental summarization algorithm con-
sists of an incremental update method, called for ev-
ery data triple, which adjusts the summary’s data
structures, so that at any point, the summary re-
ﬂects exactly the graph triples visited until then.

For each s p o ∈ G:

If sc(s) (cid:54)= srcp, fuse them into new
p = sc(s) ∪ srcp; similarly, if tc(o) (cid:54)=
p = tc(o) ∪ trgp. 2. For

1.
1.1.
Check if srcp, trgp, sc(s) and tc(o) are
known; those not known are initialized with
{p};
1.2.
clique src(cid:48)
trgp, fuse them into trg(cid:48)
each s p o ∈ G:
2.1.
fS(s) ← the (unique) summary node
corresponding to the cliques (sc(s), tc(s));
similarly, fS(o) ← the node corresponding to
(sc(o), tc(o)) (create the nodes if needed).
Add fS(s) p fS(o) to G/S.
2.2

Algorithm 2: Global S summarization of a
graph

increm-W(s p o)

1. Check if sp and op are known: either both
are known (if a triple with property p has al-
ready been traversed), or none;
2. Check if fW(s) and fW(o) are known; none,
one, or both may be, depending on whether
s, respectively o have been previously encoun-
tered;
3. Fuse sp with fW(s) (if one is unknown, as-
sign it the value of the other), and op with
fW(o);
4. Update fW(s) and fW(o), if needed;
5. Add the edge fW(s) p fW(o) to G/W.

Algorithm 3: Incremental W summarization of
one triple

Algorithm 3 outlines incremental W summariza-
tion. For example (see the ﬁgure below), let’s as-
sume the algorithm traverses the graph G in Figure 2
starting with: p1 advises p2, then p1 wrote a1, then
p4 teaches c2. When we summarize this third triple,
we do not know yet that p1 is equivalent to p4, be-
cause no common source of teaches and advises
(e.g., p3 or p4) has been seen so far. Thus, p4 is
found not equivalent to any node visited so far,
and represented separately from p1. Now assume
the fourth triple traversed is p4 advises p5: at this
point, we know that advises, wrote and teaches
are in the same source clique, thus p1 ≡W p4, and
their representatives (highlighted in yellow) must
be fused in the summary (Step 3.) More generally,
it can be shown that ≡W only grows as more triples
are visited, in other words: if in a subset G(cid:48) of G’s
triples, two nodes n1, n2 are weakly equivalent, then
this holds in any G(cid:48)(cid:48) with G(cid:48) ⊆ G(cid:48)(cid:48) ⊆ G.

16

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

p1

p4

p1

p4

a w

te ⇒ a w

te

a w

te a ⇒ a w te

p2

a1

c2

p2

a1

c2

p5

Summary node fusion dominates the algorithm’s
complexity. Let N1, N2 be two sets of G nodes, rep-
resented at a certain point by the distinct summary
nodes m1, m2. When fusing them in a single m,
we must also record that all the nodes in N1 ∪ N2
are now represented by m. A na¨ıve implementation
leads to O(N 2) complexity, where N is the num-
ber of data nodes, since each new node may lead to
a fusion whose cost is O(N ); in the worst case N
could be proportional to |G|, the number of triples
in G, leading to an overall complexity of O(|G|2) for
the incremental weak summarization.

Instead, we rely on a Union-Find [14] (aka Dis-
joint Sets) data structure, with the path compres-
sion and union by size optimizations, which guar-
antee an overall quasi-linear worst-case complexity
to our incremental weak summarization algorithm.
The exact complexity is O(N α(N )) where α(N ),
the inverse Ackermann’s function, is smaller than 5
for any machine-representable input N . Assimilat-
ing this to linear-time, the algorithm’s complexity
class is in O(|G|), which is also optimal, as summa-
rization must fully traverse G.

Algorithm 4 outlines the incremental update of
the S summary due to the traversal of the triple
s p o. Conceptually, the algorithm is symmetric
for the source (s) and target (o) of the edge, we
only discuss the source side below. Steps 1. and 2.
start by determining the source clique of s, based on
its previously known source clique (if any) and the
previously known target clique of p (if any); after
step 2., s’s source (and target) clique reﬂecting also
the newly seen triple s p o are completely known.
Determining them may have involved fusing some
previously separate cliques. For instance, on the
graph in Figure 2, assume we ﬁrst traverse the triple
p1 advises p2, then p4 teaches c2; so far we have the
source cliques {advises}, {teaches} and ∅. If the
next traversed triple is p4 advises p5, we fuse the
source cliques (step 3.1) {advises} and {teaches}
into {advises, teaches}. This requires fusing the
summary node whose (source, target) cliques were
({advises}, ∅) with the one which had ({teaches},
∅) (Step 3.2).

The last intricacy of incremental strong summa-
rization is due to the fact that unlike ≡W, ≡S may
grow and shrink during summarization. For in-
stance, assume incremental strong summarization
of the graph in Figure 2 starts with p1 wrote a1,
p2 wrote a2, p2 takes c2 (see the ﬁgure below). Af-
ter these, we know p1 ≡S p2; their source clique

increm-S(s p o)

tc(o)) are known;

1. Check if we already know a source clique
srcp (resp.
target clique trgp). Either both
are known (if a p triple has already been tra-
versed), or none. Those not known are initial-
ized with {p};
2. Check if sc(s) (resp.
those unknown are initialized with {p};
3. If sc(s) (cid:54)= srcp, fuse them into new clique
src(cid:48)
p = sc(s) ∪ srcp, using Union-Find; simi-
larly, if tc(o) (cid:54)= trgp, fuse them into trg(cid:48)
p =
tc(o) ∪ trgp, and:
3.1 Replace sc(s) and srcp with src(cid:48)
p through-
out the summary (respectively, replace tc(o)
and trgp with trg(cid:48)
3.2 The above may entail summary node
in this case, update fS (use Union-
fusions;
Find) and the summary edges to reﬂect it;
If before seeing s p o s had been already
4.
represented and it had an empty source clique,
then s needs to split, i.e., be represented sepa-
rately from the nodes to which it was ≡S previ-
ously; call split-source(s). (Symmetric dis-
cussion for o, call split-target(o)).
5. Update fS(s) and fS(o), if needed;
6. Add the edge fS(s) p fS(o) to G/S.

p);

Algorithm 4: Incremental S summarization of
one triple

split-source(s)

1. Collect all G edges adjacent to s into
transf er set.
2. For each s p o ∈ transf er, decrement by 1
the counter for fS(s) p fS(o) in the summary.
3. Update fS(s).
4. For each s p o ∈ transf er, if such edge
already exists in the summary, then increment
its counter by 1, otherwise add fS(s) p fS(o)
to the summary with counter equal to 1.
Procedure 5: Splitting summary node s on
source

is {wrote, takes} and their target clique is ∅. As-
sume the next triple traversed is p3 advises p2: at
this point, p1 is not ≡S to p2 any more, because
p2’s target clique is now {advises} instead of the
empty ∅. Thus, p2 splits from p1, that is, it needs
to be represented by a new summary node (shown
in yellow below), distinct from the representative of
p1.

p1

w

p2

w ta ⇒ w ta

p1

w

p2

a

p3

a

w ta

⇒ w w ta

a1

a2

c2

a1

a2

c2

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

17

Further, note that the representative of p1 and
p2 (at left above) had one takes edge (highlighted
in red) which was solely due to p2’s outgoing takes
edge. By deﬁnition of a quotient summary (Sec-
tion 2.2), that edge moves from the old to the new
representative of p2 (the yellow node). If, above at
left, p1 had also had an outgoing edge labeled takes,
at right, both nodes in the top row would have had
an outgoing takes edge. It can be shown that splits
only occur in such cases, i.e., o whose target clique
becomes non-empty (respectively, s whose source
clique becomes non-empty, and the node was pre-
viously represented together with other nodes; if it
was represented alone, we just update the respec-
tive clique of its representative).

The procedure split-source(s) (Procedure 5)
represents s separately, to reﬂect it no longer has
an empty target clique, and, for each outgoing edge
of s: adds a corresponding edge to the new repre-
sentative of s; and checks if, as a consequence, an
edge needs to be removed from its previous repre-
sentative. We establish:

Proposition 5. (Algorithm correctness) Ap-
plying algorithm increm-W (resp., increm-S) suc-
cessively on each triple of G, in any order, builds
G/W (resp., G/S).

Splitting requires inspecting the data edges at-
tached to the node, in order to add edges to its
new representative (such as p2 ta c2 above). We
make the hypothesis, denoted ((cid:63)), that the average
number of edges incoming/outgoing a data node is
small (and basically constant) compared to the size
of G; this was the case in the graphs we have exper-
imented with. Under the ((cid:63)) hypothesis, using the
above data structures (including Union-Find), the
complexity of incremental strong summarization is
amortized constant per added triple.

All our algorithms require O(|G|) space to store
the summary, the representation function, and their
other data structures. Encoding all graph and sum-
mary nodes as integers, however, reduces the actual
memory needs signiﬁcantly.

summarization of

7.3. Incremental
typed
graphs. We now explain how to extend our in-
cremental data triple summarization algorithms to
type triples.

To extend W,

respectively, S summarization
to type triples in “data-then-type” fashion (Sec-
tion 4.1), we run W, resp. S summarization ﬁrst,
over the data triples only, as described in the pre-
ceding two sections. This assigns their (ﬁnal) repre-
sentatives to all data nodes. Then, for each s type C
triple, we simply add to the summary the edge
fW(s) type C (resp. fS(s) type C); recall from Sec-
tion 4 that any class node C is represented by itself.
(Sec-
tion 4.2), we ﬁrst traverse the type triples only,

“type-then-data”

summarization

For

compute all the class sets, and assign to each typed
data node a representative based on its class set.
Then, we run a type-aware variant of a W (resp.
S) algorithm, either global or incremental. The
(i) In TW summarization, a data
diﬀerences are:
property p may lack an untyped source (and/or
target), if p has only typed subjects (resp. objects),
e.g., property e in the two-triples graph n1 type C,
n1 e a1. Similarly, in TS summarization, a property
it does not
like e will
have an untyped source. Whenever a clique-based
representative for a property’s source and target
is missing, the algorithms will
instead use the
type-based representative, e.g., the representative
of n1 in n1 e a1 will be the one for the type set
{C}. (ii) Summarizing the data triple s p o does
not fuse nor split the representative of s (resp. o)
if s (resp. o) is typed; the representatives of typed
nodes never change. We establish:

lack a source clique,

if

Proposition 6. (Algorithm correctness) Ap-
plying global-W (respectively global-S) on G, or ap-
plying increm-W (resp., increm-S) on each triple of
G, extended as described above for data-then-type or
type-then-data summarization leads, resp., to G/W,
G/S, G/TW and G/TS.

These algorithms need to work with the data and
type triples separately. Fortunately, most popular
RDF stores allow such direct access. The space
needed to also represent type triples remains linear
in |G|.

8. Experimental study

Algorithms compared. We have implemented in
a Java 1.8 tool available online1:

• Our global and incremental algorithms for
building G/W, G/S, G/TW, G/TS (a total of
eight);

• An algorithm which computes the fb (full
bisimilarity) summary of an RDF graph,
used in many prior works, e.g., [22]. The
summary called ∼b in [5] is obtained from
fb by collapsing all leaves together; as ex-
plained in Section 2, this leaf collapse intro-
duces a loss of information, thus we do not
adopt it.

• Algorithms to build the k-bounded bisim-
ilarity summaries for k = 1, denoted 1fw,
1bw and 1fb [23] (1fw also corresponds to
the characteristic sets of [32]). We do not
use higher k values because, as we will show,
even at this smallest k, bisimilarity sum-
maries are too large for visualization; higher
k would only increase the number of nodes
and edges. The ∼ioa summary of [5] is ob-
tained from 1fb by collapsing all leaves.

18

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

Real
datasets
DBLP
DBpedia Per-
son
Foodista
Nobel Prizes
Springer LOD

|G|

|G∞| u% #p #C

88,153,334 88,153,334
7,889,268
7,889,268

1,019,799
87,549
145,136

1,019,799
119,457
213,017

87
63

75
71
77

26
9

13
45
26

14
1

5
26
11

|G|

|G∞| u% #p #C

Synth.
datasets
BSBM [3] 1M
BSBM 10M
BSBM 100M
BSBM 138M
LUBM [19] 1M
LUBM 10M
LUBM 100M

159
38
38
593
38 2019
38 2,421
45
18
45
18
18
45
Table 3. Datasets used in experiments.

1,009,138
1,000,708
10,538,484
10,628,484
104,115,556 105,315,556
138,742,476 140,342,476
1,227,984
1,001,658
10,728,460
13,147,069
106,778,632 130,843,944

68
66
61
61
34
34
34

• The best algorithms from [5] building the
∼t and ∼ioat summaries, but without their
leaf collapse.

Settings. All experiments ran on a Linux server
with an Intel Xeon CPU E5-2640 v4 @2.40GHz and
124 GB RAM. We used PostgreSQL v9.6 to store
RDF triples in an integer-encoded triple table, in-
dexed by s, p and o; the server had 30 GB of shared
buﬀers and 640 MB working memory. The JVM
had 90 GB of RAM.
Datasets. We have experimented with real and
synthetic graphs of up to 36.5 GB. Table 3 shows
for each graph its number of triples |G|, the number
of triples in its saturation |G∞|, the percentage of
untyped nodes in the graph u%, and the number of
distinct data properties #p and classes #C. Each
graph has at least 30% untyped nodes; these form a
strong majority in all but the LUBM graphs. Note
that in BSBM graphs, the number of classes grows
with the data size.
Summary size. Table 4 reports the node and
edge counts, denoted (n|e), for the compared sum-
maries, both directly, and after applying inlining
(Section 6, denoted with the in superscript). We
report only the data edges in the summaries, and
omit (i) schema triples, or (ii) metadata triples,
e.g., C dc:publisher a1 states that a1 published class
C etc. These omitted triples are the same for all
summaries8. For space reasons, we delegate the
1bw and 1fb numbers to [6]; they are slightly worse
(i.e., more nodes and edges) than those of 1fw. We
also delegate to [6] the TW results, which are often
identical to those for TS. Numbers are missing (-|-)
when algorithms ran out of memory or longer than
3 hours.

8In details, for the graphs in Table 4, we omitted: 1008,
4028, 13352, 16020, 19, 1, 5, 246, 246, 246, 171, resp. 108
triples.

fb summarization failed to complete within 3
hours, on all but the smallest graphs (Springer, No-
bel Prizes and BSBM 1M). This is partially due
to our simple, single-computer implementation, but
computing fb is also intrinsically hard, as it re-
quires many iterations. More eﬃcient methods to
build the fb summary are parallel [26]; existing al-
gorithms to build the ∼t and ∼ioat summaries are
based on MapReduce [5]. Here, we study the size,
precision, as well as qualitative properties (see Sec-
tion 2.2) of prior-work summaries, based on simple
(if not the most eﬃcient) centralized implementa-
tions. The fb results we obtained conﬁrm the obser-
vation in Section 2.2 that such summaries are much
too complex to be used for a ﬁrst visualization.

Among the other summaries, before inlining, as
theoretically expected (Proposition 1), G/W always
has the fewest edges; G/S is close. In contrast, sum-
maries that group nodes (also) by the types, such
as G/TS, G/t and G/ioat are much larger. This is
particularly visible for larger BSBM datasets: as
the schema complexity grows, these summaries have
tens of thousands of edges. G/ioat remains too com-
plex even for the simpler-schema graphs (exclud-
ing BSBM), with hundreds or thousands of edges,
whereas G/W and G/S only have a few dozen edges.
G/1fw is always smaller than G/ioat (this can be
shown theoretically based on their deﬁnitions), but
it remains much larger (by a factor of 2 in the case
of Springer, up to 122 in the case of Foodista) than
G/S. Among the graphs other than BSBM, G/t has
less edges than G/S on the DBpedia Person graph,
and less nodes on the Springer graph; on all the oth-
ers, G/t is several times larger than G/S. Further, G/t
has the qualitative drawback of considering all un-
typed nodes equivalent; none of our summaries has
this problem.

After inlining, Gin

/W and Gin
/S are reduced to very
few (1 to 21) nodes and 2 to 36 edges. In contrast,
Gin
/t has signiﬁcantly more edges than Gin
/S (up to 11×
for BSBM10 or DBLP); it is smaller than Gin
/S (by a
small margin) only on DBPedia Person and Nobel.
/1fw, Gin
The summaries Gin
/ioat still remain very large,
thus, not useful for ﬁrst-sight visualization.
Summarization time. The times to build our
summaries using the global and the incremental al-
gorithms are plotted as a function of |G| in Fig-
ure 17; both axes are in log scale. For each sum-
mary type, the summarization time is roughly lin-
ear in the size of G, conﬁrming the expectations
Increm-W is the fastest over-
stated in Section 7.
all; it traverses G only once, thus it is faster than
global-W which performs several passes. S, TW and
TS, in this order, are more expensive, and ﬁnally
incremental S which, as we explained, is quite com-
plex. Since increm-S is rather expensive per-triple,
it is more eﬃcient to ﬁrst summarize a graph us-
ing global-S, and call increm-S only to maintain

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

19

G

G/W

G/1fw

Gin
/∼t

Gin
/S
5|9

G/TS Gin
/TS

G/∼t
264|2046 102|485

Gin
Gin
G/S
G/∼ioat
/W
/1fw
312|4477
281|1951 7|10 208|1017 48|573
179|38 1|7 184|57
613|38 1|7 618|68 5|11 1131|10274 7|10 642|1023 48|579 1114|10785 518|749 719|10320

BSBM1
BSBM10
BSBM100 2039|38 1|7 2044|70 5|11 3325|25639 7|10 2068|1023 48|579 3308|26918
BSBM138 2441|38 1|7 2446|71 5|11 3983|30759
-|- 3966|32294
DBLP
DB. Person
Foodista
LUBM1
LUBM10
LUBM100
Nobel
Springer

Gin
/∼ioat
61|617 279999|999436
-|-
86|740
-|-
-|- 2149|34503 105|895
-|-
-|- 2556|41963 110|892
-|-
-|-
439|8390
-|-
135|1651
112|91
-|-
191|4518 169|934
-|-
24|111
103|173
-|-
22|100
101|163
22|104
101|167
-|-
164|697
70|316
73|90
Table 4. Summary sizes: direct and after inlining.

38|196 14|66 267|4344 62|938
67|377 65|83
72|1959 25|975
89|81 14|75
89|83 14|77
89|83 14|77
117|555 48|434
8|9

Gin
/fb
-|-
-|-
-|-
-|-
-|-
-|-
-|-
-|-
-|-
-|-
22640|83206 10765|32671
8|9 65297|139566 15530|30028

30|66 7|17
23|26 2|8
6|21
2|4
4|9 1|2
3|6
12|16
11|13 3|6
86|43 7|27
82|18 3|12
86|44 7|28
82|18 3|12
82|18 3|12
86|44 7|27
97|59 9|18 110|110 21|36
4|2
49|24 4|2

55|237 13|188
1|2
6|33
16|58
16|58
16|58
14|65
4|2

5|11
1|2
17|33 6|13
95|94 16|58
95|94 16|58
95|94 16|58
105|85 16|33
4|2

3|11
12|36
92|94
92|94
92|94
83|82
37|24

-|- 2470|1023

49|24

40|51

49|24

G/fb

Dataset
G/TS
G/S
G/W
G/∼t
BSBM1
0.26 0.01
0.56
0.46
BSBM10
0.45 0.01
0.56
0.46
BSBM100
0.48 0.01
0.56
0.46
BSBM138
0.49 0.01
0.56
0.46
DBLP
0.09 0.03
0.23
0.37
DB. Person
0.09
0.09 0.08
0.31
Foodista
0.15 0.00
0.15
0.32
LUBM1
0.25 0.00
0.50
0.03
LUBM10
0.25 0.00
0.50
0.03
LUBM100
0.25 0.00
0.50
0.03
Nobel
0.27
0.04 0.01
0.49
Springer
0.01 0.01 0.01
0.59
Table 6. Precision loss experiments.

G/1fw
0.46
0.46
0.46
0.46
0.32
0.28
0.25
0.15
0.15
0.15
0.59
0.59

Summary precision. We now attempt to quan-
tify the loss of precision of our structural sum-
maries. A simple measure is the fraction of sum-
mary subgraphs having no isomorphic counterpart
in the data; intuitively, summary users may believe
G exhibits such structures, while this is not true. For
instance, node N1 in Figure 6 has, among others,
two outgoing edges labeled a and ta, whereas such
a node does not exist in the original graph (Fig-
ure 2). We deﬁne the precision loss at l, or P Ll
as the fraction of connected l-edges subgraphs of the
summary G/≡ without a counterpart in G. Table 6
shows P L2 scores for our datasets. By deﬁnition,
fb, 1fb and ioat have P L2 = 0 for any graph, since
they reﬂect completely node neighborhoods at dis-
tance 1. In contrast, G/W has the highest precision
loss; G/TS is the most precise, much better than ∼t
which blindly collapses untyped nodes. 1fw is quite
imprecise in some cases, since it ignores incoming
edges.
Experiment conclusion. Our four summaries
can be built eﬃciently in linear time. They strongly
reduce graph sizes and, through inlining, they lead
to compact, understandable graphs which ﬁt hu-
man comprehension capacity at ﬁrst sight.
If all
non-leaf G nodes are typed, G/TS (or, equivalently,
G/TW), with type generalization, are the most in-
formative and most precise, given that type infor-
mation speciﬁed by humans carries precious infor-
mation about the graphs. Otherwise, G/S strikes

Figure 17. Summarization time
(s) vs. graph size |G|.

dtS (s)
dtW (s) stW (s) xW (%)
Dataset
4.37
9.52
0.68
2.12
6.56
BSBM1M
52.84
0.74
73.96
123.73
19.34
BSBM10M
0.73 1451.40
BSBM100M
884.35
797.50 218.83
0.82 3627.19 2049.22
BSBM138M 1393.69 257.19
27.47
0.92
1.99
LUBM1M
3.76
47.09
0.94
LUBM10M
354.81
18.13
974.20
0.94 4247.83
LUBM100M 3472.07 214.28
0.70
3.55
0.86
0.46
Nobel
0.96
4.52
0.90
0.42
Springer

stS (s) xS (%)
0.54
0.67
0.39
0.44
0.86
0.87
0.77
0.80
0.79

24.53
302.24

3.32
4.07

Table 5. Shortcut experiments.

for instance,
it later. This is signiﬁcantly faster:
global-S on BSBM138M takes only 11.85 minutes,
while increm-S takes 34.5. Increm-TS is often faster
than increm-S because typed nodes do not lead to
splits during TS summarization.
Shortcut speed-up. Table 5 shows the time to
build (G∞)/≡ in two ways: (i) direct, i.e., saturate
G then summarize, denoted dt≡, and (ii) shortcut
(Section 5.3), summarize G, then saturate the sum-
It also
mary and summarize again, denoted st≡.
shows the shortcut speed-up x≡ for ≡∈ {W, S}
deﬁned as (dt≡ − st≡)/dt≡. The speed-up ranges
between 39% and 94% in all cases, a direct con-
Indeed, dt≡
sequence of ≡W and ≡S compression.
includes the time to summarize G∞, while st≡ in-
cludes the time to summarize (G/≡)∞; the smaller
this is, the higher x≡.

20

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

the best balance between concision and informa-
tive content, while G/W loses more precision. The
shortcut speeds up W and S summarization of G∞ by
39% to 94%. Thus, we ﬁnd the strong summary the
safest and most interesting choice: it can be built ef-
ﬁciently and is most likely to lead to informative yet
understandable RDF graph summaries. More gen-
erally, the data publisher can build them all (ﬁrst
build G/S and G/TS, then G/W from G/S and G/TW from
G/TS) and select the one(s) to share with potential
data users.

Quality metrics for RDF graph summaries have
been proposed in [40]. Along these metrics, our
summaries score high for preserving all classes and
properties from G; the price they pay for compact-
ness is to sometimes show instances that do not
exist in G (as our precision loss experiments show).
We currently work on using summaries to auto-
matically identify interesting analytical queries in
large RDF graphs and to speed up RDF keyword
search.
Acknowledgments ˇSejla ˇCebiri´c has contributed
to discussions on early versions of this work.

9. Related Work and Conclusion

As discussed in the Introduction and in Sec-
tion 2.2, summarization is a well-studied notion for
general graphs [29] and RDF ones in particular [7].
Our work pertains to the family of quotient sum-
maries of RDF graphs, and most directly compares
to bisimilarity-based quotients as well as the more
In this comparison, our sum-
RDF-speciﬁc ones.
maries, and among them the strong summary which
we ﬁnd generally the best, has the advantages of be-
ing (i) compact and easy to understand for domain-
speciﬁc graphs, (ii) eﬃciently computed in linear-
time, and (iii) beneﬁting from the original shortcut
procedure we introduced. None of our summaries
has the drawback of collapsing all leaves, all roots,
or all untyped nodes.
In contrast, more complex
summaries such as 1fb and ∼ioat are better suited
for indexing, but not as a ﬁrst interface to show
users.

Many non-quotient RDF graph summaries exist,
[13] builds answer-preserving sum-
see, e.g., [7].
maries for reachability and graph pattern queries.
However, these summaries do not preserve query
structure (i.e., joins), which quotient summaries do
preserve.

Other graph summaries compress graphs with
bounded “error” (number of edges to be added
as “corrections” after decompression, to retrieve
the original graph) [31, 24]. Nodes and edges are
summarized according to their frequencies and/or
based on ontology patterns in [28, 33]. Summaries
where nodes are grouped by graph clustering [20],
user-deﬁned aggregation rules [34], mining [9], and
identiﬁcation of frequent subtrees [39] do not re-
ﬂect the complete structure, and/or require user
input. With diﬀerent objectives, these summaries
may omit part of the graph structure, or be much
too large for visualization.

Work on ﬁtting XML data into relational
stores [12, 4] also aimed at ﬁnding “homogeneous”
node groups; “inlining” there meant storing in the
relation of node n, its properties which occur at
most once. Our inlining (Section 6) pushes leaf
nodes within their parents, regardless of their num-
ber of occurrences.

References

[1] Abiteboul, S., Hull, R., Vianu, V.: Foundations of

Databases. Addison-Wesley (1995)

[2] Alu¸c, G., Hartig, O., ¨Ozsu, M.T., Daudjee, K.: Diver-
siﬁed stress testing of RDF data management systems.
In: ISWC, pp. 197–212 (2014)

[3] Bizer, C., Schultz, A.: The Berlin SPARQL Benchmark.

Int. J. Semantic Web Inf. Syst. 5(2) (2009)

[4] Bohannon, P., Freire, J., Roy, P., Sim´eon, J.: From
XML schema to relations: A cost-based approach to
XML storage. In: ICDE (2002)

[5] Campinas, S., Delbru, R., Tummarello, G.: Eﬃciency
and precision trade-oﬀs in graph summary algorithms.
In: IDEAS (2013)

[6] ˇCebiri´c, ˇS., Goasdou´e, F., Guzewicz, P., Manolescu,
I.: Compact Summaries of Rich Heterogeneous Graphs.
Research Report RR-8920, INRIA and U. Rennes 1
(2018). URL https://hal.inria.fr/hal-01325900v6.
See also previous version (v5)

[7] Cebiric, S., Goasdou´e, F., Kondylakis, H., Kotzinos, D.,
Manolescu, I., Troullinou, G., Zneika, M.: Summarizing
Semantic Graphs: A Survey. The VLDB Journal (2018).
URL https://hal.inria.fr/hal-01925496

[8] ˇCebiri´c, ˇS., Goasdou´e, F., Manolescu, I.: A frame-
work for eﬃcient representative summarization of RDF
graphs. In: ISWC (poster) (2017)

[9] Chen, C., Lin, C.X., Fredrikson, M., Christodorescu,
M., Yan, X., Han, J.: Mining graph patterns eﬃciently
via randomized summaries. PVLDB 2(1) (2009)

[10] Chen, Q., Lim, A., Ong, K.W.: D(K)-index: An adap-
tive structural summary for graph-structured data. In:
SIGMOD (2003)

[11] Consens, M.P., Miller, R.J., Rizzolo, F., Vaisman, A.A.:
Exploring XML web collections with DescribeX. TWEB
4(3) (2010)

[12] Deutsch, A., Fern´andez, M.F., Suciu, D.: Storing
SIGMOD

semistructured data with STORED. In:
(1999)

[13] Fan, W., Li, J., Wang, X., Wu, Y.: Query preserving

graph compression. In: SIGMOD (2012)

[14] Galil, Z., Italiano, G.F.: Data structures and algorithms
for disjoint set union problems. ACM Comput. Surv.
23(3), 319–344 (1991)

[15] Goasdou´e, F., Guzewicz, P., Manolescu, I.: Incremental
structural summarization of RDF graphs. In: EDBT.
Lisbon, Portugal (2019). URL https://hal.inria.fr/
hal-01978784

[16] Goasdou´e, F., Manolescu, I., Roati¸s, A.: Eﬃcient query
answering against dynamic RDF databases. In: EDBT
(2013)

[17] Goldman, R., Widom, J.: Dataguides: Enabling
query formulation and optimization in semistructured
databases. In: VLDB (1997)

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

21

[18] Gubichev, A., Neumann, T.: Exploiting the query struc-
ture for eﬃcient join ordering in SPARQL queries. In:
EDBT, pp. 439–450 (2014)

[19] Guo, Y., Pan, Z., Heﬂin, J.: LUBM: A benchmark
for OWL knowledge base systems. J. Web Sem. 3(2-3)
(2005)

[20] Gurajada, S., Seufert, S., Miliaraki, I., Theobald, M.:
Using graph summarization for join-ahead pruning in a
distributed RDF engine. In: SWIM Workshop (2014)

[21] Henzinger, M.R., Henzinger, T.A., Kopke, P.W.: Com-
puting simulations on ﬁnite and inﬁnite graphs. In:
FOCS (1995)

[22] Kaushik, R., Bohannon, P., Naughton, J.F., Korth,
H.F.: Covering indexes for branching path queries. In:
SIGMOD (2002)

[23] Kaushik, R., Shenoy, P., Bohannon, P., Gudes, E.: Ex-
ploiting local similarity for indexing paths in graph-
structured data. In: ICDE (2002)

[24] Khan, K., Nawaz, W., Lee, Y.: Set-based approximate
approach for lossless graph summarization. Computing
97(12), 1185–1207 (2015)

[25] Khatchadourian,

S., Consens, M.P.:

ExpLOD:
Summary-based exploration of interlinking and RDF us-
age in the linked open data cloud. In: ESWC (2010)
[26] Khatchadourian, S., Consens, M.P.: Constructing
bisimulation summaries on a multi-core graph process-
ing framework. In: GRADES Workshop (2015)

[27] Le, W., Li, F., Kementsietsidis, A., Duan, S.: Scalable
keyword search on large RDF data. IEEE TKDE 26(11)
(2014)

[28] LeFevre, K., Terzi, E.: GraSS: Graph structure summa-

rization. In: SDM (2010)

[29] Liu, Y., Safavi, T., Dighe, A., Koutra, D.: Graph sum-
marization methods and applications: A survey. ACM
Comput. Surv. 51(3) (2018)

[30] Milo, T., Suciu, D.: Index structures for path expres-

sions. In: ICDT (1999)

[31] Navlakha, S., Rastogi, R., Shrivastava, N.: Graph sum-
marization with bounded error. In: SIGMOD (2008)
[32] Neumann, T., Moerkotte, G.: Characteristic sets: Ac-
curate cardinality estimation for RDF queries with mul-
tiple joins. In: ICDE (2011)

[33] Principe, R.A.A., Spahiu, B., Palmonari, M., Rula,
A., Paoli, F.D., Maurino, A.: ABSTAT 1.0: Compute,
manage and share semantic proﬁles of RDF knowledge
graphs. In: ESWC (2018)

[34] Rudolf, M., Paradies, M., Bornh¨ovd, C., Lehner, W.:
SynopSys:
large graph analytics in the SAP HANA
database through summarization. In: GRADES (2013)
[35] Sch¨atzle, A., Neu, A., Lausen, G., Przyjaciel-Zablocki,
M.: Large-scale bisimulation of RDF graphs. In: SWIM
Workshop (2013)

[36] Tian, Y., Hankins, R.A., Patel, J.M.: Eﬃcient aggre-
gation for graph summarization. In: SIGMOD. ACM
(2008)

[37] Tran, T., Ladwig, G., Rudolph, S.: Managing struc-
tured and semistructured RDF data using structure in-
dexes. IEEE TKDE 25(9) (2013)
Resource

framework.

description

[38] W3C:

http://www.w3.org/RDF/

[39] Zhao, P., Yu, J.X., Yu, P.S.: Graph indexing: Tree +

delta >= graph. In: VLDB (2007)

[40] Zneika, M., Vodislav, D., Kotzinos, D.: Quality metrics

for RDF graph summarization. Semantic Web (2018)

Appendix

We include here the proofs of all the statements
made in the paper. The main ones are for the gen-
eral shortcut Theorems 1 and 2, the W and S short-
cuts (Theorems 3 and 4), and the correctness of our
incremental algorithms (Propositions 5 and 6). The
others serve as ingredients for these main proofs.

Appendix A. Proof of Proposition 1

Proof. First, note that any two weak summary
nodes n1, n2 cannot be targets of the same data
property. Indeed, if such a data property p existed,
let T C be the target clique it belongs to. By the
deﬁnition of the weak summary, n1 corresponds to a
set of (disjoint) target cliques ST C1, which includes
T C, and a set of disjoint source cliques SSC1. Sim-
ilarly, n2 corresponds to a set of (disjoint) target
cliques ST C2, which includes T C, and a set of dis-
joint source cliques SSC2. The presence of T C in
ST C1 and ST C2 contradicts the fact that diﬀerent
equivalence classes of G nodes correspond to dis-
joint sets of target cliques. The same holds for the
sets of properties of which weak summary nodes are
sources. Thus, any data property has at most one
source and at most one target in G/W. Further, by
the deﬁnition of the summary as a quotient, every
data property present in G also appears in the sum-
mary. Thus, there is exactly one p-labeled edge in
(cid:3)
G/W for every data property in G.

Appendix B. Proof of Proposition 2

Proof. If two G/S distinct nodes had the same source
and the same target clique, they would be strongly
equivalent. This cannot be the case in a quotient
summary obtained through ≡S, since by deﬁnition,
such a summary has one node for each ≡S equiva-
lence class. Thus, any two distinct G/S have distinct
source cliques and/or distinct target cliques.

S

Now, let m be a G/S node, and Sm = f −1
(m)
be the set of all G nodes represented by m. By the
deﬁnition of a quotient summary, m must be the
target (resp. the source) of an edge carrying each
of the labels on the edges entering (resp. going out
of) any node n ∈ Sm. Thus, m is source of all
the properties in the source clique shared by the
nodes in Sm, and is target of all the properties in
the target clique shared by the nodes in Sm. Thus,
m has the source and target clique of any node from
(cid:3)
Sm; this concludes our proof.

Appendix C. Proof of Theorem 1

Proof. We ﬁrst show that an homomorphism can
be established from the node sets of G∞ to that of
(G/≡)∞.

Observe that RDF saturation with RDFS con-
straints only adds edges between graph nodes, but
does not add nodes. Thus, a node n is in G∞ iﬀ n

22

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

is in G. Further, by the deﬁnition of our quotient-
based summaries, n is in G iﬀ f≡(n) is in G/≡. Fi-
nally, again by the deﬁnition of saturation, f≡(n) is
in G/≡ iﬀ f≡(n) is in (G/≡)∞.

Therefore, every G∞ node n maps the f≡(n)

(G/≡)∞ node (*).

Next, we show that there is a one-to-one mapping

between G∞ edges and those of (G/≡)∞.

If n1 p n2 is an edge in G∞, at least one of the

following two situations holds:

• n1 p n2 is an edge in G. This holds iﬀ
f≡(n1) p f≡(n2) is an edge in G/≡, by def-
inition of an RDF summary. Finally,
if
f≡(n1) p f≡(n2) is an edge in G/≡, then
f≡(n1) p f≡(n2) is also an edge in (G/≡)∞.
• n1 p(cid:48) n2 is an edge in G, and p(cid:48) sc p belongs
to schema triples of the saturated graph,
thus n1 p n2 is produced by saturation in
G∞. In this case, we show similarly to the
preceding item that f≡(n1) p(cid:48) f≡(n2) is an
edge in (G/≡)∞, hence f≡(n1) p f≡(n2) is
also an edge added to (G/≡)∞ by satura-
tion, since (G/≡)∞ and G∞ have the same
(saturated) schema triples (Section 5).
If n1 type c is an edge in G∞, at least one of the

following two situations holds:

• n1 type c is an edge in G. This holds iﬀ
f≡(n1) type c is an edge in G/≡, by deﬁnition
of an RDF summary (recall that f≡(c) = c
for classes). Finally, if f≡(n1) type c is an
edge in G/≡, then f≡(n1) type c is also an
edge in (G/≡)∞.

• n1 p n2 is an edge in G and p domain c (or
p range c) belongs to schema triples of the
saturated graph, thus n1 type c is produced
by saturation in G∞. In this case, we show
similarly as above that f≡(n1) p f≡(n2) is
an edge in (G/≡)∞, hence f≡(n1) type c is
also an edge added to (G/≡)∞ by satura-
tion, since (G/≡)∞ and G∞ have the same
(saturated) schema triples (Section 5).

Therefore, every G∞ edge n1 p n2 (resp. n1 type c)
maps into the (G/≡)∞ edge f≡(n1) p f≡(n2) (resp.
f≡(n1) type c) (**).

From (*) and (**), it follows that f is an homo-
(cid:3)

morphism from G∞ to (G/≡)∞.

Appendix D. Proof of Theorem 2

Proof. We start by introducing some notations
(see Figure 18). Let f1 be the representation func-
tion from G∞ into (G∞)/≡, and f2 be the represen-
tation function from (G/≡)∞ into ((G/≡)∞)/≡.

Let the function ϕ be a function from the
(G∞)/≡ nodes to the ((G/≡)∞)/≡ nodes deﬁned as:
ϕ(f1(n)) = f2(f (n)) for n any G∞ node.

n1 p n2
∈ G∞

f1

f

f (n1) p f (n2)
∈ (G/≡)∞

f2

f1(n1) p f1(n2) ∈ (G∞)/≡

φ

f2(f (n1)) p f2(f (n2))
∈ ((G/≡)∞)/≡

Figure 18. Diagram illustrating
Theorem 2.

First,

Suppose that for every pair (n1, n2) of G nodes,
n1 ≡ n2 in G∞ iﬀ f (n1) ≡ f (n2) in (G/≡)∞ holds.
Let us show that this condition suﬃces to ensure
(G∞)/≡ ≡ ((G/≡)∞)/≡ holds, i.e., the ϕ function de-
ﬁnes an isomorphism from (G∞)/≡ to ((G/≡)∞)/≡.
let us show that ϕ is a bijection from
all the (G∞)/≡ nodes to all the ((G/≡)∞)/≡ nodes.
Since for every pair n1, n2 of G∞ nodes, n1 ≡ n2
iﬀ f (n1) ≡ f (n2) in (G/≡)∞, it follows that (G∞)/≡
and ((G/≡)∞)/≡ have the same number of nodes (*).
Further, a given node n in (G∞)/≡ represents a
set of equivalent nodes n1, . . . , nk from G∞. By
hypothesis, n1 ≡ · · · ≡ nk in G∞ iﬀ f (n1) ≡
· · · ≡ f (nk) in G∞
/≡ holds. Hence, every node
n = f1(n1) = · · · = f1(nk) of (G∞)/≡ maps to a
distinct node n(cid:48) = f2(f (n1)) = · · · = f2(f (nk)) in
((G/≡)∞)/≡ (**).

1 = f (n1), . . . , n(cid:48)

Similarly, a given node n(cid:48) in ((G/≡)∞)/≡ repre-
sents a set of equivalent nodes n(cid:48)
k =
f (nk) in (G/≡)∞. By hypothesis, f (n1) ≡ · · · ≡
f (nk) in G∞
/≡ iﬀ n1 ≡ · · · ≡ nk in G∞ holds. Hence,
every node n(cid:48) = f2(f (n1)) = · · · = f2(f (nk)) in
((G/≡)∞)/≡ maps to a distinct node n = f1(n1) =
· · · = f1(nk) of (G∞)/≡ (***).

From (*), (**) and (***), it follows that ϕ is a
bijective function from all the (G∞)/≡ nodes to all
the ((G/≡)∞)/≡ nodes.

Now, let us show that ϕ deﬁnes an isomorphism

from (G∞)/≡ to ((G/≡)∞)/≡.

1 p n(cid:48)

For every edge n(cid:48)

2 in (G∞)/≡, by deﬁni-
tion of an RDF summary, there exists an edge
n1 p n2 in G∞ such that n(cid:48)
2 = f1(n1) p f1(n2).
Figure 18 illustrates the discussion. Further,
if
n1 p n2 is in G∞, then f (n1) p f (n2) is in (G/≡)∞
(Theorem 1), hence f2(f (n1)) p f2(f (n2)) is in
((G/≡)∞)/≡. Therefore,

1 p n(cid:48)

for
every
• since
in (G∞)/≡,
edge
f2(f (n1)) p f2(f (n2))
and

f1(n1)
there

p

f1(n2)
an edge
in ((G/≡)∞)/≡,

is

• since ϕ(f1(n)) = f2(f (n)), for n any G∞
node, is a bijective function from all (G∞)/≡
nodes to all ((G/≡)∞)/≡ nodes,

• it follows that ((G/≡)∞)/≡ contains the im-
age of all (G∞)/≡ f1(n1) p f1(n2) triples
through ϕ (*).

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

23

1 p n(cid:48)(cid:48)

2 = f2(n(cid:48)

Now, for every edge n(cid:48)(cid:48)

2 in ((G/≡)∞)/≡,
there ex-
by deﬁnition of an RDF summary,
1 p n(cid:48)
in (G/≡)∞ such that
ists an edge n(cid:48)
2
n(cid:48)(cid:48)
1) p f2(n(cid:48)
1 p n(cid:48)(cid:48)
2). Hence, by Theorem 1,
there exists an edge n1 p n2 in G∞ such that
n(cid:48)
1 p n(cid:48)
2 = f (n1) p f (n2). Moreover, since n1 p n2
is in G∞, f1(n1) p f1(n2) is in (G∞)/≡. Therefore,
since for every f2(f (n1)) p f2(f (n2)) edge in
((G/≡)∞)/≡, there is an edge f1(n1) p f1(n2) in
(G∞)/≡, and since ϕ(f1(n)) = f2(f (n)), for n any
G∞ node, is a bijective function from all (G∞)/≡
nodes to all ((G/≡)∞)/≡ nodes, (G∞)/≡ contains
the image of all ((G/≡)∞)/≡ n(cid:48)(cid:48)
2 triples through
ϕ−1 (**).

1 p n(cid:48)(cid:48)

Similarly, for every edge n(cid:48)

1 type c in (G∞)/≡, by
deﬁnition of an RDF summary, there exists an edge
n1 type c in G∞ such that n(cid:48)
1 type c = f1(n1) type c.
Further, if n1 type c is in G∞, then f (n1) type c is
in (G/≡)∞ (Theorem 1), hence f2(f (n1)) type c is
in ((G/≡)∞)/≡. Therefore,

• since for every f1(n1)

type c edge in
(G∞)/≡, there is an edge f2(f (n1)) type c
in ((G/≡)∞)/≡, and

• since ϕ(f1(n)) = f2(f (n)), for n any G∞
node, is a bijective function from all (G∞)/≡
nodes to all ((G/≡)∞)/≡ nodes,

• it follows that ((G/≡)∞)/≡ contains the
image of all (G∞)/≡ f1(n1) type c triples
through ϕ (*’).
Now, for every edge n(cid:48)(cid:48)

1 type c in (G/≡)∞ such that n(cid:48)(cid:48)

1 type c in ((G/≡)∞)/≡,
by deﬁnition of an RDF summary, there exists an
edge n(cid:48)
1 type c =
f2(n(cid:48)
1) type c. Hence, by Theorem 1, there exists
an edge n1 type c in G∞ such that n(cid:48)
1 type c =
f (n1) type c. Moreover, since n1 type c is in G∞,
f1(n1) type c is in (G∞)/≡. Therefore, since for
every f2(f (n1)) type c edge in ((G/≡)∞)/≡, there
is an edge f1(n1) type c in (G∞)/≡, and since
ϕ(f1(n)) = f2(f (n)),
is a
bijective function from all (G∞)/≡ nodes to all
((G/≡)∞)/≡ nodes, (G∞)/≡ contains the image of
1 type c triples through ϕ−1 (**’).
all ((G/≡)∞)/≡ n(cid:48)(cid:48)
From (*) and (**), and, (*’) and (**’), it fol-
lows that ϕ deﬁnes an isomorphism from (G∞)/≡ to
(cid:3)
((G/≡)∞)/≡.

for n any G∞ node,

Appendix E. Saturation and property

cliques

The next Lemma describes the relationships be-
tween a clique C of G, its saturated version C +, and
the cliques of G∞:

property
(Saturation vs.
Lemma 3.
cliques) Let C, C1, C2 be non-empty source (or
target) cliques of G.

(1) There exists exactly one source (resp. tar-
get) clique C∞ of G∞ such that C ⊆ C∞.

1 ∩ C +

(2) If C +

1 ∪· · ·∪C +

2 (cid:54)= ∅, then all the properties in
C1 and C2 are in the same G∞ clique C∞.
(3) Any non-empty source (or target) clique
C∞ is a union of the form C +
k for
some k ≥ 1, where each Ci is a non-empty
source (resp. target) clique of G, and for any
Ci, Cj where 1 ≤ i, j ≤ k with i (cid:54)= j, there
exist some cliques D1 = Ci, . . . , Dn = Cj
in the set {C1, . . . , Ck} such that:
n−1 ∩ D+

2 (cid:54)= ∅, . . . , D+
(4) Let p1, p2 be two data properties in G, whose
source (or target) cliques are C1 and C2.
Properties p1, p2 are in the same source
(resp. target) clique C∞ of G∞ if and only
if there exist k non-empty source (resp. tar-
get) cliques of G, k ≥ 0, denoted D1, . . . , Dk
such that:

1 ∩ D+

n (cid:54)= ∅

D+

C +
∅, . . . , D+

1 ∩ D+
k−1 ∩ D+

1 (cid:54)= ∅, D+

1 ∩ D+

k (cid:54)= ∅, D+

2 (cid:54)=
k ∩ C +

2 (cid:54)= ∅.

Proof. We prove the lemma only for source cliques;
the proof for the target cliques is very similar.

(1) Any resource r ∈ G having two data prop-
erties also has them in G∞; thus, any data
properties in the same source clique in G are
also in the same source clique in G∞. The
unicity of C∞ is ensured by the fact that
the source cliques of G∞ are by deﬁnition
disjoint.

(2) C +

1 and C +

2 intersect on property p iﬀ there
exist some p1 ∈ C1 and p2 ∈ C2 which are
specializations of the same p (one, but not
both, may also be p itself). Independently,
we know that there exist r1, r2 ∈ G such
that r1 has p1 and r2 has p2; in G∞, r1 has
p1 and p, thus these two properties are in
the same G∞ clique. Similarly, r2 has p2
and p, which ensures that p is also in the
same G∞ source clique.

(3) Let {p1, . . . , pk} be the data properties that
appear both in G and in C∞; it follows from
the saturation rules and the deﬁnition of
cliques, that k > 0. For 1 ≤ i ≤ k, let Ci
be the G source clique comprising pi. Ap-
plying lemma point 1., Ci ⊆ C∞ for each
1 ≤ i ≤ k. Further, it is easy to see that
C +
i ⊆ C∞, since any property that satura-
tion adds to C +
is also added by saturation
i
to C∞. Thus, (cid:83)
1≤i≤k C +
i ⊆ C∞.
Let us now show that C∞ ⊆ (cid:83)

1≤i≤k C +
i .
Let p ∈ C∞ be a data property, then there
exists a resource r having p in G∞. Then, in
G, r has a property p(cid:48) which is either p, or is
such that p(cid:48) sp p in G∞. Then, in G∞, r has
both p and p(cid:48), which entails that p(cid:48) ∈ C∞.
Therefore, p(cid:48) is a data property occurring
both in C∞ and in G, therefore p(cid:48) is one of

24

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

the properties pi, for some 1 ≤ i ≤ k, that
is, p(cid:48) ∈ Ci, and accordingly, p ∈ C +
i due to
p(cid:48) sp p.

Thus, any data property p ∈ C∞ is part

of some C +
i .

We must still show that the saturated
cliques intersect.
If k = 1 the statement
is trivially true. Suppose k ≥ 2 and the
statement is false. Let C denote the set
{C1, . . . , Cm}; the cliques in C are pairwise
disjoint by deﬁnition. Let I ⊆ C be a max-
imal subset of C cliques such that the satu-
rations of I cliques all intersect (directly or
indirectly). Let J = C \ I be the comple-
ment of I; if the last part of 4. is false, J
is not empty. We denote I +, respectively
J +, the set of the saturated cliques from I,
resp. J .

No data property pi

from I + can be
source-related in G∞ to any data prop-
erty pj from J +. This is because source-
relatedness requires a resource r having in
G∞ both pi and a property p source-related
to pj. If such a property p existed, it would
belong both to I + (since p has a common
source with pi) and to J + (since p is source-
related to pj); or, I + and J + have no prop-
erty in common.

The lack of source-relatedness in G∞ be-
tween pi and pj chosen as above contra-
dicts the hypothesis that they are part of
the same source clique of G∞, namely C∞.
(4) The statement follows quite directly as a
consequence of the previous one, concluding
our proof.

(cid:3)

Appendix F. Proof of Lemma 1

Proof. We prove the lemma for target-related prop-
erties.

in (G/W)∞.

“Only if”: If data properties are target-related in
(G/W)∞, then they belong to the same target clique
T C∞
W
By Lemma 3, point 3, it follows that T C∞
is
W
the union of the saturations of a set of G/W cliques
(T C 1

W )+. Then:

W )+, . . . , (T C m
W )+, (T C 2
• For every 1 ≤ j ≤ m:

W is the target clique of a G/W node

– T C j
nj;
– nj

set

represents

of weakly-
a
equivalent G resources, which are
targets only of properties in T C j
W .
W are
Thus,
target-related in G.

the properties

in T C j

– Thus, in G∞, also, the properties in

T C j

W are target-related.

– From this and the deﬁnition of a sat-
urated graph and of a saturated tar-
get clique, it follows that the proper-
ties from (T C j
W )+ are target-related in
G∞.

• Further, still by Lemma 3, point 4, each
(T C j
W)+
W )+ intersects at least another (T C l
for 1 ≤ l (cid:54)= j < m, thus the target proper-
ties in all the (T C j
W )+ for 1 ≤ j ≤ m, and
in particular p, are target-related to each
other in G∞. Thus, p is target-related in
G∞ to all properties from T C∞
W .

“If”: if data properties are target-related in G∞,
then they belong to the same target clique T C∞
in G∞. Let n1, . . . , nk be the set of all G resources
which are values of some properties in T C∞. By
deﬁnition of an RDF summary and Theorem 1, each
summary representative f (ni) of ni, for 1 ≤ i ≤ k,
is at least the object of the same properties as ni,
hence all the properties of T C∞ in G∞ are target-
(cid:3)
related in (G/W)∞.

Appendix G. Proof of Proposition 3

Proof. Recall from Lemma 3 that:

SC∞

W = (SC 1
T C∞

W = (T C 1

W )+ ∪ (T C 2

W )+ ∪ (SC 2

W )+ ∪ . . . ∪ (SC m

W )+ and
W )+

W )+ ∪ . . . ∪ (T C n
W , . . . , SC m

for some G/W source cliques SC 1
get cliques T C 1

W , . . . , T C n
W .
Lemma 1 ensures that the data properties in
W )+ are related in G∞, and those
W )+ ∪. . .∪(SC m
W )+ are related in G∞.

W )+ ∪ . . . ∪ (T C n

(SC 1
of (T C 1

W and tar-

Moreover, nW was created in G/W from a set of
weakly-equivalent G nodes having as source clique
one among SC 1
W and as target clique one
W . In G∞, these nodes connect
among T C 1
W . (cid:3)
W with those of T C∞
the data properties of SC∞

W , . . . , SC m

W , . . . , T C n

Appendix H. Proof of Theorem 3

Proof. We show that W summaries enjoy the
stated in
suﬃcient condition for completeness
Theorem 2, i.e., given two nodes n1, n2 in G∞, f
the representation homomorphism corresponding
to the weak-equivalence relation ≡W, and f (n1),
f (n2) the images of n1, n2 in (G/W)∞ through f
(recall Theorem 1), it holds that: n1 ≡W n2 in G∞
iﬀ f (n1) ≡W f (n2) in (G/W)∞.

“Only if”: n1 ≡W n2 in G∞ iﬀ they are connected
by an alternating chain of source and target cliques
of G∞ (as shown in Figure 19); to reuse that ﬁgure
for the current proof, let us use n2k to denote the n2
of the current lemma statement. Note that G∞ only
adds triples not nodes, thus all the nodes shown in
the ﬁgure also exist in G. Now, let us consider the
G/W nodes f (n1), f (n2), . . . , f (n2k) obtained by ap-
plying the representation function f on n1, . . . , n2k.

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

25

G

f (n1)

R2

r2

f (n2)

(G/W)∞

T C∞
W,1

SC∞
W,1

T C∞
W,2

SC∞
W,m

r1

R1

r3

. . .

r2m+1

R3

R2m+1

G

Figure 19. Sketch for the suﬃ-
cient condition for the weak sum-
mary to enjoy the shortcut prop-
erty.

By Theorem 1, f is also a homomorphism from G∞
to (G/W)∞, therefore any incoming (outgoing) edge
into (from) a node nj of G∞ is also incoming (resp.
outgoing) into (from) the respective node f (nj) of
(G/W)∞. As a consequence, we can reproduce the
alternating clique structure into (G/W)∞, which suf-
ﬁces to make f (n1) and f (n2k) weakly equivalent
in (G/W)∞.

“If”: f (n1) ≡W f (n2) in (G/W)∞ iﬀ they are con-
nected by an alternating chain of source and target
cliques in (G/W)∞. Assume w.l.o.g. that the chain
is as shown in Figure 19, that is, of the form:
• f (n1) shares a target clique T C∞
• r1(T C∞
W,1, SC∞
W,1)
• r2(T C∞
W,2, SC∞
W,1), . . .,
W,m−1, SC∞
• r2m+1(T C∞

W,m), and f (n2) has the

W,1 with r1

source clique SC∞
W,m
The alternating chain starts with a target clique
and ends with a source clique (of course three other
combinations are possible). In the chain, each re-
source is either:

• r2i+1(T C∞
• r2i+2(T C∞

W,i+1, SC∞
W,i+2, SC∞

W,i+1) or
W,i+1)

for some 0 ≤ i < m. Every r2i+1 and r2i+2 resource
is a node from (G/W )∞, thus a node from G/W (be-
cause saturating G/W does not create nodes). For a
given rj, let Rj be the set of weakly-equivalent G
resources from which rj was created; all resources
in Rj are by deﬁnition weakly equivalent in G, and
this also holds in G∞.

By Proposition 3, T C∞

W,1 is also a target clique
of G∞, and it must be the target clique of n1 in
G∞ (because of the f homomorphism from G∞ into
(G/W)∞ ensured by Theorem 1). Similarly, SC∞
W,m
must be a source clique in G∞ and in particular the
source clique of n2.

In G∞, n1 shares its target clique T C∞

W,1 with the
nodes in R1, thus n1 is weakly-equivalent to any
node from R1.

Further, by Proposition 3, if the node r1 has the
target clique T C∞
W,1 in
(G/W)∞, then the G∞ node whose target clique is

W,1 and the source clique SC∞

W,1 must also have the source clique SC∞

W,1 in G∞.
T C∞
(Proposition 3 also ensures that a node in G∞ has
SC∞

W,1 as its source clique.)
If the alternating chain is long enough to com-
prise r2 (that is: if the chain does not degenerate in
a single node), that corresponds to the set R2 of G
nodes which, in G∞, have the source clique SC∞
W,1,
therefore they are weakly equivalent to all nodes
from R1 which have the same source clique. Thus,
n1 is weakly equivalent in G∞ to the nodes from R1
and R2.

The above reasoning can be applied on each edge
in the alternating chain, extending weak equiva-
lence from n1 through all the Rj sets until n2. (cid:3)

Appendix I. Proof of Lemma 2

Proof. “If”:
if data properties are target-related
in G∞, then they belong to the same target clique
T C∞ in G∞. Let n1, . . . , nk be the set of all G re-
sources which are values of some properties in T C∞.
By deﬁnition of an RDF summary and Theorem 1,
each image fS(ni) of ni, for 1 ≤ i ≤ k is at least
the object of the same properties as ni, hence all
the properties of T C∞ in G∞ are target-related in
(G/S)∞.

“Only If”: if two data properties p1 and p2 are
target-related in (G/S)∞, then they belong to the
same target clique T C S,∞, in which they are at dis-
tance n ≥ 0, i.e., they are target-related because of
a set (cid:83)n
i=0{ri+1} of nodes which all have the target
clique T C S,∞. In G/S, each such ri+1 has a target
i ⊆ T C S,∞, moreover each ri+1 results
clique T C S
from a set of G nodes nj
i+1, j ≥ 1, which by deﬁni-
tion of a strong RDF summary, have all the source
clique T C S
i+1 node has target
clique T C S,∞ in G∞ (since G and G/S have the same
schema), in which p1 and p2 are target related. (cid:3)

i . Hence, every such nj

Appendix J. Proof of Proposition 4

Proof. Recall from Lemma 3 that:

SC∞

S = (SC 1
T C∞

S = (T C 1

S )+ ∪ (SC 2

S )+ ∪ . . . ∪ (SC m

S )+ ∪ (T C 2

S )+ ∪ . . . ∪ (T C n

S )+ and
S )+

for some SG source cliques SC 1
S , . . . , T C n
cliques T C 1
S .

S , . . . , SC m

S and target

Lemma 2 ensures that the data properties in
S )+ are related in G∞, and those
S )+ ∪. . .∪(SC m
S )+ are related in G∞.

S )+ ∪ . . . ∪ (T C n

(SC 1
of (T C 1

Moreover, nS was created in SG from a set of
strongly-equivalent G nodes all sharing a source
clique SC i
S, for 1 ≤ i ≤ m, and all sharing a tar-
get clique T C j
S , for some 1 ≤ j ≤ n. Thus, in G∞,
these nodes connect the data properties of SC∞
S
(cid:3)
with those of T C∞
S .

26

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

Appendix K. Proof of Theorem 4

Proof. “Only if” follows directly from Theorem 1.
To prove “if”, note that f (n1) ≡S f (n2) in (SG)∞
iﬀ they have the same source clique SC∞
S and the
in (SG)∞. By Proposi-
same target clique T C∞
S
tion 4, T C∞
is also a target clique of G∞, and it
S
must be the target clique of n1 and n2 in G∞ (be-
cause of the f homomorphism from G∞ into (SG)∞
ensured by Theorem 1). Similarly, SC∞
is a source
S
clique in G∞, and in particular the source clique of
n1 and n2.

Thus, n1 ≡S n2 in G∞.

(cid:3)

Appendix L. Proof of Theorem 7

Proof. We ﬁrst prove the claim for ≡fw.

We show this result using the suﬃcient condition
stated in Theorem 2. That is, n1 ≡fw n2 in G∞ holds
iﬀ f (n1) ≡fw f (n2) in (G/fw)∞ holds.

This holds for class nodes and for property nodes
since, by deﬁnition, they are only equivalent to
themselves through some RDF node equivalence re-
lation.

Now, consider two data nodes n1, n2 in G∞ such
that n1 ≡fw n2 in G∞, and let us show that
f (n1) ≡fw f (n2) in (G/fw)∞.

If n1 ≡fw n2 holds in G∞, then for every triple
n1 p m1 there exists a triple n2 p m2 such that
m1 ≡fw m2 holds, and conversely for every triple
n2 p m2 there exists a triple n1 p m1 such that
m1 ≡fw m2 holds.

Let P ∞

n1,n2→m1,m2

be the set of outgoing proper-

ties from n1 to m1 and from n2 to m2 in G∞.

In G, the set of outgoing properties from n1 to
m1, denoted Pn1→m1 is a subset of P ∞
,
n1,n2→m1,m2
since by deﬁnition the saturation of a graph only
adds edges; similarly, in G, the set of outgoing prop-
erties from n2 to m2, denoted Pn2→m2 is a sub-
set of P ∞
, which may be diﬀerent from
Pn1→m1.

n1,n2→m1,m2

By deﬁnition of a ≡fw-summary, the set of outgo-
ing properties from f (n1) to f (m1) in G/fw is exactly
Pn1→m1 and similarly the set of outgoing properties
from f (n2) to f (m2) in G/fw is exactly Pn2→m2 .

Since G and G/fw have the same schema (Sec-
tion 5), it follows that in (G/fw)∞, the set of outgo-
ing properties from f (n1) to f (m1), and from f (n2)
to f (m2), is exactly P ∞
(data edges can
only be added through subProperty constraints).

n1,n2→m1,m2

Since the above holds for any pair of data nodes
n1, n2 such that n1 ≡fw n2 in G∞, and for any of
their G∞ outgoing edges n1 p m1 and n2 p m2, hence
f (n1) ≡fw f (n2) in (G/fw)∞ holds.

Now, consider two data nodes f (n1), f (n2) in
(G/fw)∞ such that f (n1) ≡fw f (n2) in (G/fw)∞ and
let us show that n1 ≡fw n2 holds in G∞.

If f (n1) ≡fw f (n2) holds in (G/fw)∞, then for
every triple f (n1) p f (m1) there exists a triple

f (n2) p f (m2) such that f (m1) ≡fw f (m2) holds,
and conversely for every triple f (n2) p f (m2) there
exists a triple f (n1) p f (m1) such that f (m1) ≡fw
f (m2) holds.
Let P ∞

f (n1),f (n2)→f (m1),f (m2) be the set of outgo-
ing properties from f (n1) to f (m1) and from f (n2)
to f (m2) in (G/fw)∞.

In G/fw, the set of outgoing properties from
f (n1) to f (m1), denoted Pf (n1)→f (m1) is a sub-
set of P ∞
f n1),f (n2)→f (m1),f (m2), since by deﬁnition
the saturation of a graph only adds edges; simi-
larly, in G/fw, the set of outgoing properties from
f (n2) to f (m2), denoted Pf (n2)→f (m2) is a subset
of P ∞
f (n1),f (n2)→f (m1),f (m2), which may be diﬀerent
from Pf (n1)→f (m1).

By deﬁnition of a ≡fw-summary, the set of out-
going properties from n1 to m1 in G is exactly
Pf (n1)→f (m1) and similarly the set of outgoing prop-
erties from n2 to m2 in G is exactly Pf (n2)→f (m2).
Since G and G/fw have the same schema (Sec-
tion 5), it follows that in G∞, the set of outgoing
properties from n1 to m1, and from n2 to m2, is ex-
actly P ∞
f (n1),f (n2)→f (m1),f (m2) (data edges can only
be added through subProperty constraints).

Since the above holds for any pair of data
nodes f (n1), f (n2) such that f (n1) ≡fw f (n2) in
(G/fw)∞, and for any of their (G/fw)∞ outgoing
edges f (n1) p f (m1) and f (n2) p f (m2), hence
n1 ≡fw n2 in G∞ holds.

The proof for ≡bw directly derives from the above
one by considering incoming edges instead of outgo-
ing ones; the proof for ≡fb then derives from those
of ≡fw and ≡bw by considering both incoming and
(cid:3)
outgoing edges.

Appendix M. Proof of Proposition 5

Proof. All our algorithms (global or incremental)
start by identifying the class and property nodes:
this is done retrieving all the subjects and objects
from schema triples, and also all the objects of type
triples. As previously stated, triple stores routinely
support such retrieval eﬃciently. Our algorithms
start by representing these special schema nodes ex-
actly by themselves, and copying in the summary
all the schema triples. This exploits the observation
made in Section 5 (G and G/≡ have the same schema
triples).

Below, we show the correctness of incremen-
tal W and S summarization on data triples. The
proof of Proposition 6 (below) extends this also to
type triples.

The correctness of incremental W summariza-
tion on data triples follows from the fact that Algo-
rithm increm-W preserves a set of invariants. Let Gk
be the ﬁrst k triples of G, in the order in which they
are traversed by the algorithm. For any 1 ≤ k ≤ |G|,

RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY

27

after applying increm-W on k data triples, the fol-
lowing invariants are preserved:

(1) The source and target srcp and trgp of any
property p present in these k triples are
known.

(2) For any summarized triple s p o, we have
fW(s) = srcp and fW(o) = trgp; further, the
summary contains the edge fW(s) p fW(o).

The preservation of these invariants is shown by
considering all the cases which may occur for a given
summarized triple s p o: the subject s may have al-
ready been seen (in which case this triple may lead
to a fusion), or not (in which case we create the new
representative of s), and similarly for o. For p there
are also two cases (depending on whether we had al-
ready encountered it or not, we may create srcp and
trgp, or just fuse them with pre-existing represen-
tatives of s and o). There are 8 cases overall. The
replacements and fusions detailed in Algorithm 3
guarantee these invariants.

While, for simplicity of presentation, Algorithm
increm-W considers the possible fusions due to s
and o separately, in reality, given that they may
impact the same node(s) (e.g., if fW(s) = fW(o)),
all the replacements are ﬁrst computed, then rec-
onciled into a list of summary node substitutions,
applied in all the data structures. For instance,
suppose we need to replace summary node 3 with
1 because of a fusion on the subject side, and also
summary node 5 with 3 because of a fusion on the
object side. In this case, the algorithm will replace
5 and 3 directly with 1. If the replacements were
applied sequentially, e.g., ﬁrst 3 with 1, the sec-
ond replacement would leave 3 (not 1) instead of 5,
which would be an error.

Similarly, the correctness of

incremental S
summarization on data triples follows from the
fact that Algorithm increm-S preserves the follow-
ing invariants after having been called on k succes-
sive data triples, with 1 ≤ k ≤ |G|:

(1) The source and target clique sc(p) and tc(p)
of any property p present in these k triples
are known, and they contain p.

(2) For any summarized triple s p o, we
have fS(s) = sc(p) and fS(o) = tc(p);
further, the summary contains the edge
fS(s) p fS(o).

(3) For any source clique sc and target clique
tc of a node n appearing in the summarized
triple, the summary contains exactly one
node.

(4) For any summary node m, the count m(cid:93)
is exactly the cardinality of the set {n ∈
G | fS(n) = m}.

(5) For any summary edge m

p
−→ m(cid:48), the count
p
e(cid:93) is exactly the cardinality of the set {n
−→
n(cid:48) edge of G (cid:107) fS(n) = m and fS(n(cid:48)) = m(cid:48)}.

(6) For any (subject, property) combination oc-
curring in the summarized triples, the count
(sp)(cid:93) is exactly the number of times this
occurred in the triples. Similarly, for any
(property, object) combination appearing
in the summarized triples, the count (po)(cid:93)
is exactly the number of times it appeared.

Like for increm-W, there are eight cases depend-
ing on whether s, p and o have been previously
seen. Further, in the four cases where s has been
seen, we may need to split s’s representative, or not,
and similarly for o; thus, the six cases original cases
where at least one of them had been seen lead to 12
cases (to which we add the remaining two, where
neither s nor o had been seen), for a total of 14
cases.

Items 4, 5 and 6 are ensured during: the addi-
tion of an edge to the summary (this sets e(cid:93) to 1
or increases it); the assignment of representatives
to nodes (this sets m(cid:93) to 1 or increments it); the
edge repartition during split (this subtracts from
one edges e(cid:93) exactly the count that it adds to an-
other new edge); and node replacements (which,
when replacing u with v, either carry u(cid:93) into v(cid:93),
if v did not exist in the summary previously, or add
u(cid:93) to v(cid:93) if it did). Together, 4, 5 and 6 ensure
the correctness of the split algorithm (explained in
Section 7.1).

The previous items are ensured by the creation
of summary nodes (at most one exists at any time
for a given source and target clique), fusing cliques
(this guarantees each property is in the right clique,
and remove cliques input to the fusion), and replac-
ing / fusing summary nodes, as well as from the
(cid:3)
correctness of the split procedure.

Appendix N. Proof of Proposition 6

Proof. First, recall that TW and TS summarization
start with the type triples, which means all type
nodes are detected and represented according to
their class sets, before the data triples are summa-
rized. This entails that among the cases which oc-
cur for W and S summarization (8, respectively, 14,
see discussion in the proof of Proposition 5), those
in which the subject, respectively, the object was
already represented are further divided in two, de-
pending on whether the subject, respectively, object
was a typed node.

This shows that incremental TW summarization
handles a superset of the cases handled by the W
one, and similarly for TS and TS. Thus, increm-TW,
respectively, increm-TS preserve all the invariants
of increm-W, respectively, increm-S9, with some
additions, which we highlight in italics below.
Additions of TW summarization w.r.t. W:

9Note that in the particular case of triples connecting

untyped nodes, the algorithms coincide.

28

F. GOASDOU´E, P. GUZEWICZ, AND I. MANOLESCU

(1) The source and target srcp and trgp of any
property p present with an untyped source,
respectively, an untyped target in the sum-
marized triples are known.

(2) For any summarized triple s p o, we have
fW(s) = srcp if s is untyped and fW(o) =
trgp if o is untyped; further, the summary
contains the edge fW(s) p fW(o).
Additions of TS summarization w.r.t. S:

(1) The source and target clique sc(p) and tc(p)
of any property p present in these k triples
with an untyped source, respectively, with
an untyped target are known, and they con-
tain p.

(2) For any summarized triple s p o, we have
fS(s) = sc(p) if s is untyped, and fS(o) =
tc(p) if o is untyped; further, the summary
contains the edge fS(s) p fS(o).

Further, they also preserve:

(7) The summary contains one node for each
set of classes belonging to some resource in
the input.

(8) For any node n with a non empty class set,
fTW(n) (respectively, fTS(n)) is the node cor-
responding to the class set of n.

These invariants are ensured by the way in which
we collect all class sets during the initial traver-
sal of type triples (common to the TW and TS algo-
rithms). Further, during the TW and TS summariza-
tion, as said in Section 7.3, the representatives of
typed nodes never fuse, and never split.

The 6 invariants from the proof of Prop. 5 en-
sure the correct summarization of data triples when
s and o are untyped. Together with the two
above, they also ensure the correct summarization
(cid:3)
of triples having a typed s and/or o.

(F. Goasdou´e) Univ. Rennes, Inria, CNRS, IRISA,

France

Email address, F. Goasdou´e: fg@irisa.fr

(P. Guzewicz) Institut Polytechnique de Paris, In-

ria, France

Email address, P. Guzewicz: pawel.guzewicz@inria.fr

(I. Manolescu) Inria and Institut Polytechnique de

Paris, France

Email address, I. Manolescu: ioana.manolescu@inria.fr

