Oracle simulation: a technique for protocol composition
with long term shared secrets
Hubert Comon, Charlie Jacomme, Guillaume Scerri

To cite this version:

Hubert Comon, Charlie Jacomme, Guillaume Scerri. Oracle simulation: a technique for protocol
composition with long term shared secrets. ACM CCS 2020, Nov 2020, Orlando, United States.
pp.1427-1444. ￿hal-02913866￿

HAL Id: hal-02913866

https://inria.hal.science/hal-02913866

Submitted on 10 Aug 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Oracle simulation: a technique for protocol composition with
long term shared secrets

Hubert Comon1, Charlie Jacomme2, and Guillaume Scerri3

1,2LSV, CNRS & ENS Paris-Saclay & Inria & Université Paris-Saclay
3Université Versailles Saint-Quentin & Inria

August 10, 2020

Abstract

We provide a composition framework together with a variety of composition theorems
allowing to split the security proof of an unbounded number of sessions of a compound
protocol into simpler goals. While many proof techniques could be used to prove the
subgoals, our model is particularly well suited to the Computationally Complete Symbolic
Attacker (CCSA) model.

We address both sequential and parallel composition, with state passing and long term
shared secrets between the protocols. We also provide with tools to reduce multi-session
security to single session security, with respect to a stronger attacker. As a consequence,
our framework allows, for the ﬁrst time, to perform proofs in the CCSA model for an
unbounded number of sessions.

To this end, we introduce the notion of O-simulation: a simulation by a machine
that has access to an oracle O. Carefully managing the access to long term secrets, we
can reduce the security of a composed protocol, for instance P (cid:107)Q, to the security of P
(resp. Q), with respect to an attacker simulating Q (resp. P ) using an oracle O. As
demonstrated by our case studies the oracle is most of the time quite generic and simple.
These results yield simple formal proofs of composed protocols, such as multiple ses-
sions of key exchanges, together with multiple sessions of protocols using the exchanged
keys, even when all the parts share long terms secrets (e.g. signing keys). We also provide
with a concrete application to the SSH protocol with (a modiﬁed) forwarding agent, a
complex case of long term shared secrets, which we formally prove secure.

Contents

I The Framework

1 Introduction

1.1 Our contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Related Works

3

3
4
5

1

7
2 Protocols and Indistinguishability
7
. . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1 Syntax and semantics of terms
8
2.2 Syntax of the protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Semantics of the protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
2.4 Stateless Oracle Machines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.5 Computational indistinguishability . . . . . . . . . . . . . . . . . . . . . . . . . 12

3 Simulatability

13
3.1 Protocol Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.2 Generic Oracles for Tagged Protocols . . . . . . . . . . . . . . . . . . . . . . . . 23

4 Main Composition Theorems

25
4.1 Composition without State Passing . . . . . . . . . . . . . . . . . . . . . . . . . 25
4.2 Composition with State Passing . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
4.3 Unbounded Replication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

5 Unbounded Sequential Replication

II Applications to Key Exchange

33

34

6 Application to Key Exchanges

34
6.1 Our Model of Key Exchange . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
6.2 Proofs of Composed Key Exchange Security . . . . . . . . . . . . . . . . . . . . 35

7 Basic Diﬃe-Hellman Key Exchange

38

8 Extension to Key Conﬁrmations

40
8.1 Proofs with Key Conﬁrmations . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

41
9 Application to SSH
9.1 The SSH Protocol
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
9.2 Security of SSH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
9.3 SSH with Forwarding Agent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

III Composition in the CCSA logic

47

10 Oracles in the CCSA Logic
48
10.1 Syntax and Semantics
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
10.2 Oracle Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

11 Computational Soundness of the logic

51
11.1 Protocols
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
11.2 Introduction of attacker’s functions . . . . . . . . . . . . . . . . . . . . . . . . . 52

12 Extension to the Model for Unbounded Replication

53

2

A Messages

59
A.1 Syntax of messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
A.2 Semantics of terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

B Protocols

60
B.1 Protocol Algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
B.2 Formal deﬁnition of a protocol execution . . . . . . . . . . . . . . . . . . . . . . 60
. . . . . . . . . . . . . . . . . . . . . . . . 61
B.3 Formal deﬁnition of protocol oracles

C A case study : signed DDH

64
C.1 Key exchange security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
C.2 Proof for φ3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
C.2.1 Real or random of the key . . . . . . . . . . . . . . . . . . . . . . . . . . 67
C.2.2 Authentication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
C.3 Conclusion for Signed DDH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69

D An application to SSH

69
D.1 Presentation of SSH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
D.2 The security of the protocol without forwarding agent
. . . . . . . . . . . . . . 70
D.3 Proof of real of random . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
. . . . . . . . . . . . . . . . . . . . . . . . . . . 72
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
D.4 Proof for the authentication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73

D.3.1 Proof of Ax |= φ2 ∼ ψ2
D.3.2 Proof of Ax |= φ1
2 ∼ ψ1
2

E SSH with forwarding agent

E.1 Scheme of the proof

74
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
E.1.1 First application of Corollary 3 . . . . . . . . . . . . . . . . . . . . . . . 75
E.1.2 Second application of Corollary 3 . . . . . . . . . . . . . . . . . . . . . . 76

F Proofs

77
F.1 Formal Corollary for Key Exchange . . . . . . . . . . . . . . . . . . . . . . . . . 77
F.2 Formal Corollary for Key Conﬁrmations . . . . . . . . . . . . . . . . . . . . . . 79
F.3 Oracle Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
F.4 Autocomposition Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
F.5 Key Exchanges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
F.6 Computational soundness

Part I
The Framework

1

Introduction

This paper is concerned with the security proofs of composed protocols. This topic has been
widely studied in the last two decades. For instance, Universal Composability (UC) and
simulation based reductions [1–6] and other game-based composition methods [7–10] address
this issue. While the former proceed in a more bottom-up manner (from secure components in

3

any environment, construct secure complex protocols), the latter proceed in a more top-down
way: from the desired security of a complex protocol, derive suﬃcient security properties of its
components. Such “top-down” proofs design allows more ﬂexibility: the security requirements
for a component can be weaker in a given environment than in an arbitrary environment.
The counterpart is the lack of “universality”: the security of a component is suitable for some
environments only.

We follow the “top-down” approach. While we aim at designing a general methodology,
our target is the management of formal security proofs in the Computationally Complete
Symbolic Attacker (CCSA) model [11]. As a side result of our work, we provide with a way
of proving the security of an arbitrary number of sessions (that may depend on the security
parameter) in the CCSA model.

When trying to (de-)compose security properties, the main diﬃculty comes from the fact
that diﬀerent protocols may share some secrets. This is typically the case for multiple sessions
of the same protocol, or for key exchange protocols, which result in establishing a shared
secret that will be later used in another protocol. Protocols may also share long term secrets,
for instance the same signing key may be used for various authentication purposes. Another
example is the SSH protocol with the agent forwarding feature [12], which we will consider
later. The forwarding feature allows to obtain, through previously established secure SSH
connections, signatures of fresh material required to establish new connections.
It raises a
diﬃculty, as signatures with a long term secret key are sent over a channel established using
the same long term secret key.

As far as we know, the existing composition results that follow the “top-down” approach
cannot be used in situations where there is both a “state passing”, as in key exchange protocols,
and shared long term secrets. For instance, in the nice framework of [10], the same public key
cannot be used by several protocols, a key point for reducing security of multiple sessions to
security of one session.

When decomposing the security of a composed protocol into the security of its components,
we would like to break a complex proof into simpler proofs, while staying in the same proof
framework. This is also a diﬃculty since the attacker on a protocol component might use the
other components: we need a proof with respect to a stronger attacker. In [10], such a strong
attacker can be simulated by a standard one, because there is no shared long term secret.

1.1 Our contributions

We provide with a composition framework that reduces the security of a compound protocols
to the security of its components. We allow both state passing and shared long term secrets.
We stay in the same proof framework of the CCSA model.

The starting idea is simple: if we wish to prove the security of a composed protocol P (cid:107)Q,
it is suﬃcient to prove the security of P against an attacker that may simulate Q, maybe
with the help of an oracle.
If n are the secrets shared by P and Q, this simulation has
to be independent of the distribution of n. This is actually an idea that is similar to the
key-independence of [8].

Therefore, we ﬁrst introduce the notion of O-simulation, in which an oracle O holds the
shared secrets: if Q is O-simulatable and P is secure against an attacker that has access to O,
then P (cid:107)Q is secure. Intuitively, O deﬁnes an interface through which the secrets can be used
(e.g. obtaining signatures of only well tagged messages). O simulatable protocols conform to
this interface.

4

We extend this basic block to arbitrary parallel and sequential compositions, as well as
replication of an unbounded number of copies of the same protocol. In the latter case, the
security of a single copy of P against an attacker that has access to an oracle allowing to
simulate the other copies, requires to distinguish the various copies of a same protocol. In the
universal composability framework, this kind of properties is ensured using explicit session
identiﬁers. We rather follow a line, similar to [13], in which the session identiﬁers are implicit.
Our main composition Theorems are generic: the classical game based setting can be used
to prove the subgoals. They are also specially well-suited for the CCSA model, which allows
to complete computational proofs of real life protocols [14–16], while only relying on ﬁrst order
logic and cryptographic axioms. Many such axioms can easily be generalized so as to be sound
with respect to an attacker that has access to oracles (we will see examples later).

A proof using such axioms is valid for an attacker who has access to an environment,
while abstracting all the details of the environment and its interactions with the attacker.
Moreover, as our reductions from one session to multiple sessions are uniform, we may now
complete proofs in the CCSA model for a number of session that is parameterized by the
security parameter. This was a limitation (and left as an open issue) in all previous CCSA
papers.

We illustrate our composition results showing how to split the security of any (multi-session
with shared long term secret) composed key exchange into smaller proofs. We then complete
the formal proof of security of a Diﬃe-Hellman key exchange (ISO 9798-3 [17]) for any number
of sessions in parallel.

We generalize the application to key exchanges performing key conﬁrmations, i.e. using
the derived key in the key exchange (as in TLS). The generalization is simple, which is a clue
of the usability of our framework.

To illustrate the usability of our framework, we use all our results to prove the security of
the SSH [12] protocol with a modiﬁed agent forwarding, a complex example of key exchange,
with both key conﬁrmation and long term shared secrets. The modiﬁcation, which consists in
the addition of a tag to specify if the signature was performed remotely, is necessary for the
protocol to satisfy some natural security properties related to the agent forwarding.

1.2 Related Works

We introduce the composition problem through a process algebra: protocols are either build-
ing blocks (deﬁned,e.g, with a transition system) or composed using parallel and sequential
composition, and replication. This prevents from committing to any particular programming
language, while keeping a clean operational semantics. This approach is also advocated in [10],
which follows a similar approach. Other works on composition (e.g., [5, 7]) rely on speciﬁc
execution models.

Our starting idea, to prove a component w.r.t. a stronger attacker that has access to the
context, is not new. This is the basis of many works, including [8–10,18]. The main diﬀerence,
that we wish to emphasize, is that these works do not support long term shared secrets, used
in diﬀerent components. Notably, the oracles of [10] are only used to decompose protocols
with state passing. Our notion of simulatability allows sharing long term secret by granting
the attacker access to oracles that depend on the secrets (for instance, signing oracles). It also
allows a symmetric treatment for proofs of a protocol and proofs of its context.

For several speciﬁc problems, typically key exchanges, there are composition results allow-
ing to prove independently the key exchange protocol and the protocol that uses the exchanged

5

key [8, 9, 13, 18, 19]. In such examples, the diﬃculty also comes from the shared secret, es-
pecially when there is a key conﬁrmation step. In that case, the derived key is used for an
integrity check, which is part of the key exchange. Then the property of the key exchange:
“the key is indistinguishable from a random” does not hold after the key conﬁrmation and
thus cannot be used in the security proof of the protocol that uses this exchanged key. In [8],
the authors deﬁne the notion of key independent reduction, where, if an attacker can break
a protocol for some key distribution, he can break the primitive for the same distribution of
the key. This is related to our notion of simulatability, as interactions with shared secrets
are captured by an oracle for ﬁxed values of the key, and thus attacks on the protocol for
a ﬁxed distribution are naturally translated into attacks against the primitive for the same
distribution. Key exchanges with key conﬁrmation are therefore a simple application of our
composition results. Along the same line, [19] extends [18] to multi staged key exchanges,
where multiple keys might be derived during the protocol. While we do not directly tackle
this in our paper, our framework could be used for this case.

The authors of [9] also provide results allowing for the study of key renewal protocols (which
we capture with the sequential replication Theorem), and has the advantage to be inside a
mechanized framework, while we only cast our results inside a mechanizable framework. It
does not however consider key conﬁrmations.

The UC framework initiated by [1] and continued in [3, 4, 6] is a popular way of tackling
composition. As explained above, this follows a “bottom-up” approach, in which protocols
must be secure in any context, which often yield very strong security properties, some of
which are not met in real life protocols. Moreover, to handle multiple sessions of a protocol
using a shared secret, joint-state theorems are required. This requires a tagging mechanism
with a distinct session identiﬁer (sid) for each session. Relaxing this condition, the use of
implicit session identiﬁers was established in [20] for the UC framework, ideas continued in [13]
for Diﬃe-Hellman key exchanges, where they notably provide a proof of the ISO 9798-3 [17]
protocol.

We do not consider a composition that is universal: it depends on the context. This allows
us to relax the security properties regarding the protocol, and thus prove the compositional
security of some protocols that cannot be proved secure in the UC sense. We also rely on
implicit sids to prove the security of multiple sessions. Some limitations of the UC framework
are discussed in [18, Appendix A].

In [5], the authors also address the ﬂexibility of UC (or reactive simulatability) showing how
to circumvent some of its limitations. The so-called “predicates” are used to restrict the order
and contents of messages from environment and deﬁne a conditional composability. Assuming
a joint-state conditional composability theorem, secret sharing between the environment and
the protocol might be handled by restricting the accepted messages to the expected use of the
shared secrets. However, the framework does not cover how to prove the required properties
of (an instance of) the environment.

Protocol Composition Logic is a formal framework [21] designed for proving, in a “Dolev-
Yao model”, the security of protocols in a compositional way. Its computational semantics is
very far from the usual game-based semantics, and thus the guarantees it provides [22] are
unclear. Some limitations of PCL are detailed in [23].

The compositional security of SSH, in the sense of [18], has been studied in [24]. They do
not consider however the agent forwarding feature. It introduces important diﬃculties since
the key exchange is composed with a second key exchange that uses both the ﬁrst derived key
and the same long term secrets. SSH has also been studied, without agent forwarding, in [25],

6

where the implementation is derived from a secure modelling in CryptoVerif [26].

Summing up, our work is strongly linked to previous composition results and captures
analogues of the following notions in our formalism:
implicit disjointness of local session
identiﬁers [20], single session games [18], key-independent reductions [8] and the classical
proof technique based on pushing part of a protocol inside an attacker, as recently formalized
in [10]. We build on all these works and additionally allow sharing long term secrets, thanks
to a new notion of O-simulatability. This ﬁts with the CCSA model: the formal proofs
of composed protocols are broken into formal proofs of components. All these features are
illustrated by a proof of SSH with (a modiﬁed) agent forwarding.

2 Protocols and Indistinguishability

We ﬁrst recall some features of the CCSA model. Although this model is not used until the
case studies, it may be useful for an easier understanding of the protocol semantics.

2.1 Syntax and semantics of terms

To enable composition with long term shared secrets, we must be able to specify precisely
the shared randomness between protocols. We use symbols from an alphabet of names, to
represent the random samplings. The same symbol used twice represents the same (shared)
randomness. Those names can be seen as pointers to a speciﬁc randomness, where all the
randomness has been sampled upfront at the beginning of the protocol. This idea stems from
the CCSA model [11], from which we re-use exactly the same term semantics. This is one of
the reason why our results, while applicable in a broader context, ﬁt naturally in the CCSA
model. Let us recall the syntax and semantics of terms drawn from the CCSA model.

Syntax We use terms built over explicit names to denote messages computed by the protocol.
The terms are deﬁned with the following syntax:

t

names
::= n
indexed names
n(cid:126)i
variable
x
f (t1, . . . , tn) operation of arity n

|
|
|

A key addition to the CCSA model is that some names can be indexed by sequences of
index variables. This is necessary so that we may later on consider the replication of protocols.
When a replicated protocol depends on a name ni, the ﬁrst copy (session) of the protocol uses
n1, the second n2, . . . . Names without index models randomness shared by all sessions of
the protocol. Variables are used to model the attacker inputs, and function symbols allows to
model the cryptographic computations.

Semantics Terms are interpreted as bitstrings. As in the computational model, the inter-
pretation depends on some security parameter η. As we assume that all the randomness is
sampled at the beginning, the interpretation depends on an inﬁnitely long random tape ρs.
We then leverage the notion of a cryptographic library 1, that provides an interpretation for

1This corresponds in the CCSA model to the notion of functional model.

7

all names and function symbols. A cryptographic library Mf provides for each name n a
Probabilistic Polynomial Time Turing Machine (PPTM for short) An, that is given access to
the random tape ρs. As an additional input, all machines will always be given the security
parameter in unary. Each An extracts a bit-string of length η from the random tape. Diﬀerent
names extract non-overlapping parts of the random tape. In the interpretation, we give to all
the PPTM the same random tape ρs, so each name is always interpreted with the same value
in any term (and thus any protocol), and all names are interpreted independently.

Mf also provides for each function symbol f (encryption, signature,...) a PPTM Af , that
must be deterministic. To model randomized cryptographic primitives, additional randomness
must be given to the function symbol as extra names (cf. Example 2.1).

Given Mf , the semantic mapping [[·]]η,σ
ρs

evaluates its argument, a formal term, given an
assignment σ of its variables to bit-strings and a random tape ρs. For instance, if n is a
name, [[n]]η
ρs = An(1η, ρs) (extracts a bit-string of length η from the random tape ρs) and
[[sign(x, k)]]η,{x(cid:55)→m}
= Asign(m, Ak(1η, ρs)). The details about the syntax and semantic of
ρs
messages can be found in Appendix A.

2.2 Syntax of the protocols

The summary of the protocol syntax is given in Figure 1. An elementary protocol models a
thread running on a speciﬁc computer. let denotes variable binding inside a thread, in(c, x)
(resp. (out(c, m)) denotes an input (resp. an output) of the thread over the channel c, where
all channels are taken out of a set C. For simplicity, channel identiﬁers are constants or indexed
constants. In particular, they are known to the attacker. The if then else constructs denotes
conditionals, 0 is a successfully terminated thread and ⊥ is an aborted thread.

For protocols, our goal is to state and prove general composition results: we ﬁrst consider
sequential composition (the ; operator), where 0; P reduces to P , while ⊥; P reduces to ⊥.
In most cases, we will omit 0. We also consider parallel composition (the (cid:107) operator), a
ﬁxed number N of copies running concurrently (cid:107)i≤N , as well as an arbitrary number of copies
running concurrently (cid:107)i. For instance, we can express a (two-parties) key-exchange consisting
of an initiator I and a responder R with I(cid:107)R, the key exchange followed by a protocol using
the exchanged key (I; P I )(cid:107)(R; P R), as well as any number of copies of the resulting protocol
running in parallel: (cid:107)i((I; P I )(cid:107)(R; P R)). We can also consider an arbitrary iteration of a
protocol, “;i”, which could be used for expressing, for instance, key renewal.

We provide in Appendix B a full deﬁnition of the protocol algebra. For generality, the full
algebra is also parameterized by some atomic protocols, that can be used to easily extend the
syntax.

We allow terms inside a protocol to depend on some free variables and, in this case, we
denote P (x1, . . . , xn) a protocol, which depends on free variables x1, . . . , xn. P (t1, . . . , tn)
denotes the protocol obtained when instantiating each xi by the term ti.

We denote N (P ) (resp C(P )) the set of names (resp. channel names) of P .

Example 2.1. Given a randomized encryption function enc, we let P (c, x1, x2) be the protocol
in(c, x).out(c, enc(x, x1, x2)). Given names sk, r representing respectively a secret key and
a random seed, EN := (cid:107)i≤N P (ci, ri, sk) is then the protocol allowing the attacker to obtain
cyphertexts for an unknown secret key sk. Unfolding the deﬁnitions, we get:

The generalization giving access to encryption for ﬁve secret keys is expressed with (cid:107)i(cid:107)j≤5P (cj,i, rj,i, skj).

EN := P (c1, r1, sk)(cid:107) . . . (cid:107)P (cn, rn, sk)

8

elementary protocols:

Pel

::= let x = t in Pel
in(c, x).Pel
|
out(c, m).Pel
|
|
if s = t then Pel else Pel
0
|
| ⊥

variable binding
input
output
conditional
success
failure

protocols:
P, P (cid:48)

::= Pel
|
|
|
|

Pel; P
P (cid:107)P (cid:48)
(cid:107)i≤N P
(cid:107)iP

sequential composition
parallel composition
bounded replication
unbounded replication

Figure 1: The protocol algebra

φ, (P, σ) −→
A
φ, (P ; Q, σ) −→
A

φ(cid:48), (P (cid:48), σ(cid:48))

φ(cid:48), (P (cid:48); Q, σ(cid:48)) φ, (0; Q, σ) −→
A

φ, (Q, σ)

φ, (P, σ) −→
A
φ, (P, σ)(cid:107)E −→
A

φ(cid:48), (P (cid:48), σ(cid:48))

φ(cid:48), (P (cid:48), σ(cid:48))(cid:107)E

Figure 2: Operational Semantics (excerpt)

2.3 Semantics of the protocols

We give here some essential features of the formal execution model, which we need to formalize
our composition results.

A (global) state of a protocol consists in a frame, which is a sequence of bit-strings mod-
elling the current attacker knowledge, and a ﬁnite multiset of pairs (P, σ), where P is a protocol
and σ is a local binding of variables. Intuitively, each of the components of the multiset is the
current state of a running thread. We write such global states φ, (P1, σ1)(cid:107) · · · (cid:107)(Pn, σn).

The transition relation between global states is parameterized by an attacker A who inter-
acts with the protocol, modelled as a PPTM with its dedicated random tape ρr. The attacker
chooses which of the threads is going to move and computes, given φ, the input to that thread.
In the following, the conﬁguration of the protocol and the security parameter are (also) always
given to the attacker, which we do not make explicit for simplicity.

We give some of the rules describing the Structural Operational Semantics in Figure 2. The
full semantics can be found in Appendix B. The transition relation −→
between conﬁgurations
A
depends on the attacker A, the security parameter η and the random samplings ρs (to interpret
terms) and ρr (the randomness of the attacker). In P ; Q, P has to be executed ﬁrst. When it
is completed (state 0), then the process can move to Q, inheriting the variable bindings from
P . If P is not waiting for an input from the environment, it can move independently from
any of the other parallel processes.

9

The semantics of inputs (not detailed for simplicity) reﬂects the interactions with the
attacker. A computes the input to the protocol, given a frame φ and its own random tape
ρr. Therefore transitions depend not only on the attacker machines, but also2 on the name
samplings ρs (secret coins) and ρr (attacker’s coins).

Example 2.2. Continuing Example 2.1, the initial conﬁguration corresponding to E2 is
∅, (P (c1, r1, sk), ∅)(cid:107)(P (c2, r2, sk), ∅), where the attacker knowledge is empty and no local vari-
ables are bound. We consider one of the possible reductions, for some attacker A that ﬁrst
sends a message over channel c1 and then c2:

∅, (P (c1, r1, sk), ∅)(cid:107)(P (c2, r2, sk), ∅)

−→
A

−→
A

−→
A

−→
A

∅, (out(c1, enc(x, r1, sk), {x (cid:55)→ m})(cid:107)(P (c2r2, sk), ∅)

m = A(∅, ρr) is the first input
message computed by the attacker

φ, (P (c2, r2, sk), ∅)

φ = [[enc(x, r1, sk)]]η,{x(cid:55)→m}

is the
interpretation of the output
received by the attacker

ρs

φ, (out(c2, enc(x, r1, sk), {x (cid:55)→ m2})

m2 = A(φ, ρr) is the second input
message computed by the attacker

(φ, [[enc(x, r2, sk)]]η,{x(cid:55)→m2}

ρs

), 0

We assume action determinism of the protocols [27]: given an input message on a given

channel, if the current state is

φ, (P1, σ1)(cid:107) · · · (cid:107)(Pn, σn),

at most one of the Pi may move to a non-abort state. This means that each thread checks
ﬁrst that it is the intended recipient of the message. This also means that each output has to
be triggered by an input signal: none of the Pi starts with an output action. We remark that
in practice, protocols are action determinate.

For replicated protocols (cid:107)i≤N P or (cid:107)iP , the names in P that are indexed by the variable i

are renamed as follows: (cid:107)i≤N P is the protocol P {i (cid:55)→ 1}(cid:107) . . . (cid:107)P {i (cid:55)→ N } and

φ, ((cid:107)iP, σ)(cid:107)E −→
A

φ, ((cid:107)i≤A(ρr,φ)P, σ)(cid:107)E.

In other words, the attacker chooses how many copies of P will be considered, which may
depend, in particular, on the security parameter. A(ρr, φ) must be a natural number in
unary.

2.4 Stateless Oracle Machines

For reasons that have been explained in the introduction, we wish to extend the semantics of
protocols and their indistinguishability to attackers that have access to an additional stateless
oracle. At this stage, we need stateless oracles in order to be compositional. Let us explain

2They actually also depend on the oracle’s coins, when A is interacting with an external oracle, which we

explain later.

10

this. Assume we wish to prove a property of R in the context P (cid:107)Q(cid:107)R. The idea would be to
prove R, interacting with an attacker that simulates P (cid:107)Q. This attacker is itself a composition
of an attacker that simulates P and an attacker that simulates Q. The protocols P , Q, R
share primitives and secrets, hence the simulation of P, Q requires access to an oracle that
holds the secrets. If such an oracle were to be stateful, we could not always build a simulator
for P (cid:107)Q from simulators of P, Q respectively, since oracle replies while simulating Q could
depend on oracle queries made while simulating P , for instance.

The oracles depend on a security parameter η (that will not always be explicit), (secret)
random values and also draw additional coins: as a typical example, a (symmetric key) en-
cryption oracle will depend on the key k and use a random number r to compute enc(m, r, k)
from its query m. Therefore, the oracles can be seen as deterministic functions that take two
random tapes as inputs: ρs for the secret values and ρO for the oracle coins.

Formally, oracles take as input tuples (m, r, s) where m is a ﬁnite sequence of bitstrings, r
is a handle for a random value and s is a handle for a secret value. r and s are respectively used
to extract the appropriate parts of ρO, ρs respectively, in a deterministic way: the randomness
extracted from ρO is uniquely determined by m, r, s and the extractions for diﬀerent values
do not overlap.

In what follows, we only consider oracles that are consistent with a given cryptographic
library Mf . Such oracles only access ρs through some speciﬁc names. This set of names is
called the support of the oracle.

Example 2.3. An encryption oracle for the key k (corresponding to the handle “1”), succes-
sively queried with (m, 1, 1), (m(cid:48), 2, 1), (m, 3, 1), (m, 1, 1), (m(cid:48), 2, 2), . . . will produce respec-
tively the outputs enc(m, r1, k), enc(m(cid:48), r2, k), enc(m, r3, k), enc(m, r1, k), ⊥,. . . Here r1, r2, r3
are non-overlapping parts of ρO (each of length η). The support of this oracle is {k}.

The formal deﬁnition of stateless oracles is a bit involved, notably to formally specify
the randomness extraction. This construction is required to ensure the determinism of the
oracles. Determinism is required to build a single simulator for two parallel protocols from
the individual simulators for the two protocols.

For instance, for an oracle performing randomized encryption, rather than always en-
crypting with a fresh nonce, this system allows multiple attackers to obtain an encryption of
a message with the same random.

Deﬁnition 1 ((Stateless) Oracle). An oracle O is a triple of functions that have the following
inputs

• a sequence of bitstrings w ∈ ({0, 1}∗)n and two bitstrings r, s: the query, consisting of

an input query w, an input tag r, an input key s;

• a random tape ρs for the (secret) random values;

• the security parameter η;

• a random tape ρO for the oracle’s coins.

The ﬁrst function assigns to each w, s, r an integer n(w, s, r) ∈ N and is assumed injective.
n(w, s, r) is used to extract a substring e1(n(w, s, r), η, ρO) from ρO, which is uniquely deter-
mined by the input. We assume that the length of the substring extracted by e1 only depends
on η, and substrings extracted with e1 are disjoint for diﬀerent values of n.

11

The second function e2 assigns to each s a sequence p(s) of natural numbers, that are used
to extract secret values from ρs: e2(s, η, ρs) is a sequence of bitstrings. It is also assumed to
be injective.

The third function takes η, w, r, s, e1(n(w, s, r), η, ρO), e2(s, η, ρs) as input and returns a

result (a bitstring) or a failure message.

Example 2.4. Expanding upon Example 2.3, the encryption oracle is given by the triple of
functions (e1, e2, e3) such that:

• e1(n(w, s, r), η, ρO) extracts the substring r at position range [n(w, s, r) × η, (n(w, s, r) +

1) × η] from ρO.
(cid:40)

• e2(s, η, ρs) =

if s = 1

[[k]]η
ρs
0 else

• e3(η, w, r, s, e1(n(w, s, r), η, ρO), e2(s, η, ρs)) = [[enc(y, r, x)]]η

{y(cid:55)→w,r(cid:55)→r,x(cid:55)→e2(s,η,ρs)

Given η, and a sequence of bitstrings m, we call r1 the sequence of bitstrings at position range
[n(m, 1, 1)×η, (n(m, 1, 1)+1)×η] from ρO. Then, on input (m, 1, 1), e1(n(m, 1, 1), η, ρO) = r1,
e2(1, η, ρs) = [[k]]η
ρs

and the oracle returns e3(η, m, 1, 1, r1, [[k]]η

ρs) = [[enc(y, r, k)]]η

y(cid:55)→m,r(cid:55)→r1

.

An oracle machine (PPTOM) is a PPTM, equipped with an additional tape, on which the
queries to the oracle are written and from which the oracle replies are read. We often write
explicitly the machine inputs, as in AO(ρs,ρO)(ω, ρr), where ω is the input data of A, ρr is
its random tape and ρs, ρO are the random tapes accessible to the oracle. These deﬁnitions
extend to multiple oracles (cid:104)O1, . . . , On(cid:105), preﬁxing the query with an index in {1, . . . , n}.

Deﬁnition 2. A Probabilistic Polynomial Time Oracle Machine (PPTOM) is a Turing ma-
chine denoted by AO and equipped with:

• an input/working/output tape (as usual; it is read/write);

• a read-only random tape ρr (attacker’s coins);

• an oracle input tape ρO;

• an oracle output tape, which is read-only.

• an oracle read-only random tape ρs (not accessible by the Turing Machine);

Note that once the oracle’s random tape is ﬁxed, we ensure that all our oracles are deter-

ministic.

2.5 Computational indistinguishability

To deﬁne the classical notion of indistinguishability, we describe how protocols may be seen
as oracles, that an attacker can interact with. Given a protocol P and a cryptographic library
Mf , the oracle OP is an extension of the previous oracles:
it takes as an additional input
an history tape that records the previous queries. Given a query m with history h (now the
components r, s are useless), the oracle replies what would be the output of P , given the

12

successive inputs h, m. It also appends the query m to the history tape. The formal deﬁnition
of protocol oracles can be found in Appendix B.3.

The machines that interact with OP are also equipped with the history tape that is read-
only: the history can only be modiﬁed by the oracle. Since P may use secret data, the oracle
may access a secret tape ρs; this will be explicit.

An oracle may implement multiple parallel protocols: the oracle O(cid:104)P1,...,Pn(cid:105) ﬁrst checks
which Pi is queried (there is at most one such i, by action determinism) and then replies as
OPi

.
Finally, we may consider oracles that combine protocols oracles and stateless oracles.

A(cid:104)O1,...,Om(cid:105),(cid:104)OP1 ,...,OPn(cid:105) is also written AO1,...,Om,OP1 ,...,OPn .
Deﬁnition 3. Given a cryptographic library Mf , an oracle O and protocols P1, . . . , Pn, Q1, . . . , Qn,
we write AO,OP1?Q1 ,...,OPn?Qn ≺ (cid:15) if for every polynomial time oracle Turing machine AO,

|Pρs,ρr,ρO {AO(ρs,ρO),OP1 (ρs),...,OPn (ρs)(ρr, 1η) = 1}

−Pρs,ρr,ρO {AO(ρs,ρO),OQ1 (ρs),...,OQn (ρs)(ρr, 1η) = 1}|

is negligible in η. We will write P ∼=O Q for AO,OP ?Q ≺ (cid:15).
Example 2.5. For i ∈ {1, 2}, the protocol Pi is deﬁned with the single transition:

q, {x1, ..., xn}

xn+1=(m1,m2)
−−−−−−−−−→ (q, enc(mi, sk), {x1, ..., xn, xn+1})

The protocol expects to receive a couple as input, and will output either the left message or
∼=O P2 then captures the fact that an attacker
the right message using some secret key. P1
with oracle O has a negligible probability to win the IND-CPA game.

By construction, indistinguishability is compatible with our constructions for protocols in
parallel and multiple protocol oracles. Indeed the oracle protocol for P (cid:107)Q behaves exactly the
same as the two oracle OP and OQ in parallel.

Lemma 4. For protocols P, Q, A, B, an oracle O, and a list Ol of protocol oracles,

AO,O(A(cid:107)P )?(B(cid:107)Q) ≺ (cid:15) ⇔ AO,Ol,OA?B,OP ?Q ≺ (cid:15)

3 Simulatability

We deﬁne a notion of “perfect” simulation, where a protocol depends on some secrets that the
attacker can only access through an oracle, and an attacker must be able to produce exactly
the same message as the protocol. This means that an attacker, given access O but not to a
set of secrets n, can completely simulate the protocol P (using O to have a partial access to
the secrets), i.e., produce exactly the same distribution of message.

Formally, given a set of names n, an oracle O and a protocol P . We say that νn.P is
O-simulatable, if there exists a PTOM AO such that for any attacker BO, the sequences of
messages produced by BO,OP has exactly the same probability distribution as the on produced
by BO interacting with AO instead of OP .

Assume that Q ∼=O R and νn.P is O-simulatable, where n contains the secrets shared by
P, Q and R. Any distinguisher against Q ∼=O R can also produce any message that would
produce P in this context, and can therefore be transformed into a distinguisher against
Q(cid:107)P ∼=O R(cid:107)P . In other terms, Q ∼=O R and νn.P is O-simulatable implies that Q(cid:107)P ∼= R(cid:107)P .

13

3.1 Protocol Simulation

The goal in the rest of the paper is to use this notion of simulatability to obtain composability
results. Suppose one wants to prove P (cid:107)Q ∼= P (cid:107)R, knowing that Q ∼=O R and P is O-
simulatable. The way to obtain a distinguisher for Q ∼=O R from one on P (cid:107)Q ∼= P (cid:107)R is to
“push” the (simulated version) of P within the distinguisher. A protocol P is then simulatable
if there exists a simulator AO that can be “pushed “ in any distinguisher D. We formalize this
construction below, where a protocol is simulatable if and only if any distinguisher D behaves
in the same way if the protocol oracle OP is replaced by its simulator AO. We deﬁne formally
D[AO]O the replacement of OP in DO,OP .

Deﬁnition 5. Given an oracle O, a cryptographic library Mf , a protocol P , PTOMs DO,OP (ρrD , 1η)
and AO(· · · , 1η), we deﬁne D[AO]O(ρr, 1η) as the PTOM that:

1. Splits its random tape ρr into ρr1, ρr2

2. Simulates DO,OP (ρr2, 1η) by replacing every call to OP with a computation of AO: each
time D enters a state corresponding to a call to OP , D[AO] appends the query m to a
history θ (initially empty), executes the subroutine AO(ρs,ρO)(ρr1, θ, 1η) and behaves as
if the result of the subroutine was the oracle reply.

3. Preﬁxes each random handle of an oracle call of D with 0 and random handle of an

oracle call of A with 1.

4. Outputs the ﬁnal result of D.

D[AO]O must simulate AO and D so that they do not share randomness. To this end,
D[AO]O ﬁrst splits its random tape ρr into ρr1
(playing the
role of ρD). The oracle queries are preﬁxed by distinct handles for the same reason. DO,OP
has access to the shared secrets via both O and OP , while D[AO]O only has access to them
through the oracle O . Remark that if AO and DO,OP has a run-time polynomially bounded,
so does D[AO]O.

(playing the role of ρO) and ρr2

To deﬁne the central notion of O-simulatability, the distribution produced by any distin-
guisher interacting with the simulator must be the same as the distribution produced when it
is interacting with the protocol. However, as we are considering a set of shared secrets n that
might be used by other protocols, we need to ensure this equality of distributions for any ﬁxed
concrete value v of the shared secrets. Then, even if given access to other protocols using the
shared secrets, no adversary may distinguish the protocol from its simulated version.

Deﬁnition 6. Given an oracle O with support n, a cryptographic library Mf , a protocol P ,
a sequence of names n, then, νn.P is O-simulatable if and only if there exists a PTOM AO
P
such that for every PTOM DO,OP , for every η, every v ∈ ({0, 1}η)|n|, c ∈ {0, 1}(cid:63),

Pρs,ρr,ρO {DO,OP (ρr, 1η) = c | [[n]]η

ρs = v}

= Pρs,ρr,ρO {D[AO

P ]O(ρr, 1η) = c | [[n]]η

ρs = v}

Note that our deﬁnition of simulatability is a very strong one as it requires a perfect
equality of distributions, as opposed to computational indistinguishability. This is intuitively
what we want: O-simulation expresses that P only uses the secrets in n as O does. This
notion is not intended to capture any security property.

14

P ]O,OQ and D[AO

In practice, let us consider the security property P (cid:107)Q ∼= P (cid:107)Q(cid:48), where P is simulatable
by AO
. The idea of the later composition result is that an attacker D that distinguishes
P
between DO,OP ,OQ and DO,OP ,OQ(cid:48) can be turned into an attacker that distinguishes between
P ]O,OQ(cid:48) . Notice that here, Q and P may share some secrets, and their
D[AO
distributions are not independent. The intuition is that Q is ﬁxing a speciﬁc value for the
shared name between P and Q, and P then needs to be simulatable for this ﬁxed value. This
is why the notion of simulatability asks that a protocol is simulatable for any ﬁxed value of
a set of secret names. The formalization of this proof technique is given by the following
Proposition.

Proposition 7. Given an oracle O with support n, a cryptographic library Mf , protocols P, Q
such that N (P ) ∩ N (Q) ⊆ n, then, for any PTOM AO
P if and
only if for every PTOM DO,OP ,OQ, for every η, every v ∈ ({0, 1}η)|n|, c ∈ {0, 1}(cid:63),
Pρs,ρr,ρO {DO,OP ,OQ(ρr, 1η) = c | [[n]]η

P , νn.P is O-simulatable with AO

ρs = v}

= Pρs,ρr,ρO {D[AO

P ]O,OQ(ρr, 1η) = c | [[n]]η

ρs = v}

It then implies that:

Pρs,ρr,ρO {DO,OP ,OQ(ρr, 1η) = c} = Pρs,ρr,ρO {D[AO

P ]O,OQ(ρr, 1η) = c}

While this Deﬁnition intuitively captures the proof technique used to allow composition, it
does not provide insight about how to prove the simulatability. Another equivalent deﬁnition
states that a protocol is simulatable if there exists a simulator that can produce exactly the
same distribution of messages as the protocol interacting with any attacker. We formalize in
the following this second Deﬁnition, and prove that the two Deﬁnitions are equivalent, which
also yields the proof of Proposition 7.

For this second Deﬁnition of simulation to be realizable, we need to ensure that simulator’s
oracle calls and attacker’s oracle calls use a disjoint set of random coins for the oracle random-
ness. We thus assume, w.l.o.g., that the random handles r of simulator’s queries are preﬁxed
by 1. This ensures that, as long as adversaries only make oracle calls preﬁxed by 0 (this
can be assumed w.l.o.g. since it only constrains the part of the oracle’s random tape where
the randomness is drawn) the oracle randomness used by the simulator is not used by the
adversary. We provide later in Example 3.2 a complete example illustrating both simulation
and the need of the preﬁx and a formal deﬁnition of preﬁxed models.

Deﬁnition 8. Given a cryptographic library Mf , a sequence of names n, an oracle O and
a protocol P , we say that νn.P is O-simulatable if the support of O is n and there is a
PTOM AO (using random handles preﬁxed by 0) such that, for every c ∈ {0, 1}(cid:63), for every
v ∈ ({0, 1}η)|n|, for every m ≥ 1, for every PTOM BO (using random handles preﬁxed by 1),

Pρs,ρr1 ,ρr2 ,ρO {AO(ρs,ρO)(ρr1, θ1

= Pρs,ρr1 ,ρr2 ,ρO {OP (ρs, θ2

m, 1η) = c | [[n]]η
m) = c | [[n]]η

ρs = v}
ρs = v}

where

φ2
k+1 = φ2
φ1
k+1 = φ1
k+1 = θi
θi

k, OP (ρs, θ2
k)
k, AO(ρs,ρO)(ρr1, θ1
k, BO(ρs,ρO)(ρr2, η, φi

k, η)

k+1)

for 0 ≤ k < m and φ0 = ∅, θ0 = BO(ρs,ρO)(ρr2, η, ∅).

15

The machine AO can be seen as the simulator, while B is an adversary that computes the
inputs: the deﬁnition states that there is a simulator, independently of the adversary. We
asks for equality of distributions, between the sequence of messages θ2, corresponding to the
interactions of BO with OP , and the sequence of messages θ1, corresponding to the interactions
of BO with AO.

Note that our deﬁnition of simulatability is a very strong one as it requires a perfect
equality of distributions, as opposed to computational indistinguishability. This is intuitively
what we want: O-simulation expresses that P only uses the shared secrets as O does. This
notion is not intended to capture any security property.

The two deﬁnitions are indeed equivalent. To prove this, a ﬁrst technical Lemma is re-
quired. It shows that O-simulation, whose deﬁnition implies the identical distributions of two
messages produced either by the simulator or by the oracle, implies the equality of distributions
of message sequences produced by either the oracle or the simulator. It is proved essentially
via an induction on the length of the sequence of messages. For any sequence of names n and
parameter η, we denote Dη
n = {[[n]]η
ρs|ρs ∈ {0, 1}ω} the set of possible interpretations of n. We
reuse the notations of Deﬁnition 8.

Lemma 9. Given a cryptographic library Mf , a sequence of names n, an oracle O with support
n and a protocol P , that is O-simulatable with AO, we have, for every x, y, c, r2, rB ∈ {0, 1}(cid:63),
every v ∈ Dη
n, for every m ≥ 1, for every PTOM BO (using tags preﬁxed by 1):

Pρs,ρr1 ,ρr2 ,ρO {θ1

m = x, φ1
= Pρs,ρr1 ,ρr2 ,ρO {θ2

m = y| [[n]]η
m = x, φ2

ρs = v, ρB
m = y| [[n]]η

O = rB, ρr2 = r2}
ρs = v, ρB

O = rB, ρr2 = r2}

where we split ρO into ρA

O (cid:93) ρB

O such that O called by B only accesses ρB

O and O called by

A only accesses ρA

O (which is possible thanks to the distinct preﬁxes).

We now prove that Deﬁnition 8 implies Deﬁnition 5, i.e that the simulatability implies

that we can replace a protocol oracle by its simulator.

Lemma 10. Given an oracle O (with support n), a cryptographic library Mf , a sequence of
names n , P, Q protocols, such that νn.P is O-simulatable in the sense of Deﬁnition 8 with
P and N (P ) ∩ N (Q) ⊆ n then, for every PTOM DO,OP ,OQ (preﬁxed by 1), every η, every
AO
v ∈ Dη

n and every c ∈ {0, 1}(cid:63),

Pρs,ρr,ρO {DO,OP ,OQ(ρr, 1η) = c | [[n]]η

ρs = v}

= Pρs,ρr,ρO {D[AO

P ]O,OQ(ρr, 1η) = c | [[n]]η

ρs = v}

The idea is to use the deﬁnition of O-simulatability, using a PTOM BO that behaves exactly
as D when it computes the next oracle queries from the previous answers. The diﬃculty is
that D may call the oracle OQ, while B has no access to this oracle. We know however that
shared names are included in n, whose sampling can be ﬁxed at once (thanks to the deﬁnition
of O-simulation). The other randomness in Q can be drawn by B from ρr, without changing
the distribution of OQ’s replies.

Proof. Fix η and the interpretation [[n]]η

ρs = v.

Given D, we let Dm be the machine that behaves as D, however halting after m calls to
OP (or when D halts if this occurs before the mth call) and returning the last query to OP .

16

We have that Dm ﬁrst executes Dm−1, then performs the oracle call OP (ρs, θm−1), getting
um−1 and performs the computation of the next oracle call vm (if D makes another oracle call),
updates the history θm := (v1, . . . , vm) and returns vm if there is one or the output of D oth-
erwise. Dm[AO
P ] ﬁrst executes Dm−1[AO
P ], then performs the computation AO
m−1)
of u(cid:48)
m) and
(if one is performed), updates θ(cid:48)
, computes the next oracle call v(cid:48)
m
m
outputs either vm of the output of D.

P (Mf , ρr1, θ(cid:48)
1, . . . , v(cid:48)

m := (v(cid:48)

We wish to use the deﬁnition of O-simulation in order to conclude. However, we cannot

directly use the O-simulation, as D has access to an extra oracle OQ.

Part 1

We ﬁrst prove that, assuming AO
P

is a simulator of OP :

Pρs,ρr,ρO {DO,OP (ρr, 1η) = c} = Pρs,ρr,ρO {D[AO

P ]O(ρr, 1η) = c}

This is a straightforward consequence of Lemma 9. Writing respectively p1
c} and p2

P ]O(ρr, 1η) = c}, Using ρr1, ρr2

1(c) = Pρs,ρr,ρO {D[AO

as in Deﬁnition 5, we have

1(c) = Pρs,ρr,ρO {DO,OP (ρr, 1η) =

p1
1(c) =

p2
1(c) =

(cid:88)

rB,r2

(cid:88)

rB,r2

Pρs,ρr,ρO {DO,OP (ρr, 1η) = c | ([[n]]η

ρs, ρB

O, ρr2) = (v, rB, r2)}

×Pρs,ρr,ρO {([[n]]η

ρs, ρB

O, ρr2) = (v, rB, r2)}

Pρs,ρr,ρO {D[AO

P ]O(ρr, 1η) = c| ([[n]]η

ρs, ρB

O, ρr2) = (v, rB, r2)}

×Pρs,ρr,ρO {[[n]]η

ρs = v, ρB

O = rB, ρr2 = r2}

2(rB, r2, ¯v, c) = Pρs,ρr,ρO {DO,OP (ρr, 1η) = c| ([[n]]η
p1

ρs, ρB

O, ρr2) = (v, rB, r2)}

We let

and

2(rB, r2, ¯v, c) = Pρs,ρr,ρO {D[AO
p2

P ]O(ρr, 1η) = c| ([[n]]η

ρs, ρB

O, ρr2) = (v, rB, r2)}

We use Deﬁnition 8 with BO(ρr2, η, φ) as the machine that simulates Dm for m = |φ| and
using φ instead of querying the oracle. Let us deﬁne φi
for i = 1, 2 as in Deﬁnition 8.
m
Note that with the deﬁnition of D, B uses preﬁxes for oracle calls, disjoint from those used
be the last
in AP , hence randomness used for oracle calls in A and B are disjoint. Let vi
m
message of θi
. Choosing m such
m
that D makes less than m oracle calls, we have

. By deﬁnition of D and B we have v1

m = vm and v2

m = v(cid:48)
m

, θi
m

2(rB, r2, ¯v, c) = (cid:80)
pi

¯x s.t. xm=c,¯y

Pρs,ρr1 ,ρr2 ,ρO {θi

m = x, φi

m = y| ([[n]]η

ρs, ρB

O, ρr2) = (v, rB, r2)}.

Lemma 9 yields for all rB, r2, c that p2

2(rB, r2, c) = p1

2(rB, r2, c), which concludes part 1.

Part 2

We now prove that:

∀D. Pρs,ρr,ρO {DO,OP (ρr, 1η) = c} = Pρs,ρr,ρO {D[AO

P ]O(ρr, 1η) = c}

⇒

(1)

∀D. Pρs,ρr,ρO {DO,OP ,OQ(ρr, 1η) = c} = Pρs,ρr,ρO {D[AO

P ]O,OQ(ρr, 1η) = c}

17

We are thus going to show that, with the interpretation of n ﬁxed, we can simulate OQ in
some D(cid:48) by sampling in ρr instead of ρs. However, both computations of OP and OQ depend
on ρs. This is where we need the assumptions that n contains the shared secrets between P
and Q, as well as the splitting of ρr.

For any machine MO,OQ, we let [M]O
n

be the machine that executes M, simulating OQ
for a ﬁxed value v of n. The machine samples the names appearing in Q and not in n and
hard codes the interpretation of n.

More precisely, we write OQ(ρs, θ) := OQ((ρs0, ρs1, ρs2), θ) where ρs0
for the sampling of other names in Q, and ρs2
n (ρr, 1η) is the machine that:

pling of n, ρs1
Then [M]O

for the reminder.

is used for the sam-

• Splits ρr into two inﬁnite and disjoints ρsQ, ρrM and initializes an extra tape θ to zero.

• Simulates M(ρrM , 1η) but every time M calls OQ with input u, the machine adds u to

θ, and produces the output of OQ((v, ρrQ, 0), θ).

Such a machine runs in deterministic polynomial time (w.r.t. η). For any machine MO,OQ,OP ,
we similarly deﬁne [M]O,OP
. Now, we have that, for any c, by letting, for any X and U ,
X (U ) := PX {U = c | [[n]]η
Pc,v

ρs = v}:

n

Pc,v
ρs,ρr,ρO (DO,OP (ρs0 ,ρs1 ,ρs2 ),OQ(ρs0 ,ρs1 ,ρs2 )(ρr, 1η))
=1 Pc,v
=2 Pc,v
=3 Pc,v
=4 Pc,v
=5 Pc,v

ρs,ρr,ρO (DO,OP (ρs0 ,ρs1 ,ρs2 ),OQ(ρs0 ,ρs1 ,0)(ρr, 1η))
ρs1 ,ρs2 ,ρr,ρO (DO,OP (ρs0 ,0,ρs2 ),OQ(ρs0 ,ρs1 ,0)(ρr, 1η))
ρs1 ,ρs2 ,ρr,ρO (DO,OP (v,0,ρs2 ),OQ(v,ρs1 ,0)(ρr, 1η))
ρsQ,ρs,ρrD,ρO (DO,OP (v,0,ρs),OQ(v,ρsQ,0)(ρr, 1η))
ρs,ρr,ρO ([D]O,OP (ρs)

(ρr, 1η)) (ii)

n

Since

1. OQ does not access ρs2

2. OP does not access ρs1
3. We are sampling under the assumption that [[n]]η

ρs = v, i.e., ρs0

is equal to v.

4. Renaming of tapes

5. By construction

And we also have similarly that, for any c:

Pρs,ρr,ρO {D[AO
= Pρs,ρr,ρO {[D[AO

P ]O,OQ(ρr, 1η) = c | [[n]]η
v (ρr, 1η) = c | [[n]]η

P ]]O

ρs = v}
ρs = v} (iii)

By applying the left-handside of (1) to [D]O,OP (ρs)
v (ρr, 1η), and using
(ii) and (iii), we can conclude by transitivity. We conclude the proof of the lemma by putting
Part 1 and Part 2 together.

(ρr, 1η) and [D[AO

P ]j]O

n

We now prove the converse direction.

18

Lemma 11. Given an oracle O with support n, a cryptographic library Mf , protocols P, Q
such that N (P ) ∩ N (Q) ⊂ n, if there is a PTOM AO
P such that, for every PTOM DO,OP ,OQ,
for every η, every v ∈ Dη

n and every c ∈ {0, 1}(cid:63),

Pρs,ρr,ρO {DO,OP ,OQ(ρr, 1η) = c | [[n]]η

ρs = v}

= Pρs,ρr,ρO {D[AO

P ]O,OQ(ρr, 1η) = c | [[n]]η

ρs = v}

then νn.P is O-simulatable.

Proof. Let B be a PTOM, η, an interpretation v ∈ Dη
and m ∈ N , we must prove that the
n
output distribution of B will be the same whether it interacts m-th time with AO
or OP .
P
We deﬁne D as follows. For i := 0 to m − 1, D computes wi := B(α1, . . . , αi). Then D calls
OP with wi and let αi+1 be the reply. D ﬁnally outputs αm. We denote by w(cid:48)
the
i
corresponding values for D[AO

and α(cid:48)
i

P ]O,OQ

Let us denote

k+1 = φ1
φ1
k+1 = θi
θi
for 0 ≤ k < m and φ0 = θ0 = ∅.

We have by construction of D for any c:

k, OP (ρs, θ2
k+1 = φ2
φ2
k)
k, AO(ρs,ρO)(Mf , ρr1, θ1
k, BO(ρs,ρO)(Mf , ρr2, η, φi
k)

k, η)

Pρs,ρr1 ,ρr2 ,ρO {wm = c | [[n]]η

ρs = v} = Pρs,ρr1 ,ρr2 ,ρO {OP (ρs, θ2

m) = c | [[n]]η

ρs = v}

and

Pρs,ρr1 ,ρr2 ,ρO {w(cid:48)

m = c | [[n]]η

ρs = v} = Pρs,ρr1 ,ρr2 ,ρO {AO(ρs,ρO)(Mf , ρr1, θ1

m, η) = c | [[n]]η

ρs = v}

The hypothesis gives us that :

Pρs,ρr1 ,ρr2 ,ρO {wm = c | [[n]]η

ρs = v} = Pρs,ρr1 ,ρr2 ,ρO {w(cid:48)

m = c | [[n]]η

ρs = v}

So we conclude that:

Pρs,ρr1 ,ρr2 ,ρO {AO(ρs,ρO)(Mf , ρr1, θ1
= Pρs,ρr1 ,ρr2 ,ρO {OP (ρs, θ2

m, η) = c | [[n]]η
ρs = v}

m) = c | [[n]]η

ρs = v}

We can ﬁnally conclude, as Lemmas 10 and 11 directly yields that Deﬁnition 8 is equivalent

to Deﬁnition 8 simply by taking Q as the empty protocol.

Example 3.1. We ﬁx ﬁrst Mf (in an arbitrary way). We consider the following handshake
protocol, in which n, r, k, r(cid:48) are names:

A := in (cA, x0).out(cA, enc(n, r, k)). in (cA, x).

if dec(x, k) = (cid:104)n, 1(cid:105) then out(cA, ok)

(cid:107) B := in (cB, y).out(cB, enc((cid:104)dec(y, k), 1(cid:105) , r(cid:48), k))

We consider the oracle Oenc,dec

that, when receiving (cid:104)t, m(cid:105) as input, answers enc(m, ro, k)
if t = "enc", and dec(m, l) if t = "dec" (the oracle actually also expects an handle for
the secret key and a tag to specify where to sample ro). We can easily prove that νk.A is

k

19

k

Oenc,dec
-simulatable, as the attacker can sample an arbitrary n(cid:48), use the oracle to compute
enc(n(cid:48), ro, k) (which has the same distribution as enc(n(cid:48), r, k) for any ﬁxed value of k) with
the request (cid:104)"enc", n(cid:105), and dec(x, k) with the request (cid:104)"dec", x(cid:105).

Intuitively, the shared secret k is only used in A in ways that are directly simulatable with

the oracle, and A is thus O-simulatable.

Thanks to the more intuitive Deﬁnition of simulatability (cf. Deﬁnition 8 for details),
proving simulatability is in practice a syntactic veriﬁcation. With Oenc,dec
from the previous
example, νk.P is O-simulatable for any P where all occurrences of k occurs at key position,
and all encryptions use fresh randoms.

k

Let us explain why the previous examples illustrate the need for preﬁxed models.

Example 3.2. We take a more formal view on Example 3.1.

Let O be the encryption-decryption oracle: it expects an input (cid:104)"dec", m(cid:105) or (cid:104)"enc", m(cid:105),
a key s = 1 (only one encryption key is considered), an input tag t and a security parameter
η and returns

• enc(m, r, k) if the query is preﬁxed by "enc", k is the secret value extracted from ρs
corresponding to the key 1, r is drawn from ρO and associated with the tag t (via e1).

• dec(m, k) if the query is preﬁxed by "dec", k is the secret value extracted from ρs

corresponding to the key 1

• an error message otherwise (either the primitives fail or the query does not have the

expected format).

The goal is to show that νk.A is O-simulatable. (So, here, B is useless, and we let P be

A).

OP is then deﬁned as follows:

• On input w1, with an empty history, it outputs [[enc(n, r, k)]]η
ρs

history tape.

and writes w1 on the

• On input w2 with a non empty history tape,
and an error otherwise.

[[(cid:104)n, 1(cid:105)]]η
ρs

it outputs ok if [[dec(x, k)]]η,x(cid:55)→w2

ρs

=

The machine AO(ρr1, θ, η) is then deﬁned as follows:

• If θ = {m1}

1. A draws α (for the value of n) from ρr1
2. calls O with ((cid:104)"enc", α(cid:105) , 1, t) and gets back the bitstring [[enc(n, r, z)]]η,z(cid:55)→[[k]]η
.
ρs
The interpretation of k is indeed ﬁxed at once since it belongs to the “shared”
names bounded by ν.

and draws t from ρr1

ρr1 ,ρO

3. outputs [[enc(x, r, z)]]η,x(cid:55)→α,z(cid:55)→[[k]]η

ρs

ρr1

• If θ = (m1, m2),

1. calls O with ((cid:104)"dec", m2(cid:105) , 1, −) and gets back the bitstring w = [[dec(y, z)]]y(cid:55)→m2,z(cid:55)→[[k]]η

ρs

or an error message.

20

2. checks whether w = [[(cid:104)n, 1(cid:105)]]η

ρr1

. If it is the case, then outputs ok.

Now, consider an arbitrary PTOM BO.

• φ1

1 = [[enc(n, x, k)]]η,x(cid:55)→s1
where s1 is the randomness used by O when queried with [[t]]ρr1
(note: we will see that it does matter to be very precise here; we cannot simply claim
that the value of x is just a randomness drawn by O).

ρr1

• φ2

• θ1

1 = [[enc(n, r, k)]]η
ρs
i = wi, an arbitrary bitstring, computed by BO using the oracle O, φ1
i
tape ρr2

.

and the random

• φ1

1, ok if
2 = φ1
[[dec(y, z)]]y(cid:55)→w1,z(cid:55)→[[k]]η
otherwise

ρs = [[(cid:104)n, 1(cid:105)]]η

ρr1

and an error

• φ2

2 = φ2

1, ok if [[dec(x, k)]]η,x(cid:55)→w2
A O-simulates νk.P iﬀ, for every v = [[k]]ρs

= [[(cid:104)n, 1(cid:105)]]η
ρs

ρs

,

and an error otherwise

Pρs,ρr1,ρr2 ,ρO {[[dec(y, z)]]y(cid:55)→w1,z(cid:55)→v = [[(cid:104)n, 1(cid:105)]]η
}
ρr1
= [[(cid:104)n, 1(cid:105)]]η
ρs}

= Pρs,ρr1 ,ρr2,ρO {[[dec(x, k)]]η,x(cid:55)→w2

ρs

First, the distributions of φ1
1

and φ2
1

depends on ρs only. The distributions of φ1
Now the distributions w1 = BO(φ1

are identical. φ1
depends on ρr1
1
and φ2
1, [[(cid:104)n, 1(cid:105)]]ρs
1, [[(cid:104)n, 1(cid:105)]]ρr1
and w2 = BO(φ1
1, ρr2), [[(cid:104)n, 1(cid:105)]]ρr1

are
. This is
equal if the randomness used by B are disjoint from the random coins used in φ1
why there is an assumption that ρr1
and ρr2
are disjoint and why it should be the case that
the random coins used in the oracle queries of B are distinct from the ones used in the oracle
queries of A. This can be ensured by the disjointness of tags used by A and B respectively.
With these assumptions, we get the identity of the distributions of dec(w1, v), [[(cid:104)n, 1(cid:105)]]ρs

are also identical.
2, ρr2), [[(cid:104)n, 1(cid:105)]]ρs
1, φ2
1

and ρO, while φ2
1

and dec(w2, v), [[(cid:104)n, 1(cid:105)]]ρs

, hence the desired result.

Without these assumptions (for instance non-disjointness of tags used by B, A), B can
query O with a random input and a random tag, say n(cid:48), t(cid:48). As above, we let s1 be the random
value drawn by O corresponding to the tag t(cid:48). Then P{[[n]]ρs = n(cid:48) ∧ [[r]]ρs = s1} = 1
22η while

P{[[n]]ρr1

= n(cid:48) ∧ [[r]]ρr1

= s1} = 1
= 1
= 1

2η P{[[t]]ρr1
2η + 2η−1
2η × ( 1
22η (2 − 1
2η )

= [[t(cid:48)]]ρr2
∨ ([[t]]ρr1
2η × 1
2η )

(cid:54)= [[t(cid:48)]]ρr2

∧ [[r]]ρr1

= [[r(cid:48)]]ρO )}

In other words, the collision is more likely to occur since it can result from either a collision
in the tags or a collision in the randomness corresponding to diﬀerent tags.

As demonstrated in the previous example, it is necessary to assume that oracle random-
ness used by the simulator queries and the attacker queries are disjoint. The simplest way
of ensuring this is to force all tags of oracle calls to be preﬁxed. We show here that this
assumption can be made without loss of generality.

21

Deﬁnition 12. Given a PTOM AO and a constant c. We deﬁne AO
as a copy of A,
except that all calls to the oracle of the form w, r, s are replaced with calls of the form w, c·r, s,
where the · denotes the concatenation of bitstrings.

pref −c

The following lemma shows that we can, w.l.o.g., consider models, in which the tags are

preﬁxed.

Lemma 13. For any non-empty constant c and any PTOM AO, we haves

Pρs,ρr,ρO {AO(ρs,ρO)(ρr, 1η) = 1} = Pρs,ρr,ρO {AO(ρs,ρO)

pref −c (ρr, 1η) = 1}

Proof. We ﬁx a constant c, for any oracle O (with functions n, e1, e2), we deﬁne Opref −c (with
mapping function n(cid:48), e(cid:48)

) the copy of O such that:

1, e(cid:48)
2

n(cid:48)(w, s, r) = n(w, s, c|r)
n is injective by deﬁnition, so n(cid:48) is injective too. For any v ∈ {0, 1}η, as all extractions of e1
are unique for each value of n and their length only depends on η, we have for any w, r, s

PρO {e1(n(w, s, r), η, ρO) = v} = PρO {e(cid:48)

1(n(cid:48)(w, s, r), η, ρO) = v}

This implies that for any input, O and Opref −c will produce the same output distribution.
So AO and AOpref −c will produce the same distributions for any input. We conclude by
remarking that AOpref −c and AO

behaves the same by construction.

pref −c

An immediate consequence of this Lemma is that for all indistinguishability results, we

can, w.l.o.g., constrain attackers to only use preﬁxed oracle calls.

In particular it implies equivalence between indistinguishability in a computational model

and indistinguishability for preﬁxed distinguishers in the preﬁxed computational model.

Thanks to the previous Deﬁnitions, simulatability is stable under composition operators.
This is an important feature of the notion of simulatability, as it allows to reduce the simulation
of large processes to the simulation of simpler processes.

Theorem 1. Given an oracle O, protocols P, Q, and n = N (P ) ∩ N (Q), if

• νn.P is O-simulatable

• νn.Q is O-simulatable

Then νn.P (cid:107)Q and νn.P ; Q are O-simulatable.
Proof. Let D be an arbitrary PTOM. By Lemma 10, there is a machine AO
P
Pρs,ρr,ρO {DO,OP ,OQ(ρr, 1η) = c | [[n]]η

ρs = v}

= Pρs,ρr,ρO {D[AO

P ]O,OQ(ρr, 1η) = c | [[n]]η

ρs = v}

s.t.

Applying once more the Lemma 10, there is a machine AO
Q

s. t., for every c ∈ {0, 1}(cid:63),

Pρs,ρr,ρO {DO,OP ,OQ(ρr, 1η) = c | [[n]]η

ρs = v}

P ][AO

= Pρs,ρr,ρO {D[AO

Q]O(ρr, 1η) = c | [[n]]η

ρs = v}
P (cid:107)Q(Mf , ρr1, θ, 1η, m) as the machine that behaves as AO

We deﬁne AO
P (Mf , ρr1,P , θP , 1η, m)
(resp. AO
Q(Mf , ρr1,Q, θQ, m)) if m is a message supposed to be handled by P (resp. by Q)
(use of action determinism) Then the result is appended to θP (resp. θQ). This assumes (this
is an invariant) that θ can be split into θP and θQ.
P ][AO

P (cid:107)Q]O. Then we use Lemma 11 to conclude.

We note that D[AO

Q]O = D[AO

22

Alternative notions of simulatability We discuss here some variation on our notion of
simulatability. First, let us note that our notion of simulatability assumes that models are
preﬁxed. As demonstrated previously this is necessary in order to get an achievable notion of
simulatability. We will therefore not consider models that are not preﬁxed. We may consider
variants of simulatability, depending on the order of the quantiﬁers and sharing of randomness
between simulator and distinguisher. We deﬁne simulatability as the existence of a simulator
that works for all distinguishers. In other words our ordering of quantiﬁer is:

∃AO(ρr1)∀D(ρr2)

In a preﬁxed model, we believe that switching the quantiﬁers lead to the same notion:

∃AO(ρr1)∀D(ρr2) ⇔ ∀D(ρr2)∃AO(ρr1)

We provide no proof, but the intuition is that there exists a “universal” distinguisher, namely
the PTOM D, which performs any possible queries with uniform probability. Now, consid-
ering any other distinguisher D(cid:48), as the simulator AO for D has to provide the exact same
distribution as the protocol for each query of D, as D performs all possible queries (with very
small probability), AO will also be a correct simulator for D(cid:48).

Another alternative is to allow the simulator and the distinguisher to share the same
randomness. Then, ∃AO(ρr)∀D(ρr) seems to provide an unachievable deﬁnition. Indeed, if
the simulator is not allowed to use private randomness while the protocol is, the simulator
cannot mimic the probabilistic behavior of the protocol.

The last possibility however seems to oﬀer an alternative deﬁnition for simulatability:

∀D(ρr)∃AO(ρr)

This seems to be a weaker deﬁnition than ours as the choices of the simulator can depend on
the ones of the distinguisher. It may simplify (slightly) the proofs for the main theorem, but
it would create issues for the unbounded replication as it would break uniformity of reductions
(since the runtime of the simulator may now depend on the environment it is running in).

3.2 Generic Oracles for Tagged Protocols

In order for our deﬁnition of simulatability to be useful, the design of oracles is a key point.
They need to be:

1. generic/simple, yet powerful enough so that protocols can be easily shown to be simu-

latable,

2. restrictive enough so that proving protocols in the presence of oracles is doable.

We provide here with examples of such oracles, namely generic tagged oracles for signature,
that will be parameterized by arbitrary functions, together with security properties that are
still true in the presence of tagged oracles.

In practice, protocols that use some shared secrets use tags, for instance string preﬁxes,
to ensure that messages meant for one of the protocol cannot be confused with messages
meant for the other one. These tags can ensure what is called “domain separation” of the two
protocols, ensuring that the messages obtained from one cannot interfere with the security of
the second protocol. These tags can be explicit, for instance by adding a ﬁxed constant to

23

the messages, or implicit, where each message of a protocol depend on some fresh randomness
that can be used to deﬁne some kind of session identiﬁer.

We deﬁne generic oracles for decryption and signatures, parameterized by an abstract
tagging function T and a secret key sk, that allow to perform a cryptographic operation with
the key sk, on any message m satisfying T (m). T can then simply check the presence of a
preﬁx, or realize some implicit tagging, checking that the message depends on the randomness
used by a speciﬁc session.

After deﬁning those generic oracles, we deﬁne generic axioms, parameterized by T , that
allow to perform proofs against attackers with access to the oracle. The generic axiom for
signatures (or any other primitive) are implied by the classical cryptographic axioms.

We see tagging as a boolean function T computable in polynomial time over the inter-
pretation of messages. For instance, if the messages of protocol P are all preﬁxed with the
identiﬁer idP , T is expressed as T (m) := ∃x.m = (cid:104)idP , x(cid:105). In a real life protocol, idP could
for instance contain the name and version of the protocol.

Intuitively tagged oracles produce the signature of any properly tagged message and allow

to simulate P .

With these oracles, an immediate consequence of the composition Theorems found in
Section 4 is the classical result that if two protocols tag their messages diﬀerently, they can be
safely composed [28]. Note that as our tag checking function is an arbitrary boolean function:
tagging can be implicit, as illustrated in our applications in Section 6.

As an example, we provide two oracles, one for encryption and one for signing, that allow

to simulate any protocol that only produces messages that are well tagged for T .

Deﬁnition 14. Given a name sk and a tagging function T , we deﬁne the generic signing
oracle Osign
T,sk

and the generic decryption oracle Odec
T,sk

as follows:

Osign

T,sk (m) := if T (m) then

output(sign(m, sk))

Odec

T,sk(m) := if T (dec(m, sk)) then
output(dec(m, sk))

Any well-tagged protocol according to T , i.e., a protocol that only decrypts or signs well
tagged messages, will be simulatable using the previous oracles. Hence we meet the goal 1
stated at the beginning of this section, as this can be checked syntactically on a protocol. We
provide, as an example, the conditions for a tagged signature.

Example 3.3. Any protocol P whose signatures are all of the form if T (t) then sign(t, sk)
for some term t (that does not use sk) is immediately νsk.P Osign
Indeed,
T,sk
informally, all internal values of the protocol except sk can be picked by the simulator from
its own randomness, while all terms using sk can be obtained by calls to the tagged signing
oracle, as all signed terms in P are correctly tagged. Let us emphasize that the simulation
holds for any speciﬁc value of sk, as the distribution of outputs is the same, whether it is the
simulator that draws the internal names of P , except sk, or P itself.

-simulatable.

As we need to perform cryptographic proofs in the presence of oracles, it is useful to
deﬁne security properties that cannot be broken by attackers with access to these oracles
(without having to consider the speciﬁc calls made to these oracles). The games deﬁning
these properties slightly diﬀer from the classical security games. Consider the example of

24

signatures and the usual EUF-CMA game. If the attacker is, in addition, equipped with an
oracle O that signs tagged messages, they immediately win the EUF-CMA game, “forging” a
signature by a simple call to O. We thus deﬁne a tagged unforgeability game (T-EUF-CMA),
derived from the EUF-CMA game, where the adversary wins the game only if they are able
to produce the signature of a message that is not tagged.

Deﬁnition 15. A signature scheme (Sign, Vrfy) is T-EUF-CMA secure for oracle O and
interpretation of keys Ask if, for any PTOM A, the game described in Figure 3 returns true
with probability (over ρr, ρs, ρO) negligible in η.

T,sk(η, ρr, ρs, ρO):

Game EUF-CMAΣ,A
List ← []
(pk, sk) ← ([[pk]]ρs, [[sk]]ρs)
(m, σ) ← AO(ρs,ρO),Sign(pk, η, ρr)
Return ¬T (m) ∧ Vrfy(pk, m, σ) ∧ m (cid:54)∈ List

Oracle Sign(m):
List ← (m : List)
σ ← Sign(sk, m)
Return σ

Figure 3: Game for Tagged Unforgeability (T-EUF-CMA)

The main goal of the previous deﬁnition is to allow us to prove protocols in the presence
of oracles (hence composed with simulated ones), reaching the goal 2 stated at the beginning
of the section.

More precisely, one can, for instance, simply design a classical game based proof, reducing
the security of the protocol to the security of the T-EUF-CMA game rather than the classical
EUF-CMA game. This reasoning is valid as EUF-CMA implies T-EUF-CMA even in the
presence of the corresponding oracle.

Proposition 16. If a signature scheme (Sign, Vrfy) is EUF-CMA secure for keys given by
Ask, then (Sign, Vrfy) is T-EUF-CMA secure for the oracle Osign
T,sk and the interpretation of
keys Ask.

Remark that the base assumptions made about the cryptographic primitives are classi-
cal ones, and thus the ﬁnal proof of the composed protocol only depends on some classical
cryptographic hypotheses.

4 Main Composition Theorems

We distinguish between two complementary cases. First, Theorem 2 covers protocols composed
in a way where they do not share states besides the shared secrets (e.g., parallel composition
of diﬀerent protocols using the same master secret key). Second, Theorem 4 covers protocols
passing states from one to the other (e.g., a key exchange passing an ephemeral key to a
secure channel protocol). We ﬁnally extend these composition results to self-composition, i.e.,
proving the security of multiple sessions from the security of a single one or the security of a
protocol lopping on itself, for instance a key renewal protocol.

4.1 Composition without State Passing

Essentially, if two protocols P, Q are indistinguishable, they are still indistinguishable when
running in any simulatable context. The context must be simulatable for any ﬁxed values

25

of the shared names of P, Q and the context. The context can contain parallel or sequential
composition as illustrated by the following example.

Example 4.1. Let P, Q, R, S be protocols and O an oracle. Let n = N (P (cid:107)Q) ∩ N (R(cid:107)S). If
P ∼=O Q and νn.R(cid:107)S is O-simulatable, then some applications of Theorem 2 can yield

1. P (cid:107)R ∼=O Q(cid:107)R
2. R; P ∼=O R; Q
3. (R; P )(cid:107)S ∼=O (R; Q)(cid:107)S

We generalize the previous example to any simulatable context and to n protocols. For
n] a context, i.e., a protocol built using the syntax
, viewed as elementary processes. C[P1, . . . , Pn] is the

any integer n, we denote by C[_
1, . . . , _
of protocols and distinct symbols _
i
protocol in which each hole _i is replaced with Pi.

Example 4.2. In the three examples of Example 4.1, in order to apply the next theorem, we
respectively use as contexts

• C[_

• C[_

• C[_

1] := _
1(cid:107)R
1] := R; _
1
1] := (R; _

1)(cid:107)S.

In this ﬁrst Theorem, no values (e.g., ephemeral keys) are passed from the context to the
protocols. In particular, the protocols do not have free variables which may be bound by the
context.

Theorem 2. Given a cryptographic library Mf and an oracle O, let P1, . . . , Pn, Q1, . . . , Qn
be protocols and C[_1, . . . , _n] be a context such that all their channels are disjoint, 0 some
constant, n a sequence of names and c1, . . . , cn fresh channel names. If

1. N (C) ∩ N (P1, . . . , Pn, Q1, . . . , Qn) ⊆ n

2. νn.C[out(c1, 0), . . . , out(cn, 0)] is O-simulatable

3. P1(cid:107) . . . (cid:107)Pn

∼=O Q1(cid:107) . . . (cid:107)Qn

Then

C[P1, . . . , Pn] ∼=O C[Q1, . . . , Qn]
Speciﬁcally3, there exists a polynomial pS (independent of C) such that, if pC is the polynomial
bound on the runtime of the simulator for C, we have,

AdvC[P1,...,Pn]∼=OC[Q1,...,Qn](t)

≤ AdvP1(cid:107)...(cid:107)Pn∼=OQ1(cid:107)...(cid:107)Qn

(cid:16)

(cid:0)t, n, |C|, pC(t)(cid:1)(cid:17)

pS

3We provide, in this Theorem and the following ones, explicit advantages, as our constructions do not
directly allow for unbounded replication. This will later be used to ensure that the advantage of the adversary
only grows polynomially with respect to the number of sessions.

26

Note that the bound we obtain for the reduction is polynomial in the running time of
the context. We denote by C the protocol C in which each _i is replaced with out(ci, 0).0,
where ci is a channel name and 0 is a public value.
Intuitively, C abstracts out the com-
ponents Pi, only revealing which Pi is running at any time. The intuition behind the proof
∼=O C(cid:107)Q1(cid:107) . . . (cid:107)Qn
of the Theorem is then as follows. First, we show that C(cid:107)P1(cid:107) . . . (cid:107)Pn
implies C[P1, . . . , Pn] ∼=O C[Q1, . . . , Qn]. This is done by a reduction, where we mainly
have to handle the scheduling, which is possible thanks to the information leaked by C, and
the action determinism of the protocols. In a sense, this means that indistinguishability for
protocols in parallel implies indistinguishability for any scheduling of those protocols. Sec-
ondly, by simulating C thanks to Proposition 7, the two hypothesis of the Theorem imply
∼=O C(cid:107)Q1(cid:107) . . . (cid:107)Qn. The second part is where our notion of simulatability
C(cid:107)P1(cid:107) . . . (cid:107)Pn
comes into play, and where it is essential to deal carefully with the shared secrets.

For our latter results, we must actually generalize slightly this Theorem. A use case is for
instance when we want to prove that P (cid:107)Q ∼= P (cid:107)P implies that ifbthenP elseQ ∼= P for some
boolean condition b. In this case, we actually need to rename the channels used by P and Q
in the second protocol, so that both P and Q uses the same channels. We thus introduce a
renaming on channels σ that allows us to compose components in an arbitrary way.

The generalized version of the Theorem is as follows.

Theorem 3. Let C[_1, . . . , _n] be a context. Let P1, . . . , Pn, Q1, . . . , Qn be protocols, and let
σ : C(P1, . . . , Pn) (cid:55)→ C such that C(cid:107)P1(cid:107) . . . (cid:107)Pn, C(cid:107)Q1(cid:107) . . . (cid:107)Qn, C[P1σ, . . . , Pnσ], C[Q1σ, . . . , Qnσ]
are protocols. Given a cryptographic library Mf , an oracle O, if

1. n ⊇ N (C) ∩ N (P1, . . . , Pn, Q1, . . . , Qn)

2. νn.C is O-simulatable

3. P1(cid:107) . . . (cid:107)Pn

∼=O Q1(cid:107) . . . (cid:107)Qn

Then

C[P1σ, . . . , Pnσ] ∼=O C[Q1σ, . . . , Qnσ]

Speciﬁcally, there exists a polynomial pS (independent of C) such that, if pC is the polynomial
bound on the runtime of the simulator for C, we have,

AdvC[P1σ,...,Pnσ]∼=OC[Q1σ,...,Qnσ](t) ≤ AdvP1(cid:107)...(cid:107)Pn∼=OQ1(cid:107)...(cid:107)Qn

(cid:16)

(cid:0)t, n, |C|, |σ|, pC(t)(cid:1)(cid:17)

pS

Proof. Let A be an attacker against

C[P1σ, . . . , Pnσ] ∼=O C[Q1σ, . . . , Qnσ].

In the scheduling part, we ﬁrst build an attacker against

C(cid:107)P1(cid:107) . . . (cid:107)Pn

∼=O C(cid:107)Q1(cid:107) . . . (cid:107)Qn.

We then remove the context C through the O-simulatability.

27

Scheduling part Let us construct BO,OC ,OR1 ,...,ORn with either for every i, Ri = Pi, or,
for every i, Ri = Qi. BO,OC ,OR1 ,...,ORn initially sets variables c1, . . . , cn to 0 (intuitively, ci
records which processes have been triggered) and sets x to the empty list. It then simulates
AO,OC[R1σ,...,Rnσ] but, each interaction with OC[R1σ,...,Rnσ] and the corresponding request (c, m)
is replaced with:

• if there exist i such that ci = 1 and c ∈ C(Riσ) then

with (cσ−1, m)

returns ⊥, then, if contexts C1 and C2 are such that C[_

– query ORi
– if ORi
C1[_
sequential composition: an error message disables the continuation).
– else the answer (c(cid:48), m(cid:48)) is changed (c(cid:48)σ, m(cid:48)) (and the simulation goes on)

n] =
i; C2], it adds to x the channels C(C2). (This corresponds to the semantics of

1, . . . , _

• else if c ∈ C(C) and c /∈ x then

with (c, m)

– query OC
– if OC
– else continue with the reply of OC

answers (cid:62) on channel γi, set ci = 1

This new attacker is basically simply handling the scheduling of the protocols, using the
signals raised in the context to synchronize everything. The condition that there exists i such
that ci = 1 and c ∈ C(Ri) is always satisﬁed by a unique i, otherwise C[P1σ, . . . , Pnσ] or
C[Q1σ, . . . , Qnσ] would not be well formed.

The execution time of B then only depends on the number of channels in C, the size of
the channel substitution σ, the number of protocols n in addition to the cost of simulating
A. Hence if t is the runtime of A, there exists pS1
such that the runtime of B is bounded
(uniformly in C, P1, . . . , Pn, Q1, . . . Qn) by pS1(n, t, |C|, |σ|):

AdvC[P1,...,Pn]∼=C[Q1,...,Qn]

AO

(t) ≤ AdvP1(cid:107)...(cid:107)Pn∼=Q1(cid:107)...(cid:107)Qn
BO,O
C

(pS1(t, n, |C|, |σ|))

Simulatability Now, with the fact that νn.C is O-simulatable, we have a simulator AO
C
such that, thanks to Lemma 10, B[AO
]O,OR behaves exactly as BO,OC ,OR. We have, for pC
C
the polynomial bound on the runtime of AC

, by Deﬁnition 5,

AdvP1(cid:107)...(cid:107)Pn∼=Q1(cid:107)...(cid:107)Qn

BO,O
C

(t) ≤ AdvP1(cid:107)...(cid:107)Pn∼=Q1(cid:107)...(cid:107)Qn
B[AO
C

]O

(q(pC(t) + t))

and ﬁnally,

≤ AdvP1(cid:107)...(cid:107)Pn∼=Q1(cid:107)...(cid:107)Qn
]O

B[AO
C

AdvC[P1σ,...,Pnσ]∼=C[Q1σ,...,Qnσ]

(t)

AO
(q(pC ◦ pS1(n, t, |C|, |σ|) + pS1(n, t, |C|, |σ|)))

Given a protocol P and a context C, for Theorem 2 to be used, we need an oracle such

that:

1. the context C is simulatable with the oracle O,

28

2. the protocol P is secure even for an attacker with access to O (P ∼=O Q).
Our goal is to ﬁnd an oracle that is generic enough to allow for a simple proof of indis-
tinguishability of P and Q under the oracle, but still allows to simulate C. Notably, if we
take as oracle the protocol oracle corresponding to the context itself, we can trivially apply
Theorem 2 but proving P ∼=O Q amounts to proving C[P ] ∼= C[Q].

Application to tagged protocols We consider two versions of SSH, calling them SSH2
and SSH1, assuming that all messages are preﬁxed respectively with the strings “SSHv2.0”
and “SSHv1.0”. Both versions are using the same long term secret key sk for signatures. We
assume that both versions check the string preﬁx.

To prove the security of SSH2 running in the context of SSH1, we can use Theorem 2. If we
∼= I(cid:107)SSH1.

denote by I the idealized version of SSH2, the desired conclusion is SSH2(cid:107)SSH1
Letting C[_

1(cid:107)SSH1, it is then suﬃcient to ﬁnd an oracle O such that:

1] = _

1. νsk.SSH1 is O-simulatable (the simulatability of C directly follows),

2. SSH2

∼=O I

If we deﬁne the tagging function TSSH1

-
TSSH1 ,sk
simulatable (see Deﬁnition 14) as SSH1 does enforce the tagging checks. We thus let O be
Osign

that checks the preﬁx, SSH1 is trivially Osign

.

Assuming that sign veriﬁes the classical EUF-CMA axiom, by Proposition 16, it also
veriﬁes the tagged version EUF-CMATSSH1 ,sk. To conclude, it is then suﬃcient to prove that
SSH2

∼=O I with a reduction to EUF-CMATSSH1 ,sk.

TSSH1 ,sk

Application to encrypt and sign For performances considerations, keys are sometimes
used both for signing and encryption, for instance in the EMV protocol. In [29], an encryption
scheme is proven to be secure even in the presence of a signing oracle using the same key. Our
Theorem formalizes the underlying intuition, i.e.
if a protocol can be proven secure while
using this encryption scheme, it will be secure in any context where signatures with the same
key are also performed.

4.2 Composition with State Passing

In some cases, a context passes a sequence of terms to another protocol. If the sequence of
terms is indistinguishable from another one, we would like the two experiments, with either
sequences of terms, to be indistinguishable.

Example 4.3. Let us consider the protocol P (x1, x2) := in(c, x).out(c, enc(x, x1, x2)). We
assume that we have a function kdf, which, given a random input, generates a suitable key for
the encryption scheme. Let a random name seed and let C[_
.
C[(cid:107)iP (ri, sk)] provides an access to an encryption oracle for the key generated in C:

1] := let sk = kdf(seed) in _

1

C[(cid:107)iP (ri, sk)] :=

let sk = kdf(seed) in

(cid:107)i(in(c, x).out(c, enc(x, ri, sk)))

A classical example is a key exchange, used to establish a secure channel. The situation
is dual with respect to the previous theorem: contexts must be indistinguishable and the
continuation must be simulatable.

29

Theorem 4. Let C, C(cid:48) be n-ary contexts such that each hole is terminal. Let P1(x), . . . , Pn(x)
be parameterized protocols, such that channel sets are pairwise disjoint. Given a cryptographic
library Mf , an oracle O , n ⊇ N (C) ∩ N (P1, . . . , Pn), t1, . . . , tn, t(cid:48)
n sequences of terms,
(cid:101)C := C[out(c1, t1), . . . , out(cn, tn)] and (cid:101)C(cid:48) := C(cid:48)[out(c1, t(cid:48)
n)]. If
(cid:101)C(cid:107)in(c1, x).P1(x)(cid:107) . . . (cid:107)in(cn, x).Pn(x) is a protocol and:

1, . . . , t(cid:48)
1), . . . , out(cn, t(cid:48)

1. (cid:101)C ∼=O (cid:101)C(cid:48)

2. νn.in(c1, x).P1(x)(cid:107) . . . (cid:107)in(cn, x).Pn(x) is O-simulatable

then C[P1(t1), . . . , Pn(tn)] ∼=O C(cid:48)[P1(t(cid:48)
1), . . . , Pn(t(cid:48)
Speciﬁcally, there exists a polynomial pS (independent of P1, . . . , Pn) such that if pO is the
polynomial bound on the runtime of the simulator for P := in(c1, x).P1(x)(cid:107) . . . (cid:107)in(cn, x).Pn(x),
we have,

n)]

Adv C[P1(t1),...,Pn(tn)]∼=OC[P1(t(cid:48)

1),...,Pn(t(cid:48)

n)](t) ≤ Adv (cid:101)C∼=O (cid:101)C(cid:48)(cid:16)

(cid:0)t, n, |P |, pP (t)(cid:1)(cid:17)

pS

(cid:101)C is the context, in which all the bound values (for instance the key derived by a key
exchange) are outputted on distinct channels. (cid:102)C(cid:48) corresponds to the idealized version. We
can pass those bound values to another protocol P , if this protocol P can be simulated for
any possible value of the bound values.

Proof. The proof is very similar to Theorem 2.

Let us assume that we have an attacker such that

(cid:18)

Adv

A

O,O

C[P1(t1),...,Pn(tn)]?C[P1(t(cid:48)

1),...,Pn(t(cid:48)

n)]

(cid:19)

= (cid:15)0

We denote C1 = C[out(c1, t1), . . . , out(cn, tn)], C2 = C[out(c1, t(cid:48)
in(1, x).P1(x), . . . , P (cid:48)

n = in(n, x).Pn(x). We ﬁrst construct an attacker against:

1), . . . , out(cn, t(cid:48)

n)], P (cid:48)

1 =

C1(cid:107)P (cid:48)

1(cid:107) . . . (cid:107)P (cid:48)
n

∼= C2(cid:107)P (cid:48)
O,O

1(cid:107) . . . (cid:107)P (cid:48)
n

O,OD,OP (cid:48)
1

,...,OP (cid:48)

n)] but, after
Let us consider B
setting some variables d1, . . . , dn to 0 and some list x to the empty list, for every call to
OC[P1(t1),...,Pn(tn)]?C[P1(t(cid:48)

n which simulates A

of the form (c, m):

C[P1(t1),...,Pn(tn)]?C[P1(t(cid:48)

1),...,Pn(t(cid:48)

1),...,Pn(t(cid:48)

n)]

• if there exist i such that di = 1 and c ∈ C(P (cid:48)

i ) then

with (cσ−1, m)

i

– query OP (cid:48)
– if OP (cid:48)
C[_

i

terminates set ci = 0 and if it returns ⊥, then, with C and C(cid:48)(cid:48) such that

1, . . . , _

n] = C[_

i; C(cid:48)(cid:48)] it adds to x the channels C(C(cid:48)(cid:48))

– else it forwards the answer (c(cid:48), m(cid:48)) as (c(cid:48)σ, m(cid:48))

• else if c ∈ C(C1) and c /∈ x then

– queries OD with (c, m)
– if OD answers with some ti on channel i

30

∗ set di = 1
∗ sends (i, ti) to OP (cid:48)

i

and forwards the answer

– else forwards the answer of OD

With this construction, we do have

(cid:16)

B

Adv

O,OC1?C2 ,OP (cid:48)
1

,...,OP (cid:48)
n

(cid:17)

= (cid:15)0

Using Lemma 4, we get a distinguisher B(cid:48) such that:

(cid:16)

B

Adv

(cid:48)O,OC1?C2 ,OP (cid:48)

1(cid:107)...(cid:107)P (cid:48)
n

(cid:17)

= (cid:15)0

Now, with the fact that νn.P (cid:48)

1(cid:107) . . . (cid:107)P (cid:48)
n
]O,OD behaves exactly as B
such that thanks to Proposition 7, B(cid:48)[AO
P (cid:48)
1(cid:107)...(cid:107)P (cid:48)
n
(cid:17)
= (cid:15)0.
]O,OC1?C2

We ﬁnally have Adv
B(cid:48)[AO
P (cid:48)
1(cid:107)...(cid:107)P (cid:48)
n
The bound on the advantage is derived similarly to Theorem 2.

is O simulatable, we have a simulator AO
P (cid:48)
1(cid:107)...(cid:107)P (cid:48)
n
,OD .

1(cid:107)...(cid:107)P (cid:48)
n

O,OP (cid:48)

(cid:16)

When we do so, we only assume that they are all distinct. The following example shows
how Theorems 2 and 4 can be used to derive the security of one session of a key exchange
composed with a protocol.

2

1(cid:107)R; _

Example 4.4. Let us consider a key exchange I(cid:107)R where xI (resp. xR) is the key derived
by the initiator I (resp. the responder R) in case of success. We denote by KE[_
2] :=
I; _
the composition of the key exchange with two continuations; the binding of xI
(resp. xR) is passed to the protocol in sequence. Consider possible continuations P I (xI ), P R(xR)
that use the derived keys and ideal continuations (whatever “ideal” is) QI (xI ), QR(xR). We
sketch here how to prove KE[P I (xI ), P R(xR)] ∼= KE[QI (xI ), QR(xR)] (i.e., the security of
the channel established by the key exchange). This will be generalized to multi-sessions in
Section 6. We use both Theorems 2 and 4.
Assume, with a fresh name k, that:

1, _

1. Oke is an oracle allowing to simulate the key exchange

2. OP,Q allows to simulate in(cI , x).P I (x)(cid:107)in(cR, x).P R(x) and

in(cI , x).QI (x)(cid:107)in(cR, x).QR(x)
3. P I (k)(cid:107)P R(k) ∼=Oke QI (k)(cid:107)QR(k)
4. KE[out(cI , xI ), out(cR, xR)] ∼=OP,Q KE[out(cI , k), out(cR, k)]

Hypothesis 3 captures the security of the channel when executed with an ideal key, and
Hypothesis 4 captures the security of the key exchange. Both indistinguishability are for an
attacker that can simulate the other part of the protocol.
Using Theorem 2 with Hypothesis 1 and 3 yields

KE[P I (k), P R(k)] ∼= KE[QI (k), QR(k)]

31

Hypothesis 2 and 4 yield, with two applications of Theorem 4, one for P and one for Q, that
KE[P I (xI ), P R(xR)] ∼= KE[P I (k), P R(k)] and KE[QI (xI ), QR(xR)] ∼= KE[QI (k), QR(k)].
Transitivity allows us to conclude that the key exchange followed by the channel using the
produced key is indistinguishable from the key exchange followed by the ideal secure channel:

KE[P I (xI ), P R(xR)] ∼= KE[QI (xI ), QR(xR)]

In Theorem 4, the simulatability of

νn.in(cP , k); P (k)(cid:107)in(cQ, k); Q(k)

may be a requirement too strong in some applications. This issue will be raised when we
consider the forwarding agent of the SSH protocol, as detailed in Section 9.3, but we can
avoid it in this speciﬁc case. For more complex applications, it might be interesting in the
future to consider a weaker version of function applications where the produced key k always
satisﬁes a condition H(k). We could then design an oracle O so that for all names satisfying
condition H(k) we would have that P (k)(cid:107)Q(k) is O-simulatable.

4.3 Unbounded Replication

An important feature of a compositional framework is the ability to derive the security of a
multi session protocol from the analysis of a single session. To refer to multiple sessions of
a protocol, we consider that each session uses some fresh randomness that we see as a local
session identiﬁer.

The main idea behind the Theorem is that the oracle will depend on a sequence of names
of arbitrary length. This sequence of names represents the list of honest randomness sampled
by each party of the protocol, and the oracle enables simulatability of those parties.

We provide bellow the Proposition that allows to put in parallel any number of replications

of simulatable protocols.

Proposition 17. Let Or be an oracle parameterized by a sequence of names s, and O an
oracle. Let p be a sequence of names, P (x), R1
i (x, y) and Q(x) be protocols,
such that Nl(R1
i ) is disjoint of the oracle support. If we have, for sequences of names
k
1
, . . . , lsid
lsid

i , . . . , Rk
j
, with s = {lsid
i }1≤j≤k,i∈N :

i (x, y), . . . , Rk

j
1. ∀i, j ∈ N, νp, lsid
2. P (p) ∼=Or Q(p)

i .Rj

j
i ) is Or-simulatable.
i (p, lsid

3. s is disjoint of the support of O.

Then, for any integers N1, . . . , Nk:

P (p)(cid:107)i≤N1(R1

k
1
i )(cid:107) . . . (cid:107)i≤Nk Rk
i (p, lsid
i (p, lsid
i )
1
i )(cid:107) . . . (cid:107)i≤Nk Rk
i (p, lsid

∼=O,Or Q(p)(cid:107)i≤N1R1

k
i (p, lsid
i )

Speciﬁcally, there exists a polynomial pS (independent of all Rj) such that if pRj is the

polynomial bound on the runtime of the simulator for Rj, we have,

AdvP (p)(cid:107)i≤N1 (R1

i (p,lsid

≤ AdvP (p)∼=O,Or Q(p)(cid:16)

1
i )(cid:107)...(cid:107)i≤Nk Rk

i (p,lsid

k
i )∼=OQ(p)(cid:107)i≤N1 R1

i (p,lsid

1
i )(cid:107)...(cid:107)i≤Nk Rk

i (p,lsid

k

i )(t)

(cid:0)t, N1, |R1|, . . . , Nk, |Rk|, pR1(t), . . . , pRk (t)(cid:1)(cid:17)

pS

32

In the previous proposition and following applications, we talk about sequences of names
j
i }1≤j≤k,i∈N. This does not have any practical meaning and is only a
of the form s = {lsid
shortcut. In practice, we must have that the previous hypotheses hold for any polynomial p
j
i }1≤j≤k,1≤i≤p(η). We will precisely deﬁne this in Section 12.
and any sequence s = {lsid

Applying the previous Proposition with P and Q as R1 and R2, we can obtain the Theorem
for the unbounded replication of a protocol, where the number of sessions depends on the
security parameter.

Theorem 5. Let Or, O be oracles both parameterized by a sequence of names s. Let p be
a sequence of names, Pi(x, y) and Qi(x, y) be parameterized protocols, such that Nl(P, Q) is
disjoint of the oracles support.
, with s =
P
Q
i }i∈N:
i , lsid
{lsid

P
If we have, for sequences of names lsid

, lsid

Q

P
P
i ) is Or-simulatable.
i .Pi(p, lsid
1. ∀ i ≥ 1, νp, lsid

2. ∀ i ≥ 1, νp, lsid

Q
i .Qi(p, lsid

Q
i ) is Or-simulatable.

3. s is disjoint of the support of O.

P
4. P0(p, lsid

0 ) ∼=Or,O Q0(p, lsid

Q
0 )

then,

P
||iPi(p, lsid

i ) ∼=O ||iQi(p, lsid

Q
i )

To prove this result, we use the explicit advantages that can be derived from our com-
position Theorems, which increases polynomially with respect to the number of sessions, and
apply a classical hybrid argument to conclude.

In our applications (Section 6), the main idea is to ﬁrst use Theorem 5 to reduce the
multi-session security of a key exchange or a communication channel to a single session, and
then use Theorems 2 and 4 to combine the multiple key exchanges and the multiple channels.
Remark, that in practice, to express the security properties of the protocols, we need to
allow the protocols to use a predicate T (x) whose interpretation may depend on the list of
honest randomness sampled by each party of the protocol. For instance, this predicate may
be used to check whether a value received by a party corresponds to a randomness sent by
another party, and we would have T (x) := x ∈ s. The two previous Theorems are in fact also
valid in such cases, and we will use such notations in the application to key exchanges, but
we delay to Section 12 the formalization of such predicates.

5 Unbounded Sequential Replication

We replicate a sequential composition where at each occurrence, a value produced by the
protocol is transmitted to the next occurrence. This corresponds to the security of a protocol
looping on itself, as it is the case for some key renewal protocols.

Such protocols depend on an original key, and are thus parameterized process of the form
P (x). As they renew the key stored in the variable x, they rebind x to some new value and
thus contain a construct of the form let x = _ in .

33

Proposition 18. Let O be an oracle, two parameterized processes P (x), Q(x), a set of names
n = Ng(P, Q) and fresh names k0, l. We assume that Nl(P, Q) is disjoint of the support of O.
If:

• νn.in(cP , x); P (x)(cid:107)in(cQ, x); Q(x) is O-simulatable, and
• P (k0); out(cP , x)(cid:107)Q(k0); out(cQ, x) ∼=O P (k0); out(cP , l)(cid:107)Q(k0); out(cQ, l)

then, for any N,

P (k0); P (x);N ; out(cP , x)(cid:107)Q(k0); Q(x);N ; out(cQ, x)

∼=O P (k0); P (x);N ; out(cP , l)(cid:107)Q(k0); Q(x);N ; out(cQ, l)

The main idea behind the proof is to perform as many function applications (Theorem 4)
as needed, one for each replication of the protocol. Remark that compared to the previous
replication, where we considered multiple sessions of the protocol and thus a notion of local
session identiﬁer was required, here we consider a single session looping on itself, and we do
not need those identiﬁers.

Part II
Applications to Key Exchange

6 Application to Key Exchanges

Although our framework is not speciﬁcally tailored to key exchanges or any speciﬁc property,
we choose to focus here on this application. We outline how our theorems may be used to
prove the security of a protocol using a key derived by a key exchange in a compositional way.
(Let us recall that the key exchange and the protocol using the derived key may share long
term secrets).

6.1 Our Model of Key Exchange

In order to obtain injective agreement, key exchanges usually use fresh randomness for each
session as local session identiﬁers. For instance in the case of a Diﬃe-Hellman key exchange,
the group shares may be seen as local session identiﬁers.

As in Example 4.4, KE is a key exchange with possible continuations. In addition, we
consider multiple copies of KE, indexed by i, and local session identiﬁers lsid for each copy:

KEi[_

1, _

2] := I(lsidI

i , idI ); _

1(cid:107)R(lsidR

i , idR); _

2

Here, id captures the identities of the parties and lsid captures the randomness that will be
used by I and R to derive their respective local session identiﬁers. In the key exchange, I
to the value of lsid received from the other party
binds xI to the key that it computes, xI
and xI
id

to the received identity. Symmetrically, R binds the variables xR, xR

i (xR) the continuation (e.g., a record protocol based on the
If we denote by P I
i (xR)] is the composition of a session of the key exchange
derived secret key), KEi[P I
with the protocol where the values of xI , xR (computed keys) are passed respectively to

i (xI )(cid:107)P R

i (xI ), P R

and xR
id

lsid

lsid

.

34

i (xI ) or P R
P I
the composed protocol is expressed as follows:

i (xR). With Q an idealized version of P (however it is deﬁned), the security of

(cid:107)iKEi[P I

i (xI ), P R

i (xR)] ∼= (cid:107)iKEi[QI

i (xI ), QR

i (xR)]

Intuitively, from the adversary point of view, P is equivalent to its idealized version, even if
the key is derived from the key exchange as opposed to magically shared.

Equivalently, the security of the composed protocol can be proved if we have that the
advantage against the following indistinguishability is polynomial in N (and of course negli-
gible).

(cid:107)i≤N KEi[P I

i (xI ), P R

i (xR)] ∼= (cid:107)i≤N KEi[QI

i (xI ), QR

i (xR)]

A Corollary formalizing the following discussion can be found in Appendix F.1.

6.2 Proofs of Composed Key Exchange Security

Following the same applications of Theorems 2 and 4 as in Example 4.4, we decompose the
proof of the previous indistinguishability goals into the following goals:

1. ﬁnd an oracle OP,Q to simulate multiple sessions of P or Q,

2. design an oracle Oke to simulate multiple sessions of KE

3. complete a security proof under Oke for multiple sessions of the protocol using fresh

keys,

4. complete a security proof under OP,Q for multiple sessions of the key exchange.

We further reduce the security of the protocol to smaller proofs of single sessions of the
various components of the protocols under well chosen oracles. The following paragraphs
successively investigate how to simplify the goals (1),(2),(3),(4) above. For simplicity, we only
consider here the case of two ﬁxed honest identities.

In the following, we provide the conditions S-1,S-2,P-1,P-2,P-3,P-4,K-1,K-2,K-3 that must

be satisﬁed, so that we can prove

(cid:107)iKEi[P I

i (xI ), P R

i (xR)] ∼= (cid:107)iKEi[QI

i (xI ), QR

i (xR)]

using our framework and the decomposition of Example 4.4. Corollary 2, that formalizes the
following discussion and generalizes it to non ﬁxed identities, can be found in Appendix F.1.
We denote p = {idI , idR} and assume that they are the only shared names between KE, P
and Q and are the only names shared by two distinct copies Pi, Pj (resp. Qi, Qj). We also
denote by s = {lsidI

i }i∈N the set of all copies of the local session identiﬁers.

i , lsidR

Protocol simulatability For the simulation of the protocol, there must exists an oracle
OP,Q such that

S-1 νp.in(cI , xI ).P I

i (xI )(cid:107)in(cR, xR).P R

i (xR) is OP,Q-simulatable

Indeed, if this condition is fulﬁlled (and a similar one replacing P with Q), then, thanks
to Theorem 1, νp.(cid:107)i(in(cI , xI ).P I
i (xR)) is OP,Q-simulatable (and similarly
for Q). This meets the condition (2) of Theorem 4.

i (xI )(cid:107)in(cR, xR).P R

35

Key exchange simulatability For the simulation of the key exchange context, we need N
(with N polynomial in the security parameter) copies of KE and, in each of them, the initiator
(resp. the responder) may communicate with N possible responders (resp.
initiators). We
therefore use Theorem 2 with a context C with 2N 2 holes. C is the parallel composition of
N contexts and, as above, we use Theorem 1 to get the condition (1) of Theorem 2. Let KE(cid:48)
i
be4

KEi[

if
1≤j≤N
if
1≤j≤N

xI
lsid = lsidR
lsid = lsidI
xR

j then out(cI , (cid:104)i, j(cid:105)) else ⊥,
j then out(cR, (cid:104)i, j(cid:105)) else ⊥]

C is then (cid:107)i≤N KE(cid:48)
i

and C can be inferred by replacing each out((cid:104)i, j(cid:105)) with a hole. We
output (cid:104)i, j(cid:105) so that we know that the full scheduling is simulatable. Then, the condition to
be met by the key exchange is that

We then get, thanks to Theorem 1 the condition (1) of Theorem 2.

S-2 νp.KE(cid:48)
i

is Oke-simulatable

Security of the protocol Our goal is (cid:107)iPi(ki) ∼=Oke (cid:107)iQi(ki). Based on Theorem 5, we
only need an oracle Or so that:

P-1) ∀ i ≥ 1, νp, ki.P0(ki) is Or-simulatable,

P-2) ∀ i ≥ 1, νp, ki.Q0(ki) is Or-simulatable,

P-3) s is disjoint of the support of Oke,
P-4) P0(k0) ∼=Or,Oke Q0(k0).
We use the fresh names ki to model fresh magically shared keys, and use them as local sids
for Theorem 5. The intuition is similar to the notion of Single session game of [18], where the
considered protocols are such that we can derive the security of multiple sessions from one
session. For instance, if the key is used to establish a secure channel, revealing the other keys
does not break the security of one session, but allows to simulate the other sessions.

Security of the key exchange The security of the key exchange is more complicated to
deﬁne, in the sense that it cannot simply be written with a classical replication. The partnering
of sessions is not performed beforehand, so we must consider all possibilities. We may express
the security of a key exchange by testing the real-or-random for each possible session key.
We denote ki,j the fresh name corresponding to the ideal key that will be produced by the
i-th copy of the initiator believing to be partnered with the j-th copy of the responder. The
security of the key exchange is captured through the following indistinguishability:

(cid:107)i≤N KEi[out(xI ), out(xR)] ∼=OP,Q

(cid:107)i≤N KEi[

if
1≤j≤N
if
1≤j≤N

lsid = lsidR
xI
lsid = lsidI
(xR

j then out(ki,j) else ⊥,
j ) then out(kj,i) else ⊥]

where the advantage of the attacker is polynomial in N . Remark that we sometimes omit
channels, when they only need to be distinct.

4we denote

if
1≤j≤N

ci then ai else a(cid:48)

:= if c1 then a1 else if c2 · · · then an else a(cid:48)

36

Using a classical cryptographic hybrid argument (detailed in Proposition 39), we reduce
the security of multiple sessions to the security of one session in parallel of multiple corrupted
sessions; the security of each step of the hybrid game is derived from Equation (1) using
Theorem 4. It is expressed, with stateX
i = (cid:104)xX , lsidX

lsid(cid:105), as

i , xX

(cid:107)i≤N KEi[out((cid:104)stateI

i (cid:105))] ∼=OP,Q
i (cid:105)), out((cid:104)stateR
(cid:107)i≤N −1KEi[out((cid:104)stateI
lsid = lsidR
(cid:107) KEN [ if xI

i (cid:105)), out((cid:104)stateR
i (cid:105))]
N then out((cid:104)k, lsidI

N , xI
i }1≤i≤N −1 then ⊥,

lsid(cid:105))

lsid /∈ {lsidR
i (cid:105)),

else if xI
else out((cid:104)stateI
if xR
lsid = lsidI
else if xR
else out((cid:104)stateR
The previous equivalence expresses that when we look at N sessions that all output their
full state upon completion, the particular matching of the parties in KEN has a key that is
real or random if they are indeed partnered together, and if they are not partnered together,
they must be talking to another agent from the other KEi. We may see the other sessions as
corrupted sessions, as they leak their states upon completion.

N , xR
i }1≤i≤N −1 then ⊥,

lsid /∈ {lsidI
i (cid:105))]

N then out((cid:104)k, lsidR

lsid(cid:105))

(1)

We further reduce the problem to proving the security of a single session even when there
is an oracle simulating corrupted sessions. To this end, we need to reveal the dishonest local
session’s identiﬁers to the attacker, but also to allow him to perform the required cryptographic
operations, e.g. signatures using the identities.

We deﬁne, for X ∈ {I, R}, sX as the set of copies of the local session identiﬁers of I or
R, except a distinguished one (indexed 0 below) and s = sI ∪ sR. To obtain the security of
multiple sessions of the key exchange, we use Proposition 17.5. To this end, we would need to
design an oracle Or, such that the following assumptions are satisﬁed, where OP,Q corresponds
to O of Proposition 17:
K-1) ∀1 ≤ i ≤ N, νlsidI

i , idR.
KEi[out(xI ), out(xR)](cid:107)out((cid:104)lsidR

i , idI , lsidR

i , lsidI

i (cid:105)) is Or simulatable.

K-2) KE0[ out((cid:104)xI , lsidI
out((cid:104)xR, lsidR

0, xI
0 , xR

lsid(cid:105)),
lsid(cid:105))]

∼=Or,OP,Q KE0[

0 then out((cid:104)k, lsidI

0, xI

lsid(cid:105))

lsid /∈ sR then ⊥

lsid = lsidR

if xI
else if xI
else out((cid:104)xI , lsidI
lsid = lsidI
if xR
else if xR
else out((cid:104)xR, lsidR

lsid /∈ sI then ⊥
0 , xR

0, xI

lsid(cid:105))]

lsid(cid:105)),
0 then out((cid:104)k, lsidR

0 , xR

lsid(cid:105))

K-3) s is disjoint of the support of OP,Q.

Intuitively, if the initiator believes to be talking to the honest responder, then it outputs
the ideal key, and if it is not talking to any simulated corrupted party, it raises a bad event.
Note that while the structure of the proof does not fundamentally change from other
proofs of key exchanges, e.g. [18], each step of the proof becomes straightforward thanks to
our composition results. Our proofs are also more ﬂexible, as shown by the extension to key
exchanges with key conﬁrmation in Section 8.

5We also use Theorem 1 to get the simulatability of N sessions in parallel from the simulatability of each

session.

37

Initiator
skI , ai

Receiver
skR, bi

pk(skI ), gai

pk(skR), gbi, sign((gai, gbi, pk(skI )), skR)

sign((gbi, gai, pk(skR)), skI )

Figure 4: ISO 9798-3 Diﬃe Hellman Key Exchange

7 Basic Diﬃe-Hellman Key Exchange

We outline here the application of our framework to the ISO 9798-3 protocol, a variant of the
Diﬃe-Hellman key exchange. It is proven UC composable in [13]. We use our result to extend
the security proof to a context with shared long term secrets (which was not the case in the
UC proof). We present the protocol in Figure 4, and show how to instantiate the required
values and oracles to perform the proof presented in Section 6.2. The formal proofs (using the
CCSA model [11]) are provided in Appendix C.

Our decomposition and subsequent proofs show that the DDH key exchange can be used
to securely derive a secret key for any protocol that does not rely on the long term secret
used in the key exchange. Our proof is also modular, in the sense that it could be adapted to
provide also the security when the continuation protocol uses the long term shared secret as
well.

A high level view of the protocol is given in Figure 4, and it is formally expressed in our
algebra in Figure 5, where _I and _R denote the possible continuations at the end of each
party. We use pattern matching in the inputs to simplify the notations, where for instance
in(c, (cid:104)m, x(cid:105)) with m some constant only accepts inputs whose ﬁrst projection is m, and then
bind the variable x to the second projection.
If the inputs are not of the given form, the
protocols goes to an error branch.

Our goal is to apply the decomposition of Section 6.2, for some abstract continuations P
and Q that are supposed to used the derived key. We need to ﬁnd suitable identities and local
session identiﬁers so that the Conditions from the decomposition of Section 6.2 are fulﬁlled.
As we do not specify P and Q, we only discuss the conditions relative to the security of the
key exchange, e.g., K-1,K-2 and K-3. Remark that those conditions are suﬃcient to derive a
notion similar to the classical security of a key exchange, as for any P and Q that do not share
long term shared secrets with the key exchange. The other conditions are trivial to derive or
only rely on the security of the continuation when using an ideal key.

The identity of each party is its long term secret key, and thus, we use skI and skR as idI
and idR. Each session of the key exchange instantiates a fresh Diﬃe-Hellman share, that can
be seen as a local session identiﬁer. We thus use gai and gbi as lsidI
. These values
i
can also be used as implicit tagging since any signed message either depends on ai or bi.

and lsidR
i

With those choices, we need to ﬁnd a tagging function T that will provide a tagged oracle
OT such that the Conditions K of Section 6.2 are satisﬁed. Those Conditions, reformulated
with the current notations and with OT standing for Or, are expressed as follow:

K-1) ∀1 ≤ i ≤ N, νai, skI , bi, skR.

Ii[out(kI )](cid:107)Ri[out(kR)](cid:107)out((cid:104)gai, gbi(cid:105)) is OT -simulatable.

38

(cid:107)i

(

Ii :=

(cid:107)
Ri :=

)

out((cid:104)pk(skI ), gai(cid:105))
in((cid:104)xpk, xB, xm(cid:105)).
if verify(xm, xpk) = (cid:104)gai, xB, pk(skI )(cid:105) then

out(sign((cid:104)xB, gai, xpk(cid:105), skI ))
let kI = xai
_
I

B in

in((cid:104)xpk, xA(cid:105)).
out((cid:104)pk(skR), gbi, sign((cid:104)xA, gbi, xpk(cid:105), skR)(cid:105))
in(xm).
if verify(xm, xpk) = (cid:104)gbi, xA, pk(skR)(cid:105) then

let kR = xbi
_

A in

R

Figure 5: ISO 9798-3 Diﬃe Hellman Key Exchange in the Pi Calculus (omitted channels)

K-2)

I0 [out((cid:104)kI , ga0, xB(cid:105))]
(cid:107)R0 [out((cid:104)kR, gb0, xA(cid:105))]

∼=OT ,OP,Q









I0

(cid:107)R0

if xB = gb0 then out((cid:104)xa0
else if xB /∈ {gbi}i≥1 then ⊥
else out((cid:104)kI , ga0, xB(cid:105))
if xA = ga0 then out((cid:104)xb0
else if xA /∈ {gai}i≥1 then ⊥
else out((cid:104)kR, ga0, xB(cid:105))

B , ga0, xB(cid:105))

A , gb0, xA(cid:105))









K-3) {gai, gbi}i≥1 is disjoint of the support of OP,Q.

K-2 either corresponds to a matching conversation (i.e., all messages received by one were
sent by the other) between the sessions with sids ga0, gb0, in which case the output is (twice)
an ideal key k, or else it is a matching conversation with a simulated session, in which case it
outputs the computed keys. It is neither of those cases, it should not happen, and we raise
a bad event (denoted ⊥). The proof of the K-2 is thus a real-or-random proof of a honestly
produced key. We do not provide the proof of K-2 in this section, it is provided in Appendix C.
We must deﬁne an implicit tagging that allows to both have the simulatability and the
indistinguishability. Remark that ﬁrst, we extend the tagging function T of Deﬁnition 14 so
that it may depend on a second argument of arbitrary length, yielding T (m, s), the corre-
sponding signing oracle being denoted Osign
. This is required so that the implicit tagging
T,sk,s
may depend on all the possible local session identiﬁers. The exact deﬁnition of this extension
is given in Section 12.

We deﬁne the implicit tagging functions T I and T R as

T I (m, {gai, gbi}i≥1) := ∃s ∈ {ai}i≥1, ∃m1, m2.m = (m1, gs, m2)
T R(m, {gai, gbi}i≥1) := ∃s ∈ {bi}i≥1, ∃m1, m2.m = (m1, gs, m2)

This tagging function will suit our needs, as all messages signed by the two parties follow
this pattern. Moreover, in the protocol, the value sent in the ﬁrst message should match gai in

39

the last message. Therefore, when the protocol of Figure 4 is successfully completed, we can
prove that if xB (cid:54)= gb0, then xB ∈ {gbi|i ≥ 1}, i.e., T R(xB, {gai, gbi}i≥1) is true (and similarly
for R).

Let s = {gai, gbi}i≥1, we ﬁnally deﬁne OT = Osign

T R,skR,s, Os, where Os simply
reveals the elements in s, we do obtain the simulatability of multiple sessions of the key
exchange (Hypothesis 1).

T I ,skI ,s, Osign

To adapt this proof to a concrete example, the security proof of K-2 would be performed
under an oracle OP,Q that allows to simulate the continuation (Condition P-1 of Section 6.2).
The continuation should then be proven secure when using an ideal key (Conditions P of
Indeed, let us consider a record protocol
Section 6.2).
L := LI (xI )(cid:107)LR(xR), that exchanges encrypted messages using the exchanged key, and does
not share any long term secret, i.e., does not use the signing keys of the key exchange. Without
any shared secret, we do not need any oracle to simulate in(k); LI (k)(cid:107)in(k); LR(k), so we can
choose a trivial OP,Q that does nothing.

In some cases, this step is trivial.

8 Extension to Key Conﬁrmations

We present how our compositional framework can be used to prove the security of a key
exchange, in which the key is derived in a ﬁrst part of the protocol and then used (key
conﬁrmation) in the second part. Compared to [8], our method allows in addition sharing of
long term secrets.

i (lsidR

i , idI ); I 1

i (xI ) and Ri := R0

Consider a key exchange I(lsidI

i , idR). We further split I and R into Ii :=
i , idI )(cid:107)R(lsidR
correspond to the key
and R0
i (xR), where I 0
I 0
i , idr); R1
i (lsidI
i
i
and R1
exchange up to, but not including, the ﬁrst use of the secret key (xI or xR), and I 1
i
i
are the remaining parts of the protocol. The intuition behind the proof of security is that at
the end of I 0
, i.e. just before the key conﬁrmation, either the sessions are partnered
i
together and the derived key satisﬁes the real-or-random, or they are not, which means that
the key conﬁrmation performed by I 1
i

will fail. We denote

and R0
i

and R1
i

KEi[_

and

1, _

2] := I 0

i (lsidI

i , idI ); I 1

i (xI ); _

1(cid:107)R0

i (lsidR

i , idR); R1

i (xR); _

2

i [_

1, _

KE0

2] := I 0

i , idI ); _
We proceed as in Section 6, outlining how we may split the security proof into smaller proofs
using our framework, using the same composition Theorems at each step. We thus provide the
necessary Conditions S-1,S-2,P-1,K-1,K-2,K-3 so that, for some continuation P I
i (xR)
and its idealized version Q,

j , idR); _

i (xI )(cid:107)P R

i (lsidR

i (lsidI

1|R0

2

(cid:107)iKEi[P I

i (xI ), P R

i (xR)] ∼= (cid:107)iKEi[QI

i (xI ), QR

i (xR)]

A formal Corollary can be found in Appendix F.2.

8.1 Proofs with Key Conﬁrmations

Key exchange and protocol simulatability We modify slightly the conditions S-1 and
S-2 of Section 6.2 to reﬂect the fact that we now consider the key conﬁrmation to be part of
the continuation:

40

S-1) νp.in(x).I 1(x); P I (x), in(x).R1(x); P R(x), in(x).I 1(x); QI (x),

in(x).R1(x); QR(x) are OP,Q simulatable.

S-2) νp. (cid:107)i≤N I 0

i (lsidI

i , idI );

(cid:107)i≤N R0

i (lsidR

i , idR);

if
1≤i≤N

lsid = lsidR
xI

j then

out((cid:104)i, j(cid:105))
i (xI ); ⊥
lsid = lsidI
xR

else I 1
if
1≤i≤N

j then

is Oke-simulatable.

out((cid:104)i, j(cid:105))

else R1

i (xR); ⊥

Security of the protocol Compared to Section 6.2, the continuation must be secure even
in the presence of the messages produced during the key conﬁrmation:

i (xI ); P I

i (xI )(cid:107)R1

i (xR); P R

P-1) (cid:107)i≤N I 1

i (xR) ∼=Or,Ok (cid:107)i≤N I 1
We could once again split this goal into a single session proof using Theorem 5. We remark
that to prove the security of the single session, we can further reduce the proof by using an
oracle that may simulate I 1 and R1, as the security of P should not depend on the messages
of the key conﬁrmation.

i (xR); QR

i (xI )(cid:107)R1

i (xI ); QI

i (xR)

Security of the key exchange We proceed in a similar way as in Section 6.2 and we use
the same notations. The following Conditions are then suitable:

KE0

K-1) ∀i ≤ N, νlsidI

i , idI , lsidR
i [out(xI ), out(xR)](cid:107)out((cid:104)lsidR
K-2) s is disjoint of the support of OP,Q.

i , idR.

i , lsidI

i (cid:105)) is OT -simulatable

K-3) KE0

0 [if xI

lsid /∈ sR then I 1
else out((cid:104)xI , lsidI
if xR
lsid /∈ sI then R1
else out((cid:104)xR, lsidR

0 (xI )
0, xI
0(xR)
0 , xR

lsid(cid:105)),

lsid(cid:105))]

∼=OKE ,OP,Q KE0

0 [if xI

lsid = lsidR

0 then out((cid:104)k, lsidI

0, xI
0 (xI ); out(⊥)

lsid(cid:105))

lsid /∈ sR then I 1

else if xI
else out((cid:104)xI , lsidI
lsid = lsidI
if xR
else if xR
else out((cid:104)xR, lsidR

lsid /∈ sI then R1
0 , xR

0, xI

lsid(cid:105)),
0 then out((cid:104)k, lsidR

lsid(cid:105))]

0 , xR
0(xR); out(⊥)

lsid(cid:105))

or xR

lsid = lsidI
0

The indistinguishability expresses that, if the two singled out parties are partnered, i.e.,
, then we test the real-or-random of the key. Else, it speciﬁes
xI
lsid = lsidR
0
that a party must always be partnered with some honest session, i.e., that xX
lsid /∈ sY will
lsid /∈ sY we run the key conﬁrmation, and on
never occur. To this end, on one side, when xX
the other side we run the key conﬁrmation followed in case of success by a bad event. Finally,
when two honest parties are partnered, but are not the singled out parties, they leak their
states.

9 Application to SSH

SSH [12] is a protocol that allows users to login onto a server from a remote platform. It is
widely used in the version where signatures are used for authentication. An interesting feature

41

Platform
skP , ai

gai

Server 1
skS, bi, ci

Server 2
skT , di

let sid = hash((cid:104)gai, gbi, gaibi(cid:105))

gbi, pk(skS), sign(sid, skS)

let k=gaibi

enc(sign(sid, skP ), k)

Successful login of the user on Server 1

gci

let sid2 = hash((cid:104)gci, gdi, gcidi(cid:105))

let k2 = gcidi

enc(sid2, k)

gdi, pk(skT ), sign(sid2, skT )

enc(sign((cid:104)sid2, “f orwarded”(cid:105), skP ), k) enc(sign((cid:104)sid2, “f orwarded”(cid:105), skP ), k2)

Figure 6: SSH with Forwarding Agent

is forwarding agent: once a user u is logged on a server S, they may, from S, perform another
login on another server T . As S does not have access to the signing key of u, it forwards
a signature request to u’s platform using the secure SSH channel between u and S. This
represents a challenge for compositional proofs: we compose a ﬁrst key exchange with another
one, the second one using a signature key already used in the ﬁrst.

We provide the decomposition of the security proof of SSH composed with one (modiﬁed)
forwarding agent. We use multiple times in sequence our composition Theorems, that allow us
to further simplify the required indistinguishability proofs. The corresponding indistinguisha-
bility proofs are performed in Appendix D and Appendix E.

There is a known weakness in this protocol: any privileged user on S can use the agents
of any other user as a signing oracle. Thus, in order to be able to prove the security of the
protocol, we only consider the case where there is no such privileged user. Figure 6 presents an
example of a login followed by a login using the forwarding agent. For simplicity, we abstract
away some messages that are not relevant to the security of the protocol.

In the current speciﬁcation of the forwarding agent, it is impossible for a server to know
if the received signature was completed locally by the user’s platform, or remotely through
the forwarding agent. As the two behaviors are diﬀerent in term of trust assumptions, we
claim that they should be distinguishable by a server. For instance, a server should be able
to reject signatures performed by a forwarded agent, because intermediate servers are not
trusted. To this end, we assume that the signatures performed by the agent are (possibly
implicitly) tagged in a way that distinguishes between their use in diﬀerent parts of the
protocol. This assumption also allows for domain separation between the two key exchanges,
and thus simpliﬁes the proof.

We consider a scenario in which there is an unbounded number of sessions of SSH, each with
one (modiﬁed) forwarding agent, used to provide a secure channel for a protocol P . Thanks to
multiple applications of Theorems 2 and 4, we are able to break the proof of this SSH scenario
into small ones, that are very close to the proof of a simple Diﬃe-Hellman key exchange. This
assumes the decisional Diﬃe-Hellman (DDH) hypothesis for the group, EUF-CMA for the

42

Pi :=

out(gai);
in((cid:104)xB, pk(skS), sign(cid:105))
let k = xai
B in
let sid = hash((cid:104)gai, xB, k(cid:105)) in
if verify(sign, pk(skS)) = sid then
out(enc(sign(sid, skP ), k));
_

P .

Si :=

A in

in(xA);
let k = xbi
let sid = hash((cid:104)xA, gbi, k(cid:105)) in
out((cid:104)gbi, pk(skS), sign(sid, skS)(cid:105))
in(enc(xsign, k))
if verify(xsign, pk(skP )) = sid then

_

S.

SSH := (cid:107)i(Pi[0](cid:107)Si[0])

Figure 7: Basic SSH Key Exchange

signature scheme and that the encryption must ensure integrity of the cyphertexts (this last
assumption is only required for the forwarded key exchange, where a signature is performed
over an encrypted channel). P also has to satisfy the conditions of Section 8.1. In particular,
it must be secure w.r.t. an attacker that has access to a hash that includes the exchanged
secret key, since SSH produces such a hash. Note that the scenario includes multiple sessions,
but only one forwarding. The extension would require an induction to prove in our framework
the security for any number of chained forwardings.

9.1 The SSH Protocol

The basic SSH key exchange is presented in Figure 7, with possible continuations at the end
denoted by _P and _S. In this Section, we use a strong notion of pattern matching, where
for instance in(enc(xsign, k)) is a syntactic sugar for in(x); let xsign = dec(x, k) in _.

As it is always the case for key exchanges that contain a key conﬁrmation, the indistin-
guishability of the derived key is not preserved through the protocol. The diﬃculty of SSH
is moreover that once a user has established a secure connection to a server, they can from
this server establish a secure connection to another server, while using the secure channel
previously established to obtain the user credentials. We provide in Figure 8 a model of the
SSH with forwarding of agent (reusing the deﬁnitions of P and S from Figure 7). After a
session of P terminates successfully, a F orwardAgent is started on the computer.
It can
receive on the secret channel a signing request and perform the signature of it. In parallel,
after the completion of a session of S, a distant session of P that runs on the same machine as
S can be initiated by P Distant. It will request on the previously established secret channel
the signature of the corresponding sid. Finally, as the forwarding can be chained multiple
time, at the end of a successful P Distant, a F orwardServer is set up. It accepts to receive a
signing request on the new secret channel of P Distant, forwards the request on the old secret
channel, gets the signature and ﬁnally forwards it.

The forwarding agent implies a diﬃcult composition problem: we sequentially compose
a basic SSH exchange with a second one that uses the derived key and the same long term
secret keys. Thus, to be able to prove the security of SSH with forwarding agent, we must be
able to handle key conﬁrmations and composition with shared long term secrets.

43

A in

SF orwardi :=
in(xA);
let k = xbi
let sid = hash((cid:104)xA, gbi, k(cid:105)) in
out((cid:104)gbi, pk(skS), sign(sid, skS)(cid:105))
in(enc(sign, k))
if verify(sign, pk(skP )) = (cid:104)sid, “fwd ”(cid:105) then

_

SF

P Distanti(oldk) :=

out(gai);
in((cid:104)xB, pk(skS), sign(cid:105))
let k = xai
B in
let sid = hash((cid:104)gai, xB, kP (cid:105)) in
if verify(sign, pk(skS)) = sid then

out(enc(sid, oldk))
in(enc(sign, oldk))
out(enc(sign, k))
_

P D.

F orwardAgent(k) :=
in(enc(sid, k))
out(enc(sign((cid:104)sid, “fwd ”(cid:105), skP ), k))

SSHF orward := (cid:107)i(Pi[F orwardAgent(k)](cid:107)SF orwardi(cid:107)Si[P Distanti(k)])

Figure 8: SSH Key Exchange with Forwarding Agent

9.2 Security of SSH

We show how to prove the Conditions of Section 8 to the basic SSH protocol (without forward-
ing agent). We provide in Figure 9 the decomposition for key exchanges with key conﬁrmation
corresponding to the SSH protocol. We directly specify that P and S may only relate to each
other by hard-coding the expected public keys in them. This is the classical behaviour of SSH
where a user wants to login on a speciﬁc server, and the public key of the user was registered
previously on the server.

For some abstract continuation RP (x)(cid:107)RS(x) and its idealized version QP (x)(cid:107)QS(x), our

goal would be to prove that

P 0
i

:=
out(gai);
in(xB)
let k = xai
0.
i (xB, k) :=
in((cid:104)pk(skS), sign(cid:105))

B in

P 1

let sid = hash((cid:104)ga, xB, k(cid:105)) in
if verify(sign, pk(skS)) = sid then

out(enc(sign(sid, skP ), k))
_P.

S0
i :=
in(xA);
let k = xbi
let sid = hash((cid:104)xA, gbi, k(cid:105)) in

A in

out(gbi)
S1
i (sid, k) :=

out((cid:104)pk(skS), gbi, sign(sid, skS)(cid:105))
in(enc(sign, k))
if verify(sign, pk(skP )) = sid then

_S.

Figure 9: Divided SSH Key Exchange

44

i ; P 1
P 0

i (xB, k)[RP (k)](cid:107)S0

i ; S1

i (sid, k)[RS(k)] ∼= P 0

i ; P 1

i (xB, k)[QP (k)](cid:107)S0

i ; S1

i (sid, k)[QS(k)]

Without specifying the continuation, a ﬁrst step toward the security of the basic SSH key
exchange is to obtain Conditions K-1 and K-3 of Section 8. Recall that if a key exchange
satisﬁes those Conditions, it can be seen as a secure key exchange in the classical sense as it
can be composed with any continuation that do not share any long term secrets. The proofs
only need to ne adapted when it is not the case.

The behaviour of the protocol is very similar to the signed DDH key exchange (Figure 4)
previously studied. We can once again see the DH shares {ai, bi}i∈N as local session identiﬁers
that can be used to pair sessions. For each session and each party, the messages signed by this
party always depend strongly on the DH share. We can thus make all SSH sessions simulatable
with the following tagging functions and corresponding signing oracles.

TP (m, s) := ∃s ∈ {ai}i∈N, ∃m1, m = hash(gs, m1, ms
1)
TS(m, s) := ∃s ∈ {bi}i∈N, ∃m1, m = hash(m1, gs, ms
1)
We have that the set of axioms Ax = EUF-CMATP ,skP ,s∧EUF-CMATS ,skS ,s is Osign
sound thanks to Proposition 27. We use those axioms to perform the proof of K-3, where the
tagging essentially implies the authentication property. However, the proof must be slightly
stronger, when we consider that the continuations P, Q are instantiated with a second round
of SSH with a forwarding agent that uses the same long term secrets.

TP ,skP ,s, Osign

TS ,skQ,s, Oai,bi

9.3 SSH with Forwarding Agent

For concision, we write F A for F orwardAgent, SF for SF orward, and P D for P Distant.
Let us consider an abstract continuation protocol, satisfying a security property of the form
RP (k)(cid:107)RS(k) ∼= QP (k)(cid:107)QS(k) where k denotes a fresh name modelling an ideal key produced
by a key exchange.

We once again assume that the agents are only willing to communicate with the honest
identities, i.e., pk(skS) and pk(skP ) are predeﬁned in the processes. The goal is to prove the
following equivalence.

(cid:107)i

(Pi[F A(k)]
(cid:107)Si[P D(k); RP (kP D)]
(cid:107)SF [RS(kSF )])

∼= (cid:107)i

(Pi[F A(k)]
(cid:107)Si[P D(k); QP (kP D)]
(cid:107)SF [QS(kSF )])

It corresponds to the fact that we should have RP (k)(cid:107)RS(k) ∼= QP (k)(cid:107)QS(k), even if the ideal
key k is replaced for each party by a key derived by a SSH key exchange (P D and SF ) using
an forwarding agent (F A) based on a previous SSH key exchange (P and S).

We apply twice the decomposition of Section 8, once to show the security of the ﬁrst key
exchange (as done in the previous paragraph), and that we can thus prove the security of the
second key exchange using an ideal key derived instead of the one derive by the ﬁrst exchange.
The second application is then used to prove the security of this second key exchange.

First application The ﬁrst application is performed with the following Conditions (corre-
sponding to the one of Section 8), which allow to derive the desired conclusion.

45

K-3):

P 0
0 ;

(cid:107)S0
0 ;

P-1):

if xB /∈ s then

P 1

0 (xB, k); out(k)
else out(k, ga0, xB)
if xA /∈ s then

S1
i (xA, k); out(k)
else out(k, gb0, xA)

P 0
0 ;

∼=OP S ,Of orward

(cid:107)S0
0 ;

if xB = gb0 then

out(k, ga0, xB)
else if xB /∈ s then
P 1(xB, k); bad
else out(k, gb0, xA)
if xA = ga0 then
out(k, gb0, xA)
else if xB /∈ s then
0 (xA, k); bad
else out(k, gb0, xA)

S1

(cid:107)iP 1

i (k)[F A(k)](cid:107)S1

i (k)[P D(k); RP ](cid:107)SF [RS] ∼=OKE1

(cid:107)iP 1

i (k)[F A(k)](cid:107)S1

i (k)[P D(k); QP ](cid:107)SF [QS]

We use the following oracles:

• OP S allows to simulate (K-1) the other honest sessions of P and S, it corresponds to

Osign
TP ,F,skS ,s, Osign

TS ,F,skP ,s, Oai,bi

of Section 9.2.

• Oforward allows to simulate (S-1) the continuation, i.e., protocols of the form

in(k); P 1(k)[F A(k)](cid:107)in(k); S1(k)[P D(k); RP ](cid:107)SF [RQ]

• OKE1

allows to simulate (S-2) (cid:107)i(Pi(cid:107)Si) (it is identical to OP S).

All simulations are performed under νskS, skP . To deﬁne Oforward , we need to settle an
issue. Indeed, for hypothesis S-1, we need to provide an oracle that can simulate sessions of
the forwarding protocols. However, in order to get the simulatability of in(k).F A(skP , k), one
must give a generic signing oracles to the attacker, which would obviously make the protocol
insecure. Based on the assumption that the forwarded sessions perform signatures tagged with
“fwd (cid:48)(cid:48) (as shown below), we can however provide a signing oracle for such messages only. It
allows for the simulatability of the forwarding agent and of the forwarded client and server.
More speciﬁcally, recall the the forwarding agent is of the form:

F A(skP , k) :=

in(enc(sid, k));

out(enc(sign((cid:104)sid, “fwd ”(cid:105), skP ), k))

We may obtain its simulatability with the following tagging function:

Tfor (m, s) := ∃m1. m = (cid:104)m1, “fwd ”(cid:105)

Then, Oforward is simply Osign

Tfor ,F,skP ,s, Osign

Tfor ,F,skS ,s, Oa(cid:48)

i,b(cid:48)
i

the corresponding EUF-CMA axioms in Appendix E.

. We prove Condition K-3 under

46

Second application We further simplify Condition P-1 of the previous paragraph with a
second application of the decomposition of Section 8. We now denote s(cid:48) = {a(cid:48)
i}i∈N. P Di
and SFi are split into P D0
similarly to the split of Figure 9 before and
and SF 0
i , SF 1
i
after the key conﬁrmation. The tagging functions used are only slight variations of the tagging
functions for the ﬁrst SSH key exchange:

i , P D1
i

i, b(cid:48)

P (m, s(cid:48)) := ∃i, ∃X, m = (cid:104)hash(ga(cid:48)
T (cid:48)
S(m, s(cid:48)) := ∃i, ∃X, m = (cid:104)hash(X, gb(cid:48)
T (cid:48)

i, X, X a(cid:48)
i, X b(cid:48)

i), “fwd ”(cid:105)
i), “fwd ”(cid:105)

We then need to prove the Conditions:
K-3):

0 (k); F A(k)(cid:107)S1
P 1

0 (k); P D0

0(k);

(cid:107)SF 0
0 ;

0 (k); F A(k)(cid:107)S1
P 1

∼=OKE1 ,Ok
F P S ,ORQ
0 (k); P D0
0;

if xB /∈ s(cid:48) then

P D1

0(xB, k); out(k)

else out(k, ga(cid:48)
if xA /∈ s(cid:48) then

0, xB)

SF 1

0 (xA, k); out(k)

else out(k, gb(cid:48)

0, xA)

if xB = gb(cid:48)

0 then

out(k, ga(cid:48)

0, xB)
else if xB /∈ s(cid:48) then
0(xB, k); bad
0, xA)

P D1

else out(k, gb(cid:48)
if xA = ga(cid:48)
out(k, gb(cid:48)

0 then
0, xA)

else if xB /∈ s(cid:48) then
0 (xA, k); bad
0, xA)

else out(k, gb(cid:48)

SF 1

(cid:107)SF 0
0 ;

Note that k is a fresh name that could be considered as a long term secret, i.e., in p.

And P-1):

(cid:107)iP D1

i (k(cid:48)); RP (k(cid:48))(cid:107)SF 1

0 (k(cid:48)); RS(k(cid:48)) ∼=OKE1 ,OF P S (cid:107)iP D1

i (k(cid:48)); QP (k(cid:48))(cid:107)SF 1

i (k(cid:48)); QS(k(cid:48))

With the oracles:

• Ok

F P S
to Osign
T (cid:48)

allows to simulate (K-1) the other honest sessions of P D and SF , it corresponds
P ,skS ,s, Osign

S ,skP ,s, Oa(cid:48)
T (cid:48)

of Section 9.2.

i,b(cid:48)
i

• ORQ allows to simulate (S-1) the continuation, i.e., protocols of the form

in(k); P D1(k); RP (k)(cid:107)in(k); SF 1(k); RQ(k)

We prove Condition K-3 under the corresponding EUF-CMA axioms in Appendix E.
Remark that to ensure that the forwarding agent only signs the sid sent by P D, it is required
that the encryption scheme is an authenticated encryption scheme.

47

Part III
Composition in the CCSA logic

10 Oracles in the CCSA Logic

We extend the semantics of the CCSA logic so that it now refers to attackers that can have
access to an extra oracle O. We then lift the notion of soundness for the axioms to support
oracles, deﬁning the notion of O-soundness.

10.1 Syntax and Semantics

While the cryptographic library of the CCSA logic stays as is, the computational model must
now also depend on some oracle that is given to the attacker, and the corresponding random
oracle tape.

Deﬁnition 19. A computational model M is an extension of a cryptographic library Mf ,
which provides an oracle O, and an additional PTOM AO
for each symbol g ∈ G, that takes
g
as input an inﬁnite random tape ρr, a security parameter 1η and a sequence of bitstrings.
We deﬁne the interpretation of extended terms as, given M, η, σ, ρs , ρO and ρr:
• [[n]]η,σ

:= An(1η, ρs) if n ∈ N

M,ρs,ρr,ρO

• [[x]]η,σ

M,ρs,ρr,ρO

= [[xσ]]η,σ

if x ∈ X

• [[f (u)]]η,σ

M,ρs,ρr,ρO

M,ρs,ρr,ρO
= Af (1η, [[u]]η,σ

M,ρs,ρr,ρO

) if f ∈ Σ

• [[g(u)]]η,σ

M,ρs,ρr,ρO

= AO(ρs,ρO)
g

([[u]]η,σ

M,ρs,ρr,ρO

, ρr, 1η) if g ∈ G

We also adapt the deﬁnition of the interpretation of ∼.

Deﬁnition 20. Given a computational model M, including an oracle O, two sequences of
terms t, u, and an assignment σ of the free variables of t, u to ground terms, we have M, σ |=O
t ∼ u if, for every polynomial time oracle Turing machine AO,

|Pρs,ρr,ρO {AO(ρs,ρO)([[t]]σ,η

ρs;ρr;ρO , ρr, 1η) = 1}

−Pρs,ρr,ρO {AO(ρs,ρO)([[u]]σ,η

ρs;ρr;ρO , ρr, 1η) = 1}|

is negligible in η. Here, ρs, ρr, ρO are drawn according to a distribution such that every ﬁnite
preﬁx is uniformly sampled.

10.2 Oracle Soundness

To perform proofs in the logic, we need to design axioms that are sound w.r.t. an attacker
that has access to O; we say that the axiom is O-sound in this case. They should be easy to
verify for actual libraries, yet powerful enough for the proofs that we intend to complete. The
purpose of this Section is to provide such axioms. We ﬁrst extend the notion of soundness to
oracles.

Deﬁnition 21. Given a family of computational models F using oracle O, a set of ﬁrst order
formulas A is O-sound (w.r.t. F) if, for every ψ ∈ A, every M ∈ F, M |=O ψ.

48

With such a deﬁnition, if A is O-sound (w.r.t. F) and A |= φ (where φ is a closed formula),

then, for every M ∈ F, M |=O φ.

Example 10.1 (Function application). For any O, F, function f , terms t1, . . . , tn, u1, . . . , un

t1, . . . , tn ∼ u1, . . . , un =⇒ f (t1, . . . , tn) ∼ f (u1, . . . , un)

is O sound.

Example 10.2. Given a single key encryption oracle O for key k, the formula

is

enc(0, r, k) ∼ enc(1, r, k)

• not sound (nor O-sound) in general,

• sound but not O-sound for non randomized SPRP encryption,

• O-sound for IND-CPA encryption.

Note that the axioms that are designed in [11] cannot be borrowed directly. For instance,
n ∼ n(cid:48), where n, n(cid:48) are names, is a standard axiom: two randomly generated numbers of the
same length cannot be distinguished. However, if either n or n(cid:48) is in the support of O, some
information on their interpretation can be leaked by the oracle. The axiom n ∼ n(cid:48) is sound,
but not O-sound. We have to modify this axioms as follows:

Lemma 22. For any oracle O with support n, the axiom ∀k, k(cid:48) /∈ n, k ∼ k(cid:48) is O-sound.

Proof. We are given a cryptographic library, and oracle O with support n, and two names k,
k(cid:48) not in the support. We are also given AO which is a distinguisher over k ∼ k(cid:48). We deﬁne
a PTTM A(cid:48) which on input (m, ρr, 1η):

• Splits ρr into three distinct inﬁnite tapes ρso, ρra, ρro.

• Simulates AO(ρso,ρro)(m, ρra, 1η).

Let us a prove that A(cid:48) is a distinguisher over k ∼ k(cid:48), which contradicts the unconditional
soundness of this axiom when there is no oracle.

We denote by πk(ρs, η) the tapes where every bit of ρs which does not correspond to a
c(ρs, η) where all bits for k are set to 0. We then have

name of k is set to 0, and similarly πk
for any PTOM AO:

ρs , ρr, 1η) = 1}

Pρs,ρr,ρO {AO(ρs,ρO)([[k]]σ,η
=1 Pρs,ρr,ρO {AO(πk(ρs,η),ρO)([[n]]σ,η
πk
=2 Pρs1,ρs2,ρr,ρO {AO(ρs1,ρO)([[n]]σ,η
ρs2, ρr, 1η) = 1}
=3 Pρso,ρs,ρra,ρro{AO(ρso,ρro)([[k]]σ,η
ρs , ρra, 1η) = 1}
=4 Pρs,ρr {A(cid:48)([[k]]σ,η

ρs , ρr, 1η) = 1}

c (ρs,η), ρr, 1η) = 1}

1. Thanks to the deﬁnition of support, the oracle answers the same on πk(ρs, η) and ρs;
2. we split ρs in two, to replace independent tapes πk(ρs, η) and πk

c(ρs, η);

49

3. we rename random tapes;

4. by construction of A(cid:48).

This shows that A(cid:48) has the same advantage as AO against k ∼ k(cid:48), which concludes the

proof.

Other axioms in [11] can be extended without problem. For instance the transitivity of ∼

or the function application axiom:

Lemma 23. For any O, f ∈ F, terms t1, . . . , tn, u1, . . . , un

t1, . . . , tn ∼ u1, . . . , un =⇒ f (t1, . . . , tn) ∼ f (u1, . . . , un)

is O sound.

In general, what we have is that any axiom independent from the oracle support is sound.

Lemma 24. For any O, and terms t, s, such that all names in t, s do not appear in supp(O),
we have that t ∼ s is sound if and only if t ∼ s is O-sound.

This allows us to derive, given an oracle and a recursive set of axiom, the set of axioms

which is sound w.r.t. an oracle.

For instance, the general DDH axiom is, for any names a, b, c, ga, gb, gab ∼ ga, gb, gc. If we
denote by s the support of some oracle, the O-sound DDH version is simply the set of formulas
DDHs for all name a, b, c /∈ s, ga, gb, gab ∼ ga, gb, gc. Here, the notation gx corresponds to
g(n)r(x), where g is the function which extracts a group generator and r the function which
evaluates names into exponents. We may consider that we have two interpretations of those
function such that DDH holds.

EUF-CMA We deﬁne a CCSA version of the tagged EUF-CMA axiom. It is a direct
adaptation of the CCSA EUF-CMA axiom to match the behaviour of the tagged EUF-CMA
axiom (Figure 3).

Deﬁnition 25. Given a name sk and a function symbol T , we deﬁne the generic axiom scheme
EUF-CMAT,sk as, for any term t such that sk is only in key position:

if ( checksign(t, pk(sk)))
then T ( getmess(t))

.
(cid:87)

sign(x,sk)∈St(t) (t .= sign(x, sk))

∼ (cid:62)

else (cid:62)

The tagged signing oracles is deﬁned as previously, only adding the extra argument to the

tagging function.

Deﬁnition 26. Given a name sk and a function T , we deﬁne the generic signing oracle Osign
T,sk
as follows:

Osign

T,sk (m) := if T (m) then output(sign(m, sk)))

50

Proposition 27. For any computational model in which the interpretation of sign is EUF-CMA,
any name sk, and any boolean function T , EUF-CMAT,sk is Osign
Proof. Let us assume that soundness is violated. We then have a term t and a computational
model such that t does not satisfy EUF-CMAT,sk.
It means that the formula on the left
hand side holds. As in t the secret key sk only occurs in key positions, we can simulate t by
sampling all names, performing applications of function symbols, and sometimes calling the
oracle Osign
to obtain a signature. t may also depend on attacker function symbols that have
access to an oracle Osign
that produces exactly the
T,sk
same distribution of t for any ﬁxed value of sk.
sk be the PTOM which:

. Thus, we can build a PTOM AOsign

T,sk -sound.

T,sk,Osign

sk

sk

Let BOsign
• simulates AOsign

T,sk , by sampling all names itself, except sk;

• for every call made by A to Osign
T,sk
the case query the signing oracle to get the signature, else fails.

with input m, B checks that T (M ) holds, and if it is

sk

The probability distribution of BOsign

also
produces an output o which violates the EUF-CMAT,sk axiom. We thus have that o is a
valid signature, and is either not well tagged or does not correspond to a sub-term of t.

is exactly the same as AOsign

sk , so BOsign

T,sk,Osign

As all calls to Osign

made by B either correspond to a well tagged message or to a sub
term of t, we know that o does not correspond to a signature produced by the signing oracle.
BOsign
is thus an attacker which given access to a signing oracle can produce a signature for a
message not signed by the oracle, i.e., an attacker which can win the EUF-CMA axiom.

sk

sk

sk

11 Computational Soundness of the logic

11.1 Protocols

Given a protocol P , we reuse from [11] the deﬁnition of Φ(fold(P )) which we will denote tP .
It is only needed for technical proofs. We remark here that with the notations of [11], we
would have ρ1 = ρs and ρ2 = ρr.

The correction of the term representing a protocol with respect to the protocol oracles is

given by the following Lemma.

Lemma 28. Given a protocol P (which is action deterministic), a functional model Mf , an
oracle O, a security parameter η ∈ N, an history tape θ = ∅, tP = t1
P , σ := {x1 (cid:55)→
d1, . . . , xn (cid:55)→ dn} an assignment of the free variables in tP to D, for every ρs, ρr, ρO,

P , . . . , tn

[[t1

P ]]σ,η

ρs,ρr,ρO

, . . . , [[tn

P ]]σ,η

ρs,ρr,ρO

=

OP (ρs, ∅)(d1(ρs, ρr, η, ρO)), . . . , OP (ρs, d1(ρs, ρr, η, ρO), . . . , dn−1(ρs, ρr, η, ρO))(dn(ρs, ρr, η, ρO))

Proof. While straightforward, the proof relies on the deﬁnitions of protocol execution in a
model deﬁned in [11] and the soundness of the folding, which we do not recall here. We
extend Mf into a computational model M in such a way that

[[gi]]([[t1

P ]]σ,η

ρs,ρr,ρO

, . . . , [[ti−1

ρs,ρr,ρO

, ρr) = di(ρs, ρr, η, ρO)

for i = 1, . . . , n. We then have [[tP ]]M = [[t1

ρs,ρr,ρO , . . . , [[tn

P ]]σ,η

ρs,ρr,ρO

.

P ]]σ,η
P ]]σ,η

51

The folding soundness from [11] implies that P ∼M fold(P ). The proof actually im-
plies pointwise equality of the executions of P and fold(P ) in M. If we denote ψ(P ) (resp
ψ(fold(P ))) the sequence of outputs of the execution of P (resp fold(P )) in this model, we
thus have that ψ(P ) = ψ(fold(P )).

We directly have by deﬁnition of the tP that [[tP ]]M = [[Φ(fold(P )]]M = ψ(fold(P )).
Finally, by construction of OP which emulates exactly the execution of P we have ψ(P ) =
OP (ρs, ∅)(d1(ρs, ρr, η, ρO)), . . . , OP (ρs, d1(ρs, ρr, η, ρO), . . . , dn−1(ρs, ρr, η, ρO))(dn(ρs, ρr, η, ρO))
which concludes the proof.

11.2

Introduction of attacker’s functions

As in [11], we may replace the variables occurring in the protocol P (or its folding tP ) with
terms that include the attacker functions g ∈ G.

If tP = t0

P , . . . , tn
P

, we let (cid:102)tP = (cid:102)t0

P , . . . , (cid:102)tn
P

be the sequence of terms deﬁned by:

• (cid:102)t0

P = t0

P {x0 (cid:55)→ g0()} and φP

0 = ∅

• (cid:103)ti+1

P = ti+1

1 ), . . . , xi+1 (cid:55)→ gi+1(φP
We then denote σP the substitution {x0 (cid:55)→ g0(), x1 (cid:55)→ g1(φP

P {x0 (cid:55)→ g0(), x1 (cid:55)→ g1(φP

i+1)} and φP
1 ), . . . , xn (cid:55)→ gn(φP

i+1 = φP
n )}.

i , (cid:103)ti+1
P

There is exactly one attacker function for every message produced by the protocol, and the
function symbol are deﬁned independently from the protocol.The functions are placeholder
for the attacker actions, whom we give the previous answers he may have obtained in the
protocol.

Example 11.1. We consider the protocol which for a given key sk, will allow the at-
tacker to perform one decryption and will then output an encryption. We may have tP =
dec(x, sk), enc(y, r, sk), where x and y are the two expected inputs. Then (cid:102)tP = dec(g0()), sk), enc(g1(dec(g0()), sk), r, sk).
When we interpret this term, the attacker can choose the evaluation of g0 and g1. He can at
ﬁrst provide the protocol with a message and obtain its decryption, and can then compute a
new message, maybe based on the previous decryption he obtained.

Once we have ﬁxed the cryptographic library, and we consider two protocols P and Q, a
computational such that (cid:102)tP (cid:54)∼ (cid:102)tQ means that we have multiple PPTOMs which can compute
messages so that in the end, a ﬁnal PPTOM can distinguish the two protocols. We may from
those machines reconstruct a single machine, which is an attacker against P ∼=O Q. Conversely,
an attacker against P ∼=O Q may be split into multiple machines, so that a machine computes
the next message given by the attacker to the protocol, those machines providing in the end
a computational model such that (cid:102)tP (cid:54)∼ (cid:102)tQ.

Formally, we have the computational soundness of our oracle indistinguishability.

Lemma 29. Given two protocols P, Q, random tapes ρr, ρs, a cryptographic library Mf and
an oracle O, we have:

∀M ⊃ Mf . M |=O (cid:102)tP ∼ (cid:102)tQ
⇔
P ∼=O Q

We ﬁnally have a result of computational soundness. We write Ax |= φ if the set of

formulas Ax and the formula ¬φ are inconsistent.

52

Theorem 6. Given P, Q two protocols, O an oracle, A a set of axioms ,Mf a cryptographic
library we assume that:

• A is O-sound w.r.t F = {M ⊃ Mf }

• A |= (cid:102)tP ∼ (cid:102)tQ

Then P ∼=O Q

Proof. Let us assume that we have a distinguisher on AO,OP ?Q and that A is O-sound.

With Lemma 29 we have a computational model M ⊃ Mf such that M |=O (cid:102)tP (cid:54)∼ (cid:102)tQ.
As A is O-sound, we also have M |=O A, and this contradicts the fact that the formulas are
inconsistent.

We reduce computational indistinguishability to an inconsistency proof on the one hand

and a soundness proof of the axioms on the other hand.

12 Extension to the Model for Unbounded Replication

Recall that for unbounded replications, we used notations such as x /∈ s, for inﬁnite sequences
of names s. While the previous extension is enough to handle our composition results, we need
for our applications to key exchanges to be able to express formally those predicates. To this
end, for any name n of arity l, we give a formal interpretation to n, that intuitively models
the sequence of names n1,...,1, . . . , nr1,...,rl

of length polynomial in the security parameter.

We deﬁne the syntax and provide variations of the axioms that can be used to reason
in this context. We then provide the concrete semantics so that these axioms are sound as
technical details.

We provide a way to support inﬁnite sequences in the CCSA logic, but note that our
composition framework does not always require inﬁnite sequences. When considering basic
key exchanges, it is enough to use coﬁnite sequences. Basically, if the property

KE0[if xI

lsid = lsidR

0 then out(k) else out(xI

0), if xR

lsid = lsidI

0 then out(k) else out(xR

0 )]

holds even when the attacker can simulate corrupted sessions, it is enough to derive the
security of multiple sessions. It is interesting, as this property does not rely on inﬁnite se-
quences.

To understand this, let us brieﬂy consider a basic unsigned Diﬃe Hellman key exchange.
It must of course not verify the previous property. The exchange shares are ga0, gb0. To
break the previous property, we can give as a share to I the correct gb0, I will then produce
depending on the side k or ga0b0. If we provide R with ga0 × ga0, R does not believe to be
paired with I and it then always output as key g2a0b0. One can then easily distinguish if the
output of R is the square of the output of I.

Basically, this stems from the fact that always outputting the actual key leaks information

to the attacker when agents are not paired together.

For key exchanges with key conﬁrmation, we wish to test the real or random before we
have any authentication (as the authentication may come from the key conﬁrmation). So if
we always leak the key of the agent, the property will not be veriﬁed. However, we do need to
leak the key to enable to go from one session to multiple sessions (to give the attacker enough
information for the simulatability). The idea is then, as expressed in the previous Theorems,

53

to only leak the key when two “honest” parties are paired together. Else, we execute the
key conﬁrmation, which should fail. Here, we have an explicit need to be able to test which
sessions are honest, whether they are corrupted or not, and this for an unbounded number of
sessions. Hence the need for a test based on inﬁnite sequences.

Syntax Recall that names are deﬁned with an arity, where a name n of index arity l can
be indexed by l integers, yielding a distinct copy of the name for each indexes. Moreover, in
a protocol, the index variables occurring in names must all be bound through a parallel or a
sequential binder, and thus once we consider the term corresponding to the protocol in the
CCSA logic, all names appear without index variables.

For any name n of index arity l, the syntax of terms in the CCSA logic only contained all
for k1, . . . , kl ∈ N as symbols of arity 0 (a constants of the term algebra).
of arity 0. We also provide

the copies nk1,...,kl
For each name n, we add to the syntax of terms the symbol seqn
a function symbol ∈ using inﬁx notation, so that t ∈ seqn

is now in the syntax.

Axioms The classical α-renaming axiom still holds, but all copies of a name are renamed
at once. Thus, for any sequences of terms t, and any names n, n(cid:48) of index arity l such that n(cid:48)
does not occur in t, we have:

(1) t ∼ t{seqn (cid:55)→ seqn(cid:48)} ∪ {nk1,...,kl (cid:55)→ n(cid:48)

k1,...,kl

| k1, . . . , kl ∈ N}

Furthermore, we also provide axioms that allow to reason about the membership predicate,

deﬁned as:

(2) nk1,...,kl ∈ seqn ∼ true for any name n and all k1, . . . , kl ∈ N;
(3) n(cid:48)

∈ seqn ∼ false for any name n(cid:48) distinct of n and all k1, . . . , kl ∈ N.
Remark that as ∈ is a boolean function symbol, it is in contradiction with its negation

k1,...,kl

and we trivially have that that for any term t and name n,

t ∈ seqn ∧ t /∈ seqn ∼ false

This is actually what is used in our proofs of indistinguishability, as tagged oracles in our
applications provide messages m such that we have f (m) ∈ seqn
for some function f , and the
security property raises bad if f (m) /∈ seqn

.

Semantics The idea is that seqn
should model all sequences seqn = {n1, . . . , np(η)} for any
polynomial p. Then, if an indistinguishability holds for all such sequences for all polynomials,
it also holds when the polynomial is bigger than the running time of the distinguisher, and
the sequence then models an inﬁnite sequence. To model this, the interpretation of a term
t may now depend on some polynomial p with one indeterminate and with positive integer
coeﬃcients given to the PTTMs, and the interpretation is denoted [[t]]η,σ

.

The indistinguishability predicate ∼ is now interpreted as indistinguishability for all dis-

M,p,ρs,ρr,ρO

tinguishers and all polynomials p. Deﬁnition 20 now becomes:

Deﬁnition 30. Given a computational model M, including an oracle O, two sequences of
terms t, u, and an assignment σ of the free variables of t, u to ground terms, we have M, σ |=O

54

t ∼ u if, for any strictly increasing polynomial p and every polynomial time oracle Turing
machine AO,

|Pρs,ρr,ρO {AO(p,ρs,ρO)([[t]]σ,η

M,p,ρs;ρr;ρO

−Pρs,ρr,ρO {AO(p,ρs,ρO)([[u]]σ,η

, ρr, 1η) = 1}

M,p,ρs;ρr;ρO

, ρr, 1η) = 1}|

is negligible in η. Here, ρs, ρr, ρO are drawn according to a distribution such that every ﬁnite
preﬁx is uniformly sampled.

So, we can now assume that the interpretation of terms may depend on a polynomial p.
We previously assumed for a name ni, that the cryptographic library was providing a distinct
for each k ∈ N. However, to
Turing Machine for each copy of the name, i.e., a machine Ank
build a machine that can interpret seqn
, all the copies of the name must be extracted in a
uniform way, so that it is possible to collect all of them in polynomial time. To this end, we
now consider that a cryptographic library provides, for each name ni
of index arity l, a Turing
Machine An that takes as input the security parameter, the random tape ρS and l integers,
and returns a sequence of bitstrings of length η extracted from ρs. Then, the interpretation
, with k1, . . . , kl ∈ N is, given M, η, σ, ρs , ρO and ρr.
of the name nk1,...,kl

[[nk1,...,kl]]η,σ

M,p,ρs,ρr,ρO

:= An(1η, ρs, k1, . . . , kl)

The set of all the An should use distinct parts of the random tape ρs, and each An should
return distinct parts of the tape for each sequence of integers given as integers. This can be
done for instance if ρs is seen as a folding of random tapes ρs,n in a single tape, such that
each An only accesses bits corresponds to ρs,n through the inverse folding (this essentially
corresponding to bijective mappings from Nk to N). Then, for each sequence of integers
k1, . . . , kl, An extracts from ρs,n a unique sequence of bits by computing a bijection f from
Nl to N, and extracting the bitstrings of length η at position η × f (k1, . . . , kl).
Using this new interpretation for names, we now deﬁne the semantics of seqn

, for any name

n of index arity l, as, given M (that now contains a polynomial p), η, σ, ρs, ρO and ρr,

[[seqn]]η,σ

M,p,ρs,ρr,ρO

:= Aseqn(1η, p, ρs)

where Aseqn

is the machine that:

• contains l nested loops over the l variables c1, . . . , cl all ranging from 1 to p(η);

• at each iteration, simulate An(1η, ρs, c1, . . . , cl) and appends its result to the output

tape.

Remark that given a model M, and thus the machine An, we completely ﬁx the machine Aseqn
.
will produce the sequence of bitstring corresponding to the interpretation
Essentially, Aseqn
of n1,...,1, . . . , np(η),...,p(η).

The CCSA axioms presented previously are still sound in this semantics. Essentially, this
is because when the axiom scheme does not depend on any seqn
in
terms satisfying the guards of the scheme can be simulated by an attacker who samples p(η)
randoms.

, all the occurrences of seqn

Lemma 31. For any computational model in which the interpretation of sign is EUF-CMA,
any name sk, EUF-CMAT,sk is Osign
T,sk -sound even for terms that may depend on some seqn.

55

Proof. We have a term t, a computational model and a polynomial p such that the interpre-
are of length p(η) contradicts the EUF-CMAT,sk axiom.
tation of t where all sequences seqn
The proof is exactly the same as Proposition 27, as we can once again from t build a Turing
Machine that samples all names but sk (and may thus sample p(η) names for each sequence),
and is then able to simulate all operations of t.

This means that we can safely consider a version of EUF-CMAT,sk where for instance
and still have the soundness of the axiom. Remark that this

T (x) is of the form x ∈ seqn
proof would hold similarly for other cryptographic axioms.

We however have to prove the soundness of the axioms that are speciﬁc to seq.

Proposition 32. Axioms (1),(2) and (3) are sound in all models where the interpretation of
∈ is given by the machine A∈(1η, x1, x2) that checks if x1 is a bitstring of length η and returns
true if and only if x1 is a sub-string of x2 starting at a position which is a multiple of η.

Proof.

1. The alpha-renaming axiom is sound, unconditionally. This is similar to the classical
CCSA logic alpha-renaming axiom, which holds as all randomness for a given name
(of any arity) are completely independent and uniform. Replacing all occurrences of a
name by a another fresh one thus yields exactly the same distribution. In essence, we
replace in the interpretation of t all occurrences of An and Aseqn
by An(cid:48) and Aseqn(cid:48)
.
As the machines for n(cid:48) did not occur previously in the interpretation of t, we indeed
have that the machines of n and of n(cid:48) produce the same independent distribution for
the interpretation of t.

2. Given nk1,...,kl

and seqn

, we have for any polynomial p strictly increasing that for η large
enough, ki ≤ p(η) for 1 ≤ i ≤ l. Thus, for η large enough, the interpretation of seqn
contains the result of An(1η, ρs, k1, . . . , kl) (simulated by Aseqn
), and A∈ always output
true. The advantage of any attacker then becomes 0 which is negligible.

3. The probability of collision between two sequences of bitstrings of length η is 1

any polynomial p, as seqn
independent uniform sampling of length η, the probability that n(cid:48)
at a position which is a multiple of η is the probability 1 − (1 − 1
answer true with only a negligible probability.

is a uniform sampling of length p(η) × η, and n(cid:48)

2η . For
is an
occurs in seqn
k1,...,kl
2η )p(η). Thus, A∈ will

k1,...,kl

As the interpretation A∈ given in the previous proposition corresponds to the interpreta-
tion required in the application to key exchanges (Section 6), we can indeed use those axioms
in proofs of key exchange security.

References

[1] R. Canetti, Universally Composable Security: A New Paradigm for Cryptographic

Protocols, 2000. [Online]. Available: http://eprint.iacr.org/2000/067

56

[2] R. Canetti and T. Rabin, “Universal Composition with Joint State,” in Advances in
Cryptology - CRYPTO 2003, ser. Lecture Notes in Computer Science, D. Boneh, Ed.
Springer Berlin Heidelberg, 2003, pp. 265–281.

[3] M. Backes, B. Pﬁtzmann, and M. Waidner,

“The Reactive Simulatability (RSIM)
Framework for Asynchronous Systems,” Inf. Comput., vol. 205, no. 12, pp. 1685–1720,
Dec. 2007. [Online]. Available: http://dx.doi.org/10.1016/j.ic.2007.05.002

[4] D. Hofheinz and V. Shoup, “GNUC: A New Universal Composability Framework,”
[Online]. Available:

Journal of Cryptology, vol. 28, no. 3, pp. 423–508, Jul. 2015.
https://doi.org/10.1007/s00145-013-9160-y

[5] M. Backes, M. Dürmuth, D. Hofheinz, and R. Küsters, “Conditional reactive simulatabil-

ity,” Int. J. Inf. Sec., vol. 7, no. 2, pp. 155–169, 2008.

[6] J. Camenisch, S. Krenn, R. Küsters, and D. Rausch, “iUC: Flexible Universal Compos-

ability Made Simple,” Tech. Rep., 2019.

[7] U. Maurer, “Constructive cryptography - A new paradigm for security deﬁnitions and
proofs,” in TOSCA, ser. Lecture Notes in Computer Science, vol. 6993. Springer, 2011,
pp. 33–56.

[8] C. Brzuska, M. Fischlin, N. P. Smart, B. Warinschi, and S. C. Williams, “Less is
more: relaxed yet composable security notions for key exchange,” International Journal
of Information Security, vol. 12, no. 4, pp. 267–297, Aug. 2013. [Online]. Available:
https://doi.org/10.1007/s10207-013-0192-y

[9] B. Blanchet, “Composition Theorems for CryptoVerif and Application to TLS 1.3,” in
31st IEEE Computer Security Foundations Symposium (CSF’18). Oxford, UK: IEEE
Computer Society, Jul. 2018, pp. 16–30.

[10] C. Brzuska, A. Delignat-Lavaud, C. Fournet, K. Kohbrok, and M. Kohlweiss, “State
separation for code-based game-playing proofs,” in ASIACRYPT (3), ser. Lecture Notes
in Computer Science, vol. 11274. Springer, 2018, pp. 222–249.

[11] G. Bana and H. Comon-Lundh, “A computationally complete symbolic attacker for
equivalence properties,”
in Proceedings of the 21st ACM Conference on Computer
and Communications Security (CCS’14), G.-J. Ahn, M. Yung, and N. Li, Eds.
Scottsdale, Arizona, USA: ACM Press, Nov. 2014, pp. 609–620. [Online]. Available:
http://www.lsv.ens-cachan.fr/Publis/PAPERS/PDF/BC-ccs14.pdf

[12] T. Ylonen and C. Lonvick, “The Secure Shell (SSH) Transport Layer Protocol.” [Online].

Available: https://tools.ietf.org/html/rfc4253

[13] R. Küsters and D. Rausch, “A Framework for Universally Composable Diﬃe-Hellman
IEEE

Key Exchange,” in IEEE 38th Symposium on Security and Privacy (S&P 2017).
Computer Society, 2017, pp. 881–900.

[14] G. Scerri and S.-O. Ryan,
Computational Security.”
Available: https://hal.inria.fr/hal-01417123

“Analysis of Key Wrapping APIs: Generic Policies,
IEEE Computer Society, Jun. 2016, pp. 281–295. [Online].

57

[15] H. Comon and A. Koutsos,

in Proceedings of

Protocols,”
Symposium (CSF’17), B. Köpf and S. Chong, Eds.
USA: IEEE Computer Society Press, Aug. 2017, pp. 100–114.
http://ieeexplore.ieee.org/document/8049714/

“Formal Computational Unlinkability Proofs of RFID
the 30th IEEE Computer Security Foundations
Santa Barbara, California,
[Online]. Available:

[16] G. Bana, R. Chadha, and A. K. Eeralla, “Formal Analysis of Vote Privacy Using
Computationally Complete Symbolic Attacker,” in Computer Security - 23rd European
Symposium on Research in Computer Security, ESORICS 2018, Barcelona, Spain,
[Online]. Available:
September 3-7, 2018, Proceedings, Part II, 2018, pp. 350–372.
https://doi.org/10.1007/978-3-319-98989-1_18

[17] “ISO/IEC 9798-3:2019,

3: Mechanisms using digital
//www.iso.org/standard/67115.html

IT Security techniques – Entity authentication – Part
https:

signature techniques.”

[Online]. Available:

[18] C. Brzuska, M. Fischlin, B. Warinschi, and S. C. Williams,

“Composability of
Bellare-rogaway Key Exchange Protocols,” in Proceedings of the 18th ACM Conference
on Computer and Communications Security, ser. CCS ’11. New York, NY, USA: ACM,
2011, pp. 51–62. [Online]. Available: http://doi.acm.org/10.1145/2046707.2046716

[19] M. Fischlin and F. Günther, “Multi-Stage Key Exchange and the Case of Google’s
QUIC Protocol,” in Proceedings of the 2014 ACM SIGSAC Conference on Computer
ser. CCS ’14. New York, NY, USA: ACM,
and Communications Security,
2014, pp. 1193–1204, event-place:
[Online]. Available:
http://doi.acm.org/10.1145/2660267.2660308

Scottsdale, Arizona, USA.

[20] R. Küsters and M. Tuengerthal,

in Proceedings of

Session Identiﬁers,”
and Communications Security,
2011, pp. 41–50, event-place: Chicago,
//doi.acm.org/10.1145/2046707.2046715

“Composition Theorems Without Pre-established
the 18th ACM Conference on Computer
ser. CCS ’11. New York, NY, USA: ACM,
http:

[Online]. Available:

Illinois, USA.

[21] N. Durgin, J. Mitchell, and D. Pavlovic, “A Compositional Logic for Proving Security
Properties of Protocols,” J. Comput. Secur., vol. 11, no. 4, pp. 677–721, Jul. 2003.
[Online]. Available: http://dl.acm.org/citation.cfm?id=959088.959095

[22] A. Datta, A. Derek, J. C. Mitchell, V. Shmatikov, and M. Turuani, “Probabilistic
Polynomial-Time Semantics for a Protocol Security Logic,” in Automata, Languages and
Programming, ser. Lecture Notes in Computer Science, L. Caires, G. F. Italiano, L. Mon-
teiro, C. Palamidessi, and M. Yung, Eds. Springer Berlin Heidelberg, 2005, pp. 16–29.

[23] C. Cremers, “On the Protocol Composition Logic PCL,” in Proceedings of the 2008 ACM
Symposium on Information, Computer and Communications Security, ser. ASIACCS
’08. New York, NY, USA: ACM, 2008, pp. 66–76, event-place: Tokyo, Japan. [Online].
Available: http://doi.acm.org/10.1145/1368310.1368324

[24] S. C. Williams, “Analysis of the SSH Key Exchange Protocol,” in Cryptography and
Coding, ser. Lecture Notes in Computer Science, L. Chen, Ed. Springer Berlin Heidelberg,
2011, pp. 356–374.

58

[25] D. Cadé and B. Blanchet, “From Computationally-Proved Protocol Speciﬁcations to Im-
plementations and Application to SSH,” Journal of Wireless Mobile Networks, Ubiquitous
Computing, and Dependable Applications (JoWUA), vol. 4, no. 1, pp. 4–31, Mar. 2013.

[26] B. Blanchet, “CryptoVerif: A Computationally Sound Mechanized Prover for Crypto-
graphic Protocols,” in Dagstuhl seminar "Formal Protocol Veriﬁcation Applied", Oct.
2007.

[27] V. Cortier and S. Delaune, “A method for proving observational equivalence,” in 2009

22nd IEEE Computer Security Foundations Symposium.

IEEE, 2009, pp. 266–276.

[28] M. Arapinis, V. Cheval, and S. Delaune, “Verifying Privacy-Type Properties in a Modular
Way,” in 2012 IEEE 25th Computer Security Foundations Symposium, Jun. 2012, pp. 95–
109.

[29] K. G. Paterson, J. C. N. Schuldt, M. Stam, and S. Thomson, “On the Joint Security of
Encryption and Signature, Revisited,” in Advances in Cryptology – ASIACRYPT 2011,
ser. Lecture Notes in Computer Science, D. H. Lee and X. Wang, Eds. Springer Berlin
Heidelberg, 2011, pp. 161–178.

A Messages

Protocols and oracles produce messages depending on names, randomness and some crypto-
graphic primitives. We deﬁne here formally a syntax and a semantic for such messages.

A.1 Syntax of messages

We build terms over F a set of function symbols, which will represent the honest function
symbols (encryption symbol, decryption), a set of variables X (unknown terms), and a set of
names N , intended to denote respectively the secret and public names. Names may be sorted,
for instance to capture what is a secret key and what is a randomness.

Example A.1. We deﬁne F := {enc/3, dec/2} an encryption scheme, N = {k, r} a secret key,
a key and a randomness. Then, with mess an arbitrary term t1 = enc(mess, k, r) represents
the encryption of an arbitrary message, and dec(t1, k) represents its decryption.

A.2 Semantics of terms

We wish to describe protocols (i.e messages) as terms, whose interpretation must be ﬁxed and
deterministic. This allows us to obtain an interpretation, which is uniform, and we provide
this interpretation with explicit randomness.

Messages will thus be interpreted as deterministic PPT, which takes as inputs:

• ρs, a random tape for secret names (e.g secret keys)

• 1η, the security parameter

Let D be the set of such PPT, called messages.
A cryptographic library Mf is a mapping [[·]]Mf

that interprets the function symbols,
names and closed terms in the set of messages. The index Mf is omitted unless there is some
ambiguity, in order to avoid overloaded notations. [[·]]M is deﬁned as follows:

59

1. if n ∈ N , n is interpreted as the machine [[n]]M = An that on input (1η, ρs) extracts a
word of length η from the tape ρs. Diﬀerent names should extract disjoint parts of the
random tape.

2. if f ∈ F, then, with d1, ..., dn ∈ Dn a sequence of messages, [[f ]]M(d1, . . . , dn) is the

machine such that, on input (1η, ρs),

[[f ]]M(d1, . . . , dn)(1η, ρs) := Af (d1(1η, ρs, ρO), . . . , dn(1η, ρs))

Intuitively, we simply compose the machine, which represents f , with all the machines
representing its inputs. f can only be deterministic, any randomness must be explicitly
given as an argument.

Given an assignment σ of variables to messages in D, the random tape ρs, and a security
parameter η ∈ N, for each f ∈ F a Turing machine Af , the (evaluation of the) interpretation
of a term t is inductively deﬁned as follows:

• [[n]]η,σ
ρs

:= An(1η, ρs) if n ∈ N

• [[x]]η,σ

ρs = (xσ)(1η, ρs, ) if x ∈ X

• [[f (u)]]η,σ

ρs = Af ([[u]]η,σ

ρs ) if f ∈ F

Such an interpretation of terms of course depends on the functional model Mf : we may

add Mf as an index of the semantic bracket if needed.

On the contrary, if the parameters are clear from the context we may simply write [[]] for
, or provide with the relevant arguments only.

[[]]σ
ρs

Example A.2. Let us consider N = {sk, m, r} and F = {enc}. We may deﬁne Aenc as a TM
implementing some encryption function, and Ask as the TM which extracts the η ﬁrst bits of
ρs, and similarly for m and r with the following bits of ρs. In this cryptographic library, the
term enc(m, r, sk) will now be interpreted as the encryption of a random string by a random
string.

B Protocols

B.1 Protocol Algebra

The precise syntax of our process algebra is deﬁned in Figure 10.

B.2 Formal deﬁnition of a protocol execution

A protocol state is a pair ϕ, (P1, σ1)(cid:107) · · · (cid:107)(Pn, σn), where each Pi is a protocol, σi is an envi-
ronment binding variables to bit-strings (intuitively the attacker’s inputs), ϕ is a sequence of
bit-strings (intuitively the protocol outputs). The parallel operator is considered as associative
and commutative.

The semantics of elementary protocols assumes that, after an attacker input, the protocol
moves immediately as much as possible until it stops or waits for another input. Formally,
we deﬁne a relation −→ , that does not depend on the attacker, such that, for instance,
φ, (out(c, t).P, σ) −→ φ (cid:93) (c, [[t]]η,σ
ρs ), P, σ. σ (cid:93) ν is deﬁned such that all previously deﬁned

60

terms:

t

::= n
n(cid:126)i
x
f (t1, . . . , tn)

|
|
|

Pel

elementary protocols:
::= Pa
let x = t in Pel
|
in(c, x).Pel
|
out(c, m).Pel
|
if s = t then Pel else Pel
|
|
0
| ⊥

names
indexed names
variable
operation of arity n

an atomic protocol
variable binding
input
output
conditionals

protocols:
P, P (cid:48)

::= Pel
|
|
|
|
|
|

Pel; P
P (cid:107)P (cid:48)
(cid:107)i≤N P
(cid:107)iP
;i≤N Pel
;i Pel

sequential composition
parallel composition
parallel replication
unbounded replication
sequential replication
unbounded sequential replication

Figure 10: Protocol algebra

bindings in σ are overwritten by the ones in ν. In other words, in case of an output, we add to
the frame the interpretation of t, given the current assignment of its variables and a (secret)
random tape. We write

!−→ the reduction of a global state to its normal form w.r.t. −→ .

Given an adversary A, a sampling ρs of the names and a sampling ρr the attacker’s random
coins, for composed protocols, the operational semantics is given in Figure 11 and Figure 12
in the SOS style.

Note that a protocol with free variables may not be executed alone, but only in a context
where its variables have been deﬁned. Given P a protocol with free variables x1, . . . , xk
and n1, . . . , nk a sequence of names, we may write P (n1, . . . , nk) as a short cut for let x1 =
n1 in . . . let xk = nk in P (x1, . . . , xk).

n] is a protocol built over the protocol alge-
Deﬁnition 33 (Context). A context C[_
bra, where some elementary protocols are replaced with holes. Each hole _
can occur only
i
once in the context. Given the (elementary) protocols P1, . . . , Pn, C[P1, . . . , Pn] is then the
protocol obtained when replacing each hole by the corresponding protocol.

1, . . . , _

B.3 Formal deﬁnition of protocol oracles

Deﬁnition 34 (Protocol Oracle). A protocol oracle is deﬁned as the previous stateless oracles,
except that it has an additional history input, and only use w from its input (w, r, s). The
protocol oracle machines also have an additional history tape, that cannot be accessed by the
machine: it is only passed to the oracle, which also records the input queries on the history

61

Elementary protocols

ϕ, (if s = t then P else Q, σ) −→ ϕ, P, σ

ϕ, (if s = t then P else Q, σ) −→ ϕ, Q, σ

if [[s]]η,σ

ρs = [[t]]η,σ
ρs

if [[s]]η,σ
ρs

(cid:54)= [[t]]η,σ
ρs

ϕ, P, σ (cid:93) {x (cid:55)→ A(ρr, ϕ)} !−→ ϕ(cid:48), P (cid:48), σ(cid:48)

ϕ, in (c, x).P, σ −→
A

ϕ(cid:48), P (cid:48), σ(cid:48)

ϕ, out(c, s).P, σ −→ ϕ (cid:93) {[[s]]η,σ

ρs }, P, σ

ϕ, let x = t in P, σ −→ ϕ, P, σ (cid:93) {x (cid:55)→ [[t]]η,σ
ρs }

Sequential compositions

ϕ, P, σ !−→ ϕ(cid:48), P (cid:48), σ(cid:48)
ϕ(cid:48), P (cid:48), σ(cid:48)
ϕ, P, σ −→
A

ϕ, P, σ −→
A
ϕ, P ; Q, σ −→
A

ϕ(cid:48), P (cid:48), σ(cid:48)
ϕ(cid:48), P (cid:48); Q, σ(cid:48)

ϕ, 0; Q, σ −→
A

ϕ, Q, σ

ϕ, ⊥; Q, σ −→
A

ϕ, ⊥, σ

Variable bindings are passed
to Q when the preﬁx execu-
tion succeeds
Q cannot be executed when
the preﬁx execution fails

ϕ, ;i≤N P, σ −→
A

ϕ, P {i (cid:55)→ 1}; · · · ; P {i (cid:55)→ N }, σ

ϕ, ;i P, σ −→
A

ϕ, ;i≤A(ρr,ϕ) P, σ

Figure 11: Operational semantics of elementary protocols and sequential compositions

62

Protocols

ϕ, (0, σ)(cid:107)E −→
A

ϕ, E

Parallel processes are outside
of the scope of local bindings

ϕ, (⊥, σ)(cid:107)E −→
A

ϕ, E

ϕ, P, σ −→
A
ϕ, (P, σ)(cid:107)E −→
A

ϕ(cid:48), P (cid:48), σ(cid:48)
ϕ(cid:48), (P (cid:48), σ(cid:48))(cid:107)E

The interactions between a
process P and processes run-
ning in parallel are computed
by the attacker

ϕ, P (cid:107)Q, σ −→
A

ϕ, (P, σ)(cid:107)(Q, σ)

ϕ, (cid:107)i≤N P, σ −→
A

ϕ, P {i (cid:55)→ 1}(cid:107) · · · (cid:107)P {i (cid:55)→ N }, σ

ϕ, ((cid:107)iP )(cid:107)E, σ −→
A

ϕ, ((cid:107)i≤A(ρr,ϕ)P )(cid:107)E, σ

Figure 12: Operational Semantics of protocols

tape. We write AOP (ρs) for a protocol oracle Turing machine whose initial history tape is
empty and such that OP does not use the random tape ρO.

We may generalize in the natural way the deﬁnition of protocol oracle machines to support

any number of oracles where each protocol oracle has a distinct additional history tape.

We are now ready, given a protocol P , to deﬁne the protocol oracle OP .

Deﬁnition 35. Given a protocol P (which is action deterministic), a functional model Mf ,
a security parameter η ∈ N and a random tape ρs, OP is the protocol oracle, which, given ρs
and an history θ = {o1, ..., on} ∈ ({0, 1}∗)n, on a query m:

• appends m to the history tape;

• executes the protocol P according to the semantics, using as inputs the history;

• return the ﬁnal output produced by the protocol.

We extend the deﬁnition of PPTOM with:

• A protocol oracle input tape

• A protocol oracle history tape

• A protocol oracle output tape

The machine may call the protocol oracle OP by writing on its input tape some content
m, and there is then a single move to the current conﬁguration to a conﬁguration in which the
history tape has been extended with the content of the input tape, and the protocol oracle
output tape has been set to the output of OP (ρs, θ)(m).

63

We will often need to consider that we may have several protocol oracles for one PPTOM.
We thus deﬁne a way to compose together oracles and protocol oracles. Protocol oracles can
be merged together only if their respective protocols do not share input channels.

Deﬁnition 36. For any n and protocols P1, . . . , Pn such that ∀1 ≤ i < j ≤ n.C(Pi)∩C(Pj) = ∅,
we deﬁne the oracle < OP1, . . . , OPn > (ρs, θ) which on input query:

• check if its input is of the form query := (channel, mess);

• computes i such that channel ∈ C(Pi), and reject if there is no such i;

• computes θi the projection of its history such that θi = {(channel, mess) ∈ θ|channel ∈

C(Pi)};

• return the value of OPi(ρs, θi)(mess).

We will often write AOP1 ,...OPn (ω, ρr) for A<OP1 ,...OPn >(ω, ρr).
We may then use PPTOM with multiple oracles and multiple protocol oracles, written

AO1,...,Ok,OP1 ,...OPn (ω, ρr) for A<O1,...Ok>,<OP1 ,...OPn >(ω, ρr).

C A case study : signed DDH

We apply our framework to the ISO 9798-3 protocol. It was proven UC composable in [13].
With our framework, it could be composed even with an oracle which uses the same long term
secret. We also note that our proof could be mechanized, as it is performed in a ﬁrst order
logic. With only one session and if we prioritise the outputs, there are three interleaving, with
corresponding frames φ3, ψ3 and χ3:

64

φ0 := pk(skI ), ga
φ1 := φ0, (pk(skR), gb, sign((g0(φ0), gb, g1(φ0)), skR))
φ2 := φ1, if checksign(g4(φ1), g2(φ1)) ∧ g3(φ1) = π2(getmess(g4(φ1))) then

if π1(getmess(g4(φ1))) = ga ∧ π3(getmess(g4(φ1))) = pk(skI ) then

sign((g3(φ1), ga, g2(φ1)), skI ), _
A

φ3 := φ2, if checksign(g5(φ2), g1(φ0) ∧ g0(φ0) = π2(getmess(g5(φ2))) then
if π1(getmess(g5(φ2))) = gb ∧ π3(getmess(g5(φ2))) = pk(skR) then

_

B.

ψ0 := φ0
ψ1 := ψ0, if checksign(g2(ψ0), g0(ψ0)) ∧ g1(ψ0) = π2(getmess(g2(ψ0))) then

if π1(getmess(g2(ψ0))) = ga ∧ π3(getmess(g2(ψ0))) = pk(skI ) then

sign((g1(ψ0), ga, g0(ψ0)), skI ), _
A

ψ2 := ψ1, (pk(skR), gb, sign((g3(ψ1), gb, g4(ψ1)), skR))
ψ3 := if checksign(g5(ψ2), g4(ψ1) ∧ g3(ψ1) = π2(getmess(g5(ψ2))) then

if π1(getmess(g5(ψ2))) = gb ∧ π3(getmess(g5(ψ2))) = pk(skR) then

_

B.

χ0 := φ0
χ1 := χ0, (pk(skR), gb, sign((g0(χ0), gb, g1(χ0)), skR))
χ2 := if checksign(g2(χ1), g1(χ0) ∧ g0(χ0) = π2(getmess(g2(χ1))) then

if π1(getmess(g2(χ1))) = gb ∧ π3(getmess(g2(χ1))) = pk(skR) then

_

B.

χ3 := χ2, if checksign(g5(χ2), g3(χ2)) ∧ g4(χ2) = π2(getmess(g5(χ2))) then

if π1(getmess(g5(χ2))) = ga ∧ π3(getmess(g5(χ2))) = pk(skI ) then

sign((g4(χ2), ga, g3(χ2)), skI ), _

A

C.1 Key exchange security

We show how to apply Corollary 1. We will use idI = skI , idR = skR, lsidI = ga and
lsidR = gb. Then, for any n we set s = a1, b1, . . . , an, bn. We deﬁne the functions:

T I (m, s) := ∃ai ∈ s, ∃A, A(cid:48)m = (A, gai, A(cid:48))
T R(m, s) := ∃bi ∈ s, ∃A, A(cid:48)m = (A, gbi, A(cid:48))

We then set OKE = Osign
elements in s.

T I ,skI ,s, Osign

T R,skR,s, Os, where Os simply reveals the exponents of the

We ﬁx KE(skI , skR, ai, bi)[_
We remark that proving at the end of the protocol that (kI , ga, olsid, oid) is indistinguish-
able to (k, ga, olsid, oid) is equivalent to proving that kI is indistinguishable from k, as the
other elements are public information.

R] = I(ai, skI )[_

I ](cid:107)I(bi, skR)[_

I , _

R].

To apply the Corollary, it remains to prove that:

1. ∀1 ≤ i ≤ N, (νai, idI , bi, idR.KE(skI , skR, ai, bi)[out(kI , gai, olsid, oid), out(kR, gbi, olsid, oid)]

is OKE simulatable)).

2. Ax is OKE sound.

65

3.

4.

5.

Ax |= φ3[g3(φ1)a, g0(φ0)b] ∼
φ3[

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then

out(k)
else if ¬ (cid:87)

bad

i g3(φ1) = gbi ∧ g2(φ1) = pk(skR) then

else out(g3(φ1)a)
,
if g0(φ0) = ga ∧ g1(φ0) = pk(skI ) then

out(k)
else if ¬ (cid:87)

bad

i g0(φ0) = gai ∧ g1(φ0) = pk(skI ) then

else out(g0(φ0)b)]

Ax |= ψ3[g1(ψ0)a, g3(ψ1)b] ∼
ψ3[

if g1(ψ0) = gb ∧ g0(ψ0) = pk(skR) then

out(k)
else if ¬ (cid:87)

bad

i g1(ψ0) = gbi ∧ g0(ψ0) = pk(skR) then

else out(g1(ψ0)a)
,
if g3(ψ1) = ga ∧ g4(ψ1) = pk(skI ) then

out(k)
else if ¬ (cid:87)

bad

i g3(ψ1) = gai ∧ g4(ψ1) = pk(skI ) then

else out(g3(ψ1)b)]

Ax |= χ3[g4(χ2)a, g0(χ0)b] ∼
χ3[

if g4(χ2) = gb ∧ g3(χ2) = pk(skR) then

out(k)
else if ¬ (cid:87)

bad

i g4(χ2) = gbi ∧ g3(χ2) = pk(skR) then

else out(g4(χ2)a)
,
if g0(χ0) = ga ∧ g1(χ0) = pk(skI ) then

out(k)
else if ¬ (cid:87)

bad

i g0(χ0) = gai ∧ g1(χ0) = pk(skI ) then

else out(g0(χ0)b)]

We have that Ax = EUF-CMA

T I ,F,skI ,s ∧ EUF-CMA

T R,F,skR,s ∧ DDHs,skI ,skR

is OKE-

sound thanks to Proposition 27.

The simulatability also instantly follows from the deﬁnitions, as the attackers as access to

the ai and bi, and can produce signatures on them (but only on them).

We only provide the proof for the most diﬃcult frame φ3, where the attacker has the most
knowledge for each computation. ψ3 and χ3 can be handled exactly the same way, except that
on applications of the EUF-CMA axioms, the attacker does not have the honest signatures
in the frame (as the order of the agents has been mixed up), which simplify the proof.

66

C.2 Proof for φ3
We from now on omit Ax.

C.2.1 Real or random of the key

The real or random goal is:

φ3[

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then

g3(φ1)a

else

g3(φ1)a

,
if g0(φ0) = ga ∧ g1(φ0) = pk(skI ) then

g0(φ0)b

else

g0(φ0)b

φ3[

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then

k
else

g3(φ1)a

∼

,
if g0(φ0) = ga ∧ g1(φ0) = pk(skI ) then

k
else

g0(φ0)b

]

]

There are by case disjunctions four possible cases, the ﬁrst one being:

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then
if g0(φ0) = ga ∧ g1(φ0) = pk(skI ) then

φ3[g3(φ1)a, g0(φ0)b]

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then
if g0(φ0) = ga ∧ g1(φ0) = pk(skI ) then

∼

φ3[k, k]

We can deﬁne the substitution τ := {g3(φ1) ← gb, g2(φ1), ← pk(skR), g0(φ0) ← ga, g1(φ0) ←

pk(skI )}, the goal then becomes: φ3[gab, gab]τ ∼ φ3[k, k]τ .

Note that a, b is not included in s, skI , skR, we can thus use the DDH axiom on them.
Looking at φ3τ , we also see that all occurences of a and b are of the form ga or gb. Thus
applying DDH directly gives us:

φ3[gab, gab]τ ∼ φ3[gc, gc]τ

We conclude by renaming of gc into k.

The second case is:

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then
if g0(φ0) (cid:54)= ga ∨ g1(φ0) (cid:54)= pk(skI ) then

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then
if g0(φ0) (cid:54)= ga ∨ g1(φ0) (cid:54)= pk(skI ) then

∼

φ3[g3(φ1)a, g0(φ0)b]

φ3[k, g0(φ0)b]

Here, we actually prove that we never go into the branch which reveals either the g3(φ1)a

or the k, thus yielding the equivalence.

We thus prove that:

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then
if g0(φ0) (cid:54)= ga ∨ g1(φ0) (cid:54)= pk(skI ) then

checksign(g4(φ1), g2(φ1))
∧g3(φ1) = π2(getmess(g4(φ1)))
∧π1(getmess(g4(φ1))) = ga
∧π3(getmess(g4(φ1))) = pk(skI )

∼

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then
if g0(φ0) (cid:54)= ga ∨ g1(φ0) (cid:54)= pk(skI ) then
false

67

We have by application of the equalities:

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then
if g0(φ0) (cid:54)= ga ∨ g1(φ0) (cid:54)= pk(skI ) then

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then
if g0(φ0) (cid:54)= ga ∨ g1(φ0) (cid:54)= pk(skI ) then

checksign(g4(φ1), g2(φ1))
∧g3(φ1) = π2(getmess(g4(φ1)))
∧π1(getmess(g4(φ1))) = ga
∧π3(getmess(g4(φ1))) = pk(skI )

∼

checksign(g4(φ1), pk(skR))
∧gb = π2(getmess(g4(φ1)))
∧π1(getmess(g4(φ1))) = ga
∧π3(getmess(g4(φ1))) = pk(skI )

We now apply EUF-CMA

T R,F,skR,s

to g4(φ1), so we either have g4(φ1) = sign((g0(φ0), gb, g1(φ0)), skR)

(the honest signature), which is a contradiction with g0(φ0) (cid:54)= ga and π1(getmess(g4(φ1))) =
ga, or the signature comes from the oracle and g4(φ1) = (A, gbi, A(cid:48)), in contradiction with
gb = π2(getmess(g4(φ1))).

We thus have:

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then
if g0(φ0) (cid:54)= ga ∨ g1(φ0) (cid:54)= pk(skI ) then

checksign(g4(φ1), pk(skR))
∧gb = π2(getmess(g4(φ1)))
∧π1(getmess(g4(φ1))) = ga
∧π3(getmess(g4(φ1))) = pk(skI )

if g3(φ1) = gb ∧ g2(φ1) = pk(skR) then
if g0(φ0) (cid:54)= ga ∨ g1(φ0) (cid:54)= pk(skI ) then

∼

false

And we conclude by transitivity.
Of the two remaining cases, one is symmetrical to the previous one, and the last one is

trivial.

C.2.2 Authentication

The goal is:

φ3[ if g3(φ1) (cid:54)= gb then

if ¬ (cid:87)

g3(φ1)a

i g3(φ1) = gbi ∧ g2(φ1) = pk(skR) then

i g3(φ1) = gbi ∧ g2(φ1) = pk(skR) then

φ3[ if ¬g3(φ1) = gb then

if ¬ (cid:87)
bad

,
if g0(φ0) (cid:54)= ga then
if ¬ (cid:87)

g0(φ0)b

i g0(φ0) = gai ∧ g1(φ0) = pk(skI ) then

∼

,
if g0(φ0) (cid:54)= ga then
if ¬ (cid:87)
bad

i g0(φ0) = gai ∧ g1(φ0) = pk(skI ) then

]

We prove that each condition is never true using the EUF-CMA axioms. The four cases

]

are symmetrical, we only prove the ﬁrst one:

if checksign(g4(φ1), g2(φ1)) ∧ g3(φ1) = π2(getmess(g4(φ1))) then
if π1(getmess(g4(φ1))) = ga∧
π3(getmess(g4(φ1))) = pk(skI ) then
if g3(φ1) (cid:54)= gb then
¬ (cid:87)

i g3(φ1) = gbi ∧ g2(φ1) = pk(skR)

∼
if checksign(g4(φ1), g2(φ1)) ∧ g3(φ1) = π2(getmess(g4(φ1))) then
if π1(getmess(g4(φ1))) = ga∧
π3(getmess(g4(φ1))) = pk(skI ) then
if g3(φ1) (cid:54)= gb then
false

68

By case disjunction g2(φ1) = pk(skR), the negative one being trivial, we must prove:

if checksign(g4(φ1), pk(skR)) ∧ g3(φ1) = π2(getmess(g4(φ1))) then
if π1(getmess(g4(φ1))) = ga∧
π3(getmess(g4(φ1))) = pk(skI ) then
if g3(φ1) (cid:54)= gb then
¬ (cid:87)
i g3(φ1) = gbi

∼
if checksign(g4(φ1), pk(skR)) ∧ g3(φ1) = π2(getmess(g4(φ1))) then
if π1(getmess(g4(φ1))) = ga∧
π3(getmess(g4(φ1))) = pk(skI ) then
if g3(φ1) (cid:54)= gb then
false

We now apply EUF-CMA

T R,F,skR,s

to g4(φ1), so we either have g4(φ1) = sign((g0(φ0), gb, g1(φ0)), skR)

(the honest signature), which is a contradiction with g3(φ1) (cid:54)= gb and g3(φ1) = π2(getmess(g4(φ1))),
or the signature comes from the oracle and g4(φ1) = (A, gbi, A(cid:48)),
¬ (cid:87)

i g3(φ1) = gbi. This conclude the proof.

in contradiction with

C.3 Conclusion for Signed DDH

We thus have the security of the signed DDH protocol.
If we want to use Corollary 2 to
compose it with for instance a record protocol RP := RPI (k)(cid:107)RPR(k), which simply exchange
encrypted messages using the exchanged key, and do not share any long term secret, it is trivial.
Indeed, without any shared secret, in(k); RPI (k)(cid:107)in(k); RPR(k) is simulatable without any
oracle, so we can take Op = ∅. This means that we have the ﬁrst set of hypothesis.

Now, RP would be proven secure with IND-CCA, and this can be proven easily, even if
many other session of RP with distinct keys are in parallel. So we can simply set Or as the
oracle which outputs all the ki,j and Ok as the oracle which output p, and obtain the multi
session security of RP , and the simulatability of the key exchange.

RP could be a single round trip enrypted exchange, or actually any number of round trip,

easily proved secure using Proposition 18.

D An application to SSH

D.1 Presentation of SSH

We only show here how the proof of security of SSH could be split up into smaller proofs
thanks to our framework, but we do not actually prove the smaller proofs. We will thus only
provide a high level point of view of SSH, not going into too many implementations details,
but rather focusing on the parts that represent a challenge for composition. SSH is a simple
key exchange which can be used to set up an authenticated and secret channel between a
user’s computer and a server, with ﬁrst an authentication of the server, and then an optional
authentication of the user, either through a password or a secret key. We provide in Figure 13
the basic SSH key exchange, with authentication through secret keys.

We can see that the indistinguishability of the key is not preserved through the protocol.
The diﬃculty of SSH is moreover that once a user has established a secure connection to a
server, he can from this server establish a secure connection to another server, while using the

69

P (skP, pk(skS))[_] :=

S(skS, pk(skP ))[_] :=

new a;
out(ga);
in(< B, pk(skS), sign >)
let k = Ba in
let sid = hash(< ga, B, k >) in
if checksign(sign, pk(skS))

∧ getmess(sign) = sid then
out(enc(sign(sid, skP ), k))
[_].

in(A);
new b;
let k = Ab in
let sid = hash(< A, gb, k >) in
out(< gb, pk(skS), sign(sid, skS) >)
in(enc(sign, k))
if checksign(sign, pk(skP ))
∧ getmess(sign) = sid then
[_].

SSH :=!P (skP, pk(skS))[0](cid:107)!S(skS, pk(skP ))[0]

Figure 13: Basic SSH key exchange

secure channel previously established to obtain the user credentials. We provide in Figure 14 a
model of the SSH with forwarding of agent (reusing the deﬁnitions of P and S from Figure 13),
where after a P is ran successufully, a F orwardAgent is started on the computer which can
receive on the secret channel a signing request and perform the signature of it. In parallel,
after the completion of some S, a distant session of P can be initiated by P Distant, which
will request on the previous secret channel the signature of the sid. Finally, as the forwarding
can be chained multiple time, at the end of a successful P Distant, a F orwardServer is set
up, which will accept to receive a signing request on the new secret channel of P Distant,
forward the request on the old secret channel, get the signature and forward it.

With the agent forwarding, we are faced with the new problem which is that we sequentially

compose a basic SSH exchange with other ones which use the same long term secret keys.

To summarize, to be able to prove the security of SSH with agent forwarding, we must be

able to handle key conﬁrmations and composition with shared long term secret.

D.2 The security of the protocol without forwarding agent

We show how we may apply Corollary 3 to the basic SSH protocol.

We provide in Figure 15, how we decompose the ssh protocols in order to prove its security.
To simplify, we directly specify that P and S may only relate to each other by hard-coding
the expected public keys inside them.

A ﬁrst step is to obtain the hypothesis A-3, relating to the security of the basic SSH key
exchange. We split this goal into two subgoals with a case study, the ﬁrst one capturing the
real or random of the key,

P 0(a, skP, pk(skS)); out(k)(cid:107)S0(b, skS, pk(skP )); out(k) ∼=O
P 0(a, skP, pk(skS)); [if B = gb then out(k(cid:48)) else out(k)]
(cid:107)S0(b, skS, pk(skP ))[if A = ga then out(k(cid:48)) else out(k)]

70

P Distant(oldk, pk(skS)) :=

SF orward(skS, pk(skP )) :=

in(A);
new b;
let k = Ab in
let sid = hash(< A, gb, k >) in
out(< gb, pk(skS), sign(sid, skS) >)
in(enc(sign, k))
if checksign(sign, pk(skP ))

∧ getmess(sign) =< sid, “f orwarded” > then
0.

new a;
out(ga);
in(B, pk(skS), sign)
let k = Ba in
let sid = hash(< ga, B, kP >) in
if checksign(sign, pk(skS))

∧ getmess(sign) = sid then
out(enc(sid, oldk))
in(enc(sign, oldk))
out(enc(sign, k))
0.

F orwardAgent(skP, k) :=

in(enc(sid, k))
out(enc(sign(< sid, “f orwarded” >, skP ), k))

SSHF orward :=

P (skP, pk(skS)); F orwardAgent(skP, k)
(cid:107)SF orward(skS, pk(skP ))
(cid:107)S(skS, pk(skP )); P Distant(k, pk(skS))

Figure 14: SSH key exchange with agent forwarding

P 0(a, skP, pk(skS)) :=

out(ga);
in(< B >)
let k = Ba in
0.

P 1(a, skP, pk(skS), B, k) :=
in(< pk(skS), sign >)

let sid = hash(< ga, B, k >) in
if checksign(sign, pk(skS))
∧ getmess(sign) = sid then

out(enc(sign(sid, skP ), k))
0.

S0(b, skS, pk(skP )) :=

in(A);
let k = Ab in
let sid = hash(< A, gb, k >) in

out(gb)

S1(b, skS, pk(skP ), sid, k) :=

out(< pk(skS), gb, sign(sid, skS) >)
in(enc(sign, k))
if checksign(sign, pk(skP ))
∧ getmess(sign) = sid then

0..

Figure 15: Divided SSH key exchange

71

and the second one the authentication:
P 0(a, skP, pk(skS)); if ¬((cid:87)
(cid:107)S0(b, skS, pk(skP )); if ¬((cid:87)
∼=O
P 0(a, skP, pk(skS)); if ¬((cid:87)
(cid:107)S0(b, skS, pk(skP )); if ¬((cid:87)

i B = gbi) then P 1(a, skP, pk(skS), B, k); out(k)
i A = gai) then S1(b, skS, pk(skP ), sid, k); out(k)

i B = gbi) then P 1(a, skP, pk(skS), B, k); bad
i A = gai) then S1(b, skS, pk(skP ), sid, k); bad

D.3 Proof of real of random

We start by proving that:

Ax |= P 0(a, skP, pk(skS)); out(k)(cid:107)S0(b, skS, pk(skP )); out(k) ∼
P 0(a, skP, pk(skS)); [if B = gb then out(k(cid:48)) else if B = gbi then out(k)]
(cid:107)S0(b, skS, pk(skP ))[if A = ga then out(k(cid:48)) else if A = gai then out(k)]

For this proof, we may use Ax = DDHs, where s does not contain a and b.
We denote φj
the i-eme term of the j-eme folding in the left game, and ψj
i
i

game. After splitting over each possible folding of actions, we have the sequence of terms:

for the right

• φ0 = ga; φ1 = φ0, gb, g0(φ0)b; φ2 = φ1, g1(φ1)a
• φ1

1 = φ0, g0(φ0)a, ; φ1

1, gb, g1(φ1

2 = φ1

1)b

• ψ0 = φ0; ψ1 = ψ0, gb, if g0(φ0) = ga then k(cid:48) else if g0(φ0) = gai then g0(φ0)b; ψ2 =

ψ1, if g1(ψ1) = gb then k(cid:48) else if g1(ψ1) = gbi then g1(ψ1)a
1 = ψ0, if g0(φ0) = gb then k(cid:48) else if g0(φ0) = gbi then g0(ψ0)a; ψ1
ga then k(cid:48) else if g1(ψ1

1) = gai then g1(ψ1

1)b

• ψ1

2 = ψ1

1, gb, if g1(ψ1

1) =

And we have to prove that Ax |= φ2 ∼ ψ2 and Ax |= φ1

2 ∼ ψ1
2

.

D.3.1 Proof of Ax |= φ2 ∼ ψ2
We apply the EQ that are true in the if branches, and we perform a case study on the ﬁrst
conditional of the sequence, yielding the four terms:

• ψ(cid:48)

• ψ(cid:48)(cid:48)

• φ(cid:48)

• φ(cid:48)(cid:48)

1 = ψ0, gb, EQ(g0(φ0), ga), k(cid:48)
1 = ψ0, gb, EQ(g0(φ0)), gai), gaib
1 = φ0, gb, EQ(g0(φ0), ga), gab
1 = φ0, gb, EQ(g0(φ0), gai), gaib

With DDH , we can replace gab with k(cid:48), and with transitivity, we have that

.

Moreover, we trivially have

Ax |= φ(cid:48)

1 ∼ ψ(cid:48)
1

Ax |= φ(cid:48)(cid:48)

1 ∼ ψ(cid:48)(cid:48)
1

The we also apply the EQand perform another case study on the second conditional,

yielding eight terms:

72

• ψ(cid:48)

2 = ψ(cid:48)

1, EQ(g1(ψ(cid:48)

1), gb), k(cid:48)

• ψ(cid:48)(cid:48)

2 = ψ(cid:48)

1, EQ(g1(ψ(cid:48)

1), gbi), gabi

• ψ(cid:48)(cid:48)(cid:48)

2 = ψ(cid:48)(cid:48)

1 , EQ(g1(ψ(cid:48)(cid:48)

1 ), gb), k(cid:48)

• ψ(cid:48)(cid:48)(cid:48)(cid:48)

2 = ψ(cid:48)(cid:48)

1 , EQ(g1(ψ(cid:48)(cid:48)

1 ), gbi), gabi

• φ(cid:48)

2 = φ(cid:48)

1, EQ(g1(φ(cid:48)

1), gb), gab

• φ(cid:48)(cid:48)

2 = φ(cid:48)

1, EQ(g1(φ(cid:48)

1), gbi), gabi

• φ(cid:48)(cid:48)(cid:48)

2 = φ(cid:48)(cid:48)

1, EQ(g1(φ(cid:48)(cid:48)

1), gb), gab

• φ(cid:48)(cid:48)(cid:48)(cid:48)

2 = φ(cid:48)(cid:48)

1, EQ(g1(φ(cid:48)(cid:48)

1), gbi), gabi

From now on, we omit Ax. We then prove the four equivalence required to conclude:

1. φ(cid:48)

2 ∼ ψ(cid:48)
2
We ﬁrst use function application (FA) multiple times to get φ(cid:48)
1, EQ(g1(ψ(cid:48)
Then, we use DDH to replace gab with k(cid:48) and transitivity to conclude that: φ(cid:48)

2 ∼ ψ(cid:48)

1), gb), gab.
2 ∼ ψ(cid:48)
2

.

2. φ(cid:48)(cid:48)

2 ∼ ψ(cid:48)(cid:48)
2
FA* on φ(cid:48)

1 ∼ ψ(cid:48)
1

yields the conclusion φ(cid:48)(cid:48)

2 ∼ ψ(cid:48)

1, EQ(g1(ψ(cid:48)

1), gbi), gabi.

3. φ(cid:48)(cid:48)(cid:48)

2 ∼ ψ(cid:48)(cid:48)(cid:48)
2
1 ), gb), gab. After expressing the fact that
FA* on φ(cid:48)(cid:48)
gaib = (gb)ai (i.e. all terms can be expressed as a context of ga, gb, gab), we use DDH to
replace gab with k(cid:48) and conclude.

1 , EQ(g1(ψ(cid:48)(cid:48)

, yields φ(cid:48)(cid:48)(cid:48)

2 ∼ ψ(cid:48)(cid:48)

1 ∼ ψ(cid:48)(cid:48)
1

4. φ(cid:48)(cid:48)(cid:48)(cid:48)

2 ∼ ψ(cid:48)(cid:48)(cid:48)(cid:48)
2
FA* on φ(cid:48)(cid:48)

1 ∼ ψ(cid:48)(cid:48)
1
We thus have Ax |= φ2 ∼ ψ2.

yields the conclusion φ(cid:48)(cid:48)(cid:48)(cid:48)

2 ∼ ψ(cid:48)(cid:48)

1 , EQ(g1(ψ(cid:48)(cid:48)

1 ), gbi), gabi.

D.3.2 Proof of Ax |= φ1

2 ∼ ψ1
2

We ﬁrst note that EQ(g0(φ0), gb) ∼ false as φ0 does not contain b. Thus, the positive branch
can be eliminated and we get ψ1
. We then have ψ1
1) =
ga then k(cid:48) else g1(φ1

1, gb, if g1(φ1

where ψ1(cid:48)

2 ∼ ψ1(cid:48)

2 = φ1

1 ∼ φ1
1

We conclude once again with a case study, a DDH for one case, and trivial equality in the

1)b.

2

other case.

D.4 Proof for the authentication

We now prove that:

Ax |= P 0(a, skP, pk(skS)); if ¬((cid:87)
(cid:107)S0(b, skS, pk(skP )); if ¬((cid:87)
∼
P 0(a, skP, pk(skS)); if ¬((cid:87)
(cid:107)S0(b, skS, pk(skP )); if ¬((cid:87)

i B = gbi) then P 1(a, skP, pk(skS), B, k); out(k)

i A = gai) then S1(b, skS, pk(skP ), sid, k); out(k)

i B = gbi) then P 1(a, skP, pk(skS), B, k); bad
i A = gai) then S1(b, skS, pk(skP ), sid, k); bad

73

The proof is very similar to the proof of authentication of the signed DH key exchange,

we only outline the arguments here.

TP (m, s) := ∃i, ∃X, m = hash(gai, X, X ai)
TS(m, s) := ∃i, ∃X, m = hash(X, gbi, X bi)

We have that Ax = EUF-CMATP ,skP,s ∧ EUF-CMATS ,skS,s is Osign

TP ,skA,s, Osign

TS ,skB,s, Oai,bi

sound thanks to Proposition 27.

We prove that bad may never occur, either in P or S. For bad to occur, the signature
checks must succeed in one of the process, while the session identiﬁer is not an honest one.
In this case, we prove that the signature checks will always fail, i.e that , for sign, B and A
terms produced by the attacker:

B = gbi) ∧ checksign(sign, pk(skS))) ∧ getmess(sign) = hash(< ga, B, Ba >) ∼ false

(cid:95)

¬(

i

or

(cid:95)

¬(

i

A = gai) ∧ checksign(sign, pk(skP )) ∧ getmess(sign) = hash(< A, gb, Ab >) ∼ false

If those two equivalences are true for all possible values of the term sign that can be taken
depending on the traces, bad will never be raised. Let us for instance prove the ﬁrst one. For
all possible traces, the only honest signature by skS that might appear inside the message
sign is of the form sign(hash(< A, gb, Ab >), skS).

By using the EUF-CMATS ,skS,s axiom, we obtain

¬((cid:87)

¬((cid:87)

i B = gbi) ∧ checksign(sign, pk(skS))) ∧ getmess(sign) = hash(< ga, B, Ba >)

∼

i B = gbi) ∧ (Ts( getmess(sign)) ∨ getmess(sign) = hash(< A, gb, Ab >), skS)

∧ getmess(sign) = hash(< ga, B, Ba >)

(Ts( getmess(sign)) is directly in contradiction with ¬((cid:87)

i B = gbi), and the same goes

for getmess(sign) = hash(< A, gb, Ab >), skS), we do obtain the expected conclusion.

E SSH with forwarding agent

E.1 Scheme of the proof

Here, we wish to compose SSH with another potential session of SSH using the forwarding
agent. Then, a protocol which is secure if executed with a real or random key should be secure
when using the key given by the SSH session using the forward agent.

We will write F A for F orwardAgent, SF for SF orward, and P D for P Distant. We

consider a record protocol, satisfying a property of the form Y (k)(cid:107)Z(k) ∼= Y (cid:48)(k)(cid:107)Z(cid:48)(k).

We also assume that the agents are only willing to communicate with the honnest identity,
i.e pk(skS) and pk(skP ) are predeﬁned inside the processes. This is usually the case for SSH,
where the user is asked to either validate or insert himself some public key.

Our goal is then:

74

!n2

P (skP, pk(skS)); F A(skP, k);
(cid:107)S(skS, pk(skP )); P D(k, pk(skS)); Y (kP D)
(cid:107)SF (skS, pk(skP )); Z(kSF )

∼=!n2

P (skP, pk(skS)); F A(skP, k);
(cid:107)S(skS, pk(skP )); P D(k, pk(skS)); Y (cid:48)(kP D)
(cid:107)SF (skS, pk(skP )); Z(cid:48)(kSF )

We split the proof using two applications of Corollary 3.
The P and S will use randomness of the form ai, bi, and P D and SF randomness of the

form a(cid:48)
i

and b(cid:48)
i

.

E.1.1 First application of Corollary 3

The application is performed with the following hypothesis, which allows to derive the desired
conclusion.
A-3:

P 0(a, skP );

if B = gb then

P 0(a, skP );

if ¬T (B, s) then

(cid:107)S0(b, skS);

P 1(a, skP, Ba); out(Ba)

else out(Ba, ga, B)
if ¬T (A, s) then

S1(b, skS, Ab); out(Ab)

else out(Ab, gb, A)

∼=OP S ,Of orward

(cid:107)S0(b, skS);

out(k, ga, B)
else if ¬T (B, s) then
P 1(a, skP, Ba); bad

else out(Ab, gb, A)
if A = ga then
out(k, gb, A)

else if ¬T (B, s) then
S1(b, skS, Ab); bad

else out(Ab, gb, A)

B-1:

!n2P 1(k); F A(k)(cid:107)S1(k); P D(k); Y (cid:107)SF ; Z ∼=OKE1

!n2P 1(k); F A(k)(cid:107)S1(k); P D(k); Y (cid:48)(cid:107)SF ; Z(cid:48)

With the oracles:

• OP S allows to simulate (A-1) the other honnest sessions of P and S, it corresponds to

Osign
TP ,skS,s, Osign

TS ,skP,s, Oai,bi

of Appendix D.4.

• Of orward allows to simulate (C-1) the continuation, i.e the protocols of the form

in(k); P 1(k); F A(k)(cid:107)in(k); S1(k); P D(k); Y (cid:107)SF ; Z

allows to simulate (C-2) !n2P (cid:107)S (it is similar to OP S).

• OKE1
All simulations are performed under νskS, skP . To deﬁne Of orward, we need to settle an
issue. . Indeed, for hypothesis C-1, we need to provide an oracle that can simulates sessions of
the forwarding protocols. However, in order to get the simulatability of in(k).F A(skP, k), one
must give a generic signing oracles to the attacker, which would obviously make the protocol
unsecure. Based on the assumption that the forwarded sessions perform signatures tagged
with “forwarded”, as shown below, we however can provide a signing oracle only for such
messages, allowing for the simulatability of the forwarding agent, and of the forwarded client
and server. More speciﬁcally, recall the the forwarding agent is of the form:

F A(skP, k) :=

in(enc(sid, k))

out(enc(sign(< sid, “f orwarded” >, skP ), k))

75

Then, we may obtain the simulatability with:

Tf or(m, s) := ∃A, m =< m, “f orwarded” >

Tf or,skP,s, Osign

Then, Of orward is simply Osign
Tf or,skS,s, Oa(cid:48)
This diﬃculty actually stems from a well known weakness in the agent forwarding. When
a user logs on a remote server, he set up on the server a socket which allows to ask for any
signature.
If another user has privileged access to the server, he may also use the socket,
and obtain a signature for any session. In our model, we assume that only honest sessions of
forwarder P can access an agent, which allows us to prove the security. Providing a proof of
SSH without this modiﬁcation still represent a challenge regarding composition.

i,b(cid:48)
i

Now, the proof of A-3 is instantly derived from the proof performed in Appendices D.3
P ,skP,s. The
P ( getmess(sign), s) is incompatible

and D.4, where we replace for instance EUF-CMATP ,skP,s with EUF-CMATP ∨T (cid:48)
proofs will work as previously, based on the remark that T (cid:48)
for instance with getmess(sign) = hash(< ga, B, Ba >).

The diﬃculty now lies in proving the security of what we do after the ﬁrst SSH key

exchange, i.e proving Hypothesis B-1. This is where we apply once again Corollary 3.

E.1.2 Second application of Corollary 3

We wish to prove that:

!n2P 1(k); F A(k)(cid:107)S1(k); P D(k); Y (cid:107)SF ; Z ∼=OKE1

!n2P 1(k); F A(k)(cid:107)S1(k); P D(k); Y (cid:48)(cid:107)SF ; Z(cid:48)

We use as hypothesis:
A-3:

P 1(k); F A(k)(cid:107)S1(k); P D0(a, skP );

if ¬T (B, s) then

P D1(a, skP, Ba); out(Ba)

(cid:107)SF 0(b, skS);

else out(Ba, ga, B)
if ¬T (A, s) then

P 1(k); F A(k)(cid:107)S1(k); P D0(a, skP );

if B = gb then

∼=OKE1 ,Ok

F P S ,OY Z

SF 1(b, skS, Ab); out(Ab)

else out(Ab, gb, A)

(cid:107)SF 0(b, skS);

out(k, ga, B)
else if ¬T (B, s) then

P D1(a, skP, Ba); bad

else out(Ab, gb, A)
if A = ga then
out(k, gb, A)

else if ¬T (B, s) then

SF 1(b, skS, Ab); bad

else out(Ab, gb, A)

Note that the k used here is a fresh name, which could be considered as a long term secret,
i.e inside p. We may prove this without considering P 1 and S1, and replacing them by oracles
which can simulate them. The proof of A-3 can once again be derived from the proof performed
in Appendices D.3 and D.4. Note that here, the proof is greatly simpliﬁed because our modiﬁed

76

forwarding agent ensure that any signed session identiﬁer is honest, and the secrecy of the
name k is not even required to perform the proof. This proof could also performed without
the additional check added to the forwarding agent, but it would then require a cryptographic
assumption regarding the encryption.

And B-1:

P D1(k(cid:48)); Y (k(cid:48))(cid:107)SF 1(k(cid:48)); Z(k(cid:48)) ∼=OKE1 ,O

KEk
2

P D1(k(cid:48)); Y (cid:48)(k(cid:48))(cid:107)SF 1(k(cid:48)); Z(cid:48)(k(cid:48))

With the oracles:

• Ok

F P S
to Osign
T (cid:48)

allows to simulate (A-1) the other honnest sessions of P D and SF , it corresponds
P ,skS,s, Osign

S ,skP,s, Oai,bi
T (cid:48)

of Appendix D.4.

• OY Z allows to simulate (C-1) the continuation, i.e the protocols of the form

in(k); P D1(k); Y (k)(cid:107)in(k); SF 1(k); Z(k)

2

allows to simulate (C-2) !n2F A(k)(cid:107)P D(k)(cid:107)SF (it is similar to OF P S).

• OKEk
Here, we do not commit to any transport protocol used after the SSH key exchange. It
would probably use some encryption using the fresh key. Then, if for instance IND-CCAis
required to prove Y (cid:107)Z ∼= Y (cid:48)(cid:107)Z(cid:48), to prove B − 1, we would need to assume that IND-CCAis
still valid even when the attacker has access to the hash of a message containing the key used
for encryption. This holds for instance in the random oracle model. A proof of B − 1 could
then be derived from the proof of Y (cid:107)Z ∼= Y (cid:48)(cid:107)Z(cid:48) which would still be valid under an oracle
producing hashes of the key, i.e an oracle which could simulate P D1 and SF 1.

F Proofs

F.1 Formal Corollary for Key Exchange

We denote p = {idI , idR} and s = {lsidI
identiﬁers.

i , lsidR

i }i∈N the set of all the copies of the local session

Formalizing the previous Section, to prove the security of a key exchange, we can use the

following Corollary of Theorem 5.

Corollary 1. Let Oke, O be oracles and KEi[_1, _2] := I(lsidI
a key exchange protocol, such that I binds xI , xI
disjoint of the oracle support. Let idI , idR be names and sI = {lsidI
of names :

lsid, R binds xR, xR

id, xI

i , idI ); _1(cid:107)R(lsidR

i , idR); _2
lsid and Nl(KE) is
i }i∈N sets

i }i∈N,sR = {lsidR

id, xR

1. ∀i ≥ 1, (νlsidI

i , idI , lsidR

i , idR.

KEi[out((cid:104)xI , lsidI

i , xI

lsid, xI

id(cid:105)), out((cid:104)xR, lsidR

i , xR

lsid, xR

id(cid:105))](cid:107)out((cid:104)lsidR

i , lsidI

i (cid:105))

is Oke simulatable)).

2. s is disjoint of the support of O.

77

KE0[out((cid:104)xI , lsidI
if xI
KE0[

0, xI
lsid = lsidR
out((cid:104)k, lsidI

id(cid:105)), out((cid:104)xR, lsidR
id = idR then

lsid, xI
0 ∧ xI
0, xlsid, xid(cid:105))

else if xI

lsid /∈ sR ∧ xI

id = idR then

⊥

0 , xR

lsid, xR

id)] ∼=Oke,O

3.

else out((cid:104)xI , lsidI
lsid = lsidI
if xR
out((cid:104)k, lsidR

0 ∧ xR
0 , xR

else if xR

lsid /∈ sI ∧ xR

lsid, xI
0, xI
id(cid:105)),
id = idI then
lsid, xR
id(cid:105))
id = idI then

⊥

else out((cid:104)xR, lsidR

0 , xR

lsid, xR

id(cid:105))]

Then, for any N which depends on the security parameter:

(cid:107)i≤N KEi[out(xI ), out(xR)] ∼=O

(cid:107)i≤N KEi[

id = idR) then
if (xI
lsid = lsidR
xI
if
1≤j≤N

j ∧ xI

id = idR then

out(ki,j)

else out(xI ),
if (xR
id = idI ) then
lsid = lsidI
xR
if
1≤j≤N

j ∧ xR

id = idI then

out(kj,i)

else out(xR)]

Then, building upon the previous Corollary and the sequential composition Theorems, the
following Corollary shows the precise requirements to prove the security of a protocol which
uses a key exchange, for an bounded number of session and with long term secrets shared
between the key exchange and the protocol.

Corollary 2. Let OT , Oke, Or,OP,Q be oracles and

KEi[_1, _2] := I(lsidI

binds xI , xI
idI , idR be names, sI = {lsidI

lsid, R binds xR, xR

id, xI

i , idI ); _1(cid:107)R(lsidR
id, xR

i , idR); _2 a key exchange protocol, such that I
lsid and Nl(KE) is disjoint of the oracle support. Let
i }i∈N and s = sI ∩ sR sets of names.

i }i∈N,sR = {lsidR

Let p = {idI , idR}, P (x, y) = P1(x, y)(cid:107)P2(x, y) and Q(x, y, z) = Q1(x, y, z)(cid:107)Q1(x, y, z) be

parameterized protocols, such that Nl(P, Q) is disjoint of the oracle support.

I-1 ∀i ≥ 1, (νlsidI

i , idI , lsidR

i , idR.KEi[out(xI ), out(xR)](cid:107)out((cid:104)lsidR

i , lsidI

i (cid:105)) is OT -simulatable)).

I-2 s is disjoint of the support of OP,Q.

78

KE0[out((cid:104)xI , lsidI
[if xI
KE0

0, xI
lsid = lsidR
out((cid:104)k, lsidI

lsid, xI
0 ∧ xI
0, xI
lsid /∈ sR ∧ xI

else if xI

id(cid:105)), out((cid:104)xR, lsidR
id = idR then
id(cid:105))

lsid, xI

id = idR then

⊥

0 , xR

lsid, xR

id(cid:105)) ∼=OT ,OP,Q

I-3

and

else out((cid:104)xI , lsidI
lsid = lsidI ∧ xR
if xR
0 , xR
out((cid:104)k, lsidR

else if xR

lsid /∈ sI ∧ xR

lsid, xI
0, xI
id(cid:105)),
id = idI then
lsid, xR
id(cid:105))
id = idI then

⊥

else out((cid:104)xR, lsidR

0 , xR

lsid, xR

id(cid:105))]

R-1 ∀ 1 ≤ i, j ≤ n, νp, ki,j.P0(p, ki,j) is Or-simulatable.

R-2 ∀ 1 ≤ i ≤ n, νp, ki,j.Q0(p, ki,j) is Or-simulatable.

R-3 s is disjoint of the support of Ok.
R-4 P0(p, k) ∼=Or,Oke Q0(p, k)

and

C-1 νp.in(xI

i ).P I

i (xI

i )(cid:107)in(xR

i ).P R

i (xR

i )is OP,Q-simulatable.

(cid:107)i≤n KEi[

1. νp.

if
1≤j≤n

(xI

id = idR) then

if (xI
lsid = lsidR

id = idR) then
j ∧ xI
out((cid:104)i, j(cid:105))
i (xI
else P I
i ),
id = idI ) then

if (xR
lsid = lsidI

j ∧ xR
out((cid:104)i, j(cid:104))
i (xR

i )]

else P R

if
1≤j≤n

(xR

id = idI ) then

is Oke-simulatable.

Then, for any n which may depend on the security parameter:

(cid:107)i≤nKEi[if xI

id = idR then QI

(cid:107)i≤nKEi[P I
i ) else P I
i (xI

i (xI
i (xI

i ), P R
i (xR
i ), if xR

i )] ∼=
id = idI then QR

i (xR

i ) else P R

i (xR

i )]

F.2 Formal Corollary for Key Conﬁrmations

The Theorem for those key exchanges is very similar to Corollary 2. The main diﬀerence is
that now, instead of working on a key exchange KE := I(lsidI , idI )|R(lsidR, idR)[, we further
split I and R, in I = I 0; I 1 and R := R0; R1, where I 0 and R0 will corresponds to the key
exchange up to but not including the ﬁrst use of the secret key, and I 1 and R1 as the remainder
of the protocol.

79

Corollary 3. Let OKE, Or,OP,Q be oracles and

KEi[_1, _2] := Ii(lsidI

i , idI ); _1|Ri(lsidRi, idR); _2

i (lsidR

i , idR); R1

a key exchange protocol with Ii(lsidI
R0
disjoint of the oracles support. Let p = {idI , idR}, Pi(x, y) = P I
QI
i (x, y, z)(cid:107)QR
the oracles support.

i , idR) :=
i (xR) such that I 0 binds xI , xid, xlsid, R0 binds xR, xid, xlsid and Nl(KE) is
i (x, y),Q(x, y, z) =
i (x, y, z), Ci(z) and Di(z) be protocols, such that Nl(P, Q, C, D) is disjoint of

i (xI ) and Ri(lsidR

i , idI ) := I 0

i (x, y)(cid:107)P R

i , idI ); I 1

i (lsidI

Let idI , idR be names, sI = {lsidI

i }i∈N,sR = {lsidR

i }i∈N and s = sI ∩ sR sets of names.

A-1 ∀i ∈ N, (νlsidI
simulatable)).

i , idI , lsidR

i , idR.Ci(p)(cid:107)I 0

i (lsidI

i , idI ); out(xI )(cid:107)R0

i (lsidR

i , idR); out(xR) is OKE

A-2 s is disjoint of the support of Op.

Ci(p)(cid:107)I 0

0 (lsidI

0, idI );

(cid:107)R0(lsidR

0 , idR);

∼=OKE ,Op
Ci(p)(cid:107)I 0(lsidI

0, idI );

A-3

(cid:107)R0(lsidR

0 , idR);

if xI

id = idR then

lsid /∈ sR ∧ xI
I 1(xI ); out(xI )
else out((cid:104)xI , lsidI
if xR

lsid, xI
lsid /∈ sI ∧ xid = idI then
R1(xR); out(xR)
else out((cid:104)xR, lsidR, xR

0, xI

lsid, xR

id(cid:105))

id(cid:105))

if xI

lsid = lsidR ∧ xid = idR then
0, xI
out((cid:104)k, lsidI

lsid, xI

id(cid:105))

else if xI

lsid /∈ sR ∧ xI

id = idR then

I 1(xR); ⊥

else out((cid:104)xI , lsidI , xI
lsid = lsidI ∧ xR
if xR
0 , xR
out((cid:104)k, lsidR

else if xR

lsid /∈ sI ∧ xR

lsid, xI
id(cid:105))
id = idI then
lsid, xR
id(cid:105))
id = idI then

I 1(xR); ⊥

and for any N which may depend on the security parameter:

else out((cid:104)xR, lsidR

0 , xR

lsid, xR

id(cid:105))

B-1 (cid:107)i≤N 2Di(p)(cid:107)I 1

i (ki); P I

i (p, ki)(cid:107)B1

i (ki); P R

i (p, ki) ∼=Or,Ok (cid:107)i≤n2Di(p)(cid:107)I 1

i (ki); QI

i (p, ki)(cid:107)B1

i (ki); QR

i (p, ki)

and

C-1 νp, lsidI
(cid:107)in(x).I 1

i , lsidR
i (x); QI

i .Di(p)(cid:107)in(x).Pi(x) (cid:107)in(x).Qi(x)(cid:107)in(x).I 1

i (x); P I

i (x)(cid:107)in(x).R1

i (x); P R

i (x)

i (x)(cid:107)in(x).R1

i (x); QR

i (x) is Op simulatable.

80

(cid:107)i≤N Ci(p)(cid:107)I 0

i (lsidI

i , idI );

if
1≤j≤N

lsid = lsidR
xI

j ∧ xI

id = idR then

out((cid:104)i, j(cid:105))

lsid /∈ sR ∧ xI

id = idR then

else if xI
I 1
i (xI ); ⊥
else I 1
if
1≤j≤N

i (xI ); P I
i (xI )
lsid = lsidI
xR

j ∧ xR

id = idI then

out((cid:104)i, j(cid:105))

else if (xR

lsid /∈ sI ∧ xR

id = idI then

i (xR); ⊥

R1
else R1

i (xR); P R

i (xR)

C-2 νp.

(cid:107)R0

i (lsidR

i , idR)[

is Ok simulatable.

Then, for any n:

(cid:107)i≤N Ci(p)(cid:107)Di(p)(cid:107)KEi[if xI

(cid:107)i≤N Ci(p)(cid:107)Di(p)(cid:107)KEi[P I
id = idR then QI

i (xI ) else P I

i (xI ), P R

i (xR)] ∼=

i (xI ), if xR

id = idI then QR

i (xR) else P R

i (xR)]

F.3 Oracle Simulation

We ﬁrst show that O-simulation, whose deﬁnition implies the identical distributions of two
messages produced either by the simulator of by the oracle, implies the equality of distributions
of message sequences produced by either the oracle or the simulator.

Lemma 9. Given a cryptographic library Mf , a sequence of names n, an oracle O with support
n and a protocol P , that is O-simulatable with AO, we have, for every x, y, c, r2, rB ∈ {0, 1}(cid:63),
every v ∈ Dη
n, for every m ≥ 1, for every PTOM BO (using tags preﬁxed by 1):

Pρs,ρr1 ,ρr2 ,ρO {θ1

m = x, φ1
= Pρs,ρr1 ,ρr2 ,ρO {θ2

m = y| [[n]]η
m = x, φ2

ρs = v, ρB
m = y| [[n]]η

O = rB, ρr2 = r2}
ρs = v, ρB

O = rB, ρr2 = r2}

where we split ρO into ρA

O (cid:93) ρB

O such that O called by B only accesses ρB

O and O called by

A only accesses ρA

O (which is possible thanks to the distinct preﬁxes).
Proof. We proceed by induction on m. Let us ﬁx x, y, c, r2, rB ∈ {0, 1}(cid:63) and v ∈ Dη
n
assume that:

. We

Pρs,ρr1 ,ρr2 ,ρO {θ1

m = x, φ1
= Pρs,ρr1 ,ρr2 ,ρO {θ2

m = y| [[n]]η
m = x, φ2

ρs = v, ρB
m = y| [[n]]η

O = rB, ρr2 = r2}
ρs = v, ρB

O = rB, ρr2 = r2}

We deﬁne vi

m+1 = BO(ρs,ρO)(Mf , ρr2, η, φi

m).

As the support of O is n, we have that O(ρs, ρO) = O(πk(ρs, η), ρO) .

Using conditional probabilities, we have that:

Pρs,ρr1 ,ρr2 ,ρO {θ1

m+1 = x, φ1
= Pρs,ρr1 ,ρr2 ,ρO {v1
×Pρs,ρr1 ,ρr2 ,ρO {θ1

m = y| [[n]]η
m+1 = xm+1| θ1
m = x, φ1

ρs = v, ρB

O = rB, ρr2 = r2}
m = y, [[n]]η

m = x, φ2

m = y| [[n]]η

ρs = v, ρB

ρs = v, ρB
O = rB, ρr2 = r2}

O = rB, ρr2 = r2}

81

Now, if we deﬁne Ov,rB

we have that

such that Ov,rB = O(πn(ρs, η), ρB

O) when [[n]]η

ρs = v and ρB

O = rB ,

Pρs,,ρr1 ,ρr2 ,ρO {v1

=1

ρs = v, ρB

O = rB, ρr2 = r2}

m+1 = xm+1| θ1
Pρs,ρr1 ,ρr2 ,ρO {BO(πn(ρs,η),ρB
m = x, φ1

| θ1

m = x, φ1

m = y, [[n]]η

m = y, [[n]]η
O)(Mf , ρr2, η, φ1
ρs = v, ρB

Pρs,ρr1 ,ρr2 ,ρO {BOv,rB (Mf , r2, η, y) = xm+1

| θ1

m = x, φ1

m = y, [[n]]η

ρs = v, ρB

Pρs,ρr1 ,ρr2 ,ρO {BOv,rB (Mf , r2, η, y) = xm+1}
Pρs,ρr1 ,ρr2 ,ρO {BOv,rB (Mf , r2, η, y) = xm+1

m) = xm+1
O = rB, ρr2 = r2}

O = rB, ρr2 = r2}

m = y, [[n]]η

| θ2

m = x, φ2
Pρs,ρr1 ,ρr2 ,ρO {BO(πn(ρs,η),ρB
m = x, φ2

| θ2

ρs = v, ρB
O)(Mf , ρr2, η, φ2
ρs = v, ρB

O = rB, ρr2 = r2}
m) = xm+1
O = rB, ρr2 = r2}

m = y, [[n]]η

=2

=3
=4

=5

Justiﬁed with:

1. because O(ρs, ρO) = O(πn(ρs, η), ρB

2. O(πn(ρs, η), ρB

O) = Ov,rB

, and φ1

O);
m = y;

3. the considered event does not depends on any of the conditional events removed;

4. the considered event does not depends on any of the conditional events added;

5. reversing the previous steps.

So we conclude that, as we also have the induction hypothesis:

Pρs,ρr1 ,ρr2 ,ρO {θ1

m+1 = x, φ1
= Pρs,ρr1 ,ρr2 ,ρO {θ2

m = y| [[n]]η
m+1 = x, φ2

ρs = v, ρB
m = y| [[n]]η

O = rB, ρr2 = r2}
ρs = v, ρB

O = rB, ρr2 = r2} (i)

We now deﬁne:

m+1 = AO(πn(ρs,η),ρA
u1

O)(Mf , ρr1, θ1

m (cid:93) v1

m+1, η)

We deﬁne the Turing machine B, such that:

m+1 = OP (ρs, θ2
u2

m (cid:93) v2

m+1)

BO(ρs,ρO)(Mf , ρr2, η, φi

m) :=

if ∀j ≤ m + 1, BO(v,rB)(Mf , r2, η, φi

j) = xj

∧φi

m = y

then BO(v,rB)(Mf , r2, η, φi
else ⊥

m)

We then deﬁne v(cid:48)
m

and θ(cid:48)
m

for B similarly as vm for B.

82

We deﬁne Ov,ρA

O

such that Ov,ρA

O

= O(πn(ρs, η), ρA

O) when [[n]]η

ρs = v. We then have:

Pρs,ρr1 ,ρr2 ,ρO {u1

m+1 = ym+1| θ1

m+1 = x, φ1

m = y, [[n]]η

=1 Pρs,ρr1 ,ρr2 ,ρO {A

O

=2 Pρs,ρr1 ,ρr2 ,ρO {A

[[n]]η

[[n]]η

v,ρA
ρs = v, ρB
O
v,ρA
ρs = v, ρB
O
v,ρA

O (Mf , ρr1, x, η) = ym+1| θ1
O = rB, ρr2 = r2}
O (Mf , ρr1, θ1(cid:48)
O = rB, ρr2 = r2}
O (Mf , ρr1, θ1(cid:48)
m+1 = x, φ1

m = y| [[n]]η

=3 Pρs,ρr1 ,ρr2 ,ρO {A

×(Pρs,ρr1 ,ρr2 ,ρO {θ1

m+1, η) = ym+1| θ1

m+1 = x, φ1

m = y,

m+1, η) = ym+1| [[n]]η

ρs = v}

ρs = v, ρB

O = rB, ρr2 = r2}

ρs = v, ρB

O = rB, ρr2 = r2}
m = y,

m+1 = x, φ1

×Pρs,ρr1 ,ρr2 ,ρO {ρB
=4 Pρs,ρr1 ,ρr2 ,ρO {OP (ρs, θ2(cid:48)
×(Pρs,ρr1 ,ρr2 ,ρO {θ1

×Pρs,ρr1 ,ρr2 ,ρO {ρB
=5 Pρs,ρr1 ,ρr2 ,ρO {OP (ρs, θ2(cid:48)
×(Pρs,ρr1 ,ρr2 ,ρO {θ2

O = rB, ρr2 = r2| [[n]]η
m+1) = ym+1| [[n]]η
m = y, | [[n]]η

O = rB, ρr2 = r2| [[n]]η
m+1) = ym+1| [[n]]η
m = y, | [[n]]η

m+1 = x, φ2

m+1 = x, φ1

ρs = v})−1

ρs = v}
ρs = v, ρB

ρs = v})−1

ρs = v}
ρs = v, ρB

×Pρs,ρr1 ,ρr2 ,ρO {ρB
=6 Pρs,ρr1 ,ρr2 ,ρO {OP (ρs, θ2(cid:48)
ρB
O = rB, ρr2 = r2}

O = rB, ρr2 = r2| [[n]]η
m+1) = ym+1| θ2

m+1 = x, φ2

ρs = v})−1

m = y, [[n]]η

ρs = v,

O = rB, ρr2 = r2}

=7 Pρs,ρr1 ,ρr2 ,ρO {OP (ρs, x) = ym+1| θ2

m+1 = x, φ2

m = y, [[n]]η

ρs = v,

O = rB, ρr2 = r2}

=8 Pρs,ρr1 ,ρr2 ,ρO {u2

m+1 = ym+1| θ2

m+1 = x, φ2

m = y, [[n]]η

ρs = v,

ρB
O = rB, ρr2 = r2}

ρB
O = rB, ρr2 = r2}

Justiﬁed with:

1. using the conditional probabilities;

2. by deﬁnition of B which produces x under the conditional events;

3. using conditional probabilities, as θm (cid:54)= x ∨ φm (cid:54)= y ⇒ B = ⊥;

4. by O simulatability on B;

5. using (i);

6. using conditional probabilities, as θm (cid:54)= x ∨ φm (cid:54)= y ⇒ B = ⊥;

7. by deﬁnition of B which produces x under the conditional events;

8. using the conditional probabilities.

Combining the previous equality with equation (i) ﬁnally yields through conditional prob-

abilities:

Pρs,ρr1 ,ρr2 ,ρO {θ1

m+1 = x, φ1
= Pρs,ρr1 ,ρr2 ,ρO {θ2

m+1 = y| [[n]]η
m+1 = x, φ2

ρs = v, ρB
m+1 = y| [[n]]η

O = rB, ρr2 = r2}
ρs = v, ρB

O = rB, ρr2 = r2}

83

F.4 Autocomposition Results

Proposition 18. Let O be an oracle, two parameterized processes P (x), Q(x), a set of names
n = Ng(P, Q) and fresh names k0, l. We assume that Nl(P, Q) is disjoint of the support of O.
If:

• νn.in(cP , x); P (x)(cid:107)in(cQ, x); Q(x) is O-simulatable, and
• P (k0); out(cP , x)(cid:107)Q(k0); out(cQ, x) ∼=O P (k0); out(cP , l)(cid:107)Q(k0); out(cQ, l)

then, for any N,

P (k0); P (x);N ; out(cP , x)(cid:107)Q(k0); Q(x);N ; out(cQ, x)

∼=O P (k0); P (x);N ; out(cP , l)(cid:107)Q(k0); Q(x);N ; out(cQ, l)

Proof. We proceed by induction on N . The result is exactly the ﬁrst hypothesis for N = 0.

Given some N > 1, we assume that

P (ki);N −1; out(k)(cid:107)Q(ki);N −1; out(k) ∼=O P (ki);N −1; out(l)|Q(ki);N −1; out(l)

(i)

In the following, we will write P (ki);N −1 for P (ki); P (k);N −2 and we will omit to mention
the α-renaming made over the local names in Nl(P, Q) between the diﬀerent copies of P and Q.
The renaming is however essential so that we may for instance have Nl(P N −1(k)) ∩ Nl(P ) = ∅
when we wish to apply Theorem 4. This silent renaming is possible because Nl(P, Q) is not
contained in the support of O.

We obtain by application of Theorem 4 with A = P (ki);N −1, B = Q(ki);N −1, P1(x) :=

P (x);0; out(k) and P2(x) := Q(x);0; out(k):

P ;N (ki); out(k)(cid:107)Q;N (ki); out(k) ∼=O P ;N −1(ki); P (l);0; out(k)(cid:107)Q;N −1(ki); Q(l);0; out(k)

(I)

Now, with Theorem 2 applied on P (l);0; out(k)(cid:107)Q(l);0; out(k) ∼=O P (l);0; out(l(cid:48))(cid:107)Q(l);0; out(l(cid:48))

with l(cid:48) a fresh name, with P := P (ki);N −1 and Q := Q(ki);N −1, we obtain:

P (ki);N −1; P (l);0; out(k)(cid:107)Q;N −1(ki); Q(l); out(k) ∼=O P (ki);N −1; P (l);0; out(l(cid:48))(cid:107)Q(ki);N −1; Q(l);0; out(l(cid:48))

(II)

We also perform an application of Theorem 4 on (i) with A = P (ki);N −1, B = Q(ki);N −1,

P1(k) := P (ki);0; out(l) and P2(k) := Q(ki);0; out(l) :

P (ki);N −1; P (l);0; out(l(cid:48))|Q(ki);N −1; P (l);0; out(l(cid:48)) ∼=O P (ki);N ; out(l)(cid:107)Q(ki);N ; out(l)

(III)

We conclude by transitivity with (I),(II) and (III).

Simulatability is stable by binding names that do not appear in the protocol, which means
that we will be able simulate at the same times two simulatable protocol who do not share
long term secret.

Lemma 37. Given a cryptographic library Mf , a sequence of names n, an oracle O with
support n and a sequence of terms t, if νn.t is O-simulatable , then for any sequence of names
m such that m ∩ N (t1, . . . , tn) = ∅, νn ∪ m.t is O-simulatable.

84

Proof. Let there be a cryptographic library Mf , a sequence of names n, an oracle O with
support n and a sequence of terms t O-simulatable. As the names of m do not appear in t,
the probability of any event regarding t is independent from an event regarding m so we have
for any PTOM AO, η, sequences c, v, w ∈ {0, 1}∗,

Pρs,ρr1 ,ρr2 ,ρO {AO(ρs,ρO)(Mf , m1, . . . , mk, ρr2, η) = c | [[n]]η
Pρs,ρr1 ,ρr2 ,ρO {AO(ρs,ρO)(Mf , m1, . . . , mk, ρr2, η) = c | [[n]]η

ρs = v, [[m]]η
ρs = v}

= Pρs,ρr,ρO {[[t1, . . . , tn]]η
= Pρs,ρr,ρO {[[t1, . . . , tn]]η

ρs,ρr,ρO = c|[[n]]η
ρs,ρr,ρO = c|[[n]]η

ρs = v}
ρs = v, [[m]]η

ρs = w}

ρs = w}

Thus νn ∪ m.t is O-simulatable.

Proposition 17. Let Or be an oracle parameterized by a sequence of names s, and O an
oracle. Let p be a sequence of names, P (x), R1
i (x, y) and Q(x) be protocols,
such that Nl(R1
i ) is disjoint of the oracle support. If we have, for sequences of names
k
1
, . . . , lsid
lsid

i , . . . , Rk
j
i }1≤j≤k,i∈N :
, with s = {lsid

i (x, y), . . . , Rk

j
1. ∀i, j ∈ N, νp, lsid

i .Rj

j
i ) is Or-simulatable.
i (p, lsid

2. P (p) ∼=Or Q(p)

3. s is disjoint of the support of O.

Then, for any integers N1, . . . , Nk:

P (p)(cid:107)i≤N1(R1

k
1
i )(cid:107) . . . (cid:107)i≤Nk Rk
i (p, lsid
i )
i (p, lsid
1
i )(cid:107) . . . (cid:107)i≤Nk Rk
i (p, lsid

∼=O,Or Q(p)(cid:107)i≤N1R1

k
i (p, lsid
i )

Speciﬁcally, there exists a polynomial pS (independent of all Rj) such that if pRj is the

polynomial bound on the runtime of the simulator for Rj, we have,

AdvP (p)(cid:107)i≤N1 (R1

i (p,lsid

1
i )(cid:107)...(cid:107)i≤Nk Rk

i (p,lsid

k
i )∼=OQ(p)(cid:107)i≤N1 R1

i (p,lsid

1
i )(cid:107)...(cid:107)i≤Nk Rk

i (p,lsid

k

i )(t)

≤ AdvP (p)∼=O,Or Q(p)(cid:16)

(cid:0)t, N1, |R1|, . . . , Nk, |Rk|, pR1(t), . . . , pRk (t)(cid:1)(cid:17)

pS

Rather than proving the previous Theorem, where we recall that the protocols may depend
on a predicate T (x) whose interpretation depends on s, we prove the version where P directly
depends on s.

Proposition 38. Let Or be an oracle parameterized by a sequence of names s. Let p be
a sequence of names, P (x), R1
i (x, y, z) and Q(x, y) be protocols, such that
1
Nl(R1
i , . . . , Rk
i ) is disjoint of the oracle support. If we have, for sequences of names lsid
j
i }i,j∈N :
with s = {lsid

i (x, y, z), . . . , Rk

k
, . . . , lsid

,

j
1. ∀i, j ∈ N, νp, lsid

i .Rj

j
i (p, lsid
i , s) is Or-simulatable.

2. P (p) ∼=O Q(p, s)

85

Then, for any integers N1, . . . , Nk:

P (p)(cid:107)i≤N1(R1

1
i , s)(cid:107) . . . (cid:107)i≤Nk Rk
i (p, lsid

k
i (p, lsid
i , s)
1
i , s)(cid:107) . . . (cid:107)i≤Nk Rk
i (p, lsid

∼=Or Q(p, s)(cid:107)i≤N1R1

k
i , s)
i (p, lsid

Speciﬁcally, there exists polynomial pS (independent of all Rj)such that if pRj is the poly-

nomial bound on the runtime of the simulator for Rj, we have,

AdvP (p)(cid:107)i≤N1 (R1

1
i ,s)(cid:107)...(cid:107)i≤Nk Rk
i (p,lsid
≤ AdvP (p)∼=OQ(p,s)(cid:16)

k
i ,s)∼=Or Q(p,s)(cid:107)i≤N1 R1
i (p,lsid

1
i ,s)(cid:107)...(cid:107)i≤Nk Rk
i (p,lsid
(cid:0)t, N1, |R1|, . . . , Nk, |Rk|, pR1(t), . . . , pRk (t)(cid:1)(cid:17)

pS

k
i (p,lsid

i ,s)(t)

Proof. We prove the result for k = 1, denoting R1 as R, as the generalization is immediate.
Let there be an integer n.

Hypothesis 1 with Lemma 37 gives us that for 1 ≤ i ≤ N , νlsidi, p.Ri(p, lsidi, s) is OR-

simulatable.

Moreover, with δ = {p, s}, N (Ri(p, lsidi, s)) ∩ δ = {p, lsidi}, so thanks to Theorem 1, for

1 ≤ i ≤ N , νδ.R(p, lsidi, s) is OR-simulatable.

Now, up to renaming of the local names of R (which is possible as they do not appear in
the oracle support), we have that ∀1 ≤ i < j ≤ N.N (Ri(p, lsidi, s)) ∩ N (Rj(p, lsidj, s)) ⊂ δ,
so with Theorem 1 we have that (cid:107)i≤N Ri(p, lsidi, s) is OR-simulatable.

Note that if R is simulatable by a simulator bounded by a polynomial pR(t) on an input
of size t, then (cid:107)i ≤ N R(p, lsidi, s) is simulatable by a simulator bounded by a polynomial
q(n, pR(t)), where q is uniform in n and R.

Finally, we have that (cid:107)i≤N Ri(p, lsidi, s) is OR-simulatable and P (p, lsidn) ∼=O Q(p, s), so

we conclude with Theorem 2.

Instantiating the bound on the advantage from Theorem 2 with |C| = n|R| and pC(t) =

q(n, pR(t)) yields the desired result.

Theorem 5. Let Or, O be oracles both parameterized by a sequence of names s. Let p be
a sequence of names, Pi(x, y) and Qi(x, y) be parameterized protocols, such that Nl(P, Q) is
disjoint of the oracles support.
, with s =
P
Q
i }i∈N:
i , lsid
{lsid

P
If we have, for sequences of names lsid

, lsid

Q

P
P
1. ∀ i ≥ 1, νp, lsid
i ) is Or-simulatable.
i .Pi(p, lsid
Q
Q
i ) is Or-simulatable.
i .Qi(p, lsid

2. ∀ i ≥ 1, νp, lsid

3. s is disjoint of the support of O.

P
4. P0(p, lsid

0 ) ∼=Or,O Q0(p, lsid

Q
0 )

then,

Q
i )
We once again generalize with the explicit dependence in s.

i ) ∼=O ||iQi(p, lsid

P
||iPi(p, lsid

Theorem 7. Let Or, O be oracles both parameterized by a sequence of names s. Let p be
a sequence of names, Pi(x, y) and Qi(x, y, z) be parameterized protocols, such that Nl(P, Q)
, with
is disjoint of the oracles support.
Q
P
i }i∈N :
i , lsid
s = {lsid

P
If we have, for sequences of names lsid

, lsid

Q

86

P
P
i ) is Or-simulatable.
i .Pi(p, lsid
1. ∀ i ≥ 1, νp, lsid

2. ∀ i ≥ 1, νp, lsid

Q
i .Qi(p, lsid

Q
i , s) is Or-simulatable.

3. s is disjoint of the support of O.

P
4. P0(p, lsid

0 ) ∼=Or,O Q0(p, lsid

Q
0 , s)

then,

P
||iPi(p, lsid

i ) ∼=O ||iQi(p, lsid

Q
i , s)

Proof. By application of Theorem 5, we get that for all n1, n2,

Q
P
P
0 )(cid:107)1<i≤N1Pi(p, lsid
i )(cid:107)1<i≤N2Qi(p, s, lsid
i )
P0(p, lsid
∼=Or,O
Q
P
Q
i )(cid:107)1<i≤N2Qi(p, s, lsid
0 )(cid:107)1<i≤N1Pi(p, lsid
i )

Q0(p, s, lsid

By weakening of the attacker, we get:

Q
P
P
0 )(cid:107)1<i≤N1Pi(p, lsid
i )(cid:107)1<i≤N2Qi(p, s, lsid
i )
P0(p, lsid
∼=O

Q0(p, s, lsid

Q
P
Q
i )(cid:107)1<i≤N2Qi(p, s, lsid
0 )(cid:107)1<i≤N1Pi(p, lsid
i )

Then, for a polynomial p (assumed without loss of generality increasing), any n = p(η),

and all j < n:

Q
P
P
i )(cid:107)1<i≤N −j−1Qi(p, s, lsid
0 )(cid:107)1<i≤j−1Pi(p, lsid
P0(p, lsid
i )
∼=O
Q
P
Q
i )(cid:107)1<i≤N −j−1Qi(p, s, lsid
0 )(cid:107)1<i≤j−1Pi(p, lsid
i )

Q0(p, s, lsid

Through the renaming of the lsid, which is possible as s is disjoint from the oracle support,

we get that:

P
P
P
Pj(p, lsid
j−1)(cid:107)Qj+1(p, s, lsid
0 ) . . . (cid:107)Pj−1(p, lsid
j )(cid:107)P0(p, lsid
∼=O
P
P
Q
j−1)(cid:107)Qj+1(p, s, lsid
0 ) . . . (cid:107)Pj−1(p, lsid
j , s)(cid:107)P0(p, lsid

Qj(p, lsid

Q
j+1)(cid:107) . . . Qn(p, s, lsid

Q
n )

Q
j+1)(cid:107) . . . Qn(p, s, lsid

Q
n )

Thanks to Theorem 5, there exist polynomial pS such that, if pP and pQ are the polynomial
bound on the runtime of the simulators for P or Q, for all j, we have that the advantage of any
attacker running in time t against the previous indistinguishability, denoted D, is bounded
by:

AdvD(cid:16)

(cid:0)t, j − 1, |P |, . . . , p(η) − j − 1, |q|, pP (t), . . . , pQ(t)(cid:1)(cid:17)

pS

Thus, for all j, the advantage of any attacker against the corresponding game is uniformly
bounded by:

AdvD(cid:16)
We then conclude with an hybrid argument.

pS

(cid:0)t, p(η), |P |, . . . , p(η), |q|, pP (t), . . . , pQ(t)(cid:1)(cid:17)

87

F.5 Key Exchanges

We ﬁrst prove a proposition which allows to reduce the security of n sessions in parallel to the
security of one session with N − 1 sessions in parallel. It is expressed in a more general way
than required for basic key exchanges, so that we can reuse it for other results.

Proposition 39. Let O be an oracle and KEi[_1, _2] := Ii(lsidI
a key exchange protocol, such that I binds xI , xI
is disjoint of the oracle support. Let idI , idR be names, sI = {lsidI
s = sI ∪ sR sets of names,

lsid, R binds xR, xR

id, xI

i , idI ); _1(cid:107)Ri(lsidR
id, xR

i , idR); _2
lsid and Nl(KE)
i }i∈N,

i }i∈N, sR = {lsidR

Let T1(x),T2(x), S1(x),S2(x) be parametric processes with completely disjoint names. Let
i }1≤i≤N and Os an oracle.

N be an integer (which may depend on η), and let s = {lsidI
If s is disjoint of the support of O and if,

i , lsidR

1. νs.out(s) is Os-simulatable.

(cid:107)KEn[

lsid, xI
(cid:107)i≤N −1KEi[out((cid:104)xI , lsidI , xI
if xI
id = idR then
lsid /∈ sR ∧ xI
lsid, xI
S1(xI , lsidI , xI
id)
lsid, xI
else out((cid:104)xI , lsidI , xI
if xR
id = idI then
lsid /∈ sI ∧ xR
lsid, xR
S2(xR, lsidR, xR
id)
lsid, xR
else out((cid:104)xR, lsidR, xR
lsid, xI

(cid:107)i≤N −1KEi[out((cid:104)xI , lsidI , xI
if xI
(cid:107) KEn[

2.

id(cid:105)), out((cid:104)xR, lsidR, xR

lsid, xR

id(cid:105))]

id(cid:105)),

∼=O,Os

id(cid:105))]
id(cid:105)), out((cid:104)xR, lsidR, xR

lsid, xR

id(cid:105))]

lsid = lsidR
out((cid:104)k, lsidI
lsid /∈ sR ∧ xI
T1(xI , lsidI

id = idR then

n ∧ xI
n, xlsid, xid(cid:105))

id = idR then

n, xlsid, xid)

if xI

else out((cid:104)xI , lsidI , xI
if xR

lsid, xI
id(cid:105)),
id = idI then

lsid = lsidI
out((cid:104)k, lsidR
lsid /∈ sI ∧ xR
T2(xR, lsidR

n ∧ xR
n , xlsid, xid(cid:105))
id = idI then

n , xlsid, xid)

if xR

else out(xR, lsidR, xR

lsid, xR
id)

88

Then:

(cid:107)i≤N KEi[

if xI

id = idR then
lsid /∈ sR ∧ xI
S1(xI , lsidI , xI
lsid, xI
id)
lsid, xI
else out((cid:104)xI , lsidI , xI
lsid /∈ sI ∧ xR
id = idI then
if xR
lsid, xR
S2(xR, lsidR, xR
id)
lsid, xR
else out((cid:104)xR, lsidR, xR

id(cid:105)),

id(cid:105))]

∼=O

(cid:107)i≤N KEi[

if
1≤j≤N

id = idR then

j ∧ xI

lsid = lsidR
xI
out((cid:104)ki,j, lsidI

i , xlsid, xid(cid:105))

id = idR then
n, xlsid, xid)
lsid, xI
id(cid:105)),
id = idI ) then

j ∧ xR

if xI

lsid /∈ sR ∧ xI

T1(xI , lsidI

else out((cid:104)xI , lsidI , xI

if
1≤j≤N

lsid = lsidI
xR
out((cid:104)kj,i, lsidR

i , xlsid, xid(cid:105))

if xR

lsid /∈ sI ∧ xR

id = idI then

T2(xR, lsidR
else out((cid:104)xR, lsidR, xR

n , xlsid, xid)
lsid, xR
id(cid:105))]

Proof. We ﬁx N and deﬁne an ordering (arbitrary) on the couples (i, j)1≤i,j≤N

. We then set:

G0

(i,j) :=
(cid:107)r≤N KEr[

if
(r,t)≥(i,j)

id = idR then

out((cid:104)kr,t, lsidI
if
(r,t)≥(i,j)

t ∧ xI
lsid = lsidR
xI
r, xI
xI
lsid /∈ sR ∧ xI
r, xI

lsid, xI

T1(xI , lsidI

id)

lsid, xI
id(cid:105))
id = idR then

else if xI

lsid /∈ sR ∧ xI
S1(xI , lsidI , xI
else out((cid:104)xI , lsidI , xI

id = idR then
lsid, xI
id)
lsid, xI

id(cid:105)),

id = idI ) then

if
(t,r)≥(i,j)

lsid = lsidI
xR
out((cid:104)kt,r, lsidR
if
(t,r)≥(i,j)

t ∧ xR
r , xR
xR
lsid /∈ sI ∧ xR

lsid, xR
id)
id = idI then

else if xR

T2(xR, lsidR

r , xR
lsid /∈ sI ∧ xR
S2(xR, lsidR, xR
else out((cid:104)xR, lsidR, xR

lsid, xR
id)
id = idI then
lsid, xR
id)
lsid, xR

id(cid:105))]

89

and

G1

(i,j) :=
(cid:107)r≤N KEr[

if
(r,t)>(i,j)

id = idR then

out((cid:104)kr,t, lsidI
if
(r,t)>(i,j)

t ∧ xI
lsid = lsidR
xI
r, xI
lsid /∈ sR ∧ xI
xI
r, xI

lsid, xI

T1(xI , lsidI

id)

lsid, xI
id(cid:105))
id = idR then

else if xI

lsid /∈ sR ∧ xI
S1(xI , lsidI , xI
else out((cid:104)xI , lsidI , xI

id = idR then
lsid, xI
id)
lsid, xI

id(cid:105)),

id = idI ) then

if
(t,r)>(i,j)

lsid = lsidI
xR
out((cid:104)kt,r, lsidR
if
(t,r)>(i,j)

t ∧ xR
r , xR
lsid /∈ sI ∧ xR
xR

lsid, xR
id)
id = idI then

else if xR

T2(xR, lsidR

r , xR
lsid /∈ sI ∧ xR
S2(xR, lsidR, xR
else out((cid:104)xR, lsidR, xR

lsid, xR
id)
id = idI then
lsid, xR
id)
lsid, xR

id(cid:105))]

We note that G1

(i,j) = G0

, that G0
is the game on the left hand side of the goal.

(i,j)+1

(0,0)

and that G0

(n,n)

is the game on the right hand side of the goal,

Thus, if we have uniformly that G1

∼= G0

(i,j)

, we can conclude with a classical hybrid

(i,j)

We remark that G1

and G0

(i,j)

only diﬀer in two places, where a conditional is added in

(i,j)

argument.

Ii and one in Rj.

Let us ﬁx (i, j), we deﬁne the substitution σ := {lsidI
n, lsidR
j

(cid:55)→
n } and denote s(cid:48) = sσ. We apply the substitution both to the oracle and

lsidI
the protocol, and the hypothesis allows us to get, for all N :

N (cid:55)→ lsidR

n (cid:55)→ lsidI

i , lsidR

j , lsidI
i

(cid:55)→ lsidR

90

id(cid:105))(cid:107)Rs(lsidR

s , idR); out((cid:104)xR, lsidR

s , xR

lsid, xR

id(cid:105))

s , idR); out((cid:104)xR, lsidR

s , xR

lsid, xR

id(cid:105))

(cid:107)(r,s)(cid:54)=(i,j)Ir(lsidI
i , idI );
(cid:107)Ii(lsidI

(cid:107)Rj(lsidR

j , idR)[

if xI

r, idI ); out((cid:104)xI , lsidI
lsid /∈ sR ∧ xI
S1(xI , lsidI
i , xI
else out((cid:104)xI , lsidI
lsid /∈ sI ∧ xR
if xR
S2(xR, lsidR
j , xR
else out((cid:104)xR, lsidR

r, xI
lsid, xI
id = idR then
lsid, xI
id)
lsid, xI
i , xI
id),
id = idI then
lsid, xR
id)
j , xR
lsid, xid(cid:105))

∼=O,Os(cid:48)
(cid:107)(r,s)(cid:54)=(i,j)Ir(lsidI
(cid:107) Ii(lsidI

r, idI ); out((cid:104)xI , lsidI
i , idI );

if xI

(cid:107) Rj(lsidR

j , idR)[

if xI

lsid, xI
j ∧ xI
i , xI

id(cid:105))(cid:107)Rs(lsidR
id = idR then
lsid, xI
id)

r, xI
lsid = lsidR
out((cid:104)k, lsidI
id = idR then
lsid /∈ sR ∧ xI
lsid, xI
r, xI
T1(xI , lsidI
id)
else out((cid:104)xI , lsidI
i , xlsid, xid(cid:105))
id = idI then
i ∧ xR
lsid = lsidI
if xR
lsid, xR
i , xR
out((cid:104)k, lsidR
id(cid:105))
id = idI then
lsid /∈ sI ∧ xR
lsid, xR
T2(xR, lsidR
id)
lsid, xR
i , xR

r , xR
else out((cid:104)xR, lsidR

if xR

id(cid:105))

We remark that, for any r:

νs.in(x, y);

if
(r,t)>(i,j)

lsidlsidR
x=

t ∧ xid = idR then out(kr,t, y) else out(x, y)

and

νs.in(x, y);

and (resp. with S1)

if
(t,r)>(i,j)

lsid = lsidI
xR

t ∧ xid = idR then out(kt,r, y) else out(x, y)

νs.in(y);

if
(r,t)>(i,j)

lsid /∈ sR ∧ xI
xI

id = idR then T1(y)

and (resp. with S2)

νs.in(y);

if
(t,r)>(i,j)

lsid /∈ sI ∧ xR
xR

id = idI then T2(y)

are Os-simulatable by the attacker as all lsidR
They are then all simulatable in parallel at the same time (Theorem 1) and using function

are simulatable with Os

j , lsidI
j

application (Theorem 4), we get:

91

∼=O

(cid:107)r≤N KEr[

id = idR then

if
(r,t)>(i,j)

out((cid:104)kr,t, lsidI
if
(r,t)>(i,j)

t ∧ xI
lsid = lsidR
xI
r, xI
xI
lsid /∈ sR ∧ xI
r, xI

lsid, xI

T1(xI , lsidI

id)

lsid, xI
id(cid:105))
id = idR then

else if xI

lsid /∈ sR ∧ xI
S1(xI , lsidI , xI
else out((cid:104)xI , lsidI , xI

id = idR then
lsid, xI
id)
lsid, xI

id(cid:105)),

,

id = idI ) then

if
(t,r)>(i,j)

lsid = lsidI
xR
out((cid:104)kt,r, lsidR
if
(t,r)>(i,j)

t ∧ xR
r , xR
xR
lsid /∈ sI ∧ xR

lsid, xR
id)
id = idI then

else if xR

T2(xR, lsidR

r , xR
lsid /∈ sI ∧ xR
S2(xR, lsidR, xR
else out((cid:104)xR, lsidR, xR

lsid, xR
id)
id = idI then
lsid, xR
id)
lsid, xR

id(cid:105))]

(cid:107)(r,s)(cid:54)=(i,j)Ir(lsidr

I , idI );

(cid:107)Rs(lsids

R, idR);

id = idR then

if
(r,t)>(i,j)

out((cid:104)kr,t, lsidI
if
(r,t)>(i,j)

t ∧ xI
lsid = lsidR
xI
r, xI
lsid /∈ sR ∧ xI
xI
r, xI

lsid, xI

T1(xI , lsidI

id)

lsid, xI
id(cid:105))
id = idR then

else if xI

lsid /∈ sR ∧ xI
S1(xI , lsidI , xI
else out((cid:104)xI , lsidI , xI

id = idR then
lsid, xI
id)
lsid, xI

id(cid:105))

id = idI ) then

if
(t,r)>(i,j)

lsid = lsidI
xR
out((cid:104)kt,r, lsidR
if
(t,r)>(i,j)

t ∧ xR
s , xR
xR
lsid /∈ sI ∧ xR

lsid, xR
id)
id = idI then

Ii(lsidi

I , idI );

Rj(lsidj

R, idR);

else if xR

T2(xR, lsidR

s , xR
lsid /∈ sI ∧ xR
s , xR

lsid, xR
id)
id = idI then
lsid, xR
id)
lsid, xR
s , xR
id = idR then

S2(xR, lsidR
else out((cid:104)xR, lsidR
lsid = lsidR
xI

id(cid:105))

if
(i,t)>(i,j)

if xI

id(cid:105))

t ∧ xI
lsid, xI
out((cid:104)kr,t, lsidI
i , xI
j ∧ xI
lsid = lsidR
id = idR) then
out((cid:104)k, lsidI
lsid, xI
i , xI
id(cid:105))
xI
lsid /∈ sR ∧ xI
id = idR then
i , xI

T1(xI , lsidI

lsid, xI

id)

if
(i,t)>(i,j)

else if xI

lsid /∈ sR ∧ xI
S1(xI , lsidI
i , xI
else out((cid:104)xI , lsidI

id = idR then
lsid, xI
id)
lsid, xI
i , xI

id(cid:105))

id = idI ) then

if xR

if
(t,j)>(i,j)

if
(t,j)>(i,j)

lsid = lsidI
xR
t ∧ xR
out((cid:104)kt,r, lsidR
j , xR
lsid, xR
id(cid:105))
i ∧ xR
lsid = lsidI
id = idI ) then
lsid, xR
j , xR
out((cid:104)k, lsidR
id(cid:105))
xR
id = idI then
lsid /∈ sI ∧ xR
lsid, xR
id)
id = idI then
lsid, xR
id)
lsid, xR
j , xR
id(cid:105))
92

j , xR
lsid /∈ sI ∧ xR
j , xR

T2(xR, lsidR

S2(xR, lsidR
else out((cid:104)xR, lsidR

else if xR

After α-renaming k into ki,j, this is exactly G1
Note that the advantage, for any (i, j), against G1
from Theorem 4, by the the advantage against G1
are simulated.

(0,0)

(i,j)

(i,j)

∼= G0
∼= G0

(i,j)

, which concludes the proof.
is bounded, using the bound
, the case where the most things

(i,j)

∼= G0

(0,0)

Corollary 1. Let Oke, O be oracles and KEi[_1, _2] := I(lsidI
a key exchange protocol, such that I binds xI , xI
disjoint of the oracle support. Let idI , idR be names and sI = {lsidI
of names :

lsid, R binds xR, xR

id, xI

i , idI ); _1(cid:107)R(lsidR

i , idR); _2
lsid and Nl(KE) is
i }i∈N sets

i }i∈N,sR = {lsidR

id, xR

1. ∀i ≥ 1, (νlsidI

i , idI , lsidR

i , idR.

KEi[out((cid:104)xI , lsidI

i , xI

lsid, xI

id(cid:105)), out((cid:104)xR, lsidR

i , xR

lsid, xR

id(cid:105))](cid:107)out((cid:104)lsidR

i , lsidI

i (cid:105))

is Oke simulatable)).

2. s is disjoint of the support of O.

KE0[out((cid:104)xI , lsidI
if xI
KE0[

0, xI
lsid = lsidR
out((cid:104)k, lsidI

id(cid:105)), out((cid:104)xR, lsidR
id = idR then

lsid, xI
0 ∧ xI
0, xlsid, xid(cid:105))

else if xI

lsid /∈ sR ∧ xI

id = idR then

⊥

0 , xR

lsid, xR

id)] ∼=Oke,O

3.

else out((cid:104)xI , lsidI
lsid = lsidI
if xR
out((cid:104)k, lsidR

0 ∧ xR
0 , xR

else if xR

lsid /∈ sI ∧ xR

lsid, xI
0, xI
id(cid:105)),
id = idI then
lsid, xR
id(cid:105))
id = idI then

⊥

else out((cid:104)xR, lsidR

0 , xR

lsid, xR

id(cid:105))]

Then, for any N which depends on the security parameter:

(cid:107)i≤N KEi[out(xI ), out(xR)] ∼=O

(cid:107)i≤N KEi[

if (xI
id = idR) then
lsid = lsidR
xI
if
1≤j≤N

j ∧ xI

id = idR then

out(ki,j)

else out(xI ),
if (xR
id = idI ) then
lsid = lsidI
xR
if
1≤j≤N

j ∧ xR

id = idI then

Proof. Let us ﬁx N , which may depend on the security parameter.

out(kj,i)

else out(xR)]

Ry direct application of Theorem 5, with P := I(lsidI , idI ); out((cid:104)xI , lsidI , xI

lsid, xI

id(cid:105))(cid:107)R(lsidR, idR); out((cid:104)xR, lsidR, xR

lsid, xR

id(cid:105)),

93

R := KE, and Q being the right handside of hypothesis (3), we get that:

(cid:107)i≤N KEi[out((cid:104)xI , lsidI
∼=O,Oke

i , xI

lsid, xI

id(cid:105)), out((cid:104)xR, lsidR

i , xR

lsid, xR

id(cid:105))]

(cid:107)i≤N −1KEi[out((cid:104)xI , lsidI

i , xI

lsid, xI

id(cid:105)), out((cid:104)xR, lsidR

i , xR

lsid, xR

id(cid:105))]

(cid:107)KE0[

if xI

lsid = lsidR ∧ xid = idR then
out((cid:104)k, lsidI , xlsid, xid(cid:105))
lsid /∈ sR ∧ xI

id = idR then

else if xI

⊥

else out((cid:104)xI , lsidI , xI
lsid = lsidI ∧ xR
if xR
out((cid:104)k, lsidR, xR

else if xR

lsid /∈ sI ∧ xR

lsid, xI
id(cid:105)),
id = idI then
lsid, xR
id(cid:105))
id = idI then

⊥

lsid, xR
This allows us to obtain the hypothesis of Proposition 39, where Os is instantiated with

else out((cid:104)xR, lsidR, xR

id(cid:105))]

Oke. We thus conclude using Proposition 39.

Corollary 2. Let OT , Oke, Or,OP,Q be oracles and

KEi[_1, _2] := I(lsidI

binds xI , xI
idI , idR be names, sI = {lsidI

lsid, R binds xR, xR

id, xI

i , idI ); _1(cid:107)R(lsidR
id, xR

i , idR); _2 a key exchange protocol, such that I
lsid and Nl(KE) is disjoint of the oracle support. Let
i }i∈N and s = sI ∩ sR sets of names.

i }i∈N,sR = {lsidR

Let p = {idI , idR}, P (x, y) = P1(x, y)(cid:107)P2(x, y) and Q(x, y, z) = Q1(x, y, z)(cid:107)Q1(x, y, z) be

parameterized protocols, such that Nl(P, Q) is disjoint of the oracle support.

I-1 ∀i ≥ 1, (νlsidI

i , idI , lsidR

i , idR.KEi[out(xI ), out(xR)](cid:107)out((cid:104)lsidR

i , lsidI

i (cid:105)) is OT -simulatable)).

I-2 s is disjoint of the support of OP,Q.

KE0[out((cid:104)xI , lsidI
[if xI
KE0

0, xI
lsid = lsidR
out((cid:104)k, lsidI

lsid, xI
0 ∧ xI
0, xI
lsid /∈ sR ∧ xI

else if xI

id(cid:105)), out((cid:104)xR, lsidR
id = idR then
id(cid:105))

lsid, xI

id = idR then

⊥

0 , xR

lsid, xR

id(cid:105)) ∼=OT ,OP,Q

I-3

and

else out((cid:104)xI , lsidI
lsid = lsidI ∧ xR
if xR
0 , xR
out((cid:104)k, lsidR

else if xR

lsid /∈ sI ∧ xR

lsid, xI
0, xI
id(cid:105)),
id = idI then
lsid, xR
id(cid:105))
id = idI then

⊥

else out((cid:104)xR, lsidR

0 , xR

lsid, xR

id(cid:105))]

R-1 ∀ 1 ≤ i, j ≤ n, νp, ki,j.P0(p, ki,j) is Or-simulatable.

R-2 ∀ 1 ≤ i ≤ n, νp, ki,j.Q0(p, ki,j) is Or-simulatable.

R-3 s is disjoint of the support of Ok.

94

R-4 P0(p, k) ∼=Or,Oke Q0(p, k)

and

C-1 νp.in(xI

i ).P I

i (xI

i )(cid:107)in(xR

i ).P R

i (xR

i )is OP,Q-simulatable.

(cid:107)i≤n KEi[

1. νp.

if
1≤j≤n

(xI

id = idR) then

if (xI
lsid = lsidR

id = idR) then
j ∧ xI
out((cid:104)i, j(cid:105))
i (xI
else P I
i ),
id = idI ) then

if (xR
lsid = lsidI

j ∧ xR
out((cid:104)i, j(cid:104))
i (xR

i )]

else P R

if
1≤j≤n

(xR

id = idI ) then

is Oke-simulatable.

Then, for any n which may depend on the security parameter:

(cid:107)i≤nKEi[P I
i ) else P I
i (xI
Proof. Using Corollary 1 on hypothesis A-1,A-2 and A-3, we get that, for all N :

i )] ∼=
id = idI then QR

i ), P R
i (xR
i ), if xR

id = idR then QI

(cid:107)i≤nKEi[if xI

i (xI
i (xI

i (xR

i ) else P R

i (xR

i )]

(cid:107)i≤N KEi[out(xI ), out(xR)] ∼=O

(cid:107)i≤N KEi[

id = idR) then
if (xI
lsid = lsidR
xI
if
1≤j≤N

j ∧ xI

id = idR then

out(ki,j)

else out(xI ),
if (xR
id = idI ) then
lsid = lsidI
xR
if
1≤j≤N

j ∧ xR

id = idI then

out(kj,i)

else out(xR)]

Now, as νp, lsidI

i , lsidR

i .in(x).P (x)(cid:107)in(x).Q(x) is Op-simulatable (hypothesis C-1), using

twice Theorem 4 we get that :

(cid:107)i≤N KEi[P I (xI ), P R(xR)] ∼=Op

(cid:107)i≤N KEi[

if (xI
id = idR) then
lsid = lsidR
xI
if
1≤j≤N

j ∧ xI

id = idR then

P I (ki,j)

else P I (xI ),
if (xR
id = idI ) then
lsid = lsidI
xR
if
1≤j≤N

j ∧ xR

id = idI then

and

P R(kj,i)

else P R(xR)]

95

(cid:107)i≤N KEi[if xI

(cid:107)i≤N KEi[

id = idR then QI (xI ) else P I (xI ), if xR
if (xI
id = idR) then
lsid = lsidR
xI
if
1≤j≤N

j ∧ xI

id = idR then

id = idI then QR(xR) else P R(xR)] ∼=Op

QI (ki,j)

else P I (xI ),
if (xR
id = idI ) then
lsid = lsidI
xR
if
1≤j≤N

j ∧ xR

id = idI then

QR(kj,i)

else P R(xR)]

Moreover, using Theorem 5 on hypothesis B-1,B-2,B-3 and B-4, we get that

∀n (cid:107)i≤N 2

Pi(p, ki) ∼=Ok Qi(p, ki)

Combined with Theorem 2 on the Ok simulatability of the key exchange (hypothesis C-2)

we get:

(cid:107)i≤N KEi[

(cid:107)i≤N KEi[

id = idR) then
if (xI
lsid = lsidR
xI
if
1≤j≤N

j ∧ xI

id = idR then

P I (ki,j)

else P I (xI ),
if (xR
id = idI ) then
lsid = lsidI
xR
if
1≤j≤N

P R(kj,i)

else P R(xR)]

∼=
id = idR) then
if (xI
lsid = lsidR
xI
if
1≤j≤N

j ∧ xR

id = idI then

j ∧ xI

id = idR then

QI (ki,j)

else P I (xI ),
if (xR
id = idI ) then
lsid = lsidI
xR
if
1≤j≤N

j ∧ xR

id = idI then

We thus conclude with transitivity.

QR(kj,i)

else P R(xR)]

Corollary 3. Let OKE, Or,OP,Q be oracles and

KEi[_1, _2] := Ii(lsidI

i , idI ); _1|Ri(lsidRi, idR); _2

a key exchange protocol with Ii(lsidI
R0
disjoint of the oracles support. Let p = {idI , idR}, Pi(x, y) = P I

i , idR) :=
i (xR) such that I 0 binds xI , xid, xlsid, R0 binds xR, xid, xlsid and Nl(KE) is
i (x, y),Q(x, y, z) =

i (xI ) and Ri(lsidR

i , idI ) := I 0

i (x, y)(cid:107)P R

i , idR); R1

i , idI ); I 1

i (lsidR

i (lsidI

96

QI
i (x, y, z)(cid:107)QR
the oracles support.

i (x, y, z), Ci(z) and Di(z) be protocols, such that Nl(P, Q, C, D) is disjoint of

Let idI , idR be names, sI = {lsidI

i }i∈N,sR = {lsidR

i }i∈N and s = sI ∩ sR sets of names.

A-1 ∀i ∈ N, (νlsidI
simulatable)).

i , idI , lsidR

i , idR.Ci(p)(cid:107)I 0

i (lsidI

i , idI ); out(xI )(cid:107)R0

i (lsidR

i , idR); out(xR) is OKE

A-2 s is disjoint of the support of Op.

Ci(p)(cid:107)I 0

0 (lsidI

0, idI );

(cid:107)R0(lsidR

0 , idR);

∼=OKE ,Op
Ci(p)(cid:107)I 0(lsidI

0, idI );

A-3

(cid:107)R0(lsidR

0 , idR);

if xI

id = idR then

lsid /∈ sR ∧ xI
I 1(xI ); out(xI )
else out((cid:104)xI , lsidI
if xR

lsid, xI
lsid /∈ sI ∧ xid = idI then
R1(xR); out(xR)
else out((cid:104)xR, lsidR, xR

0, xI

lsid, xR

id(cid:105))

id(cid:105))

if xI

lsid = lsidR ∧ xid = idR then
0, xI
out((cid:104)k, lsidI

lsid, xI

id(cid:105))

else if xI

lsid /∈ sR ∧ xI

id = idR then

I 1(xR); ⊥

else out((cid:104)xI , lsidI , xI
lsid = lsidI ∧ xR
if xR
0 , xR
out((cid:104)k, lsidR

else if xR

lsid /∈ sI ∧ xR

lsid, xI
id(cid:105))
id = idI then
lsid, xR
id(cid:105))
id = idI then

I 1(xR); ⊥

and for any N which may depend on the security parameter:

else out((cid:104)xR, lsidR

0 , xR

lsid, xR

id(cid:105))

B-1 (cid:107)i≤N 2Di(p)(cid:107)I 1

i (ki); P I

i (p, ki)(cid:107)B1

i (ki); P R

i (p, ki) ∼=Or,Ok (cid:107)i≤n2Di(p)(cid:107)I 1

i (ki); QI

i (p, ki)(cid:107)B1

i (ki); QR

i (p, ki)

and

C-1 νp, lsidI
(cid:107)in(x).I 1

i , lsidR
i (x); QI

i .Di(p)(cid:107)in(x).Pi(x) (cid:107)in(x).Qi(x)(cid:107)in(x).I 1

i (x); P I

i (x)(cid:107)in(x).R1

i (x); P R

i (x)

i (x)(cid:107)in(x).R1

i (x); QR

i (x) is Op simulatable.

(cid:107)i≤N Ci(p)(cid:107)I 0

i (lsidI

i , idI );

if
1≤j≤N

lsid = lsidR
xI

j ∧ xI

id = idR then

out((cid:104)i, j(cid:105))

C-2 νp.

(cid:107)R0

i (lsidR

i , idR)[

j ∧ xR

id = idI then

lsid /∈ sR ∧ xI

id = idR then

else if xI
I 1
i (xI ); ⊥
else I 1
if
1≤j≤N

i (xI ); P I
i (xI )
lsid = lsidI
xR

out((cid:104)i, j(cid:105))

else if (xR

lsid /∈ sI ∧ xR

id = idI then

i (xR); ⊥

R1
else R1

i (xR); P R

i (xR)

is Ok simulatable.

97

Then, for any n:

(cid:107)i≤N Ci(p)(cid:107)Di(p)(cid:107)KEi[P I
id = idR then QI

i (xI ), P R

i (xR)] ∼=

(cid:107)i≤N Ci(p)(cid:107)Di(p)(cid:107)KEi[if xI

i (xR) else P R
i (xI ) else P I
Proof. Let N an integer, which may depend on the security parameter. Ry application of
Theorem 5, with P and R as the left handside of hypothesis A-3, and Q being the right
handside of hypothesis A-3, we get that:

id = idI then QR

i (xI ), if xR

i (xR)]

(cid:107)i≤n−1Ci(p)(cid:107)I 0
Cn(p)(cid:107)I 0

n(lsidI

i (lsidI

n, idI );

i , idI ); out(xI )(cid:107)R0

i (lsidR
lsid /∈ sR ∧ xid = idR then
if (xI
n(xI ); out(xI )
I 1

i , idR); out(xR)

(cid:107)

(cid:107)R0

n(lsidR

n , idR);

∼=OP

else out(xI )
lsid /∈ sR ∧ xI
if xI
n(xR); out(xR)
R1

else out(xR)

id = idI then

(cid:107)i≤N −1Ci(p)(cid:107)I 0
(cid:107) Cn(p)(cid:107)I 0

i (lsidI

i , idI ); out(xI )(cid:107)R0

n(lsidI

n, idI );

if xlsid = lsidn

i (lsidR
R ∧ xI

i , idR); out(xR)
id = idR then

lsid /∈ sR ∧ xI

id = idR then

(cid:107)R0

n(lsidR

n , idR)[

I ∧ xid = idI then

lsid /∈ sI ∧ xR

id = idI then

out(k)
else if xI

n(xI ); bad
I 1
else out(xI )
if xR

lsid = lsidn
out(k)
else if xR

R1

n(xR); bad
else out(xR)

Using Proposition 39, with S1 = I 1(xI ); out(xI ), S2 = R1(xR); out(xR), R1 = I 1(xI ); ⊥, R2 =
R1(xR); ⊥, we get that:

98

Ci(p)(cid:107)I 0

i (lsidI

i , idI );

(cid:107)R0

i (lsidR

i , idR);

(cid:107)i≤N

∼=OP

id = idR then

id = idI then

lsid /∈ sR ∧ xI
if xI
i (xI ); out(xI )
I 1

else out(xI )
lsid /∈ sI ∧ xR
if xR
i (xR); out(xR)
R1

else out(xR)

(cid:107)i≤N Ci(p)(cid:107)I 0

i (lsidI

i , idI );

if
1≤j≤N

lsid = lsidj
xI

R ∧ xI

id = idR then

(cid:107)R0

i (lsidR

i , idR)[

I ∧ xR

id = idI then

out(ki,j)

else if xI

lsid /∈ sR ∧ xI

id = idR then

i (xI ); bad
I 1
else out(xI )
lsid = lsidj
xR

if
1≤i≤N

out(kj,i)

R1

i (xR); bad
else out(xR)

else if xR

lsid /∈ sI ∧ xR

id = idI then

Now, with this context, using twice using Theorem 4 with the simulatability of νp, lsidI
i (x); P R

i (x) from C-1, we may get that:

i (x)(cid:107)in(x).R1

(cid:107)in(x).Pi(x)(cid:107)in(x).I 1

i (x); P I

i , lsidR

i .Di(p)

(cid:107)i≤N Ci(p)(cid:107)Di(p)(cid:107)I 0

i (lsidI

i , idI );

(cid:107)R0

i (lsidR

i , idR);

id = idR then

i (xI ); P I

lsid /∈ sR ∧ xI
if xI
I 1
i (xI )
i (xI ); P I
else I 1
i (xI )
if xR
lsid /∈ sI ∧ xid = idI then
R1
i (xR)
i (xR); P R
else R1

i (xR); P R

i (xR)

∼=OP

lsid = lsidR
xI
if
1≤j≤N
i (ki,j); P 1
I 1
i (ki,j)
lsid /∈ sR ∧ xI

else if xI

i (xI ); ⊥
I 1
else I 1
if
1≤k≤m
R1

i (xI )
i (xI ); P I
lsid = lsidI
xR
i (kj,i); P R
i (kj,i)
lsid /∈ sI ∧ xR

else if xR

i (xR); ⊥

R1
else R1

i (xR); P R

i (xR)

j ∧ xI

id = idR then

id = idR then

j ∧ xR

id = idI then

id = idI then

(cid:107)i≤N Ci(p)(cid:107)Di(p)(cid:107)I 0

i (lsidI

i , idI );

(cid:107)R0

i (lsidR

i , idR)[

99

We can simplify the left handside of the equivalence and get that:

(cid:107)i≤N Ci(p)(cid:107)Di(p)(cid:107)I 0
(cid:107)R0
∼=OP

i , idR);

i (lsidR

i (lsidI

i , idI );

I 1
i (xI ); P I
i (xR); P R
R1

i (xI )
i (xR)

(cid:107)i≤N Ci(p)(cid:107)Di(p)(cid:107)I 0

i (lsidI

i , idI );

(cid:107)R0

i (lsidR

i , idR);

lsid = lsidj
xI
if
1≤j≤m
i (ki,j); P 1
I 1
i (ki,j)
lsid /∈ sR ∧ xI

else if xI

I 1
i (xI ); bad
else I 1
if
1≤j≤N
R1

i (xI ); P I
i (xI )
lsid = lsidj
xR
i (kj,i)
lsid /∈ sI ∧ xR

i (kj,i); P R

else if xR

i (xR); ⊥

R1
else R1

i (xR); P R

i (xR)

R ∧ xid = idR then

id = idR then

I ∧ xR

id = idI then

id = idI then

Ry performing the same operation with Q, we can also get:

(cid:107)i≤N

∼=OP

Ci(p)(cid:107)Di(p)(cid:107)I 0

i (lsidI

i , idI );

(cid:107)R0

i (lsidR

i , idR);

id = idR then
if xI
I 1
i (xI )
i (xI ); QI
i (xI ); P I
else I 1
id = idI then
if xR
i (xR); QR
R1
else R1

i (xR); P R

i (xR)

i (xR)

i (xI )

(cid:107)i≤N Ci(p)(cid:107)Di(p)(cid:107)I 0

i (lsidI

i , idI );

(cid:107)R0

i (lsidR

i , idR)[

lsid = lsidR
xI
if
1≤j≤N
i (ki,j); Q1
I 1
i (ki,j)
lsid /∈ sR ∧ xI

else if xI

I 1
i (xI ); ⊥
else I 1
if
1≤j≤N
R1

i (xI ); P I (xI )
lsid = lsidI
xR
i (kj,i)
lsid /∈ sI ∧ xR

i (kj,i); QR

else if xR

i (xR); ⊥

R1
else R1

i (xR); P R

i (xR)

j ∧ xI

id = idR then

id = idR then

j ∧ xR

id = idI then

id = idI then

To conclude with transitivity, we must prove the equivalence between the two idealized

version with either P or Q.

Combining Hypothesis B-1 with Theorem 2 on the Ok simulatability of the key exchange

(hypothesis C-2) we do get the necessary equivalence to conclude:

100

(cid:107)i≤N Ci(p)(cid:107)Di(p)(cid:107)I 0

i (lsidI

i , idI );

(cid:107)R0

i (lsidR

i , idR)[

∼=

lsid = lsidR
xI
if
1≤j≤N
I 1
i (ki,j); P 1
i (ki,j)
lsid /∈ sR ∧ xI

else if xI

i (xI ); bad
I 1
else I 1
if
1≤j≤N
R1

i (xI ); P I
i (xI )
lsid = lsidj
xR
i (kj,i)
lsid /∈ sI ∧ xR

i (kj,i); P R

else if xR

i (xR); bad

R1
else R1

i (xR); P R

i (xR)

j ∧ xid = idR then

id = idR then

I ∧ xR

id = idI then

id = idI then

(cid:107)i≤N Ci(p)(cid:107)Di(p)(cid:107)I 0

i (lsidI

i , idI );

(cid:107)R0

i (lsidR

i , idR);

lsid = lsidR
xI
if
1≤j≤N
i (ki,j); Q1
I 1
i (ki,j)
lsid /∈ sR ∧ xI

else if xI

I 1
i (xI ); ⊥
else I 1
if
1≤j≤N
R1

i (xI )
i (xI ); P I
lsid = lsidI
xR
i (kj,i)
lsid /∈ sI ∧ xR

i (kj,i); QR

else if xR

i (xR); ⊥

R1
else R1

i (xR); P R

i (xR)

j ∧ xI

id = idR then

id = idR then

j ∧ xR

id = idI then

id = idI then

F.6 Computational soundness

Lemma 4. For protocols P, Q, A, B, an oracle O, and a list Ol of protocol oracles,

AO,O(A(cid:107)P )?(B(cid:107)Q) ≺ (cid:15) ⇔ AO,Ol,OA?B,OP ?Q ≺ (cid:15)

Proof. For protocols P, Q such that C(P ) ∩ C(Q) = ∅, for any message m, random tape ρs and
history tape θ, we have by deﬁnition of the semantic of (cid:107) and the deﬁnition of the parallel
oracles:

The desired result then immediately follows.

OP (cid:107)Q(ρs, θ)(m) =< OP , OQ > (ρs, θ)(m)

Lemma 29. Given two protocols P, Q, random tapes ρr, ρs, a cryptographic library Mf and
an oracle O, we have:

∀M ⊃ Mf . M |=O (cid:102)tP ∼ (cid:102)tQ

⇔
P ∼=O Q

101

Proof. Let us write (cid:102)tP = (cid:102)t0
. Without loss of generality, we assume that every distin-
guisher makes exactly n calls to the oracle, if it is not the case we simply add dummy calls
for the remaining ones.

P , . . . , (cid:102)tn
P

We start by proving the top to bottom implication. Given a distinguisher BO,OP ?Q and
) be the successive contents of the oracle input
η, ρr, we let m0, . . . , mk (resp. m(cid:48)
tape along the computation of AO(ρs,ρO),OP (ρs) (resp. AO(ρs,ρO),OQ(ρs)). Let σ = {x0 (cid:55)→
m0, . . . , xk (cid:55)→ mk} (resp. σ(cid:48) = {x1 (cid:55)→ m(cid:48)
,
k}). Consider now the PPTOM AO
gk
which, on input b0, . . . , bk, η, ρr, executes the same code as B, however replacing the ith call
to the oracle OP (resp. OQ), i ≤ k, using bi instead of the oracle reply.

1, . . . , xk (cid:55)→ m(cid:48)

0, . . . , m(cid:48)
k

The result of AO
gk

is then what B would have queried at the k + 1 oracle call. It follows
) if bi is the reply of OP (resp. OQ) on the query

that AO
(b0, . . . , bk, η, ρr) = mk (resp. m(cid:48)
gk
k
mi, for i < k. This deﬁnes an extension M of Mf .

Thanks to the Lemma 28, for every ρs, ρr, ρO, for every i ≤ k, [[ti

P ]]σ,η

ρs,ρr,ρO = OP (ρs, m0, . . . , mi−1)

Q]]σ(cid:48),η

ρs,ρr,ρO = OQ(ρs, m(cid:48)

and [[ti
1, . . . , m(cid:48)
the interpretation of gi, for every ρs, ρr, ρO, for every i ≤ k, [[(cid:102)ti
and [[(cid:102)ti

i−1). Now, according to our deﬁnition of (cid:102)tP and thanks to
ρs,ρr,ρO = OP (ρs, m0, . . . , mi−1)

P ]]η

Q]]η

ρs,ρr,ρO = OQ(ρs, m(cid:48)

i−1).
If we now consider the output of AO
gn

0, . . . , m(cid:48)

, we have that, for every ρr, ρO,

AO

gn([[(cid:102)t0

P ]]η

ρs,ρr,ρO

, . . . , [[(cid:102)tk

P ]]η

ρs,ρr,ρO

, η, ρr) = BO,OP

gn([[(cid:102)t0

and AO
on (cid:102)tP ≈M

Q]]η

ρs,ρr,ρO , . . . , [[(cid:102)tn

Q]]η

ρs,ρr,ρO , η, ρr) = BO,OQ. Thus, Mf and AO
gn

form a distinguisher

O (cid:102)tQ, which wins with the same probability as B.

For the bottom to top direction, we are given a computational model M and a distinguisher
and σQ as deﬁned for (cid:102)tQ.

and σP as deﬁned for (cid:102)tP , and φQ

O (cid:102)tQ. We consider φP
i

BO on (cid:102)tP ≈M

i

Thanks to the Lemma 28, for every ρs, ρr, ρO, for every i ≤ k,

[[ti

P ]]σP ,η

ρs,ρr,ρO

= OP (ρs, [[g0()]]σP ,η

ρs,ρr,ρO

, . . . , [[gi−1(φP

i−1)]]σP ,η

ρs,ρr,ρO

)

Q]]σQ,η

ρs,ρr,ρO = OQ(ρs, [[g0()]]σQ,η

and [[ti
(cid:102)tP , we have for every ρs, ρr, ρO, for every i ≤ k,

ρs,ρr,ρO , . . . , [[gi−1(φQ

i−1)]]σQ,η

ρs,ρr,ρO ). Then, with the deﬁnition of

[[(cid:102)ti

P ]]η

ρs,ρr,ρO

= OP (ρs, [[g0()]]η

ρs,ρr,ρO

, . . . , [[gi−1(φP

i−1)]]η

ρs,ρr,ρO

)

and [[(cid:102)ti

Q]]η

ρs,ρr,ρO = OQ(ρs, [[g0()]]η

i−1)]]η
We may now consider the PPTOM B(cid:48)O,OP ?Q, which :

ρs,ρr,ρO , . . . , [[gi−1(φQ

ρs,ρr,ρO ).

• Set m0 to the result of [[g0()]]η

ρs,ρr,ρO

.

• For i going from 0 to n − 1:

– set ti to the result of OP ?Q(mi)
– set mi+1 to the result of [[gi+1(t0, . . . , ti)]]σP ,η

ρs,ρr,ρO )

• set tn to the result of OP ?Q(mn)

• outputs BO(t0, . . . , tn)

102

With our previous observation, t0, . . . , tn is either equal to [[(cid:102)tP ]]η
O (cid:102)tQ, B(cid:48)O,OP ?Q is a distinguisher.

as BO is a distinguisher on (cid:102)tP ≈M

ρs,ρr,ρO

or [[(cid:102)tQ]]η

ρs,ρr,ρO

, and

Lemma 22. For any oracle O with support n, the axiom ∀k, k(cid:48) /∈ n, k ∼ k(cid:48) is O-sound.

Proof. We are given a cryptographic library, and oracle O with support n, and two names k,
k(cid:48) not in the support. We are given a AO which is a distinguisher over k ∼ k(cid:48). We deﬁne a
PPTTM A(cid:48) which on input (m, ρr, 1η) :

• Splits ρr into three distinct inﬁnite tapes ρso, ρra, ρro

• Simulates AO(ρso,ρro)(m, ρra, 1η)

Let us a prove that A(cid:48) is a distinguisher over k ∼ k(cid:48), which contradicts the unconditional
soundness of this axiom when there is no oracle.

We denote πk(ρs, η) the tapes where every bit of ρs which does not correspond to a name
c(ρs, η) where all bits for k are set to 0. We then have for any

of k is set to 0, and similarly πk
PPTOM AO:

ρs , ρr, 1η) = 1}

|Pρs,ρr,ρO {AO(ρs,ρO)([[k]]σ,η
=1 Pρs,ρr,ρO {AO(πk(ρs,η),ρO)([[n]]σ,η
πk
=2 Pρs1,ρs2,ρr,ρO {AO(ρs1,ρO)([[n]]σ,η
ρs2, ρr, 1η) = 1}
=3 Pρso,ρs,ρra,ρro{AO(ρso,ρro)([[k]]σ,η
ρs , ρra, 1η) = 1}
=4 Pρs,ρr {A(cid:48)([[k]]σ,η

ρs , ρr, 1η) = 1}

c (ρs,η), ρr, 1η) = 1}

1. Thanks to the deﬁnition of support, the oracle answers the same on πk(ρs, η) and ρs;
2. we split ρs in two, to replace independent tapes πk(ρs, η) and πk
3. we rename random tapes;

c(ρs, η);

4. by construction of A(cid:48).

This shows that A(cid:48) has the same advantage as AO against k ∼ k(cid:48), which concludes the

proof.

103

