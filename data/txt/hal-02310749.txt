Order-Invariant First-Order Logic over Hollow Trees
Julien Grange, Luc Segoufin

To cite this version:

Julien Grange, Luc Segoufin. Order-Invariant First-Order Logic over Hollow Trees. CSL 2020 - 28th
annual conference of the European Association for Computer Science Logic, Jan 2020, Barcelona,
Spain. pp.1-23, ￿10.4230/LIPIcs.CSL.2020.23￿. ￿hal-02310749v2￿

HAL Id: hal-02310749

https://inria.hal.science/hal-02310749v2

Submitted on 7 Apr 2020

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Order-Invariant First-Order Logic over Hollow
Trees

Julien Grange
ENS Paris & PSL & INRIA & CNRS, France
jgrange@di.ens.fr

Luc Segouﬁn
INRIA & ENS Paris & PSL, France
luc.segouﬁn@inria.fr

Abstract

We show that the expressive power of order-invariant ﬁrst-order logic collapses to ﬁrst-order logic
over hollow trees. A hollow tree is an unranked ordered tree where every non leaf node has at most
four adjacent nodes: two siblings (left and right) and its ﬁrst and last children. In particular there is
no predicate for the linear order among siblings nor for the descendant relation. Moreover only the
ﬁrst and last nodes of a siblinghood are linked to their parent node, and the parent-child relation
cannot be completely reconstructed in ﬁrst-order.

2012 ACM Subject Classiﬁcation Theory of computation → Finite Model Theory

Keywords and phrases order-invariance,ﬁrst-order logic

Digital Object Identiﬁer 10.4230/LIPIcs.CSL.2020.23

1

Introduction

First-order logic (FO) is a classical formalism for expressing properties over ﬁnite structures.
It is the building block of many other formalisms that are highly expressive such as MSO or
logics using ﬁxpoints such as LFP. An important and desirable feature of FO, and of all its
extensions mentioned above, is that it expresses only intrinsic properties of the structure, i.e.
properties invariant under isomorphisms. A limitation of FO is that it cannot express some
simple properties. In particular, as it cannot distinguish between nodes that are related via
some automorphism, it cannot always go through all the nodes of a structure in order to
perform simple tasks such as counting them.

In many scenarios, in particular in computer science, the structures under investigation
are stored on a disk: this yields an implicit order among the elements of the structure. It
is then reasonable to use this order within the logical formalism. In the case of FO this
means adding a new binary predicate that is interpreted as a linear order. However, we
want to do this in such a way that closure under isomorphisms is retained: the expressible
properties should only depend on the structure and not on the way it is stored on the disk,
the latter being arbitrary and subject to change. When this property is veriﬁed we say that
the formula is order-invariant and we denote by < -inv FO the set of ﬁrst-order formulas
that are order-invariant. We stress that being order-invariant is not a decidable property [5]
hence < -inv FO is not a recursive set of formulas.

Obtaining a “real” logic (in the sense of Gurevich, in particular with a recursive syntax)
that has exactly the same expressive power as < -inv FO is a challenging question. Solving
the same question for <-inv LFP would solve the longstanding quest of ﬁnding a logic for
PTime as it follows from Immermann-Vardi Theorem that <-inv LFP captures PTime.

In order to ﬁnd a logic for < -inv FO, it is useful to understand a bit better its expressive

power; such is the goal of this paper.

An example, attributed to Gurevich, shows that < -inv FO is in general strictly more

© Julien Grange and Luc Segouﬁn;
licensed under Creative Commons License CC-BY
28th EACSL Annual Conference on Computer Science Logic (CSL 2020).
Editors: Maribel Fernández and Anca Muscholl; Article No. 23; pp. 23:1–23:18

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

23:2

Order-Invariant First-Order Logic over Hollow Trees

expressive than FO [1]. Another key result shows that < -inv FO retains the local property
of FO [8]. It seems that it requires dense structures for < -inv FO to express strictly more
than FO. For instance when the structures are trees it has been shown that < -inv FO has
exactly the same expressive power than FO [5]. In [5] a “tree” is either a binary tree, where
every node has at most three neighbors: its parent, its left child and its right child or, an
unranked unordered tree where every node is related to its parent and all of its children, but
no order is assumed among siblings.

The question of whether < -inv FO = FO over any class of structures of bounded
treewidth was left open in [5], where it is only shown that, over structures of bounded
treewidth, < -inv FO can only express properties deﬁnable in MSO.

In order to show that < -inv FO collapses to FO over a class of structures of bounded
treewidth, it is tempting to reduce the case of bounded treewidth to the case of trees, using
tree decompositions. When trying this strategy one immediately faces two diﬃculties. The
ﬁrst one is, given two FO similar structures (in this introduction we informally say that two
structures are “FO similar” if they satisfy the same FO sentences of quantiﬁer rank k for
some k suﬃciently large and depending on the context), to exhibit a tree decomposition for
each of them such that the resulting tree decompositions are FO similar. Once this is done,
we can apply the known result over trees showing that the tree decompositions actually agree
on all order-invariant properties of a given quantiﬁer rank: they are < -inv FO similar. The
second diﬃculty is then to lift the order-invariance similarity from the tree decompositions
to the original structures.

The second diﬃculty could be solved easily if we could interpret the original structure
within its tree decomposition. Unfortunately this cannot be done in ﬁrst-order (this requires
reachability as an element of the structure could appear in bags arbitrarily far away within
the tree decomposition). This problem can be eliminated by assuming “domino treewidth”,
i.e. that an element appears in a bounded number of bags, which is equivalent to assuming
bounded degree of the structure on top of bounded treewidth [6].

Even when assuming bounded degree, the ﬁrst diﬃculty remains and we still do not know
the precise expressive power of < -inv FO over structures of bounded degree and pathwidth 2!
This paper is an attempt toward solving the pathwidth 2 case.

We show that < -inv FO collapses to FO over the class of hollow trees. Hollow trees are
ﬁrst-order structures with two binary relations that are interpreted so that the resulting
structure is a tree with the following features: each node has at most four neighbors: its
ﬁrst child, its last child and possibly a left and a right sibling. One of the binary relation
denotes the sibling relation while the other one denotes the partial parent-child relation. This
model strictly extends the case of binary trees as a node may have arbitrarily many children.
However it is less powerful than the unranked ordered model as a node is not directly related
to its parent, unless it is the ﬁrst or last of its children. Note that because of its locality,
FO cannot reconstruct the complete parent-child relation of every node within a hollow tree
(this can be done in MSO or using the transitive closure of the sibling relation).

It is not immediate to see how hollow trees are related to structures of pathwidth 2
and of bounded degree. It turns out that if in the model of hollow trees we only had one
binary relation and could not distinguishing between the (partial) parent-child relation and
the sibling one, then we would be able to encode in FO the basic blocks, called tracks, of
structures of bounded degree and pathwidth 2 in this model. This operation is described in
Section 2.2. In particular the collapse of < -inv FO to FO on hollow trees would imply the
collapse on tracks, as we explain in Section 2.4. We leave the extension of our result to this
class of structures as an open problem.

J. Grange and L. Segouﬁn

23:3

Our proof follows a strategy similar to the case of binary trees: we ﬁrst exhibit a set
of operations over hollow trees (actually over structures FO similar to hollow trees) that
preserve order-invariance similarity. We then show that if two hollow trees are FO similar
then one of them can be transformed using our set of operations into the other, lifting FO
similarity to < -inv FO similarity. The ﬁrst part is standard and makes use of the locality
of < -inv FO [8]. The second part is more combinatorial and forms the main technical
contribution of this paper.

Related work. Besides the papers already mentioned above, there exist several other
publications related to our work. We will make use in our proof of the fact that < -inv FO ⊆
MSO over classes of graphs of bounded treewidth, which has been initially claimed in [5].
Another proof of this result, extended to a broader class called “decomposable structures”,
can be found in [7].

If testing order invariance is undecidable for FO it is decidable for its two variable

fragment [15].

Several authors considered order-invariance for more expressive logics (ﬁrst-order with
modulo predicates [13], MSO [7]) or with more expressive numerical predicates [10, 9, 2, 14].
Our proof technique follows lines similar to [5, 13] but is mildly related to the others.

The proofs that are missing or just sketched in the main part of the paper are given in

greater details in the appendix.

2

Preliminaries

2.1 General notations

We consider relational structures and use classical terminology for them. We use Σ to denote
a relational schema and Σ-structure to denote a structure over Σ. Our structures are always
ﬁnite and are denoted through calligraphic upper-case letters and their domain through
the corresponding standard upper-case letter. For instance, A would denote the domain of
the structure A. For a relation symbol R ∈ Σ and a Σ-structure A, we denote by RA the
interpretation of R in A.

Given a relational signature Σ, ﬁrst-order logic, FO(Σ), and monadic second-order
logic, MSO(Σ), are deﬁned in the standard way (see, e.g., [11]). The main formalism of
interest here is order-invariant ﬁrst-order logic, denoted < -inv FO(Σ). A sentence ϕ in
FO(Σ ∪ {<}) belongs to < -inv FO(Σ) if for every Σ-structure A, whether (A, <A) |= ϕ is
independent of the choice of the linear order <A on A. In that case, we write A |= ϕ. For
any L ∈ {FO(Σ), MSO(Σ), < -inv FO(Σ)} and two Σ-structures A and B, we write A ≡L
k B
to mean that A and B satisfy the same sentences of L of quantiﬁer rank at most k. As usual
we omit Σ when it is clear from the context.

We use the standard notion of FO-interpretations in order to deﬁne a new structure
from an existing one. Given a FO-interpretation I, we call arity of I the number of free
variables in the formula of I which deﬁnes the domain of the new structure, and depth of I
the maximum among the quantiﬁer ranks of the formulas deﬁning the domain and the new
relations. It is a well known result that for every A, B, and I of arity a and depth d, and for
every k ∈ N, if A ≡L

ak+d B then I(A) ≡L

k I(B).

Let A be a structure over a vocabulary containing the binary relation symbol R. We say

that U ⊆ A is R-stable if ∀x ∈ U, ∀y ∈ A, (R(x, y) ∨ R(y, x)) → y ∈ U .

For a set σ of symbols, we deﬁne the vocabulary Pσ := {Ps : s ∈ σ}, where every Ps is a

unary relation symbol.

C S L 2 0 2 0

23:4

Order-Invariant First-Order Logic over Hollow Trees

As usual the Gaifman graph of a relational structure A is the (unoriented) graph whose
vertices are the elements of the domain of the structure and the edges relate two vertices
that appear in the same tuple of a relation of A. We denote by distA(x, y) the distance
between x and y in the Gaifman graph of A. Given two sets S and T of elements of A and
m ∈ N, we say that S and T are m-distant in A, if distA(x, y) ≥ m for all x ∈ S and all
y ∈ T . The k-neighborhood N k
A(x) of some x ∈ A is the substructure of A induced by
{y ∈ A : distA(x, y) ≤ k} together with an additional constant interpreted as x. The k-type
tpk
A(x) of x in A is the isomorphism class of its k-neighborhood. We extend those deﬁnitions
to tuples of elements in the usual way, ﬁxing the tuples pointwise.

For k ∈ N, we deﬁne the k-enrichment Ek(A) of a Σ-structure A as A itself where each
element has been recolored with its k-type. Ek(A) is a structure over the vocabulary Σ
augmented with a unary predicate for every k-type over Σ: there are a ﬁnite number of them
as long as we consider classes of structures of bounded degree.

2.2 Hollow trees

Barát, Hajnal, Lin and Yang [3] proved that any graph of pathwidth at most 2 can be
decomposed in a series of what they called tracks. Thus, a ﬁrst step towards proving the
collapse of < -inv FO to FO on classes of pathwidth at most 2 is to show that < -inv FO = FO
on the class of tracks.

•

•

•

•

•

•

•

•

Figure 1 Example of track of degree 3. Each dashed arc represent a path.

A typical example of track of degree 3 is depicted in Figure 1, where the dashed arcs are
colored paths, and all the chords are single edges. Each chord could actually be a single edge
or the juxtaposition of two edges with a single vertex in the middle; we can however ignore
that case, since the middle vertices can be encoded in FO by coloring the chords according
to whether they are simple or double edges.

We show in Figure 2 how such a track can be turned into a structure resembling a tree.

We add color and number identiﬁers to clarify the translation.

Note that those two transformations, as well as their inverse, are deﬁnable as FO-
interpretations as soon as the square edge is part of the track. We will thus see in Lemma 2
that the collapse of < -inv FO to FO on any of these classes of structures amounts to the
collapse on the other.

This remark motivates the deﬁnition of hollow trees. Informally, hollow trees resemble
the aforementioned tree-like structure with the key diﬀerence that the vertical edges (i.e. the
parent-child edges) and the horizontal one are distinguishable. In return for that speciﬁcation,
we do not restrict the complexity of the underlying tree, while the tree-like structures resulting

J. Grange and L. Segouﬁn

23:5

3

•

2

•

4

5

•

•

6

•

•

8

7

•

•

1

(cid:4)

9

(cid:4)

1

•

•

•

•

4

5

3

2

•

6

•

7

•

8

•

(cid:4)

9

1

2

3

4

9

8

7

6

•

•

•

•

5

Figure 2 Turning a track of degree 3 into a tree-like structure. One goes from the track to
the intermediate structure by cutting the edge represented as a square, and from the intermediate
structure to the tree-like structure by contracting each chord into a vertex.

from the transformation of a track are very constrained. In particular, the class of hollow
trees has unbounded pathwidth.

Let’s now formally deﬁne hollow trees.
An unranked ordered tree is a tree with a successor relation among the children of any
node. We see unranked ordered trees as structures over the signature composed of two binary

C S L 2 0 2 0

23:6

Order-Invariant First-Order Logic over Hollow Trees

relation symbols S and S0, where S is interpreted as the parent-child relation, and S0 as the
horizontal successor. A set of nodes that share the same parent is called a siblinghood.

We deﬁne a mapping H from the set of unranked ordered trees to structures over two
binary predicates S and E. Given an unranked ordered tree T , H(T ) is deﬁned as follows:

its domain is T
H(T ) |= S(x, y) iﬀ T |= S(x, y) and y is either the ﬁrst or the last of its siblings
E is interpreted as the symmetrical closure of S0

The image of H is the set of hollow trees, denoted H. If P = H(T ) then T is the underlying
tree structure of P.

In other words, within a hollow tree, only the two children at the endpoints of a siblinghood
know their parent. Notice that we do not distinguish between the ﬁrst and last child, nor do
we between the left and right sibling. This makes the model more general, as explained in
Section 2.4. An example of hollow tree is given in the left part of Figure 3.

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

Figure 3 An example of hollow tree (left) and of hollow quasitree (right). The dotted arrows

represent S and the plain (symmetrical) lines represent E.

Given a ﬁnite alphabet σ, we deﬁne Hσ, the set of hollow trees over σ, as the set of
colored extensions of hollow trees using the vocabulary Pσ, where the interpretations of the
predicates of Pσ partition the domain.

2.3 Main result

If C is a class of structures, we say that < -inv FO = FO over C if for each property
deﬁnable in < -inv FO, there exists a ﬁrst-order formula expressing this property over all
structures of C. Notice that for every σ, Hσ is a class of structures of treewidth 2. Therefore
< -inv FO ⊆ MSO over Hσ [5]. The main result we prove in this paper is:

(cid:73) Theorem 1. For all σ, < -inv FO = FO over Hσ

We outline the proof here, and give more details in the rest of this paper.

f (α) Q then P ≡<-inv FO

Proof sketch. Our goal is to ﬁnd some function f such that, ∀α ∈ N, ∀P, Q ∈ Hσ, if
P ≡FO
f (α) reﬁnes
≡<-inv FO
. Both equivalence relations being of ﬁnite index and the former being deﬁnable in
FO for every ﬁxed α, the result follows.

Q. This means that the equivalence relation ≡FO

α

α

To show this we ﬁx some α ∈ N and consider two hollow trees P and Q, such that
P ≡FO
f (α) Q for a large enough f (α). The general idea is to modify Q through some operations
that are invisible to all formulas of < -inv FO of quantiﬁer rank less than α, until we reach P.
This will ensure that P ≡<-inv FO

Q.

α

We will use two kinds of operations as described in Section 3: “swap operations”,
which preserve < -inv FO, and one which preserves MSO (and a fortiori < -inv FO as
< -inv FO ⊆ MSO over Hσ by [5]).

J. Grange and L. Segouﬁn

23:7

The MSO-preserving operation will be used in Section 3.3, in order to pump Q to make

sure that every neighborhood type is present at least as many times in Q as in P.

Once this is done, we explain in Section 4 how to transform Q with swap operations in
order to include P into it. Since Q may be larger than P, there could be some extra material
in Q that we call “loops”. The last step is to remove those loops and this is the goal of
Section 6.

When performing the swap operations, there will be a constant need for reorganizing the
S-edges (in particular to make sure that the loops are S-stable). Section 5 and Section 6.3
(cid:74)
compile the results that allow us to do so.

2.4 Bi-FO-interpretations and corollaries

Before we give more details about the proof of our main result, we recall in this section a
classical tool for reducing the collapse of < -inv FO to FO from one class of structures to
another. We then state a few corollaries of Theorem 1.

Let C1, C2 be two classes of structures over the respective vocabularies τ1 and τ2.
We say that C1 is bi-FO-interpretable through C2 if there exist two FO-interpretations
I12 and I21, respectively from τ1 to τ2, and from τ2 to τ1, such that for every A ∈ C1,
I12(A) ∈ C2 and I21(I12(A)) ’ A, where ’ denotes the existence of an isomorphism between
two structures. The following result is rather straightforward:

(cid:73) Lemma 2. If C1 is bi-FO-interpretable through C2 and < -inv FO = FO over C2, then
< -inv FO = FO over C1

Recall that in the deﬁnition of hollow trees the relation E is symmetric. This turns out
to be more general than choosing E as an arbitrary directed binary relation as shown in
the following result where a directed hollow tree is deﬁned as for hollow trees but with
a directed binary relation E. Note that we do not assume that E is a successor relation
among siblings, the direction of E could be arbitrary, but the result below works in particular
when E is a successor relation. Via a simple bi-FO-interpretation which uses extra colors to
encode the direction of the edges, we get the following result:

(cid:73) Corollary 3. For every σ, < -inv FO = FO on the class of σ directed hollow trees

Deﬁne a path over σ as a word over the alphabet σ, where the successor edges are
symmetrical (the argument used in the proof of Corollary 3 guarantees that paths are a
more general model than words). The class of paths over σ is obviously bi-FO-interpretable
through Hσ: just add a S-parent to the endpoints of the path, and then forget about it.
Thus we get:

(cid:73) Corollary 4. For every alphabet σ, < -inv FO = FO on the class of paths over σ.

Similarly, a straightforward bi-FO-interpretation together with Theorem 1 give us back

the result from [5] that < -inv FO = FO on ranked trees.

3

Swaps and pumping

In this section we provide a few operations, denoted swaps, that preserve ≡<-inv FO
. Although
the k-type of every element will be left unchanged, applying these operations may break the
somewhat rigid structure of hollow trees. In order to work with the intermediate structures,
we loosen the deﬁnition of hollow trees and deﬁne hollow quasitrees as follows:

k

C S L 2 0 2 0

23:8

Order-Invariant First-Order Logic over Hollow Trees

(cid:73) Deﬁnition 5. For k > 0 and σ a set of colors, we deﬁne the set of hollow k-quasitrees
on σ, quasi-Hk
σ, as the set of all ﬁnite structures over {E, S} ∪ Pσ such that the k-type of
any of their elements is the k-type of some element in some hollow tree in Hσ, and which
are such that their relation E is acyclic.

In other words a hollow quasitree diﬀers from a hollow tree by its relation S which may
not induce a tree structure: a node may have its S-children in two distinct siblinghoods and
a hollow quasitree may have cycles using the relation S (but not using only the relation E).
Note that by deﬁnition Hσ ⊆ quasi-Hk
σ for every k. An example of what a hollow quasitree
could look like is given in the right part of Figure 3. Note that locally, it looks like a hollow
tree.

Let T ∈ quasi-Hk

σ. We deﬁne the support of T as its restriction to the vocabulary
Pσ ∪ {E}. The n-enriched support of T , denoted Suppn(T ), is the support of its n-
enrichment (and not the other way around). Hence, it keeps in memory the local behavior
within T . The set End(T ) of endpoints of T is the set of elements of the support having
degree one. A connected component of the support of T is called a thread1. Note that by
E-acyclicity of T , each of its threads is a path, hence contains exactly two endpoints. We
say that a hollow k-quasitree has the matching endpoints property if the two endpoints
of each thread have the same S-parent. Note that a hollow tree has the matching endpoints
property. Notice also that in a hollow k-quasitree, any thread of length less than 2k + 1
has matching endpoints. For x, y ∈ T belonging to the same thread, [x, y] denotes the set
of elements that lie between them (formally, those who disconnect x from y in Supp0(T )),
including x and y. We naturally deﬁne [x, y[ as [x, y] \ {y}.

The following lemma, implicit in the proof of locality of < -inv FO by Grohe and
Schwentick [8], will allow us to prove that our operations preserve order-invariance equivalence:

p (α) ∈ N such
(cid:73) Lemma 6. Let Σ be a relational vocabulary and let p, α ∈ N. There exists oΣ
that for every structure A over Σ, and for every p-tuples of elements ¯a, ¯b ∈ Ap that have the
same oΣ

p (α)-type in A, there are two orders <¯a¯b and <¯b¯a on A such that

(A, <¯a¯b) ≡FO
α (A, <¯b¯a)
¯a¯b is an initial segment of <¯a¯b
¯b¯a is an initial segment of <¯b¯a

Our operations are divided into three families depending on whether we modify the

relation S, the relation E, or whether we do a global pumping,
In the following, R is a hollow (m + 1)-quasitree on σ.

3.1 crossing-S-swaps

Let a, a0, a00, b, b0, b00 ∈ R be such that S(a, a0), S(a, a00), S(b, b0), S(b, b00) and such that
tpm
R(b, b0, b00). Let R− := R\{S(a, a0), S(a, a00), S(b, b0), S(b, b00)} and assume
that the sets {a0, a00}, {b0, b00} and {a, b} are pairwise (2m + 3)-distant in R−.

R(a, a0, a00) = tpm

Then R0 := R− ∪ {S(a, b0), S(a, b00), S(b, a0), S(b, a00)} is called the m-guarded crossing-

S-swap between a and b in R (see Figure 4).

(cid:73) Note 7. A particular case where the distance condition is met is when distR(a, b) ≥ 2m + 5.

1 A thread is nothing other than a siblinghood when the quasitree is a tree.

J. Grange and L. Segouﬁn

23:9

a
•

b
•

−→

a
•

b
•

a0

a00

b0

b00

a0

a00

b0

b00

Figure 4 The crossing-S-swap between a and b

(cid:73) Lemma 8. For all α ∈ N there exists s(α) ∈ N such that for all m ≥ s(α), and every
hollow (m + 1)-quasitree R,

if R0 is the m-guarded crossing-S-swap between a and b in R,
then R0 ≡<-inv FO
R, and ∀x ∈ R, tpm+1

(x) = tpm+1

α

R0

R (x). Moreover R0 ∈ quasi-Hm+1

σ

and Suppm+1(R0) = Suppm+1(R).

Proof sketch. In order to prove that R0 ≡<-inv FO
R we need to exhibit a linear order over
R and one over R0 such that we can play an α-round Ehrenfeucht-Fraïssé game between
the resulting ordered structures. The linear orders are constructed using Lemma 6 applied
to (a0, a00) and (b0, b00) and the structure R−. A simple FO-interpretation is then used to
transfer the corresponding orders onto R and R0. Proving that the type of an element is
(cid:74)
unchanged is straightforward.

α

3.2 E-swaps

We deﬁne four diﬀerent kinds of E-swaps.

Let a, b, a0, b0 ∈ R be such that E(a, b), E(a0, b0), a, b and a0, b0 appear in two diﬀerent
threads of R and such that {a, b, a0, b0} and End(R) are (2m + 3)-distant in Supp0(R).
Furthermore, assume that tpm
R(a0, b0). Let R0 := R \ {E(a, b), E(a0, b0)} ∪
{E(a, b0), E(a0, b)}.

R(a, b) = tpm

Then R0 is called the m-guarded crossing-E-swap between ab and a0b0 in R (c.f.

Figure 5).

|

|

(cid:7)

♦

a
|

a0
|

b
|

b0
|

−→

•

◦

|

|

|

|

(cid:7)

♦

a b0
|
|

a0
|

b
|

◦

•

|

|

Figure 5 Illustration of the m-guarded crossing-E-swap between ab and a0b0 in R

Let a, b, b0, a0 ∈ R appear in that order in a single thread of R, such that E(a, b), E(a0, b0),
and such that {a, b, a0, b0} and End(R) are (2m + 3)-distant in Supp0(R). Furthermore,
assume that tpm
R(a0, b0). Let R0 := R \ {E(a, b), E(a0, b0)} ∪ {E(a, b0), E(a0, b)}.
Then R0 is called the m-guarded mirror-E-swap at [b, b0] in R (c.f. Figure 6).

R(a, b) = tpm

|

◦

a
|

b
|

>>>

b0 a0
|
|

•

|

−→

|

◦

a b0
|
|

<<<

b a0
|
|

•

|

Figure 6 Illustration of the m-guarded mirror-E-swap at [b, b0] in R

C S L 2 0 2 0

23:10 Order-Invariant First-Order Logic over Hollow Trees

Consider now a, b, c, d, a0, b0, c0, d0 ∈ R appearing in that order in a single thread of R
such that E(a, b), E(c, d), E(a0, b0), E(c0, d0) and such that {a, b, c, d, a0, b0, c0, d0} and End(R)
are (2m + 3)-distant in Supp0(R). Furthermore, assume that tpm
R(a0, b0) and
tpm
Let R0 := R \ {E(a, b), E(a0, b0), E(c, d), E(c0, d0)} ∪ {E(a, b0), E(a0, b), E(c, d0), E(c0, d)}. R0
is called the m-guarded segment-E-swap between [b, c] and [b0, c0] in R (c.f. Figure 7).

R(a, b) = tpm

R(c, d) = tpm

R(c0, d0).

a b
|
|

•

c d
|
|

a0 b0
|
|

(cid:126)

c0 d0
|
|

◦

♦

|

|

(cid:7)

−→

a b0
|
|

c0 d
|
|

a0 b
|
|

(cid:126)

◦

c d0
|
|

•

♦

|

|

(cid:7)

Figure 7 Illustration of the m-guarded segment-E-swap between [b, c] and [b0, c0] in R

Finally, let a, b, a0, b0, a00, b00 be elements of R appearing in that order in a single thread of
R, such that E(a, b), E(a0, b0) and E(a00, b00) and {a, b, a0, b0, a00, b00} and End(R) are (2m + 3)-
distant in Supp0(R). Furthermore, suppose that tpm

R(a0, b0) = tpm

R(a, b) = tpm

R(a00, b00).

Let R0 := R \ {E(a, b), E(a0, b0), E(a00, b00)} ∪ {E(a, b0), E(a0, b00), E(a00, b)}. R0 is called
the m-guarded contiguous-segment-E-swap between [b, a0] and [b0, a00] in R (c.f.
Figure 8).

|

(cid:7)

a
|

b
|

a0
|

b0
|

a00 b00
|
|

◦

•

♦

|

−→

|

(cid:7)

a b0
|
|

a00
|

b
|

◦

a0 b00
|
|

•

♦

|

Figure 8 Illustration of the m-guarded contiguous-segment-E-swap between [b, a0] and [b0, a00] in

R

As long as m is large enough, all the m-guarded E-swaps preserve ≡<-inv FO

α

and the

(m + 1)-type of every element:

(cid:73) Lemma 9. For all α ∈ N there exists s(α) ∈ N such that for every m ≥ s(α) and every
hollow (m + 1)-quasitree R, if R0 is either

the m-guarded crossing-E-swap between ab and a0b0 in R
the m-guarded mirror-E-swap at [b, b0] in R
the m-guarded contiguous-segment-E-swap between [b, a0] and [b0, a00] in R
the m-guarded segment-E-swap between [b, c] and [b0, c0] in R

then R0 ≡<-inv FO

α

R, ∀x ∈ R, tpm+1

R0

(x) = tpm+1

R (x) and R0 ∈ quasi-Hm+1

σ

.

Proof sketch. The proof is a tedious case analysis. Basically it amounts to the following
idea: if the elements involved in the swap are far away from each other then we can use
Lemma 6 in the structure R minus the E-edges of interest, and get orders on R and R0
which make these structures similar as in the proof of Lemma 8.

On the other hand, if the elements are close to each other, then the fact that they share
the same type induces some periodicity on their neighborhoods. These neighborhoods can
therefore be decomposed into several consecutive similar pieces. We can then apply Lemma 6
(cid:74)
to these smaller components to conclude.

3.3 Pumping

The next operation makes use of the fact that < -inv FO ⊆ MSO over hollow trees. Hence
our hollow trees can be “pumped” in order to duplicate some of their parts.

Given a structure A and a k-type τ , we denote by |A|τ the number of elements of A whose
k-type is τ . We will essentially use 0-types as our structures will be enriched by recoloring

J. Grange and L. Segouﬁn

23:11

each element by its k-type. In view of this we denote by [[A]] the function τ 7→ |A|τ whose
domain is the set of 0-types over the considered vocabulary.

Let d, D ∈ N, and f, g be functions from a same domain to N. We say that f ≤D

d g if for

every x in the domain:

if f (x) ≤ d, then f (x) = g(x)
if f (x) 6= g(x), then g(x) ≥ f (x) + D

By f < g, we mean that ∀x, f (x) < g(x) or f (x) = g(x) = 0.

In the following proposition < -inv FO can be replaced by MSO.

(cid:73) Proposition 10. ∀α, n, d ∈ N, ∃M ∈ N, ∀D ∈ N, ∀P, Q ∈ Hσ, if P ≡FO
exists Q0 ∈ Hσ such that Q0 ≡<-inv FO

Q and [[En+1(P)]] ≤D

d [[En+1(Q0)]].

α

M Q, then there

Proof sketch. This is a pumping argument: by setting M large enough, we make sure
in FO that if a (n + 1)-type has more occurrences in P than in Q, then it has enough
occurrences in Q so that we can ﬁnd a context in Q containing at least one occurrence,
and no occurrence of a rare type, such that we can duplicate this context inside Q without
(cid:74)
changing its MSO-type.

4

Inclusion and pseudo-inclusion

Recall that our ultimate goal is to show that if two hollow trees agree on the same FO
sentences of quantiﬁer rank f (α) then they agree on all < -inv FO sentences of quantiﬁer
rank α. For this, we will show that if P and Q are hollow trees that agree on all FO sentences
of quantiﬁer rank f (α) then we can use operations such as the swap operations described in
Section 3 to transform Q into P. As these operations preserve < -inv FO we get the desired
result.

In this section we perform the ﬁrst step towards transforming Q into P. We show
that using the swap operations we can transform Q into Q0 so that Q0 “includes” P. The
resulting structure Q0 will be a hollow quasitree. In the next sections we will continue the
transformation and remove from Q0 all the extra material it contains, deriving P.

In order to deﬁne what we mean by “inclusion” we need the notion of a n-abstract context
of a hollow quasitree. Intuitively this is a S-stable n-enriched substructure. More formally,
given a hollow quasitree T ∈ quasi-Hn
σ and a set U of its domain that is S-stable, then
C := T|U , together with the function tpn(.) that maps x ∈ U to its n-type in T , is called a
n-abstract context denoted C = Ctxtn(T |U ). The set of n-abstract contexts is denoted
Ctxtn
T (x) and not tpn
C (x). We need to remember, at least
locally, how C was glued to the rest of T in order to preserve n-types when moving C to
some other place.

σ. Note that tpn(x) denotes tpn

We are now ready to deﬁne the notion of “inclusion”. We actually deﬁne both “inclusions”
and “pseudo-inclusions”. We will need to pseudo-include a hollow quasitree into another
(Proposition 12), and then to include an abstract context into a hollow quasitree (Propos-
ition 13). Since a hollow k-quasitree T ∈ quasi-Hk
σ can be seen as a k-abstract context
(T = Ctxtk(T |T )), we only need to deﬁne (pseudo-)inclusions from an abstract context into
a hollow quasitree.

(cid:73) Deﬁnition 11. Let k ∈ N, U ∈ Ctxtk
k-pseudo-inclusion if h is injective and for all x, y, z ∈ U the following is veriﬁed:
1. tpk

σ and Q ∈ quasi-Hk

σ. We say that h : U → Q is a

Q(h(x)) = tpk(x),

C S L 2 0 2 0

23:12 Order-Invariant First-Order Logic over Hollow Trees

2. if x and y are in the same thread of U then h(x) and h(y) are also on the same thread of

Q and if moreover z ∈ [x, y] then h(z) ∈ [h(x), h(y)],

3. if U |= E(x, y) and t is the E-neighbor of h(x) in [h(x), h(y)] then t is the image of y
by an isomorphism (induced by the fact that they share the same k-type) between the
n-neighborhood of x and that of h(x).

and tpk−1

If U |= E(x, y) and Q 6|= E(h(x), h(y)) then {x, y} is said to be a jumping pair for h,
Q (h(x), t), where t is the E-neighbor of h(x) in [h(x), h(y)], is called its type.2
A k-pseudo-inclusion is said to be reduced if there is at most one jumping pair of a given

type.

A k-pseudo-inclusion is called a k-inclusion if it has no jumping pairs, that is if it

preserves E.

The last condition of pseudo-inclusion is a complication induced by the fact that E is not
oriented and that we thus cannot distinguish between the two siblings of a node. It ensures
that h preserves the neighborhoods in the right order. We can now state the main result of
this section. Note that the precondition that Q has more realizations for each type than U or
P will not be a problem in view of Proposition 10. The second proposition is stronger than
the ﬁrst one as it derives inclusion instead of pseudo-inclusion, but it requires the stronger
hypothesis that every occurring type has strictly more realizations in Q than in U.

(cid:73) Proposition 12. For every α, m ∈ N, there exists N ∈ N such that ∀P, Q ∈ quasi-HN +1
,
if [[EN +1(P)]] ≤ [[EN +1(Q)]], then there exists Q0 ∈ quasi-Hm+1
Q,
[[Em+1(Q0)]] = [[Em+1(Q)]] and h that is a (m + 1)-pseudo-inclusion from P into Q0.

σ
such that Q0 ≡<-inv FO

α

σ

(cid:73) Proposition 13. For every α, m ∈ N, there exists N ∈ N such that ∀U ∈ CtxtN +1
,
σ
∀Q ∈ quasi-HN +1
such that
Q0 ≡<-inv FO
α

σ
Q, [[Em+1(Q0)]] = [[Em+1(Q)]] and U is (m + 1)-included in Q0.

, if [[EN +1(U)]] < [[EN +1(Q)]], then there exists Q0 ∈ quasi-Hm+1

σ

Proof sketch. Both propositions have a similar proof: we ﬁrst prove Proposition 12, and
explain afterwards how to move from pseudo-inclusions to inclusions.

We deﬁne the pseudo-inclusion h step by step, extending the domain of h thread by
thread and, inside each thread, from one of its endpoint to the other. At each step we modify
Q using E-swaps, if necessary.

We give a special treatment to short threads and portions of the long threads that are
close to the endpoints:
in that case, no modiﬁcation of Q is required as the cardinality
precondition ensures the presence of the necessary sequences within Q. We then move to the
parts of the long threads that are far from the endpoints, adding them one node at a time to
the domain of the pseudo-inclusion. Note that as all the elements involved in the E-swaps to
come are distant from the endpoints, the E-swaps involved are guarded.

Let x0 be the last node of the current thread t that has been given an image by h, and
let x be the next node to which we want to extend the domain of h. By hypothesis, we know
that there exists a node y /∈ Im(h) far from any endpoint, that has the same (m + 1)-type as
x. We denote by y0 the neighbor of y that has the same m-type as x0, and by ˆx the neighbor
of h(x0) having the same m-type as x.

We proceed to a case analysis depending on the relative position of y, y0, h(x0) and ˆx. If
y0, y are on the same thread as h(x0), ˆx and in the same direction (in particular when y = ˆx),

2 This is an ease of notation; to be more precise, we should make the type of a jumping pair symmetrical.

J. Grange and L. Segouﬁn

23:13

we simply set h(x) to y and we are done. If not, one of the E-swaps will place y to the
desired position.

For instance, if y0, y are on the same thread as h(x0), ˆx but in the reverse direction
(c.f. Figure 9, where the double line represents Im(h)), then we consider the m-guarded
mirror-E-swap at [ˆx, y] in Q and extend h by setting h(x) to y.

h(x0) ˆx
|
|

|

>>>

y y0
|
|

−→

|

|

h(x0) y
|
|

<<<

|

|

|

Figure 9 h(x0), ˆx and y0, y are in the same thread, but in reverse order: we use a mirror-E-swap

Now, if y is on a thread that does not intersect Im(h) (c.f. Figure 10), we consider the
m-guarded crossing-E-swap between h(x0)ˆx and y0y in Q, and extend h by setting h(x) to y.

h(x0) ˆx
|
|

y0
|

y
|

•

◦

|

|

−→

|

|

h(x0) y
|
|

|

|

◦

•

|

|

|

|

Figure 10 y is on a thread disjoint from Im(h): we use a crossing-E-swap

If y0, y are in the same direction as h(x0), ˆx, and are between h(z) and h(z0) where z and

z0 are consecutive node of the current thread (c.f. Figure 11).

Then we consider the m-guarded segment-E-swap between [u0, y0] and [h(z0), h(x0)] in Q,

and extend h by setting h(x) to y.

|

h(z)
|

|
u0

y0 y
|
|

•

h(z0) h(x0)

◦

|

|

|

|
ˆx

| −→

|

h(z)
|

|
h(z0)

h(x0)
|

|
y

u0
|

•

y0
|

|

◦

|

|

Figure 11 y0, y are between the images of two already included neighbors: we use a segment-E-

swap

There are a few other cases that are treated similarly. This concludes the proof for

pseudo-inclusion.

For Proposition 13, as we wish to construct an inclusion, we need to make sure that there

is no “jump” in the mapping.

Note that among all the previously mentioned cases, only one didn’t guarantee the absence
of a jump, namely when y0, y are on the same thread as h(x0), ˆx and in the right direction,
but when y 6= ˆx. We then use the stronger hypothesis on the number of types in Q, which
guarantees that there also exist z, z0 verifying the same conditions as y, y0 (cf. Figure 12).
We consider the m-guarded contiguous-segment-E-swap between [ˆx, y0] and [y, z0] in Q, and
extend h by setting h(x) to y. h is now an inclusion.

h(x0) ˆx
|
|

y0
|

y
|

•

z0
|

z
|

◦

|

−→

|

|

h(x0) y
|
|

◦

|

|

•

|

z
|

|

Figure 12 y0, y, z0, z and h(x0), ˆx are on the same thread, in the same order: we use a contiguous-

segment-E-swap to avoid a jump in the inclusion

(cid:74)

C S L 2 0 2 0

23:14 Order-Invariant First-Order Logic over Hollow Trees

5

Tools for reorganizing S-edges

In the previous section, we have seen how to “rewrite” Q using E-swap operations in order to
pseudo-include P into the resulting quasitree. By deﬁnition, the pseudo-inclusion h of P into
Q respects the enriched support but can be completely wild relatively to the S-edges. For
instance, in Q, the endpoints of a thread may not have the same S-parent. In this section
we show how to use S-swaps in order to ensure that our pseudo-inclusion mapping takes into
account (to various degrees) the S-edges. We say that two nodes of a quasitree are S-siblings
if they share the same S-parent.

In Section 5.1, we show how to make sure that the pseudo-inclusion respects the S-siblings
relation. In Section 5.2 we show how to ensure that the image of a pseudo-inclusion is S-stable.
S-stability is required to deﬁne and operate on the loops, as will be established in Section 6.

5.1 S-siblings re-association

The following Lemma shows how to modify a pseudo-inclusion in order for it to preserve the
S-siblings relation. Note that it doesn’t necessarily mean that the image structure has the
matching endpoint property because the initial structure itself may not have this property
as it is derived from a quasitree.

(cid:73) Lemma 14. ∀α, m ∈ N, ∃N ∈ N, ∀W ∈ CtxtN
pseudo-inclusion, then there exists some Q0 ∈ quasi-Hm+1
h0 : W → Q0 such that Q0 ≡<-inv FO
S-siblings in W, then so are h0(x) and h0(y) in Q0.

σ , if h : W → Q is a N -
and some (m+1)-pseudo-inclusion
Q, Suppm+1(Q0) ’ Suppm+1(Q) and, if x and y are

σ , ∀Q ∈ quasi-HN

α

σ

Proof sketch. We correct the S-edges two by two: let x, y be two S-siblings in W such that
h(x), h(y) are not S-siblings in Q, and let z ∈ Q be the S-sibling of h(x).

z and h(y) must have the same (N − 2)-type: we can use a crossing-E-swap or a mirror-
E-swap (depending on whether they are the endpoints of a same thread) to exchange their
positions and make sure h(x) and h(y) are S-siblings.

However, for these swaps to be guarded, we must operate far enough from the endpoints.
(cid:74)

This can be done as long as we choose N large enough.

A particular case of the previous lemma is when W is a hollow tree and h is surjective:
then Q0 has the matching endpoints property. This result will be useful in the proof of
Proposition 18.

5.2 S-stabilization

The image of a pseudo-inclusion has no reason to be S-stable, thus neither has its complement.
However, this is a crucial requirement to apply the results presented in the next section,
Section 6, in order to remove the extra material not in the image of the pseudo-inclusion.

The next result provides a method to ensure that the image (and its complement) of a

pseudo-inclusion is S-stable.

Recall that a pseudo-inclusion is said to be reduced if there is at most one jumping pair
of a given type. At the end of this process, we get a reduced pseudo-inclusion, which will
allow us to minimize the complement of its image in Section 6.1.

(cid:73) Proposition 15. For every α, m ∈ N, there exist N, d, D ∈ N such that, for every P ∈ Hσ,
Q ∈ quasi-HN +1
d [[EN +1(Q)]] and P is (N + 1)-pseudo-included
in Q through some h, there are some h0 and Q0 ∈ quasi-Hm+1
Q,

such that [[EN +1(P)]] ≤D

such that Q0 ≡<-inv FO

σ

σ

α

J. Grange and L. Segouﬁn

23:15

Suppm+1(Q0) ’ Suppm+1(Q), h0 is a reduced (m + 1)-pseudo-inclusion of P in Q0 and
Q0 \ Im(h0) is S-stable in Q0.

Proof sketch. We consider all the pairs of elements x, y which break the S-stability of Im(h),
i.e. such that S(x, y), x ∈ Im(h) and y 6∈ Im(h). If there are many of them, then at least two
of them are far from each other and we can apply a crossing-S-swap to correct the mapping h.
We end up with a bounded number of problematic pairs that can be corrected separately. (cid:74)

6

Removing unnecessary material

In this section we show how to remove the material in Q that is not present in the image of
the pseudo-inclusion of P. From the previous section we can assume that the pseudo-inclusion
mapping preserves the S-siblings relation and that its image is S-stable. The remaining part
of Q is then a union of “loops” in the sense that they connect nodes that have the same type.
After deﬁning properly the notion of loop, we will use in Section 6.1 a pumping argument in
order to reduce the size of the loop to some constant while preserving ≡<-inv FO
. In Section 6.2
we then show how to remove small loops without aﬀecting the order-invariant equivalence
class. Finally, in Section 6.3 we show that if a hollow tree and a hollow quasitree have the
same enriched support, then they are ≡<-inv FO

: this concludes the proof of Theorem 1.

α

α

We start with the deﬁnition of an abstract loop.
Let n ∈ N. Let Typen

σ[2] denote the set of (n − 1)-types for pairs over the vocabulary
Pσ ∪ {E, S}, of degree ≤ 4. Let Σn be the vocabulary enriching Pσ ∪ {E, S} with two unary
symbols J 1

σ[2].
Let h be a reduced n-pseudo-inclusion from P ∈ Hσ to Q ∈ quasi-Hn

τ for every τ ∈ Typen

τ and J 2

σ, such that

V := Q \ Im(h) is S-stable.

Let Q+ be an extension of Q to Σn obtained in the following way. Since h is reduced, for
every τ ∈ Typen
σ[2], there is at most one jumping pair of type τ . If there isn’t, J 1
τ are
interpreted as the empty set. Else, let {x, x0} be this pair, and u0 (resp. u) be the E-neighbor
τ as {h(x0), u} (the
of h(x) (resp. h(x0)) in [h(x), h(x0)]. Interpret J 1
assignments x 7→ 1 and x0 7→ 2 are arbitrary). This is illustrated on the left part of Figure 13,
where the double line represents Im(h). We say that Q+ is a h-jump-extension of Q.
We deﬁne V+ = Ctxtn(Q+|V ) as the extension of Ctxtn(Q|V ) to Σn where every J i

τ as {h(x), u0} and J 2

τ and J 2

deﬁned consistently with Q+ (i.e. ∀x ∈ V, V+ |= J i
illustrated in Figure 13. V+ is called an n-abstract loop. Let Ln
loops.

τ (x) iﬀ Q+ |= J i

τ is
τ (x)). This process is
σ be the set of n-abstract

J 1
τ
|
|
h(x)

|

J 2
τ
|
|
h(x0)

|

|

|

|

J 1
τ
|

J 2
τ
|

|

|

|

Figure 13 Example of a h-jump-extension Q+ of Q (on the left), and its associated abstract loop

V+ of support V := Q \ Im(h) (on the right)

Every Σn-structure will have a ’+’ symbol in its name. When we omit it, we mean
σ, we get V :=

the reduction of the structure to Pσ ∪ {E, S} (for instance, from V+ ∈ Ln
Ctxtn(Q|V ) ∈ Ctxtn

σ).

C S L 2 0 2 0

23:16 Order-Invariant First-Order Logic over Hollow Trees

6.1 Loop minimization

It will be crucial to bound the size of the loops left by a pseudo-inclusion. The following
result does this using a simple pumping argument.

(cid:73) Proposition 16. For every α, n ∈ N, there exists N ∈ N such that for every P ∈ Hσ,
Q ∈ quasi-Hn
σ and reduced n-pseudo-inclusion h : P → Q, if V := Q \ Im(h) is S-stable then
there exists some Q0 ∈ quasi-Hn
σ and a reduced n-pseudo-inclusion h0 : P → Q0 such that
Q0 ≡<-inv FO
α

Q, U := Q0 \ Im(h0) is S-stable and |U | ≤ N .

6.2 Loop elimination

It now remains to get rid of the small loops. This is a consequence of the “aperiodicity”
of < -inv FO: we cannot distinguish in < -inv FO between k and k + 1 copies of the same
object if k is suﬃciently large. Starting from a small loop, we can use the inclusion results
of Section 4 to recreate many copies of the loop within Q, then, according to the following
proposition, get rid of one copy using aperiodicity.

(cid:73) Proposition 17. ∀α ∈ N, ∃l ∈ N, ∀m ∈ N, ∃n ∈ N, ∀M ∈ N, ∃K ∈ N such that for every
abstract loop U+ ∈ Ln+1
such that |U | ≤ M , (l + 1) · [[En+1(U)]] <
[[En+1(Q)]] and such that for every (n + 1)-type χ that occurs in U, |Q|χ ≥ K, there exists
Q0 ∈ quasi-Hm

Q and [[Em(Q)]] = [[Em(Q0)]] + [[Em(U)]]

and every Q ∈ quasi-Hn+1

σ such that Q0 ≡<-inv FO

α

σ

σ

Proof sketch. The proof is based on the well known result that ﬁrst-order formulas of
quantiﬁer-rank k cannot distinguish between a linear order of length 2k and a linear order of
length 2k + 1 (see, for instance, [11]). Hence if a loop is repeated at least 2k + 1 times, we
can eliminate one instance without changing the ≡<-inv FO

class of the structure.

k

First, we include many copies of the loop in Q. The inclusion may not preserve S-edges:
the next step is to re-associate these S-edges with crossing-S-swaps in order for these copies
to be isomorphic. This is made possible by the hypothesis on the number of occurrences of
types appearing in U: it gives us room to make sure the crossing-S-swaps are guarded.
Once this is done, we can remove one copy in a < -inv FO-indistinguishable way.

(cid:74)

6.3 S-parents re-association

We now turn to the last step of the proof of Theorem 1.

After the removal of the extra material in Q, we have transformed our initial hollow
tree Q into a hollow quasitree having the same number of occurrences of any type as the
initial P. They both have the same threads but may diﬀer with their S-edges. The following
proposition states that they are ≡<-inv FO

, thus ending the proof of Theorem 1.

α

The techniques used in the proof of the following proposition are strongly reminiscent of

those used in [4]; it requires a notion of vertical-S-swaps adapted to hollow trees.

(cid:73) Proposition 18. ∀α ∈ N, there exists n1 ∈ N such that ∀P ∈ Hσ, ∀Q ∈ quasi-Hn1
Suppn1(P) ’ Suppn1(Q) then P ≡<-inv FO
Q.

α

σ , if

7

Conclusion

We have shown that < -inv FO = FO over hollow trees. As we have discussed in Section 2.2,
in order to lift this result to tracks of bounded degree, i.e. the basic blocks of structures of
pathwidth 2 and bounded degree, it suﬃces to show that < -inv FO = FO over structures

J. Grange and L. Segouﬁn

23:17

that have the same underlying graph than hollows trees, but without the possibility to
distinguish a sibling from a child; in other words, there is only one binary relation that is
the union of E and S. This is because there exists a bi-FO-interpretation from tracks of
bounded degree through this class of structures.

Unfortunately our proof does not extend to this class of structures as it was crucial in
our proof to distinguish between E-swaps and S-swaps. We leave this generalization as an
open problem.

We also have no idea yet on what to do when the degree is not assumed to be bounded,
as we are then also facing the second diﬃculty mentioned in the introduction, namely
reinterpreting the initial structure within its tree representation.

In this paper we bypassed the ﬁrst problem mentioned in the introduction, ﬁnding similar
tree decompositions given similar structures, by working directly on trees. This problem
seems unavoidable when working with graphs. There are examples of similar structures of
treewidth 2 that do not have any similar tree decompositions of width 2. It might even be
the case that for all k there are two similar structures of treewidth 2 that do not have similar
tree decomposition of width k. If that were true, completely new ideas would be needed to
solve the treewidth 2 case.

References

1

Serge Abiteboul, Richard Hull, and Victor Vianu. Foundations of Databases. Addison-Wesley,
1995. URL: http://webdam.inria.fr/Alice/.

2 Matthew Anderson, Dieter van Melkebeek, Nicole Schweikardt, and Luc Segouﬁn. Locality

from circuit lower bounds. SIAM J. Comput., 2012.

3

János Barát, Péter Hajnal, Yixun Lin, and Aifeng Yang. On the structure of graphs with
path-width at most two. Studia Scientiarum Mathematicarum Hungarica, 2012.

4 Michael Benedikt and Luc Segouﬁn. Regular tree languages deﬁnable in FO and in FOmod .

ACM Trans. Comput. Log., 2009.

5 Michael Benedikt and Luc Segouﬁn. Towards a characterization of order-invariant queries over

tame graphs. J. Symb. Log., 2009.

6 Hans L. Bodlaender and Joost Engelfriet. Domino treewidth. J. Algorithms, 1997.

7 Michael Elberfeld, Marlin Frickenschmidt, and Martin Grohe. Order invariance on decom-
posable structures. In Proceedings of the 31st Annual ACM/IEEE Symposium on Logic in
Computer Science, LICS, 2016.

8 Martin Grohe and Thomas Schwentick. Locality of order-invariant ﬁrst-order formulas. ACM

Trans. Comput. Log., 2000.

9

10

11

Frederik Harwath and Nicole Schweikardt. Regular tree languages, cardinality predicates, and
addition-invariant FO. In 29th International Symposium on Theoretical Aspects of Computer
Science, STACS, 2012.

Frederik Harwath and Nicole Schweikardt. On the locality of arb-invariant ﬁrst-order logic
with modulo counting quantiﬁers. In Computer Science Logic, CSL, 2013.

Leonid Libkin. Elements of Finite Model Theory. Texts in Theoretical Computer Science. An
EATCS Series. Springer, 2004.

12 Roger C Lyndon, Marcel-Paul Schützenberger, et al. The equation aM = bN cP in a free group.

The Michigan Mathematical Journal, 1962.

13 Hannu Niemistö. On locality and uniform reduction. In 20th IEEE Symposium on Logic in

Computer Science, LICS, 2005.

14 Nicole Schweikardt and Luc Segouﬁn. Addition-invariant FO and regularity. In Proceedings of

the 25th Annual IEEE Symposium on Logic in Computer Science, LICS, 2010.

C S L 2 0 2 0

23:18 Order-Invariant First-Order Logic over Hollow Trees

15 Thomas Zeume and Frederik Harwath. Order-invariance of two-variable logic is decidable. In
Proceedings of the 31st Annual ACM/IEEE Symposium on Logic in Computer Science, LICS,
2016.

J. Grange and L. Segouﬁn

23:19

A

Proofs for Section 2 (Preliminaries)

(cid:73) Theorem 1. For all σ, < -inv FO = FO over Hσ

Proof. Let α ∈ N. Recall that we want to ﬁnd f (α) such that ∀P, Q ∈ Hσ, if P ≡FO
then P ≡<-inv FO

Q.

f (α) Q

α

We set, in that order:

l as in Proposition 17 (loop elimination), that is such that FO[α] cannot distinguish the
linear order on {1, · · · , l} from the linear order on {1, · · · , l + 1}
n1 as in Proposition 18 (S-parents re-association)
n2 as in Proposition 12 (pseudo-inclusion) for n1 − 1
n3 as in Proposition 17 (loop elimination) for n2
M as in Proposition 16 (loop minimization) for n3 + 1
K as in Proposition 17 (loop minimization) for n2 and M
n4, d1, D as in Proposition 15 (S-stabilization of the image of a pseudo-inclusion) for n3
n5 as in Proposition 12 (pseudo-inclusion) for n4
f (α) as in Proposition 10 (pumping) for n5 and d := max(d1, K)

Starting from P ≡FO

propositions in the reverse order: we transform Q into P along a sequence of ≡<-inv FO
quasitrees (with smaller and smaller radius) Qi as follows:

f (α) Q, we unfold the previously set indexes to apply the corresponding
hollow

α

According to Proposition 10, we can pump inside Q to get Q0 ≡<-inv FO

Q such that

α

[[En5+1(P)]] ≤D

d [[En5+1(Q0)]].

Now that we’ve made sure there were at least as many occurrences of every type in Q0
Q0 such that [[En4+1(Q1)]] = [[En4+1(Q0)]] and

as in P, Proposition 12 yields a Q1 ≡<-inv FO
P is (n4 + 1)-pseudo-included in Q1 by some h.

Since [[En4+1(P)]] ≤D
d1

Q1 such that
Suppn3+1(Q2) ’ Suppn3+1(Q1), and some reduced h0 which (n3 + 1)-pseudo-includes P in
Q2, where V := Q2 \ Im(h0) is S-stable in Q2

[[En4+1(Q1)]], Proposition 15 gives some Q2 ≡<-inv FO

α

α

Proposition 16 gives us some Q3 and U+ ∈ Ln3+1

σ

and [[En3+1(Q3)]] = [[En3+1(P)]] + [[En3+1(U)]]

such that Q3 ≡<-inv FO

α

Q2, |U | ≤ M

Since |U | ≤ M and for every type (n3 + 1)-type ξ that occurs in U, |Q3|ξ ≥ K (indeed:
since ξ occurs in U, |Q0|ξ 6= |P|ξ and |Q3|ξ > |P|ξ > d ≥ K), we can remove the extra
elements by applying Proposition 17, which gives Q4 ≡<-inv FO
Q3 such that [[En2+1(Q4)]] =
[[En2+1(Q3)]] − [[En2+1(U)]] = [[En2+1(P)]]

α

P and Q4 having the same number of occurrences of every (n2 + 1)-type, we can pseudo-
Q4 such that

include one into another according to Proposition 12, which gives Q5 ≡<-inv FO
Suppn1(Q5) ’ Suppn1 (P) (indeed, the pseudo-inclusion cannot have any jumping pair)

α

Finally, Proposition 18 allows us to conclude that Q5 ≡<-inv FO

α

sequence of transformations.

This concludes the proof that P ≡<-inv FO

α

Q.

P, completing our

(cid:74)

(cid:73) Lemma 2. If C1 is bi-FO-interpretable through C2 and < -inv FO = FO over C2, then
< -inv FO = FO over C1

Proof. We show that for some function f , for every k ∈ N and A, B ∈ C1, if A ≡FO
A ≡<-inv FO
k

B.

f (k) B, then

C S L 2 0 2 0

23:20 Order-Invariant First-Order Logic over Hollow Trees

As < -inv FO = FO over C2 we know that there is a function g such that for all k ∈ N
and A, B ∈ C2, if A ≡FO
B: to any order-invariant formula with a
quantiﬁer rank less than k, choose an arbitrary ﬁrst-order equivalent formula over C2 and
take g(k) as the max of their quantiﬁer rank.

g(k) B, then A ≡<-inv FO

k

Let a12, d12 (resp. a21, d21) be the arity and depth of I12 (resp. I21), and set f (k) :=

a12g(a21k + d21) + d12.

Assume now that A, B ∈ C1 are such that A ≡FO
f (k) B.
Applying I12 to both structures gives us I12(A) ≡FO
Hence I12(A) ≡<-inv FO
a21k+d21

I12(B), which yields A ≡<-inv FO

k

g(a21k+d21) I12(B).

B after applying I21.

(cid:74)

The ﬁrst consequence of this result is that we can assume a normal form over hollow trees
without loss of generality. Namely that each S-parent has exactly two S-children, and that
no element is at the same time a S-parent and a S-child. Indeed, there is a simple bi-FO-
interpretation that transforms a general hollow tree into one having the desired properties
(by duplicating nodes that are only child, and those that are simultaneously S-parent and
S-child, and marking them with new unary predicates), and back to the initial one.

(cid:73) Corollary 3. For every σ, < -inv FO = FO on the class of σ directed hollow trees

Proof. We use Lemma 2 and exhibit a bi-FO-interpretation from directed hollow trees over
σ through hollow trees over σ ∪ {—, |}.

We give the ﬁrst FO-interpretation I (from directed hollow trees to hollow trees), and

leave the reverse one to the reader.

To avoid confusion in the notations, let’s rename the directed binary relation E as F in
the vocabulary of directed hollow trees: hence I goes from the vocabulary {F, S} ∪ Pσ to
{E, S} ∪ Pσ∪{—,|}}.

Given a σ directed hollow tree T , I(T ) is deﬁned as follow:

its domain is T , plus two new elements vxy and vyx for every x, y ∈ T such that
T |= F (x, y)
the interpretation of S is unchanged
E is interpreted as the union of {(x, vxy), (vxy, x), (vxy, vyx), (vyx, vxy), (vyx, y), (y, vyx)}
for every x, y ∈ T such that T |= F (x, y)
the interpretation of every P ∈ Pσ is unchanged
P— is interpreted as {vxy : x, y ∈ T, T |= F (x, y)}
P| is interpreted as {vyx : x, y ∈ T, T |= F (x, y)}

Intuitively, xF y has been transformed into the (symmetrical) gadget on four elements
xE—E|Ey. This encoding allows the converse FO-interpretation to recover the orientation
(cid:74)
of the F -edges of T from I(T ) in a straightforward way.

B

Proofs for Section 3 (Swaps and pumping)

(cid:73) Lemma 8. For all α ∈ N there exists s(α) ∈ N such that for all m ≥ s(α), and every
hollow (m + 1)-quasitree R,

if R0 is the m-guarded crossing-S-swap between a and b in R,
then R0 ≡<-inv FO
R, and ∀x ∈ R, tpm+1

(x) = tpm+1

α

R0

R (x). Moreover R0 ∈ quasi-Hm+1

σ

and Suppm+1(R0) = Suppm+1(R).

J. Grange and L. Segouﬁn

23:21

Proof. We ﬁrst show that R0 ≡<-inv FO
FO-interpretations. Recall the function oΣ
Σ := Pσ ∪ {E, S, P1/2, P3/4} where P1/2 and P3/4 are unary. Assume now that m ≥ oΣ
where c is a constant to be chosen later on.

R. This is essentially a reduction to Lemma 6 using
p given by Lemma 6. We use it with p = 2 and
2 (α + c)

α

Consider the extension R? of R− to Σ where the interpretation of P1/2 is {a} and that
3/4 are at distance > m from a0, a00, b0 and b00 in R?, we have

of P3/4 is {b}. Since P R?
R? (a0, a00) = tpm
that tpm

1/2 and P R?
R? (b0, b00).

We can therefore apply Lemma 6, and get two orders <a0a00b0b00 and <b0b00a0a00 such that
α+c (R?, <b0b00a0a00). Now, consider the FO-interpretation that adds a

(R?, <a0a00b0b00) ≡FO
S-edge between u and v if either:

P1/2(u) and v is the ﬁrst or the second element of <
P3/4(u) and v is the third or the fourth element of <

and then forgets about P1/2 and P3/4.

Take c to be the depth of this FO-interpretation (which has arity 1).
Note that the result of this FO-interpretation on (R?, <a0a00b0b00 ) is an ordered extension

of R and its result on (R?, <b0b00a0a00) is an ordered extension of R0.

This entails R0 ≡<-inv FO

R.

α

Now, let x ∈ R, and let’s show that tpm+1
First, if x is at distance > m + 1 of {a, a0, a00, b, b0, b00} in R, there isn’t any change in its

(x) = tpm+1

R (x).

R0

(m + 1)-neighborhood.

Otherwise, there are several cases, according to whether x belongs to N m+1
R− (a00), N m+1

R− (a0),
R− (b0); we treat the ﬁrst one of them, the others

R− (b0), or N m+1

R− (b), N m+1

R− (a), N m+1

N m+1
being similar.

Set da := distR−(x, a) and db := distR−(x, b). By hypothesis, da ≤ m + 1.
We distinguish two cases:

R0

R−

R−

(x) into N m+1

(b0, b00), hence N m+1

R (x) into N m+1

R− (x) and N m−da

if db > m+1: because of the distance constraint, we can partition N m+1
R− (x)
and N m−da
(a0, a00), with two S-edges joining a in the ﬁrst and a0, a00 in the second. These
two parts are at distance ≥ 2 in R−, hence they are fully independent (no overlap, and
no edge between the two except for S(a, a0) and S(a, a00)).
Likewise, we can partition N m+1
N m−da
(a0, a00) ’ N m−da
R−
if db ≤ m + 1: now, we can partition N m+1
(a0, a00) and
N m−db
(b0, b00), with two S-edges joining a in the ﬁrst to a0, a00 in the second and two
R−
S-edges joining b in the ﬁrst to b0, b00 in the third, as depicted in Figure 15. These three
parts are at distance ≥ 2 in R−, hence they are fully independent (no overlap, and no
edge between the two except for S(a, a0), S(a, a00), S(b, b0) and S(b, b00)).
Likewise, we can partition N m+1
as shown in Figure 15.
N m−da
R−
N m+1
R0

R−
(x).
R− (x), N m−da

(a0, a00) ’ N m−da
(x).

R0
R (x) into N m+1

(b0, b00), hence N m+1

R− (x), N m−da

R (x) ’ N m+1

(b0, b00) and N m−db

(b0, b00) and N m−db

(a0, a00) ’ N m−db

(x) into N m+1

R (x) ’

(b0, b00).

(a0, a00),

R−

R−

R−

R−

R−

R−

R0

(cid:73) Lemma 9. For all α ∈ N there exists s(α) ∈ N such that for every m ≥ s(α) and every
hollow (m + 1)-quasitree R, if R0 is either

the m-guarded crossing-E-swap between ab and a0b0 in R
the m-guarded mirror-E-swap at [b, b0] in R
the m-guarded contiguous-segment-E-swap between [b, a0] and [b0, a00] in R

(cid:74)

C S L 2 0 2 0

23:22 Order-Invariant First-Order Logic over Hollow Trees

N m+1
R− (x)
•
x

N m+1
R− (x)
•
x

a •

b•

a0

a00

b0

−→

b00

a0

a •

b•

a00

b0

b00

N m−da
R−

(a0, a00)

N m−db
R−

(b0, b00)

N m−db
R−

(a0, a00)

N m−da
R−

(b0, b00)

Figure 14 Evolution of the neighborhood of x before and after a crossing-S-swap in the proof of

Lemma 8. We see N m+1

R (x) on the left and N m+1

R0

(x) on the right.

the m-guarded segment-E-swap between [b, c] and [b0, c0] in R

then R0 ≡<-inv FO

α

R, ∀x ∈ R, tpm+1

R0

(x) = tpm+1

R (x) and R0 ∈ quasi-Hm+1

σ

.

(cid:73) Note. In each of these cases, the swap doesn’t introduce any E-loop. Hence, once we’ve
shown that every elements keeps its (m + 1)-type, we immediately get that R0 ∈ quasi-Hm+1
.
However, these operations do not preserve hollowtreeness. This is the reason why we

σ

introduced the notion of quasitree.

We prove Lemma 9 separately for every type of E-swap. We will need the following

lemmas:

(cid:73) Lemma 19. Let Q ∈ quasi-Hm+1
are pairwise (2m + 3)-distant in Supp0(Q). Then distQ(x, y) ≥ 2m + 3.

and x, y ∈ Q such that the sets {x}, {y} and End(Q)

σ

Proof. This is a consequence of the fact that in a hollow (m + 1)-quasitree, a thread of
length less than 2m + 1 must have matching endpoints.

Suppose that there exists path of length ≤ 2m + 2 in Q from x to y, and let p be such a

path of shortest length.

The path p may use either an E-edge or an S-edges. We divide p into segments between
two consecutive S-edges. Let t1, · · · , tr be the corresponding threads in that order (with
possible repetitions).

We know that x ∈ t1 and y ∈ tr. As x and y are at distance at least 2m + 3 when using

only E-edges, we must have r ≥ 2.

There are two ways for p to go from ti to ti+1: either (1) using and S-edge S(a, ei+1) with
a ∈ ti and ei+1 ∈ End(ti+1), or (2) using an S-edge S(b, ei) with b ∈ ti+1 and ei ∈ End(ti).
As x is far from the endpoints of t1, p must go from t1 to t2 using case (1). Similarly, p
must go from tr−1 to tr using case (2). Hence, there must exist some 1 < i < r such that p
moves from ti−1 to ti following (1), and from ti to ti+1 following (2).

Since p is a shortest path, the two endpoints of ti involved in (1) and (2) cannot be the
same; hence p goes from one endpoint of ti to the other and the length of ti must be ≤ 2m + 1.
Since Q ∈ quasi-Hm+1
, branches of length ≤ 2m + 1 must have matching endpoints. This
(cid:74)
contradicts the minimality of p, since p could have avoided ti completely.

σ

(cid:73) Lemma 20. Let Q ∈ quasi-Hm+1
{x, y} and End(Q) are (2m + 3)-distant in Supp0(Q).

σ

and x 6= y ∈ Q belonging to the same thread, such that

Every path of length < 2m + 3 between x and y goes through every E-edge of [x, y].

In other words, if Q− is Q minus any E-edge of [x, y], distQ− (x, y) ≥ 2m + 3.

J. Grange and L. Segouﬁn

23:23

Proof. The proof is identical as the one of Lemma 19, by considering a shortest path of
length ≤ 2m + 2 from x to y that doesn’t go through every E-edge of [x, y]: we arrive at the
(cid:74)
same contradiction.

The following lemma will only be needed in Section 5; however, we state it here as its

proof is very similar to the previous ones.

(cid:73) Lemma 21. Let Q ∈ quasi-Hm+1
, and x, y ∈ End(Q) such that distSupp0(Q)(x, y) ≥ 2m+3.
Then any path of length ≤ 2m + 3 from x to y goes through at least one of their S-parents.

σ

Proof. We proceed similarly as in Lemma 19; let’s use the same notations.

Suppose that p doesn’t go through x’s parent neither y’s. Let’s show that p goes from
t1 to t2 using case (1): if not, it uses case (2) through the other endpoint of t1. Hence, t1
would be of length ≤ 2m + 1 (since it takes at least 2 to reach y from there), and would have
matching endpoints; this is absurd, since p would go through x’s parent.

Similarly, we show that p moves from tr−1 to tr following (2).
We can conclude exactly as in Lemma 19.

(cid:74)

Proof of Lemma 9 for crossing-E-swaps

We let R− := R \ {E(a, b), E(a0, b0)}.

It follows from Lemma 19 and Lemma 20 that a, b, a0 and b0 are at distance at least

2m + 3 from each other in R−.

First, we show that R0 ≡<-inv FO

FO-interpretations. Recall the function oΣ
Σ := Pσ ∪ {E, S, P1, P2} where P1 and P2 are unary. Assume now that m ≥ oΣ
c is a constant to be chosen later on.

R. This is essentially a reduction to Lemma 6 using
p given by Lemma 6. We use it with p = 1 and
1 (α + c) where

α

of P2 is {b0}. Since P R?
tpm

1

Consider the extension R? of R− to Σ where the interpretation of P1 is {b} and that
are at distance > m from a and a0 in R?, we have that

and P R?

2

R? (a0).

R? (a) = tpm
We can therefore apply Lemma 6, and get two orders <aa0 and <a0a such that (R?, <aa0
α+c (R?, <a0a). Now, consider the FO-interpretation that adds a (symmetrical) E-edge

) ≡FO
between u and v if either:

P1(u) and v is the ﬁrst element of <
P2(u) and v is the second element of <

and then forgets about P1 and P2.

Take c to be the depth of this FO-interpretation (which has arity 1). Note that the result
of this FO-interpretation on (R?, <aa0) is an ordered extension of R and that its result on
(R?, <a0a) is an ordered extension of R0. This entails R0 ≡<-inv FO

R.

α

Now, let x ∈ R, and let’s show that tpm+1
First, if x is at distance > m + 1 of {a, b, a0, b0} in R, there isn’t any change in its

(x) = tpm+1

R (x).

R0

(m + 1)-neighborhood.

N m+1

Otherwise, there are several cases, according to whether x belongs to N m+1
R− (b) or N m+1
Set d := distR(x, a).
We can partition N m+1

R− (b0); we treat the ﬁrst one, the others being similar.

R (x) into N m+1

R− (x) and N m−d

R− (b), with an E-edge joining a in the

R− (a), N m+1

R− (a0),

ﬁrst and b in the second.

Because of the distance condition, these two parts are at distance ≥ 2 in R−, hence they

are fully independent (no overlap, and no edge between the two except for E(a, b)).

Likewise, we can partition N m+1

R0

(x) into N m+1

R− (x) and N m−d

R− (b0).

C S L 2 0 2 0

23:24 Order-Invariant First-Order Logic over Hollow Trees

N m−d

R− (b) ’ N m−d

R− (b0), hence N m+1

R (x) ’ N m+1

R0

(x).

Proof of Lemma 9 for mirror-E-swaps

Let R− := R \ {E(a, b), E(a0, b0)}. It follows from Lemma 20 that the three sets {a}, {a0}
and {b, b0} are (2m + 3)-distant in R−.

The proof that R0 ≡<-inv FO

α
Now, let x ∈ R, and let’s show that tpm+1
First, if x is at distance > m + 1 of {a, b, a0, b0} in R, there isn’t any change in its

(x) = tpm+1

R is done exactly as in the case of crossing-E-swaps.

R (x).

R0

(m + 1)-neighborhood.

Otherwise, there are several cases, according to whether x belongs to N m+1
R− (b) or N m+1

R− (a0),
R− (b0); the ﬁrst two are similar to the cases appearing in the proof for crossing-

R− (a), N m+1

N m+1
E-swaps.

We treat the third one, the fourth being symmetrical.
Set d := distR− (x, b) and d0 := distR− (x, b0). By hypothesis, d ≤ m + 1.
N m+1

R (x) can partitioned into N m+1

R− (x), N m−d
R− (a0),
with an E-edge joining b in the ﬁrst to a in the second, and an E-edge joining b0 in the ﬁrst
to a0 in the third (if it is nonempty).

R− (a) and the possibly empty N m−d0

We claim that any two of these three neighborhoods are at distance ≥ 2 in R−, hence they
are fully independent: no overlap, and no edge between any two of them, except (possibly)
for E(a, b) and (possibly) E(a0, b0).

Indeed, suppose (the other pairs of neighborhoods are treated similarly) that N m+1

R− (x) and
N m−d
R− (a) are at distance ≤ 1. Then distR− (a, x) ≤ 2m + 2 − d, hence distR− (a, b) ≤ 2m + 2,
which contradicts Lemma 20 for a and b (recall that {a, b} and End(R) are (2m + 3)-distant
in Supp0(R)).

Likewise, we can partition N m+1
R− (a0) and N m−d0
N m−d

R− (a) ’ N m−d

(x) into N m+1
R− (a0) ’ N m−d0

R− (x), N m−d
R− (a), hence N m+1

R− (a).
R (x) ’ N m+1

R− (a0) and N m−d0

R0

R0

(x).

Proof of Lemma 9 for contiguous-segment-E-swaps

Let R− := R \ {E(a, b), E(a0, b0), E(a00, b00)}.

Let x, y be non-endpoint elements of the same thread of some Q ∈ quasi-Hn+1
. Let
Q− := Q \ {E(x0, x), E(y, y0)}, where x0 (resp. y0) is the E-neighbor of x (resp. y) that
doesn’t belong to [x, y].
We denote by [x, y]Q

n the substructure of Q− induced by the set of nodes at distance ≤ n

σ

in Q− from [x, y], together with a new color marking x as the left endpoint.

We deﬁne concatenation as follows: if x, x1, y1, y appear in the same thread in that order,

and E(x1, y1), then we write [x, y]Q

n =: [x, x1]Q

n · [y1, y]Q
n .

Let us abbreviate distSupp0(Q)(x, y) as |[x, y]| (that is, the distance from x to y if we are

only allowed E-edges).

First, let’s prove that (m + 1)-types are unchanged by a m-guarded contiguous-segment-

E-swap.

Let x ∈ R, and let’s show that tpm+1
(x) = tpm+1
If x is at distance > m + 1 of {a, b, a0, b0, a00, b00} in R, there isn’t any change in its

R (x)

R0

(m + 1)-neighborhood.

Otherwise, there are several cases, according to whether x belongs to N m+1
R− (a0), N m+1

R− (b),
R− (b00). We treat the second one, the other ones

R− (a00) or N m+1

R− (b0), N m+1

R− (a), N m+1

N m+1
being similar or simpler.

J. Grange and L. Segouﬁn

23:25

Set db := distR− (x, b), da0 := distR− (x, a0), and db0a00 := distR− (b0, a00). By hypothesis,

db ≤ m + 1.

R (x) into N m+1

We can partition N m+1

(b0)
and N m−1−da0 −db0 a00
(b00), with an E-edge joining b in the ﬁrst to a in the second, an E-edge
joining a0 in the ﬁrst to b0 in the third, and an E-edge joining a00 in the third to b00 in the
fourth (in the case they are non-empty).

(a), and the possibly empty N m−da0

R− (x), N m−db

R−

R−

R−

We claim that any two of these four neighborhoods are at distance ≥ 2 in R−, hence they
are fully independent: no overlap, and no edge between any two of them except (possibly)
for E(a, b), E(a0, b0) and E(a00, b00).

Indeed, suppose (the other pairs of neighborhoods are treated similarly) that N m+1

R− (x) and
N m−db
(a) are at distance ≤ 1. Then distR−(a, x) ≤ 2m+2−db, hence distR− (a, b) ≤ 2m+2,
R−
which contradicts Lemma 20 for a and b (recall that {a, b} and End(R) are (2m + 3)-distant
in Supp0(R)).

Likewise, we can partition N m+1

(x) into N m+1

R− (x), N m−db

R−

(a00), N m−1−db−db0 a00
R−

(a) and

R0

N m−da0
R−

(b00).
Because tpm

(a00) and N m−1−db−db0a00
R−

N m−db
R−
(if they are both nonempty).

R(a, b) = tpm

R(a0, b0) = tpm

R(a00, b00), N m−db

(a) is isomorphic to the union of
(a) with an E-edge joining b0 in the ﬁrst and a in the second

R−

Similarly, the union of N m−da0

R−

(b0) and N m−1−da0 −db0 a00
R−

in the ﬁrst and b00 in the second (if they are both nonempty) is isomorphic to N m−da0

(b00) with an E-edge joining a00
(b00).

R−

Hence N m+1

R (x) ’ N m+1

R0

(x).

Now, let’s exhibit a s(α) such that for every m ≥ s(α), m-guarded contiguous-segment-

E-swaps preserve ≡<-inv FO

.

α

We will ﬁrst set N ∈ N instead of s(α), that will be suﬃcient for most cases. Then, we

will deﬁne s(α) ≥ N which will work for all cases.

Recall the function oΣ

p needed for Lemma 6, and consider n := oΣ
2 (α + c) where c is to be
chosen later on, and Σ := Pσ ∪ {E, S, P1, P4} where P1 and P4 are unary. We distinguish
between several cases depending on whether a, a0 and a00 are close or not, where “close” is
relative to n:

1. Assume ﬁrst that tpn

n ’ [b0, a00]R

R− (b, a0) = tpn

n , as well as those where |[a, a0]|

:= {b00}. Since P R?
1
are at distance > n from {b, a0, b0, a00} (this is guaranteed by Lemma 20, because

R− (b0, a00).
This case covers the instances where [b, a0]R
and |[a0, a00]| are both > 2n + 2.
Consider the extension R? of R− to Σ where P R?
and P R?
we will make sure that s(α) ≥ n), tpn
R? (b, a0) = tpn
Hence, we can apply Lemma 6, and get two orders <ba0b0a00 and <b0a00ba0 such that
(R?, <ba0b0a00) ≡FO
Now, consider the FO-interpretation that adds a symmetrical E-edge between u and v if
either:

α+c (R?, <b0a00ba0).

:= {a} and P R?

R? (b0, a00).

1

4

4

P1(u) and v is the ﬁrst element of <
u is the second element of < and v is either its third one
u is the fourth element of < and P4(v)

and then forgets about P1 and P4.
Take c to be the depth of this FO-interpretation (which has arity 1).

C S L 2 0 2 0

23:26 Order-Invariant First-Order Logic over Hollow Trees

Note that the result of this FO-interpretation on (R?, <ba0b0a00) is an ordered extension
of R and that its result on (R?, <b0a00ba0) is an ordered extension of R0.
This entails R0 ≡<-inv FO
R.
n can be decomposed as [b0, a1]R
2. Assume next that [b0, a00]R

n · · · [bk, a00]R

n · [b1, a2]R

n , where

α

each of these enriched segments is isomorphic to [b, a0]R
n .
We can then apply k + 1 times Case 1 and obtain R0 ≡<-inv FO

R as desired.
3. From now on, N ≥ l(2n + 2) + n for a large enough l to be chosen later on.

α

As we are not in Case 1, we can restrict our study to the cases where |[a, a0]| ≤ 2n + 2
(the cases where |[a0, a00]| ≤ 2n + 2 can be treated similarly).
We will need the following claim, which is based on the Lyndon-Schützenberger Theorem.
(cid:73) Claim 22. Let n ∈ N and R ∈ quasi-Hn+1
.
Let a1, b1, a2, b2, a3, b3, a4, b4 appear in that order in a single thread of R, such that
E(a1, b1), E(a2, b2), E(a3, b3) and E(a4, b4).
Suppose that [b1, a2]R
Then there exist decompositions [b1, a2]R
W1 · · · Wp, where all the Ui, Vi and Wi are isomorphic.

n = V1 · · · Vq, and [b3, a4]R

n = U1 · · · Up, [b2, a3]R

n and [b1, a3]R

n ’ [b2, a4]R
n .

n ’ [b3, a4]R

n =

σ

n ), v := Θn([b2, a3]R

n to the word [x, y] where each element is colored

Proof. Consider Θn which maps [x, y]R
with its n-type in [x, y]R
n .
n ) and w := Θn([b3, a4]R
Let u := Θn([b1, a2]R
The hypothesis guarantee u = w and uv = vw. Hence uv = vu.
By Lyndon-Schützenberger Theorem, there must exist a word a and integers p, q such
that u = w = ap and v = aq [12].
We can decompose [b1, a2]R
and w, to get [b1, a2]R
n = V1 · · · Vq, and [b3, a4]R
all the Ui, Vi and Wi are mapped to a by Θn, hence are isomorphic.

n alongside those decompositions of u, v
n = W1 · · · Wp, where
(cid:67)

n , [b2, a3]R
n = U1 · · · Up, [b2, a3]R

n and [b3, a4]R

n ).

Let φ be an isomorphism between the N -neighborhood of (a, b) and that of (a0, b0).
As |[a, a0]| ≤ 2n+2, a0 and b0 are in the N -neighborhood of (a, b): set x0 := a0 and y0 := b0.
Construct by induction xi+1 := φ(xi) and yi+1 := φ(yi) until i > l. Our choice of N
ensures that xi and yi are well deﬁned as xi−1 and yi−1 remain in the N -neighborhood
of (a, b). For all j ≤ l, Xj := [yj−1, xj]R
Likewise, starting from (a00, b00) instead of (a0, b0), we show that there exist x0
such that for j ∈ [1, l] (and with the convention that x0
isomorphic to [b, a0]R
n .
We distinguish several cases:

n is isomorphic to [b, a0]R
n .

1, · · · , x0
j−1]R
j, x0

1, y0
j := [y0

0 = a00), X 0

l, y0
l
n is

a. Suppose that |[a0, a00]| ≥ 2N . This ensures that all the (xi)i≥1, (yi)i≥0, (x0

i)i≥0 and

(y0
i)i≥1 belong to [b0, a00].
We can decompose [b, a00]R

n as

[b, a0]R

n · [y0, x1]R
n
}

|

{z
X1

· · · [yl−1, xl]R
n
}

|

{z
Xl

·[yl, x0

n · [y0
l]R
|

l−1]R
l, x0
n
{z
}
X 0
l

· [y0
|

l−1, x0
{z
X 0
l−1

l−2]R
n
}

· · · [y0
|

0]R
n
}

1, x0
{z
X 0
1

Let R1 be the n-guarded contiguous-segment-E-swap between [b, x0
in R (recall that a00 = x0
If l is chosen large enough, namely l ≥ 2n + 4, this swap falls in Case 1 of this Lemma
and therefore R1 ≡<-inv FO

l−1] and [y0

l−1, a00]

0).

R.

α

J. Grange and L. Segouﬁn

23:27

In R1, [y0

l−1, x0

l−1]R1

n (that is, the segment strictly between a and b00) is decomposed as

[y0
|

l−1, x0
{z
X 0
l−1

l−2]R
n
}

· · · [y0
|

0]R
n
}

1, x0
{z
X 0
1

·[b, a0]R

n · [y0, x1]R
n
}

|

{z
X1

· · · [yl−1, xl]R
n
}

|

{z
Xl

·[yl, x0

n · [y0
l]R
|

l−1]R
l, x0
n
{z
}
X 0
l

l−1] in R1.

Now, let R2 be the n-guarded contiguous-segment-E-swap between [y0
[y0, x0
By choice of l, this swap falls again in Case 1 of this Lemma. Thus, R2 ≡<-inv FO
Observe now that in R2, [b, a00]R2
as

R1.
n (the segment strictly between a and b00) is decomposed

l−1, a0] and

α

[y0, x1]R
n
|
{z
}
X1

· · · [yl−1, xl]R
n
}

|

{z
Xl

·[yl, x0

n · [y0
l]R
|

l−1]R
l, x0
n
{z
}
X 0
l

· [y0
|

l−1, x0
{z
X 0
l−1

l−2]R
n
}

· · · [y0
|

0]R
n
}

1, x0
{z
X 0
1

·[b, a0]R
n

that is, [b0, a00]R

n · [b, a0]R

n . Hence R2 = R0, and we get R0 ≡<-inv FO

α

R.

b. Suppose now that |[a0, a00]| < 2N . Set s(α) := (2N +1)(2n+2)+n. Just as before (by re-
2N +1,
2N +1 that all are isomorphic to [b, a0]R
n .
i)0≤i≤2N can be in [b0, a00]. Let k be the smallest index such that

0, · · · , x0

2N +1, y0

0, y0

1, · · · , X 0

k, y0
k−1]R
k]R

k−1, y0
k, a0, b0, x0
n by deﬁnition.

placing l with 2N +1), we deﬁne x0, y0, · · · , x2N +1, y2N +1 and x0
and accordingly, X1, · · · , X2N +1 and X 0
Not all of the (x0
i /∈ [b0, a00] (we know that 1 ≤ k ≤ 2N ).
x0
If x0
k = a0, we can conclude using Case 2.
Otherwise, a, b, x0
n ’ [y0
k, x0
[b, a0]R
k−1]R
To see that [b, x0
X 0
k+1 to the ﬁnal segments of length |[b0, x0
We can now apply Claim 22, and get decompositions [b, x0
V1 · · · Vq, and [b0, x0
Hence, [b, a0]R
can be transposed onto each X 0
Ui, the Vi and the Wi are isomorphic.
We can now decompose [b, a00]R

n ’ [b0, x0

k and X 0

k−1]R

n as

n , consider the restriction of an isomorphism between
k−1]| = |[b, x0

k]|.

k, a0]R
n = W1 · · · Wp, where all the Ui, Vi and Wi are isomorphic.

n = U1 · · · Up, [y0

k]R

n =

n can be decomposed as U1 · · · Up · V1 · · · Vq, and such a decomposition
j, the

p+q, where all the Y i

i , 0 < i < k, as X 0

1 · · · Y i

i = Y i

k−1 must appear in that order in the thread.

U1 · · · Up · V1 · · · Vq
{z
}
|
[b,a0]R
n

· W1 · · · Wp
{z
|
}
[b0,x0
k−1]R
n
|

· Y k−1
1
|

· · · Y k−1
p+q
}
{z
X 0
k−1
{z
[b0,a00]R
n

· · · Y 1
|

1 · · · Y 1
{z
X 0
1

p+q
}

}

Now, we can use Case 2 to swap Vq with [b0, a00]R
segment strictly between a and b00 is

n : R1 ≡<-inv FO

α

R, where in R1, the

U1 · · · Up · V1 · · · Vq−1 · W1 · · · Wp · Y k−1

1

· · · Y k−1

p+q · · · Y 1

1 · · · Y 1

p+q · Vq

Repeating this operation p + q − 1 times allows us to conclude that R0 ≡<-inv FO

α

R.

C S L 2 0 2 0

23:28 Order-Invariant First-Order Logic over Hollow Trees

Proof of Lemma 9 for segment-E-swaps

The proof that ∀x ∈ R, tpm+1

R0

(x) = tpm+1

R0

(x) is done as for the contiguous-segment-E-swaps.

Let’s now ﬁnd s(α) ∈ N that guarantees the ≡<-inv FO

α

invariance of any m-guarded

segment-E-swaps, for m ≥ s(α).

Let n := oΣ

2 (α + c) where c is the depth of some FO-interpretation to be speciﬁed later

on, and Σ := Pσ ∪ {E, S, P1, P2, P3, P4} where P1, P2, P3 and P4 are unary.

Let R− := R \ {E(a, b), E(a0, b0), E(c, d), E(c0, d0)}.

1. Assume ﬁrst that tpn

4

n ’ [b0, c0]R

R− (b, c) = tpn

:= {d0}. Since P R?

n , as well as those where |[a, c]| and

R− (b0, c0).
This case covers the instances where [b, c]R
|[a0, c0]| both are > 2n + 2.
Consider the extension R? of R− to Σ where P R?
and P R?
(this is guaranteed by Lemma 20, because we will make sure that s(α) ≥ n), tpn
tpn
Hence, we can apply Lemma 6, and get two orders <bcb0c0 and <b0c0bc such that (R?, <bcb0c0
) ≡FO
Now, consider the FO-interpretation that adds a symmetrical E-edge between u and v if
either:

:= {a0}
are at distance > n from {b, c, b0, c0}
R? (b, c) =

α+c (R?, <b0c0bc).

1
and P R?

:= {a}, P R?

:= {d}, P R?

R? (b0, c0).

, P R?
2

, P R?
3

4

3

2

1

P1(u) and v is the ﬁrst element of <
u is the second element of < and P2(v)
P3(u) and v is the third element of <
u is the fourth element of < and P4(v)
and then forgets about P1, P2, P3 and P4.
Take c to be the depth of this FO-interpretation (which has arity 1).
Note that the result of this FO-interpretation on (R?, <bcb0c0) is an ordered extension of
R and that its result on (R?, <b0c0bc) is an ordered extension of R0.
This entails R0 ≡<-inv FO

R.

α

2. We can now, without loss of generality, assume that |[a, c]| ≤ 2n + 2.

Let s be the threshold s(α) from the proof of contiguous-segment-E-swaps. Let us increase
that threshold for it to account for segment-E-swaps: set s(α) := (2n + 2) + M with
M := max(s, n).
Consider an isomorphism ϕ from N s(α)
By choice of s(α), tpM
Since (ϕ(c), ϕ(d)) 6= (c0, d0) (for otherwise, we would be in the Case 1), there are only two
subcases to consider:

R (a, b) to N s(α)

R (c, d) = tpM

R (ϕ(c), ϕ(d)).

R (a0, b0).

if a0, b0, ϕ(c), ϕ(d), c0, d0 appear in that order, i.e. the segment strictly between a and
d0 can be decomposed as:

[b, c]R

n · [d, a0]R

n · [b0, ϕ(c)]R

n · [ϕ(d), c0]R
n

Let R1 be the M -guarded segment-E-swap between [b, c] and [b0, ϕ(c)] in R.
This swap falls under the scope of Case 1 since M ≥ n, hence R1 ≡<-inv FO
∀z ∈ R, tpM +1
decomposed as:

R and
R (z). In R1, the segment strictly between a and d0 can be

(z) = tpM +1

R1

α

[b0, ϕ(c)]R

n · [d, a0]R

n · [b, c]R

n · [ϕ(d), c0]R
n

J. Grange and L. Segouﬁn

23:29

Hence we are in the conditions (since M ≥ s) to apply Lemma 9 in the case of the
M -guarded contiguous-segment-E-swap between [d, c] and [ϕ(d), c0] in R1.
We get R2 ≡<-inv FO
α
decomposed as:

In R2, the segment strictly between a and d0 can be

R1.

[b0, ϕ(c)]R

n · [ϕ(d), c0]R

n · [d, a0]R

n · [b, c]R

n = [b0, c0]R

n · [d, a0]R

n · [b, c]R
n

That is, R2 = R0, and we get R0 ≡<-inv FO
if a0, b0, c0, d0, ϕ(c), ϕ(d) appear in that order, i.e. the segment strictly between a and
ϕ(d) can be decomposed as:

R as desired.

α

[b, c]R

n · [d, a0]R

n · [b0, c0]R

n · [d0, ϕ(c)]R
n

Let R1 be the M -guarded segment-E-swap between [b, c] and [b0, ϕ(c)] in R.
This swap falls under the scope of Case 1 since M ≥ n, hence R1 ≡<-inv FO
∀z ∈ R, tpM +1
be decomposed as:

R and
R (z). In R1, the segment strictly between a and ϕ(d) can

(z) = tpM +1

R1

α

[b0, c0]R

n · [d0, ϕ(c)]R

n · [d, a0]R

n · [b, c]R
n

Hence we are in the conditions (since M ≥ s) to apply Lemma 9 in the case of the
M -guarded contiguous-segment-E-swap between [d0, ϕ(c)] and [d, c] in R1.
We get R2 ≡<-inv FO
α
decomposed as:

R1. In R2, the segment strictly between a and ϕ(d) can be

[b0, c0]R

n · [d, a0]R

n · [b, c]R

n · [d0, ϕ(c)]R
n

That is, the segment strictly between a and d0 is

[b0, c0]R

n · [d, a0]R

n · [b, c]R
n

Hence R2 = R0, and we get R0 ≡<-inv FO

α

R as desired.

(cid:73) Proposition 10. ∀α, n, d ∈ N, ∃M ∈ N, ∀D ∈ N, ∀P, Q ∈ Hσ, if P ≡FO
exists Q0 ∈ Hσ such that Q0 ≡<-inv FO

Q and [[En+1(P)]] ≤D

d [[En+1(Q0)]].

α

M Q, then there

subsumes ≡<-inv FO

Proof. The proof is a simple pumping argument. We rely on the fact that hollow trees have
bounded treewidth hence < -inv FO ⊆ MSO on Hσ. In particular there is a β ∈ N such that
. We will construct Q0 such that Q0 ≡MSO
≡MSO
β
Let d0 > d be a number that will be speciﬁed during the proof. We choose M large
enough to make sure that every (n + 1)-type has the same number of occurrences in P and
in Q up to a threshold d0 (this can be expressed in FO).

β Q.

α

We prove the proposition by induction on the number κ of (n + 1)-types τ such that

|P|τ 6= |Q|τ and |Q|τ < |P|τ + D.

If κ = 0, there is nothing to do as Q0 := Q ﬁts. Otherwise, let τ be such a type. Notice

that because P ≡FO

M Q we must have |Q|τ > d0.

There are two cases to consider:

Assume there exists a thread in Q which contains at least l nodes x1, x2, · · · , xl (in that
order) having the same (n + 1)-type, whose subtrees each contains at least one node
of type τ in Q, and such that for every i < l, duplicating within the thread the forest
below [xi, xi+1[ does not aﬀect the ≡MSO
of Q, where l is chosen large enough so that

β

C S L 2 0 2 0

23:30 Order-Invariant First-Order Logic over Hollow Trees

β Q and we can conclude by induction.

there exists i < l such that the forest below [xi, xi+1[ doesn’t contain any occurrence of a
(n + 1)-type τ 0 such that |Q|τ 0 ≤ d.
Then we construct Q0 from Q by duplicating the forest below [xi, xi+1[ as many times
as necessary to have enough nodes of type τ . This decreases κ and guarantees that
Q0 ≡MSO
Assume now that there is a chain for the ancestor relation x1, x2, · · · , xl having the
same (n + 1)-type such that each of the contexts CP (xi, xi+1) (we use here the notations
introduced for Lemma 26 to denote the context between xi and xi+1) contains at least
one node of type τ and ∀i, j, SP (xi) ≡MSO
SP (xj) (the subtrees at xi and xj), where l is
large enough to guarantee the existence of some i < l such that CP (xi, xi+1) contains no
node of any type τ 0 such that |Q|τ 0 ≤ d
Let Q0 := PP (xi) · CP (xi, xi+1)k · SP (xi+1) (that is, we’ve duplicated k times the context
between xi and xi+1) with k large enough so we have enough nodes of type τ . We have
Q0 ≡MSO

β Q and κ has decreased by 1: we can conclude by induction.

β

It remains to ﬁx d0 large enough so that one of the two cases above must hold.

(cid:74)

C

Proofs for Section 4 (Inclusion and pseudo-inclusion)

(cid:73) Proposition 12. For every α, m ∈ N, there exists N ∈ N such that ∀P, Q ∈ quasi-HN +1
,
if [[EN +1(P)]] ≤ [[EN +1(Q)]], then there exists Q0 ∈ quasi-Hm+1
Q,
[[Em+1(Q0)]] = [[Em+1(Q)]] and h that is a (m + 1)-pseudo-inclusion from P into Q0.

σ
such that Q0 ≡<-inv FO

α

σ

(cid:73) Proposition 13. For every α, m ∈ N, there exists N ∈ N such that ∀U ∈ CtxtN +1
,
σ
∀Q ∈ quasi-HN +1
such that
Q0 ≡<-inv FO
α

σ
Q, [[Em+1(Q0)]] = [[Em+1(Q)]] and U is (m + 1)-included in Q0.

, if [[EN +1(U)]] < [[EN +1(Q)]], then there exists Q0 ∈ quasi-Hm+1

σ

Proof. We mainly focus on the proof of Proposition 12. We will then explain how to modify
the proof using the extra hypothesis in order to get inclusion instead of pseudo-inclusion
thus proving Proposition 13.

We modify Q using E-swaps in order to construct a pseudo-inclusion h from P. This is
done step by step, extending the domain of h thread by thread and, inside each thread, from
one of its endpoint to the other.

We distinguish between two kinds of threads of P. The short ones will be easily taken
care of as they can be completely described in ﬁrst-order. The long ones will require more
work.

In view of Lemma 9, we assume that m ≥ s(α). We set n := 3m + 3. We will only
perform swaps involving nodes at distance (along E) ≥ n − m from the endpoints; hence,
the “distant from endpoints” conditions of m-guarded E-swaps will always be satisﬁed.

A thread is short if its length (the distance along E between its two endpoints) is at most
2(n − m). By taking N large enough, our hypothesis [[EN +1(P)]] ≤ [[EN +1(Q)]] guarantees
that we can ﬁnd a injective mapping from the short threads of P to that of Q, which sends
each short thread to one having an isomorphic (m + 1)-enrichment. We initialize h according
to this mapping. It is clear that h is a partial (m + 1)-pseudo-inclusion mapping.

It remains to extend the domain of h to the long threads.
Let a be an endpoint of a long thread of P: segtypen−m

m+1,P (a) denotes the isomorphism
type of the segment [a, b], where b is the element at distance n − m of a in its thread, and
every element is colored with its (m + 1)-type in P. By Endn−m
m+1 (Q), we mean
that every segtypen−m

m+1,.(.) has at least as many occurrences in P as in Q.

m+1 (P) ≤ Endn−m

J. Grange and L. Segouﬁn

23:31

Let ˚S n−m
from End(P)

m+1 (P) be the restriction of Suppm+1(P) to elements that are at distance > n − m

Every intermediate structure Q0 will verify the following invariant:



Q0 ≡<-inv FO
Q

α
[[Em+1(Q0)]] = [[Em+1(Q)]]
m+1 (P) ≤ Endn−m
Endn−m

[[ ˚S n−m

m+1 (P)]] ≤ [[ ˚S n−m

m+1 (Q0)]]

m+1 (Q0) and h preserves segtypen−m

m+1,.(.)

(1)

As long as N is large enough, the hypothesis guarantees that Q veriﬁes (1).
Assume we have already constructed a partial (m + 1)-pseudo-inclusion h from P to Q0
where Q0 veriﬁes (1). We show that we can construct a new hollow quasitree Q00 ∈ quasi-Hm+1
verifying (1), using a sequence of E-swaps applied to Q0 in such a way that h can be extended
by at least one element of P .

σ

To this end, assume ﬁrst that the domain of h is the union of a number of threads, each
contained in its entirety (this is the case at the beginning). Let Im(h) denote the image of h.
Let t be any thread of P not in the domain of h and let x be an endpoint of t. We want to
extend h in order for its domain to contain x.

m+1,Q0(y) = segtypen−m

(1) ensures that there exists an endpoint y /∈ Im(h) of a long thread of Q0 such that
segtypen−m
m+1,P (x). We don’t modify Q0 and extend h by sending every
z ∈ [x, x0] to the corresponding h(z) ∈ [y, y0] (where x0, y0 are the elements at distance n − m
of x, y in their threads). Every z and h(z) have the same (m + 1)-type, and h preserves E
on [x, x0].

By construction, h is a partial (m + 1)-pseudo-inclusion mapping as desired.

Suppose now that the domain of h contains a set of (entire) threads and the initial
segment of a thread t of P, that includes at least the points of t at distance ≤ n − m from
its endpoint in the domain of h. Let x0 be the last element of t in the domain of h and x
be the ﬁrst element of t not in the domain of h. In particular we have E(x0, x). Assume
furthermore that x is at distance > n − m from the other endpoint of t.
m+1 (Q0)]], there exists an element y ∈ ˚S n−m

m+1 (P)]] ≤ [[ ˚S n−m

Since [[ ˚S n−m

the same (m + 1)-type as x. Let y0 be the image of x0 by an isomorphism between N m+1
and N m+1

(y).

m+1 (Q0) \ Im(h) having
(x)

P

Q0

Let ˆx be the image of x by an isomorphism between N m+1
By deﬁnition, tpm
If y = ˆx, leave Q0 unchanged and let h map x to ˆx. Otherwise, there are several cases to

Q0(h(x0), ˆx) = tpm

(x0) and N m+1

Q0(y0, y).

(h(x0))

Q0

P

consider depending on the positions of y and y0.

1. if y is on a thread that does not intersect Im(h).

Let Q00 be the m-guarded crossing-E-swap between h(x0)ˆx and y0y in Q0. Extend h by
setting h(x) to y (c.f. Figure 16, in which Im(h) is represented as double lines).

h(x0) ˆx
|
|

y0
|

y
|

•

◦

|

|

−→

|

|

h(x0) y
|
|

|

|

◦

•

|

|

|

|

Figure 15 An illustration of the progression in the (pseudo-)inclusion (case 1)

C S L 2 0 2 0

23:32 Order-Invariant First-Order Logic over Hollow Trees

2. if y is between h(z) and h(z0) where z and z0 are consecutive node of the current thread
t already in the domain of h and such that y0 is between h(z) and y (that is, they are in
the right order for a segment-E-swap), c.f. Figure 17.
Let u0 and u be the respective E-neighbors of h(z) and h(z0) in [h(z), h(z0)]. h being a
pseudo-inclusion, tpm
Q0(u, h(z0)).
Let Q00 be the m-guarded segment-E-swap between [u0, y0] and [h(z0), h(x0)] in Q0, and
extend h by setting h(x) to y

Q0(h(z), u0) = tpm

|

h(z)
|

|
u0

y0 y
|
|

•

h(z0) h(x0)

◦

|

|
u

|

|

| −→

|

h(z)
|

|
h(z0)

h(x0)
|

|
y

u0
|

•

y0
|

|

◦

|

|

Figure 16 An illustration of the progression in the (pseudo-)inclusion (case 2)

3. if y is between h(z) and h(z0) where z and z0 are consecutive nodes of the current thread
t already in the domain of h and such that y0 is between y and h(z0) (that is, they are not
in the right order for a segment-E-swap), c.f. Figure 18. This means that y, y0, h(x0), ˆx
appear in that order.
Let R be the m-guarded mirror-E-swap at [y0, h(x0)] in Q0
In R, h(z), u0, h(z0), u now appear in that order.
Let Q00 be the m-guarded mirror-E-swap at [u0, h(z0)] in R and extend h by setting h(x)
to y.

|

h(z)
|

|
u0

y y0
|
|

•

h(z0) h(x0)

◦

|
u

|

+

|

|
ˆx

| −→

|

h(z)
|

|
u0

h(x0) h(z0)

•

|
y

|

)

|

◦

|
u

y0
|

|

| −→

|

h(z0) h(x0)

|

|
h(z)

|

+

|
y

u0 u
|
|

•

◦

|

|

|

Figure 17 An illustration of the progression in the (pseudo-)inclusion (case 3)

4. if y is between h(z) and h(z0) where z and z0 are consecutive node in some thread diﬀerent

from t already in the domain of h (c.f. Figure 19).
Let R be the m-guarded crossing-E-swap between y0y and h(x0)ˆx in Q0
Let Q00 be the m-guarded crossing-E-swap between h(z)u0 and uh(z0) in R, and extend
h by setting h(x) to y.

y
|

◦

h(z0)
|

|

h(z)
|

|

•

h(x0) ˆx
|
|

y0
|

|

|

|

|

−→

|

|

h(z) u0
|
|

h(x0)
|

y
|

•

◦

|

|

u h(z0)
|
|

|

|

−→

h(z)
|

|
h(z0)

h(x0) y
|
|

|

|

|

|

◦

|

•

|

|

|

Figure 18 An illustration of the progression in the (pseudo-)inclusion (case 4)

J. Grange and L. Segouﬁn

23:33

5. if y is on the same thread as h(x0), such that h(x0), ˆx, y, y0 appear in that order (c.f.

Figure 20).
Then let Q00 be the m-guarded mirror-E-swap at [ˆx, y] in Q0 and extend h by setting
h(x) to y.

h(x0) ˆx
|
|

|

>>>

y y0
|
|

−→

|

|

h(x0) y
|
|

<<<

|

|

|

Figure 19 An illustration of the progression in the (pseudo-)inclusion (case 5)

6. ﬁnally if y is on the same thread as h(x0) but h(x0), ˆx, y0, y appear in that order.

This is the case where we cannot achieve inclusion without extra hypothesis. For
Proposition 12, we simply allow a “jump” and set h(x) to y without changing Q0.

In the previous case analysis, in order to perform E-swaps, it was important for x (and
therefore y) to be far away from the endpoint e of t that is not already in the domain of h.
In order to conclude the proof of Proposition 13, it remains to consider the case where x is
at distance n − m from e.

By hypothesis, there exists an endpoint a outside of Im(h) of a long thread such that
m+1,P (e). Let ξ be the isomorphism between [e, x] and [a, y],

segtypen−m
where y is the element at distance n − m of a in its thread.

m+1,Q0(a) = segtypen−m

If a is not on the same thread as h(x0), let y0 be the E-neighbor of y not in [y, a]. We
let Q00 be the m-guarded crossing-E-swap between h(x0)ˆx and y0y in Q0 and extend h by
setting h(u) to ξ(u) for all u in [x, e].

Otherwise, we don’t modify Q0 and simply extend h by setting h(u) to ξ(u) for every u

in [x, e]. Notice that there may be a jump between h(x0) and h(x).

This concludes the proof of Proposition 12. We now move to the proof of Proposition 13.
We decompose U as P ] V , where P is the union of the threads of U whose endpoints
were endpoints in the structure from which U is derived (that is, their type is a type of
endpoint). We let P be (U )|P and proceed as above with the threads of P.

It all works as above except for the two cases where we introduced a jump. Consider
again the situation of Case 6. Our extra cardinality hypothesis ensures that there is a z 6= y
verifying the same conditions as y (otherwise we would be in a previous case). Assume
WLOG that h(x0), y, z appear in that order (c.f. Figure 21).. Set Q00 to be the m-guarded
contiguous-segment-E-swap between [ˆx, y0] and [y, z0] in Q0, and extend h by setting h(x) to
y. h is now an inclusion.

h(x0) ˆx
|
|

y0
|

y
|

•

z0
|

z
|

◦

|

−→

|

|

h(x) y
|
|

◦

|

|

•

|

z
|

|

Figure 20 An illustration of the progression in the inclusion (case 6, for Proposition 13)

We also introduced a jump when extending h to the endpoint of some thread. But the
cardinality condition ensures that we have two endpoints a1 6= a2 outside of Im(h) such that
segtypen−m
m+1,P (e). Hence at least one of them is
on a diﬀerent thread than h(x0) and the procedure described above yields an inclusion.

m+1,Q0(a1) = segtypen−m

m+1,Q0(a2) = segtypen−m

In order to conclude the proof of Proposition 13 it remains to extend the domain of h to
V . This done in the exact same way but, as the threads of V may not include the endpoints,

C S L 2 0 2 0

23:34 Order-Invariant First-Order Logic over Hollow Trees

it gives rise to new cases. We use the same notations. Let t be the thread under investigation
and let u be its ﬁrst element in V . Note that u doesn’t have to be an endpoint of t.

The ﬁrst diﬀerence is in Case 6: it may be the case that there is no z verifying the same
conditions as y. In this case, and if no previous case is applicable, it must be the case that
such a z appear “before” h(u): that is, z, h(u), h(x0), y appear in that order. There are now
two possibilities:

as described in Figure 22, z0, z, h(x0) are in that order, where z0 is the image of x0 by
an isomorphism mapping the neighborhood of x to that of z. Then set Q00 to be the
m-guarded contiguous-segment-E-swap between [z, h(x0)] and [ˆx, y0] in Q0, and extend h
by setting h(x) to y.

z0 z
|
|

|

(cid:7)

h(u) h(x0)

•

|

|

|
ˆx

y0 y
|
|

◦

♦

| −→

|

(cid:7)

z0 ˆx
|
|

y0
|

z
|

◦

h(u) h(x0)

•

|

|

|
y

♦

|

Figure 21 An illustration of the progression in the inclusion of V, ﬁrst completion of case 6

otherwise, z, z0, h(x0) appear in that order (c.f. Figure 23).
Set Q00 to be the m-guarded mirror-E-swap at [z0, h(x0)] in Q0, and extend h by setting
h(x) to z. Notice that we have “reversed” the direction on the inclusion of the current
thread but this isn’t an issue since E is not oriented.

z
|

z0
|

h(u)
|

≫

|

•

h(x0)
|

+

|
ˆx

◦

| −→

|

•

h(x0)
|

)

|
z

h(u)
|

≪

z0
|

ˆx
|

◦

|

Figure 22 An illustration of the progression in the inclusion of V, second completion of case 6

The second diﬀerence is that it is now possible that none of the cases described above are
applicable. In that situation, there must exist two nodes y and z “before” h(u) having the
same type as x. If at least one of them (say z) is in reverse order (i.e. z, z0, h(x0) appear in
that order, c.f. Figure 23) we proceed exactly as before.

Otherwise, it means that we can set Q00 to be (assuming WLOG that y, z, h(x0) appear
in that order, c.f. Figure 24) the m-guarded contiguous-segment-E-swap between [y, z0] and
[z, h(x0)] in Q0 and extend h by setting h(x) to y.

|

(cid:7)

|

y
|

z0
|

z
|

•

h(u)
|

◦

h(x0)
|

|

−→

♦

|

|

(cid:7)

|

z
|

h(u)
|

◦

h(x0) y
|
|

z0
|

•

|

♦

|

Figure 23 An illustration of the progression in the inclusion of V, if no previous case is applicable

(cid:74)

D Proofs for Section 5 (Tools for reorganizing S-edges)

(cid:73) Lemma 14. ∀α, m ∈ N, ∃N ∈ N, ∀W ∈ CtxtN
pseudo-inclusion, then there exists some Q0 ∈ quasi-Hm+1

σ , ∀Q ∈ quasi-HN

σ , if h : W → Q is a N -
and some (m+1)-pseudo-inclusion

σ

J. Grange and L. Segouﬁn

23:35

h0 : W → Q0 such that Q0 ≡<-inv FO
S-siblings in W, then so are h0(x) and h0(y) in Q0.

α

Q, Suppm+1(Q0) ’ Suppm+1(Q) and, if x and y are

Proof. We can assume that m ≥ s(α). N is to be ﬁxed later, and will chosen such that
2N ≥ 2(2m + 3) + 1.

Let (x1, y1), · · · , (xr, yr) denote all the pairs of endpoints of threads of length ≤ 2N − 1
of W (they must be S-siblings), and let (xr+1, yr+1), · · · , (xs, ys) denote the other pairs of
S-siblings of W, in an arbitrary order.

We are going to construct a sequence of structures Q = Qr ≡<-inv FO

α
same (m + 1)-enriched support, and functions fr, · · · , fs such that

· · · ≡<-inv FO
α

Qs of

fi (m + 1)-pseudo-includes W in Qi
∀j ≤ i, fi(xj) and fi(yj) are S-siblings in Qi
∀j > i, let z be the S-sibling of fi(xj) in Qi. Let Z (resp. Y ) be the element at distance
2m + 3 of z (resp. fi(yj)) in Supp0(Qi) (Z and Y exist since their threads are of length
≥ 2N ). Then Suppm+1(Qi)|[z,Z] ’ Suppm+1(Qi)|[fi(yj ),Y ]

For i = r, set Qr := Q and fr := h. Note that threads of Q of length ≤ 2N − 1
must have matching endpoints. N is chosen large enough so that the last property holds
(N := 2 + (2m + 3) + (m + 1) is enough).

Assume now that we have constructed Qi and fi as required. If fi(xi+1) and fi(yi+1) are

S-siblings in Qi, set Qi+1 := Qi and fi+1 := fi.

Otherwise, let z be the S-sibling of fi(xi+1), Z (resp. Y ) be the element at distance 2m+3
of z (resp. fi(yi+1)) in Supp0(Qi), and Z 0 (resp. Y 0) be the element at distance 2m + 4 of z
(resp. fi(yi+1)) in Supp0(Qi). We know that Suppm+1(Qi)|[z,Z] ’ Suppm+1(Qi)|[fi(yi+1),Y ]
(witnessed by an isomorphism φ).

In particular, tpm
Qi

(Z, Z 0) = tpm
Qi
distant in Supp0(Qi) by choice of N .
We distinguish between two cases:

(Y, Y 0), and {Y, Y 0, Z, Z 0} and End(Qi) are (2m + 3)-

if Y, Y 0 and Z, Z 0 are in diﬀerent threads.
Let Qi+1 be the m-guarded crossing-E-swap between ZZ 0 and Y Y 0 in Qi (c.f. Figure 25).

fi(xi+1)
|

|

|

•

◦

Z 0 Z
|
|

Y 0 Y
|
|

|

z
|

♦

−→

fi(yi+1)
|

♦
2m + 3

fi+1(xi+1) = fi(xi+1)
|

|

|

◦

•

|

Y 0 Z
|
|

Z 0 Y
|
|

fi+1(yi+1) = z
♦
|

fi(yi+1)
|

♦

Figure 24 After the m-guarded crossing-E-swap between ZZ 0 and Y Y 0 in Qi, fi+1(xi+1) and

fi+1(yi+1) are S-siblings

if Y, Y 0 and Z, Z 0 are in the same thread.
Let Qi+1 be the m-guarded mirror-E-swap at [Z 0, Y 0] in Qi (c.f. Figure 26).

In both cases, we deﬁne fi+1 as Φ ◦ fi where Φ the permutation of Qi deﬁned as φ on

[z, Z], φ−1 on [fi(yi+1), Y ], and the identity elsewhere.

Lemma 9 guarantees that in both cases, Qi+1 ≡<-inv FO

α

Qi and, together with the invariant

Suppm+1(Qi)|[z,Z] ’ Suppm+1(Qi)|[fi(yi+1),Y ], that Suppm+1(Qi+1) ’ Suppm+1(Qi).

C S L 2 0 2 0

23:36 Order-Invariant First-Order Logic over Hollow Trees

fi(xi+1)
|

fi(yi+1)
|

♦

Y Y 0
|
|

Z 0 Z
|
|

>>>

|

z
|

♦
2m + 3

fi+1(xi+1)
|

−→

fi(yi+1)
|

♦

Y Z 0
|
|

Y 0 Z
|
|

<<<

|

fi+1(yi+1) = z
♦
|

Figure 25 After the m-guarded mirror-E-swap at [Z 0, Y 0] in Qi, fi+1(xi+1) and fi+1(yi+1) are

S-siblings

Furthermore, fi+1(xi+1) and fi+1(yi+1) are S-siblings, and it is straightforward to see

that fi+1 is a (m + 1)-pseudo-inclusion, and that the other conditions are still respected.

In the end, Q0 := Qs and h0 := fs ﬁt.

(cid:74)

We will often need to state that several sets are far from each other. To this end we
introduce the notion of scattering, which is a compact way of saying that. For a subset A
of a structure R whose vocabulary contains the binary relation S, deﬁne R \ S(A) to be R
minus all the S-edges adjacent to any element of A. If A = {z}, we note R \ S(z) instead of
R \ S({z}).

(cid:73) Deﬁnition 23. Let A1, · · · , Ak, B be subsets of R, and δ ∈ N.

We say that A1, · · · , Ak are δ-scattered wrt. B if A1, · · · , Ak, B are pairwise δ-distant

in R \ S(A1 ∪ · · · ∪ Ak).

The following lemma will be useful in a couple of proofs. It gives a setting in which we

can apply simultaneous crossing-S-swaps:

1, b00

s, a00

(cid:73) Lemma 24. Let α, s ∈ N, m ≥ s(α),R ∈ quasi-Hm+1
b1, b0
i, a00
s , bs, b0
1 ,· · · , as, a0
of ai (resp. bi) and B ⊇ {b1, b0
(2m + 5)-distant and for every i, tpm
Let R0 be R where all the S(ai, a0
i ), S(bi, a0

σ
s ∈ R such that a0
1 , · · · , bs, b0
i, a00
R(ai, a0
i), S(ai, a00

s, b00
i ) = tpm
i ), S(bi, b0

i) and S(bi, a00

s, b00
1, b00

i), S(ai, b00

S(ai, b0
S-swap between ai and bi in R.

1, a00
1 ,
i, b00
i ) are the S-children
s } such that {a1}, · · · , {as}, B are pairwise

, and distinct elements a1, a0
i (resp. b0

R(bi, b0

i, b00
i ).
i) and S(bi, b00

i ) have been replaced by
i ): in other words, R0 is the simultaneous crossing-

R, Suppm+1(R0) = Suppm+1(R) (in particular, R0 ∈ quasi-Hm+1

σ

)

Then R0 ≡<-inv FO

and {a1}, {a0

α
1, a00
1 }, · · · , {as}, {a0

s, a00

s } are m-scattered wrt. B in R0.

Proof. Recall from Note 7 that 2m + 5 provides a suﬃcient distance condition to apply a
m-guarded crossing-S-swap.

We construct a sequence of structures R = R0 ≡<-inv FO

Rs having the
same (m + 1)-enriched support, where Ri is the simultaneous crossing-S-swap between aj
and bj in R for every j ≤ i.

· · · ≡<-inv FO
α

α

Let’s show by induction that for every i, Ri veriﬁes (Pi):

1. {ai+1}, · · · , {as}, B are pairwise (2m + 5)-distant
2. {a1}, {a0

1 }, · · · , {ai}, {a0

i } are m-scattered wrt. B

1, a00

i, a00

R veriﬁes (P0). Suppose that we have constructed Ri and let Ri+1 be the m-guarded
crossing-S-swap between ai+1 and bi+1 in Ri: (Pi).1 ensures that distRi(ai+1, bi+1) ≥ 2m + 5.
Lemma 8 gives Ri+1 ≡<-inv FO
Ri and Suppm+1(Ri+1) = Suppm+1(Ri). Let’s show that
Ri+1 veriﬁes (Pi+1):

α

J. Grange and L. Segouﬁn

23:37

(Pi+1).1 holds since the (2m + 4)-neighborhoods of the (aj)j>i+1 haven’t seen any change,

because of (Pi).1.
(Pi+1).2 : Let R−

i denote Ri \ S({a1, a0
1, a00

i+1 denote Ri+1 \ S({a1, a0

1, a00

1 , · · · , ai, a0

1 , · · · , ai+1, a0

i, a00
i+1, a00

i }).
i+1}).

Let R−

i, a00

1, a00

1 } ∪ · · · ∪ {ai} ∪ {a0

Let x, y ∈ {a1} ∪ {a0
(Pi).2 entails that x and y are each at distance ≥ m in R−
from each other and from B,
i
and (Pi).1 implies (since x and y are at distance 1 of B) that they are at distance ≥ m
in Ri (hence in R−
Hence, the swap doesn’t aﬀect their m-neighborhoods in R−
≥ m from each other and from B in Ri+1 \ S({a1, a0

i , and they are still at distance
i }), hence in R−
i+1

i } be elements of two diﬀerent sets.

i ) from {ai+1, a0

1 , · · · , ai, a0

i+1, a00

i+1}.

1, a00

i, a00

i+1, a00

i+1} and b ∈ B. A path in R−

Let a ∈ {ai+1, a0
i+1 of length ≤ m−1 from a to b or from
a to x doesn’t go through the new S-edges, hence is valid in Ri and contradicts (Pi).1 (in
(a, b) ≥ m
the second case, because x is at distance 1 from B in Ri). This entails distR−
and distR−

(a, x) ≥ m

i+1

i+1

It remains to show that distR−
Suppose that there is a path of length ≤ m − 1 in R−
is valid in R−
Ri ∈ quasi-Hm+1

i . Hence, there would be a “vertical loop” in N Ri

(ai+1, a0

i+1

.

σ

i+1 from ai+1 to a0

i+1).
i+1. This path
m+1(ai+1), contradicting

i+1) ≥ m (and similarly for ai+1 and a00

We set R0 := Rs, which has the desired properties.

(cid:74)

(cid:73) Proposition 15. For every α, m ∈ N, there exist N, d, D ∈ N such that, for every P ∈ Hσ,
Q ∈ quasi-HN +1
d [[EN +1(Q)]] and P is (N + 1)-pseudo-included
in Q through some h, there are some h0 and Q0 ∈ quasi-Hm+1
Q,
Suppm+1(Q0) ’ Suppm+1(Q), h0 is a reduced (m + 1)-pseudo-inclusion of P in Q0 and
Q0 \ Im(h0) is S-stable in Q0.

such that [[EN +1(P)]] ≤D

such that Q0 ≡<-inv FO

α

σ

σ

Proof. We can assume that m ≥ s(α). We will ﬁrst provide a non-necessarily reduced
(m0 + 1)-pseudo-inclusion verifying those conditions, with m0 := 2m + 3, and then modify it
as well as the underlying structure to get a ﬁtting reduced (m + 1)-pseudo-inclusion.

For every n ∈ N (we will assign a value to n later on), there is a N such that, under the
hypothesis, Lemma 14 yields R ≡<-inv FO
Q such that Suppn+2(R) ’ Suppn+2(Q) and g
which (n + 2)-pseudo-includes P in R and respects the S-siblings relation; we denote by V
the complement of Im(g) in Q. This implies that two nodes having the same S-parent are
both either in Im(g) (and are the two endpoints of the same thread) or in V .

α

We say that z ∈ V is misassociated if its S-children are in Im(g). Likewise, we say that
g(x) is misassociated if its S-children are in V . The (n + 2)-type of this element is called the
type of the misassociation. Note that the number of misassociations in V and in Im(g) is
the same.

First, we deal with all but a bounded number of misassociations. There exists a M (which
depends only on n) such that, if there are more than 2M misassociations, then we can ﬁnd a
misassociated element of V and one of Im(g) that have the same type, and are at distance
≥ 2(n + 1) + 5 from one another: this is because a hollow quasitree has degree at most 4. We
can solve these misassociations by a (n + 1)-guarded crossing-S-swap, according to Lemma 8
and Note 7, which preserves Suppn+2(R).

Once we’ve done that, we’re left with at most M misassociations in V , and the same
r )) be an arbitrary enumeration

number in Im(g). Let (z1, g(x0

1 )), · · · , (zr, g(x0

1), g(x00

r), g(x00

C S L 2 0 2 0

23:38 Order-Invariant First-Order Logic over Hollow Trees

of the misassociated elements of V , together with their S-children (recall that x0
S-siblings in P, and let xi be their S-parent).

i and x00

i are

Fix i between 1 and r. There exists a sequence xi = x1

i and x00j

i

the S-children of xj

), and g(xsi

i ) is misassociated ; let z0

i , · · · , xsi
i in P, for every j, g(xj
i, z00

i of elements of P , such
i ) is the S-parent
i ∈ V be its S-children, and

that, if we name x0j
of g(x0j+1
rename yi := xsi
i

) and g(x00j+1

i

i

for ease. This sequence is represented in Figure 27.

zi
•

V
V

g(x1
i )
•

g(x2
i )
•

Im(g)

· · ·

g(xsi

i ) = g(yi)

•

V
V

g(x01
i )

g(x001

i ) g(x02
i )

g(x002

i )g(x0si
i )

g(x00si
i

) z0
i

z00
i

Figure 26 From zi to (z0

i, z00
i )

P (x0j+1
R (g(xj+1

For every j, tpn+2
in turn implies tpn+1

R (g(x0j+1
R (g(xj
i ))
i
R (zi) = tpn+1
For the same reason, we have that tpn+1
R (g(yi))

) = tpn+2
)) = tpn+1

R (zi) = tpn+1

)), hence tpn+1

τi := tpn+1

i

i

P (xj+1

i

) = tpn+1

R (g(xj

i )), which

R (g(x1

i )).

In the end, we get

Let B be the set containing the zi, the g(yi), for 1 ≤ i ≤ r, and their S-children.
Since we’ve bounded r by M and R is of degree 4, we can choose d and D large enough so
i, t00
that we are able to ﬁnd t1, · · · , tr ∈ V and u1, · · · , ur ∈ Im(g), with respective S-children t0
i
and u0
i , such that ti and ui are of type τi (since zi ∈ V is of type τi, there must be at least
d elements of this type in Im(g) and D in V ), and such that {t1}, · · · , {tr}, {u1}, · · · , {ur}, B
are pairwise (2n + 5)-distant in R.

i, u00

We can apply Lemma 24 with s = 2r, (a1, · · · , as) = (t1, · · · , tr, u1, · · · , ur) and

(b1, · · · , bs) = (z1, · · · , zr, g(y1), · · · , g(yr)).

This ensures that R0 (which is the simultaneous crossing-S-swaps between zi and ti and
R and Suppn+1(R0) =
r, t00
r } are

crossing-S-swaps between g(yi) and ui) is such that R0 ≡<-inv FO
α
Suppn+1(R). Furthermore, {t1}, {t0
1 }, · · · , {tr}, {t0
n-scattered wrt. B in R0.

r }, {ur}, {u0

2}, {u1}, {u0

1, u00

r, u00

1, t0

Note that we haven’t added any new misassociated element in the process: the only

misassociated elements in R0 are now the ti and the ui.

Choose retrospectively n := 2m0 + 5
Let’s show that {t1}, · · · , {tr}, {u1}, · · · , {ur} are pairwise (2m0 + 5)-distant in R0.
Let x, y be distinct elements among them, and let’s prove that distR0(x, y) ≥ 2m0 + 5.
Suppose that’s false, and consider a shortest path from x to y. It cannot be valid in R, hence
it must go though at least one new S-edge, and the ﬁrst one must be S(x, x0), with x0 being
either z0

i ) (if x = ti) for some i.

i (if x = ui) or g(x0

i) or g(x00

i or z00

The only way to reach y from x0 in less than 2m0 + 4 is through a S-children y0 of y.
Now, x 6= y, hence distSupp0(R0)(x0, y0) ≥ 2m0 + 3 (either they are endpoints of two
diﬀerent threads, either the thread they’re both in doesn’t have the matching endpoint
property, which ensures that it is of length > 2n + 1). We can thus apply Lemma 21, which
states that the path of length ≤ 2m0 + 3 from x0 to y0 must go through either x or y. This
contradicts the minimality hypothesis.

We can proceed to the sequence of m0-guarded crossing-S-swap between ui and ti in R0

for every i.

J. Grange and L. Segouﬁn

23:39

After the r swaps, we end up with R00 ≡<-inv FO

α

Q, such that Suppm0+1(R00) ’

Suppm0+1(Q), and with no misassociation left wrt g.

If the pseudo-inclusion g isn’t reduced, we reduce it by eliminating one by one its

redundant jumping pairs.

Seeing g as a m-pseudo-inclusion, we get that nodes involved in a jumping pair are at

distance ≥ 2m + 3 from the endpoints in Supp0(R00).

Let {x, x0} and {y, y0} be two jumping pairs with the same type, and u0, u (resp v0, v) be
the E-neighbors of g(x), g(x0) (resp. g(y), g(y0)) in [g(x), g(x0)] (resp. [g(y), g(y0)]). We have
that tpm

R00(u, g(x0)) = tpm

R00 (g(x), u0) = tpm

R00(g(y), v0) = tpm

R00 (v, g(y0))

If their images are on two diﬀerent threads (c.f. Figure 28), we can perform two m-guarded
crossing-E-swaps: ﬁrst, the m-guarded crossing-E-swap between g(x)u0 and vg(y0) in R00,
and then the m-guarded crossing-E-swap between g(x)g(y0) and ug(x0) in the previous swap,
after which {x, x0} is no longer a jumping pair.

g(x) u0
|
|

g(y) v0
|
|

•

◦

u g(x0)
|
|

v g(y0)
|
|

|

|

−→

|

|

|

|

g(x)
|

|
g(y0)

g(y)
|

|

◦

|

|

−→

u g(x0)
|
|

|

•

|

g(x)
|

|
g(x0)

g(y)
|

|

◦

|

|

|

|

|

•

|

g(y0)
|

|

Figure 27 Elimination of a jumping pair among two, in diﬀerent threads

If their images appear on the same thread in the order g(y), g(y0), g(x), g(x0) (c.f. Fig-
ure 29), we can perform the m-guarded contiguous-segment-E-swap between [v0, g(x)] and
[u0, u] in R00, after which {x, x0} is no longer a jumping pair.

|

g(y)
|

|
v0

g(y0) g(x)

•

|

|

◦

|

|
u0

g(x0)
|

|
u

| −→

|

g(y)
|

|

g(y0) g(x)

◦

|

|

•

|

|

|

|
g(x0)

|

Figure 28 Elimination of a jumping pair among two, with a contiguous-segment-E-swap

Otherwise, we can assume that the images appear in the order g(y), g(y0), g(x0), g(x)
(c.f. Figure 30). We can perform two consecutive m-guarded mirror-E-swaps: ﬁrst the
m-guarded mirror-E-swap at [v0, g(x0)] in R00, and then (in order to reverse again the
segment [g(y0), g(x0)] into the initial direction) the m-guarded mirror-E-swap at [g(x0), u0] in
the previous swap, after which {x, x0} is no longer a jumping pair.

|

g(y)
|

|
v0

g(y0) g(x0)

•

|

|

+

|

|

◦

g(x)
|

|

| −→

|

g(x0) g(y0)

|

|

•

|

|

◦

|

|
g(y)

)

g(y0) g(x0)

g(x)
|

|
u0

| −→

g(y)
|

|

|

◦

|

|

•

|

|

+

|

|
g(x)

|

Figure 29 Elimination of a jumping pair among two, with two mirror-E-swaps

C S L 2 0 2 0

23:40 Order-Invariant First-Order Logic over Hollow Trees

In the end, we get Q0 ≡<-inv FO

Q, such that Suppm+1(Q0) ’ Suppm+1(Q), and a
reduced h0 that (m + 1)-pseudo-includes P in Q0. Notice that during the transformation
from g (which was misassociation-free) to h, we never created any misassociation. Hence,
Q0 \ Im(h0) is S-stable.

α

E

Proofs for Section 6 (Removing unnecessary material)

(cid:74)

Let W+ ∈ Ln

σ, and g be a n-inclusion from W to some R ∈ quasi-Hn
σ.

Let R+ be an extension of R to Σn obtained in the following way. For every τ ∈ Typen
τ ), J i

and i ∈ {1, 2}, such that there exists (a unique) xi
interpreted in R+ as {g(xi
unicity of such yi
interpreted as the empty set. We say that R+ is the g-border-extension of R.

τ /∈ Im(g) and E(g(xi
τ is guaranteed. This process is depicted in Figure 31. Every other J i

σ[2],
τ (xi
τ is
τ ). The existence and
τ is

τ ∈ W such that W+ |= J i
τ ), yi

τ }, where yi

τ ), yi

g(x1
τ )
|
|

g(x2
τ )
|
|

|

|

|

−→

|

|

|

|

J 1
τ
|
|

J 2
τ
|
|

|

|

|

Figure 30 From an inclusion g (double line) of the previous V in R to the g-border-extension R+

Let In be the FO-interpretation from the vocabulary Σn to Pσ ∪ {E, S}, which adds
τ (b) for some i ∈ {1, 2} and τ , and then
τ )(i,τ ). Every In has arity 1 and depth 0. Hence for every k ∈ N and
k

an E-edge between a and b if a 6= b, J i
forgets about the (J i
Σn-structures A and B, A ≡<-inv FO

B entails In(A) ≡<-inv FO

τ (a) and J i

In(B).

k

(cid:73) Proposition 16. For every α, n ∈ N, there exists N ∈ N such that for every P ∈ Hσ,
Q ∈ quasi-Hn
σ and reduced n-pseudo-inclusion h : P → Q, if V := Q \ Im(h) is S-stable then
there exists some Q0 ∈ quasi-Hn
σ and a reduced n-pseudo-inclusion h0 : P → Q0 such that
Q0 ≡<-inv FO
α

Q, U := Q0 \ Im(h0) is S-stable and |U | ≤ N .

Proof. For every equivalence class C of ≡<-inv FO
N := max{|U C
ﬁnite index.

+| : C equivalence class for ≡<-inv FO

α

α

on Ln
σ, pick a representative U C
}. N is well deﬁned since ≡<-inv FO
α

+. Now, set
is of

Let Q+ be a h-jump-extension of Q.
Let U+ be the representative of the class of V+ := Ctxtn(Q+|V ).
Since V is S-stable in Q, Q+ \ {E(h(x), u0), E(u, h(x0)) : {x, x0} jumping pair} can be

decomposed as V+ ] R+ for some Σn-structure R+.

Note that Q = In(V+ ] R+). We set Q0 := In(U+ ] R+) and h0 := h (this makes sense

since R = Im(h)).

By deﬁnition of U+, U+ ] R+ ≡<-inv FO
It remains to show that h0 is a n-pseudo-inclusion. Every thread of P is still sent on a
single thread: indeed, for every jumping pair {x, x0} for h, h0(x) and h0(x0) lie on the same
thread. This is because in U+ ∈ Ln
σ.

V+ ] R+. Applying In yields Q0 ≡<-inv FO

Q,

α

α

All that’s left to prove is that for every a ∈ R, tpn

Q0(a) = tpn

fact that for every τ and i ∈ {1, 2}, the element of U+ colored with J i
coloured with J i

τ (if they exist) have the same n-type, once again because U+ ∈ Ln
σ.

Q(a). This follows from the
τ and the element of V+
(cid:74)

J. Grange and L. Segouﬁn

23:41

We now turn to loop elimination.
Our goal is to get rid of the extra material found outside of the image of the pseudo-
inclusion. For that, we make sure it is S-stable (Proposition 15), we minimize it (Proposi-
tion 16), then we include (Proposition 13) a great number a times this loop in Q. However, to
be able to remove a copy while staying in the same ≡<-inv FO
-class, we need to recreate every
of these loops to the original cape we included: recall indeed that the inclusion preserves the
E-edges, but not necessarily the S-edges.

α

The following lemma gives a method to modify the including structure so that the

pseudo-inclusion respects S-edges.

(cid:73) Lemma 25. ∀α, n, ∃N, ∀M, ∃D ∈ N, ∀Q ∈ quasi-HN +1
such that |W | ≤
M , for all (N + 1)-inclusion h : W → Q such that for every (N + 1)-type τ that occurs in
W, there are at least D elements of type τ in Q \ Im(h), there exist some Q0 ∈ quasi-Hn
σ and
some g that n-includes W into Q0 such that Q0 ≡<-inv FO
Q, Suppn(Q0) ’ Suppn(Q) and
W |= S(x, y) → Q0 |= S(g(x), g(y)).

, ∀W ∈ CtxtN +1

α

σ

σ

Proof. We can assume that n ≥ s(α). We’ll assign values to m and N later on, in that order.
Keep in mind from Note 7 that a crossing-S-swap is guarded as long as it happens
between elements of same type that are distant enough. First, we re-associate the S-edges
going in/out of the images of every S-parent and S-child. The hypothesis on the number of
excess occurrences of every type allows us to scatter their S-neighbors across the including
structure. Recall that we introduced the notion of scattering in Deﬁnition 23.

1 ), · · · , (xr, x0

r, x00

r ) the elements of W such that

S(xi, x0

i) ∧ S(xi, x00

Let’s enumerate arbitrarily as (x1, x0
i ) ∧ x0

i 6= x00
i .
First, we use Lemma 14 to ﬁnd R ≡<-inv FO

1, x00

Q such that Suppm+1(R) ’ Suppm+1(Q)
and g such that g : W → R is a (m + 1)-pseudo-inclusion that respects the S-siblings relation,
for some m to be speciﬁed later on. This sets the value for N .

α

i, b00

s, b00

1, b00

i) = b0

1 , · · · , bs, b0

Let B := {b1, b0

s } be such that b0
i ) = b00
k and g(x00

i are the S-children of bi and ∀i ≤
r, ∃j, k ≤ s, g(xi) = bj, g(x0
k (the existence of a k comes from the
fact that g respects the S-siblings relation). Note that the minimal such B is Im(g) plus
the S-children of every g(xi) (if they are not already in Im(g)), plus the S-parent of every
g(x0

i), g(x00
Every hollow 1-quasitree has degree at most 4. In R, | Im(g)| ≤ M ; hence as long as D is
i being the
i ), and {a1}, · · · , {as}, B are pairwise

large enough, there must exist elements (ai)1≤i≤s ∈ R, such that for every i, a0
S-children of ai in R, tpm
R0
(2m + 5)-distant in R, where m := 2n + 5.

i ) (if it’s not already in Im(g)). This guarantees that s ≤ 2r.

i ) = tpm

R(bi, b0

(ai, a0

i, a00

i, a00

i, b00

We are in the right conditions to apply Lemma 24, and get R0 ≡<-inv FO

Supp2n+6(R0) = Supp2n+6(R) and {a1}, {a0
wrt. B in R0. Note that g : W → R0 still preserves the S-siblings relation.

1 }, · · · , {as}, {a0

1, a00

s, a00

R, with
s } are (2n + 5)-scattered

α

ur, u0

i, a00
r , where ui is the S-parent of g(x0

Not all of the ai, a0
r, u00
The scattering of the ai, a0

i are of interest. We re-index them, and focus on u1, u0
i ) and u0
1, u00

i are the S-children of g(xi).
r, u00

i, u00
1 }, · · · , {ur}, {u0

i entails that {u1}, {u0

i), g(x00

1, u00

r } are (2n + 5)-

1 , · · · ,

i, a00

scattered wrt. Im(g) in R0.

Set Wi := W ] {¯xi+1, · · · , ¯xr} where, for every j > i, S(xj, x0

j ) have been
j). There cannot be a path of length ≤ 2n + 5 from x0
j
j ) to xj, as long as N + 1 ≥ 2n + 5, for otherwise there would be a vertical loop in

j) and S(xj, x00

j) and S(¯xj, x0

replaced by S(¯xj, x0
(or x00
tpN +1

W (xj).

C S L 2 0 2 0

23:42 Order-Invariant First-Order Logic over Hollow Trees

Now, let’s re-associate the S-edges back so that g respects S. We construct a sequence of
Tr having the same (n + 1)-enriched support, where Ti

structures T0 ≡<-inv FO
is the simultaneous crossing-S-swap between g(xj) and uj in R0 for j ≤ i.

· · · ≡<-inv FO
α

α

Let’s prove that for every i, Ti veriﬁes (Qi):

1. {ui+1}, {u0
2. ∀j, k > i, let aj ∈ {x0

i+1}, · · · , {ur}, {u0
j }. Then

i+1, u00

j, x00

r, u00

r } are (2n + 5)-scattered wrt. Im(g)

distTi(g(aj), g(xk)) ≥ min(distWi(aj, xk), 2n + 6)

3. ∀j 6= k > i, aj ∈ {x0

j, x00

j } and ak ∈ {x0

k, x00

k}, distTi(g(aj), g(ak)) > 2n + 5

Set T0 := R0.
We check that (Q0).2 holds, for x0

distT0(g(x0
Consider a shortest path from g(x0

j), g(xk)) ≤ 2n + 5, and let’s prove that distW0 (g(x0

j) to g(xk) in T0.

j and xk (it is similar for x00

j ). Let them be such that
j), g(xk)).

j), g(xk)) ≤ distT0 (g(x0

Suppose it goes through at least one S-edge: the ﬁrst time it does, it must be one that
j), which is contained (because g is an inclusion) in
l) (or
l ), which

goes out of the thread containing g(x0
Im(g). (Q0).1 rules out the possibility for this S-edge to be of the form S(g(xl), u0
S(g(xl), u00
contradicts the minimality of this path.

l, the only way to reach g(xk) in ≤ 2n + 4 is through S(g(xl), u00

l )): from u0

Moreover, it cannot be the S-edge landing on the other endpoint of the thread, since this
, the other
j ). In this case, there would be a shortest path from g(x0
j)

would mean that the thread is of length ≤ 2n + 4, and since R0 ∈ quasi-H2n+6
endpoint is guaranteed to be g(x00
to uj, which would directly borrow S(uj, g(x0

σ

j)).
Hence, the ﬁrst S-edge can only be S(uj, g(x0

j)), and (Q0).1 ensures that the only way this
would result in a path of length ≤ 2n + 5 is if the second edge it goes through is S(uj, g(x00
j )),
from which we can repeat the same reasoning to prove that from there, the path doesn’t go
through any S-edge.

The other possibility is that the path doesn’t go through any S-edge. In either case, it
j ) and g(xk) are on the same thread, and the shortest path follows

means that g(x0
the E-edges of this thread. Hence, a path as short exists in W0 between x0

j) or g(x00

j and xk.

We now check that (Q0).3 holds: let x0

j and x0

k (and similarly for x00

that distT0(g(x0

j), g(x0

k)) ≤ 2n + 5, and consider a shortest path from g(x0

j and for x00
j) to g(x0

k) be such
k).

The same reasoning as before ensures that g(x0

j) or g(x00
j ),
and that the shortest path follows the E-edges of that thread, which must then be of length
≤ 2n + 5 which in turn implies that j = k.

k) is on the same thread as g(x0

Now suppose that we have constructed Ti and let Ti+1 be the n-guarded crossing-S-
swap between g(xi+1) and ui+1 in Ti. Suppose that distTi(g(xi+1), ui+1) < 2n + 5: then
distTi(g(xi+1), g(x0
i+1)) ≤ 2n + 5, and (Qi).2 ensures that distWi(xi+1, x0
i+1) ≤ 2n + 5, which,
as seen above, is absurd.

Lemma 8 ensures that Ti+1 ≡<-inv FO

α

Ti and Suppn+1(Ti+1) = Suppn+1(Ti). Let’s show

that Ti+1 veriﬁes (Qi+1):

(Qi+1).1 is straightforward: we only need to note that the new S-edges appeared at distance

≥ 2n + 4 from every A ∈ {{ui+2}, {u0

i+2, u00

i+2}, · · · , {ur}, {u0

r, u00

r }}, in Ti \ S(A).

(Qi+1).2 : let j, k > i + 1 and suppose that there is a path of length l ≤ 2n + 5 between
j )) and g(xk) in Ti+1, and consider a shortest such path. Let’s
j, xk) ≤ l. If this path doesn’t go through any of the new S-edges,

g(x0
show that distWi+1(x0

j) (and similarly for g(x00

J. Grange and L. Segouﬁn

23:43

i+1) or S(ui+1, u00

i+1)), or S(g(xi+1), g(x00

(Qi).2 allows us to conclude (any path going through ¯xi+1 in Wi can now through xi+1
instead).
Otherwise, (Qi).1 ensures that it doesn’t go through S(ui+1, u0
i+1). Thus
we can decompose this path in a sequence of two (since it’s a shortest path) paths valid
in Ti, joined by either S(g(xi+1), g(x0
i+1)), or one then the other.
p2(cid:32) g(xk)
p1(cid:32) g(ai+1)Sg(xi+1)
It is not possible for the path to be decomposable as g(x0
j)
i+1, x00
i+1}), because p1 would be a path of length ≤ 2n + 5 in Ti from g(x0
(for ai+1 ∈ {x0
j)
to g(ai+1), which contradicts (Qi).3
Hence the path can be decomposed as g(x0
j)
p2, of respective length l1 and l2 (with l = l1 + l2 + 1) being valid in Ti.
(Qi).2 allows us to reﬂect p1 as a path from x0
j to xi+1 in Wi of length ≤ l1, and p2 as a
path from ai+1 to xk in Wi of length ≤ l2. Replacing ¯xi+1 by xi+1 in those paths gives
us paths at least as short valid in Wi+1. We then link them with S(xi+1, ai+1) ∈ Wi+1,
and get that distWi+1(x0

p2(cid:32) g(xk), with p1 and

p1(cid:32) g(xi+1)Sg(ai+1)

j, xk) ≤ l1 + l2 + 1 = l.
j, x00

(Qi+1).3 : let j 6= k > i + 1, aj ∈ {x0

k}.

k, x00

i+1) or S(ui+1, u00

j } and ak ∈ {x0
Suppose that there is a path (take a shortest witness) p of length ≤ 2n + 5 between g(aj)
and g(ak) in Ti+1. Because of (Qi).3, p cannot be valid in Ti. Because of (Qi).1, it cannot
go through S(ui+1, u0
i+1))
or S(g(xi+1), g(x00
It cannot go through both, for otherwise we could replace
g(x0
i+1) in p by g(x0
We can decompose p either as g(aj)
the S-edge in the other direction, as g(aj)
{x0
This is absurd since either p1 or p2 breaks (Qi).3

p2(cid:32) g(ak) or, if it goes through
p2(cid:32) g(ak), with ai+1 ∈

i+1). Hence, it must go through S(g(xi+1), g(x0

i+1} and p1, p2 valid in Ti, and of length ≤ 2n + 5.

i+1)Sui+1Sg(x00
p1(cid:32) g(ai+1)Sg(xi+1)

i+1)).
i+1)Sg(xi+1)Sg(x00

i+1) and get a path as short in Ti.

p1(cid:32) g(xi+1)Sg(ai+1)

i+1, x00

We set Q0 := Tr together with g, which have the desired properties.

(cid:74)

(cid:73) Proposition 17. ∀α ∈ N, ∃l ∈ N, ∀m ∈ N, ∃n ∈ N, ∀M ∈ N, ∃K ∈ N such that for every
abstract loop U+ ∈ Ln+1
such that |U | ≤ M , (l + 1) · [[En+1(U)]] <
[[En+1(Q)]] and such that for every (n + 1)-type χ that occurs in U, |Q|χ ≥ K, there exists
Q0 ∈ quasi-Hm

Q and [[Em(Q)]] = [[Em(Q0)]] + [[Em(U)]]

and every Q ∈ quasi-Hn+1

σ such that Q0 ≡<-inv FO

α

σ

σ

Proof. We can assume that m ≥ s(α). Let m1 be given by Lemma 25 from m, D be given
by Lemma 25 from m and M and n be given by Lemma 13 from m1. Set K := D + (l + 1)M

We construct U l

+, U l+1

+ ∈ Ln+1

σ

, such that

α

U l+1
+

[[En+1(U l)]] = l · [[En+1(U)]]
[[En+1(U l+1)]] = (l + 1) · [[En+1(U)]]
+ ≡<-inv FO
U l
Consider the FO-interpretation J (of arity 2 and depth d, independent of n) from the
vocabulary Σn+1 ∪ {N, <} (where N is a unary relational symbol) to Σn+1 ∪ {<}, which,
given a structure V+, returns J (V+) as follows. For the sake of simplicity, we will name
1, · · · , r the elements of N V+ accordingly to <V+

its universe is {1, · · · , r} × (V \ N V+)
J (V+) |= S((i, x), (j, y)) iﬀ i = j and V+ |= S(x, y)
J (V+) |= E((i, x), (j, y)) ∧ E((j, y), (i, x)) iﬀ i = j and V |= E(x, y), or j = i + 1 and
V+ |= J 2
τ (x) and V+ |= J 1
for every τ , J (V+) |= J 1

τ (y) for some τ
τ (i, x) iﬀ i = 1 and V+ |= J 1

τ (x)

C S L 2 0 2 0

23:44 Order-Invariant First-Order Logic over Hollow Trees

for every τ , J (V+) |= J 2
<J (V+) is the lexicographical order

τ (i, x) iﬀ i = r and V+ |= J 2

τ (x)

In other words, if we add r elements to the abstract loop U+, color them with N and add
an order, its image by J is the r-fold concatenation of U+ to itself (in the same direction
each time), with an order.

Fix an arbitrary order <U on U . For r ∈ N, let U [r]

+ be the Σn+1 ∪ {N, <}-structure
obtained by adding {1, · · · , r} to the universe of U+, interpreting N as {1, · · · , r} and ordering
the elements as 1, · · · , r and then accordingly to <U

Now let (U r

+, <r) := J (U [r]

+ ). See Figure 32 for an example.

U+
|

J 1
τ

|

|

|

J 2
τ

J 1
τ

|

|

|

|

|

|

|

|

|

|

|

|

J 2
τ

J−→

J 1
ξ

N

|

•

|

•

J 2
ξ

|

•

J 1
ξ

|

|

|

|

|

|

|

|

|

J 2
ξ

Figure 31 Application of J to U [3]

+ . In this illustration, two jumping pair types τ and ξ are

relevant in U+. The new order <3 is the concatenation of the old ones

If we choose l := 22α+d, we have U [l]

+ ≡FO

2α+d U [l+1]

+

, hence (U l

+, <l) ≡FO

α (U l+1

+ , <l+1), and

+ ≡<-inv FO
U l

α

U l+1
+ .

By construction, [[En+1(U l)]] = l · [[En+1(U)]] and [[En+1(U l+1)]] = (l + 1) · [[En+1(U)]]

By hypothesis, [[En+1(U l+1)]] < [[En+1(Q)]], thus we can apply Proposition 13 to get
Q such that [[Em1+1(R)]] = [[Em1+1(Q)]] and a (m1 + 1)-inclusion h from U l+1 to

R ≡<-inv FO
α
R.

Now, for every (m1 + 1)-type ξ occurring in U l+1, |R|ξ = |Q|ξ ≥ K, hence |R|R\Im(h)|ξ ≥

D by choice of K.

We can apply Lemma 25, which yields some Rl+1 ≡<-inv FO

α

R such that Suppm(Rl+1) ’

Suppm(R), and g m-includes U l+1 in Rl+1, and respects S.
+ be the g-border-extension of Rl+1.

Let Rl+1
Since g(U l+1) is S-stable in Rl+1, we can decompose Rl+1
+ ) ] R0

{1, 2}, J i
abstract loop based upon g(U l+1) such that g respects every J i
τ .
+), and let Rl := Im(g(U l
+) ] R0
+, hence Rl ≡<-inv FO
Rl+1

Note that Rl+1 = Im(g(U l+1
+ ≡<-inv FO
g(U l+1
g(U l

+ for some Σn structure R0

+ ) ] R0
+ ) ] R0

τ (y)} as g(U l+1

τ (x) ∧ J i

+) ] R0

α

α

+).

+ \ {E(x, y) : x, y ∈ Rl+1, i ∈
+, where g(U l+1
+ ) is the

Now, set Q0 := Rl. We have that Q0 ≡<-inv FO

α

[[Em(U l+1)]] + [[Em(R0)]] = [[Em(U)]] + [[Em(U l)]] + [[Em(R0)]] = [[Em(U)]] + [[Em(Q0)]]

Q, and, by construction, [[Em(Q)]] =
(cid:74)

The notion of vertical swap in a tree has been introduced in [5] and is a crucial operation in
their proof. We need here a version of these vertical swaps adapted to hollow trees. Unlike
the other swaps, vertical-S-swap preserve hollow trees. In the following, T is a hollow tree
on σ.

We start by deﬁning classical notions making use of the tree structure of T .

J. Grange and L. Segouﬁn

23:45

The (strict) ancestor relation within a hollow tree is inherited from the original tree and
is denoted by x (cid:22) y (resp. x ≺ y). Note that this relation is not part of the schema and not
expressible in FO from E and S.

Let x, y be two nodes of T such that x ≺ y. We deﬁne the context CT (x, y) at x and
y in T (referred using the simpliﬁed notation C in the following) as the substructure of T
induced by the set {z ∈ T : x ≺ z ∧ y ⊀ z}, with three distinguished nodes colored by
two new unary predicates > and ⊥: the S-children x0 and x00 of x are C’s top-anchors
(>C = {x0, x00}), and y its bottom-anchor (⊥C = {y}). The set V (C) := {z ∈ C : z (cid:22) y} is
the set of vertebræ of C. The height height(C) is |V (C)| and correspond to the diﬀerence
of depth between y and x. Given n ∈ N, C’s n-skeleton, denoted Skn(C), is the substructure
of C induced by the nodes at distance at most n of V (C), of S-children of nodes of V (C), or
of C’s top-anchors. Additionally, Skn(C) inherits the restriction of ≺ to V (C). Two contexts
are said to be n-similar if their n-skeletons are isomorphic. Given two contexts C and D, we
denote by C · D the context obtained as the disjoint union of C and D, with a S-edge from
C’s bottom-anchor to each of D’s top-anchor, and where the anchors are redeﬁned in the
natural way: >C·D := >C and ⊥C·D := ⊥D. Similarly, we deﬁne the preﬁx PT (y) at y in
T as the substructure of T induced by {z ∈ T : y ⊀ z} (the only additional relation being
⊥), and the suﬃx ST (x) at x in T as the substructure of T induced by {z ∈ T : x ≺ z}
(here, the only additional relation is >). The concatenation between a preﬁx and a context,
a preﬁx and a suﬃx, and a context and a suﬃx are deﬁned in the natural way (and results
respectively in a preﬁx, a hollow tree, and a suﬃx). Concatenation is associative.

Let x ≺ xA ≺ xB ≺ xC ∈ T , and x0, x00, x0

C be their respect-
A) =
C). Let us deﬁne P := PT (x), A := CT (x, xA), B := CT (xA, xB), C :=

ive S-children. Suppose that tpk
tpk
CT (xB, xC) and S := ST (xC). With these deﬁnitions, T = P · A · B · C · S.

C, x00
B, x0
B) and tpk

T (x, x0, x00) = tpk

A, x00
A, x0
T (xB, x0

B, x00
B, x00

T (xC, x0

T (xA, x0

C, x00

A, x00

In this case, T 0 := P · C · B · A · S is called the k-guarded vertical-S-swap between

[x, xA] and [xB, xc] in T , c.f. Figure 33.

P

A

B

C

S

−→

P

C

B

A

S

Figure 32 A vertical-S-swap from T to T 0

We wish to show:

(cid:73) Lemma 26. For all α ∈ N, there exists N ∈ N such that for every hollow tree T on σ, if
T 0 is the N -guarded vertical-S-swap between [x, xA] and [xB, xC] in T , then every node in T
has the same (N + 1)-type in T and in T 0, and T 0 ≡<-inv FO

T .

α

It is immediate to check that a N -guarded vertical-S-swap preserves (N + 1)-types. The
, concluding the proof of

following is devoted to the proof that it also preserves ≡<-inv FO

α

C S L 2 0 2 0

23:46 Order-Invariant First-Order Logic over Hollow Trees

Lemma 26.

We start by proving a special case of Lemma 26. We will reduce the general case to it.

This case is illustrated in Figure 34.

(cid:73) Lemma 27. For all α ∈ N, there exists a M ∈ N such that the following holds.
Let T ∈ Hσ and x ≺ xA ≺ xB ∈ T having for respective S-children (x0, x00), (x0
B, x00
Let P := PT (x), A := CT (x, xA), B := CT (xA, xB) and S := ST (xB).
Then P · A · B · S ≡<-inv FO
P · B · A · S

B). Suppose that tpM

T (x, x0, x00) = tpM

A) = tpM

T (xB, x0

T (xA, x0

B, x00

A, x00

B).

(x0

α

A, x00

A) and

P

A

B

S

−→

P

B

A

S

Figure 33 vertical-S-swap (special case) from P · A · B · S to P · B · A · S

Proof. We will ﬁrst set N ∈ N instead of M , that will be suﬃcient for most cases. Then, we
will deﬁne M ≥ N which will work for all cases.

Recall the function oΣ

p introduced in Lemma 6, and consider n := oΣ

3 (α + c) where c is to
be chosen later on, and Σ := Pσ ∪ {E, S, P1/2, P6} where P1/2 and P6 are new unary symbols.
We distinguish between several cases depending on whether x, xA and xB are close or not,
where “close” is relative to n:

1. Assume ﬁrst that tpn

B(x0

A, xB).

A(x0, x00, xA) = tpn

A, x00
This case covers the instances where A and B are n-similar, as well as those where
distT (x, xA) and distT (xA, xB) are > 2n + 2.
Consider the extension T − of P ] A ] B ] S to Σ where the interpretation of P1/2 only
contains the bottom-anchor of P, and that of P6 contains the top-anchors of S. Since
P T −
1/2 and P T −
A, xB).
Hence, we can apply Lemma 6, and get two orders <AB (whose ﬁrst elements are
x0, x00, xA, x0
A, xB, x0, x00, xA) such
that (T −, <AB) ≡FO
Now, consider the FO-interpretation that adds a S-edge between u and v if either:

A, xB) and <BA (whose ﬁrst elements are x0

are at distance +∞ from A and B, tpn

T −(x0, x00, xA) = tpn

α+c (T −, <BA).

T − (x0

A, x00

A, x00

A, x00

6

P1/2(u) and v is either the ﬁrst or the second element of <
u is the third element of < and v is either its fourth or ﬁfth one
u is the sixth element of < and P6(v)

and then forgets about P1/2 and P6.
Take c to be the depth of this FO-interpretation (which has arity 1).
Note that the result of this FO-interpretation of (T −, <AB) is an ordered extension of
P · A · B · S and that its result on (T −, <BA) is an ordered extension of P · B · A · S
This entails P · A · B · S ≡<-inv FO

P · B · A · S

α

J. Grange and L. Segouﬁn

23:47

2. Assume next that B can be decomposed as B1 · · · Bk, where each Bi is n-similar to A.

We can then apply k times Case 1 and obtain P · A · B · S ≡<-inv FO
desired.

α

P · B · A · S as

3. From now on, N ≥ l(2n + 2) + n for a large enough l to be chosen later on.

As we are not in Case 1, we can restrict our study to the cases where distT (x, xA) ≤ 2n+2
(the cases where distT (xA, xB) ≤ 2n + 2 can be treated similarly).
We will need the following claims. The ﬁrst one is just a simple observation.
(cid:73) Claim 28. Let U, V be two n-similar contexts of T .
For every decomposition U = U1 · · · Up, there exists a decomposition V = V1 · · · Vp such
that for every i, Ui and Vi are n-similar.

Proof. Let ϕ be an isomorphism from Skn(U) to Skn(V), and x0 ≺ x1 ≺ · · · ≺ xp ∈
T be such that Ui = CT (xi−1, xi). Since ϕ is ≺-monotonous on V (U), the Vi =
CT (ϕ(xi−1), ϕ(xi)) are well-deﬁned.
We have that V = V1 · · · Vp; it remains to show that for every i, Ui and Vi are n-similar.
Again, the ≺-monotonicity of ϕ entails that ϕ(Skn(Ui)) ⊆ Skn(Vi), which allows us to
(cid:67)
conclude.

The next one is a variant of Lyndon-Schützenberger Theorem stated for contexts of hollow
trees instead of words.
(cid:73) Claim 29. Let n ∈ N, let T ∈ Hσ, let x ≺ y ≺ z ≺ t be nodes of T , and let
U := CT (x, y), V := CT (y, z) and W := CT (z, t) such that U and W are n-similar, U · V
and V · W are n-similar.
Then there exist decompositions U = U1 · · · Up, V = V1 · · · Vq, and W = W1 · · · Wp, where
all the Ui, Vi and Wi are n-similar.

i, x00

CU (xi,xi+1)(x0

i , xi+1), where x0

i are the S-children of xi.

Proof. We deﬁne θn which maps two successive vertebræ xi ≺ xi+1 of a context U to the
type tpn
i and x00
Now, let Θn be the monoïd morphism from contexts to words extending θn; that is, if
x0 ≺ · · · ≺ xd are all the vertebræ of U, then |Θn(U)| = height(U) = d, and the ith letter
of Θn(U) is θn(xi, xi+1).
Let u := Θn(U), v := Θn(V) and w := Θn(W).
By n-similarity of U and W, u = w, and by n-similarity of U · V and V · W, uv = vw.
Hence uv = vu.
By Lyndon-Schützenberger Theorem, there must exist a word a and integers p, q such
that u = w = ap and v = aq [12].
We can decompose U, V and W alongside those decompositions of u, v and w, to get
U = U1 · · · Up, V = V1 · · · Vq, and W = W1 · · · Wp, where all the Ui, Vi and Wi are mapped
(cid:67)
to a by Θn, hence are n-similar.

Let φ be an isomorphism between the N -neighborhood of x and that of xA.
As distT (x, xA) ≤ 2n + 2, xA is in the N -neighborhood of x and set x0 := xA and
x1 := φ(xA). Construct by induction xi+1 := φ(xi) until i > l. Our choice of N ensures
that xi is well deﬁned as xi−1 remains in the N -neighborhood of x. We claim that for all
j ≤ l, Xj := CT (xj−1, xj) is n-similar to A. This is a simple consequence of the fact that
the n-skeleton of of Xj is included into the N -neighborhood of x.

C S L 2 0 2 0

23:48 Order-Invariant First-Order Logic over Hollow Trees

Likewise, starting from xB instead of xA, we show that there exist y1, · · · , yl ∈ T such
that for j ∈ [1, l] (and with the convention that y0 := xB), Yj := CT (yj, yj−1) is n-similar
to A.
We distinguish several cases:

a. Suppose that distT (xA, xB) ≥ 2N . This ensures that all the (xi)i≥1 and (yi)i≥0 belong

to B.

Suppose xl−1 ≺ yl.
If we let C := CT (xl−1, yl), we can decompose B as X1 · · · Xl−1 · C · Yl · · · Y1.
If l is chosen large enough, namely l ≥ 2n + 4, the following decomposition of T

P · A · X1 · · · Xl−1 · C · Yl
}

{z

|

· Yl−1 · · · Y1
}
{z
|

·S

falls in Case 1 of this Lemma and therefore the following equation holds

P ·A · X1 · · · Xl−1 · C · Yl
}

{z

|

· Yl−1 · · · Y1
}
{z
|

·S ≡<-inv FO
α

Likewise, we get

P ·Yl−1 · · · Y1
}

{z

|

· A · X1 · · · Xl−1 · C · Yl
}
{z
|

·S

·S ≡<-inv FO
α

T

α

α

α

|

|

T1

·S

{z

{z

(z) = tpn+1

P · B · A · S as desired.

T and ∀z ∈ T , tpn+1

· Yl−1 · · · Y1 · A
}
{z
|

P ·Yl−1 · · · Y1 · A
}

P ·X1 · · · Xl−1 · C · Yl
}

· X1 · · · Xl−1 · C · Yl
|
}
{z
Hence P · A · B · S ≡<-inv FO
Suppose now that xl−1 ⊀ yl.
Because distT (xA, xB) ≥ 2N , we know that yl ⊀ xl−1: let T1 be the n-guarded
crossing-S-swap between xl−1 and yl in T . Lemma 8 (we can always assume that
n ≥ s(α)) ensures that T1 ≡<-inv FO
(z). We are
now in the situation to apply Case 2. It only remains to do again the n-guarded
crossing-S-swap between xl−1 and yl afterwards to derive the desired T 0 ≡<-inv FO
T .
b. Suppose now that distT (xA, xB) < 2N . Set M := (2N + 1)(2n + 2) + n. Just as
before (by replacing l with 2N + 1), we deﬁne x0, · · · , x2N +1 and y0, · · · , y2N +1, and
accordingly, X1, · · · , X2N +1 and Y1, · · · , Y2N +1 that all are n-similar to A.
There are at most 2N vertebræ in B, hence not all of the (yi)0≤i≤2N can be in B. Let k
be the smallest index such that yk is not a vertebrate of B (we know that 1 ≤ k ≤ 2N ).
Since xA ≺ yk−1 and yk ≺ yk−1, xA and yk must be related by (cid:22); by deﬁnition of
k, we must have yk (cid:22) xA. If yk = xA, we can conclude using Case 2. Otherwise,
yk ≺ xA ≺ yk−1.
Likewise, either x ≺ yk or yk (cid:22) x. By n-similarity of A and Yk, and because
distT (x, xA) ≤ 2n + 2, we know that height(A) = height(Yk). Hence, it cannot be the
case that yk (cid:22) x.
We now have x ≺ yk ≺ xA ≺ yk−1. Let U := CT (x, yk), V := CT (yk, xA) and
W := CT (xA, yk−1). We have that U · V = A and V · W = Yk are n-similar.
To see that U and W are n-similar, look at Yk+1: there is a isomorphism ϕ from
Skn(Yk) to Skn(Yk+1), which is by deﬁnition ≺-monotonous on V (Yk). Hence ϕ sends
any vertebrate of Yk to the vertebrate of Yk−1 whose depth is height(A) smaller. This
entails ϕ(xA) = x, and by restricting ϕ, W and U are n-similar.
We can now apply Claim 29, and get decompositions U = U1 · · · Up, V = V1 · · · Vq, and
W = W1 · · · Wp, where all the Ui, Vi and Wi are n-similar.

J. Grange and L. Segouﬁn

23:49

Hence, A can be decomposed as U1 · · · Up · V1 · · · Vq, and such a decomposition can be
transposed as in Claim 28 onto each Yi, 0 < i < k, as Yi = Y i
p+q, where all the
Y i

j, the Ui, the Vi and the Wi are n-similar.

1 · · · Y i

T = P · U1 · · · Up · V1 · · · Vq
}

|

{z
A

· W1 · · · Wp
{z
}
|
W

|

· Y k−1
1
|

· · · Y k−1
p+q
{z
}
Yk−1
{z
B

· · · Y 1
|

1 · · · Y 1
{z
Y1

p+q
}

·S

Now, we can use Case 2 with A := Vq and derive that T is ≡<-inv FO

α

}

to

P · U1 · · · Up · V1 · · · Vq−1 · W1 · · · Wp · Y k−1

1

· · · Y k−1

p+q · · · Y 1

1 · · · Y 1

p+q · Vq · S

Repeating this operation p + q − 1 times allows us to conclude that P · A · B · S ≡<-inv FO
P · B · A · S.

α

(cid:74)

We are now ready to conclude the proof of Lemma 26. As in the proof of Lemma 27,
3 (α + c) where c is the depth of some FO-
we distinguish between two cases. Let n := oΣ
interpretation to be speciﬁed later on, and Σ := Pσ ∪ {E, S, P1/2, P3, P4/5, P6} where P1/2,
P3, P4/5 and P6 are new unary symbols.

1. Assume ﬁrst that tpn

C (x0

B, xC).

A(x0, x00, xA) = tpn

B, x00
This case covers the instances where A and C are n-similar, as well as those where
distT (x, xA) and distT (xB, xC) are > 2n + 2.
Consider the extension T − of P ]A]B ]C ]S to Σ where P T −
4/5 := {xB} and P T −
P T −
C, x00
6
1/2 , P T −
Since P T −
, P T −
3
tpn
B, x00
T − (x0
B, xC).
Hence, we can apply Lemma 6, and get two orders <AC (whose ﬁrst elements are
B, xC, x0, x00, xA) such
x0, x00, xA, x0
that (T −, <AC) ≡FO
Now, consider the FO-interpretation that adds a S-edge between u and v if either:

C}
are at distance +∞ from A and C, tpn

B, xC) and <CA (whose ﬁrst elements are x0

:= {x0
4/5 and P T −

1/2 := {x}, P T −

T −(x0, x00, xA) =

α+c (T −, <CA).

:= {x0

B, x00

B, x00

A, x00

3

6

A},

P1/2(u) and v is either the ﬁrst or the second element of <
u is the third element of < and P3(v)
P4/5(u) and v is either the fourth or the ﬁfth element of <
u is the sixth element of < and P6(v)

and then forgets about P1/2, P3, P4/5 and P6.
Take c to be the depth of this FO-interpretation (which has arity 1).
Note that the result of this FO-interpretation on (T −, <AC) is an ordered extension of
P · A · B · C · S and that its result on (T −, <CA) is an ordered extension of P · C · B · A · S
This entails P · A · B · C · S ≡<-inv FO
P · C · B · A · S

α

C S L 2 0 2 0

23:50 Order-Invariant First-Order Logic over Hollow Trees

2. We can now, without loss of generality, assume that distT (x, xA) ≤ 2n + 2.

Set N := (2n + 2) + m with m := max(M, n, s(α)), where M is given in Lemma 27.
T (x, x0, x00) to N N
Consider a isomorphism ϕ from N N
By choice of N , tpm
of ϕ(xA).
Since xB ≺ ϕ(xA) and ϕ(xA) 6= xC (for otherwise we would be in Case 1), there are only
three subcases to consider:

B, x00
T (ϕ(xA), y0, y00), where y0 and y00 are the S-children

A) = tpm

T (xB, x0

T (xA, x0

A, x00

B).

if xB ≺ ϕ(xA) ≺ xC, set C0 := CT (xB, ϕ(xA)) and X := CT (ϕ(xA), xC). We then have
T = P · A · B · C0 · X · S. Let T1 = P · C0 · B · A · X · S be the m-guarded vertical-S-swap
between [x, xA] and [xB, ϕ(xA)] in T . This swap falls under the scope of Case 1 since
m ≥ n, hence T1 ≡<-inv FO
Hence we are in the conditions (since m ≥ M ) to apply Lemma 27 on ϕ(xA) ≺ xA ≺ xC
in T1 and get T2 := P · C0 · X · B · A · S ≡<-inv FO
T1. Notice that T 0 = T2, which implies
that T 0 ≡<-inv FO
These sequence of operations is depicted in Figure 35.

T and ∀z ∈ T , tpm+1

(z) = tpm+1

(z).

T1

T

α

α

α

T

P

A

B

C0

X

S

−→

P

C0

B

A

X

S

−→

P

C0

X

B

A

S

Figure 34 The swaps solving the case xB ≺ ϕ(xA) ≺ xC . The second operation swaps the

segments between the dark nodes using Lemma 27.

T

α

α

α

T1

T .

(z).

(z) = tpm+1

T and ∀z ∈ T , tpm+1

if xB ≺ xC ≺ ϕ(xA), set C0 := CT (xB, ϕ(xA)) and X := CT (ϕ(xA), xC). We then have
T = P · A · B · C · X · S 0. Let T1 = P · C · X · B · A · S 0 be the m-guarded vertical-S-swap
between [x, xA] and [xB, ϕ(xA)] in T . This swap falls under the scope of Case 1 since
m ≥ n, hence T1 ≡<-inv FO
Hence we are in the conditions (since m ≥ M ) to apply Lemma 27 on xC ≺ ϕ(xA) ≺ xA
in T1 and get T2 := P · C · B · A · X · S 0 ≡<-inv FO
T1. Notice that T 0 = T2, which implies
that T 0 ≡<-inv FO
These operations are depicted in Figure 36.
otherwise, we have xB ≺ xC and xB ≺ ϕ(xA) but xC and ϕ(xA) are ≺-incomparable.
Let us decompose C · S as C0[S, S 0] (this notation extends in the natural way that of
context, with two bottom anchors), where S 0 := ST (ϕ(xA)), that is T = P · A · B ·
C0[S, S 0].
First, let T1 = P · A · B · C0[S 0, S] be the m-guarded crossing-S-swap between xC and
ϕ(xA) in T . Lemma 8 ensures (since m ≥ s(α)) that T1 ≡<-inv FO
T and ∀z ∈ T ,
tpm+1
(z). The distance precondition in Lemma 8 holds because T is a
T1
hollow tree.

(z) = tpm+1

α

T

J. Grange and L. Segouﬁn

23:51

P

A

B

C

X

S 0

−→

P

C

X

B

A

S 0

−→

P

C

B

A

X

S 0

Figure 35 The case where xB ≺ xC ≺ ϕ(xA). The second operation swaps the segments between

the dark nodes using Lemma 27.

Let T2 = P · C0[S 0, B · A · S] be the m-guarded vertical-S-swap between [x, xA] and
[xB, ϕ(xA)] in T1. This swap falls under Case 1, hence (m ≥ n + 1) we get T2 ≡<-inv FO
T1 and ∀z ∈ T , tpm+1
Now, let T3 = P · C0[B · A · S, S0] be the m-guarded crossing-S-swap between xA
and xC in T2. Lemma 8 ensures (since m ≥ s(α)) that T3 ≡<-inv FO
T2. Notice that
T3 = P · C · B · A · S is nothing but T 0. Hence T 0 ≡<-inv FO
This process is illustrated in Figure 37.

(z) = tpm+1

α
T .

(z).

T1

T2

α

α

−→

S 0

P

C0

B

A

S

P

A

B

C0

S 0

S

−→

S 0

−→

P

A

B

C0

S

B

A

S

P

C0

S 0

Figure 36 The case where xC and ϕ(xA) are ≺-unrelated. The ﬁrst operation is a m-guarded
crossing-S-swap between ϕ(xA) and xC . The second operation uses Case 1. The last operation is
the dual of the ﬁrst one.

(cid:73) Proposition 18. ∀α ∈ N, there exists n1 ∈ N such that ∀P ∈ Hσ, ∀Q ∈ quasi-Hn1
Suppn1(P) ’ Suppn1(Q) then P ≡<-inv FO
Q.

α

σ , if

C S L 2 0 2 0

23:52 Order-Invariant First-Order Logic over Hollow Trees

Proof. Let n0 be the maximum between the integers given by Lemma 26 and Lemma 27,
and s(α).

Let n1 be the integer given by Lemma 14 for n0.
Because of the isomorphism between the n1-enriched supports, there is a trivial n1-
such that
Q, Suppn0+1(Q0) ’ Suppn0+1(Q) and some h0 which (n0 + 1)-pseudo-includes

pseudo-inclusion of P in Q. Thus, Lemma 14 yields some Q0 ∈ quasi-Hn0+1
Q0 ≡<-inv FO
α
P in Q0 and which respects S-siblings relation.

σ

Now, P is a hollow tree, hence has the matching endpoints property, and h0 must be

surjective: this entails that Q0 has the matching endpoints property.

For the remainder of this proof, we will need to apply vertical-S-swaps to Q0 (and
subsequent hollow quasitrees), even though it is not necessarily a hollow tree. However, the
matching endpoints property ensures that the connected component R containing its root is
a hollow tree.

We will only apply vertical-S-swaps in R; when we talk of the vertical-S-swap in Q0, we
mean the disjoint union of the vertical-S-swap in R and of the other connected components
of Q0.

A tree-preﬁx of P or Q0 is a substructure T which contains the root, is E-stable and

such that if S(x, y) and y ∈ T , then x ∈ T .

Let t be a thread with matching endpoints whose parent is y and an element x. We say
that x ≺ t if x (cid:22) y. If u is a thread we write t ≺ u if y ≺ z, where z is the S-parent of both
of u’s endpoints.

Let T0, · · · , Tr be a sequence of tree-preﬁxes of P such that T0 contains only the root of

P, Tr = P , and we go from Ti to Ti+1 by adding a single thread.

We construct a sequence of structures Q0 = Q0, · · · , Qr with the following properties:

Qi+1 ≡<-inv FO
Qi
α
Suppn0+1(Qi+1) = Suppn0+1(Qi)
Ti is vertically-pseudo-included in Qi, that is for every node x and thread t of Ti, if
x is the parent of t in Ti then x ≺ t in Qi. The smallest tree-preﬁx of Qi containing all
the threads of Ti is called the Ti-pseudo-tree.

For i = 0, there is nothing to do: the root of P is vertically-pseudo-included in Q0 = Q0.
From Ti to Ti+1: we let t be the thread in Ti+1 \ Ti and let x be the parent of t.

If t is in the Ti-pseudo-tree of Qi, then there exists some element y and some thread u
in Ti such that in Ti, y is the parent of u, and in Qi, y ≺ t ≺ u. In Qi, let’s call y0 the
parent of u, u0 the thread whose parent is y, x0 the parent of t and t0 the thread whose
parent is x.
There are two cases to consider:

If y ≺ x in P (c.f. Figure 38). Then in Qi, we must have y0 ≺ x, and we can apply
Lemma 26. Let Qi+1 be the n0-guarded vertical-S-swap between [y, x0] and [y0, x] in
Qi. Note that in the limit case where y is the parent of t (that is, x0 = y), we apply
Lemma 27 instead of Lemma 26.
Otherwise, x and y must be ≺-unrelated in Qi (c.f. Figure 39). Note that because
we work in a hollow tree, the conditions to apply Lemma 8 are met. Set Q0 to be
the n0-guarded crossing-S-swap between x and x0 in Qi. Then, set Qi+1 to be the
n0-guarded crossing-S-swap between y and y0 in Q0.

J. Grange and L. Segouﬁn

23:53

y

x0

y0

x

u0

t

u

t0

−→

y

x

y0

x0

u

t

u0

t0

Figure 37 We re-associate y to u and x to t with a vertical-S-swap

x

t0

−→

y

x0

y0

u0

t

u

y

x0

u0

t0

x

y0

t

u

−→

y

u

x

y0

x0

t

u0

t0

Figure 38 We re-associate y to u and x to t with two crossing-S-swaps

Otherwise, if x ≺ t in Qi, we set Qi+1 := Qi
Otherwise, x and x0 are ≺-unrelated in Qi. Once again, we are in the right setting to apply
Lemma 8 because we work in a hollow tree. Let Qi+1 be the n0-guarded crossing-S-swap
between x and x0 in Qi.

In the end, we have vertically-pseudo-included P into Qr. Since they have the same
(cid:74)

support, the vertical-pseudo-inclusion is an isomorphism. Hence, P ≡<-inv FO

Q.

α

C S L 2 0 2 0

