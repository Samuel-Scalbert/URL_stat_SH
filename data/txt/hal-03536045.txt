Schema-Based Automata Determinization
Joachim Niehren, Momar Sakho, Antonio Al Serhali

To cite this version:

Joachim Niehren, Momar Sakho, Antonio Al Serhali. Schema-Based Automata Determinization. Gan-
dalf 2022: 13th International Symposium on Games, Automata, Logics, and Formal Verification, Sep
2022, Madrid, Spain. ￿hal-03536045v2￿

HAL Id: hal-03536045

https://inria.hal.science/hal-03536045v2

Submitted on 25 Jul 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Schema-Based Automata Determinization

Joachim Niehren
Inria, France Universit´e de Lille

Momar Sakho
Inria, France Universit´e de Lille

Antonio Al Serhali
Inria, France Universit´e de Lille

joachim.niehren@inria.fr

momar.sakho@inria.fr

antonio.al-serhali@inria.fr

We propose an algorithm for schema-based determinization of ﬁnite automata on words and of step-
wise hedge automata on nested words. The idea is to integrate schema-based cleaning directly into
automata determinization. We prove the correctness of our new algorithm and show that it is always
more efﬁcient than standard determinization followed by schema-based cleaning. Our implemen-
tation permits to obtain a small deterministic automaton for an example of an XPath query, where
standard determinization yields a huge stepwise hedge automaton for which schema-based cleaning
runs out of memory.

1 Introduction

Schemas and queries for nested words are deﬁnitions of languages of words, trees, unranked trees, and
hedges. They can model and query structured text documents such as XML and JSON documents.

Regular queries and schemas can be deﬁned by deterministic nested word automaton (NWA) [24, 8,
2, 27]. An example for a regular schema is the XML data model and examples for regular queries are the
forward navigational XPath queries on XML documents. Path queries can be seen as logical queries with
a single free variable x. Such queries deﬁne languages of nested words containing exactly one occurrence
of x. This property in turn, can be expressed by a schema onex over the alphabet extended by the query’s
variable x.

Stepwise hedge automata (SHAs) provide alternative deﬁnitions for regular schemas and queries
on nested words [26]. SHAs naturally subsume ﬁnite automata on words (NFAs) as well as stepwise
tree automata for unranked trees [10]. SHAs have the same expressive power as NWAs modulo P-time
transformations. Furthermore, SHAs come with a notion of determinism that generalizes on the left-
to-right determinism of NFAs and on the bottom-up determinism of tree automata. An algorithm for
determinizing SHAs can be based on the usual subset construction in contrast to NWAs. This becomes
possible since SHAs do not support any form of top-down determinism, which for NWAs can be ruled
out by imposing the weak single-entry property.

There exist compilers from forward navigational XPath queries to NWAs [4, 25, 12] and to SHAs [26].
The resulting automata can be determinized in, at most, exponential time. Deterministic automata are
crucial for algorithmic tasks such as universality or inclusion checking. Both problems can be decided
in P-time for the classes of deterministic SHAs or NWAs, but is DEXPTIME complete in the nondeter-
ministic cases. For instance, universality checking is relevant for the earliest query answering of XPath
queries on XML streams [17]. It is also relevant for the efﬁcient enumeration of the answer sets of regu-
lar queries [28]. The need for deterministic automata in these applications motivates the question of how
to determinize automata for nested words in practice.

Debarbieux et al.

[12] noticed that the usual determinization algorithm for NWAs often behaves
badly when applied to NWAs obtained from XPath queries as simple as //a/b. As recalled in the survey
of Okhotin and Salomaa [27], this determinization algorithm was ﬁrst invented by von Braunm¨uhl and
Verbeek in the eighties in the journal version of [8] and then rediscovered various times later on, for

Submitted to:
Gandalf 2022

© Niehren, Sakho, and Al Serhali
This work is licensed under the
Creative Commons Attribution License.

2

Schema-Based Determinization

instance in [3]. Niehren and Sakho [26, 7] observed recently that the situation is different for the de-
terminization of SHAs: It works out nicely for the SHA of //a/b and also for all other SHAs obtained
by compilation from forward navigational XPath queries in the XPathMark benchmark [16]. Even more
surprisingly, the same good behaviour was observed for the determinization algorithm for NWA when
restricted to NWAs with the weak-single entry property. This property failed for the NWAs considered
by Derbarbieux, but can be established in quadratic time by compiling NWAs to SHAs forth and back.

We then observed, unfortunately, that the determinization algorithm for SHAs may still behave badly
when applied to some forward navigational XPath queries, which arise in practice but not in the XPath-
Mark benchmark [16]. A typical killer example is the following XPath query:

(QN7)

/a/b//(* | @* | comment() | text())

It selects all nodes of an XML document that are descendants of a b-element below an a-element at the
root. The nodes may have any XML type: element, attribute, comment, or text. The nondeterministic
SHA has 145 states and an overall size of 348. Its determinization however leads to an automaton with
10.005 states and an overall size of 1.634.122. This size is way too big for many algorithms requiring
deterministic automata.

So one natural question is whether and how the size of deterministic automata can be reduced. One
idea is to apply schema-based cleaning [26] which keeps only those states and transition rules of the
automaton, that are needed to recognize some nested word satisfying the schema. For automata for
XPath queries, we can use a schema onex stating that a single node is selected by any solution, another
schema deﬁning the XML data model. When chosing the intersection of both of them as the schema, the
schema-based cleaning of the deterministic SHA for QN7 indeed has only 74 states and 203 transitions.
When applying SHA minimization [26] afterwards, the size of the automaton goes down to 27 states and
71 transition rules.

So, the schema seems to play a crucial role. Our implementation of schema-based cleaning, however,
runs out of memory for larger automata, say with more than 1000 states. Therefore, we cannot use it to
reduce the sizes of the deterministic SHA obtained from QN7 as announced above. The same holds for
our implementation of SHA minimization.

The question of how to produce small deterministic automaton for general queries that are as simple
as QN7 remains thus open. Given that schemas are relevant, one approach could be to determinize the
product of the automaton for the query with the schema. At a ﬁrst glance, this may look questionable,
given that the schema-product is usually bigger than the original automaton. So why could determiniza-
tion become more efﬁcient? But in the case of QN7, the determinization of the schema-product yields a
deterministic automata with only 92 states and 325 transition rules, and can be computed efﬁciently. That
looks promising. But we also notice that this is slightly bigger than what we announced for schema-based
cleaning. The observations made at that example motivate three general questions.

1. Why are schemas so important for automata determinization?

2. Can this be shown by complexity result for the determinization of the schema-product?

3. Is there an efﬁcient way to compute the schema-based cleaning of the determinization of an au-

tomaton? Clearly, schema-less determinization needs to be avoided.

Our main result is a novel algorithm for schema-based determinization of NFAs and SHAs, that integrates
schema-based cleaning directly into the usual determinization algorithm, rather than applying it a poste-
riori. This algorithm answers question 3 positively. Its idea is to keep only those subsets of states of the
automaton during the determinization, that can be aligned to some state of the schema. In our Theorem
2, we prove that schema-based determinization always produces the same deterministic automaton than
schema-free determinization followed by schema-based cleaning. By schema-based determinization we

Niehren, Sakho, and Al Serhali

3

obtained the schema-based cleaning of the determinization of QN7 in less than three seconds. In contrast,
the schema-based cleaning of the determinization does not terminate after a few hours. In the general
case, the worst case complexity of schema-based determinization is lower than of determinization fol-
lowed by schema-based cleaning. We also provide a more precise complexity upper bound in Proposition
12, showing that the maximal time for computing the schema-based determinization of a SHA is roughly
the square of the number of its states. For NFAs it is the product of the number of states and the size of
the alphabet.

Schema-based determinization also helps to analyze the complexity of the determinization of the
schema-product. Let A be a nondeterministic automaton and det(A) its determinization. Let schema S
be a deterministic automata and A × S the schema-product. We ﬁrst note that det(A × S) = det(A) × S
since S is deterministic.1 We second notice that det(A) × S may be way smaller than det(A). The
reason is that for the many states Q = {q1 . . . qn} of det(A) there may not exist any state s of S such that
(Q, s) ∈ det(A) × S, because this requires all states qi can be aligned to s, i.e. that (qi, s) in A × S for all
1 ≤ i ≤ n. This is why the schema is so relevant for determinization, answering question 1. Third, it
is not difﬁcult to see that the schema-based determinization detS(A) is always smaller than det(A) × S.
Furthermore, det(A) × S is equal to detS(A) × S, so that det(A × S) = detS(A) × S. Hence any size bound
for the schema-based determinization detS(A) implies a size bound for the determinization of the schema-
product. Furthermore, in our experiments detS(A) × S is only by a factor of 2 bigger than detS(A). So
the size of the determinization of the schema-product is closely tied to the size of the schema-based
determinization. This is the answer to question 2.

Outline. In Section 2, we recall the deﬁnition NFAs and discuss how to use them as schemas and queries
on words. In Section 3, we recall schema-based cleaning for NFAs. In Section 4, we contribute our
schema-based determinization algorithm in the case of NFAs and show its correctness. In Section 5, we
recall the notion of SHAs for deﬁning languages of nested words. In Section 6, we lift schema-based
determinization to SHAs. Full proofs are given in the Appendix. It also contains a section on further
related work.

2 Finite Automata on Words, Schemas, and Queries

In this section, we discuss hwo to use NFAs for deﬁning schemas and queries on words.

Let N be the set of natural numbers including 0. The set of words over a ﬁnite alphabet Σ is Σ∗ =
Σn. A word (a1, . . . , an) ∈ Σn is written as a1 . . . an. We denote by ε the empty word, i.e., the unique

∞
(cid:83)
n∈N
element of Σ0 and by w1 · w2 ∈ Σ∗ the concatenation of two words w1, w2 ∈ Σ∗. For example, if Σ = {a, b}
then aa · bb = aabb = a · a · b · b.
Deﬁnition 1. A NFA is a tuple A = (Σ, Q, ∆, I, F) such that Q is a ﬁnite set of states, the alphabet Σ is a
ﬁnite set, I, F ⊆ Q are subsets of initial and ﬁnal states, and ∆ ⊆ Q × Σ × Q is the set of transition rules.
The size of a NFA is |A| = |Q| + |∆|. A transition rule (q, a, q(cid:48)) ∈ ∆ is denoted by q a−→ q(cid:48) ∈ ∆. We

deﬁne transitions q w−→ q(cid:48) wrt ∆ for arbitrary words w ∈ Σ∗ by the following inference rules:

q ∈ Q
q ε−→ q wrt ∆

q a−→ q(cid:48) ∈ ∆
q a−→ q(cid:48) wrt ∆

q0

w1−→ q1 wrt ∆
q0

w1·w2−−−→ q2 wrt ∆

q1

w2−→ q2 wrt ∆

The language of words recognized by a NFA then is L (A) = {w ∈ Σ∗ | q w−→ q(cid:48) wrt ∆, q ∈ I, q(cid:48) ∈ F}.

1If {(q1, s1) . . . (qn, sn)} ∈ det(A × S) then there exists a tree that can go into all states q1 . . . qn with A and into all states
s1, . . . sn with S. Since S is deterministic, we have s1 = . . . sn. So there exists a tree going into {q1, . . . , qn} with det(A) and also
into all si. So ({q1, . . . , qn}, si) is a state of det(A) × S.

4

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

Schema-Based Determinization

IA (cid:54)= /0

Q ∈ Qdet(A) Q ∩ FA (cid:54)= /0
Q ∈ Fdet(A)

IA ∈ Qdet(A)
Q(cid:48) = {q(cid:48) ∈ QA | q a−→ q(cid:48) ∈ ∆A, q ∈ Q} (cid:54)= /0

IA ∈ Idet(A)

Q ∈ Qdet(A)

Q a−→ Q(cid:48) ∈ ∆det(A)

Q(cid:48) ∈ Qdet(A)

det(A) = (Σ, Qdet(A), ∆det(A), Idet(A), F det(A))

Figure 1: The accessible determinization det(A) of NFA A.

fun d e t ( A ) =

initA (cid:54)= /0 then Agenda.add(initA)

l e t Store = hashset.new( /0)
l e t Agenda = list.new() and Rules = hashset.new( /0)
i f
w h i l e Agenda.notEmpty() do
l e t Q = Agenda.pop()
l e t h be an empty h a s h t a b l e w i t h k e y s

from Σ .

/ /

t h e

v a l u e s w i l l be n o n e m p t y h a s h s u b s e t s o f QA

f o r q a−→ q(cid:48) ∈ ∆A such t h a t q ∈ Q do

i f h.get(a) = unde f
(h.get(a)).add(q(cid:48))

then h.add(a, hashset.new( /0))

f o r (a, Q(cid:48)) i n h.tolist() do Rules.add(Q a−→ Q(cid:48))

i f not Store.member(Q(cid:48)) then Store.add(Q(cid:48)) Agenda.push(Q(cid:48))

l e t initdet(A) = {Q | Q ∈ Store, Q ∩ initA (cid:54)= /0} and F det(A) = {Q | Q ∈ Store, Q ∩ F A (cid:54)= /0}
r e t u r n (Σ, Store.toSet(), Rules.toSet(), initdet(A), F det(A))

Figure 2: A program computing the accessible determinization of an NFA A from Fig. 1.

A NFA A is called deterministic or equivalently a DFA, if it has at most one initial state, and for
every pair (q, a) ∈ Q × Σ there is at most one state q(cid:48) ∈ QA such that q a−→ q(cid:48) ∈ ∆A. Any NFA A can be
converted into a DFA that recognizes the same language by the usual subset construction. The accessible
determinization det(A) of A = (Σ, QA, ∆A, IA, F A) is deﬁned by the inference rules in Fig. 1. It works
It is well known
like the usual subset construction, except that only accessible subsets are created.
that L (A) = L (det(A)). Since only accessible subsets of states are added, we have Qdet(A) ⊆ 2QA
.
Therefore, the accessible determinization may even reduce the size of the automaton and often avoid the
exponential worst case where Qdet(A) = 2QA

.

Proposition 2. The accessible determinization det(A) of a NFA A can be computed in expected amortized
time O(|Qdet(A)| |∆A| + |A|).

Proof. An algorithm computing the ﬁxed point of the inference rules for accessible determinization in
Fig. 1 is presented in Fig. 2. It uses dynamic perfect hashing [13] for implementing hash sets, so that
set inserting and membership can be done in randomized amortized time O(1). The algorithm has a
hash set Store to save all discovered states Qdet(A) and a hash set Rules to collect all transition rules.
Furthermore, it has a stack Agenda to process all new states Q ∈ Qdet(A). For each Q popped from the
stack Agenda, the algorithm uses a hash table h to compute all pairs (a, Q(cid:48)) such that Q a−→ Q(cid:48) ∈ ∆det(A)
and Q(cid:48) (cid:54)= /0. This is done by iterating of ∆A so in time O(|∆A|). By iterating over the hash table h, all
transitions Q a−→ Q(cid:48) will be added to the set Rules and Q(cid:48) will be added to the stack Agenda and to the
hash set Store if it wasn’t there yet. The overall number of elements in the Agenda is |Qdet(A)|. For each

Niehren, Sakho, and Al Serhali

5

Figure 3: The NFA A0 for the regular expression
(x + ε).(x.a)∗

4:

The

Figure
tion det(A0) up to the renaming of
[{2, 4}/0,{2, 3}/1,{2}/2, {3}/3].

accessible

determiniza-
states

Figure 5: The schema-based cleaning of det(A0)
with schema words-onex
Σ.

Figure 6: Schema words-onex
bet Σ (cid:93) {x}.

Σ with alpha-

Q, the computation of all Q(cid:48) is in time O(|∆A|). The preprocessing of A requires time O(|A|). Thus, the
total time of the algorithm is in O(|Qdet(A)| |∆A| + |A|).

As a running example, we consider the NFA A0 for the regular expression (x + ε).(x.a)∗ that is drawn
as a labeled digraph in Fig. 3: the nodes of the graph are the states and the labeled edges represent the
transitions rules. The initial states are indicated by an ingoing arrow and the ﬁnal state are doubly circled.
The graph of the DFA det(A0) obtained by accessible determinization is shown in Fig. 4. It is given up
to a renaming of the states that is given in the caption. Note that only 4 out of the 23 = 8 subsets are
accessible, so the size increases only by a single state and two transitions rules in this example.

A regular schema over Σ is a DFA with the alphabet Σ. We next show how to use automata to deﬁne

regular queries on words. For this, any word is seen
as a labeled digraph. The labeled digraph of the
word aab, for instance, is drawn to the right. The
set of nodes of the graph is the set of positions of the word pos(w) = {0, . . . , n} where n is the length of
w. Position 0 is labeled by start, while all other positions are labeled by a single letter in Σ. A monadic
query function on words with alphabet Σ is a total function Q that maps some words w ∈ Σ∗ to a subset
of position Q(w) ⊆ pos(w). We say that a position π ∈ pos(w) is selected by Q if w ∈ dom(Q) and
π ∈ Q(w).

Let us ﬁx a single variable x. Given a position π of a word w ∈ Σ∗ let w ∗ [π/x] be the word obtained
from w by inserting x after position π. We note that all words of the form w ∗ [π/x] contain a single
occurrence of x. Such words are also called V -structures where V = {x} (see e.g [29]).

The set of all V -structures can be deﬁned by the schema words-onex

Σ over Σ (cid:93) {x} in Fig. 6. It is
natural to identify any total monadic query function Q with the language of V -structures LQ = {w∗[π/x] |
w ∈ Σ∗, π ∈ Q(w)}. This view permits us to deﬁne a subclass of total monadic query functions by
automata.

A (monadic) query automaton over Σ is a NFA A with alphabet Σ (cid:93) {x}. It deﬁnes the unique total
Σ). A position π of a word w ∈ Σ∗ is

monadic query function Q such that LQ = L (A) ∩ L (words-onex
thus selected by the query Q on w if and only if the V -structure w ∗ [π/x] is recognized by A, i.e.:

π ∈ Q(w) ⇔ w ∗ [π/x] ∈ L (A)

A query function is called regular if it can be deﬁned by some NFA. It is well-known from the work
of B¨uchi in the sixties [9] that the same class of regular query functions can be deﬁned equivalently by
monadic second-order logic.

6

Schema-Based Determinization

q ∈ IA

(q, s) ∈ IA×S

s ∈ IS
(q, s) ∈ QA×S

q ∈ F A

(q, s) ∈ QA×S

s ∈ F S
(q, s) ∈ F A×S

a−→ s2 ∈ ∆S
a−→ q2 ∈ ∆A
q1
(q1, s1) a−→ (q2, s2) ∈ ∆A×S

s1

(q1, s1) ∈ QA×S

(q2, s2) ∈ QA×S

Figure 7: Accessible product A × S = (Σ, QA×S, IA×S, F A×S, ∆A×S).

We note that only the words satisfying the schema words-onex

Σ (the V -structures) are relevant for the
query function Q of a query automaton A. The query automaton A0 in Fig. 3 for instance, deﬁnes the
query function that selects the start position of the words ε and a and no other positions elsewhere. This
is since the subset of V -structures recognized by A0 is x + x.a. Note that the words ε and xxa do also
belong to L (A0), but are not V -structures, and thus are irrelevant for the query function Q.

3 Schema-Based Cleaning

Schema-based cleaning was introduced only recently [26] in order to reduce the size of automata on
nested words. The idea is to remove all rules and states from an automaton that are not used to recognize
any word satisfying the schema. Schema-based cleaning can be based on the accessible states of the
product of the automaton with the schema. While this product may be larger than the automaton, the
schema-based cleaning will always be smaller.

For illustration, the schema-based cleaning of NFA det(A0) in Fig. 4 with respect to schema words-onex
Σ
is given in Fig. 5. The only words recognized by both det(A0) and words-onex
Σ are x and xa. For rec-
ognizing these two words, the automaton det(A0) does not need states 2 and 3, so they can be removed
with all their transitions rules. Thereby, the word xxa violating the schema is no more recognized after
schema-based cleaning, while it was recognized by det(A0). Furthermore, note that the state 0 needs
no more to be ﬁnal after schema-based cleaning. Therefore the word ε, which is recognized by the au-
tomaton but not by the schema, is no more recognized after schema-based cleaning. So schema-based
cleaning may change the language of the automaton but only outside of the schema.
Interestingly, the NFA A0 in Fig. 3 is schema-clean for schema words-onex

Σ too, even though it is not
perfect, in that recognizes the words ε and xxa which are rejected by the schema. The reason is that for
recognizing the words x and xa, which both satisfy the schema, all 3 states and all 4 transition rules of
A0 are needed. In contrast, we already noticed that the accessible determinization det(A0) in Fig. 4 is not
schema-clean for schema words-onex
Σ. This illustrates that accessible determinization does not always
preserve schema-cleanliness. In other words, schema-based cleaning may have a stronger cleaning effect
after determinization than before.

The schema-based cleaning of an automaton can be deﬁned based on the accessible product of the
automaton with the schema. The accessible product A × S of two NFAs A and S with alphabet Σ is
deﬁned in Fig. 7. This is the usual product, except that only accessible states are admitted. Clearly,
L (A × S) = L (A) ∩ L (S). Let ΠA(A × S) be obtained from the accessible product by projecting away
the second component, as formally deﬁned in Fig. 19. The schema-based cleaning of A with respect to
schema S is this projection.

Deﬁnition 3. sclS(A) = ΠA(A × S).

The fact that A × S is restricted to accessible states matches our intuition that all states of sclS(A)
can be used to read some word in L (A) that satisﬁes schema S. This can be proven formally under the

Niehren, Sakho, and Al Serhali

7

is
Figure 8: A DFA that
schema-clean but not perfect
for words-onex
Σ.

The

accessible
Figure 9:
product with words-onex
Σ is
schema-clean and perfect for
words-onex
Σ.

Figure 10:
with alphabet Σ (cid:93) {x, ¬x}.

The dSHA onex
Σ

condition that all states of A × S are also co-accessible. Clearly, sclS(A) is obtained from A by removing
states, initial states, ﬁnal states, and transitions rules. So it is smaller or equal in size |sclS(A)| ≤ |A| and
language L (sclS(A)) ⊆ L (A). Still, schema-based cleaning preserves the part of the language within
the schema:
Proposition 4. L (A) ∩ L (S) = L (sclS(A)) ∩ L (S).

Schema-clean deterministic automata may still not be perfect, in that schema-clean DFAs may rec-
ognize some words outside the schema. This happens if some state of a DFA is reached both, by a word
satisfying the schema and another word that does not satisfy the schema. An example for a DFA that
is schema-clean but not perfect for words-onex
Σ is given in Fig. 8. It is not perfect since it accepts the
non V -structure xaxa. The problem is that state 1 can be reached by the words a and xa, so one cannot
infer from being in state 1 whether some x was read or not. If one wants to avoid this, one can use the
accessible product of the DFA with the schema instead. In the example, this yields the DFA in Fig. 9 that
is schema-clean and perfect for words-onex
Σ.
Proposition 5. For any DFAs A and S with alphabet Σ the accessible product A×S and the schema-based
cleaning sclS(A) can be computed in expected amortized time O(|QA×S||Σ| + |A| + |S|).

Proof. It is sufﬁcient to show that the accessible product A × S can be computed in this time. An algo-
rithm to compute the ﬁxed points of the inference rules for the accessible product A × S in Fig. 7 can
be organized such that only accessible states are considered (similarly to semi-naive datalog evaluation).
This algorithm is presented in Fig. 11. It dynamically generates the set of rules Rules by using perfect
dynamic hashing [13]. Testing set membership is in time O(1) and the addition of elements to the set
is in expected amortized time O(1). The algorithm uses a stack, Agenda, to memoize all new pairs
(q1, s1) ∈ QA×S that need to be processed, and a hash set Store that saves all processed states QA×S.
We aim not to push the same pair more than once in the Agenda. For this, membership to the Store is
checked before an element is pushed to the Agenda. For each pair popped from the stack Agenda, the
a−→ q2 ∈ ∆A} and
algorithm does the following: for each letter a ∈ Σ it computes the sets Q = {q2 | q1
a−→ s2 ∈ ∆S} and then adds the subset of states of Q × R that were not stored in the hash
R = {s2 | s1
set Store to the agenda. Since A and S are deterministic, there is at most one such pair, so the time for
treating one pair on the agenda is in expected amortized time O(|Σ|). The overall number of elements in
the agenda will be |QA×S|. Note that Q and R can be computed in O(1) after preprocessing A and S in
time O(|A| + |S|). Therefore, we will have a total time of the algorithm in O(|QA×S||Σ| + |A| + |S|).

4 Schema-Based Determinization

Schema-based cleaning after determinization becomes impossible in practice if the automaton obtained
by determinization is too big. We therefore show next how to integrate schema-based cleaning into
automata determinization directly.

8

1

2

3

4

5

6

7

8

9

10

11

12

13

14

Schema-Based Determinization

fun A × S =

initA = {q0} and initS = {s0} then Agenda.add((q0, s0))

l e t Store = hashset.new( /0)
l e t Agenda = list.new() and Rules = hashset.new( /0)
i f
w h i l e Agenda.notEmpty() do
l e t (q1, s1) = Agenda.pop()
f o r a ∈ Σ do

a−→ q2 ∈ ∆A} R = {s2 | s1

a−→ s2 ∈ ∆S}

l e t Q = {q2 | q1
f o r q2 ∈ Q and s2 ∈ R do

Rules.add((q1, s1) a−→ (q2, s2))
i f not Store.member((q2, s2))

then Store.add((q2, s2)) Agenda.push((q2, s2))

l e t initA×S = {(q0, s0) | (q0, s0) ∈ Store} and F A×S = {(q, s) | (q, s) ∈ Store, q ∈ F A, s ∈ F S}
r e t u r n (Σ, Store.toSet(), Rules.toSet(), initA×S, F A×S)

Figure 11: An algorithm computing the accessible product of DFAs A and S.

IS = {s}
Q ∈ Idet(A)
Q ∈ IdetS(A) Q ∼ s

Q ∼ s
Q ∈ QdetS(A)

Q ∈ Fdet(A)

s ∈ FS
Q ∈ FdetS(A)

Q ∼ s

Q a−→ Q(cid:48) ∈ ∆det(A)

Q ∼ s

s a−→ s(cid:48) ∈ ∆S

Q a−→ Q(cid:48) ∈ ∆detS(A)

Q(cid:48) ∼ s(cid:48)

Figure 12: Schema-based determ. detS(A) = (Σ, QdetS(A), ∆detS(A), IdetS(A), F detS(A)).

The schema-based determinization of A with respect to schema S extends on accessible determiniza-
tion det(A). The idea is to run the schema S in parallel with det(A), in order to keep only those state
Q ∈ Qdet(A) that can be aligned to some state s ∈ QS. In this case we write Q ∼ s.

The schema-determinization detS(A) is deﬁned in Fig. 12. The automaton detS(A) permits to go from
any subset Q ∈ Qdet(A) and letter a ∈ Σ to the set of states Q(cid:48) = a∆det(A)(Q), under the condition that there
exists schema states s, s(cid:48) ∈ QS such that Q ∼ s and s a−→ s(cid:48). In this case Q(cid:48) ∼ s(cid:48) is inferred.
Theorem 1 (Correctness). detS(A) = sclS(det(A)) for any NFA A and DFA S with the same alphabet.

The theorem states that schema-based determinization yields the same result as accessible deter-

minization followed by schema-based cleaning.

For preparing the correctness proof we ﬁrst collapse the two systems of inference rules for accessible
products and projection into a single rule system. This yields the rule systems for schema-based cleaning
in Fig. 20.

The rules there deﬁne the automaton (cid:99)sclS(A), that we annotate with a hat, in order to distinguish it
from the previous automaton sclS(A). The rules also infer judgements (q, s) ∈ QA (cid:98)×S that we distinguish
by a hat from the previous judgments (q, s) ∈ QA×S of the accessible product. The next proposition
shows that the system of collapsed inference rules indeed redeﬁnes the schema-based cleaning.

Proposition 6. For any two NFAs A and S with the same alphabet:

sclS(A) = (cid:99)sclS(A)

and QA×S = QA (cid:98)×S

Proof of Correctness Theorem 1. Instantiating the system of collapsed rules for schema-based cleaning
from Fig. 20 with det(A) for A yields the rule system in Fig. 21. We can identify the instantiated collapsed

Niehren, Sakho, and Al Serhali

9

1

2

3

4

5

6

7

8

9

10

11

12

13

fun d e t S ( A , S ) =

l e t Store = hashset.new( /0)
l e t Agenda = list.new() and Rules = hashset.new( /0)
i f
w h i l e Agenda.notEmpty() do

initA (cid:54)= /0 and initS = {s0} then Agenda.add(initA ∼ s0)

l e t (Q1 ∼ s1) = Agenda.pop()
f o r a ∈ Σ do

l e t P = {Q2 | Q1
f o r Q2 ∈ P and s2 ∈ R do Rules.add(Q1

a−→ Q2 ∈ ∆det(A)} and R = {s2 | s1
a−→ Q2)

a−→ s2 ∈ ∆S}

i f not Store.member(Q2 ∼ s2)
then Store.add(Q2 ∼ s2) Agenda.push(Q2 ∼ s2)

l e t initdetS(A) = {Q | Q ∼ s ∈ Store, Q ∩ initA (cid:54)= /0} and F detS(A) = {Q | Q ∼ s ∈ Store, Q ∩ F A (cid:54)= /0}
r e t u r n (Σ, Store.toSet(), Rules.toSet(), initdetS(A), F detS(A))

Figure 13: An algorithm for schema-based determinization detS(A) of an NFA A and a DFA schema S.

system for (cid:99)sclS(det(A)) with that for detS(A) in Fig. 12, by identifying the judgements (Q, s) ∈ Qdet(A) (cid:98)×S
with judgments Q ∼ s. After renaming the predicates, the inference rules for the corresponding judgments
are the same. Hence (cid:99)sclS(det(A)) = detS(A), so that Proposition 6 implies sclS(det(A)) = detS(A).

Proposition 7. The schema-based determinization detS(A) for a NFA A and a DFA S over Σ can be
computed in expected amortized time O(|Qdet(A)×S||Σ| + |QdetS(A)||∆A| + |A| + |S|).

Proof. An algorithm computing the ﬁxed points of the inference rules of schema-based determinization
from Fig. 12 is given in Fig. 13. It reﬁnes the algorithm computing the accessible product with on-the-ﬂy
determinization and projection.

a−→ Q2 ∈ ∆det(A)} and P = {s2 | s1

On the stack Agenda, the algorithm stores alignments Q ∼ s such that (Q, s) ∈ Qdet(A)×S that were not
considered before. Transition rules of detS(A) are collected in hash set Rules, using the dynamic perfect
hashing aforementioned. The alignments Q1 ∼ s1 popped from the agenda are processed as follows: For
a−→ s2 ∈ ∆S} are computed. One
any letter a ∈ Σ, the sets R = {Q2 | Q1
a−→ Q2 to the set
then pushes all new pairs Q2 ∼ s2 with Q2 ∈ P and s2 ∈ R into the agenda, and adds Q1
Rules. Since S and det(A) are deterministic there is at most one pair (Q, s) ∈ P × R for Q1 and s1. So
the time for treating one pair on the agenda is in O(|Σ|) plus the time for building the needed transition
rules of det(A) from ∆A on the ﬂy. The time for the on the ﬂy computation of transition rules of det(A) is
in time O(|QdetS(A)||∆A|). The overall number of pairs on the agenda is at most |Qdet(A)×S| so the main
while loop of the algorithm requires time in O(|Qdet(A)×S||Σ|) apart from on the ﬂy determinization. This
will give us an overall complexity for the algorithm in O(|Qdet(A)×S||Σ| + |QdetS(A)||∆A| + |A| + |S|), with
consideration of the preprocessing time of A and S.

By Proposition 2, computing det(A) requires time O(|Qdet(A)| |∆A| + |A|). Therefore, with Propo-
sition 5, the accessible product det(A) × S can be computed from A and S in time O(|Qdet(A)×S||Σ| +
|Qdet(A)| |∆A|+|A|+|S|). Since QdetS(A) ⊆ Qdet(A) the proposition shows that schema-based determiniza-
tion is at most as efﬁcient in the worst case as accessible determinization followed by schema-based
cleaning. If |Qdet(A)×S||Σ| < |Qdet(A)||∆A| then it is more efﬁcient, since schema-based determinization
avoids the computation of det(A) all over. Instead, it only computes the accessible product det(A) × S,
which may be considerably smaller, since exponentially many states of det(A) may not be aligned to
any state of S. Sometimes, however, the accessible product may be bigger. In this case, schema-based
determinization may be more costly than pure accessible determinization, not followed by schema-based
cleaning.

10

Schema-Based Determinization

5 Stepwise Hedge Automata for Nested Words

We next recall SHAs [26] for deﬁning languages of nested words, regular schemas and queries. Nested
words generalize on words by adding parenthesis that must be well-nested. While containing words
natively, they also generalize on unranked trees, and hedges. We restrict ourselves to nested words with
a single pair of opening and closing parenthesis (cid:104) and (cid:105). Nested words over a ﬁnite alphabet Σ of internal
letters have the following abstract syntax.

w, w(cid:48) ∈ NΣ

::= ε | a | (cid:104)w(cid:105) | w · w(cid:48)

where a ∈ Σ

a

c

(cid:104)(cid:105)

(cid:104)(cid:105)

(cid:104)(cid:105)

We assume that concatenation · is associative and that the empty word ε is a
neutral element, that is w · (w(cid:48) · w(cid:48)(cid:48)) = (w · w(cid:48)) · w(cid:48)(cid:48) and ε · w = w = w · ε. Nested
words can be identiﬁed with hedges, i.e., words of unranked trees and letters
from Σ. Seen as a graph, the inner nodes are labeled by the tree constructor
(cid:104)(cid:105) and the leafs by symbols in Σ or the tree constructor. For instance (cid:104)a · (cid:104)b(cid:105) ·
ε(cid:105) · c · (cid:104)d · (cid:104)ε(cid:105)(cid:105) corresponds to the hedge on the right.
A nested word of type tree has the form (cid:104)h(cid:105). Note that dangling parentheses are ruled out and that
labeled parentheses can be simulated by using internal letters. XML documents are labeled unranked
trees, for instance: (cid:104)a name = “u f f ”(cid:105)(cid:104)b(cid:105)isgaga(cid:104)d/(cid:105)(cid:104)/b(cid:105)(cid:104)c/(cid:105)(cid:104)/a(cid:105). Labeled unranked trees satisfying the
XML data model can be represented as nested words over an alphabet that contains the XML node-types
(elem, attr,text, . . .), the XML names of the document (a, . . . , d, name), and the characters of the data
values, say UTF8. For the above example, we get the nested word (cid:104)elem · a · (cid:104)attr · name · u · f · f (cid:105)(cid:104)elem ·
b · (cid:104)text · i · s · g · a · g · a(cid:105)(cid:104)elem · d(cid:105)(cid:105)(cid:104)elem · c(cid:105)(cid:105)
Deﬁnition 8. A SHA is a tuple A = (Σ, Q, ∆, I, F) where ∆ = (∆(cid:48), @∆, (cid:104)(cid:105)∆) such that (Σ, Q, ∆(cid:48), I, F) is a
NFA, (cid:104)(cid:105)∆ ⊆ Q is a set of tree initial states and @∆ ⊆ Q3 a set of apply rules.

(cid:104)(cid:105)

b

d

SHAs can be drawn as graphs while extending on the graphs of NFAs. A tree initial state q ∈ (cid:104)(cid:105)∆ is
(cid:104)(cid:105)
−→ q with an incoming tree arrow. An applyrule (q1, q, q2) ∈ @∆ is drawn as a blue
drawn as a node
q
−→ q2 that is labeled by a state q ∈ Q rather than a letter a ∈ Σ. It states that a nested word in

edge q1
state q1 can be extended by a tree in state q and become a nested word in state q2.

For instance, the SHA onex

Σ is drawn graphically in Fig. 10. It accepts all nested words over Σ (cid:93)
Σ(cid:93){¬x} from
Σ for reading

Fig. 6, the SHA onex
the states assigned to subtrees. The state 0 is chosen as the single tree initial state.

{x, ¬x} that contain exactly one occurrence of letter x. Compared to the NFA words-onex
Σ contains three additional apply rules (0, 0, 0), (0, 1, 1), (1, 0, 1) ∈ @∆onex
Transitions for NFAs on words can be lifted to transitions for SHAs of the form q w−→ q(cid:48) wrt ∆ where
w ∈ NΣ and q, q(cid:48) ∈ Q. For this, we add the following inference rule to the previous inference rules for
NFAs:

q(cid:48) w−→ q wrt ∆
(cid:104)w(cid:105)
−−→ q2 wrt ∆
The rule says that a tree (cid:104)w(cid:105) can transit from a state q1 to a state q2 if there is an apply rule (q1, q, q2) ∈ @∆
so that w can transit from some tree initial state q(cid:48) ∈ (cid:104)(cid:105)∆ to q. Otherwise, the language L (A) of nested
words accepted by a SHA A is deﬁned as in the case of NFAs.
Deﬁnition 9. A SHA (Σ, Q, ∆, I, F) is deterministic or equivalently a dSHA, if it satisﬁes the following
conditions:

(q1, q, q2) ∈ @∆

q(cid:48) ∈ (cid:104)(cid:105)∆

q1

• I and (cid:104)(cid:105)∆ both contain at most one element,
• a∆ is a partial function from Q to Q for all a ∈ Σ, and

Niehren, Sakho, and Al Serhali

11

(cid:104)(cid:105)∆A
(cid:54)= /0
∈ Qdet(A)

(cid:104)(cid:105)∆A

Q1 ∈ Qdet(A)

Q2 ∈ Qdet(A)

Q(cid:48) = {q(cid:48) ∈ QA | q1@q2 → q(cid:48) ∈ ∆A, q1 ∈ Q1, q2 ∈ Q2} (cid:54)= /0

Q1@Q2 → Q(cid:48) ∈ ∆det(A)

Q(cid:48) ∈ Qdet(A)

Figure 14: Accessible determinization det(A) lifted from NFAs to SHAs.

Figure 15: A onex

Σ-cleaned minimal dSHA for the XPATH query QN7.

• @∆ is a partial function from Q × Q to Q.
Note that if A is a dSHA and ∆ = (∆(cid:48), @∆, (cid:104)(cid:105)∆) then A(cid:48) = (Σ, Q, ∆(cid:48), I, F) is a DFA. Conversely any
Σ in Fig. 10 contains the DFA

DFA A(cid:48) deﬁnes a dSHA with @∆ = /0 and I = /0. For instance, the SHA onex
words-onex

Σ(cid:93){¬x} from Fig. 6 with Σ instantiated by Σ (cid:93) {x}.

A schema for nested words over Σ is a dSHA over Σ. Note that schemas for nested words generalize
over schemas of words, since dSHAs generalize on DFAs. The rules for the accessible determinization
det(A) of a SHA A in Fig. 14 extend on those for NFAs in Fig. 1. As for words, det(A) is always
determinstic, recognizes the same language as A, and contains only accessible states. The complexity of
accessible determinization in case of SHA go similarly to DFA, however, the apply rules will introduce
quadratic factor in the number of states.
Proposition 10. The accessible determinization of a SHA can be computed in expected amortized time
O(|Qdet(A)|2 |∆A| + |A|).

The notions of monadic query functions Q can be lifted from words to nested words, so that it selects
nodes of the graph of a nested word. For this, we have to ﬁx one of manner possible manners to deﬁne
identiﬁers for these nodes. The set of nodes of a nested word w is denoted by nod(w) ⊆ N.

For indicating the selection of node π ∈ nod(w), we insert the variable x into the sequence of letters
following the opening parenthesis of π. If we don’t want to select π, we insert the letter ¬x instead. For
any nested word w with alphabet Σ, the nested word w[π/x] obtained by insertion of x or ¬x at a node
π ∈ nod(w) has alphabet Σ (cid:93) {x, ¬x}. As before, we deﬁne LQ = {w ∗ [π/x] | w ∈ NΣ, π ∈ Q(w)}.

12

Schema-Based Determinization

q ∈ (cid:104)(cid:105)∆A
(q, s) ∈ (cid:104)(cid:105)∆A×S

s ∈ (cid:104)(cid:105)∆S
(q, s) ∈ QA×S

(q1, s1) ∈ QA×S
(q, s) ∈ QA×S

q1@q → q2 ∈ ∆A
s1@s → s2 ∈ ∆S

(q1, s1)@(q, s) → (q2, s2) ∈ ∆A×S

(q2, s2) ∈ QA×S

Figure 16: Lifting accessible products to SHAs.

= {s}

(cid:104)(cid:105)∆S
∈ (cid:104)(cid:105)∆detS(A)

(cid:104)(cid:105)∆A

s1@s2 → s(cid:48) ∈ ∆S

Q1 ∼ s1

Q2 ∼ s2

Q1@Q2 → Q(cid:48) ∈ ∆det(A)

(cid:104)(cid:105)∆A

∼ s

Q1@Q2 → Q(cid:48) ∈ ∆detS(A)

Q(cid:48) ∼ s(cid:48)

Figure 17: Extension of schema-based determinization to SHAs.

The notion of a query automata can now be lifted from words to nested words straightforwardly: a
query automaton for nested words over Σ is a SHA A with alphabet Σ ∪ {x, ¬x}. It deﬁnes the unique
total query Q such that LQ = L (A) ∩ L (onex
Σ). A deterministic query automaton for the XPATH QN7 on
XML documents is given in Fig. 15.

6 Schema-Based Determinization for SHAs

We can lift all previous algorithms from NFAs to SHAs while extending the system of inference rules.
The additional rules concern tree initial states, that work in analogy to initial states, and also apply rules
that works similarly as internal rules. The new inference rules for accessible products A × S are given in
Fig. 16 and for projection ΠA(A × S) in Fig. 23. As before we deﬁne sclS(A) = ΠA(A × S). The rules
for schema-based determinization detS(A) are extended in Fig. 17. The next complexity upper bound,
however, now become quadratic with ﬁxed alphabet:
Proposition 11. If A and S are dSHAs then the accessible product A × S and the schema-based cleaning
sclS(A) can be computed in expected amortized time O(|QA×S|2 + |QA×S||Σ| + |A| + |S|).
Theorem 2 (Correctness). detS(A) = sclS(det(A)). for any SHA A and dSHA S with the same alphabet.

The proof extends on that for NFAs (Theorem 1) in a direct manner.

Proposition 12. The schema-based determinization detS(A) of a SHA A with respect to a dSHA S can
be computed in expected amortized time O(|Qdet(A)×S|2 + |Qdet(A)×S| |Σ| + |QdetS(A)|2 |∆A| + |A| + |S|).
This proposition follows the result in Proposition 7 with an additional quadratic factor in the size
of states of the product det(A) × S and the states of the schema-based determinized automaton. This is
always due to the apply rules of type Q3.

By Propositions 10 and 11, computing sclS(det(A)) by schema-based cleaning after accessible deter-
minization needs time in O(|Qdet(A)×S|2 + |Qdet(A)×S| |Σ| + |Qdet(A)|2 |∆A| + |A| + |S|). This complexity
bound is similar to that of schema-based determinization from Proposition 12. Since QdetS(A) ⊆ Qdet(A),
Proposition 12 shows that the worst case time complexity of schema-based determinization is never
worse than for schema-based cleaning after determinization.

7 Experiments

For studying the relevance of schemas in automata determinization experimentally we compare deter-
minization, schema-based determinization and the determinization of the schema-product for a scalable
collection of SHAs.

Niehren, Sakho, and Al Serhali

A

det(A)

det(A × S)

detS(A)

Q1.1
Q1.2
Q1.3
Q1.4
Q2.1
Q2.2
Q2.3
Q2.4
Q3.1
Q3.2
Q3.3
Q3.4

124 (51)
150 (61)
176 (71)
202 (81)
161 (65)
194 (77)
227 (89)
260 (101)
198 (79)
238 (93)
278 (107)
318 (121)

582 (52)
1532 (106)
4118 (230)
10950 (514)
1348 (99)
3579 (211)
9488 (467)
24691 (1047)
3246 (202)
8598 (444)
22422 (992)
57196 (2220)

441 (74)
1240 (134)
3529 (270)
9824 (582)
526 (86)
1468 (158)
4148 (322)
11470 (698)
611 (98)
1696 (182)
4767 (374)
13116 (814)

211 (40)
627 (80)
1859 (172)
5299 (384)
278 (51)
822 (103)
2414 (223)
6814 (499)
345 (62)
1017 (126)
2969 (274)
8329 (614)

sclS(
det(A))
211 (40)
627 (80)
1859 (172)

278 (51)
822 (103)

345 (62)

mini(
det(A × S))
153 (41)
155 (41)
157 (41)
159 (41)
155 (41)
157 (41)
159 (41)
161 (41)
157 (41)
159 (41)
161 (41)
163 (41)

Figure 18: Automata statistics: size(#states)

13

mini(
detS(A))
67 (19)
69 (19)
71 (19)
73 (19)
69 (19)
71 (19)
73 (19)
75 (19)
71 (19)
73 (19)
75 (19)
77 (19)

In order to obtain scalable SHAs whose determinizations are too big to be schema-cleaned or mini-

mized, we start from the following XPATH queries:

(Qn.m)

//*[self::a0 or ... or self::an]
[descendant::*[self::b0 or ... or self::bm]]

where n ∈ {1, . . . , 3} and m ∈ {1, . . . , 4}. Query Qn.m selects all elements of an XML document, that are
named by either of a0, . . ., an and have some descendant element named by either of b1, . . ., bm. We
compile those XPATH queries to SHAs based on the compiler from [26]. We note that these SHAs may
also have typed else rules. As schema S we chose the product of onex with a dSHA for the XML data
model (see Fig. 28 of the appendix).

All the experiments are conducted on a Dell laptop with the following specs: Intel® Core™ i7-
10875H CPU @ 2.30 GHz,16 cores, and 32 GB of RAM. The statistics on the sizes and number of states
of the various automata computed for these queries are presented in Table 18.

The SHA A in the ﬁrst column is the automaton obtained from query Qn.m by the compiler from
[26]. The dSHA det(A) in the second column is obtained from A by accessible determinization. We
notice that all SHAs Qn.m could be determinized within our timeout of 1000 seconds. The column
sclS(det(A)) contains the schema-based cleaning of det(A) if it could be computed within the timeout of
1000 seconds. Otherwise the ﬁeld is left blank, which is the case for 6 out of the 12 queries where the
size of det(A) is too big.

In contrast, we can compute the determinization of the schema-product det(A × S) and the schema-
based determinization detS(A) in all cases in less than 100 seconds. For instance, the highest computation
time is for Q3.4 where detS(AQ3.4) took around 31 seconds, and det(AQ3.4 × S) needed 74 seconds.

14

Schema-Based Determinization

This shows that the schema is indeed essential for determinization of these automata. Furthermore,
the automata obtained by schema-based determinization are always smaller than those obtained by de-
terminizing the schema product.

We notice that the schema-based determinization detS(A) is always equal to schema-based clean-
ing of the accessible determinization sclS(det(A)), if both could be computed within the timeout. This
conﬁrms Theorem 2 on the correctness of schema-based determinization. Note that this theorem is not
directly applicable since we are using a slightly enriched SHA model in our experiments.

Finally, we minimized all det(A × S) and detS(A). It turns out, that all mini(det(A × S)) have 41
states, while all mini(detS(A)) have 19 states (see Fig. 29 and Fig. 30 of the appendix for Q3.4). Only the
number of transition rules grows with n and m. We notice that they are neither equal nor equivalent, since
they recognize different languages outside schema S. But in any case, schema-based determinization
produces smaller dSHAs even after minimization.

Conclusion and Future Work. We presented an algorithm for schema-based determinization for NFAs
and SHAs and proved it to produce the same results as determinization followed by schema-based clean-
ing but with lower worst case complexity. This complexity result also gave us a bound on the size
of the standard determinization of the query-schema product. We started with an example of an SHA
for a regular XPATH query to lay out the risen problems, and for which schema-based determinization
produces a dSHA of size < 300, while schema-free determinization produces an dSHA of size > 1.5
million and provided a scalable experiment denoting the performance of each approach and the size of
their resulting automata. In a subsequent paper [1], we successfully applied our schema-based deter-
minization algorithm on a practical benchmark of forward navigational XPATH queries [22], that Lick
and Schmitz extracted from practical XSLT and XQuery programs. The results of our benchmark were
highly promising and raises hope of providing the needed deterministic tools for many algorithms such
as query answering and enumeration. An open line would be to improve the complexity and ﬁnd an
algorithm relying only on the transition set and therefore, possibly get rid of the quadratic factor in states
and alphabet.

Niehren, Sakho, and Al Serhali

15

References

[1] Antonio Al Serhali & Joachim Niehren (2022): A Benchmark Collection of Deterministic Automata for XPath

Queries. Available at https://hal.inria.fr/hal-03527888. Technical report.

[2] Rajeev Alur (2007): Marrying Words and Trees. In: 26th ACM SIGMOD-SIGACT-SIGART Symposium on
Principles of Database Systems, ACM-Press, pp. 233–242. Available at http://dx.doi.org/10.1145/
1265530.1265564.

[3] Rajeev Alur & P. Madhusudan (2004): Visibly pushdown languages. In: 36th ACM Symposium on Theory
of Computing, ACM-Press, pp. 202–211. Available at http://portal.acm.org/citation.cfm?coll=
GUIDE&dl=GUIDE&id=1007390.

[4] Rajeev Alur & P. Madhusudan (2009): Adding nesting structure to words. Journal of the ACM 56(3), pp.

1–43. Available at http://doi.acm.org/10.1145/1516512.1516518.

[5] Marcelo Arenas & Jorge P´erez (2011): Querying semantic web data with SPARQL. In: Proceedings of the
thirtieth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems, pp. 305–316.

[6] Mikolaj Bojanczyk & Igor Walukiewicz (2008): Forest algebras.

In J¨org Flum, Erich Gr¨adel & Thomas
Wilke, editors: Logic and Automata: History and Perspectives [in Honor of Wolfgang Thomas], Texts in
Logic and Games 2, Amsterdam University Press, pp. 107–132.

[7] Iovka Boneva, Joachim Niehren & Momar Sakho (2020): Nested Regular Expressions Can Be Compiled
to Small Deterministic Nested Word Automata. In Henning Fernau, editor: Computer Science - Theory and
Applications - 15th International Computer Science Symposium in Russia, CSR 2020, Yekaterinburg, Russia,
June 29 - July 3, 2020, Proceedings, Lecture Notes in Computer Science 12159, Springer, pp. 169–183,
doi:10.1007/978-3-030-50026-9 12. Available at https://doi.org/10.1007/978-3-030-50026-9_12.
[8] Burchard von Braunm¨uhl & Rutger Verbeek (1985): Input Driven Languages are Recognized in log n Space.
In Marek Karplnski & Jan van Leeuwen, editors: Topics in the Theory of Computation, North-Holland
Mathematics Studies 102, North-Holland, pp. 1 – 19, doi:https://doi.org/10.1016/S0304-0208(08)73072-X.
Available at http://www.sciencedirect.com/science/article/pii/S030402080873072X.

[9] J. R. B¨uchi (1960): On a Decision Method in a Restricted Second Order Arithmetic. In Press, editor: Proc.

Internat. Congr. on Logic, Methodology and Philosophy of Science, pp. 1–11.

[10] Julien Carme, Joachim Niehren & Marc Tommasi (2004): Querying Unranked Trees with Stepwise Tree
Automata. In: 19th International Conference on Rewriting Techniques and Applications, Lecture Notes in
Computer Science 3091, Springer Verlag, pp. 105–118. Available at http://www.ps.uni-sb.de/Papers/
abstracts/stepwise.html.

[11] Hubert Comon, Max Dauchet, R´emi Gilleron, Christof L¨oding, Florent Jacquemard, Denis Lugiez, Sophie
Tison & Marc Tommasi (2007): Tree Automata Techniques and Applications. Available online since 1997:
http://tata.gforge.inria.fr.

[12] Denis Debarbieux, Olivier Gauwin, Joachim Niehren, Tom Sebastian & Mohamed Zergaoui (2015): Early
nested word automata for XPath query answering on XML streams. Theor. Comput. Sci. 578, pp. 100–125,
doi:10.1016/j.tcs.2015.01.017. Available at http://dx.doi.org/10.1016/j.tcs.2015.01.017.
[13] Martin Dietzfelbinger, Anna R. Karlin, Kurt Mehlhorn, Friedhelm Meyer auf der Heide, Hans Rohnert
& Robert Endre Tarjan (1994): Dynamic Perfect Hashing: Upper and Lower Bounds. SIAM J. Com-
put. 23(4), pp. 738–761, doi:10.1137/S0097539791194094. Available at https://doi.org/10.1137/
S0097539791194094.

[14] Ronald Fagin, Benny Kimelfeld, Frederick Reiss & Stijn Vansummeren (2015): Document Spanners: A
Formal Approach to Information Extraction. J. ACM 62(2), pp. 12:1–12:51, doi:10.1145/2699442. Available
at https://doi.org/10.1145/2699442.

[15] Michael J. Fischer & Richard E. Ladner (1979): Propositional Dynamic Logic of Regular Programs. J.
Comput. Syst. Sci. 18(2), pp. 194–211, doi:10.1016/0022-0000(79)90046-1. Available at https://doi.
org/10.1016/0022-0000(79)90046-1.

[16] Massimo Franceschet: XPathMark Performance Test.

https://users.dimi.uniud.it/~massimo.

franceschet/xpathmark/PTbench.html. Accessed: 2020-10-25.

16

Schema-Based Determinization

[17] Olivier Gauwin, Joachim Niehren & Sophie Tison (2009): Earliest Query Answering for Deterministic
Nested Word Automata.
In: 17th International Symposium on Fundamentals of Computer Theory, Lec-
ture Notes in Computer Science 5699, Springer Verlag, pp. 121–132. Available at http://hal.inria.fr/
inria-00390236/en.

[18] Georg Gottlob & Christoph Koch (2002): Monadic Queries over Tree-Structured Data.

In: 17th Annual

IEEE Symposium on Logic in Computer Science, Copenhagen, pp. 189–202.

[19] Georg Gottlob, Christoph Koch & Reinhard Pichler (2003): The complexity of XPath query evaluation. In:
22nd ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, pp. 179–190.
[20] Haruo Hosoya & Benjamin C. Pierce (2003): XDuce: A statically typed XML processing language. ACM
Trans. Internet Techn. 3(2), pp. 117–148, doi:10.1145/767193.767195. Available at https://doi.org/10.
1145/767193.767195.

[21] Leonid Libkin, Wim Martens & Domagoj Vrgoˇc (2013): Querying Graph Databases with XPath. In: Pro-
ceedings of the 16th International Conference on Database Theory, ICDT ’13, Association for Comput-
ing Machinery, New York, NY, USA, p. 129–140, doi:10.1145/2448496.2448513. Available at https:
//doi.org/10.1145/2448496.2448513.

[22] Anthony Lick (2019): Logique de requˆetes `a la XPath : syst`emes de preuve et pertinence pratique. Theses,

Universit´e Paris-Saclay. Available at https://tel.archives-ouvertes.fr/tel-02276423.

[23] Wim Martens & Tina Trautner (2018): Evaluation and Enumeration Problems for Regular Path Queries. In
Benny Kimelfeld & Yael Amsterdamer, editors: 21st International Conference on Database Theory (ICDT
2018), Leibniz International Proceedings in Informatics (LIPIcs) 98, Schloss Dagstuhl–Leibniz-Zentrum fuer
Informatik, Dagstuhl, Germany, pp. 19:1–19:21, doi:10.4230/LIPIcs.ICDT.2018.19. Available at http://
drops.dagstuhl.de/opus/volltexte/2018/8594.

[24] Kurt Mehlhorn (1980): Pebbling Moutain Ranges and its Application of DCFL-Recognition.

In J. W.
de Bakker & Jan van Leeuwen, editors: Automata, Languages and Programming, 7th Colloquium, Noordwei-
jkerhout, The Netherlands, July 14-18, 1980, Proceedings, Lecture Notes in Computer Science 85, Springer,
pp. 422–435, doi:10.1007/3-540-10003-2 89. Available at https://doi.org/10.1007/3-540-10003-2_
89.

[25] Barzan Mozafari, Kai Zeng & Carlo Zaniolo (2012): High-performance complex event processing over XML
streams.
In K. Selc¸uk Candan, Yi Chen, Richard T. Snodgrass, Luis Gravano, Ariel Fuxman, K. Selc¸uk
Candan, Yi Chen, Richard T. Snodgrass, Luis Gravano & Ariel Fuxman, editors: SIGMOD Confer-
ence, ACM, pp. 253–264, doi:10.1145/2213836.2213866. Available at http://dx.doi.org/10.1145/
2213836.2213866.

[26] Joachim Niehren & Momar Sakho (2021): Determinization and Minimization of Automata for Nested Words
Revisited. Algorithms, doi:10.3390/a14030068. Available at https://hal.inria.fr/hal-03134596.
[27] Alexander Okhotin & Kai Salomaa (2014): Complexity of input-driven pushdown automata. SIGACT News
45(2), pp. 47–67, doi:10.1145/2636805.2636821. Available at https://doi.org/10.1145/2636805.
2636821.

[28] Markus L. Schmid & Nicole Schweikardt (2021): A Purely Regular Approach to Non-Regular Core
Spanners.
In Ke Yi & Zhewei Wei, editors: 24th International Conference on Database Theory (ICDT
2021), Leibniz International Proceedings in Informatics (LIPIcs) 186, Schloss Dagstuhl – Leibniz-Zentrum
f¨ur Informatik, Dagstuhl, Germany, pp. 4:1–4:19, doi:10.4230/LIPIcs.ICDT.2021.4. Available at https:
//drops.dagstuhl.de/opus/volltexte/2021/13712.

[29] H. Straubing (1994): Finite Automata, Formal Logic, and Circuit Complexity. Progress in Computer Science
and Applied Series, Birkh¨auser. Available at https://books.google.fr/books?id=jLbH4LJbuDsC.
[30] J. W. Thatcher (1967): Characterizing derivation trees of context-free grammars through a generalization of

automata theory. Journal of Computer and System Science 1, pp. 317–322.

[31] J. W. Thatcher & J. B. Wright (1968): Generalized ﬁnite automata with an application to a decision problem

of second-order logic. Mathematical System Theory 2, pp. 57–82.

Niehren, Sakho, and Al Serhali

17

(q, s) ∈ IA×S
q ∈ IΠA(A×S)

(q, s) ∈ QA×S
q ∈ QΠA(A×S)

(q, s) ∈ F A×S
q ∈ F ΠA(A×S)

(q1, s1) a−→ (q2, s2) ∈ ∆A×S
a−→ q2 ∈ ∆ΠA(A×S)

q1

Figure 19: Projection ΠA(A × S) = (Σ, QΠA(A×S), ∆ΠA(A×S), IΠA(A×S), F ΠA(A×S)).

A Proofs for Section 1 (Introduction)

A.1 Further Related Work

Nested regular path queries.
[21, 23] are formulas from propositional dynamic logic (PDL) [15].
While applicable to general data graphs, they can also be restricted to nested words. They extend on
usual regular expression by adding nested ﬁlters that are closed under the logical operators. Filters may
test for the existence of nodes answering a nested regular path query. When XML documents, nested
regular path queries can be identiﬁed with regular forward XPath queries [5, 19]. t is folklore that nested
regular path queries on data trees can be compiled to automata.
MSO. For ranked trees, one can ﬁrst compile path queries to the monadic second-order (MSO) formulas,
and from there to tree automata that recognize so-called V-structures [31, 18, 10]. V-structures are trees
that are annotated with variables x satisfying words-onex
Σ, saying where the any variable assignement
has to assign a single node to variable x. In recent database terminology, languages of V-structures are
called document spanners [14, 28]. But since the compilation of path queries to MSO formulas eagerly
introduces quantiﬁer alternations, that are to be eliminated by repeated automata determinization, this
approach leads to a large size blowup.
Nested Regular Expressions. A more recent idea [7] is to compile nested regular path queries to nested
regular expressions in a ﬁrst step, i.e., regular expressions for nested words that were introduced earlier
under the name regular expression types by Hosoya and Pierce [20]. Nested regular expressions support
the usual operators of regular expressions and the nesting expressions (cid:104)e(cid:105) for deﬁning languages of
nested words. Furthermore, they support vertically recursive deﬁnitions based on µ-expressions µx.e,
intersections e ∩ e(cid:48), and complementation e. It is then possible to compile nested regular expressions
to SHAs or NWAs, by lifting the usual automata constructions from standard regular to nested regular
expressions.
Forest Algebras. Nested words are very similar to forests, i.e., sequences of unranked trees. The
transition relation of any SHA can be used to deﬁne a forest algebra [6].
Hedge Automata. Stepwise hedge automata (SHAs) improve on classical hedge automata [30, 11] in
that they come with a satisfying notion of determinism.

B Proofs for Section 3 (Schema-Based Cleaning)

C Proofs for Section 4 (Schema-Based Determinization)

Proposition 6. For any two NFAs A and S with the same alphabet:

sclS(A) = (cid:99)sclS(A)

and QA×S = QA (cid:98)×S

Proof. The two equations are shown by the following four lemmas. The judgements with a hat there are
to be inferred by the collapsed system of inference rules in Fig. 20, while the other judgments are to be
inferred with the rule system for accessible products in Fig. 7.

18

Schema-Based Determinization

q ∈ IA

s ∈ IS

q ∈ F A

s ∈ F S

(q, s) ∈ QA (cid:98)×S

q ∈ I (cid:99)sclS(A)
(q, s) ∈ QA (cid:98)×S
q ∈ Q (cid:99)sclS(A)

(q, s) ∈ QA (cid:98)×S
q1

a−→ q2 ∈ ∆A
q1

s1
a−→ q2 ∈ ∆(cid:99)sclS(A)

a−→ s2 ∈ ∆S

(q2, s2) ∈ QA (cid:98)×S

(q1, s1) ∈ QA (cid:98)×S

q ∈ F (cid:99)sclS(A)

(cid:99)sclS(A) = (Σ, Q (cid:99)sclS(A), ∆(cid:99)sclS(A), I (cid:99)sclS(A), F (cid:99)sclS(A))

Figure 20: A collapsed rule systems for schema-based cleaning (cid:99)sclS(A).

Lemma 13. q ∈ I (cid:99)sclS(A) iff q ∈ IsclS(A).

Proof. The rule systems of accessible product, projection, and the collapsed system can be used as
following :

q ∈ IA

s ∈ IS

q ∈ I (cid:99)sclS(A)

q ∈ IA
s ∈ IS
(q, s) ∈ IA×S
q ∈ IsclS(A)

Lemma 14. (q, s) ∈ QA (cid:98)×S iff (q, s) ∈ QA×S.

Proof. We proof for all n ≥ 0 that if (q, s) ∈ QA (cid:98)×S has a proof tree of size n then there exists a proof tree
for (q, s) ∈ QA×S. The proof is by induction on n.

In the case of the rules of the initial states, (q, s) ∈ QA (cid:98)×S is inferred directly whenever (q, s) ∈ QA×S

and vice versa, using the following:

q ∈ IA

(q, s) ∈ IA×S

s ∈ IS
(q, s) ∈ QA×S

q ∈ IA

s ∈ IS

q ∈ I (cid:99)sclS(A)

(q, s) ∈ QA (cid:98)×S

If (q, s) ∈ QA (cid:98)×S is inferred by the internal rule of the collapsed rule system in Fig. 20. Then the proof

tree has the following form for some proof tree T1:

q1

a−→ q2 ∈ ∆A

a−→ s2 ∈ ∆S
s1
(q2, s2) ∈ QA (cid:98)×S

T1
(q1, s1) ∈ QA (cid:98)×S

This shows that there is a smaller proof tree T1 for inferring (q1, s1) ∈ QA (cid:98)×S. So by induction hypothesis
1 for inferring (q1, s1) ∈ QA×S with the proof system of accessible
applied to T1, there exists a proof tree T (cid:48)
products in Fig. 7:

T (cid:48)
1
(q1, s1) ∈ QA×S
Therefore, we also have the following proof tree for (q2, s2) ∈ QA×S with the internal rule for the acces-
sible product:

q1

a−→ q2 ∈ ∆A

a−→ s2 ∈ ∆S
s1
(q2, s2) ∈ QA×S

T (cid:48)
1
(q1, s1) ∈ QA×S

Niehren, Sakho, and Al Serhali

19

For the inverse direction, if (q, s) ∈ QA×S is inferred by the internal rule of the accessible product

rule system in Fig. 7. Then the proof tree has the following form for some proof tree T1:

q1

a−→ q2 ∈ ∆A

a−→ s2 ∈ ∆S
s1
(q2, s2) ∈ QA×S

T1
(q1, s1) ∈ QA×S

This means that there is a smaller proof tree T1 for inferring (q1, s1) ∈ QA×S. By induction hypothesis
1 for inferring (q1, s1) ∈ QA (cid:98)×S with the collapsed system in
applied to T1, there exists a proof tree T (cid:48)
Fig. 20:

T (cid:48)
1
(q1, s1) ∈ QA (cid:98)×S

which leads to the following proof tree for (q2, s2) ∈ QA×S with the internal rule for the collapsed system:

q1

a−→ q2 ∈ ∆A

a−→ s2 ∈ ∆S
s1
(q2, s2) ∈ QA (cid:98)×S

T (cid:48)
1
(q1, s1) ∈ QA (cid:98)×S

Lemma 15. q1

a−→ q2 ∈ ∆(cid:99)sclS(A) iff q1

a−→ q2 ∈ ∆sclS(A).

Proof. We prove for all n ≥ 0 that, if q1
proof tree for q1

a−→ q2 ∈ ∆sclSA and vice versa. The proof is by induction on n.

a−→ q2 ∈ ∆(cid:99)sclS(A) has a proof tree of size n, then there exists a

a−→ q2 ∈ ∆(cid:99)sclS(A) is inferred by the internal rule of the collapsed system, the proof tree will have

If q1
the following for some tree T1:

q1

a−→ q2 ∈ ∆A

T1
(q1, s1) ∈ QA (cid:98)×S

a−→ s2 ∈ ∆S
s1
a−→ q2 ∈ ∆(cid:99)sclS(A)

q1

By Lemma 14 and the rule of internal rules of the accessible product rule system:

q1

a−→ q2 ∈ ∆A

s1

a−→ s2 ∈ ∆S
(q1, s1) a−→ (q2, s2) ∈ ∆A×S

T (cid:48)
1
(q1, s1) ∈ QA×S

For the inverse direction, if q1

a−→ q2 ∈ ∆sclS(A) is inferred by the internal rule of the accessible product,

the proof tree will have the following for some tree T1:

T1
(q1, s1) ∈ QA×S

q1

a−→ q2 ∈ ∆A

s1

a−→ s2 ∈ ∆S
(q1, s1) a−→ (q2, s2) ∈ ∆A×S
a−→ q2 ∈ ∆sclS(A)

q1

20

Schema-Based Determinization

Q ∈ Idet(A)

s ∈ IS

Q ∈ F det(A)

s ∈ F S

(Q, s) ∈ Qdet(A)×S

Q ∈ I (cid:99)sclS(det(A))
(Q, s) ∈ Qdet(A) (cid:98)×S
Q ∈ Q (cid:99)sclS(det(A))

(Q, s) ∈ Qdet(A) (cid:98)×S

Q ∈ F (cid:99)sclS(det(A))

Q1

a−→ Q2 ∈ ∆det(A)

a−→ s2 ∈ ∆S

s1

(Q1, s1) ∈ Qdet(A)×S

Q1

a−→ Q2 ∈ ∆(cid:99)sclS(det(A))

(Q2, s2) ∈ Qdet(A) (cid:98)×S

(cid:99)sclS(det(A)) = (Σ, Q (cid:99)sclS(det(A)), ∆(cid:99)sclS(det(A)), I (cid:99)sclS(det(A)), F (cid:99)sclS(det(A)))

Figure 21: Instantiation of the collapsed rule system for schema-based cleaning from Fig. 20 with det(A).

By lemma 14 and the rule of internal rules of the collapsed system:

q1

a−→ q2 ∈ ∆A

T (cid:48)
1
(q1, s1) ∈ QA×S

a−→ s2 ∈ ∆S
s1
a−→ q2 ∈ ∆(cid:99)sclS(A)

q1

Lemma 16. q ∈ Q (cid:99)sclS(A) iff q ∈ QsclS(A) and q ∈ F (cid:99)sclS(A) iff q ∈ F sclS(A).

Proof. We start proving q ∈ Q (cid:99)sclS(A) iff q ∈ QsclS(A). By Lemma 14, and rules of construction of the
accessible product, projection, and collapsed systems, this lemma holds for some proof trees T and T (cid:48) as
follows:

T
(q, s) ∈ QA×S
q ∈ QsclS(A)

T (cid:48)
q ∈ Q (cid:99)sclS(A)

Finally, we show q ∈ F (cid:99)sclS(A) iff q ∈ F sclS(A). Using Lemma 14, there exists some proof trees T and
T (cid:48) that infers (q, s) ∈ QA×S and (q, s) ∈ QA (cid:98)×S in both ways and therefore having the following form of
rules:

q ∈ F A

s ∈ F S

T
(q, s) ∈ QA (cid:98)×S

q ∈ F A

q ∈ F (cid:99)sclS(A)

s ∈ F S
(q, s) ∈ F A×S
q ∈ F sclS(A)

T (cid:48)
(q, s) ∈ QA×S

D Proofs for Section 5 (Stepwise Hedge Automata for Nested Words)

Proposition 10. The accessible determinization of a SHA can be computed in expected amortized time
O(|Qdet(A)|2 |∆A| + |A|).

Proof. An algorithm for computing the ﬁxed points of the inference rules of accessible determinization
of a SHA is presented in Fig. 22. It extends on the case of NFAs with the same data structures. It uses
dynamic perfect hashing for the hash sets. The additional treatment of apply rules, that dominates the
complexity of the algorithm, works as follows: for each Q ∈ Qdet(A) in the Agenda and each state Q1 ∈
Qdet(A) in the Store, it computes the sets Q(cid:48) = {q(cid:48) | q@q1 → q(cid:48), q1 ∈ Q1, q ∈ Q} and Q(cid:48)(cid:48) = {q(cid:48)(cid:48) | q1@q →

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

Niehren, Sakho, and Al Serhali

21

fun detSHA (A) =

initA (cid:54)= /0 then Agenda.add(initA)

l e t Store = hashset.new( /0)
l e t Agenda = list.new() and Rules = hashset.new( /0)
i f
w h i l e Agenda.notEmpty() do
l e t (Q) = Agenda.pop()
l e t h be an empty h a s h t a b l e w i t h k e y s

from Σ .

/ /

t h e

v a l u e s w i l l be n o n e m p t y h a s h s u b s e t s o f QA

f o r q a−→ q(cid:48) ∈ ∆A such t h a t q ∈ Q do

i f h.get(a) = unde f

then h.add(a, hashset.new( /0))

(h.get(a)).add(q(cid:48))
f o r (a, Q(cid:48)) i n h.tolist() do Rules.add(Q a−→ Q(cid:48))

i f not Store.member(Q(cid:48)) then Store.add(Q(cid:48)) Agenda.push(Q(cid:48))

f o r Q1 ∈ Store do

l e t Q(cid:48) = {q(cid:48) | q@q1 → q(cid:48), q1 ∈ Q1, q ∈ Q}
i f Q(cid:48) (cid:54)= /0 then Rules.add(Q@Q1 → Q(cid:48))

i f not Store.member(Q(cid:48)) then Store.add(Q(cid:48)) Agenda.push(Q(cid:48))

l e t Q(cid:48)(cid:48) = {q(cid:48)(cid:48) | q1@q → q(cid:48)(cid:48), q1 ∈ Q1, q ∈ Q}
i f Q(cid:48)(cid:48) (cid:54)= /0 then Rules.add(Q1@Q → Q(cid:48)(cid:48))

l e t initdet(A) = {Q | Q ∈ Store, Q ∩ initA (cid:54)= /0} and F det(A) = {Q | Q ∈ Store, Q ∩ F A (cid:54)= /0}
r e t u r n (Σ, Store.toSet(), Rules.toSet(), initdet(A), F det(A))

Figure 22: An algorithm for accessible determinization of SHAs.

(q, s) ∈ (cid:104)(cid:105)∆A×S
q ∈ (cid:104)(cid:105)∆ΠA(A×S)

(q1, s1)@(q, s) → (q2, s2) ∈ ∆A×S
q1@q → q2 ∈ ∆ΠA(A×S)

Figure 23: Lifting projections ΠA(A × S) to SHAs.

q(cid:48)(cid:48), q1 ∈ Q1, q ∈ Q} and puts all new non-empty sets in both the Agenda and the Store, while adding
dynamically the generated apply rules in the hash set Rules. Again, the overall number of elements in
the agenda will be |Qdet(A)|, requiring time in O(|Qdet(A)|2 |∆A|). With a precomputation time of A in
O(|A|), the total computation will be in O(|Qdet(A)|2 |∆A| + |A|).

E Proofs for Section 6 (Schema-Based Determinization for SHAs)

Proposition 11. If A and S are dSHAs then the accessible product A × S and the schema-based cleaning
sclS(A) can be computed in expected amortized time O(|QA×S|2 + |QA×S||Σ| + |A| + |S|).

The algorithm in Fig. 24 is obtained by lifting the algorithm for DFAs in Fig. 11 to SHAs. For the case
of apply rules, we have to combine each pair (q1, s1) ∈ QA×S in the stack Agenda with all (q, s) ∈ QA×S
in the hash set Store, in both directions. The time to treat these pairs is O(|QA×S|2), so quadratic in the
worst case. As before, no state (q1, s1) will be processed twice, due to the set membership test before
pushing a pair into the agenda.

Proposition 12. The schema-based determinization detS(A) of a SHA A with respect to a dSHA S can
be computed in expected amortized time O(|Qdet(A)×S|2 + |Qdet(A)×S| |Σ| + |QdetS(A)|2 |∆A| + |A| + |S|).

Proof. Analogously to the case of NFAs on words. The algorithm in Fig. 25 computes the ﬁxed point of
the inference rules of schema-based determinization of SHAs. As for NFAs, it stores untreated alignments

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

Schema-Based Determinization

22

fun A × S =

initA = {q0} and initS = {s0} then Agenda.add((q0, s0))

l e t Store = hashset.new( /0)
l e t Agenda = list.new() and Rules = hashset.new( /0)
i f
w h i l e Agenda.notEmpty() do
l e t (q1, s1) = Agenda.pop()
f o r a ∈ Σ do

a−→ s2 ∈ ∆S}
l e t Q = {q2 | q1
f o r q2 ∈ Q and s2 ∈ R do Rules.add((q1, s1) a−→ (q2, s2))

a−→ q2 ∈ ∆A} and R = {s2 | s1

i f not Store.member((q2, s2))

then Store.add((q2, s2)) Agenda.push((q2, s2))

f o r (q, s) ∈ Store do

l e t Q(cid:48) = {q2 | q1@q → q2 ∈ ∆A} and R(cid:48) = {s2 | s1@s → s2 ∈ ∆S}
f o r q2 ∈ Q(cid:48) and s2 ∈ R(cid:48) do Rules.add((q1, s1)

(q,s)
−−−→ (q2, s2))

i f not Store.member((q2, s2))

then Store.add((q2, s2)) Agenda.push((q2, s2))

l e t Q(cid:48)(cid:48) = {q2 | q@q1 → q2 ∈ ∆A} and R(cid:48)(cid:48) = {s2 | s@s1 → s2 ∈ ∆S}
f o r q2 ∈ Q(cid:48)(cid:48) and s2 ∈ R(cid:48)(cid:48) do Rules.add((q, s)

(q1,s1)
−−−−→ (q2, s2))

i f not Store.member((q2, s2))

then Store.add((q2, s2)) Agenda.push((q2, s2))

l e t initA×S = {(q0, s0) | (q0, s0) ∈ Store} and F A×S = {(q, s) | (q, s) ∈ Store, q ∈ F A, s ∈ F S}
r e t u r n (Σ, Store.toSet(), Rules.toSet(), initA×S, F A×S)

Figure 24: An algorithm computing the accessible product of dSHAs A and S.

on a stack Agenda and processed alignments in a hash set Store. It also collects transition rules in a
hash set Rules. New alignments can now be produced by the the inference rule for apply transitions:
for each alignment Q1 ∼ s1 on the Agenda and Q2 ∼ s2 in the Store, the algorithm computes the sets
{s | s1@s2 → s ∈ ∆S} and {Q | Q1@Q2 → Q ∈ ∆det(A)} and pushes all pairs Q ∼ s outside the Store to
the Agenda. There may be at most one such pair since S and det(A) are deterministic. We also have
to consider the symmetric case where Q1 ∼ s1 on the store and Q2 ∼ s2 on the Agenda. Thus, it is in
time O(|Qdet(A)×S|2) which is quadratic in the worst case. Added to the latter, the cost of computing
the transition of det(A) on the ﬂy which is in worst case O(|QdetS(A)|2 |∆A| + |A|). Therefore, having
the whole algorithm running, including the time for computing the internal rules, in O(|Qdet(A)×S|2 +
|Qdet(A)×S| |Σ| + |QdetS(A)|2 |∆A| + |A| + |S|) .

F Proof of Correctness Theorem 2

The proof extends on the proof of the case of words (Theorem 1) in a direct manner.

We ﬁrst lift the collapsed rule system for NFAs from Fig. 20 to SHAs inFig. 26, and then show that

collapsed rules also redeﬁne the schema-based cleaning (cid:99)sclS(A) = sclS(A) in the case of SHAs.
Proposition 17. For any two SHAs A and S with the same alphabet:

ΠA(A × S) = (cid:99)sclS(A)

and QA×S = QA (cid:98)×S

Proof. The two equations are shown either by new lemmas or an extension of the lemmas from the proof
of Theorem 1, whereas all unchanged existing lemmas hold(Lemmas 13, 15 and 16).

Niehren, Sakho, and Al Serhali

23

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

fun d e t S ( A , S ) =

l e t Store = hashset.new( /0)
l e t Agenda = list.new() and Rules = hashset.new( /0)
i f
w h i l e Agenda.notEmpty() do

initA (cid:54)= /0 and initS = {s0} then Agenda.add(initA ∼ s0)

l e t (Q1 ∼ s1) = Agenda.pop()
f o r a ∈ Σ do

l e t P = {Q2 | Q1
f o r Q2 ∈ P and s2 ∈ R do Rules.add(Q1

a−→ Q2 ∈ ∆det(A)} and R = {s2 | s1
a−→ Q2)

a−→ s2 ∈ ∆S}

i f not Store.member(Q2 ∼ s2)

then Store.add(Q2 ∼ s2) Agenda.push(Q2 ∼ s2)

f o r (Q ∼ s) ∈ Store do

l e t P(cid:48) = {Q2 | Q1@Q → Q2 ∈ ∆det(A)} and R(cid:48) = {s2 | s1@s → s2 ∈ ∆S}
f o r Q2 ∈ P(cid:48) and s2 ∈ R(cid:48) do Rules.add(Q1@Q → Q2)

i f not Store.member(Q2 ∼ s2)

then Store.add(Q2 ∼ s2) Agenda.push(Q2 ∼ s2)

l e t P(cid:48)(cid:48) = {Q2 | Q@Q1 → Q2 ∈ ∆det(A)} and R(cid:48)(cid:48) = {s2 | s@s1 → s2 ∈ ∆S}
f o r Q2 ∈ P(cid:48)(cid:48) and s2 ∈ R(cid:48)(cid:48) do Rules.add(Q@Q1 → Q2)

i f not Store.member(Q2 ∼ s2)

then Store.add(Q2 ∼ s2) Agenda.push(Q2 ∼ s2)

l e t initdetS(A) = {Q | Q ∼ s ∈ Store, Q ∩ initA (cid:54)= /0} and F detS(A) = {Q | Q ∼ s ∈ Store, Q ∩ F A (cid:54)= /0}
r e t u r n (Σ, Store.toSet(), Rules.toSet(), initdetS(A), F detS(A))

Figure 25: An algorithm for schema-based determinization of an SHA A and a dSHA schema S

q ∈ (cid:104)(cid:105)∆A
q ∈ (cid:104)(cid:105)∆(cid:99)sclS(A)

s ∈ (cid:104)(cid:105)∆S

(q, s) ∈ QA (cid:98)×S

q1@q → q2 ∈ ∆A

s1@s → s2 ∈ ∆S
q1@q → q2 ∈ ∆(cid:99)sclS(A)

(q1, s1) ∈ QA (cid:98)×S
(q2, s2) ∈ QA (cid:98)×S

(q, s) ∈ QA (cid:98)×S

Figure 26: Lifting the collapsed rule system from NFAs to SHAs.

Lemma 18. q ∈ (cid:104)(cid:105)∆(cid:99)sclS(A)

iff (cid:104)(cid:105)∆sclS(A)

Proof. The rule systems of accessible product, projection and the collapsed system can be used as fol-
lowing :

q ∈ (cid:104)(cid:105)∆A

s ∈ (cid:104)(cid:105)∆S

q ∈ (cid:104)(cid:105)∆(cid:99)sclS(A)

q ∈ (cid:104)(cid:105)∆A

s ∈ (cid:104)(cid:105)∆S

(q, s) ∈ (cid:104)(cid:105)∆A×S
q ∈ (cid:104)(cid:105)∆sclS(A)

Lemma 19 (extends Lemma 14). (q, s) ∈ QA (cid:98)×S iff (q, s) ∈ QA×S.

All proofs for initial states rules and internal rules from the previous lemma hold and we extend it

for tree initial rules and apply rules:

Proof. Similarly, we prove for all n ≥ 0 that if (q, s) ∈ QA (cid:98)×S has a proof tree of size n then there exists
a proof trees for (q, s) ∈ QA×S. The proof is by induction on n.

24

Schema-Based Determinization

In the case of tree initial rules, (q, s) ∈ QA (cid:98)×S is inferred directly whenever (q, s) ∈ QA×S and vice

versa, using the following:

q ∈ (cid:104)(cid:105)∆A
(q, s) ∈ (cid:104)(cid:105)∆A×S

s ∈ (cid:104)(cid:105)∆S
(q, s) ∈ QA×S

q ∈ (cid:104)(cid:105)∆A
q ∈ (cid:104)(cid:105)(cid:99)sclS(A)

s ∈ (cid:104)(cid:105)∆S
(q, s) ∈ QA (cid:98)×S

In the same spirit, if (q, s) ∈ QA (cid:98)×S is inferred by the apply rule of the same system, then the proof

tree has the following form for some proof trees T1 and T :

q1@q → q2 ∈ ∆A

s1@s → s2 ∈ ∆S

T1
(q1, s1) ∈ QA (cid:98)×S

T
(q, s) ∈ QA (cid:98)×S

(q2, s2) ∈ QA (cid:98)×S

This means that there are smaller proof trees T1 and T for inferring respectively (q1, s1) ∈ QA (cid:98)×S and
(q, s) ∈ QA (cid:98)×S. Correspondingly, by induction hypothesis applied to T1 and T , there exists T (cid:48)
1, T (cid:48) for
inferring (q1, s1) ∈ QA×S and (q, s) ∈ QA×S:

T (cid:48)
1
(q1, s1) ∈ QA×S

T (cid:48)
(q, s) ∈ QA×S

Thus allowing the following proof tree for (q2, s2) ∈ QA×S with the apply rule of the accessible product:

q1@q → q2 ∈ ∆A

s1@s → s2 ∈ ∆S

T (cid:48)
1
(q1, s1) ∈ QA×S

T (cid:48)
(q, s) ∈ QA×S

(q2, s2) ∈ QA×S

For the inverse direction of the apply rules, and using the induction hypothesis, we will be able to

infer (q2, s2) ∈ QA (cid:98)×S with some T (cid:48)

1 and T (cid:48) and ending with the following proof tree:

q1@q → q2 ∈ ∆A

s1@s → s2 ∈ ∆S

T (cid:48)
1
(q1, s1) ∈ QA (cid:98)×S

T (cid:48)
(q, s) ∈ QA (cid:98)×S

(q2, s2) ∈ QA (cid:98)×S

Lemma 20. q1@q → q2 ∈ ∆(cid:99)sclS(A) iff q1@q → q2 ∈ ∆sclS(A).

Proof. Following the same logic in Lemma 15, this lemma holds by the following sequence of rules, for
some proof trees T1, T , T (cid:48)

1 and T (cid:48) :

q1@q → q2 ∈ ∆A

s1@s → s2 ∈ ∆S

T1
(q1, s1) ∈ QA (cid:98)×S

T
(q, s) ∈ QA (cid:98)×S

q1@q → q2 ∈ ∆(cid:99)sclS(A)

q1@q → q2 ∈ ∆A

T (cid:48)
1
(q1, s1) ∈ QA×S

s1@s → s2 ∈ ∆S
(q1, s1)@(q, s) → (q2, s2) ∈ ∆A×S

T (cid:48)
(q, s) ∈ QA×S

Niehren, Sakho, and Al Serhali

25

Q ∈ (cid:104)(cid:105)∆det(A)

s ∈ (cid:104)(cid:105)∆S

Q ∈ (cid:104)(cid:105)∆(cid:99)sclS(det(A))

(Q, s) ∈ Qdet(A) (cid:98)×S

Q1@Q → Q2 ∈ ∆det(A)

s1@s → s2 ∈ ∆S

(Q1, s1) ∈ Qdet(A) (cid:98)×S

(Q, s) ∈ Qdet(A) (cid:98)×S

Q1@Q → Q2 ∈ ∆(cid:99)sclS(det(A))

(Q2, s2) ∈ Qdet(A) (cid:98)×S

Figure 27: Extending the instantiation of the alt. deﬁnition of schema-based cleaning: (cid:99)sclS(det(A)) =
(Σ, Q (cid:99)sclS(det(A)), ∆(cid:99)sclS(det(A)), I (cid:99)sclS(det(A)), F (cid:99)sclS(det(A))).

(q1, s1)@(q, s) → (q2, s2) ∈ ∆A×S
q1@q → q2 ∈ ∆(cid:99)sclS(A)

For the inverse direction, the sequence of rules, for some proof trees T1, T , T (cid:48)

1 and T (cid:48) will be:

q1@q → q2 ∈ ∆A

T1
(q1, s1) ∈ QA×S

s1@s → s2 ∈ ∆S
(q1, s1)@(q, s) → (q2, s2) ∈ ∆A×S
q1@q → q2 ∈ ∆sclS(A)

T
(q, s) ∈ QA×S

q1@q → q2 ∈ ∆A

s1@s → s2 ∈ ∆S

T (cid:48)
1
(q1, s1) ∈ QA (cid:98)×S

T (cid:48)
(q, s) ∈ QA (cid:98)×S

q1@q → q2 ∈ ∆(cid:99)sclS(A)

Proof of Correctness of Theorem 2. For the proof of theorem for nested words with SHA, we extend
the instantiation of the rule system for schema-based cleaning from Fig. 26 with det(A), yielding the rule
system in Fig. 27. The whole instantiation holds with the previous instantiation for words and we can
still identify the rule system for (cid:99)sclS(det(A)) with the rule system detS(A). With the same identiﬁcation
of judgements and predicate renaming, the two systems are still exactly the same. Having (cid:99)sclS(det(A)) =
detS(A) implies, by Proposition 17 sclS(det(A)) = detS(A).

G Proofs for Section 7 (Experiments)

26

Schema-Based Determinization

Figure 28: A schema for the intersection of XML data model with onex.

Figure 29: The automaton mini(detS(A)) of the query Q3.4.

Niehren, Sakho, and Al Serhali

27

Figure 30: The automaton mini(det(A × S)) of the query Q3.4.

