Revisiting Semiring Provenance for Datalog
Camille Bourgaux, Pierre Bourhis, Liat Peterfreund, Michaël Thomazo

To cite this version:

Camille Bourgaux, Pierre Bourhis, Liat Peterfreund, Michaël Thomazo. Revisiting Semiring Prove-
nance for Datalog. KR 2022 - 19th International Conference on Principles of Knowledge Representa-
tion and Reasoning, Jul 2022, Haifa, Israel. pp.91-101, ￿10.24963/kr.2022/10￿. ￿hal-03771031￿

HAL Id: hal-03771031

https://hal.science/hal-03771031

Submitted on 7 Sep 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Revisiting Semiring Provenance for Datalog

Camille Bourgaux1 , Pierre Bourhis2 , Liat Peterfreund3 , Micha¨el Thomazo1
1DI ENS, ENS, CNRS, PSL University & Inria, Paris, France
2CRIStAL, CNRS, University of Lille, Inria, Lille, France
3LIGM, CNRS, Universit´e Gustave Eiffel, ENPC, Paris, France
camille.bourgaux@ens.fr, pierre.bourhis@inria.fr,
liat.peterfreund@univ-eiffel.fr, michael.thomazo@inria.fr

Abstract

Data provenance consists in bookkeeping meta information
during query evaluation, in order to enrich query results with
their trust level, likelihood, evaluation cost, and more. The
framework of semiring provenance abstracts from the speciﬁc
kind of meta information that annotates the data. While the
deﬁnition of semiring provenance is uncontroversial for unions
of conjunctive queries, the picture is less clear for Datalog.
Indeed, the original deﬁnition might include inﬁnite computa-
tions, and is not consistent with other proposals for Datalog
semantics over annotated data. In this work, we propose and
investigate several provenance semantics, based on different
approaches for deﬁning classical Datalog semantics. We study
the relationship between these semantics, and introduce prop-
erties that allow us to analyze and compare them.

1

Introduction

Datalog is a rule language widely studied both in the database
community, where it is seen as a query language, and in the
KR community, as an ontology language.

In relational databases, the framework of semiring prove-
nance was introduced to generalize computations over
annotated databases, e.g., the semantics of probabilistic
databases (Senellart 2017), the bag semantics, lineage or
why-provenance (Cheney, Chiticariu, and Tan 2009).
In
this framework, the semantics of positive relational alge-
bra queries over databases annotated with elements of any
commutative semiring is inductively deﬁned on the struc-
ture of the query (Green, Karvounarakis, and Tannen 2007;
Green and Tannen 2017). Provenance semirings are expres-
sions (such as polynomials) built from variables associated
to each tuple of the database (Green 2009). A provenance ex-
pression provides a general representation of how tuples have
been used to derive a query result, and can be faithfully eval-
uated in any semiring in which the considered provenance
semiring can be homomorphically embedded.

Semiring provenance has also been studied for Datalog
queries, for which it was deﬁned based on the set of all deriva-
tion trees for the query (Green, Karvounarakis, and Tannen
2007; Deutch et al. 2014; Deutch, Gilad, and Moskovitch
2018). However, this deﬁnition seems less axiomatic than
in the case of relational databases. Indeed, there may be in-
ﬁnitely many derivation trees, leading to inﬁnite provenance
expressions, while Datalog programs have ﬁnite models that

can be computed efﬁciently (Abiteboul, Hull, and Vianu
1995). A consequence is that this deﬁnition is valid only for
a restricted class of semirings, namely ω-continuous. Re-
cently, Dannert et al. (2021) restrict the semiring even further
by considering fully-chain complete semirings in order to
extend provenance deﬁnition to logical languages featuring
negation and ﬁxed-point. Even if numerous useful semirings
are ω-continuous, or can be extended to a such semiring, inﬁ-
nite provenance expressions may be considered unintuitive
in some cases. Consider, for example, the counting semiring
(i.e., natural numbers with standard operations) for which
provenance of positive relational algebra queries corresponds
to their bag semantics. This semiring can be extended to
an ω-continuous one by adding ∞ to the natural numbers,
hence providing a way to capture the bag semantics for Dat-
alog queries (Mumick, Pirahesh, and Ramakrishnan 1990;
Green, Karvounarakis, and Tannen 2007). However, query
answers having inﬁnite multiplicities may not seem very nat-
ural or informative. Moreover, alternative bag semantics for
languages close to Datalog have been deﬁned, and would
not lead to such inﬁnite multiplicities when applied to Dat-
alog. This is in particular the case of the bag semantics for
ontology-based data access (Nikolaou et al. 2017; Nikolaou
et al. 2019), which corresponds to one of the two semantics
proposed for source-to-target tuple generating dependencies
in the context of data exchange (Hernich and Kolaitis 2017).
Interestingly, these bag semantics are not based on derivation
trees but are model-theoretic semantics: they deﬁne anno-
tated interpretations, and conditions for rules satisfaction
over such interpretations. Such model-theoretic semantics
have also been used in other contexts to evaluate Datalog
and variants over annotated databases, such as fuzzy Datalog
(Achs and Kiss 1995) or description logic knowledge bases
annotated with provenance tokens (Calvanese et al. 2019;
Bourgaux et al. 2020). Finally, yet other semantics deﬁnitions
have been proposed for some use cases. For instance, Zhao,
Subotic, and Scholz (2020) consider minimal depth proof
trees, which correspond to a Datalog evaluation algorithm,
with the intended use of understanding the computation of
the result, and guiding debugging.

The fact that the above semantics are not encompassed
by the deﬁnition of semiring provenance for Datalog, along
with the need of handling inﬁnite computations which are
entailed by this deﬁnition, motivate us to investigate alterna-

tive natural semantics that might be a better ﬁt in different
contexts.

In this paper we introduce several natural provenance se-
mantics for Datalog over annotated data. Our deﬁnitions
are based on different classical approaches: model-theoretic,
execution-based and proof tree-based. They capture the se-
mantics mentioned previously, and are inspired by practical
needs. For instance, our semantics deﬁnition based on min-
imal depth derivation trees capture the behavior of Datalog
engines, such as Soufﬂ´e (Soufﬂ´e 2020), that store only mini-
mal depth derivation trees instead of storing them all (which
might be impossible in case there are inﬁnitely many); Our
semantics based on non-recursive derivation trees (in which a
fact is not derived from itself) resembles the approach taken
by some graph query languages, e.g., SPARQL and Cypher,
to handle queries with possibly inﬁnite outputs by allowing
to explicitly restrict the output to include only simple paths.
In addition, some of the semantics suggested in the paper are
closely related to paradigms for weighted reasoning in the
context of words and trees (Esparza and Luttenberger 2011;
St¨uber and Vogler 2008).

After deﬁning these different semantics, we study under
which conditions they coincide and investigate their connec-
tions. We then provide a general framework for deﬁning such
provenance semantics, and present several properties relevant
for provenance semantics that allow us to compare them. We
brieﬂy discuss some complexity issues in conclusion. Proofs
and additional discussion are available in the appendix of
(Bourgaux et al. 2022).

2 Preliminaries

2.1 Datalog
We use the standard Datalog settings (cf. (Abiteboul, Hull,
and Vianu 1995) part D).

Syntax Let P, C, and V be mutually disjoint, possibly in-
ﬁnite sets of predicates, constants, and variables respectively.
Elements of C ∪ V are called terms. An atom has the form
p(t1, . . . , tn) where p ∈ P is an n-ary predicate, and ti’s
are terms. A fact (or ground atom) is a variable-free atom.
A (Datalog) rule is an expression: ∀(cid:126)x∀(cid:126)y(φ((cid:126)x, (cid:126)y) → ψ((cid:126)x))
where (cid:126)x and (cid:126)y are tuples of variables and φ((cid:126)x, (cid:126)y) and ψ((cid:126)x)
are conjunctions of atoms whose variables are (cid:126)x ∪ (cid:126)y and (cid:126)x
respectively. We call φ((cid:126)x, (cid:126)y) and ψ((cid:126)x) the body and head of
the rule, respectively. From now on, we assume that rules are
in normalized form, i.e., the head consists of a single atom
H((cid:126)x), and quantiﬁers are implicit. The domain D(A) of a
set A of atoms is the set of terms that appear in its atoms.

A database D is a ﬁnite set of facts, and a Datalog pro-
gram (or ontology) Σ is a ﬁnite set of Datalog rules. The
schema of D (resp. Σ) denoted S(D) (resp. S(Σ)) is the set
of predicates that appear in its atoms.1

Semantics The semantics of Datalog can classically be
deﬁned in three ways: through models, ﬁxpoints or deriva-
tion trees. All three deﬁnitions rely on the notion of ho-

1Note that we do not require the set of predicates of atoms
appearing in heads of rules to be disjoint from S(D); naturally, all
of our results are valid under this assumption as well.

momorphism: a homomorphism from a set A of atoms to
a set B of atoms is a function h : D(A) → D(B) such
that h(t) = t for all t ∈ C, and p(t1, . . . , tn) ∈ A implies
h(p(t1, · · · , tn)) := p(h(t1), . . . , h(tn)) ∈ B. We denote by
h(A) the set {h(p(t1, . . . , tn)) | p(t1, . . . , tn) ∈ A}. The
homomorphism deﬁnition is extended to conjunctions of
atoms by viewing them as the sets of atoms they contain.

A set I of facts is a model of a rule r := φ((cid:126)x, (cid:126)y) → ψ((cid:126)x),
denoted by I |= r, if every homomorphism h from φ((cid:126)x, (cid:126)y)
to I is also a homomorphism from ψ((cid:126)x) to I; it is a model of
a Datalog program Σ if I |= r for every r ∈ Σ; it is a model
of a database D if D ⊆ I. A fact α is entailed by D and Σ,
denoted Σ, D |= α, if α ∈ I for every model I of Σ and D.
Example 1. Let Σ contain the rules B(x) → A(x),
R(x, y) ∧ A(y) → B(x), and R(x, y) → R(y, x), and
D := {B(a), B(b), R(a, b), R(b, a)}. Each model of D and
Σ contains all facts in D as well as A(a) and A(b), which
are thus entailed by Σ, D.

An equivalent way to deﬁne the entailment of a fact α by
D and Σ is to check if there is a homomorphism from α to
a speciﬁc model, deﬁned as the least ﬁxpoint containing D
of the immediate consequence operator: An immediate con-
sequence for D and Σ is either α ∈ D, or α such that there
exists a rule r := φ((cid:126)x, (cid:126)y) → ψ((cid:126)x) and a homomorphism h
from φ((cid:126)x, (cid:126)y) to D such that h(ψ((cid:126)x)) = α.

Finally, a third deﬁnition relies on derivation trees.

Deﬁnition 1 (Derivation Tree). A derivation tree t of a fact
α w.r.t. a database D and a program Σ is a ﬁnite tree whose
leaves are labeled by facts from D and non-leaf nodes are
labeled by triples (p(t1, . . . , tm), r, h) where
• p(t1, . . . , tm) is a fact over the schema S(Σ);
• r is a rule from Σ of the form φ((cid:126)x, (cid:126)y) → p((cid:126)x);
• h is a homomorphism from φ((cid:126)x, (cid:126)y) to the facts of the labels
of the node children, such that h(p((cid:126)x)) = p(t1, . . . , tm);
• there is a bijection f between the node children and the
atoms of φ((cid:126)x, (cid:126)y), such that for every q((cid:126)z) ∈ φ((cid:126)x, (cid:126)y),
f (q((cid:126)z)) is of the form (h(q((cid:126)z)), r(cid:48), h(cid:48)) or is a leaf labeled
by h(q((cid:126)z)).

Moreover, if (p(t1, · · · , tm), r, h) or p(t1, · · · , tm) is the
root of t, then p(t1, · · · , tm) = α.
Example 2. Let Σ contain r1 := R(x, y) → H(x, x), r2 :=
R(x, y) → H(x, y) and r3 := S(x, y, z) ∧ S(x, z, y) →
H(x, x).
then
the fact α := H(a, a) has the following derivation trees
(α, r3, h3)

If D = {R(a, a), S(a, b, c), S(a, c, b)},

(α, r3, h(cid:48)

(α, r2, h)

(α, r1, h)

3)

R(a, a)

R(a, a)

S(a, b, c)S(a, c, b)

S(a, c, b)S(a, b, c)

where h(x) = h(y) = a, h3(x) = a, h3(y) = b, h3(z) = c
and h(cid:48)

3(x) = a, h(cid:48)

3(y) = c, h(cid:48)

3(z) = b.

Note that when the program at hand is recursive (i.e., the
dependency graph of its predicates contains cycles) a fact
may have inﬁnitely many derivation trees. Figure 1 depicts
some of the inﬁnitely many derivation trees of A(a) from
Example 1. In this example, and from this point on, we
omit rules and homomorphisms from trees when there is no
ambiguity.

A(a)

A(a)

B(a)

A(a)

B(a)

R(a, b) A(b)

R(a, b)

A(b)

B(a)

B(b)

R(b, a)

B(b)

Figure 1: Some derivation trees of A(a) in Example 1.

Queries A conjunctive query (CQ) is an existentially quan-
tiﬁed formula ∃(cid:126)y φ((cid:126)x, (cid:126)y) where φ((cid:126)x, (cid:126)y) is a conjunction of
atoms with variables in (cid:126)x ∪ (cid:126)y; a union of conjunctive queries
(UCQ) is a disjunction of CQs (over the same free variables).
A query is Boolean if it has no free-variables. A set of
facts I satisﬁes a Boolean CQ (BCQ) q := ∃(cid:126)y φ((cid:126)y), written
I |= q, if and only if there is a homomorphism from φ((cid:126)y)
to I. A BCQ q is entailed by a Datalog program Σ and
database D, written Σ, D |= q, if and only if I |= q for every
model I of Σ and D. Note that Σ, D |= q if and only if
Σ ∪ {φ((cid:126)y) → goal}, D |= goal, where goal is a nullary pred-
icate such that goal /∈ S(Σ) ∪ S(D). A tuple of constants
(cid:126)a is an answer to a CQ q((cid:126)x) := ∃(cid:126)y φ((cid:126)x, (cid:126)y) over Σ and D if
(cid:126)a and (cid:126)x have the same arity and Σ, D |= q((cid:126)a) where q((cid:126)a) is
the BCQ obtained by replacing the variables from (cid:126)x with the
corresponding constants from (cid:126)a. When Σ = ∅, it amounts to
the existence of a homomorphism from q((cid:126)a) to D, which cor-
responds to the semantics of CQs over relational databases.

2.2 Annotated Databases
To equip databases with extra information, their facts might
be annotated with, e.g., trust levels, clearance degree required
to access them, or identiﬁers to track how they are used.

In the framework of semiring provenance, annotations are
elements of algebraic structures known as commutative semir-
ings. A semiring K = (K, +K, ×K, 0K, 1K) is a set K with
distinguished elements 0K and 1K, equipped with two binary
operators: +K, called the addition, which is an associative
and commutative operator with identity 0K, and ×K, called
the multiplication, which is an associative operator with iden-
tity 1K. It also holds that ×K distributes over +K, and 0K is
annihilating for ×K. When multiplication is commutative, the
semiring is said to be commutative. We use the convention
according to which multiplication is applied before addition
to omit parentheses. We omit the subscript of operators and
distinguished elements when there is no ambiguity.
Deﬁnition 2. An annotated database is a triple (D, K, λ)
where D is a database, K = (K, +K, ×K, 0K, 1K) is a semir-
ing, and λ : D (cid:55)→ K \ {0K} maps facts into semiring ele-
ments different from 0K.
Example 3 (Ex. 1 cont’d). The semiring N = (N, +, ×, 0, 1)
of the natural numbers equipped with the usual opera-
tions is used for bag semantics. The tropical semiring
T = (R∞
+ , min, +, ∞, 0) is used to compute minimal-cost
paths. We deﬁne λN : D (cid:55)→ N \ {0} by λN(B(a)) = 3,
λN(B(b)) = 1, λN(R(a, b)) = 2, λN(R(b, a)) = 1; And
λT : D (cid:55)→ R+ by λT(B(a)) = 10, λT(B(b)) = 1,
λT(R(a, b)) = 5, λT(R(b, a)) = 2.

We next list some possible properties of semirings. A
semiring is + -idempotent (resp. ×-idempotent) if for every
a ∈ K, a + a = a (resp. a × a = a). It is absorptive if for
every a, b ∈ K, a × b + a = a. It is positive if for every
a, b ∈ K, a × b = 0 if and only if (a = 0 or b = 0), and
a + b = 0 if and only if a = b = 0. Finally, an important
class is that of ω-continuous commutative semirings in which
inﬁnite sums are well-deﬁned. Given a semiring, we deﬁne
the binary relation (cid:118) such that a (cid:118) b if and only if there
exists c ∈ K such that a + c = b. A commutative semiring is
ω-continuous if (cid:118) is a partial order, every (inﬁnite) ω-chain
a0 (cid:118) a1 (cid:118) a2 . . . has a least upper bound sup((ai)i∈N),
and for every a, a + sup((ai)i∈N) = sup((a + ai)i∈N) and
a × sup((ai)i∈N) = sup((a × ai)i∈N).

The semantics of queries from the positive relational alge-
bra, and in particular of UCQs, over annotated databases is
deﬁned inductively on the structure of the query (Green, Kar-
vounarakis, and Tannen 2007). Intuitively, joint use of data
(conjunction) corresponds to multiplication, and alternative
use of data (union or projection) corresponds to addition.
3 cont’d). The BCQ ∃xy (R(x, y) ∧
Example 4 (Ex.
is entailed from (D, N, λN) with multiplicity
B(y))
λN(R(a, b)) × λN(B(b)) + λN(R(b, a)) × λN(B(a)) = 5,
and from (D, T, λT) with minimal cost min(λT(R(a, b)) +
λT(B(b)), λT(R(b, a)) + λT(B(a))) = 6.

A semantics of Datalog over annotated databases has been
deﬁned by Green, Karvounarakis, and Tannen (2007) using
derivation trees, that we shall name the all-tree semantics.
It associates to each fact α entailed by Σ and D the follow-
ing sum, where T Σ
D (α) is the set of all derivation trees for
α w.r.t. Σ and D and Λ(t) := (cid:81)
v is a leaf of t λ(v) is the K-
annotation of the derivation tree t (since K is commutative,
the result of the product is well-deﬁned).
(cid:88)

P AT(Σ, D, K, λ, α) :=

Λ(t).

t∈T Σ

D (α)

D (α) may be inﬁnite, P AT is well-deﬁned for all Σ,

Since T Σ
(D, K, λ) and α only in the case where K is ω-continuous.
3 cont’d). The fact α := A(a)
Example 5 (Ex.
is entailed with minimal cost: P AT(Σ, D, T, λT, α) =
Since N is not ω-
D (α)Σv is a leaf of tλT(v) = 3.
mint∈T Σ
continuous, P AT(Σ, D, N, λN, α) is not deﬁned.

2.3 Provenance Semirings
Provenance semirings have been introduced to abstract from a
particular semiring by associating a unique provenance token
to each fact of the database, and building expressions that
trace their use. Given a set X of variables that annotate the
database, a provenance semiring Prov (X) is a semiring over
a space of provenance expressions with variables from X.

Various such semirings were introduced in the context
of relational databases (Green 2009): The most expres-
sive annotations are provided by the provenance polyno-
mials semiring N[X] := (N[X], +, ×, 0, 1) of polynomi-
als with coefﬁcients from N and variables from X, and the
usual operations. Less general provenance semirings include,
for example, the semiring B[X] := (B[X], +, ×, 0, 1) of

polynomials with Boolean coefﬁcients, and the semiring
PosBool (X) := (PosBool (X), ∨, ∧, false, true) of positive
Boolean expressions.

In the Datalog context, it is important to allow for inﬁ-
nite provenance expressions, as there can be inﬁnitely many
derivation trees. A formal power series with variables from
X and coefﬁcients from K is a mapping that associates
to each monomial over X a coefﬁcient in K. A formal
power series S can be written as a possibly inﬁnite sum
S = Σm∈mon(X)S(m)m where mon(X) is the set of mono-
mials over X and S(m) is the coefﬁcient of the monomial m.
The set of formal power series with variables from X and co-
efﬁcients from K is denoted K
. Green, Karvounarakis,
and Tannen (2007) deﬁne the Datalog provenance semiring
as the semiring N∞
of formal power series with coefﬁ-
cients from N∞ = N ∪ {∞}.

(cid:74)
homomorphism
=
(K, +K, ×K, 0K, 1K) to K(cid:48) = (K (cid:48), +K(cid:48), ×K(cid:48), 0K(cid:48), 1K(cid:48)) is a
mapping h : K → K (cid:48) such that h(0K) = 0K(cid:48), h(1K) = 1K(cid:48),
and for all a, b ∈ K, h(a +K b) = h(a) +K(cid:48) h(b) and
h(a ×K b) = h(a) ×K(cid:48) h(b). A semiring homomorphism be-
tween ω-continuous semirings is ω-continuous if it preserves
least upper bounds: h(sup((ai)i∈N)) = sup((h(ai))i∈N).

from K

semiring

X
(cid:74)

X

A

(cid:75)

(cid:75)

Following Deutch et al. (2014), we say that a provenance
semiring Prov (X) specializes correctly to a semiring K,
if any valuation ν : X → K extends uniquely to a (ω-
continuous if Prov (X) and K are ω-continuous) semiring
homomorphism h : Prov (X) → K, allowing the computa-
tions for K to factor through the computations for Prov (X).
A provenance semiring Prov (X) is universal for a set of
semirings if it specializes correctly to each semiring of this
set. Green, Karvounarakis, and Tannen (2007) showed that
N[X] is universal for commutative semirings, and N∞
is
universal for commutative ω-continuous semirings.

X
(cid:74)

(cid:75)

3 Alternative Semantics
In this section we propose several natural ways of deﬁning
the semantics of Datalog over annotated databases, and in-
vestigate their connections. We have seen that the semantics
of Datalog can equivalently be deﬁned through models, ﬁx-
points or derivation trees. The semantics we propose also fall
into these three approaches. For presentation purposes, we
see each semantics as a partial function P that associates to a
Datalog program Σ, annotated database (D, K, λ), and fact
α, a semiring element P(Σ, D, K, λ, α).

3.1 Model-Based Semantics

We ﬁrst investigate two provenance semantics based on Data-
log’s model-theoretic semantics. In both cases, we will deﬁne
interpretations (I, µI ) where I is a set of facts and µI is a
function that annotates facts of I, and formulate requirements
for them to be models of Σ and (D, K, λ), extending standard
models of Σ and D with fact annotations.

Annotated Model-based Hernich and Kolaitis (2017) de-
ﬁne two bag semantics in the context of data exchange: the
incognizant and cognizant semantics. The difference between
them arise from the two different semantics of bag union: the

incognizant semantics uses the maximum-based union, while
the cognizant semantics uses the sum-based union.

In more details, both semantics are based on the following
semantics for source-to-target tuple generating dependencies
(s-t tgds): a pair (I, J) of source and target instances satisﬁes
an s-t tgd q1((cid:126)x) → q2((cid:126)x) if for every answer (cid:126)a to q1 over I,
(cid:126)a is an answer to q2 over J with at least the same multiplicity.
Given a set of s-t tgds Σ and a source I, a target J is an
incognizant solution for I w.r.t. Σ if (I, J) satisﬁes every
s-t tgd in Σ. It is a cognizant solution if for every r ∈ Σ,
there is a target instance Jr such that (I, Jr) satisﬁes r and
(cid:93)Jr ⊆ J, where (cid:93) denotes the sum-union of bags (i.e., the
multiplicity of each element of the sum-union is equal to the
sum of its multiplicities). The incognizant (resp. cognizant)
certain answers to a query q w.r.t. Σ on I are deﬁned using
bag intersection of the answers over the incognizant (resp.
cognizant) solutions for I w.r.t. Σ, i.e., the multiplicity of an
answer is the minimum of its multiplicities over the solutions.
Note that for BCQs, the only possible certain answer is the
empty tuple.

For example, consider Σ = {B(x) → A(x), C(x) →
A(x)} and D = {(B(a), 1), (C(a), 1)}. Under the incog-
nizant semantics, the multiplicity of the certain answer of
the Boolean query A(a) w.r.t. Σ and D is 1 while under the
cognizant semantics it is 2. Indeed, J = {(A(a), 1)} is an
incognizant solution for D w.r.t. Σ as it satisﬁes both s-t tgds,
but is not a cognizant solution as the sum of multiplicities
that arise from the two rules is 2.

It is easy to show that the cognizant semantics is equivalent
to P AT on the counting semiring N = (N, +, ×, 0, 1), and
thus coincides with the classical bag semantics for Datalog.
However, we have seen that the incognizant and cognizant
semantics differ. Moreover, note that in the ﬁeld of ontology-
based data access, the bag semantics deﬁned by Nikolaou
et al. for DL-LiteR (2017; 2019) coincides with the incog-
nizant semantics, thus disagrees with the classical Datalog
bag semantics (Mumick, Pirahesh, and Ramakrishnan 1990;
Green, Karvounarakis, and Tannen 2007).

We hence deﬁne a provenance semantics that coincides
with these semantics when used with the counting semiring.
Since it is based on greatest lower bounds, it is deﬁned on a
restricted class of semirings.

Let K = (K, +, ×, 0, 1) be a commutative ω-continuous
semiring such that for every K (cid:48) ⊆ K, the greatest lower
bound inf(K (cid:48)) of K (cid:48) is well deﬁned (i.e., there exists a
unique z ∈ K such that z (cid:118) x for every x ∈ K (cid:48) and every z(cid:48)
such that z(cid:48) (cid:118) x for every x ∈ K (cid:48) is such that z(cid:48) (cid:118) z), Σ be
a Datalog program, and (D, K, λ) be an annotated database.
We deﬁne K-annotated interpretations as pairs (I, µI ) where
I is a set of facts, and µI is a function from I to K. We say
that a K-annotated interpretation (I, µI ) is a model of Σ and
(D, K, λ), denoted by (I, µI ) |= (Σ, D, K, λ), if
1. D ⊆ I, and for every α ∈ D, λ(α) (cid:118) µI (α);
2. for every φ((cid:126)x, (cid:126)y) → H((cid:126)x) in Σ, whenever there is a
homomorphism h : φ((cid:126)x, (cid:126)y) (cid:55)→ I, then h(H((cid:126)x)) ∈ I and
(cid:89)
µI (β) (cid:118) µI (h(H((cid:126)x))).

(cid:88)

h(cid:48):φ((cid:126)x,(cid:126)y)(cid:55)→I,h(cid:48)((cid:126)x)=h((cid:126)x)
β∈h(cid:48)(φ((cid:126)x,(cid:126)y))
The annotated model-based provenance semantics P AM is

deﬁned by

P AM(Σ, D, K, λ, α) := inf({µI (α)|(I, µI )|=(Σ, D, K, λ)}).

Proposition 1. If the Datalog rules in Σ are (1) s-t tgds, or
(2) formulated in DL-LiteR, then for every BCQ q, P AM(Σ ∪
{q → goal}, D, N, λN, goal) is equal to the multiplicity of
the empty tuple in (1) the incognizant certain answers or (2)
the bag certain answers to q w.r.t. Σ and (D, N, λN).

Set-Annotated Model-based We adapt the work on prove-
nance for the description logics DL-LiteR and ELHr (Cal-
vanese et al. 2019; Bourgaux et al. 2020), where the semir-
ing is assumed to be a ×-idempotent provenance semiring
Prov (X) and rules are also annotated. Annotated models of
annotated knowledge bases are deﬁned as set of facts anno-
tated with sets of monomials from Prov (X). Given a fact α
and a monomial m over X, (Σ, D, Prov (X), λX ) |= (α, m)
holds when m belongs to the annotation set of α in every
models of Σ and (D, Prov (X), λX ).

To obtain an analog provenance semantics for Datalog, we
deﬁne interpretations which associate facts with (possibly
inﬁnite) sets of annotations, and formulate the requirements
for them to be models of Σ and (D, K, λ).

Let K = (K, +, ×, 0, 1) be a commutative ω-continuous
semiring, Σ be a Datalog program, and (D, K, λ) be an an-
notated database. We deﬁne K-set-annotated interpretations
as pairs (I, µI ) where I is a set of facts, and µI is a function
from I to the power-set of K. We say that a K-set-annotated
interpretation (I, µI ) is a model of Σ and (D, K, λ), denoted
by (I, µI ) |= (Σ, D, K, λ), if
1. D ⊆ I, and for every α ∈ D, λ(α) ∈ µI (α);
2. for every φ((cid:126)x, (cid:126)y) → H((cid:126)x) in Σ, whenever there is a ho-
momorphism h : φ((cid:126)x, (cid:126)y) (cid:55)→ I, then h(H((cid:126)x)) ∈ I and if
h(φ((cid:126)x, (cid:126)y)) = β1 ∧ · · · ∧ βn, {Πn
i=1ki | (k1, . . . , kn) ∈
µI (β1) × · · · × µI (βn)} ⊆ µI (h(H((cid:126)x))).
The set-annotated model-based provenance semantics

P SAM is deﬁned by

P SAM(Σ, D, K, λ, α) :=

(cid:88)

k.

k∈(cid:84)

(I,µI )|=(Σ,D,K,λ) µI (α)

Connections between semantics Let (cid:118) be the binary re-
lation between provenance semantics such that P (cid:118) P (cid:48) if
and only if P(Σ, D, K, λ, α) (cid:118) P (cid:48)(Σ, D, K, λ, α) for every
Σ, (D, K, λ) and α on which P and P (cid:48) are well-deﬁned.
Proposition 2. The following holds:

P AM (cid:118) P AT and P SAM (cid:118) P AT.

Next examples show that P AM and P SAM are incomparable.
Example 6. Let Σ = {A(x) → goal, B(x) → goal}, D =
{A(a), B(a)}, λN(A(a)) = 2 and λN(B(a)) = 3.

Annotated models of Σ and (D, N, λN) are such that

µI (goal) ≥ 3, so P AM(Σ, D, N, λN, goal) = 3.

Set-annotated models of Σ and (D, N, λN) are such that

{2, 3} ⊆ µI (goal), so P SAM(Σ, D, N, λN, goal) = 5.

Hence P AM(Σ, D, N, λN, goal)<P SAM(Σ, D, N, λN, goal).

Example 7. Let Σ = {R(x, y) → goal}, D =
{R(a, b), R(a, c)}, λN(R(a, b)) = 2 and λN(R(a, c)) = 2.
Annotated models of Σ and (D, N, λN) are such that

µI (goal) ≥ 4, so P AM(Σ, D, N, λN, goal) = 4.

Set-annotated models of Σ and (D, N, λN) are such that

{2} ⊆ µI (goal), so P SAM(Σ, D, N, λN, goal) = 2.

Hence P AM(Σ, D, N, λN, goal)>P SAM(Σ, D, N, λN, goal).
Despite of their inherently different approaches, P AM, P SAM

and P AT coincide on a large class of semirings.
If K is a commutative + -idempotent
Proposition 3.
(D, K, λ),
then for every Σ,
ω-continuous semiring,
and α, P AM(Σ, D, K, λ, α) = P SAM(Σ, D, K, λ, α) =
P AT(Σ, D, K, λ, α).

(cid:75)

(cid:74)

(cid:74)

(cid:74)

X

• P SAM(Σ, D, N∞

Additional insights on the connection between deﬁni-
tions can be gained by considering the provenance semiring
N∞
: the monomials with non-zero coefﬁcients are the
same with all semantics but their coefﬁcients may differ (P AT
leading to the highest coefﬁcients by Proposition 2).
Proposition 4. Let λX be an injective function from D to X.
• A monomial occurs in P AT(Σ, D, N∞
, λX , α) if and
X
only if it occurs in P AM(Σ, D, N∞
(cid:74)
(cid:75)
, λX , α).
X
(cid:75)
, λX , α) is obtained by setting all non-
X
zero coefﬁcients to 1 in P AT(Σ, D, N∞
(cid:75)
An example where P AT and P AM or P SAM differ on
N∞
is the following: Let Σ contain A(x) → B(x),
B(x) → A(x), D = {A(a)} and λX (A(a)) = x.
Since there are inﬁnitely many derivation trees for
A(a), P AT(Σ, D, K, λX , A(a)) = ∞x while for P ∈
{P AM, P SAM}, P(Σ, D, N∞
X
as
(cid:74)
{A(a), B(a)} with both facts annotated with x (resp. {x}) is
a (resp. set-)annotated model for Σ and (D, N∞

, λX , A(a)) = x,
(cid:75)

, λX , α).

X
(cid:74)

Note that P AM and P SAM can still lead to inﬁnite prove-
nance expressions: Let Σ = {A(x) ∧ B(x) → A(x)},
D = {A(a), B(a)}, λX (A(a)) = x and λX (B(a)) = y.
For P ∈ {P AM, P SAM}, P(Σ, D, N∞
, λX , A(a)) =
x + xy + xy2 + xy3 + . . . .

X
(cid:74)

, λX ).

X

X

(cid:74)

(cid:75)

(cid:74)

(cid:75)

(cid:75)

(cid:75)

3.2 Execution- and Tree-Based Semantics
We saw that when annotations are present there is more than
one way to deﬁne a model-based semantics for Datalog and
that it differs from the all-tree semantics. We now investigate
deﬁnitions based on classical Datalog evaluation algorithms.
We extend the notion of immediate consequence operator
describing the application of rules onto facts, with the compu-
tation of annotation. To this end, we introduce the annotation
aware immediate consequence operator TΣ. Applying TΣ
on a set of annotated facts (I, K, λ) results in (ITΣ , K, λTΣ )
where ITΣ is the result of applying the immediate conse-
quence operator to Σ and I, and λTΣ annotates facts in ITΣ
with the relational provenance (over (I, K, λ)) of the UCQ
formed by the bodies of the rules that create them. Formally,

ITΣ := {H((cid:126)a) | I |= ∃(cid:126)y φ((cid:126)a, (cid:126)y) , φ((cid:126)x, (cid:126)y) → H((cid:126)x) ∈ Σ}

λTΣ (H((cid:126)a)) :=

(cid:88)

(cid:89)

λ(β)

h((cid:126)x)=(cid:126)a, I|=h(φ((cid:126)x,(cid:126)y))
φ((cid:126)x,(cid:126)y)→H((cid:126)x)∈Σ

β∈h(φ((cid:126)x,(cid:126)y))

We deﬁne a union operator for annotated databases (over
the same semiring): (I, K, λ) ∪ (I (cid:48), K, λ(cid:48)) := (I ∪ I (cid:48), K, λ(cid:48)(cid:48))
where λ(cid:48)(cid:48)(α) := λ(α) + λ(cid:48)(α) where we slightly abuse nota-
tion by setting λ(α) = 0 if α /∈ I, and λ(cid:48)(α) = 0 if α /∈ I (cid:48).

(Σ, D, K, λ) := TΣ(I i

Naive Evaluation / All Trees
In the naive evaluation al-
gorithm, all rules are applied in parallel until a ﬁxpoint is
reached. The ‘annotation aware’ version of it is as follows:
n (Σ, D, K, λ) := (D, K, λ), and deﬁne inductively
We set I 0
n(Σ, D, K, λ)) ∪ (D, K, λ). Note
I i+1
n
that the subscript n of In is an abbreviation for ‘naive’, and
the superscript i indicates how many times TΣ was applied.
n(Σ, D, K, λ). We say that
n = I k
n
n(α)) exists for every α ∈ I k
n .

Let (I i
n(Σ, D, K, λ) converges if there is some k such that I (cid:96)
I i
for every (cid:96) ≥ k, and sup(λi
Proposition 5. For every Σ, D, K, λ, if K is ω-continuous
then I i
In this case, we deﬁne I∞
:= supi→∞ λi
n.
n
The naive execution provenance semantics P NE is deﬁned by

n(Σ, D, K, λ) converges.

n) denote I i

n and λ∞
n

n, K, λi

:= I k

P NE(Σ, D, K, λ, α) :=

(cid:26)λ∞
n (α)
0

α ∈ I∞
n
otherwise

and is equivalent to the all-tree semantics.
Proposition 6. It holds that P NE = P AT.

Optimized Naive Evaluation / Minimal Depth Trees
We consider an optimized version of the naive algorithm
that stops as soon as the desired fact is derived. We de-
ﬁne the ‘annotation aware’ version of this algorithm by
o,α(Σ, D, K, λ) := (D, K, λ), and
I 0

o,α (Σ, D, K, λ) :=
I i+1
(cid:26)TΣ(I i

o,α(Σ, D, K, λ)) ∪ (D, K, λ) α /∈ I i

o,α(Σ, D, K, λ)
I i

o,α
otherwise
o,α, K, λi

o,α is such that I i

o,α(Σ, D, K, λ) := (I i

where I i
o,α).
Proposition 7. For every Σ, D, K, λ, and α such that
o,α(Σ, D, K, λ) =
Σ, D |= α , there exists k ≥ 0 such that I k
o,α(Σ, D, K, λ) for every (cid:96) ≥ k.
I (cid:96)
With k as provided by Proposition 7, we deﬁne the opti-

mized execution provenance semantics P OE by:

P OE(Σ, D, K, λ, α) :=

(cid:26)λk

o,α(α) α ∈ I k
o,α
otherwise

0

We show that an equivalent tree-based semantics can be ob-
tained by considering only minimal depth trees for the desired
fact. This approach has been considered useful, for example
to present a ‘small proof’ for debugging (Zhao, Subotic, and
Scholz 2020). Formally, let depth(t) denote the depth of
tree t. We say that t ∈ T Σ
D (α) is of minimal depth if for ev-
ery t(cid:48) ∈ T Σ
D (α) it holds that depth(t) ≤ depth(t(cid:48)). The
minimal depth tree provenance semantics P MDT is deﬁned by

P MDT(Σ, D, K, λ, α) :=

(cid:88)

Λ(t)

t∈T Σ

D (α)

is of minimal depth

and is equivalent to the optimized naive execution.
Proposition 8. It holds that P OE = P MDT.

Seminaive Evaluation / Hereditary Minimal Depth Trees
In the seminaive evaluation algorithm, facts are derived
only once. We introduce a new consequence operator
∆Σ that derives only new facts and is deﬁned as fol-
lows: ∆Σ(I, K, λ) := (I∆Σ , K, λ∆Σ ) where TΣ(I, K, λ) :=
(ITΣ , K, λTΣ ), I∆Σ := ITΣ \ I, and λ∆Σ is the restriction
of λTΣ to I∆Σ . We can now deﬁne the annotation aware
sn(Σ, D, K, λ) :=
I 0
version of the seminaive evaluation:
(D, K, λ) and I i+1
sn(Σ, D, K, λ) ∪
:= I i
sn(Σ, D, K, λ)).
∆Σ(I i
Proposition 9. For every Σ, D, K, λ, there exists k ≥ 0 such
that I k

sn(Σ, D, K, λ) for every (cid:96) ≥ k.

sn(Σ, D, K, λ) = I (cid:96)

sn (Σ, D, K, λ)

Note that, unlike in Proposition 5, we do not require K to
be ω-continuous. With k provided by Proposition 9, the sem-
inaive execution provenance semantics P SNE is deﬁned by

P SNE(Σ, D, K, λ, α) :=

(cid:26)λk
sn
0

α ∈ I k
sn
otherwise

To capture this with the tree-based approach we need to
further restrict all subtrees to be of minimal depth. Formally,
a derivation tree t ∈ T Σ
D (α) is a hereditary minimal-depth
(derivation) tree if for every node n of t labeled by (β, r, h),
the subtree tβ with root n is a minimal-depth derivation
tree for β. The hereditary minimal depth tree provenance
semantics P HMDT is deﬁned by

P HMDT(Σ, D, K, λ, α) :=

(cid:88)

Λ(t)

t∈T Σ

D (α)

is hereditary minimal-depth

and is equivalent to the seminaive execution.
Proposition 10. It holds that P SNE = P HMDT.

3.3 Non-Recursive Tree-Based Semantics
Both execution-based semantics P OE and P SNE take into ac-
count ﬁnite subsets of derivation trees (and hence converge).
Is there a more informative tree-based semantics (i.e., one
that takes into account a bigger subset of derivation trees)
that still converges? We present such a semantics based on
the intuition that deriving a fact from itself is redundant.

Formally, a non-recursive (derivation) tree is a derivation
tree that does not contain two nodes labeled with the same
fact and such that one is the descendant of the other. The
non-recursive tree provenance semantics P NRT is deﬁned by

P NRT(Σ, D, K, λ, α) :=

(cid:88)

Λ(t).

t∈T Σ

D (α)

is non-recursive

Connections between semantics Next proposition fol-
lows from the fact that hereditary minimal-depth trees are
of minimal-depth and non recursive. The sets of minimal
depth trees and non-recursive trees are incomparable, so that
P NRT (cid:54)(cid:118) P MDT and P MDT (cid:54)(cid:118) P NRT.
Proposition 11. The following hold:

P HMDT (cid:118) P NRT (cid:118) P AT and P HMDT (cid:118) P MDT (cid:118) P AT

Moreover P NRT and P AT coincide on speciﬁc semirings.

Proposition 12. For every Σ, D, K, λ and α,
a commutative absorptive ω-continuous semiring,
P NRT(Σ, D, K, λ, α) = P AT(Σ, D, K, λ, α).

if K is
then

If K is not absorptive, there exists Σ, (D, K, λ) and α
such that P NRT(Σ, D, K, λ, α) (cid:54)= P AT(Σ, D, K, λ, α), even
in the case where K is + -idempotent and ×-idempotent:
Let Σ consist of the rule A(x) ∧ B(x) → A(x) and D =
{A(a), B(a)}. Then P NRT(Σ, D, K, λ, A(a)) = λ(A(a))
while P AT(Σ, D, K, λ, A(a)) = λ(A(a)) + λ(A(a)) ×
λ(B(a)).

The other semantics differ even under strong restrictions.
Example 8. This example shows that P NRT, P MDT and P HMDT
differ even if K is + and ×-idempotent and absorptive.

Let Σ ={B(x) ∧ C(x) → A(x), D(x) → B(x),
E(x) → C(x), F (x) → E(x)}

D ={C(a), D(a), E(a), F (a)}

The three derivation trees of A(a) w.r.t. Σ and D are non-
recursive, but only the ﬁrst two are of minimal depth and only
the ﬁrst one is a hereditary minimal-depth tree.

A(a)

A(a)

A(a)

B(a)

C(a)

B(a)

C(a)

B(a)

C(a)

D(a)

E(a)

D(a)

D(a)

E(a)

F (a)

Thus, if (D, K, λ) is such that λ(C(a)) = c, λ(D(a)) = d,
λ(E(a)) = e, and λ(F (a)) = f then

P NRT(Σ, D, K, λ, A(a)) =c × d + d × e + d × f
P MDT(Σ, D, K, λ, A(a)) =c × d + d × e
P HMDT(Σ, D, K, λ, A(a)) =c × d

4 Basics Properties
In this section, we provide a framework allowing to compare
the provenance semantics presented in the previous section.
It is clear that they all fulﬁll the following deﬁnition.
Deﬁnition 3 (Provenance semantics). A provenance seman-
tics is a partial function that assigns to a Datalog program
Σ, annotated database (D, K, λ) and fact α, an element
P(Σ, D, K, λ, α) in K such that:
1. Σ, D (cid:54)|= α implies P(Σ, D, K, λ, α) = 0K.
2. If K is positive, P(Σ, D, K, λ, α) = 0K implies Σ, D (cid:54)|= α.

We call the semiring domain of P the maximal set S of semir-
ings such that P(Σ, D, K, λ, α) is deﬁned for every K ∈ S,
and every Σ, (D, K, λ) and α.

Intuitively, Deﬁnition 3 means that the semantics reﬂects
fact (non)-entailment. It is extremely permissive: We could
deﬁne such a semantics that associates to each entailed fact
a random semiring element different from zero, and does
not bring any information beyond facts entailment. In the
sequel, we state and discuss a number of properties that may
be expected to be satisﬁed by a provenance semantics.

Throughout this section, when not stated otherwise, P, Σ,
D, K, λ and α denote respectively an arbitrary provenance
semantics, Datalog program, database, commutative semiring
(K, +, ×, 0, 1), function from D to K \ {0}, and fact. We
phrase properties as conditions, and say that P satisﬁes a
property if it satisﬁes the condition. We also denote by λX
an injective function λX : D (cid:55)→ X.

4.1 Compatibility with Classical Notions
Property 1 is a sanity check: if a Datalog program amounts
to a UCQ, the provenance should be the same as the one
deﬁned for relational databases (Green, Karvounarakis, and
Tannen 2007). A Datalog program Σ is UCQ-deﬁned if its
rules are of the form φ((cid:126)x, (cid:126)y) → H((cid:126)x) where H is a predicate
that does not occur in the body of any rule. In this case, the
equivalent UCQ QΣ of Σ is (cid:83)
Property 1 (Algebra Consistency). If Σ is UCQ-deﬁned with
rule head H((cid:126)x) and H /∈ S(D), then for every tuple (cid:126)a of
same arity as (cid:126)x, the relational provenance of QΣ((cid:126)a) is equal
to P(Σ, D, K, λ, H((cid:126)a)).

φ((cid:126)x,(cid:126)y)→H((cid:126)x)∈Σ ∃(cid:126)yφ((cid:126)x, (cid:126)y).

While Property 1 considers the behavior of a provenance
semantics on a restricted class of queries, we can alternatively
consider its behavior on a speciﬁc semiring. Boolean prove-
nance has a very natural deﬁnition, based on the database
subsets that entail the query, and is widely used, notably for
probabilistic databases (Senellart 2017), but also for ontology-
mediated query explanation (e.g., in Datalog+/− or descrip-
tion logics (Ceylan et al. 2019; Ceylan et al. 2020)). It is
formalized with the semiring PosBool (X).
Property 2 (Boolean Compatibility).

P(Σ, D, PosBool (X), λX , α) =

(cid:95)

(cid:94)

λX (β)

D(cid:48)⊆D
Σ,D(cid:48)|=α

β∈D(cid:48)

Property 2 expresses ‘insensibility’ to syntax, that is, ev-
ery provenance semantics that satisﬁes Property 2 agrees
on equivalent programs (i.e., those that have the same mod-
els) for the semiring PosBool (X). This is related to ideas
from (Green 2009) on the provenance of equivalent UCQs.

4.2 Compatibility with Specialization
Semiring provenance has been introduced to abstract from
the particular semiring at hand, and factor the computations
in some provenance semiring which specializes correctly to
any semiring of interest. The next property allows one to do
so, and is thus highly desirable (Bourgaux et al. 2022).
Property 3 (Commutation with Homomorphisms). If there
is a semiring homomorphism h from K1 to K2,
then
h(P(Σ, D, K1, λ, α)) = P(Σ, D, K2, h ◦ λ, α).

We call Property 3 restricted to ω-continuous homomor-
phisms Commutation with ω-Continuous Homomorphisms.
Specializing correctly is all the more useful when P is well-
deﬁned for a lot of semirings, in particular on all commutative
or at least all commutative ω-continuous semirings.
Property 4 (Any (ω-Continuous) Semiring). P satisﬁes the
Any Semiring Property (resp. Any ω-Continuous Semiring
Property) if the semiring domain of P contains the set of all
commutative (resp. commutative ω-continuous) semirings.

Joint and Alternative Use of the Data

4.3
How is the actual usage of the data reﬂected in the provenance
semantics? The next property formalizes that multiplication
reﬂects joint use of the data, and addition alternative use. For
the rest of this section, we set goal to be a nullary predicate
not in S(Σ) ∪ S(D).
Property 5 (Joint and Alternative Use). For all tuples of
facts (α1

1, · · · , α1
), . . . , (αm
n1
P(Σ(cid:48), D, K, λ, goal) = Σm

1 , · · · , αm
nm
i=1Πni

), it holds that
j=1P(Σ, D, K, λ, αi
j)

where Σ(cid:48) = Σ ∪ {(cid:86)ni

j=1 αi

j → goal | 1 ≤ i ≤ m}.

We weaken the above by referring to each mode separately:

Property 6 (Joint Use). For all facts α1, · · · , αn,

P(Σ(cid:48), D, K, λ, goal) = Πn

j=1P(Σ, D, K, λ, αj)

where Σ(cid:48) = Σ ∪ {(cid:86)n
j=1 αj → goal}.
Property 7 (Alternative Use). For all facts α1, · · · , αm,

P(Σ(cid:48), D, K, λ, goal) = Σm

i=1P(Σ, D, K, λ, αi)

where Σ(cid:48) = Σ ∪ {αi → goal | 1 ≤ i ≤ m}.

4.4 Fact Roles in Entailment
After considering how facts can be combined or used al-
ternatively to entail a result, we ponder their possible roles
w.r.t. the entailment. Property 8 asserts that the original anno-
tation of a fact takes part in the provenance of its entailment.
Property 8 (Self). If α ∈ D, then λ(α) (cid:118) P(Σ, D, K, λ, α).
Moreover, if a database fact cannot be alternatively derived
using the rules, then its provenance should be exactly its orig-
inal annotation. To phrase this property we use the ground-
ing ΣD of Σ w.r.t. D, deﬁned by ΣD = {h(φ((cid:126)x, (cid:126)y)) →
h(H((cid:126)x)) | φ((cid:126)x, (cid:126)y) → H((cid:126)x) ∈ Σ, h : (cid:126)x ∪ (cid:126)y (cid:55)→ D(D)}. It
holds that Σ, D |= α if and only if ΣD, D |= α.
Property 9 (Parsimony). If α ∈ D does not occur in any
rule head in ΣD then P(Σ, D, K, λ, α) = λ(α).

Parsimony Property together with other constraints guar-

antee Algebra Consistency Property.
Proposition 13. If P satisﬁes Properties 5 (Joint and Alter-
native Use) and 9 (Parsimony), and is such that for every
Σ, D, K, λ, α, P(Σ, D, K, λ, α) = P(ΣD, D, K, λ, α), then
it satisﬁes Property 1 (Algebra Consistency).

Property 10 states that P reﬂects the necessity of a fact for
the entailment. We say that β ∈ D is necessary to Σ, D |= α
if Σ, D \ {β} (cid:54)|= α, and denote by Nec the set of such facts.
Property 10 (Necessary Facts). There exists e ∈ K such
that P(Σ, D, K, λ, α) = Πβ∈Necλ(β) × e.

A fact is usable to Σ, D |= α if it occurs in some derivation
tree in T Σ
D (α). Usable facts are related to the notion of
lineage (Cui, Widom, and Wiener 2000) and can be deﬁned
without resorting to derivation trees (Bourgaux et al. 2022).
Intuitively, if a fact is not usable to derive another fact, it
should not have any inﬂuence on its provenance.
Property 11 (Non-Usable Facts). For every λ(cid:48) that differs
from λ only on facts that are not usable to Σ, D |= α, it holds
that P(Σ, D, K, λ, α) = P(Σ, D, K, λ(cid:48), α).

4.5 Data Modiﬁcation
The last two properties indicate how provenance is impacted
when facts are inserted or deleted.
Property 12 (Insertion). For every (D(cid:48), K, λ(cid:48)) such that
D ∩ D(cid:48) = ∅,

P(Σ, D, K, λ, α) + P(Σ, D(cid:48), K, λ(cid:48), α)

(cid:118) P(Σ, D ∪ D(cid:48), K, λ ∪ λ(cid:48), α).
Maintaining provenance upon fact deletion is very useful
in practice. We formalize this using a provenance semiring,
which allows us to keep track of the facts. A partial evaluation
of a provenance expression p(X) over variables X is an
expression obtained from p(X) by replacing some of the
variables by a given value.
Property 13 (Deletion). For every provenance semiring
Prov (X) and D(cid:48) ⊆ D, if λ(cid:48) is the restriction of λX to
D(cid:48) and ∆ = D \ D(cid:48), then P(Σ, D(cid:48), Prov (X), λ(cid:48), α) is
equal to the partial evaluation of P(Σ, D, Prov (X), λX , α)
obtained by setting the annotations of facts in ∆ to 0:
P(Σ, D, Prov (X), λX , α)[{λX (x) = 0}x∈∆].

5 Semantics Analysis w.r.t. Properties
In this section, we analyze the semantics proposed in Sec-
tion 3 w.r.t. the properties introduced in Section 4. The
properties each semantics satisﬁes are summarized in Table 1.
Proofs of the positive cases are given in the appendix of
(Bourgaux et al. 2022) and we discuss the negative cases,
which may be more characteristic, in the sequel.

P AT P NRT P MDT P HMDT P AM P SAM

Algebra Consistency (cid:88) (cid:88) (cid:88)
Boolean Compat.

(cid:88) (cid:88)

(cid:88) (cid:88)
Com. with Hom.
Com. with ω-Cont. (cid:88) (cid:88) (cid:88)
(cid:88) (cid:88)
Any Semiring
(cid:88) (cid:88) (cid:88)
Any ω-Cont. Sem.

(cid:88)

(cid:88)
(cid:88)
(cid:88)
(cid:88)

(cid:88) (cid:88)

(cid:88)

Joint and Alt. Use
Joint Use
Alternative Use

Self
Parsimony
Necessary Facts
Non-Usable Facts

Insertion
Deletion

(cid:88) (cid:88)
(cid:88) (cid:88)
(cid:88) (cid:88)

(cid:88) (cid:88)

(cid:88) (cid:88) (cid:88)
(cid:88) (cid:88) (cid:88)
(cid:88) (cid:88) (cid:88)
(cid:88) (cid:88) (cid:88)

(cid:88) (cid:88) (cid:88)
(cid:88) (cid:88) (cid:88)
(cid:88)
(cid:88)
(cid:88) (cid:88) (cid:88)

(cid:88) (cid:88)
(cid:88) (cid:88)

(cid:88) (cid:88)

Table 1: Does a property hold for a provenance semantics?

5.1 Tree- and Execution-Based Semantics Cases
We ﬁrst discuss P MDT and P HMDT, which have not been much
investigated and stand out compared to P AT and P NRT. The
next example shows that they do not satisfy the Boolean
Compatibility, Joint and Alternative Use, Alternative Use,
Insertion and Deletion Properties.

Example 9. Consider Σ and (D, Prov (X), λX ) as follows.

Σ ={A(x) → goal, B(x) → goal, C(x) → B(x)}
D ={A(a), C(a)} with λX (A(a)) = a, λX (C(a)) = c
It holds that both P MDT(Σ, D, Prov (X), λX , goal) and
P HMDT(Σ, D, Prov (X), λX , goal) are equal to a. For P ∈
{P MDT, P HMDT} we then have the following:
(i) The Boolean provenance of goal is a ∨ c, hence P does
not satisfy the Boolean Compatibility Property.
(ii) Since P(∅, D, Prov (X), λX , A(a)) = a and
P(∅, D, Prov (X), λX , C(a)) = c, P does not satisfy the
Alternative Use, nor the Joint and Alternative Use Property.
(iii) Let D(cid:48) = {goal} and λ(cid:48)(goal) = g.
It
holds that P(Σ, D ∪ D(cid:48), Prov (X), λX ∪ λ(cid:48)
X , goal) =
g, which is different from P(Σ, D, Prov (X), λX , goal) +
P(Σ, D(cid:48), Prov (X), λ(cid:48)
X , goal) + e for every e ∈ Prov (X).
Hence P does not satisfy the Insertion Property.
(iv) Let D(cid:48) = D \{A(a)} = {C(a)}. The partial evaluation
of P(Σ, D, Prov (X), λX , goal) where a is set to 0 is equal
to 0 while P(Σ, D(cid:48), Prov (X), λX , goal) = c. Hence P does
not satisfy the Deletion Property.

We now illustrate the difference between P HMDT and P MDT:
P HMDT satisﬁes the Joint Use Property while P MDT does not.
Example 10. Let Σ = {C(x) → B(x), D(x) →
A(x)}, D = {B(a), C(a), D(a)} and λ(B(a)) = b,
λ(C(a)) = c, λ(D(a)) = d, and consider Σ(cid:48) = Σ ∪
{A(a) ∧ B(a) → goal}. P MDT(Σ(cid:48), D, K, λ, goal) =
b × d + c × d while P MDT(Σ, D, K, λ, A(a)) = d and
P MDT(Σ, D, K, λ, B(a)) = b. Hence P MDT does not satisfy
the Joint Use Property.

We conclude this discussion with the remark that P AT sat-
isﬁes the Commutation with ω-Continuous Homomorphisms
but not the Commutation with Homomorphisms Property.
Example 11. Consider the semiring N∞ with the classical
operations, and deﬁne N∞,∞(cid:48)
as its extension by an ele-
ment ∞(cid:48) such that for every n ∈ N ∪ {∞}, n + ∞(cid:48) = ∞(cid:48),
and n × ∞(cid:48) = ∞(cid:48) if n (cid:54)= 0, and 0 otherwise. Both
semirings are ω-continuous and h : N∞ (cid:55)→ N∞,∞(cid:48)
de-
ﬁned by h(n) = n for every n ∈ N, h(∞) = ∞(cid:48) is
a semiring homomorphism (which is not ω-continuous).
Assume that P AT(Σ, D, N∞, λ, goal) = Σi∈N1 = ∞.
Then h(P AT(Σ, D, N∞, λ, goal)) = ∞(cid:48) is different from
P AT(Σ, D, N∞,∞(cid:48)

, h ◦ λ, goal) = Σi∈Nh(1) = ∞.

5.2 Model-Based Semantics Cases
On + -idempotent semirings, P AM and P SAM coincide with
P AT so verify the same properties, and the semiring B
of
(cid:74)
formal power series with Boolean coefﬁcients can be used to
compute them in any + -idempotent semiring (Bourgaux et al.
2022). However, on non-idempotent semirings, they do not
satisfy several properties, and in particular the Commutation
with (ω-Continuous) Homomorphisms Properties.
Example 12. Let Σ = {A(x) → goal, B(x) → goal} and
D = {A(a), B(a)} and consider the provenance semiring
N∞
with λX (A(a)) = x and λX (B(a)) = y.

X

X

(cid:75)

It holds that both P AM(Σ, D, N∞
(cid:74)

X

, λX , goal) and

, λX , goal) are equal to x + y.

(cid:74)

(cid:75)

(cid:75)
P SAM(Σ, D, N∞

X

(cid:74)

(cid:75)

Consider now the semiring N∞, λN(A(a)) = 2 and
Both P AM(Σ, D, N∞, λN, goal) and

λN(B(a)) = 2.
P SAM(Σ, D, N∞, λN, goal) are equal to 2.

(cid:74)

(cid:75)

X

For P ∈ {P AM, P SAM} we then have the following:
(i) Let h be a ω-continuous homomorphism from N∞
to
N∞ such that h(x) = 2 and h(y) = 2. Since h(x + y) =
h(x) + h(y) = 4, P does not satisfy the Commutation with
ω-Continuous Homomorphisms Property.
(ii) The relational provenance of QΣ() w.r.t. N∞ and λN is 4
so P does not satisfy the Algebra Consistency Property.
(iii) P(∅, D, N∞, λN, A(a)) + P(∅, D, N∞, λN, B(a)) = 4
so P does not satisfy the Alternative Use nor the Joint and
Alternative Use Property.
(iv)
+
P(Σ, {B(a)}, N∞, λN, goal) = 4 is strictly greater
than P(Σ, D, N∞, λN, goal), P does not satisfy the Insertion
Property.

P(Σ, {A(a)}, N∞, λN, goal)

Since

Moreover, P SAM does not satisfy the Joint Use Property.

Example 13. Let

Σ = {A(x) → g1, A(x) → g2, B(x) → g1, B(x) → g2}
D = {A(a), B(a)} with λX (A(a)) = x, λX (B(a)) = y.
Both
P SAM(Σ, D, N∞
(cid:74)
, λX , g2) are equal
P SAM(Σ ∪ {g1 ∧ g2 → goal}, D, N∞
(cid:75)
x2 + y2 + xy (cid:54)= (x + y)2.

and
to x + y but
, λX , goal) =

, λX , g1)
(cid:75)

P SAM(Σ, D, N∞

X

X

X

(cid:74)

(cid:74)

(cid:75)

We show that P AM does not satisfy the Necessary Facts
Property in the appendix of (Bourgaux et al. 2022) because
we needed to craft a speciﬁc semiring to get a counter-
example.

6 Complexity Considerations and Conclusion
In this paper, we present alternative provenance semantics for
Datalog based on models, execution algorithms and deriva-
tion trees, and compare them through the lens of different
properties. P NRT is the only one that satisﬁes all the stud-
ied properties but does not coincide with an execution based
semantics contrary to the other tree-based semantics P AT,
P MDT, and P HMDT. The equivalence between the tree-based
P AT, P NRT and model-based P AM and P SAM deﬁnitions on
absorptive semirings may also indicates a robust provenance
on this restricted setting.

One of the main complexity sources of Datalog provenance
stems from its inﬁnite representation. Deutch et al. (2014)
studied semirings for which the provenance expressions given
by P AT are ﬁnite, and showed that they can be represented
by polynomial size circuits. We show that the annotations
produced at each iteration of our execution algorithms can
be represented by arithmetic circuits of polynomial size in
the data (Bourgaux et al. 2022). Consequently, both P MDT
and P HMDT can be represented by polynomial size circuits
regardless of the semiring. On the contrary, we show that
(assuming P (cid:54)= NP) there is no polynomially computable
circuit that computes P NRT on N∞
, by a reduction from
(cid:75)
a result by Arenas, Conca, and P´erez (2012). Whether it
is possible to polynomially compute circuits for P NRT on
provenance semirings less expressive than N∞
but non-
absorptive remains open.

X

X

(cid:74)

(cid:74)

(cid:75)

Acknowledgements
This work is supported by the ANR project CQFD (ANR-18-
CE23-0003).

References
Abiteboul, S.; Hull, R.; and Vianu, V. 1995. Foundations of
Databases. Addison-Wesley.
Achs, ´A., and Kiss, A. 1995. Fuzzy extension of datalog.
Acta Cybern. 12(2):153–166.
Arenas, M.; Conca, S.; and P´erez, J. 2012. Counting beyond
a yottabyte, or how SPARQL 1.1 property paths will prevent
adoption of the standard. In Mille, A.; Gandon, F.; Misselis,
J.; Rabinovich, M.; and Staab, S., eds., Proceedings of the
21st World Wide Web Conference 2012, WWW 2012, Lyon,
France, April 16-20, 2012, 629–638. ACM.
Bourgaux, C.; Ozaki, A.; Pe˜naloza, R.; and Predoiu, L. 2020.
Provenance for the description logic elhr. In Bessiere, C.,
ed., Proceedings of the Twenty-Ninth International Joint Con-
ference on Artiﬁcial Intelligence, IJCAI 2020, 1862–1869.
ijcai.org.
Bourgaux, C.; Bourhis, P.; Peterfreund, L.; and Thomazo,
M. 2022. Revisiting semiring provenance for Datalog.
arxiv.org/abs/2202.10766.
Calvanese, D.; Lanti, D.; Ozaki, A.; Pe˜naloza, R.; and Xiao,
G. 2019. Enriching ontology-based data access with prove-
nance. In Kraus, S., ed., Proceedings of the Twenty-Eighth
International Joint Conference on Artiﬁcial Intelligence, IJ-
CAI 2019, Macao, China, August 10-16, 2019, 1616–1623.
ijcai.org.
Ceylan, ˙I. ˙I.; Lukasiewicz, T.; Malizia, E.; and Vaicenavicius,
A. 2019. Explanations for query answers under existential
rules. In Kraus, S., ed., Proceedings of the Twenty-Eighth
International Joint Conference on Artiﬁcial Intelligence, IJ-
CAI 2019, Macao, China, August 10-16, 2019, 1639–1646.
ijcai.org.
Ceylan, ˙I. ˙I.; Lukasiewicz, T.; Malizia, E.; and Vaicenavi-
cius, A. 2020. Explanations for ontology-mediated query
answering in description logics. In Giacomo, G. D.; Catal´a,
A.; Dilkina, B.; Milano, M.; Barro, S.; Bugar´ın, A.; and
Lang, J., eds., ECAI 2020 - 24th European Conference on
Artiﬁcial Intelligence, 29 August-8 September 2020, Santiago
de Compostela, Spain, volume 325 of Frontiers in Artiﬁcial
Intelligence and Applications, 672–679. IOS Press.
Cheney, J.; Chiticariu, L.; and Tan, W. C. 2009. Provenance
in databases: Why, how, and where. Found. Trends Databases
1(4):379–474.
Cui, Y.; Widom, J.; and Wiener, J. L. 2000. Tracing the
lineage of view data in a warehousing environment. ACM
Trans. Database Syst. 25(2):179–227.
Dannert, K. M.; Gr¨adel, E.; Naaf, M.; and Tannen, V. 2021.
Semiring provenance for ﬁxed-point logic. In Baier, C., and
Goubault-Larrecq, J., eds., 29th EACSL Annual Conference
on Computer Science Logic, CSL 2021, January 25-28, 2021,
Ljubljana, Slovenia (Virtual Conference), volume 183 of
LIPIcs, 17:1–17:22. Schloss Dagstuhl - Leibniz-Zentrum f¨ur
Informatik.

Deutch, D.; Milo, T.; Roy, S.; and Tannen, V. 2014. Circuits
for datalog provenance. In Schweikardt, N.; Christophides,
V.; and Leroy, V., eds., Proc. 17th International Conference
on Database Theory (ICDT), Athens, Greece, March 24-28,
2014, 201–212. OpenProceedings.org.
Deutch, D.; Gilad, A.; and Moskovitch, Y. 2018. Efﬁcient
provenance tracking for datalog using top-k queries. VLDB
J. 27(2):245–269.
Esparza, J., and Luttenberger, M. 2011. Solving ﬁxed-
point equations by derivation tree analysis.
In Corradini,
A.; Klin, B.; and Cˆırstea, C., eds., Algebra and Coalgebra
in Computer Science, 19–35. Berlin, Heidelberg: Springer
Berlin Heidelberg.
Green, T. J., and Tannen, V. 2017. The semiring framework
for database provenance. In Sallinger, E.; den Bussche, J. V.;
and Geerts, F., eds., Proceedings of the 36th ACM SIGMOD-
SIGACT-SIGAI Symposium on Principles of Database Sys-
tems, PODS 2017, Chicago, IL, USA, May 14-19, 2017,
93–99. ACM.
Green, T. J.; Karvounarakis, G.; and Tannen, V. 2007. Prove-
In Libkin, L., ed., Proceedings of the
nance semirings.
Twenty-Sixth ACM SIGACT-SIGMOD-SIGART Symposium
on Principles of Database Systems, June 11-13, 2007, Beijing,
China, 31–40. ACM.
Green, T. J. 2009. Containment of conjunctive queries on
annotated relations. In Fagin, R., ed., Database Theory -
ICDT 2009, 12th International Conference, St. Petersburg,
Russia, March 23-25, 2009, Proceedings, volume 361 of
ACM International Conference Proceeding Series, 296–309.
ACM.
Hernich, A., and Kolaitis, P. G. 2017. Foundations of in-
formation integration under bag semantics. In 32nd Annual
ACM/IEEE Symposium on Logic in Computer Science, LICS
2017, Reykjavik, Iceland, June 20-23, 2017, 1–12. IEEE
Computer Society.
Mumick, I. S.; Pirahesh, H.; and Ramakrishnan, R. 1990. The
magic of duplicates and aggregates. In McLeod, D.; Sacks-
Davis, R.; and Schek, H., eds., 16th International Conference
on Very Large Data Bases, August 13-16, 1990, Brisbane,
Queensland, Australia, Proceedings, 264–277. Morgan Kauf-
mann.
Nikolaou, C.; Kostylev, E. V.; Konstantinidis, G.; Kaminski,
M.; Grau, B. C.; and Horrocks, I. 2017. The bag semantics of
ontology-based data access. In Sierra, C., ed., Proceedings of
the Twenty-Sixth International Joint Conference on Artiﬁcial
Intelligence, IJCAI 2017, Melbourne, Australia, August 19-
25, 2017, 1224–1230. ijcai.org.
Nikolaou, C.; Kostylev, E. V.; Konstantinidis, G.; Kaminski,
M.; Grau, B. C.; and Horrocks, I. 2019. Foundations of
ontology-based data access under bag semantics. Artif. Intell.
274:91–132.
Senellart, P. 2017. Provenance and probabilities in relational
databases. SIGMOD Rec. 46(4):5–15.
Soufﬂ´e. 2020. https://soufﬂe-lang.github.io/index.html.
St¨uber, T., and Vogler, H. 2008. Weighted monadic datalog.
Theoretical Computer Science 403(2):221–238.

Zhao, D.; Subotic, P.; and Scholz, B. 2020. Debugging large-
scale datalog: A scalable provenance evaluation strategy.
ACM Trans. Program. Lang. Syst. 42(2):7:1–7:35.

