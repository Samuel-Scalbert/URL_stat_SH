On the relation between keys and link keys for data
interlinking
Manuel Atencia, Jérôme David, Jérôme Euzenat

To cite this version:

Manuel Atencia, Jérôme David, Jérôme Euzenat. On the relation between keys and link keys for
data interlinking. Semantic Web – Interoperability, Usability, Applicability, 2021, 12 (4), pp.547-567.
￿10.3233/SW-200414￿. ￿hal-03426150￿

HAL Id: hal-03426150

https://hal.science/hal-03426150

Submitted on 12 Nov 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution 4.0 International License

Semantic web journal 12(4):547-567, 2021

On the relation between keys and link keys
for data interlinking

Manuel Atencia ∗, Jérôme David and Jérôme Euzenat
Univ. Grenoble Alpes, Inria, CNRS, Grenoble INP, LIG, F-38000 Grenoble France
E-mails: manuel.atencia@inria.fr, jerome.david@inria.fr, jerome.euzenat@inria.fr

Editor: Aidan Hogan, University of Chile, Chile
Solicited review: anonymous reviewers

Abstract. Both keys and their generalisation, link keys, may be used to perform data interlinking, i.e. ﬁnding identical resources
in different RDF datasets. However, the precise relationship between keys and link keys has not been fully determined yet. A
common formal framework encompassing both keys and link keys is necessary to ensure the correctness of data interlinking
tools based on them, and to determine their scope and possible overlapping. In this paper, we provide a semantics for keys
and link keys within description logics. We determine under which conditions they are legitimate to generate links. We provide
conditions under which link keys are logically equivalent to keys. In particular, we show that data interlinking with keys and
ontology alignments can be reduced to data interlinking with link keys, but not the other way around.

Keywords: data interlinking, keys, ontology alignments, link keys

1. Introduction

There are large amounts of RDF data available on the Web, in the form of knowledge graphs or as part
of linked open data. Interoperability between RDF datasets largely relies on links between resources
from different RDF datasets and especially links asserting the identity of resources bearing different
IRIs, speciﬁed using the owl:sameAs property [1]. Since RDF datasets tend to be large, the automatic
discovery of owl:sameAs links between RDF datasets is an important and challenging task. This task is
usually referred to as data interlinking and different algorithms and tools for data interlinking have been
proposed [2, 3].

Among the state-of-the-art approaches to data interlinking, some are based on ﬁnding keys [4–7] or
link keys [8, 9] across RDF datasets. Both keys and link keys are devices characterising what makes two
resources to be identical. Hence, it is natural to exploit them for discovering links across datasets. Even
though both techniques have been proven to be effective in data interlinking scenarios, their relationship
has not been formally established yet.

The objective of this paper is to clarify the relationship between keys and link keys. For this, we ﬁrst
provide the semantics of (RDF) keys and link keys. More speciﬁcally, we formalise how a key, in its
different versions, can be combined with an alignment between ontologies for data interlinking. Then,

*Corresponding author.

DOI: 10.3233/SW-200414, © 2021 – IOS Press and the authors.
This article is published online under the terms of the Creative Commons Attribution License (CC-BY-4.0).

2

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

we deﬁne the semantics of six kinds of link keys — weak, plain and strong link keys, and their in- and
eq-variants — and we logically ground the usage of link keys for data interlinking. Finally, we establish
the conditions under which link keys are equivalent to keys and show that data interlinking with keys and
ontology alignments can be reduced to data interlinking with link keys, but not the other way around.

The contribution of this paper focuses on the speciﬁc features of keys and link keys. It does it, to
the extent possible, independently from the underlying ontological schema and the logical constructors
used for describing or constraining class and property expressions. This is the reason why computational
issues are left for further interesting research.

In the remainder, Section 2 presents the context and related work of the paper. Section 3 introduces
the notations used throughout the paper. Section 4 recalls two different semantics of keys and Section 5
logically justiﬁes their use for data interlinking. Section 6 deﬁnes link keys. Section 7 logically grounds
the use of link keys for data interlinking. The relations between keys and link keys are established in
Section 8, both with respect to their logical entailment and the links they produce. Section 9 concludes
the paper and discusses future work.

All deﬁnitions are illustrated with concrete examples taken from real-world datasets.

2. Context and related work

Data interlinking refers to the process of ﬁnding pairs of IRIs of different RDF datasets representing
the same entity [2, 3]. The result of this process is a set of same-as links to be speciﬁed by the owl:sameAs
property. To decide whether two IRIs represent the same entity or not is mainly based on comparing their
values for selected properties. Data interlinking is reminiscent of the task of record linkage in databases
[10], but it is applied to RDF data described with RDFS/OWL ontologies.

Link discovery platforms such as SILK [11, 12] and LIMES [13] enable users to process link speciﬁca-
tions to generate links. Link speciﬁcations express the properties to be used for generating owl:sameAs
links between two RDF datasets. They also specify the similarity measures to be used for comparing
datatype property values, the aggregation functions for combining similarity values, and the similar-
ity thresholds beyond which two values are considered equal. Link speciﬁcations may be directly set
by users or they may be built (semi-)automatically, for example, using machine learning techniques
[14, 15].

A key is a set of (datatype or object) properties that uniquely identify the instances of a class within a

dataset. For example,

{creator, title} key Book

states that, if two instances of the class Book match on values for the properties creator and title then the
two instances are the same.

Key-based approaches to data interlinking ﬁrst extract key candidates from RDF datasets and then
select the most accurate candidates according to different quality measures [4–7]. When the data of two
RDF datasets are described using the same ontology, then keys, if available, can be directly used for
interlinking the datasets, but if the data are described using different ontologies, then they need to be
combined with ontology alignments [16] relating the properties and classes of the data. For example, the
previous key could be combined with the alignment correspondences creator ≡ auteur, title ≡ titre and
Book ≡ Livre to interlink the books of English and French libraries.

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

3

Keys can be used to build link speciﬁcations or can be translated into logical rules to perform data
interlinking. The latter allows to take advantage of logical reasoning [17–19]. Key extraction algorithms
discover either S-keys [5–7] or F-keys [4, 20]. There are two kinds of keys since RDF properties are
multivalued, contrary to relational attributes, which are monovalued. If a set of properties form an S-key
for a class, it is enough that two instances of the class share one value for each of the properties of the key
to infer that they are the same (e.g. email property for the AssistantProfessor class). But if the properties
form an F-key then the instances must share all values (e.g. hasPoem property for the PoemAnthology
class because two different poem anthologies may have a poem in common but will unlikely contain
exactly the same poems).

When datasets are described with different ontologies, alignments must be used, either during the key
extraction process or later when performing data interlinking. For example, the approach proposed in
[5] searches in a source dataset for S-keys over classes which are equivalent to classes in a target dataset
and then selects among the discovered S-keys those composed of properties which are equivalent to
properties of the target dataset.

Link keys generalise the combination of keys and ontology alignments for data interlinking [8, 16].
A link key is a set of pairs of properties that uniquely identify the instances of two classes of two RDF
datasets. For example,

{(cid:104)creator, auteur(cid:105), (cid:104)title, titre(cid:105)} linkkey (cid:104)Book, Livre(cid:105)

states that, if two instances of the classes Book and Livre, respectively, match on values for the properties
creator and auteur, and for the properties title and titre, then they are the same instance. Unlike the
previous key, this link key could be directly used to interlink the books of English and French libraries
without the need of any ontology alignment.

Unlike [5], the key-based approaches to data interlinking proposed in [6, 7] aim to discover S-keys
that hold not only in the source dataset, but in both source and target datasets. It is assumed that the
datasets are described using the same vocabulary, possibly resulting from merging different ontologies
with an alignment, again composed of equivalence correspondences only. Link keys do not require the
properties that compose them to be equal or semantically aligned. In addition, as we will show in this
paper, the kind of keys discovered in [6, 7] correspond to strong link keys, although data interlinking
may be possible with weak link keys (the kind of link keys considered in [8, 16]) when strong link keys
do not exist.

The formal semantics of S-keys and F-keys have been given in [21] using rules, but the combination
of S-keys and F-keys with ontology alignments for data interlinking is not formally addressed. In this
paper, we address it using description logics.

Different approaches to incorporate keys and functional dependencies to description logics have been
proposed. Keys may be treated as a new concept constructor [22, 23] or as global constraints in a separate
key box (KBox) [24–27], which is the option that we follow in this paper. The goal of these approaches
is to study the decidability of reasoning with keys or functional dependencies in speciﬁc description
logics. Here, we do not address automated reasoning with link keys. Instead, we use the formalism
of description logics to provide the semantics of keys and link keys. This allows us to ground their
legitimacy in generating links across RDF datasets. In addition, it gives us the means to compare keys
and link keys on the basis of their entailments and the links they generate.

4

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

3. Preliminaries

This section introduces minimal notions and notations used throughout the entire paper. We assume

that the reader is familiar with the basics of description logics (DLs) [28].

In this paper, ontologies will be the combination of a schema and a dataset, and they will be modelled

as DL knowledge bases.

Deﬁnition 1 (Ontology). An ontology is a knowledge base O = (cid:104)S, D(cid:105) made up of a terminological
box (TBox) S and an assertional box (ABox) D. S and D will be referred to as the schema and dataset
of O.

Thus, a schema is modelled as a set of terminological axioms, i.e. a set of subsumption, equivalence
and disjointness axioms between classes and properties: C1 R C2 and p1 R p2 with R ∈ {(cid:118), (cid:119), ≡, ⊥}.
A dataset is a set of assertions about individuals, i.e. a set of class and property assertions and equality
statements: C(a), p(a1, a2) and a1 ≈ a2.1 Classes, properties and individuals (C1, p1, a1, . . .) deﬁne the
vocabulary of an ontology. Notice that we make no restriction on the language, i.e. the classes and
properties of ontologies may be built with any DL constructor. The semantics of ontologies is inherited
from the model-theoretic semantics of knowledge bases using DL interpretations I = (∆I, ·I).

Alignments relate entities — classes, properties, individuals — that belong to different ontologies [16].
Alignment relations between classes and properties are subsumption, equivalence and disjointness. In
the case of individuals, they are related by equality. Alignment statements between classes and properties
are referred to as correspondences, whereas equality statements in alignments will be called links.

We will also model alignments as knowledge bases. The difference with ontologies is that, in the case
of an alignment, the TBox and ABox use two ontologies’ vocabularies. In addition, the ABox contains
equality statements (links) only.

Deﬁnition 2 (Alignment). Let O = (cid:104)S, D(cid:105) and O(cid:48) = (cid:104)S (cid:48), D(cid:48)(cid:105) be two ontologies. An alignment between
O and O(cid:48) is a knowledge base AO,O(cid:48) = (cid:104)CO,O(cid:48), LO,O(cid:48)(cid:105) where CO,O(cid:48) is composed of class and property
axioms C R D and p R q with R ∈ {(cid:118), (cid:119), ≡, ⊥}, C and p are class and property expressions in O’s
vocabulary and D and q are class and property expressions in O(cid:48)’s vocabulary, and LO,O(cid:48) is composed
of equality statements a ≈ b where a is an individual name in O’s vocabulary and b an individual name
in O(cid:48)’s vocabulary. The axioms in CO,O(cid:48) will be referred to as correspondences and the axioms in LO,O(cid:48)
as links. If no confusion arises, AO,O(cid:48), CO,O(cid:48) and LO,O(cid:48) will be replaced by A, C and L.

Different semantics for alignments may be found in the literature [29, 30]. Here, though, we will
consider the axioms of two ontologies and the correspondences and links of an alignment between them
to be part of one single global ontology. Without loss of generality, we can assume that the vocabularies
of O and O(cid:48) are disjoint.

In what follows, given an ontology O, we will use the letters C and p (possibly with subscripts or
superscripts) to denote class and property expressions of O, respectively, and, in case another ontology
O(cid:48) is considered, we will use D and q for O(cid:48). In this way, C1 R C2 and p1 R p2 will be used as general
axioms in O, while C R D and p R q as general correspondences in an alignment A between O and O(cid:48)
(R ∈ {(cid:118), (cid:119), ≡, ⊥}).

1Notice that “≈” is a symbol of the language, which is interpreted as equality. More speciﬁcally, for any DL interpretation

I, I |= a ≈ b iff aI = bI .

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

5

4. Two kinds of keys in description logics

In order to compare keys and link keys, we start by reformulating the semantics of keys [21] as
description logic axioms. We distinguish between several types of keys which apply in this context.
Instead of S-keys and F-keys, we will speak of in-keys and eq-keys, respectively. The preﬁxes in- and
eq- are shortened forms of intersection and equality. These notations are related to the conditions (1) and
(2) in Deﬁnitions 3 and 4.

4.1. Semantics of keys

In what follows, given a DL interpretation I = (∆I, ·I), a property p, and a domain individual δ ∈
∆I, pI(δ) will denote the set of individuals related to δ through p, i.e. pI(δ) = {η ∈ ∆I : (δ, η) ∈ pI}.

Deﬁnition 3 (in-key). An in-key assertion, or simply an in-key, has the form

({p1, . . . , pk} keyin C)

where p1, . . . , pk are properties and C is a class.

An interpretation I satisﬁes ({p1, . . . , pk} keyin C) if, for any δ, δ(cid:48) ∈ CI,

1 (δ) ∩ pI
pI

1 (δ(cid:48)) (cid:54)= ∅, . . . , pI

k (δ) ∩ pI

k (δ(cid:48)) (cid:54)= ∅ implies δ = δ(cid:48).

Deﬁnition 4 (eq-key). An eq-key assertion, or simply an eq-key, has the form

({p1, . . . , pk} keyeq C)

where p1, . . . , pk are properties and C is a class.

An interpretation I satisﬁes ({p1, . . . , pk} keyeq C) if, for any δ, δ(cid:48) ∈ CI,

1 (δ) = pI
pI

1 (δ(cid:48)) (cid:54)= ∅, . . . , pI

k (δ) = pI

k (δ(cid:48)) (cid:54)= ∅ implies δ = δ(cid:48).2

(1)

(2)

According to Deﬁnition 3, if two instances of a class share at least one value for each of the properties
of an in-key for the class, then we can infer that they are the same instance. This is formalised in
Proposition 1.

Proposition 1. The following holds:

i=1

C(a), {pi(a, ci)}k
C(b), {pi(b, di)}k

i=1
({p1, . . . , pk} keyin C)

|= a ≈ b

(3)

{ci ≈ di}k

i=1

2By pI

i (δ) = pI

i (δ(cid:48)) (cid:54)= ∅ we mean pI

i (δ) = pI

i (δ(cid:48)) and pI

i (δ(cid:48)) (cid:54)= ∅, which implies pI

i (δ) (cid:54)= ∅ (i = 1, . . . , k).

6

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

Proof. This is a direct consequence of Deﬁnition 3: for any interpretation I satisfying all the antecedent
axioms of the entailment, aI and bI will belong to CI and will share one value for each of the properties
of the in-key, hence aI will be equal to bI. (cid:3)

Similarly, according to Deﬁnition 4, given an eq-key for a class and two instances of the class, we can
infer that they are the same instance if they share all values (and at least one) for each of the properties
of the key. However, we need to be sure that all known values indeed are all values that the instances
may have. This is stated in Proposition 2.

Proposition 2. The following holds:

C(a), {pi(a, c1

{{a} (cid:118) ∀pi.{c1

i=1

i ), . . . , pi(a, cri
i , . . . , cri
i ), . . . , pi(b, dri
i=1
({p1, . . . , pk} keyeq C)

i )}k
i }}k
i )}k

i=1

C(b), {pi(b, d1

|= a ≈ b

(4)

{c1

i ≈ d1

i , . . . , cri

i ≈ dri

i }k

i=1

Proof. Let I be an interpretation that satisﬁes all the antecedent axioms of the above entailment. Let
i (aI) for i = 1, . . . , k and
us prove that I satisﬁes a ≈ b too. Since I |= pi(a, cl
l = 1, . . . , ri. Also, since I |= {a} (cid:118) ∀pi.{c1
i (aI) =
i)I}ri
i)I, which implies
{(cl
i (bI) (cid:54)= ∅ since ri (cid:62) 1. Additionally, since I |= C(a)
that pI
and I |= C(b) then aI, bI ∈ CI. Finally, since I |= ({p1, . . . , pk} keyeq C), and we have aI, bI ∈ CI
and pI

i (bI) (cid:54)= ∅ for i = 1 . . . , k, then we can infer that aI = bI, i.e. I |= a ≈ b. (cid:3)

i)I}ri
i (bI). Furthermore, pI

i } then pI
l=1. Now, since I |= cl

l=1. Therefore, pI
i)I = (dl

l=1. Similarly, qI
i (aI) = qI

i (aI) ⊆ {(cl
i ≈ dl

i (bI) = {(dl

i (aI) = qI

i (aI) = qI

i) then (cl

i)I ∈ pI

i , . . . , cri

i then (cl

i)I}ri

Thus, unlike in-keys, eq-keys require a local closed world assumption — represented in Proposition 2
by the axioms {a} (cid:118) ∀pi.{c1
i } (i = 1, . . . , k) — which, even though
it is generally advised to avoid in the context of the semantic web and linked open data, it is also expected
to be made in certain controlled scenarios.

i } and {b} (cid:118) ∀qi.{d1

i , . . . , dri

i , . . . , cri

Notice that Proposition 2 requires the logic to be able to express nominals and value restrictions. All
our results are agnostic of the used logical language but those referring to the use of eq-keys and eq-link
keys for data interlinking.

The semantics of owl:hasKey in OWL2 corresponds to the semantics of in-keys but restricted to being

applied to named instances only (thus excluding blank nodes).

Although in-keys and eq-keys have been introduced separately, it is also possible to consider a hybrid

notion of key.

Deﬁnition 5 (Hybrid key). A key assertion, or simply a key, has the form

({p1, . . . , pk}{q1, . . . , ql} key C)

where p1, . . . , pk and q1, . . . , ql are properties, and C is a class.

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

7

An interpretation I satisﬁes the key ({p1, . . . , pk}{q1, . . . , ql} key C) if, for any δ, δ(cid:48) ∈ CI,

1 (δ) ∩ pI
pI

1 (δ(cid:48)) (cid:54)= ∅, . . . , pI

k (δ) ∩ pI

k (δ(cid:48)) (cid:54)= ∅ and qI

1 (δ) = qI

1 (δ(cid:48)) (cid:54)= ∅, . . . , qI

l (δ) = qI

l (δ(cid:48)) (cid:54)= ∅

implies δ = δ(cid:48).

From here on, an ontology O will be a triple O = (cid:104)S, D, K(cid:105) which, besides the schema S (TBox) and

dataset D (ABox), has as a third component a set of keys K (KBox).

Example 1 below provides examples of in-keys and eq-keys in real RDF datasets.

Example 1 (Insee). Insee is the French institution in charge of collecting and publishing information
about French economy and society. Part of the Insee data is available in the form of RDF triples and can
be downloaded as an RDF dump or queried through a SPARQL endpoint.3 Insee ontologies are available
too. We only consider the Insee data related to administrative districts (COG dataset).

The Insee vocabulary comprises four class names for describing the main administrative divisions in
France: Commune, Arrondissement, Département and Région. Among the properties of these classes,
we ﬁnd the datatype property nom (used to specify the name of an administrative division), the object
property subdivisionDe (to specify that an administrative division is subdivision of another one, e.g. that
the commune of Grenoble is a subdivision of the Isère department) and the datatype property codeINSEE
(which is an identiﬁer for territories, including administrative divisions, and can be thought of as the key
in the Insee database). The property subdivisionDe is declared to be transitive in the Insee ontology. This
fragment of the Insee ontology is depicted in Figure 2.

No owl:hasKey axiom is declared in the Insee ontology. Nevertheless, we have checked the in-key and
eq-key conditions for the properties and classes mentioned before. We have done so in the RDF graph of
Insee extended with the transitivity of subdivisionDe. This generalises to the fully inferred graph as no
other axiom of the Insee ontology may have an impact on the satisﬁability of the examined key axioms.
As expected, the codeINSEE property is an in-key for Commune, Arrondissement, Département and

Région. Formally:

I ∗
Insee |= ({codeINSEE} keyin Commune)
I ∗
Insee |= ({codeINSEE} keyin Arrondissement)
I ∗
Insee |= ({codeINSEE} keyin Département)
I ∗
Insee |= ({codeINSEE} keyin Région)

where I ∗

Insee is the natural DL interpretation of the inferred Insee graph.4

Concerning the property nom, it turns out to be an in-key for Département and Région, but neither for
Commune nor Arrondissement. Indeed, there exist different communes (and arrondissements) sharing
the same name. For instance, Bully may refer to three different communes: Bully in the department of
Loire, Bully in Rhône and Bully in Seine-Maritime. However, there is no pair of communes of the same
department sharing the same name. In fact, nom and subdivisionDe, when put together, form a key for

3http://rdf.insee.fr.
4More speciﬁcally, this is the interpretation whose domain is made up of all IRIs and literals of the Insee graph (there are no

blank nodes), it interprets domain individuals as themselves, and classes and properties as their extensions in the graph.

8

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

the class Commune. The property subdivisionDe, though, must be treated in the sense of eq-keys. This
is because, since subdivisionDe is a transitive property, all French communes share (at least) a value for
subdivisionDe, namely, the Insee entity representing the country France. The same holds for the class
Arrondissement. Formally (note that we use hybrid keys):

I ∗
Insee |= ({nom} keyin Département)
I ∗
Insee |= ({nom} keyin Région)
I ∗
Insee |= ({nom}{subdivisionDe} key Arrondissement)
I ∗
Insee |= ({nom}{subdivisionDe} key Commune)

From here on, we will use the shortcuts Reg, Dep, Arr and Com for the corresponding Insee classes.

4.2. Relations between the different types of keys

Compared to the semantics of S-keys and F-keys deﬁned in [21], the semantics of in-keys corresponds
directly to the semantics of S-keys. This is not the case for eq-keys and F-keys. Every eq-key is an F-key
but not the other way around. The equivalence would hold if condition (2) in Deﬁnition 4 were replaced
by

1 (δ) = pI
pI

1 (δ(cid:48)), . . . , pI

k (δ) = pI

k (δ(cid:48)) implies δ = δ(cid:48).

The prerequisite that the sets of property values must be non-empty enables to consider in-keys as a
subset of eq-keys (which does not hold between S-keys and F-keys). This result is stated in Proposition 3.

Proposition 3. ({p1, . . . , pk} keyin C) |= ({p1, . . . , pk} keyeq C)

Proof. Let I be an interpretation such that I |= ({p1, . . . , pk} keyin C). We have to prove that I |=
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). We have to prove
({p1, . . . , pk} keyeq C). Let δ, δ(cid:48) ∈ CI such that pI
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k).
i (δ) and pI
that δ = δ(cid:48). Since pI
So we have δ, δ(cid:48) ∈ CI and pI
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). Since I |= ({p1, . . . , pk} keyin C), then
δ = δ(cid:48). (cid:3)

i (δ(cid:48)) are equal and non-empty, then pI

i (δ) = pI

i (δ) ∩ pI

i (δ) ∩ pI

The converse of Proposition 3 is not true, i.e. there are eq-keys that are not in-keys. Indeed, consider the
interpretation deﬁned by (aI, cI), (aI, dI), (bI, cI) ∈ pI and aI (cid:54)= bI, cI (cid:54)= dI. Then I |= (p keyeq (cid:62))
whereas I (cid:54)|= (p keyin (cid:62)). The converse is true if the key is made up of functional properties, as stated
in Proposition 4. Notice that it is possible to deﬁne a functional property as a property p such that for
any interpretation I = (∆I, ·I) and for any δ ∈ ∆I then |pI(δ)| (cid:54) 1. Indeed, p is functional if and only
for any interpretation I = (∆I, ·I) and for any δ ∈ ∆I, there exists one or no element related to δ via
pI, which is equivalent to say that |pI(δ)| (cid:54) 1.

Proposition 4. If p1, . . . , pk are functional, then

({p1, . . . , pk} keyeq C) |= ({p1, . . . , pk} keyin C)

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

9

i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). Since pi is functional, then |pI

Proof. Let I be an interpretation such that I |= ({p1, . . . , pk} keyeq C). Let δ, δ(cid:48) ∈ CI such that
i (δ(cid:48))| (cid:54) 1, but, given
pI
i (δ) ∩ pI
that their intersection is not empty, then |pI
i (δ(cid:48))| = 1. Thus, they are equal and not
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). Since I |= ({p1, . . . , pk} keyeq C) then we can infer that
empty, i.e. pI
δ = δ(cid:48). This proves that I |= ({p1, . . . , pk} keyin C). (cid:3)

i (δ)| = 1 and |pI

i (δ)| (cid:54) 1 and |pI

i (δ) = pI

Proposition 5 shows basic properties of in-keys and eq-keys that will be later used in the proofs of other
theorems. In certain occasions, we will write ({pi}k
i=1 keyx C) instead of ({p1, . . . , pk} keyx C) (x ∈
{in, eq}) to shorten too long expressions. Property (5) may be thought of as a version of Armstrong’s
reﬂexivity axiom for functional dependencies in relational databases [31]. It is not surprising that it
corresponds to one of these axioms as it deals with sets of properties. This is not the case of the other
properties, as they deal with constructors not found in the relational model. Properties (6), (7) and (8)
specify how keys behave with subsumption, intersection and union of classes, respectively. Properties
(9) and (10) specify how keys behave with subsumption and equivalence of properties. Interestingly, (9)
does not hold for eq-keys.

Proposition 5. The following holds:

({pi}k

i=1 keyx C) |= ({pi}k+1

i=1 keyx C)

({pi}k

i=1 keyx C), C (cid:119) D |= ({pi}k
({pi}k
i=1 keyx C) |= ({pi}k
i=1 keyx C (cid:116) D) |= ({pi}k
i=1 |= ({qi}k
i=1 |= ({qi}k

i=1 keyin C), {pi (cid:119) qi}k
i=1 keyx C), {pi ≡ qi}k

({pi}k

({pi}k
({pi}k

i=1 keyx D)

i=1 keyx C (cid:117) D)

i=1 keyx C)

i=1 keyin C)

i=1 keyx C)

(5)

(6)

(7)

(8)

(9)

(10)

with x ∈ {in, eq}.

Proof. Properties (5) and (6) follow directly from Deﬁnitions 3 and 4, and Properties (7) and (8) are
direct consequences of property (6).

Let us prove (9). Let I be an arbitrary DL interpretation such that I |= ({p1, . . . , pk} keyin C) and
I |= pi (cid:119) qi (i = 1, . . . , k). We have to prove that I |= ({q1, . . . , qk} keyin C). Let δ, δ(cid:48) ∈ CI such
that qI
i (δ(cid:48)),
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). This together with I |=
and, since qI
({p1, . . . , pk} keyin C) implies δ = δ(cid:48). Therefore, I |= ({q1, . . . , qk} keyin C).

i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). Since I |= pi (cid:119) qi then qI

i (δ(cid:48)) (cid:54)= ∅, then pI

i (δ) and qI

i (δ(cid:48)) ⊆ pI

i (δ) ⊆ pI

i (δ) ∩ pI

i (δ) ∩ qI

i (δ) ∩ qI

Property (10) can be proven analogously. (cid:3)

In the following section, we establish when it is legitimate to combine in-keys and eq-keys with

alignments for data interlinking.

5. Data interlinking with keys and alignments

So far, we have considered keys independently from their use for data interlinking. Keys are able to
identify duplicate resources within the same dataset and links between resources from different datasets

10

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

described using the same ontologies. But as soon as the datasets do not share the same schema, keys
alone are not enough for performing data interlinking, and alignments are required.

In this section, we uncover the implicit role of alignments in the process of data interlinking with keys.
We show that data interlinking can be expressed as a direct logical consequence of the semantics of keys
and alignments. We also highlight the need for completion when interlinking data with eq-keys.

Data interlinking can be formulated as an inference problem: for two given ontologies O = (cid:104)S, D, K(cid:105)
and O(cid:48) = (cid:104)S (cid:48), D(cid:48), K(cid:48)(cid:105) equipped with keys and an alignment A = (cid:104)C, L(cid:105) between O and O(cid:48), the problem
is to check, for any pair of individual names a and b of O and O(cid:48), respectively, if the following entailment
holds:

O, O(cid:48), A |= a ≈ b

This formulation also includes the particular case when O and O(cid:48) share the same schema, as in this case
the set of correspondences is empty, i.e. A = (cid:104)∅, L(cid:105).

In the following, we give conditions on the schemas S and S (cid:48), the datasets D and D(cid:48), the set of class
and property correspondences C, and the set of (known) links L, that, in the presence of a key κ ∈ K, are
sufﬁcient for inferring a (new) link a ≈ b. These conditions change depending on whether κ is an in-key
or an eq-key, as speciﬁed in Theorem 1 and Theorem 2 below. These two theorems provide the logical
grounds of data interlinking with keys and alignments.

Theorem 1. Let O = (cid:104)S, D, K(cid:105) and O(cid:48) = (cid:104)S (cid:48), D(cid:48), K(cid:48)(cid:105) be two ontologies and A = (cid:104)C, L(cid:105) and alignment
between O and O(cid:48) such that

– ({p1, . . . , pk} keyin C) ∈ K and
– {C (cid:119) D} ∪ {pi (cid:119) qi}k
i=1 ⊆ C.

Then, for any pair of individual names a and b of O and O(cid:48), respectively, if

– {C(a)} ∪ {pi(a, ci)}k
– {D(b)} ∪ {qi(b, di)}k
– {ci ≈ di}k

i=1 ⊆ L.
then O, O(cid:48), A |= a ≈ b.

i=1 ⊆ D,
i=1 ⊆ D(cid:48), and

Proof. Notice that C (cid:119) D and D(b) entail C(b), and that pi (cid:119) qi and qi(b, di) entail pi(b, di). Then, the
statement follows from Proposition 1. (cid:3)

Theorem 1 logically grounds data interlinking with in-keys and ontology alignments: if we know that
the properties p1, . . . , pk are an in-key for a class C in O, and that, according to an alignment A, C
subsumes a class D of O(cid:48) and p1, . . . , pk pairwise subsume properties q1, . . . , qk of O(cid:48), then, for every
pair of instances a of C and b of D, the key will generate a same-as link between a and b if, for all
i ∈ {1, . . . , k}, a has for pi a value ci which is equal to a value di that b has for qi.

Theorem 2 provides the logical basis of data interlinking with eq-keys and alignments. Note that
unlike Theorem 1, p1, . . . , pk are required to be pairwise equivalent to q1, . . . , qk. Moreover, in order to
generate a same-as link between a and b, we need to know all the values that a and b may have for pi
and qi, respectively, and that these values are the same. This local completeness is expressed as axioms
in the ontology schemas S and S (cid:48).

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

11

Theorem 2. Let O = (cid:104)S, D, K(cid:105) and O(cid:48) = (cid:104)S (cid:48), D(cid:48), K(cid:48)(cid:105) be two ontologies and A = (cid:104)C, L(cid:105) an alignment
between O and O(cid:48) such that

– ({p1, . . . , pk} keyeq C) ∈ K and
– {C (cid:119) D} ∪ {pi ≡ qi}k

i=1 ⊆ C.

Then, for any pair of individual names a and b of O and O(cid:48), respectively, if

– {C(a)} ∪

– {{a} (cid:118) ∀pi.{c1

– {D(b)} ∪

k
(cid:83)
i=1

k
(cid:83)
i=1

{pi(a, c j

i )}ri
i , . . . , cri
{qi(b, d j

i }}k
i )}ri
i , . . . , dri

i }}k

j=1 ⊆ D,

i=1 ⊆ S,

j=1 ⊆ D(cid:48),

– {{b} (cid:118) ∀qi.{d1

i=1 ⊆ S (cid:48), and

–

k
(cid:83)
i=1

{c j

i ≈ d j

i }ri

j=1 ⊆ L.

then O, O(cid:48), A |= a ≈ b.

Proof. Notice that C (cid:119) D and D(b) entail C(b), and that pi ≡ qi entails pi (cid:119) qi which, together with
qi(b, d j
i },
entails {b} (cid:118) ∀pi.{d1

i ). Also, pi ≡ qi entails pi (cid:118) qi which, along with {b} (cid:118) ∀qi.{d1

i }. Then, the statement follows from Proposition 2. (cid:3)

i ), entails pi(b, d j

i , . . . , dri

i , . . . , dri

Notice that in both theorems we only address the case when property values are individuals, i.e. when
keys are composed of object properties only. The case when property values are literals, i.e. keys with
datatype properties, does not make a difference for our purpose (although, in this case, the comparison
of property values is based on equality and not on an initial set of known same-as links L). Also, the
case when instances are related to the same individual name — e.g. p(a, c), q(b, c) — is covered by the
theorem too, as it is enough to add links of type c ≈ c to L.

Another remark on Theorems 1 and 2 is that only one key of O and no key of O(cid:48) is needed to infer
i=1 is guaranteed to be an

links. Actually, under the assumptions of the theorems, by Proposition 5, {q}k
in-key (in Theorem 1) or an eq-key (in Theorem 2) for the class D.

Even though Theorems 1 and 2 are not difﬁcult to prove, they highlight some peculiarities of data
interlinking with keys and alignments that have not received attention in the literature: the fact that
equivalence of properties is not required for interlinking with in-keys, and that local completeness is
necessary for interlinking with eq-keys.

It is possible to provide semantic versions of Theorems 1 and 2 in which the antecedent axioms are not
asserted in the ontologies and alignments but inferred from them (e.g. O, O(cid:48), A |= ({p1, . . . , pk} keyin C)
instead of ({p1, . . . , pk} keyin C) ∈ K). We have decided to present the asserted versions to stress the
nature of every axiom (mapping, data, schema knowledge or links).

We ﬁnish this section with the deﬁnition of the link set generated by a key.

Deﬁnition 6 (Link set generated by a key). Let O and O(cid:48) be two ontologies. Let A be an alignment
between O and O(cid:48). Let κ be a key. The set of links between O and O(cid:48) generated by κ under A is deﬁned

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

12

as

LO,O(cid:48),A

κ

= {a ≈ b : a is an individual in O ∧ b is an individual in O(cid:48)

∧ O, O(cid:48), A, κ |= a ≈ b ∧ O, O(cid:48), A (cid:54)|= a ≈ b}

In the following sections, we will introduce link keys and formalise data interlinking with link keys
in the same manner. We will then show that data interlinking with link keys is more general than data
interlinking with keys and alignments.

6. Link keys

We deﬁne three different types of link keys: weak, plain and strong link keys. They all allow to ﬁnd
links between two datasets, but they differ on whether they allow the existence of different resources
(duplicates) satisfying the key conditions within each of the datasets: weak link keys allow them; plain
link keys allow them only among the non-linked resources; strong link keys disallow them all.

This distinction provides us with the right framework in which to compare link keys and keys and
alignments: keys and alignments correspond to strong link keys (Theorem 5), though data interlinking
may be possible with weak link keys when strong link keys do not exist (Theorem 6). Plain link keys ﬁll
the gap between weak and strong link keys.

The distinction between weak, plain and strong link keys is important in practice too: weak link keys
can be used for data interlinking; strong link keys can be used for both data interlinking and duplicate
detection, i.e. for discovering same-as statements between individuals of the same dataset; plain link
keys lie between weak and plain link keys, as they can be used for data interlinking and for ﬁnding
duplicates among the linked individuals.

6.1. Semantics of link keys

The semantics of link keys considered in [32] is reproduced in Deﬁnition 7. It is natural to extend this
semantics to eq-keys too, and we do so in Deﬁnition 8. These kinds of link keys will be referred to as
weak link keys.

Deﬁnition 7 (Weak in-link key). A weak in-link key assertion, or simply a weak in-link key, has the form

({(cid:104)p1, q1(cid:105), . . . , (cid:104)pk, qk(cid:105)} linkkeyw

in (cid:104)C, D(cid:105))

where p1, . . . , pk and q1, . . . , qk are properties and C and D are classes.

An interpretation I satisﬁes ({(cid:104)p1, q1(cid:105), . . . , (cid:104)pk, qk(cid:105)} linkkeyw

in (cid:104)C, D(cid:105)) if, for any δ ∈ CI and η ∈ DI,

1 (δ) ∩ qI
pI

1 (η) (cid:54)= ∅, . . . , pI

k (δ) ∩ qI

k (η) (cid:54)= ∅ implies δ = η.

Note that the above deﬁnition does not specify to which ontology vocabulary the classes and properties

of a link key belong. In practice, though, the classes C and D, and the properties {pi}k
i=1
belong to different ontology schemas, and the instances of C and D to different datasets. This will
become explicit in Section 7 when we formalise data interlinking with link keys. In addition, note that

i=1 and {qi}k

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

13

the deﬁnition does not say that the properties and classes of a link key are semantically aligned, neither
via an equivalence relation nor via a subsumption relation.

Weak eq-link keys are deﬁned below.

Deﬁnition 8 (Weak eq-link key). A weak eq-link key assertion, or simply a weak eq-link key, has the
form

({(cid:104)p1, q1(cid:105), . . . , (cid:104)pk, qk(cid:105)} linkkeyw

eq (cid:104)C, D(cid:105))

where p1, . . . , pk and q1, . . . , qk are properties and C and D are classes.

An interpretation I satisﬁes ({(cid:104)p1, q1(cid:105), . . . , (cid:104)pk, qk(cid:105)} linkkeyw

in (cid:104)C, D(cid:105)) if, for any δ ∈ CI and η ∈ DI,

1 (δ) = qI
pI

1 (η) (cid:54)= ∅, . . . , pI

k (δ) = qI

k (η) (cid:54)= ∅ implies δ = η.

It is worth noting that every key can be expressed as a link key. Indeed, ({p1, . . . , pk} keyx C) is

equivalent to ({(cid:104)p1, p1(cid:105), . . . , (cid:104)pk, pk(cid:105)} linkkeyw

x (cid:104)C, C(cid:105)), with x ∈ {in, eq}.

Weak link keys are called weak because they are not necessarily composed of keys. Instead, strong
link keys, introduced below, always embed two keys. For this reason, they are closely related to keys and
alignments, as we formally state in Theorem 5. We only give the deﬁnition of strong in-link keys, as
strong eq-link keys can be deﬁned analogously.

Deﬁnition 9 (Strong in-link key). A strong in-link key assertion, or simply a strong in-link key, has the
form

({(cid:104)p1, q1(cid:105), . . . , (cid:104)pk, qk(cid:105)} linkkeys

in (cid:104)C, D(cid:105))

where p1, . . . , pk and q1, . . . , qk are properties and C and D are classes.

An interpretation I satisﬁes ({(cid:104)p1, q1(cid:105), . . . , (cid:104)pk, qk(cid:105)} linkkeys

in (cid:104)C, D(cid:105)) if

(1) I |= ({(cid:104)p1, q1(cid:105), . . . , (cid:104)pk, qk(cid:105)} linkkeyw
(2) I |= ({p1, . . . , pk} keyin C)
(3) I |= ({q1, . . . , qk} keyin D)

in (cid:104)C, D(cid:105))

Both strong and weak link keys enable to ﬁnd links between two different datasets, but strong link keys
do more. Indeed, since the properties of a strong link key are keys for the classes separately then they
can be used for ﬁnding same-as statements between individuals of the same dataset, i.e. for identifying
duplicates.

Finally, we introduce plain link keys, which are intermediate between weak and strong link keys. Plain
link keys allow to ﬁnd links and to identify duplicates of the instances that are linked. As before, we
only give the deﬁnition of a plain in-link key, since plain eq-link keys are deﬁned analogously.

Deﬁnition 10 (Plain in-link key). A plain in-link key assertion, or simply a plain in-link key, has the
form

({(cid:104)p1, q1(cid:105), . . . , (cid:104)pk, qk(cid:105)} linkkeyp

in (cid:104)C, D(cid:105))

14

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

where p1, . . . , pk and q1, . . . , qk are properties and C and D are classes.

An interpretation I satisﬁes ({(cid:104)p1, q1(cid:105), . . . , (cid:104)pk, qk(cid:105)} linkkeyp

in (cid:104)C, D(cid:105)) if, for any δ ∈ CI and η ∈ DI,

1 (δ) ∩ qI
pI

1 (η) (cid:54)= ∅, . . . , pI

k (δ) ∩ qI

k (η) (cid:54)= ∅

implies:

(1) δ = η,
(2) for any δ(cid:48) ∈ CI, pI
(3) for any η(cid:48) ∈ DI, qI

1 (δ) ∩ pI
1 (η) ∩ qI

1 (δ(cid:48)) (cid:54)= ∅, . . . , pI
1 (η(cid:48)) (cid:54)= ∅, . . . , qI

k (δ) ∩ pI
k (η) ∩ qI

k (δ(cid:48)) (cid:54)= ∅ implies δ = δ(cid:48),
k (η(cid:48)) (cid:54)= ∅ implies η = η(cid:48).

D

a3(cid:72)

≈

c3

p

p

is-a

is-a

C

is-a

is-a

c1

a1

≈

≈

(cid:47) d1

b1

c2

≈

≈

d2

p

p

p

q

q

q

is-a

is-a

D

is-a

is-a

D(cid:48)

b3

q

q

d3

≈

a4

a2

b2

b4

Fig. 1. Two datasets and links generated depending on the type of link keys (double=weak, dashed=plain, waved=strong).

Figure 1 shows the differences between weak, plain and strong link keys on two datasets D and D(cid:48):

D = {p(a1, c1), p(a1, c2), C(a1), p(a2, c2), C(a2), C(a3), p(a3, c3), C(a4), p(a4, c3)}
D(cid:48) = {q(b1, d1), q(b1, d2), D(b1), q(b2, d2), D(b2), D(b3), q(b3, d3), D(b4), q(b4, d3)}

with the initial set of links L = {c1 ≈ d1}.
Given the in-link key: ({(cid:104)p, q(cid:105)} linkkeyy

in (cid:104)C, D(cid:105)). Depending on the value of y, it will generate:

weak: a1 ≈ b1 (double-line arrow),
plain: plus a1 ≈ a2 and b1 ≈ b2 (dashed arrows),
strong: plus a3 ≈ a4 and b3 ≈ b4 (wave arrows).

(cid:111)
(cid:111)
(cid:47)
(cid:72)
(cid:22)
(cid:22)
(cid:31)
(cid:31)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:127)
(cid:127)
(cid:79)
(cid:79)
(cid:107)
(cid:115)
(cid:43)
(cid:51)
(cid:86)
(cid:86)
(cid:8)
(cid:8)
(cid:15)
(cid:15)
(cid:79)
(cid:79)
(cid:31)
(cid:31)
(cid:72)
(cid:72)
(cid:21)
(cid:21)
(cid:15)
(cid:15)
(cid:127)
(cid:127)
(cid:86)
(cid:86)
(cid:9)
(cid:9)
(cid:63)
(cid:63)
(cid:79)
(cid:79)
(cid:95)
(cid:95)
(cid:79)
(cid:79)
(cid:79)
(cid:79)
(cid:63)
(cid:63)
(cid:79)
(cid:79)
(cid:95)
(cid:95)
M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

15

The question may be raised whether it is justiﬁed to link resources by key-like conditions when these
conditions are not considered as keys (as in weak and plain link keys). This is for the same reason that
in some context it may be enough to call people by their ﬁrst name (e.g. in a nuclear family), in some
another to call them by their last name (e.g. in a student class), and yet in other contexts, ﬁrst name and
last name may not be sufﬁcient and birth date and birth place have to be used too (e.g. in a country).
Here, the context is provided by what belongs to both datasets. It is not necessary that such a link key
exists (there may be two students with the same last name in a class), but sometimes it does. In such
cases, there would be no reason to prevent using it.

As it was done for keys in Deﬁnition 5, it is possible to deﬁne hybrid weak, plain and strong link keys

by bringing together the in- and eq-conditions:

({(cid:104)pi, qi(cid:105)}k

i=1{(cid:104)r j, s j(cid:105)}l

j=1 linkkeyy (cid:104)C, D(cid:105))

with y ∈ {w, p, s}.

Alignments may be naturally extended to include a set of link keys. From here on, given two ontologies
O and O(cid:48) equipped with keys, an alignment A between O and O(cid:48) will be a triple A = (cid:104)C, L, LK(cid:105) which,
in addition to a set of class and property correspondences C and a link set L, has a set LK of link keys
between the vocabularies of O and O(cid:48) as a third component.
Below we give examples of link keys in real datasets.

Example 2 (Insee-IGN). The Insee dataset includes links to the IGN dataset (French National Geo-
graphic Institute).5 There exist owl:sameAs links between the resources representing the French com-
munes, arrondissements, departments and regions, gathered together in the two datasets using the same
class names. These links can be found by comparing the Insee codes, which are declared in both datasets
— using the ins:codeINSEE property in the Insee dataset and ign:numInsee in the IGN dataset.6 The con-
sidered fragment of the IGN ontology is depicted in Figure 2.

We have checked the different link key conditions for the property pair (cid:104)ins:codeINSEE, ign:numInsee(cid:105)
on the union of the Insee and IGN datasets taking into account the existing owl:sameAs links. They
are strong in-link keys for the class pairs (cid:104)ins:Com, ign:Com(cid:105), (cid:104)ins:Arr, ign:Arr(cid:105), (cid:104)ins:Dép, ign:Dép(cid:105) and
(cid:104)ins:Rég, ign:Rég(cid:105). Formally:

I ∗ |= ({(cid:104)ins:codeINSEE, ign:numInsee(cid:105)} linkkeys
I ∗ |= ({(cid:104)ins:codeINSEE, ign:numInsee(cid:105)} linkkeys
I ∗ |= ({(cid:104)ins:codeINSEE, ign:numInsee(cid:105)} linkkeys
I ∗ |= ({(cid:104)ins:codeINSEE, ign:numInsee(cid:105)} linkkeys

in (cid:104)ins:Com, ign:Com(cid:105))
in (cid:104)ins:Arr, ign:Arr(cid:105))
in (cid:104)ins:Dép, ign:Dép(cid:105))
in (cid:104)ins:Rég, ign:Rég(cid:105))

where I ∗ is a canonical interpretation of the RDF graph resulting from the union of the Insee and IGN
datasets whose linked individuals are merged.

Let us consider the other properties of Example 1. The property rdfs:label is used in the IGN dataset in
the same way as ins:nom is used in the Insee dataset. Instead of ins:subdivisionDe, however, IGN uses the
three properties ign:arr, ign:dpt and ign:region to declare the arrondissement, department and region an

5http://data.ign.fr
6ign is bound to the namespace http://data.ign.fr/def/geoﬂa#.

16

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

ins:TerritoireAdministratif

ins:nom

ins:codeINSEE

ins:subdivisionDe

ins:Commune

ins:Arrondissement

ins:Département

ins:Région

≡

(cid:118)

≡

≡

≡

≡

≡

(cid:119)

(cid:119)

ign:UnitéAdministrative

rdfs:label

ign:numInsee

ign:Commune

ign:arr

ign:Arrondissement

ign:dpt

ign:Département

ign:Région

Fig. 2. Fragments of the Insee and IGN ontologies and their alignment.

administrative unit belongs to. We have checked the different link key conditions for the combinations of
these properties in the scope of the class pairs (cid:104)ins:Com, ign:Com(cid:105), (cid:104)ins:Arr, ign:Arr(cid:105), (cid:104)ins:Dép, ign:Dép(cid:105)
and (cid:104)ins:Rég, ign:Rég(cid:105). This has been performed in the graph resulting from the union of the Insee graph,
extended by transitivity of subdivisionDe, and the IGN graph, and again considering the owl:sameAs
links. This generalises to the fully inferred RDF graph, as no other axiom of neither the Insee ontology
nor the IGN ontology may have an impact on the satisﬁability of the examined link key axioms. As
one would expect, the property pair (cid:104)ins:nom, rdfs:label(cid:105) is a strong in-link key for (cid:104)ins:Dép, ign:Dép(cid:105)
and (cid:104)ins:Rég, ign:Rég(cid:105). The property pairs (cid:104)ins:subdivisionDe, ign:arr(cid:105) and (cid:104)ins:subdivisionDe, ign:dpt(cid:105)
with (cid:104)ins:nom, rdfs:label(cid:105) constitute weak (and plain) in-link keys for the class pairs (cid:104)ins:Com, ign:Com(cid:105)
and (cid:104)ins:Arr, ign:Arr(cid:105), respectively. They are not strong link keys because, as explained in Example 1,
subdivisionDe must be used as an eq-key. They are not eq-link keys either because ign:arr (as well as
ign:dpt) refers to a single administrative unit, though subdivisionDe refers to several administrative units
due to transitivity. Formally:

I ∗ |= ({(cid:104)ins:nom, rdfs:label(cid:105), (cid:104)ins:subdivisionDe, ign:arr(cid:105)} linkkeyw
I ∗ |= ({(cid:104)ins:nom, rdfs:label(cid:105), (cid:104)ins:subdivisionDe, ign:dpt(cid:105)} linkkeyw
I ∗ |= ({(cid:104)ins:nom, rdfs:label(cid:105)} linkkeys
I ∗ |= ({(cid:104)ins:nom, rdfs:label(cid:105)} linkkeys

in (cid:104)ins:Dép, ign:Dép(cid:105))
in (cid:104)ins:Rég, ign:Rég(cid:105))

in (cid:104)ins:Com, ign:Com(cid:105))
in (cid:104)ins:Arr, ign:Arr(cid:105))

where I ∗ is a canonical interpretation of the aforementioned RDF graph whose linked individuals are
merged.

Obviously, the above link keys could be used for rediscovering the links.

At present, there exist tools for discovering weak in-link keys [8] and hybrid weak link keys [9].

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

17

6.2. Relations between different link keys

Below, we provide theoretical results stating the relations between the different kinds of link keys.
Propositions 6 and 7 are the counterparts of Propositions 3 and 4 for link keys and can be proven simi-
larly.

Proposition 6. The following holds:

({(cid:104)pi, qi(cid:105)}k

i=1 linkkeyy

in (cid:104)C, D(cid:105)) |= ({(cid:104)pi, qi(cid:105)}k

i=1 linkkeyy

eq (cid:104)C, D(cid:105))

with y ∈ {w, p, s}.

Proposition 7. If p1, . . . , pk and q1, . . . , qk are functional then

({(cid:104)pi, qi(cid:105)}k

i=1 linkkeyy

eq (cid:104)C, D(cid:105)) |= ({(cid:104)pi, qi(cid:105)}k

i=1 linkkeyy

in (cid:104)C, D(cid:105))

with y ∈ {w, p, s}.

Proposition 8 shows the relations between weak link keys, plain link keys and strong link keys: a
strong link key is always a plain link key, which is always a weak link key. Interestingly, there is no
distinction between weak eq-link keys and plain eq-link keys. This is due to the transitivity of equality.

Proposition 8. The following holds:

({(cid:104)pi, qi(cid:105)}k
({(cid:104)pi, qi(cid:105)}k
({(cid:104)pi, qi(cid:105)}k

i=1 linkkeys
i=1 linkkeyp
i=1 linkkeyw

x (cid:104)C, D(cid:105)) |= ({(cid:104)pi, qi(cid:105)}k
x (cid:104)C, D(cid:105)) |= ({(cid:104)pi, qi(cid:105)}k
eq (cid:104)C, D(cid:105)) |= ({(cid:104)pi, qi(cid:105)}k

i=1 linkkeyp
i=1 linkkeyw
i=1 linkkeyp

x (cid:104)C, D(cid:105))

x (cid:104)C, D(cid:105))

eq (cid:104)C, D(cid:105))

with x ∈ {in, eq}.

Proof. The ﬁrst two propositions follow directly from the deﬁnitions of link keys. We prove the validity
of the third one. Let I be a DL interpretation such that I |= ({(cid:104)pi, qi(cid:105)}k
eq (cid:104)C, D(cid:105)), and let us
i=1 linkkeyp
prove that I |= ({(cid:104)pi, qi(cid:105)}k
i (η) (cid:54)= ∅
(i = 1, . . . , k). Since I |= ({(cid:104)pi, qi(cid:105)}k
i (δ) =
i (δ(cid:48)) =
pI
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). From pI
qI
i (η) (cid:54)= ∅ (i = 1, . . . , k). This together with δ(cid:48) ∈ CI, η ∈ DI and I |= ({(cid:104)pi, qi(cid:105)}k
eq (cid:104)C, D(cid:105))
implies δ(cid:48) = η, and, since δ = η, then δ = δ(cid:48). The last condition of plain eq-link keys can be proven
analogously. (cid:3)

eq (cid:104)C, D(cid:105)). Let δ ∈ CI and η ∈ DI be such that pI
i=1 linkkeyw

eq (cid:104)C, D(cid:105)), then δ = η. Now, let δ(cid:48) ∈ CI with pI
i (δ(cid:48)) (cid:54)= ∅, we can infer that pI

i (η) (cid:54)= ∅ and pI

i=1 linkkeyw

i=1 linkkeyw

i (δ) = pI

i (δ) = qI

i (δ) = qI

In the following section, we establish when it is legitimate to use link keys for data interlinking.

18

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

7. Data interlinking with link keys

Theorems 3 and 4 give the logical foundations of data interlinking with weak in-link keys and eq-link
keys, respectively. Their proofs follow the same ideas as the proofs of Theorems 1 and 2 and are omitted.

Theorem 3. Let O = (cid:104)S, D, K(cid:105) and O(cid:48) = (cid:104)S (cid:48), D(cid:48), K(cid:48)(cid:105) be two ontologies. Let A = (cid:104)C, L, LK(cid:105) be an
alignment between O and O(cid:48) such that

– ({(cid:104)p1, q1(cid:105), . . . , (cid:104)pk, qk(cid:105)} linkkeyw

in (cid:104)C, D(cid:105)) ∈ LK.

Then, for any pair of individual names a and b of O and O(cid:48), respectively, if

– {C(a)} ∪ {pi(a, ci)}k
– {D(b)} ∪ {qi(b, di)}k
– {ci ≈ di}k

i=1 ⊆ L
then O, O(cid:48), A |= a ≈ b.

i=1 ⊆ D,
i=1 ⊆ D(cid:48), and

Theorem 3 provides the logical basis of data interlinking with weak in-link keys: if we know that the
property pairs (cid:104)p1, q1(cid:105), . . . , (cid:104)pk, qk(cid:105) are a weak in-link key for the class pair (cid:104)C, D(cid:105), then, for every pair
of instances a of C and b of D, the link key will generate a same-as link between a and b if, for every
i ∈ {1, . . . , k}, a has for pi a value ci which is equal to a value di that b has for qi.

The counterpart of Theorem 3 for weak eq-link keys is Theorem 4. In this case, to generate a same-as
link between a and b, we need to know all the values that a and b have for pi and qi, respectively, and
that these values are the same. This local completeness is expressed as axioms in the ontology schemas
S and S (cid:48).

Theorem 4. Let O = (cid:104)S, D, K(cid:105) and O(cid:48) = (cid:104)S (cid:48), D(cid:48), K(cid:48)(cid:105) be two ontologies. Let A = (cid:104)C, L, LK(cid:105) be an
alignment between O and O(cid:48) such that

– ({(cid:104)p1, q1(cid:105), . . . , (cid:104)pk, qk(cid:105)} linkkeyw

eq (cid:104)C, D(cid:105)) ∈ LK.

Then, for any pair of individual names a and b of O and O(cid:48), respectively, if

j=1 ⊆ D,

i=1 ⊆ S,
j=1 ⊆ D(cid:48),

– {C(a)} ∪

k
(cid:83)
i=1

k
(cid:83)
i=1

{pi(a, c j
i )}ri
i , . . . , cri
i }}k
{qi(b, d j
i )}ri
i , . . . , dri
i }}k
j=1 ⊆ L

– {{a} (cid:118) ∀pi.{c1

– {D(b)} ∪

– {{b} (cid:118) ∀qi.{d1
i ≈ d j
i }ri

{c j

–

k
(cid:83)
i=1

i=1 ⊆ S (cid:48), and

then O, O(cid:48), A |= a ≈ b.

Theorems 3 and 4 show that, unlike keys, weak link keys do not need mappings between classes and
properties to perform data interlinking. In addition, since, by Proposition 8, any plain or strong link key
is a weak link key, Theorems 3 and 4 hold for strong and plain link keys too.

Below we give the deﬁnition of the link set generated by a link key. It applies to all types of link keys.

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

19

Deﬁnition 11 (Link set generated by a link key). Let O and O(cid:48) be two ontologies. Let A be an alignment
between O and O(cid:48). Let λ be a link key. The set of links between O and O(cid:48) generated by λ under A is

LO,O(cid:48),A

λ

= {a ≈ b : a is an individual in O ∧ b is an individual in O(cid:48)

∧ O, O(cid:48), A, λ |= a ≈ b ∧ O, O(cid:48), A (cid:54)|= a ≈ b}

Strong link keys generate more equality statements than plain link keys, which generate more than
weak link keys. Logically speaking, it is justiﬁed by the fact that the more constraining a link key is, the
less models it has, and, thus, the more logical consequences follow from it. Dually, when searching for
link keys, it will be easier to search for weak link keys than plain link keys, which will be easier than
searching for strong link keys. This is because, in each case, more constraints need to be satisﬁed.

Therefore, the manipulation of link keys is delicate: the stronger a link key is, the more difﬁcult to
extract it, but the more equality statements it will generate. Furthermore, weak link keys may exist when
plain and strong link keys do not. In such cases, data interlinking will only be possible with weak link
keys. In contrast, duplicate detection inside datasets is only possible with plain or strong link keys.

The generation of links from a link key based on Theorems 3 and 4 is reasonably easy. It may be
achieved by using speciﬁc tools such as Linkex [33], by transforming link keys into SPARQL queries
(available from the Alignment API [34]) or by expressing them as (boolean) linkage rules to be executed
in speciﬁc platforms such as SILK [11, 12] or LIMES [13]. However, these latter platforms do not
seem to support the comparison of sets of property values, thus the direct translation of eq-link keys
is not possible. The natural extension of this approach, taking into account full reasoning, will require
developing speciﬁc provers.

Now that we have formally deﬁned how to interlink data with keys and link keys independently of

each other, we are in position to compare them.

8. Relation between keys and link keys

Keys and link keys are data interlinking devices that we have developed so far in a parallel manner.
One then may expect that their application always results in the generation of the same links. We are
now able to formally establish the relation between keys and link keys, and to show that, although there
may be data interlinking scenarios in which they will return the same links, this will not always be the
case.

This section starts by studying the relation between keys and link keys as description logic axioms
(§8.1). Theorem 5 states the correspondence between strong link keys and keys and alignments. This
correspondence no longer holds for weak link keys (Theorem 6). We also study the impact of these
results on the generation of links (§8.2): Theorems 7 and 8 show that the links generated by a strong
link key are the same as the links generated by its corresponding keys and proper alignments. There are
cases, though, in which it is possible to generate links with weak link keys while it is not possible with
keys and alignments.

8.1. Logical relations between keys and link keys

The theorems presented here are consequences of stronger results included in Appendix A. We have
decided to not include the latter in this section because the former are more directly related to data
interlinking with keys and link keys.

20

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

Theorem 5 states the correspondence between strong link keys and keys and alignments: (11) says that

strong link keys entail keys; (12) and (13) express conditions under which the converse of (11) holds.

Theorem 5. The following holds:

({(cid:104)pi, qi(cid:105)}k

i=1 linkkeys

x (cid:104)C, D(cid:105)) |= ({pi}k

i=1 keyx C)

({pi}k
({pi}k

i=1 keyin C), C (cid:119) D, {pi (cid:119) qi}k
i=1 keyeq C), C (cid:119) D, {pi ≡ qi}k

i=1 |= ({(cid:104)pi, qi(cid:105)}k
i=1 |= ({(cid:104)pi, qi(cid:105)}k

i=1 linkkeys
i=1 linkkeys

in (cid:104)C, D(cid:105))

eq (cid:104)C, D(cid:105))

(11)

(12)

(13)

with x ∈ {in, eq}.

Proof. (11) is a direct consequence of the deﬁnition of strong link keys (Deﬁnition 9). (12) and (13) are
consequences of Proposition 12 in Appendix A. (cid:3)

Given the symmetry of the link key deﬁnitions, (11), (12) and (13) hold for the right-hand side of the

link key too (with reversed subsumption relations).

Theorem 5 states that it is possible to infer keys from strong link keys. This is not surprising because
strong link keys are composed of keys by deﬁnition. We call these keys the side keys associated with a
strong link key. More interestingly, Theorem 5 also states that strong link keys can be inferred from keys
and proper alignments. Note that one key is enough to entail the strong link key as long as the alignment
holds (these alignments are different depending on whether in-link keys or eq-link keys are considered).
The converses of (12) and (13) are only partly true: strong link keys entail keys, but strong link keys
(nor plain or weak link keys) do not necessarily entail an alignment between their properties and classes.
This rejects the idea that link keys embed alignments. Link keys do not assert alignments, but express
conditions for identifying individuals. A link key between two classes C and D does not assert that C and
D are equivalent, nor that one of the classes subsumes the other, it just speciﬁes how to link individuals
that are described as instances of C and D, but there may be individuals in both classes that do not belong
to the other class. For example, there may exist a link key between the classes AdministrativeCentre and
Town, although no equivalence, nor subsumption holds between them (some administrative centres are
towns, others are cities; some towns are administrative centres, others not).

Is Theorem 5 still valid for weak and plain link keys? (12) and (13) do hold, but (11) does not. In other
words: keys and proper alignments entail weak and plain link keys (Corollary 5.1); however, none of the
side components of weak or plain link keys are necessarily keys (Theorem 6).

Corollary 5.1. The following holds:

({pi}k
({pi}k

i=1 keyin C), C (cid:119) D, {pi (cid:119) qi}k
i=1 keyeq C), C (cid:119) D, {pi ≡ qi}k

i=1 |= ({(cid:104)pi, qi(cid:105)}k
i=1 |= ({(cid:104)pi, qi(cid:105)}k

i=1 linkkeyy
i=1 linkkeyy

in (cid:104)C, D(cid:105))

eq (cid:104)C, D(cid:105))

(14)

(15)

with y ∈ {w, p}.

Proof. This is a direct consequence of Theorem 5 since, by Proposition 8, any strong link key is also a
plain and a weak link key. (cid:3)

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

21

Unlike strong link keys, none of the side components of weak or plain link keys are necessarily
keys. The proof of Theorem 6 provides two ontologies that are consistent with a weak link key but
are inconsistent with any of its side components.

Theorem 6. There exist ontologies that are consistent with a weak link key but inconsistent with each
of its side components.

Proof. Consider the following ontologies:
O1 :
C(a1), C(a2), C(a3), C(a4),
p(a1, v1), p(a2, v2), p(a3, v1), p(a4, v2),
p(cid:48)(a1, w1), p(cid:48)(a2, w1), p(cid:48)(a3, w2), p(cid:48)(a4, w1),
a1 (cid:54)≈ a2 (cid:54)≈ a3 (cid:54)≈ a4

It can be checked that

q(b1, v1), q(b2, v(cid:48)

q(cid:48)(b1, w1), q(cid:48)(b2, w1), q(cid:48)(b3, w(cid:48)

O2 :
D(b1), D(b2), D(b3), D(b4),
2), q(b3, v1), q(b3, v1),
2),
b1 (cid:54)≈ b2 (cid:54)≈ b3 (cid:54)≈ b4

2), q(cid:48)(b4, w(cid:48)

λ = ({(cid:104)p, q(cid:105), (cid:104)p(cid:48), q(cid:48)(cid:105)} linkkeyw

in (cid:104)C, D(cid:105))

is consistent with O1 ∪ O2. Notice that λ together with O1 and O2 entails the link a1 ≈ b1.

On the contrary, the side components of λ, i.e.

κ1 = ({p, p(cid:48)} keyin C)

κ2 = ({q, q(cid:48)} keyin D)

are inconsistent with O1 and O2, respectively. Indeed, O1 ∪ {κ1} |= a2 ≈ a4 because a2 and a4 share
the value v2 for p and the value w1 for p(cid:48). However, O1 ∪ {κ1} |= a2 (cid:54)≈ a4 because a2 (cid:54)≈ a4 belongs
to O1. This means that O1 ∪ {κ1} is inconsistent. In the same way, it can be shown that O2 ∪ {κ2} is
inconsistent. (cid:3)

It is noteworthy that not a single useful key (i.e. a key that can be used to generate links) can be found
in the ontologies of the proof of Theorem 6: ({p} keyin C) and ({p(cid:48)} keyin C) are both inconsistent with
O1, and ({q} keyin D) and ({q(cid:48)} keyin D) with O2. As a consequence, in this example, data interlinking
is possible with link keys (λ allows to ﬁnd a1 ≈ b1) but not with keys. Moreover, data interlinking is
possible with weak link keys but not with strong link keys.

Example 3 makes it clear in the context of a real data interlinking scenario that Equation (11) of

Theorem 5 does not hold for weak link keys.

Example 3 (Insee-IGN (cont.)). The following statement of Example 2:

I ∗ |= ({(cid:104)ins:nom, rdfs:label(cid:105), (cid:104)ins:subdivisionDe, ign:arr(cid:105)} linkkeyw

in (cid:104)ins:Com, ign:Com(cid:105))

expresses a weak in-link key satisﬁed by I ∗, the canonical interpretation of the RDF graphs of Example 2
whose linked individuals are merged.

Let us consider the side components of the above weak link key: If (11) of Theorem 5 were true for

weak link keys, then the following two keys would be satisﬁed by I ∗:

({ins:nom, ins:subdivisionDe} keyin ins:Com)

({rdfs:label, ign:arr} keyin ign:Com)

22

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

However, as explained in Example 2, ({ins:nom, ins:subdivisionDe} keyin ins:Com) is not satisﬁed by I ∗
due to the transitivity of the property ins:subdivisionDe.

One may think that data interlinking is still possible with ({rdfs:label, ign:arr} keyin ign:Com), which

is indeed satisﬁed by I ∗. This would require the following property correspondences to hold

ins:nom (cid:119) rdfs:label

ins:subdivisionDe (cid:119) ign:arr

However, I ∗ does not satisfy ins:nom (cid:119) rdfs:label but the reversed subsumption ins:nom (cid:118) rdfs:label
(see Figure 2).

Even though the side components of a weak link key are not necessarily keys for the ontologies
separately, every weak link key entails one key in the vocabulary of the ontologies together, as stated by
Proposition 9 below. Unfortunately, this link key is of very limited use in practice because the inferred
key holds for the intersection of the classes that we actually want to interlink (it is not known before
linking which individuals belong to both classes).

Proposition 9. The following holds:

({(cid:104)pi, qi(cid:105)}k

i=1 linkkeyw

x (cid:104)C, D(cid:105)) |= ({pi (cid:117) qi}k

i=1 keyw

x C (cid:117) D)

with x ∈ {in, eq}.

Proof. This is a consequence of Proposition 10 in Appendix A. (cid:3)

8.2. Relations between generated link sets

The difference between using link keys for data interlinking instead of keys and ontology alignments
becomes evident when comparing Theorem 1 with Theorem 3 and Theorem 2 with Theorem 4. In both
cases, knowledge about keys and alignments is replaced by knowledge about link keys. Theorem 7 shows
that the generated link sets are exactly the same.

Theorem 7. Let O and O(cid:48) be two ontologies. Let A = (cid:104)C, L, LK(cid:105) be an alignment between O and O(cid:48)
with {C (cid:119) D} ∪ {pi (cid:118) qi}k
in (cid:104)C, D(cid:105)).
Then it holds that LO,O(cid:48),A

i=1 keyin C) and λ = ({(cid:104)pi, qi(cid:105)}k

i=1 ⊆ C. Let κ = ({pi}k
= LO,O(cid:48),A
.
λ

i=1 linkkeys

κ

Proof. The result follows from Deﬁnitions 6 and 11 and the fact that, since {C (cid:119) D}∪{pi (cid:118) qi}k
then, by clause (12) of Theorem 5, we have O, O(cid:48), A, κ |= λ, and also O, O(cid:48), A, λ |= κ. (cid:3)

i=1 ⊆ C

The same holds for eq-keys and eq-link keys.

Theorem 8. Let O and O(cid:48) be two ontologies. Let A = (cid:104)C, L, LK(cid:105) be an alignment between
O and O(cid:48) such that {C (cid:119) D} ∪ {pi ≡ qi}k
i=1 keyeq C) and λ =
({(cid:104)pi, qi(cid:105)}k

i=1 ⊆ C. Let κ = ({pi}k

eq (cid:104)C, D(cid:105)). Then LO,O(cid:48),A

= LO,O(cid:48),A
λ

i=1 linkkeys

.

κ

Proof. The result follows from Deﬁnitions 6 and 11 and the fact that, since {C (cid:119) D}∪{pi ≡ qi}k
then, by clause (13) of Theorem 5, we have O, O(cid:48), A, κ |= λ, and also O, O(cid:48), A, λ |= κ. (cid:3)

i=1 ⊆ C

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

23

The lesson from Theorems 7 and 8 is that, for interlinking two datasets, if there is a key for one dataset
and a proper alignment from the key to the vocabulary of the other dataset, then using the key or the
strong link key entailed by the key and the alignment is strictly equivalent.

However, as explained in the previous section, weak link keys may exist even when keys and proper
alignments do not. As a conclusion, in general, link keys are more suitable than keys for data interlinking.
Thus, data interlinking algorithms are justiﬁed in discovering link keys rather than keys and alignments.
Below we provide a real data-interlinking scenario in which keys and alignments are not useful, but link
keys are.

Example 4 (Insee-GeoNames). GeoNames is a world-wide geographical database publicly available in
RDF.7 Imagine that we are given the task of ﬁnding links between the URIs of Insee and GeoNames
that represent French communes. Below we show that, for this particular task, keys and alignments are
useless as they will generate no link, while link keys will generate almost all of them.

Insee’s ontology is very different from GeoNames’ ontology.8 It is not surprising as Insee’s scope
is France and GeoNames’ is world-wide. GeoNames’ ontology basically contains only one class,
gn:Feature, of which all geographical features (countries, cities, mountains, lakes, etc.) are direct in-
stances. There is no named class equivalent to ins:Com, ins:Arr, ins:Dép or ins:Rég, but the following
complex alignment holds:

ins:Com ≡ gn:Feature (cid:117) ∃ gn:countryCode.{FR} (cid:117) ∃ gn:featureCode.{A.ADM4}

ins:Arr ≡ gn:Feature (cid:117) ∃ gn:countryCode.{FR} (cid:117) ∃ gn:featureCode.{A.ADM3}

ins:Dép ≡ gn:Feature (cid:117) ∃ gn:countryCode.{FR} (cid:117) ∃ gn:featureCode.{A.ADM2}

ins:Rég ≡ gn:Feature (cid:117) ∃ gn:countryCode.{FR} (cid:117) ∃ gn:featureCode.{A.ADM1}

From here on, the complex classes of the right-hand sides of the above equivalences will be denoted by
gn:Com, gn:Arr, gn:Dep and gn:Reg.

In Insee, apart from rdf:type and owl:sameAs, communes only have the following properties: ins:nom,
ins:subdivisionDe, ins:codeCommune and ins:codeInsee. Neither ins:codeCommune nor ins:codeInsee
has any counterpart in GeoNames’ ontology, but ins:nom and ins:subdivisionDe are aligned in the fol-
lowing way:

ins:nom ≡ gn:name

ins:subdivisionDe (cid:118) gn:parentFeature

(16)

(17)

Certainly, gn:parentFeature is a multivalued property that relates features with their parents, in either
administrative or physical subdivision. Therefore, ins:subdivisionDe, which only relates administrative
divisions, is subsumed by gn:parentFeature but not equivalent to it.

Besides ins:subdivisionDe, one could also consider the GeoNames properties gn:parentCountry and
gn:parentADMN — where gn:parentADMN refers to a level N administrative parent, N = 1, 2, 3, 4 —

7https://download.geonames.org/export/dump/allCountries.zip
8http://www.geonames.org/ontology/ontology_v3.2.rdf

24

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

ins:TerritoireAdministratif

ins:nom

ins:codeINSEE

ins:subdivisionDe

ins:Commune

ins:Arrondissement

ins:Département

ins:Région

(cid:118)

≡

(cid:118)

gn:Feature

gn:name

gn:parentFeature

gn:parentCountry

gn:parentADM1

gn:parentADM2

gn:parentADM3

gn:parentADM4

Fig. 3. Fragments of the Insee and GeoNames ontologies and their alignment.

and the alignment

ins:subdivisionDe (cid:119) gn:parentCountry

ins:subdivisionDe (cid:119) gn:parentADMN

(18)

(19)

However, (18) and (19) are not true because the properties gn:parentCountry and gn:parentADMN may
be applied to non-administrative features (e.g. a lake), which is not the case of ins:subdivisionDe. The
considered fragments of the Insee and GeoNames ontologies and their alignment are depicted in Fig-
ure 3.

The following are the minimal keys that can be formed with the properties of the alignment made up

of (16) and (17):

({ins:nom}{ins:subdivisionDe} key ins:Com)

({gn:name}{gn:parentFeature} key gn:Com)

(20)

(21)

(20) cannot be used for interlinking because this requires ins:subdivisionDe and ins:parentFeature to be
equivalent (Theorem 2), which is not true. This becomes apparent when we compare the values of French
communes for both properties, as there are values that the communes have for ins:parentFeature but not
for ins:subdivisionDe (e.g. the URI representing the European Union). Likewise, (21) is not useful.

From the above paragraph, we can conclude that keys and alignments are not useful for interlinking
communes of Insee and GeoNames. Nevertheless, link keys are. More speciﬁcally, the following link
keys can be used:

({(cid:104)ins:nom, gn:name(cid:105)}{(cid:104)ins:subdivisionDe, gn:parentADM3(cid:105)} linkkeys (cid:104)ins:Com, gn:Com(cid:105))
({(cid:104)ins:nom, gn:name(cid:105)}{(cid:104)ins:subdivisionDe, gn:parentADM2(cid:105)} linkkeys (cid:104)ins:Arr, gn:Arr(cid:105))

({(cid:104)ins:nom, gn:name(cid:105)} linkkeys

in (cid:104)ins:Dép, gn:Dep(cid:105))

(22)

(23)

(24)

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

25

Indeed, the links between departments can be found using (24) by comparing their names, and, once
these links are found, they can be used to ﬁnd links between arrondissements using (23) by comparing
their names and the departments they belong to. Finally, the found links between arrondissements can be
used to ﬁnd links between communes using (22) by comparing their names and the arrondissements they
belong to. We did so and compared the results with a reference link set. We obtained 100% precision
and 97% recall. The latter was due to the similarity function used to compare name strings.

To conclude, let us stress that, even though (19) is not true, (22) and (23) hold and are useful for
interlinking. This conﬁrms once again that the properties of a link key are not necessarily semantically
related via subsumption or equivalence.

9. Conclusions and further work

The relation between keys and link keys is much more subtle than may be thought of at ﬁrst sight, and
one may not be replaced by the other without care. In particular, we have shown that data interlinking
with keys requires (a) a proper alignment (Theorems 1 and 2), and (b) completion in the case of eq-keys
(Theorem 2). Data interlinking with link keys, in turn, does not need alignments (Theorems 3 and 4) but
still needs completion in the case of eq-link keys (Theorem 4).

Strong link keys entail keys by deﬁnition, and keys with proper alignments entail strong link keys
(Theorem 5). In this case, the links generated by a strong link key are the same as those generated by
their associated side keys and alignments (Theorems 7 and 8).

Nonetheless, in addition to not needing an alignment, weak link keys may exist independently from
the existence of any key of the individual ontologies (Theorem 6; if they are, then they are strong link
keys), and yet they may be useful for interlinking datasets.

These results provide a clear picture of the relationships between key-inspired devices available for

data interlinking. They can be easily transferred to the hybrid keys and link keys.

The work presented in this paper contributes grounding data interlinking methods based on keys and
link keys. In particular, it justiﬁes the work for directly extracting weak link keys [8] instead of searching
for keys with matching alignments. Link key extraction directly focuses on what may be used for data
interlinking instead of generating keys and alignments that may not be possible to exploit. Also, when
no strong link key exists, link key extraction may ﬁnd a suitable weak link key, though key extraction
will not return any useful key.

The clariﬁcation of the semantics of link keys tackled in this paper should lead to complement data
interlinking methods with inference methods. One approach consists in designing rules, inspired by the
statements found in propositions of this paper, to infer (link) keys from (link) keys in the same way
as Armstrong’s axioms [31] allow to derive functional dependencies. However, this approach is highly
dependent on the actual schema language used. Another approach extends description logic reasoners
to include keys [26] and link keys as axioms. In both cases, entailed link keys could be exploited by
extended versions of reasoning-based data interlinking tools. This should also enable breaking the ex-
traction+interlinking process by reasoning on link keys before interlinking in order to provide more
accurate links, eventually more efﬁciently.

Acknowledgements

This work has been partially supported by the ANR project Elker (ANR-17-CE23-0007).

26

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

The authors acknowledge the numerous discussions they had with Michel Chein, Madalina Croitoru,
Chan Le Duc, Michel Leclère, Nathalie Pernelle, Fatiha Saïs, François Scharffe and Danai Symeonidou
on the various deﬁnitions of keys that may apply in logical formalisms.

References

[1] T. Heath and C. Bizer, Linked Data : Evolving the Web into a Global Data Space, Morgan and Claypool, 2011.
[2] A. Ferrara, A. Nikolov and F. Scharffe, Data Linking for the Semantic Web, International Journal of Semantic Web and

Information Systems 7(3) (2011), 46–76.

[3] M. Nentwig, M. Hartung, A.-C. Ngonga Ngomo and E. Rahm, A survey of current Link Discovery frameworks, Semantic

Web 8(3) (2017), 419–436.

[4] M. Atencia, J. David and F. Scharffe, Keys and pseudo-keys detection for web datasets cleansing and interlinking, in:
Knowledge Engineering and Knowledge Management - 18th International Conference, EKAW 2012, Galway City, Ireland,
October 8-12, 2012. Proceedings, Lecture Notes in Computer Science, Vol. 7603, Springer, 2012, pp. 144–153.

[5] D. Symeonidou, V. Armant, N. Pernelle and F. Saïs, SAKey: Scalable Almost Key Discovery in RDF Data, in: The
Semantic Web - ISWC 2014 - 13th International Semantic Web Conference, The Semantic Web - ISWC 2014 - 13th
International Semantic Web Conference,, Lecture Notes in Computer Science, Vol. 8796, Springer, 2014, pp. 33–49.
[6] M. Achichi, M.B. Elleﬁ, D. Symeonidou and K. Todorov, Automatic Key Selection for Data Linking, in: Knowledge
Engineering and Knowledge Management - 20th International Conference, EKAW 2016, Bologna, Italy, November 19-
23, 2016, Proceedings, Vol. 10024, Lecture Notes in Computer Science, 2016, pp. 3–18.

[7] H. Farah, D. Symeonidou and K. Todorov, KeyRanker: Automatic RDF Key Ranking for Data Linking, in: Proceedings
of the Knowledge Capture Conference, K-CAP 2017, Austin, TX, USA, December 4-6, 2017, ACM, 2017, pp. 7–178.
[8] M. Atencia, J. David and J. Euzenat, Data interlinking through robust linkkey extraction, in: ECAI 2014 - 21st European
Conference on Artiﬁcial Intelligence, 18-22 August 2014, Prague, Czech Republic - Including Prestigious Applications of
Intelligent Systems (PAIS 2014), Frontiers in Artiﬁcial Intelligence and Applications, Vol. 263, IOS Press, 2014, pp. 15–
20.

[9] M. Atencia, J. David, J. Euzenat, A. Napoli and J. Vizzini, Link key candidate extraction with relational concept analysis,

Discrete applied mathematics 273 (2020), 2–20.

[10] P. Christen, Data Matching - Concepts and Techniques for Record Linkage, Entity Resolution, and Duplicate Detection,

Data-Centric Systems and Applications, Springer, 2012.

[11] J. Volz, C. Bizer, M. Gaedke and G. Kobilarov, Discovering and Maintaining Links on the Web of Data, in: The Semantic
Web - ISWC 2009, 8th International Semantic Web Conference, ISWC 2009, Chantilly, VA, USA, October 25-29, 2009.
Proceedings, Lecture Notes in Computer Science, Vol. 5823, Springer, 2009, pp. 650–665.

[12] R. Isele, A. Jentzsch and C. Bizer, Efﬁcient Multidimensional Blocking for Link Discovery without losing Recall, in:
Proceedings of the 14th International Workshop on the Web and Databases 2011, WebDB 2011, Athens, Greece, June 12,
2011, 2011.

[13] A.-C. Ngonga Ngomo and S. Auer, LIMES - A Time-Efﬁcient Approach for Large-Scale Link Discovery on the Web
of Data, in: IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artiﬁcial Intelligence, Barcelona,
Catalonia, Spain, July 16-22, 2011, IJCAI/AAAI, 2011, pp. 2312–2317.

[14] A.-C. Ngonga Ngomo and K. Lyko, EAGLE: Efﬁcient Active Learning of Link Speciﬁcations Using Genetic Program-
ming, in: The Semantic Web: Research and Applications - 9th Extended Semantic Web Conference, ESWC 2012, Her-
aklion, Crete, Greece, May 27-31, 2012. Proceedings, Lecture Notes in Computer Science, Vol. 7295, Springer, 2012,
pp. 149–163.

[15] M.A. Sherif, A.-C. Ngonga Ngomo and J. Lehmann, Wombat - A Generalization Approach for Automatic Link Dis-
covery, in: The Semantic Web - 14th International Conference, ESWC 2017, Portorož, Slovenia, May 28 - June 1, 2017,
Proceedings, Part I, Lecture Notes in Computer Science, Vol. 10249, Springer, 2017, pp. 103–119.

[16] J. Euzenat and P. Shvaiko, Ontology matching, 2nd edn, Springer, Heidelberg (DE), 2013.
[17] A. Hogan, A. Zimmermann, J. Umbrich, A. Polleres and S. Decker, Scalable and Distributed Methods for Entity Matching,
Consolidation and Disambiguation over Linked Data Corpora, Web Semantics: Science, Services and Agents on the World
Wide Web 10(0) (2012), 76–110.

[18] M. Al-Bakri, M. Atencia, S. Lalande and M. Rousset, Inferring Same-As Facts from Linked Data: An Iterative Import-by-
Query Approach, in: Proceedings of the Twenty-Ninth AAAI Conference on Artiﬁcial Intelligence, January 25-30, 2015,
Austin, Texas, USA., AAAI Press, 2015, pp. 9–15.

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

27

[19] M. Al-Bakri, M. Atencia, J. David, S. Lalande and M. Rousset, Uncertainty-sensitive reasoning for inferring sameAs facts
in linked data, in: ECAI 2016 - 22nd European Conference on Artiﬁcial Intelligence, 29 August-2 September 2016, The
Hague, The Netherlands - Including Prestigious Applications of Artiﬁcial Intelligence (PAIS 2016), Frontiers in Artiﬁcial
Intelligence and Applications, Vol. 285, IOS Press, 2016, pp. 698–706.

[20] T. Soru, E. Marx and A.-C. Ngonga Ngomo, ROCKER – A Reﬁnement Operator for Key Discovery, in: Proceedings of
the 24th International Conference on World Wide Web, WWW 2015, Florence, Italy, May 18-22, 2015, ACM, 2015.
[21] M. Atencia, M. Chein, M. Croitoru, J. David, M. Leclère, N. Pernelle, F. Saïs, F. Scharffe and D. Symeonidou, Deﬁning
Key Semantics for the RDF Datasets: Experiments and Evaluations, in: Graph-Based Representation and Reasoning - 21st
International Conference on Conceptual Structures, ICCS 2014, Ia¸si, Romania, July 27-30, 2014, Proceedings, Lecture
Notes in Computer Science, Vol. 8577, Springer, 2014, pp. 65–78.

[22] A. Borgida and G. Weddell, Adding Uniqueness Constraints to Description Logics (Preliminary Report), in: Deductive
and Object-Oriented Databases, 5th International Conference, DOOD’97, Montreux, Switzerland, December 8-12, 1997,
Proceedings, Lecture Notes in Computer Science, Vol. 1341, Springer, 1997, pp. 85–102.

[23] D. Toman and G. Weddell, On Keys and Functional Dependencies as First-Class Citizens in Description Logics, Journal

of Automated Reasoning 40(2–3) (2008), 117–132.

[24] D. Calvanese, G. De Giacomo and M. Lenzerini, Keys for Free in Description Logics, in: Proceedings of the 2000 Interna-
tional Workshop on Description Logics (DL2000), Aachen, Germany, August 17-19, 2000, CEUR Workshop Proceedings,
CEUR-WS.org, 2000, pp. 79–88.

[25] D. Calvanese, G. De Giacomo and M. Lenzerini, Identiﬁcation Constraints and Functional Dependencies in Description
Logics, in: Proceedings of the Seventeenth International Joint Conference on Artiﬁcial Intelligence, IJCAI 2001, Seattle,
Washington, USA, August 4-10, 2001, Morgan Kaufmann, 2001, pp. 155–160.

[26] C. Lutz, C. Areces, I. Horrocks and U. Sattler, Keys, Nominals, and Concrete Domains, Journal of Artiﬁcial Intelligence

Research 23 (2005), 667–726.

[27] C. Lutz and M. Milicic, Description Logics with Concrete Domains and Functional Dependencies, in: Proceedings of the
16th Eureopean Conference on Artiﬁcial Intelligence, ECAI’2004, including Prestigious Applicants of Intelligent Systems,
PAIS 2004, Valencia, Spain, August 22-27, 2004, IOS Press, 2004, pp. 378–382.

[28] S. Rudolph, Foundations of Description Logics, in: Reasoning Web. Semantic Technologies for the Web of Data - 7th
International Summer School 2011, Galway, Ireland, August 23-27, 2011, Tutorial Lectures, LNCS, Vol. 6848, Springer,
2011, pp. 76–136.

[29] A. Borgida and L. Seraﬁni, Distributed Description Logics: Assimilating Information from Peer Sources, Journal on Data

Semantics 1 (2003), 153–184.

[30] A. Zimmermann and J. Euzenat, Three Semantics for Distributed Systems and Their Relations with Alignment Compo-
sition, in: The Semantic Web - ISWC 2006, 5th International Semantic Web Conference, ISWC 2006, Athens, GA, USA,
November 5-9, 2006, Proceedings, Lecture Notes in Computer Science, Vol. 4273, Springer, 2006, pp. 16–29.
[31] W.W. Armstrong, Dependency Structures of Data Base Relationships, in: IFIP Congress, 1974, pp. 580–583.
[32] M. Gmati, M. Atencia and J. Euzenat, Tableau extensions for reasoning with link keys, in: Proceedings of the 11th
International Workshop on Ontology Matching co-located with the 15th International Semantic Web Conference (ISWC
2016), Kobe, Japan, October 18, 2016., CEUR Workshop Proceedings, CEUR-WS.org, 2016, pp. 37–48.

[33] N. Abbas, J. David and A. Napoli, Linkex: A Tool for Link Key Discovery Based on Pattern Structures, in: Supplemen-
tary Proceedings of ICFCA 2019 Conference and Workshops, Frankfurt, Germany, June 25-28, 2019, CEUR Workshop
Proceedings, Vol. 2378, CEUR-WS.org, 2019, pp. 33–38.

[34] J. David, J. Euzenat, F. Scharffe and C. Trojahn dos Santos, The Alignment API 4.0, Semantic web journal 2(1) (2011),

3–10.

Appendix A. Proofs of Section 8.1

This appendix describes the relations between keys and link keys in a more precise way than it was
done in Section 8.1. Some of the results of Section 8.1 are synthetic consequences of the ones presented
here.

Proposition 10. The following holds:

({(cid:104)pi, qi(cid:105)}k

i=1 linkkeyw

in (cid:104)C, D(cid:105)), {pi (cid:118) qi}k

i=1 |= ({pi}k

i=1 keyin C (cid:117) D)

28

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

({(cid:104)pi, qi(cid:105)}k
({(cid:104)pi, qi(cid:105)}k

i=1 linkkeyw
i=1 linkkeyw

in (cid:104)C, D(cid:105)), {pi (cid:119) qi}k
eq (cid:104)C, D(cid:105)), {pi ≡ qi}k

i=1 |= ({qi}k
i=1 |= ({pi}k

i=1 keyin C (cid:117) D)

i=1 keyeq C (cid:117) D)

i (δ) ∩ pI

Proof. Let us prove the ﬁrst entailment. Let I be such that I |= ({(cid:104)pi, qi(cid:105)}k
I |= pi (cid:118) qi (i = 1, . . . , k), and let us prove that I |= ({pi}k
that pI
In particular, δ ∈ CI and δ(cid:48) ∈ DI. Now, since I |= pi (cid:118) qi, then, pI
this and the fact that pI
I |= ({(cid:104)pi, qi(cid:105)}k
be proven analogously.

in (cid:104)C, D(cid:105)) and
i=1 keyin C (cid:117) D). Let δ, δ(cid:48) ∈ (C (cid:117) D)I such
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). Since δ, δ(cid:48) ∈ (C (cid:117) D)I = CI ∩ DI then δ, δ(cid:48) ∈ CI and δ, δ(cid:48) ∈ DI.
i (δ(cid:48)) (i = 1, . . . , k). From
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). Since
in (cid:104)C, D(cid:105)) and δ ∈ CI and δ(cid:48) ∈ DI, then δ = δ(cid:48). The second entailment can

i (δ(cid:48)) (cid:54)= ∅, we can infer that pI

i=1 linkkeyw

i=1 linkkeyw

i (δ(cid:48)) ⊆ qI

i (δ) ∩ pI

i (δ) ∩ qI

Let us prove the third entailment. Let I be such that I |= ({(cid:104)pi, qi(cid:105)}k

I |= pi ≡ qi (i = 1, . . . , k), and let us prove that I |= ({pi}k
such that pI
Now, since I |= pi ≡ qi, then, we have pI
pI
i (δ) = pI
δ(cid:48) ∈ DI and I |= ({(cid:104)pi, qi(cid:105)}k

i=1 linkkeyw
eq (cid:104)C, D(cid:105)) and
i=1 keyeq C (cid:117) D). Let δ, δ(cid:48) ∈ (C (cid:117) D)I
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). Since δ, δ(cid:48) ∈ (C (cid:117) D)I then δ ∈ CI and δ(cid:48) ∈ DI.
i (δ(cid:48)) (i = 1, . . . , k). From this and the fact that
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). Finally, since δ ∈ CI and

i (δ(cid:48)) (cid:54)= ∅, we can infer that pI

eq (cid:104)C, D(cid:105)) then it must be δ = δ(cid:48). (cid:3)

i=1 linkkeyw

i (δ(cid:48)) = qI

i (δ) = pI

i (δ) = qI

Proposition 11 is the counterpart of Proposition 10 for strong link keys. Notice that this time the

consequent is a key in the union of classes, and not only in the intersection.

Proposition 11. The following holds:

({(cid:104)pi, qi(cid:105)}k
({(cid:104)pi, qi(cid:105)}k
({(cid:104)pi, qi(cid:105)}k

i=1 linkkeys
i=1 linkkeys
i=1 linkkeys

in (cid:104)C, D(cid:105)), {pi (cid:118) qi}k
in (cid:104)C, D(cid:105)), {pi (cid:119) qi}k
eq (cid:104)C, D(cid:105)), {pi ≡ qi}k

i=1 |= ({pi}k
i=1 |= ({qi}k
i=1 |= ({pi}k

i=1 keyin C (cid:116) D)

i=1 keyin C (cid:116) D)

i=1 keyeq C (cid:116) D)

Proof. We only prove the ﬁrst entailment. Let I such that I |= ({(cid:104)pi, qi(cid:105)}k
in (cid:104)C, D(cid:105)) and
i=1 keyin C (cid:116) D). Let δ, δ(cid:48) ∈ (C (cid:116) D)I such
I |= pi (cid:118) qi (i = 1, . . . , k), and let us prove that I |= ({pi}k
that pI
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). We have δ, δ(cid:48) ∈ (C (cid:116) D)I = CI ∪ DI. Let us consider three cases:
(1) δ, δ(cid:48) ∈ CI, (2) δ, δ(cid:48) ∈ DI and (3) δ ∈ CI and δ(cid:48) ∈ DI (the case δ(cid:48) ∈ CI and δ ∈ DI is equivalent to
this last one).

i=1 linkkeys

i (δ) ∩ pI

(1) Assume that δ, δ(cid:48) ∈ CI. Since I |= ({(cid:104)pi, qi(cid:105)}k

From this and the fact that δ, δ(cid:48) ∈ CI and pI

i (δ) ∩ pI

(2) Assume that δ, δ(cid:48) ∈ DI. Since I |= ({(cid:104)pi, qi(cid:105)}k

Now, we also have that I |= pi (cid:118) qi. Thus, pI
this, and pI
fact that δ, δ(cid:48) ∈ DI and I |= ({qi}k

i (δ(cid:48)) (cid:54)= ∅, we can infer that qI

i (δ) ∩ pI

i=1 keyin D) implies δ = δ(cid:48).

i=1 linkkeys

in (cid:104)C, D(cid:105)) then I |= ({pi}k
i=1 keyin C).
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k), we can conclude that δ = δ(cid:48).
in (cid:104)C, D(cid:105)) then I |= ({qi}k
i=1 keyin D).
i (δ(cid:48)) (i = 1, . . . , k). From
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). This along with the

i (δ) and pI

i=1 linkkeys

i (δ(cid:48)) ⊆ qI

i (δ) ∩ qI

i (δ) ⊆ qI

(3) Finally, assume that δ ∈ CI, δ(cid:48) ∈ DI. Since I |= ({(cid:104)pi, qi(cid:105)}k

in (cid:104)C, D(cid:105)) then
in (cid:104)C, D(cid:105)). It is possible to proceed like in the proof of the ﬁrst statement

i=1 linkkeys

I |= ({(cid:104)pi, qi(cid:105)}k
of Proposition 10 to conclude that δ = δ(cid:48).

i=1 linkkeyw

The other two statements can be proven similarly. (cid:3)

M. Atencia, J. David, and J. Euzenat / On the relation between keys and link keys for data interlinking

29

Proposition 12 is the converse of Proposition 11. Notice, however, that, in the case of in-link keys,
the subsumptions are inverted, i.e. they are the subsuming and not the subsumed properties the ones that
must form an in-key in the union of classes.

Proposition 12. The following holds:

({pi}k
({qi}k
({pi}k

i=1 keyin C (cid:116) D), {pi (cid:119) qi}k
i=1 keyin C (cid:116) D), {pi (cid:118) qi}k
i=1 keyeq C (cid:116) D), {pi ≡ qi}k

i=1 |= ({(cid:104)pi, qi(cid:105)}k
i=1 |= ({(cid:104)pi, qi(cid:105)}k
i=1 |= ({(cid:104)pi, qi(cid:105)}k

i=1 linkkeys
i=1 linkkeys
i=1 linkkeys

in (cid:104)C, D(cid:105))

in (cid:104)C, D(cid:105))

eq (cid:104)C, D(cid:105))

Proof. We only prove the ﬁrst entailment. Let I be an interpretation such that I |= ({pi}k
and I |= pi (cid:119) qi (i = 1, . . . k).

i=1 keyin C (cid:116) D)

Since I |= ({pi}k

us prove that I |= ({qi}k
we have I |= ({pi}k
I |= ({qi}k

i=1 keyin D).

i=1 keyin C (cid:116) D), by (8) of Proposition 5, we have that I |= ({pi}k

i=1 keyin C). Let
i=1 keyin C (cid:116) D), by (8) of Proposition 5,
i=1 keyin D), and, since I |= pi (cid:119) qi, by (9) of Proposition 5, we also have that

i=1 keyin D). Since I |= ({pi}k

Finally, let us prove that I |= ({(cid:104)pi, qi(cid:105)}k
i (δ) ∩
qI
i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). From δ ∈ CI and δ(cid:48) ∈ DI we have δ, δ(cid:48) ∈ CI ∪ DI = (C (cid:116) D)I. Since
i (δ(cid:48)) (cid:54)= ∅ we infer
I |= pi (cid:119) qi, we have qI
pI
i (δ) ∩ pI
i=1 keyin C (cid:116) D)
implies δ = δ(cid:48).

i (δ(cid:48)) (cid:54)= ∅ (i = 1, . . . , k). This together with δ, δ(cid:48) ∈ (C (cid:116) D)I and I |= ({pi}k

in (cid:104)C, D(cid:105)). Let δ ∈ CI and δ(cid:48) ∈ DI with pI

i (δ(cid:48)) (i = 1, . . . , k). From this and pI

i=1 linkkeyw

i (δ(cid:48)) ⊆ pI

i (δ) ∩ qI

The second entailment can be proven analogously. The third entailment can be proven analogously

too, but will use (10) of Proposition 5. (cid:3)

