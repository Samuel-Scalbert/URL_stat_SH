Mobile participatory sensing with strong privacy
guarantees using secure probes
Iulian Sandu Popa, Dai Hai Ton That, Karine Zeitouni, Cristian Borcea

To cite this version:

Iulian Sandu Popa, Dai Hai Ton That, Karine Zeitouni, Cristian Borcea. Mobile participatory sens-
ing with strong privacy guarantees using secure probes. Geoinformatica, 2021, 25 (3), pp.533-580.
￿10.1007/s10707-019-00389-4￿. ￿hal-03329908￿

HAL Id: hal-03329908

https://hal.science/hal-03329908

Submitted on 29 Oct 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Mobile Participatory Sensing with Strong Privacy
Guarantees Using Secure Probes

Iulian Sandu Popa · Dai Hai Ton That ·
Karine Zeitouni · Cristian Borcea

Abstract Mobile participatory sensing (MPS) could beneﬁt many application
domains. A major domain is smart transportation, with applications such as
vehicular traﬃc monitoring, vehicle routing, or driving behavior analysis. How-
ever, MPS’s success depends on ﬁnding a solution for querying large numbers
of smart phones or vehicular systems, which protects user location privacy
and works in real-time. This paper presents PAMPAS, a privacy-aware mo-
bile distributed system for eﬃcient data aggregation in MPS. In PAMPAS,
mobile devices enhanced with secure hardware, called secure probes (SPs),
perform distributed query processing, while preventing users from accessing
other users’ data. A supporting server infrastructure (SSI) coordinates the
inter-SP communication and the computation tasks executed on SPs. PAM-
PAS ensures that SSI cannot link the location reported by SPs to the user
identities even if SSI has additional background information. Moreover, an en-
hanced version of the protocol, named PAMPAS+, makes the system robust
even against advanced hardware attacks on the SPs. Hence, the risk of user
location privacy leakage remains very low even for an attacker controlling the
SSI and a few corrupted SPs. Our experimental results demonstrate that these

I. Sandu Popa
DAVID Laboratory - University of Versailles Saint-Quentin, Universit´e Paris-Saclay, Ver-
sailles, France & INRIA Saclay-Ile-de-France, Universit´e Paris-Saclay, Palaiseau, France
E-mail: iulian.sandu-popa@uvsq.fr

D. H. Ton That
College of Computing and Digital Media, DePaul University, Chicago, Illinois, USA
E-mail: dtonthat@depaul.edu

K. Zeitouni
DAVID Laboratory - University of Versailles Saint-Quentin, Universit´e Paris-Saclay, Ver-
sailles, France
E-mail: karine.zeitouni@uvsq.fr

C. Borcea
Department of Computer Science, New Jersey Institute of Technology, Newark, New Jersey,
USA
E-mail: borcea@njit.edu

2

Iulian Sandu Popa et al.

protocols work eﬃciently on resource constrained SPs being able to collect the
data, aggregate them, and share statistics or derive models in real-time.

Keywords Location privacy · secure protocol · distributed architecture ·
mobile · participatory sensing · real-time urban monitoring

1 Introduction

There is an increasing interest in mobile participatory sensing for urban mon-
itoring, which appears to be a better alternative to traditional infrastructure-
based sensing to cope with the high installation and maintenance costs, as well
as the coverage limitation. Many projects have been conducted recently around
the world - or are still ongoing - in the area of environmental participatory
sensing [33], such as Citi-Sense in Oslo, CamMobSens at Cambridge, Met-
roSense at Dartmouth, OpenSense in Switzerland or Urban Civics in Paris1.
Many applications that exploit the sensing features of smart phones are al-
ready available. Examples include community based traﬃc monitoring (e.g.,
Waze2, or Navigon3), evaluating the quality of road infrastructures4, ﬁnding
available parking spaces or noise mapping [15]. As we can see from these ex-
amples, smart transportation applications such as vehicular traﬃc monitoring,
vehicle routing, or driving behavior analysis, beneﬁt greatly from mobile par-
ticipatory sensing. In addition, the emerging lightweight low-cost sensors are
changing the paradigm of environmental and health monitoring5, and allow
measuring in real-time the individual exposure to environmental risk factors
or the propagation of an epidemic.

In these scenarios, the community members (e.g., their smart phones or
vehicular systems) act as mobile probes and contribute to spatial aggregate
statistics, which in turn, beneﬁt the whole community, e.g., dynamic traﬃc
navigation or air quality mapping and alerts. Various statistics are of interest:
basic count and density, average of reported measures by location and time,
or more complex geo-statistical operations such as spatial interpolation [31].
Unfortunately, most current mobile participatory sensing systems (MPSS) re-
quire users to reveal their locations to trusted monitoring servers, which raises
serious privacy concerns because user identity could be determined based on
several locations that are linked to the same user [30]. We should stress that,
even if users might trust a centralized service, privacy violation examples are
legions (see for example DataLossDB.org) coming from negligence, abusive
use, internal or external attacks, and such violations aﬀect even the most se-
cured servers. In addition to location, sensing data reported by users could be
privacy-sensitive as well. These privacy issues represent a serious obstacle that
can prevent a wide adoption of MPSS.

1 https://goﬂow.ambientic.mobi/
2 http://www.waze.com
3 http://navigon.com
4 http://www.streetbump.org/
5 http://www.epa.gov/heasd/airsensortoolbox/

PAMPAS+

3

Several works consider the MPSS privacy problem such as [15], [6], [13],
[37], [40]. However, most approaches require trusting a proxy server [13], [40],
while others are too costly [15], [6], or sacriﬁce sensing accuracy for privacy [37].
Hence, providing a high-quality MPSS, while protecting the users’ privacy, is
still a challenge. Recently, the emergence of personal secure devices has opened
new perspectives in personal data protection. Be it a secure portable token [1],
[41], [25] communicating with the user’s smartphone or plugged inside it (e.g.,
Google Vault6), a tamper-resistant hardware security module securing the on-
board computer of a vehicle [16], or the secure TrustZone CPU [3] of the ARM
cortex-A series equipping most of mobile devices today, all such secure devices
oﬀer tangible, hardware-based security guarantees under the form of what
is generally called a Trusted Execution Environment (TEE) [38]. We lever-
age their secure data processing capability in a distributed, privacy-by-design
architecture, providing an alternative to the traditional server-centric archi-
tecture. Following current technology trends (e.g., Intel SGX [36], TrustZone
CPU [21]), we expect that such secure devices will become ubiquitous in the
near future, equipping by default users’ mobile devices and devices embedded
in smart vehicles. As such, there will be no need for users to buy and connect
external hardware to participate in MPPS applications.

This paper presents PAMPAS, a Privacy-Aware Mobile Participatory Sens-
ing system for eﬃcient mobile distributed query processing in the context of
MPSS. The novelty of PAMPAS7 [44] is two-fold: (1) it provides a system ar-
chitecture that protects users’ location privacy by preventing location tracking
from any third-party server; and (2) it provides eﬃcient aggregation protocols
that satisfy the MPSS real-time constraints in spite of the resource limitations
of secure devices. The privacy guarantee gives users strong incentives for par-
ticipation [18], in addition to the beneﬁts they get from MPSS applications. In
PAMPAS, all participants have a mobile device enhanced with secure hardware
(i.e., any of the types described above), called a secure probe (SP). SPs act
as probes for the target phenomenon, perform distributed query processing,
and share the results with the users. The secure hardware prevents users from
accessing other users’ data during the distributed computation. Secure probes
exchange data in encrypted form with help from a supporting server infrastruc-
ture (SSI). To provide real-time results, PAMPAS employs eﬃcient, parallel,
location-based aggregation protocols which partition the probes according to
their geographic distribution. The construction and the maintenance of these
partitions aim at reducing and balancing the workloads on worker SPs, while
precluding the SSI from doing location-based inference attacks against the
participants.

6 http://www.cnet.com/news/googles-project-vault-is-a-security-chip-disguised-as-an-

micro-sd-card/

7 This paper is an extended version of [44]. The new material covers three signiﬁcant
contributions. First, we design a new, more robust aggregation protocol that is resilient
to advanced hardware attacks. Second, we provide an alternative, more eﬀective partition-
ing algorithm that oﬀers a diﬀerent tradeoﬀ in terms of eﬃciency and partitioning quality
than the base partitioning algorithm. Third, we provide a thorough analysis of the privacy
protection and also an extensive evaluation of the new proposed protocols.

4

Iulian Sandu Popa et al.

Furthermore, to increase the security of PAMPAS and make it robust
against advanced hardware attacks (called lab attacks in the paper8), we design
an enhanced aggregation protocol named PAMPAS+. To this end, we consider
ﬁrst an extended threat model in which we take into account the possibility
that some of the SPs could be corrupted. We then introduce the PAMPAS+
protocol which, by isolating the risk, is able to avoid a complete leakage of
sensitive user information even if some SPs are corrupted and thus to con-
tinue protecting the privacy of the participants. Hence, PAMPAS+ drastically
reduces the beneﬁts of a lab attack and through this largely increases the sys-
tem security. At the same time, the improved privacy protection of PAMPAS+
has a minimal impact on the eﬃciency and scalability of the protocol as the
most costly operations can be done oﬄine.

We implemented and validated PAMPAS/PAMPAS+ using representative
secure hardware platforms. We used two applications for experiments, traf-
ﬁc and noise monitoring, with both real and synthetic datasets representing
small and medium-size cities. Using these applications, we compared PAM-
PAS with a state-of-the-art secure aggregation protocol described in [41]. The
experimental results show that PAMPAS outperforms this protocol in terms
of latency and scalability, which translates to much lower resource utilization
at the user side.

The rest of this paper is organized as follows. Section 2 discusses the related
work. Section 3 describes the system architecture of PAMPAS, the base threat
model, and the protocol requirements. Section 4 presents the location-based
global aggregation protocol, and Section 5 describes the privacy-aware probe
partitioning protocol. Building up on the foundation laid by the PAMPAS
protocol, we present PAMPAS+ in Section 6, an eﬃcient privacy improvement
of PAMPAS which addresses the important lab attack problem. The secu-
rity analysis of PAMPAS and PAMPAS+ is presented in Section 7, while the
experimental results as well as the performance comparison of PAMPAS and
PAMPAS+ are shown in Section 8. Finally, we conclude the paper in Section 9.

2 Related Work

Traditional system architectures used in MPSS such as [13], [40] rely on a
centralized server to collect data from mobile participants, process it, and
publish the results. This server-centric model is straightforward and easy to
deploy, run, and maintain. However, this basic approach also raises serious
privacy concerns and prevents a wide adoption of MPSS. An attacker who is
able to link several location reports to the same user can then determine the
identity of the user by leveraging, for example, background information (e.g.,
user home address). Thus, an attacker can identify the MPSS participants and

8 We use the terminology of ARM [3] which designates as lab attacks the most advanced,
comprehensive and invasive hardware attacks for which the attackers have access to labo-
ratory equipment and the knowledge to perform reverse engineering of a device and also
monitor analog signals to perform attacks such as cryptographic key analysis.

PAMPAS+

5

infer their personal habits and activities [30]. In addition to location which
is normally included in MPSS reports, the sensing data reported by users
could be privacy-sensitive as well. The works that address this issue belong to
three classes: (1) server-centric architecture and (2) cryptographic protocols
for MPSS, and (3) secure hardware devices and user-centric architectures.

Server-centric approaches. Virtual trip lines (VTLs) [22] deal with the
privacy issue by distributing the traﬃc monitoring service implementation
across several specialized servers and by providing a spatiotemporal cloaking
of the users under the VTLs. Although the attack of a single system compo-
nent prevents linking the identity and location of the users, choosing privacy-
insensitive locations for VTLs is tricky and limits the traﬃc information to
a part of the road network. Also, the problem of multi-component attack (or
collusion) remains, as well as the high cost of building such a complex system
distributed over several components. A similar approach is AnonySense [10]
which proposes a system composed of many entities such as the mobile nodes,
the registration authority, the task services, the report service, the access point
and the mix network. Each component takes responsibility for a speciﬁc role
so that a single malicious entity in the system cannot have access to too much
private information.

Shi et al. [39] propose PriSense, a people-centric urban sensing system to
tackle the problem of the privacy concerns of participating individuals. The
architecture of PriSense comprises two main components: powerful aggrega-
tion severs (ASs) and participating individuals (called nodes). Each AS is in
charge of a certain region and provides network access services for the nodes
in that region. The AS broadcasts queries in their region and the nodes con-
tribute with their data to the AS if they are relevant. To protect the user
privacy, a node randomly splits its data and sends the shares to other nodes in
its region. Then the nodes send the shares to the AS which is able to compute
base aggregation functions over the collected data. PriSense oﬀers probabilis-
tic privacy protection against malicious ASs and nodes. However, there are
several drawbacks: the deployment cost is high since it requires an AS for each
observed region, the communication cost is important since the data is split
before being sent to the AS, the type of aggregation is limited to base statisti-
cal functions (e.g., average, min, max, percentile, variance) while the accuracy
is low since a spatial unit corresponds to an AS region.

SpotMe [37] proposes a diﬀerent approach consisting in mixing the real
user’s location with fake locations before posting them to a central server.
Then, the server estimates the aggregated user locations by using probability
theory. However, the estimation errors can be important (around 20%), while
the number of observed spatial units cannot exceed a few hundreds. Also,
SpotMe involves higher communication costs because of the large number of
fake locations, while linkability may still be a problem for users who send
many consecutive location updates, which limits the usability of this approach
to sporadic updates. PoolView [17] tackles the problem of user privacy in
participatory sensing applications by applying data perturbation techniques
on the user-side to perturb private measurements before sharing. In PoolView,

6

Iulian Sandu Popa et al.

there is a tradeoﬀ between the user’s privacy level and the accuracy of the
system, i.e., the higher the required privacy level is, the higher the error in
the computed statistics is. Also, no matter the perturbation method which
is applied, there is no guarantee that the user’s privacy is always protected.
Besides, recent proposals address location privacy in diﬀerent contexts, such as
geo-indistinguishability in location-based services, by applying the diﬀerential
privacy principle to geo-location [2], [8], [29], [26] or geo-obfuscation for the
anonymization of workers in spatial task allocation [46], [26], [23]. However,
depending on the chosen degree of obfuscation, on the one hand, the quality
of service in such systems may suﬀer from the information accuracy loss, and
on the other hand, temporal correlation [7] or background knowledge can still
be used to infer the user’s location9.

By employing a fully decentralized architecture for computation, PAMPAS
avoids all the above listed problems. Moreover, the trust is enforced by using
cheap but highly secure, tamper-resistant hardware at the user side.

Cryptographic approaches. Another way to protect the users’ privacy
is to use secure cryptographic protocols [6], [15], [27], [35]. Such solutions
can oﬀer formal guarantees on location privacy and accountability to protect
against users trying to upload large amounts of fake samples. Typically, the
cryptographic solutions are based on homomorphic encryption schemes allow-
ing a central-server [35], [27] or the users [15] to aggregate the samples directly
on the cyphertext. However, the cryptographic methods have to face two ma-
jor limitations. First, homomorphic encryption only allows the computation
of basic aggregate functions (e.g., count, average, sum, standard deviation),
while more advanced functions require fully homomorphic encryption schemes,
which are not computationally feasible today. Second, even with the basic ag-
gregate functions, the cryptographic protocols can incur a large computation
and communication cost [6], [35]. Hence, the existing works typically limit the
size of the monitored space (e.g., the number of roads) and the monitoring
frequency. Therefore, such solutions cannot meet the scalability and the real-
time requirements of MPSS at the same time, and are not generic w.r.t. the
type of aggregate function. Moreover, depending on the encryption protocol,
the accuracy of the aggregate result may also be impacted since only a (low)
number of discrete range values can be computed with such protocols [6], [15],
[27], [35].

Secure hardware and user-centric approaches. Recent works have
also proposed the use of secure hardware at the user-side [1], [41], [42]. The
trust in such a distributed architecture in which all computation is done by
user devices arises from two sources: (i) the decentralization, i.e., there is
no central-server to be trusted or to be exposed to attacks having a large
beneﬁt/cost ratio; (ii) the (tamper-resistant) secure hardware at the user-
side, which protects the devices against physical attacks (even from the device
holder).

9 https://github.com/chatziko/location-guard

PAMPAS+

7

In [1], Allard et al. propose METAP, a privacy-preserving data publishing
protocol in the context of an architecture composed of low power secure devices
and a powerful but un-trusted server in order to release sanitized data to third
parties. However, this data publishing protocol does not consider the case
of spatiotemporal sensed values and cannot be used in participatory sensing
aggregations.

To et al. [41], [42] propose a similar architecture, but consider the problem
of executing SQL queries over a distributed database without revealing any
sensitive information to central servers. In particular, the work in [41] pro-
poses a secure protocol to evaluate GROUP BY SQL-like-queries, which are
similar to some extent to mobile participatory sensing aggregates. In a nut-
shell, the secure devices at the user-side push their query relevant tuples in
an encrypted form to a centralized server infrastructure. After collecting the
tuple data, the central server randomly partitions the tuples and sends each
partition to a secure device which decrypts it and produces partial aggrega-
tions (i.e., it aggregates the data belonging to the same group in a partition).
The partial aggregations are then sent back to the server, which repeats the
process (i.e., repartitions the intermediate results and resends them to some
secure devices for further aggregation). Hence, several (or many) iterations are
required before all tuples belonging to each group are aggregated. Considered
in our context, this protocol incurs high computation and communication costs
because of the speciﬁcity of MPSS aggregates (e.g., the aggregate groups are
locations, there is a high number of such groups, the computation is continu-
ous and should follow the data generation frequency, the aggregate functions
can be complex such as spatial interpolation). To improve the eﬃciency of the
secure protocol, an equi-depth histogram-based protocol is presented as an
alternative in [41]. The idea is to partition the aggregation groups into buck-
ets before the query processing, which leads to a uniform distribution of the
data in the obtained buckets, similar to an equi-depth histogram. This allows
the server to assemble the data tuples belonging to the same bucket into the
same partition, which in turn allows the secure devices to compute the ﬁnal
aggregation result in one iteration. However, building an equi-depth histogram
eﬃciently requires either knowing in advance the data distribution or having
a nearly-static distribution and then computing it using the costly secure pro-
tocol introduced above. Unfortunately, these hypotheses are not veriﬁed in
MPSS apps since the spatial distribution of the participants is not known in
advanced and also rapidly evolves over time.

PAMPAS shares the idea of employing a user-centric decentralized archi-
tecture with the above mentioned works. However, unlike existing protocols,
its secure aggregation protocol is adapted to MPSS requirements, i.e., high dy-
namicity of the participants, real-time constraints for computation, complexity
of the aggregate statistics, and low resource utilization.

Recently, a distributed vehicular rerouting system, called DIVERT, was
proposed in [32] to optimize vehicle travel time through proactive traﬃc con-
gestion avoidance. Similar to PAMPAS, DIVERT employs a hybrid architec-
ture since, although the rerouting computation is done at the vehicles, a central

8

Iulian Sandu Popa et al.

server is still needed to determine an accurate global view of the traﬃc. DI-
VERT proposes a privacy-aware traﬃc reporting scheme to protect the user
privacy against attackers at the server side. However, applying this solution
to generic participatory sensing applications (i.e., outside the context of path
rerouting computation for congestion avoidance) is impractical since its pri-
vacy mechanism only allows users to upload their location information when
located in low sensitive areas, i.e., road segments with signiﬁcant traﬃc density
since such roads naturally oﬀer a higher degree of anonymity to the partici-
pants. Hence, vehicles may only send traﬃc reports to the server if the road
density is higher than a predeﬁned threshold. Moreover, in DIVERT the users
are considered trusted. Diﬀerent, PAMPAS employs secure hardware at the
user side to prevent unauthorized access to private data and also provides se-
cure protocols preventing a massive leakage of private data in case of a lab
attack and collusion with the server.

Acknowledging users’ privacy concerns as one of the main obstacles for
long-term participation in MPSS, PriMe [28] deﬁnes a human-centric privacy
measurement method based on users’ perception. The user preferences re-
lated to sharing certain types of data are transformed into privacy metrics to
measure the individual’s inherent sensitivity and her sensitivity toward data
items based on data features. However, on the one hand, pushing the privacy
permission settings at the user side may lead to privacy issues, since not all
participants are aware of the sensitivity of the data they want to share. Also,
once shared, users lose control of their data. On the other hand, highly pro-
tective privacy settings may lead to very low accuracy levels of aggregation
results. In PAMPAS, we take a diﬀerent approach, i.e., all the user raw data
is protected using secure hardware and secure aggregation protocols; only the
aggregation results can be accessed by the participants or other third parties.
Furthermore, our data protection has no impact on the result accuracy.

A centralized solution based on secure hardware could also be devised us-
ing recent proposals to ensure shielded application execution over untrusted
servers. For example, Haven [4] extends the hardware level protection fea-
tures provided by the Intel SGX architecture from code snippets to the entire
OS. But there are limitations: this solution slows down the computation sub-
stantially; the entire security architecture depends on the chip manufacturer’s
ability to protect the secret keys; programmers will miss certain features, such
as process creation, that are not supported. More important, such an approach
exhibits the intrinsic problem of single point of failure and hence cannot pro-
tect against lab attacks on the secure hardware at the server side, a problem
which we address in PAMPAS+.

3 System Overview

This section presents the system architecture of PAMPAS, the threat model
in our system, and the data and computation model of the system. Based on

PAMPAS+

9

these elements, we derive the requirements for the PAMPAS protocols. All
acronyms used in this paper are described in Table 1.

Table 1: Acronyms used in the article

Acronym
AES
IDW
MPS
MPSS
PAMPAS
PAMPAS+
PKI
RSA
SHA
SP
SSI
TEE

Description
The Advanced Encryption Standard symmetric cryptographic algorithm
Inverse Distance Weighting
Mobile Participatory Sensing
Mobile Participatory Sensing System
Privacy-Aware Mobile Participatory Sensing system and protocol
Enhancement of the PAMPAS protocol dealing with corrupted probes
Public Key Infrastructure
The Rivest-Shamir-Adleman asymmetric cryptographic algorithm
Secure Hashing Algorithm
Secure Probe
Supporting Server Infrastructure
Trusted Execution Environment

3.1 System Architecture

PAMPAS relies on a hybrid architecture combining secure elements at the
user side (secure probes – SP) and a supporting server infrastructure (SSI)
that enables secure exchange of messages between the mobile users. SPs and
SSI jointly run a privacy-preserving protocol to exchange sensed sample up-
dates, continuously compute the spatially aggregated results, and periodically
partition SPs according to their location. This protocol can be either PAM-
PAS or an enhanced version of PAMPAS called PAMPAS+ (but not both at
the same time). Figure 1 shows the general architecture of our system in the
context of traﬃc monitoring.

Compared to a purely decentralized peer-to-peer (P2P) architecture, this
hybrid architecture has the salient advantage of not consuming any resources
from the participants to maintain the P2P overlay, which is important given
the low resources and availability of the user devices. In addition, it exchanges
messages between SPs in O(1) hops as opposed to the typical O(logN ) hops
in P2P networks.

Secure Probe (SP). Each user holds a secure portable device, which can
be implemented by any type of (tamper-resistant) secure devices ﬂourishing
today and described in Section 1. In this paper, we consider the more chal-
lenging case of cheap, low-end secure devices (see Figure 2); extending the
proposed solution to more powerful TEEs such as TrustZone or Intel SGX is
straightforward in terms of computation eﬃciency and resource consumption.
Whatever its commercial name and form factor, such a basic secure device,
called secure probe (SP) hereafter, usually embeds at the very least a secure
micro-controller (MCU) for computation (e.g., a smart card chip) connected

10

Iulian Sandu Popa et al.

Fig. 1: Overview of PAMPAS’s system architecture: mobile secure probes (SPs) leverage an
untrusted Supporting Server Infrastructure (SSI) for eﬃcient message passing among SPs.
SPs continuously compute a spatial probe partitioning (depicted by the purple dashed lines)
allowing for eﬃcient and secure sample data aggregation

to a large NAND Flash memory for data storage (e.g., an SD card). An SP
plays three roles: (i) mobile probe, (ii) processing node, and (iii) query issuer.
The SP sends encrypted samples (containing spatiotemporal sensed measures)
to SSI, participates in the data aggregation, and receives the ﬁnal results from
other SPs with the help of SSI. However, the high-level of security of SPs comes
at a price. The MCU usually has a low power CPU and a tiny RAM (a few
tens of KB). In addition, SPs have low availability in our context since they
can be connected/disconnected as required by the users. Therefore, all the
computation and communication with the SPs have to be highly optimized.

Fig. 2: Examples of cheap, low-end secure tokens that can be used in PAMPAS

Supporting Server Infrastructure (SSI). Diﬀerent from the typical
server-centric architecture, the SSI in our system acts only as a coordinator
for exchanging messages between the SPs and for temporary storage purposes.
In our architecture the SSI is not trusted. Therefore, all the temporary results
stored in the SSI have to be encrypted, e.g., using non-deterministic encryp-
tion.

PAMPAS+

11

In conclusion, the foundation for the security and privacy in PAMPAS
arises from the combination of secure hardware with a high degree of distri-
bution of the architecture (i.e., all computations are executed by some of the
SPs). The challenge is then to be able to continuously compute any type of
aggregate functions in real-time in this user-centric architecture given the low
resources of the SPs, while limiting the private information leakage to SSI or
potentially corrupted SPs.

3.2 Base Threat Model

In this section, we present the base threat model considered in PAMPAS. The
attackers in PAMPAS could be either users or the owners of SSI. Their goal
is to collect private user information (e.g., location or sensing data). Using
this private information, attackers can determine the user identities and learn
their activities and behaviors. Our threat model is based on the following
assumptions.

Assumption 1. Even though the users are untrusted, we assume in the
base threat model that all the SPs are trusted. This is reasonable considering
that a Trusted Execution Environment provides a high level of protection
against hack attacks [3] (i.e., local or remote software attacks on the secure
device) or shack attacks [3] (i.e., low budget hardware attacks). In addition, all
the persistently stored data in the NAND Flash is cryptographically protected.
Thus, SP owners cannot access the private data in their SPs.

In Section 6.1 we relax this assumption, i.e., we consider that some SPs
could be exposed to lab attackss [3] (i.e., high budget hardware attacks) and
thus be corrupted. Then, we modify the PAMPAS protocols accordingly.

Assumption 2. Each SP is supplied with a trustworthy certiﬁcate, e.g.,
from an oﬄine trusted PKI. Without this assumption, an attacker can easily
emulate nodes in the network, and conduct a Sybil attack [14], mastering a
large proportion of SPs, thus defeating any countermeasure. We also assume
that the hardware manufacturer is trusted and protects the secrets embedded
in SPs.

Assumption 3. We assume an honest-but-curious (or covert adversary)
SSI, i.e., it obeys the protocol it is supposed to do, but may try to infer
anything it can from the data or behaviors is sees. Considering a malicious
SSI (i.e., the server tampers with the protocol, e.g., by dropping messages to
infer more information) is of little interest, since a malicious SSI can be easily
detected (e.g., the SPs that aggregate the data verify if their own samples
are present in the data sent by the server) leading to critical ﬁnancial/legal
consequences for the service.

Assumption 4. We assume that the communication channel through
which the SPs transmit (encrypted) raw data to SSI is anonymous, e.g., by
using a proxy forwarder or an anonymization network (e.g., Tor). We assume
such systems are able to hide the packet origin from an adversary, so that
privacy cannot be compromised by a malicious server searching to recognize

12

Iulian Sandu Popa et al.

the origin of the uploaded messages. Let us emphasize that IP anonymity is
not enough to protect the user privacy in MPSS because identity information
could be determined from the location and sensing data.

Our goal is to ensure that users cannot read the raw data reported by
other users. The SSI must not be able to read the user raw data. Also, the
SSI must not be able to infer any additional location information about the
participants more than it already knows or could be inferred from the aggregate
result. Hence, the scope of PAMPAS is to fully protect the raw data and the
aggregation process, and does not consider the privacy exposure risks that
arise from analyzing the aggregate results, which is a complementary aspect
of this work (e.g., see [29]).

3.3 Data and Computation Models

Data model. PAMPAS is designed to be generic with respect to the type
of computation required by participatory sensing applications. In most cases,
such applications require the aggregation of geo-localized and time-stamped
sensed values collected by the sensing devices of the participants. Therefore,
a participant’s device periodically generates an update in the form sample
= (location, time, value), which is encrypted and sent to the SSI. PAMPAS
does not impose any restriction on the generation frequency of samples, which
may depend on the application sample generation policy. However, the system
should be eﬃcient and scalable for a large number of participants and a high
generation frequency of samples. Also, the participants’ privacy should be fully
protected independent of the number and spatiotemporal distribution of the
samples. Furthermore, PAMPAS considers two types of locations correspond-
ing to the two typical types of movements of users: (i) free movements in the
two-dimensional space, i.e., location = (x, y); (ii) movements constrained by
a transportation network (e.g., road or railroad network), i.e., location = (rid,
pos), where rid is the road identiﬁer and pos is the relative position on the
road. Finally, the value corresponds to the sensed measure (e.g., traﬃc speed,
noise level, etc.).

Query model. Given a stream of samples and an aggregate function,
PAMPAS produces a spatiotemporal aggregation of the sample stream such
as the stream-SQL-like [24] query formulation in Figure 3. The aggregation
is temporal since the result is computed continuously over time as long as it
is required or whenever the number of participants exceeds some predeﬁned
threshold. In this way, the spatiotemporal evolution of the measure of interest
is monitored over time. To this end, PAMPAS divides the stream using a
sliding time window (see Figure 3) and computes an aggregate result based on
all the samples generated in the time window. The ﬁnal aggregation result is a
spatial function representing the evolution in space of the observed measure in
the respective time window. For instance, the result can be the noise heat-map
in the covering area of a city or the average travel time in a road network. As

PAMPAS+

13

with the duration of observation, we do not impose any restrictions regarding
the extent of the observed space.

Fig. 3: The stream-SQL-like query formulation of the spatio-temporal aggregates supported
in PAMPAS

Spatial units. As shown in the above query, spatial aggregates are based
on a discrete referential space, i.e., a ﬁnite set of spatial units. Without loss
of generality, we consider two types of referential spaces corresponding to the
two types of users’ movements. In the case of free movement, we consider a
uniform grid and each grid cell corresponds to a spatial unit. The size of the
units is determined based on the application requirements, space size, number
of participants, etc. In the case of constrained movement by a transportation
network, we consider that a spatial unit corresponds to a network (road) seg-
ment, i.e., the network path connecting two adjacent network nodes (e.g., the
road segment between two intersections). In both cases, the number of spatial
units can be large (e.g., hundreds of thousands). The COUNT in the query
model is optional and is required in the aggregation protocol to check the
probes partitioning.

Aggregate functions. PAMPAS can compute most types of aggregate
statistics required by participatory sensing applications. Practically, our sys-
tem can compute in real-time any type of function having reasonable time
and space complexity given the relative low CPU power and little RAM of the
SP. For illustrative purpose, we consider three classes of functions in this pa-
per: (i) Typical algebraic functions: count, sum, average, standard deviation.
Such aggregate functions are the most popular in the works related to partic-
ipatory sensing [15], [6], [35]. These functions allow for example to compute
the average travel time or the traﬃc density in a road network; (ii) Speciﬁc
functions: inverse distance weighting (IDW). For instance, an application mon-
itoring the noise pollution in the city could use the IDW function to compute
a heat-map of the noise level in the entire space [31]; (iii) Holistic functions:
median, percentile, top-k. Such functions are also frequently used in statistical
computations (e.g., the median speed of vehicles in a road network). Their
particularity is that the computation of the result requires accessing the entire
sample set and cannot be achieved incrementally by accessing only subsets of
samples as with the previous two classes of functions.

An important observation is that cryptographic solutions based on homo-
morphic encryption cannot be applied for speciﬁc or holistic functions (see
Section 2). Also, the holistic functions cannot be computed eﬃciently in a

14

Iulian Sandu Popa et al.

Fig. 4: Workﬂow representation of the global protocol in PAMPAS

distributed architecture by the secure protocol proposed in [41] (as shown in
Section 8).

3.4 Protocol Requirements

In the light of the above description of the proposed user-centric architecture,
the PAMPAS protocols have to deal with the following challenges: (i) Pri-
vacy: By keeping all the sensitive data in the SPs, the adopted user-centric
architecture matches this requirement in contrast with a server-centric archi-
tecture. In short, the computation protocol should not reveal to the SSI any
additional information about the participants’ paths besides what the SSI can
infer from the aggregate result. (ii) Generality: the protocols should be able
to compute any type of function over the spatiotemporal sensed measures
by the mobile users and covering a large observation space. This is diﬀerent
from the works based on cryptographic approaches in which, typically, only
basic computation (e.g., simple aggregates like sum, average) can be achieved
and only in speciﬁc locations over limited periods of time. (iii) Eﬃciency: the
protocols should be highly eﬃcient to be able to continuously compute the ag-
gregate results in real-time with very limited resources. Indeed, for economic
and security reasons, the SPs used for data processing have low resources and
limited availability. Hence, it is necessary to minimize the computation and
communication costs of the PAMPAS protocols. (iv) Scalability: the protocols
should allow PAMPAS to scale to a large number of participants (e.g., up to
millions of users), high sampling frequencies, and very large regions. (v) Ac-
curacy: PAMPAS should continuously reﬂect the sensed measures with good
precision. In other words, protecting the users’ privacy should not impact the
accuracy of the aggregate result computed by the protocols.

4 Global Aggregation Protocol

The global privacy-preserving protocol in PAMPAS consists of three phases
that are repeatedly executed in pipeline (see Figure 4). First, the SSI collects
all the sensing updates sent by the participants for a period equal to the
sliding time window (i.e., the collection period ). Each update is encrypted

PAMPAS+

15

using symmetric non-deterministic encryption so that the SSI cannot gain
any knowledge from these updates. All the SPs share a secret key, which is
renewed periodically to increase security. The key is generated randomly by
a randomly chosen SP. To distribute the secrete key, we assume the users
authenticate using a typical PKI infrastructure, i.e., a certiﬁcate is embedded
in each user secure hardware (cf. Assumption 2 in Section 3.2). Whenever
a new SP connects to the system, it authenticates using its certiﬁcate. Then,
the SP randomly contacts another connected SP, which sends back the current
shared secret key encrypted with the public key of this newly connected SP.
The shared secret key is used by the SPs to symmetrically encrypt the
update messages (e.g., by using AES encryption) so that any SP can decrypt
messages and aggregate the data. Note that, although an SP can decrypt the
updates, a user is not allowed to access the decrypted data in her SP and
that the tamper-resistant hardware protects the transiting data from the user.
Therefore, as for the SSI, the users have access only to the ﬁnal results and
not to the raw data.

At the end of the collection period, the SSI triggers the processing period.
In this phase, only a small subset of SPs, which are randomly selected by
the SSI, are involved. The SSI partitions the collected samples such that the
number of updates in a partition can ﬁt the RAM resources of an SP (other-
wise, the persistent Flash storage of the SP has to be used incurring a much
higher computation cost). Then, each sample partition is sent to an SP, which
computes a partial aggregate result for the received updates. The encrypted
results are sent back to the SSI. Finally, the delivery period consists in deliv-
ering the current partial aggregate results to the queriers. Each querier needs
to perform the ﬁnal aggregation of these partial results, which is merely the
union of the demanded partial results.

Algorithms 1 and 2 give the detailed description of the operations executed
by the SSI and the SPs respectively. In the following, we denote by Ek and
nEk the symmetric deterministic and non-deterministic encryption with the
key k, and by E−1
the opposite decryption operations while Gi
indicates the identiﬁer of group i. All the notations used in the algorithms are
listed in Table 2.

and nE−1

k

k

To address the performance limitations of the existing protocols (such
as [41] as described in Section 2), the aggregation protocol in PAMPAS groups
the participants based on their location, which permits processing by a single
aggregating SP the reported sample updates from all the SPs in a spatial unit
(forming a group) for a time window. Thus, the SSI pushes these samples to
one aggregating SP which can aggregate the received data in one iteration.
To put that in perspective, the secure protocol in [41] incurs a costly aggre-
gation process in our context mainly because it requires a large number of
iterations, as conﬁrmed by our experimental evaluation (see Section 8). Note
that an aggregating SP does not have to belong to the probe group for which
it aggregates the samples. Indeed, the SSI randomly selects from all the par-
ticipants as many aggregating SPs as there are probe groups and then assigns
the samples in each group to an aggregating SP (as indicated in Algorithm 1).

16

Iulian Sandu Popa et al.

Notation

Description

Table 2: Notations used in the algorithms

Esk
nEsk
E−1
sk
nE−1
sk
CKij

nE ckij

i

nE ck−1
ij
AE P Ki
AE SKi
AE SK−1
Gi
P f ake
Gi
N
NG
QIcomm
QIcomp
Comp timei

Symmetric deterministic encryption using the shared key
Symmetric non-deterministic encryption using the shared key
Symmetric deterministic decryption using the shared key
Symmetric non-deterministic decryption using the shared key
The couple key shared between SPi and SPj
Symmetric non-deterministic encryption using the couple key shared
between SPi and SPj
Symmetric non-deterministic decryption using the couple key shared
between SPi and SPj
Asymmetric encryption using the public key of SPi
Asymmetric encryption using the secret key of SPi
Asymmetric decryption using the secret key of SPi
Identiﬁer of probe group i
Probability to send a fake message in group i
Number of spatial units
Number of probe groups
Degradation factor of the communication time
Degradation factor of the computation time
Computation time for the group i

Algorithm 1: PAMPAS aggregation protocol at the SSI-side

1 collection period():
2

/* Receive encrypted updates from SPs */
while (true) do

3

4

5

message = (Esk(Gi), nEsk(sample)) ;
store(message) → list[Esk(Gi)][currentT imeW indow];

6 processing period():
7

foreach i in {Esk(Gi)} do

8

9

10

11

12

13

14

/* feed in parallel the randomly selected SPs */
randomly select SPi;
while message ← list[Esk(Gi)][lastT imeW indow] do

send(message, SPi);

foreach i in {Esk(Gi)} do

/*Receive the ﬁnal results from worker SPs*/
enc resultf inal

= (Esk(Gi), nEsk(result));

i

15 delivery period():
16

foreach i in {Esk(Gi)} do

17

18

/*Send resulti to all requesting SPs*/
multicast(enc resultf inal

, {SPk});

i

To this end, the probes also send the deterministically encrypted value
of the spatial unit they are currently located in, in addition to the non-
deterministically encrypted value of the sample, i.e., message = (Ek(groupID),
nEk(sample)) (Algorithm 1, lines 4-5 and Algorithm 2, lines 3-4). Conse-
quently, the SSI can group the messages based on the encrypted unit number

PAMPAS+

17

Algorithm 2: PAMPAS aggregation protocol at the SP-side

1 collection period(): /* for all SPs */
2

/* Generate and send the sensing update: update(Gi, sample) */
message = (Esk(Gi), nEsk(sample)) ;
send anonymous(message, SSI);
/* Send a fake sample to the SSI with probability P f ake
if rand(0, 100) >= P f ake
then
f ake message = (Esk(Gi), nEsk(f ake sample)) ;
send anonymous(f ake message, SSI);

*/

Gi

Gi

9 processing period(): /* only for the selected SPs, one for each Gi */
10

while message = receive(SSI) do

sample = nE−1
sk (message);
result = result ⊕ sample;

enc resultf inal
i
send(enc resultf inal

i

, SSI);

= (Esk(Gi), nEsk(result));

15 delivery period(): /* for all SPs */
16

/* Pull the results for required {Gi} from the SSI */
foreach i in {Esk(Gi)} do

send request(Esk(Gi), SSI);
resultf inal
= nE−1
i

sk (receive(SSI));

3

4

5

6

7

8

11

12

13

14

17

18

19

and then send each group of samples to a diﬀerent SP for aggregation (lines 7-
11 in Algorithm 1 and lines 10-12 in Algorithm 2). By doing so, the advantage
is manifold. First, the processing period is guaranteed to terminate in a sin-
gle iteration, since each involved SP produces directly the aggregation result
corresponding to a spatial unit, which greatly improves both the computation
and the communication cost of the aggregation process. This is possible since
an aggregating SP receives all the samples inside a spatial unit and can thus
produce in one iteration the ﬁnal aggregated results corresponding to the unit.
This is valid for all the considered aggregated functions. However, the beneﬁts
in term of eﬃciency compared to a protocol requiring several iterations (such
as the one in [41]) are greater for holistic functions. Second, data processing
by an SP is also eﬃcient since only one aggregate is computed, which greatly
reduces the RAM requirements and avoids/reduces the usage of the persistent
storage. Third, the ﬁnal aggregate result is also partitioned and the queriers
can demand the results only for speciﬁc spatial units, which further improves
the communication cost. Furthermore, in order to avoid leaking information
regarding the spatial distribution of users, the SPs also generate and send fake
messages to the SSI (see Algorithm 2, lines 6-8). The rational and detailed
explanations for this technique are discussed in the next section.

However, despite all these beneﬁts, the above approach has one funda-
mental shortcoming originating from the skewed spatial distribution of the
participants. Although the exact location of the updates and the spatial unit
ID are hidden, the SSI knows the number of participants in each spatial unit.
If the SSI has access to side information about the spatial distribution of the

18

Iulian Sandu Popa et al.

users (e.g., global traﬃc density information), then it may use this information
to infer the approximate location of the participants (e.g., the road segment
where a group of samples have been generated). This translates into larger
privacy leakage for the users (which we quantify in Section 7.2), which indi-
cates an increase of the probability with which the SSI could link subsequent
sample updates and thus endanger the participants’ privacy.

5 Probe Partitioning Protocol

To counter the privacy threats that are rooted in the skewed spatial distri-
bution of the participants, PAMPAS continuously partitions the set of probes
based on their current location and the spatial units of the query. Similar to
the global aggregation protocol, this privacy-aware partitioning protocol is ex-
ecuted by SPs. The idea is to group SPs located in adjacent spatial units such
that the resulted probe groups have approximately the same size. Therefore,
in PAMPAS a group Gi covers several spatial units (as deﬁned in Section 3.3)
and includes all the SPs in these units. Note that in this paper we opted for
selecting spatially co-located units to constitute probe groups mainly for ’se-
mantical’ reasons. Typically, the privacy location metrics (see Section 7.2) are
deﬁned with respect to some spatial region. In general, a region refers to a
connected subspace in the related work. That being said, we believe that the
choice between regions formed by spatially co-located units or dispersed units
has little if no impact both on the eﬃciency and the security of the protocols.
Indeed, as long as the employed partitioning algorithm produces relatively
balanced groups in terms of contained number of SPs (while the remaining
diﬀerences are compensated by fake sample injections), the overall cost and
security of the protocols are preserved.

The probe partitioning has to be recomputed periodically to keep the
groups balanced since the users’ distribution in space changes over time. More-
over, the groups should contain users located in closely situated spatial units
to maximize the lifetime of a partitioning. The challenge is to implement a
partitioning algorithm that can be executed periodically at SPs because the
typical spatial partitioning algorithms are much too costly to be considered in
our context (i.e., limited-resources SPs).

Our algorithm is based on the following idea. We use a space-ﬁlling curve
to index the spatial units of the application query. A space-ﬁlling curve has
the property to map a multidimensional space to a one-dimensional space
such that, for two objects that are close in the original space, there is a high
probability that they will be close in the mapped target space. Then, we sort
the spatial units on the space-ﬁling curve index. Once sorted, an approximate
balanced grouping can be checked and computed in O(NG) space complexity
and O(N ) time complexity, where NG is the number of probe groups, and N
is the number of spatial units.

Indexing the spatial units. To allow for an eﬃcient probe partitioning
in PAMPAS, we associate an index value to each spatial unit of the query and

PAMPAS+

19

Fig. 5: Basic examples showing the indexing of spatial units in the case of free movement
(left) or constrained movement (right)

then sort the spatial units on the index values. In our system, we use Hilbert
curves to index the spatial units considered by the participatory sensing appli-
cation. The index values correspond to the indices of the Hilbert curve covering
the spatial units.

In the case of free movement, the indexing is straightforward since the
space is already partitioned with a uniform grid (see Figure 5 left). Then, we
cover the grid cells with the Hilbert curve corresponding to the grid granularity
and label each cell with the obtained Hilbert index. In the case of constrained
movement, the indexing requires two steps. First, we cover the transportation
network with a uniform grid (see Figure 5 right). The grid granularity is chosen
such that the number of network segments (see Section 3.3) intersecting with
a grid cell is low for most of the cells. Then, the grid cells are indexed with a
Hilbert curve and each network segment is labeled with the Hilbert index of
the cell containing the segment center. In case several segments are contained
by a cell, the segments are sorted by the x-coordinate and the y-coordinate of
their centers and labeled accordingly.

Once the spatial units are labeled with the Hilbert index, we sort them
on the index value to obtain a sorted unit vector. This sorted unit vector
is broadcasted to all the SPs and used, in the probe partitioning phase, as
reference by the partitioning algorithms (i.e., in both the linear partitioning
algorithm - see Algorithms 3 and 4 - and the binary partitioning algorithm -
see Algorithm 9).

Checking and repartitioning the probe grouping. Periodically, our
system veriﬁes if the current probes partitioning is still balanced with respect
to the number of probes in each group. The veriﬁcation frequency depends
on the dynamicity of users in space. In PAMPAS, the checking and reparti-
tioning processes can be executed often (i.e., every few seconds) due to their
low cost. When a partitioning checking is triggered, the system computes a
count aggregate in addition to the application aggregate function (see Fig-
ure 3), which gives the actual number of users (SPs) in all the spatial units.

20

Iulian Sandu Popa et al.

Algorithm 3: Checking probe partitioning (SP-side)

1 check probe partitioning():/* one randomly selected SP */
2

/* Pull all the results from the SSI */
foreach i in {Esk(Gi)} do

3

4

5

6

7

8

9

10

11

12

13

= receive(SSI);

send request(Esk(Gi), SSI);
enc resultf inal
i
allCounts[Gi][] ← E−1
update localy stored counts f or spatial units ;
compute groupW eights[Gi] = SU M (allCounts[Gi][])/* also required to
compute the probability to generate fake samples */;

sk (enc resultf inal

) ;

i

compute standard deviation(weights);
if standard deviation(weights) < threshold then

send f or broadcast(nEsk(groupW eighs), SSI);

else

execute probes repartitioning();

The count aggregate result is then pushed to an SP randomly chosen by the
SSI. The checker SP decrypts the results and updates the weights10 of the
sorted spatial unit vector (lines 4-7 in Algorithm 3). This operation has O(N )
complexity assuming that a small index containing the partitions frontiers is
kept in memory by the SP (which requires only NG Flash addresses to be
kept in RAM). At the same time, the SP computes in memory the count by
group (since the groups are sent one by one by the SSI, line 8 in Algorithm 3)
and compares the counts. If the balancing of the current probes partitioning
is within the predeﬁned limits, the checker SP sends the current values to
all the other SPs (i.e., exchanged encrypted through SSI), which update the
weights of the spatial units with the new count values. Otherwise, the checker
SP computes a new partitioning.

Once the sorted vector of spatial units is updated with the new weight val-
ues, the probe repartitioning can be eﬃciently computed in O(N ) and O(NG)
time and space complexity respectively (see Algorithm 4). To set the partition
borders we use a greedy algorithm, which adds spatial units to a group as long
as the total weight of the group is lower than a threshold value (lines 12-17
in Algorithm 4). The threshold is computed as the ratio between the total
number of probes and the number of groups (line 10 in Algorithm 4), and
represents the average number of users per group. The partitioning result is a
list of NG milestones indicating the group borders in the sorted index of spa-
tial units (line 15 in Algorithm 4). The result is then encrypted and delivered,
through SSI, to all users, which update their partitioning data and generate
new samples accordingly starting from the next computation window.

The proposed probes partitioning algorithm has low complexity and can
be eﬃciently executed even with the low resources of an SP. However, the
partitioning algorithm cannot guarantee a certain degree of balancing of the

10 The weight is the number of probes in a spatial unit.

PAMPAS+

21

Algorithm 4: Repartitioning process (SP-side)

1 PROBE REPARTITIONING():/* one randomly selected SP */
2

compute QI comp and QI comm for current NG;
while true do

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

/* adjust the number of groups NG */
if QI comp > QI comm then

tNG = 2 ∗ NG;

else

tNG = NG/2;

/* repartition for tNG */
avgGroupW eight = SUM(groupW eights[])/tNG;
currentGroupW eight = 0;
for i = 0 to N − 1 do

currentGroupW eight+ = allCounts[i];
if currentGroupW eight ≈ avgGroupW eight then

newP artitionM ilestones[].add(i);
newGroupW eights[].add(currentGroupW eight);
currentGroupW eight = 0;

/* check if the new partitioning for tNG is better than for NG*/
compute tQI comp and tQI comm for tNG;
if tQI comp + tQI comm < QI comp + QI comm then

NG = tNG; QI comp = tQI comp;
QI comm = tQI comm;

else

break;

message = newGroupW eights[]||newP artitionM ilestones[];
send f or broadcast(nEsk(message), SSI);

partition weights. Yet, the partitioning balancing is required to avoid leaking
any information regarding the spatial distribution of users. To deal with this
problem, the SPs generate fake samples in all the probe groups having a num-
ber of users lower than the maximum size group. Therefore, in the collection
period of each computing time window, an SP sends probabilistically a dummy
sample in addition to the real sample. The probability to send a fake sample is
proportional to the diﬀerence between the maximum size group and the num-
ber of users in the SP’s group, and inversely proportional to the number of
users in the group (see Algorithm 2, lines 6-8). The same approach is used to
hide the number of spatial units in each group. At the end of the aggregation
phase, each aggregating SP adds to the result a number of fake values equal
to the diﬀerence between the maximum number of units in the groups and the
number of units in the current group. In this way, all the partial aggregate
results received by the SSI have the same size and the SSI cannot infer the
number of units in any group. Note that the fake values are ﬁltered out by the
worker or querier SPs and therefore have no impact on the accuracy of the
results.

22

Iulian Sandu Popa et al.

Choosing the number of probe groups. The cost of the aggregation
protocol is composed of the computation cost at the SP side and the communi-
cation cost between the SSI and the SP. The number of probe groups impacts
both the computation and the communication costs. Speciﬁcally, the compu-
tation cost decreases with the increase in the number of groups and attains the
minimum value when the number of groups is equal to the number of spatial
units, i.e., an SP is used to aggregate the samples for each spatial unit. But
increasing the number of groups leads to a higher imbalance in the groups’
weights, which in turn requires injecting more fake samples and enlarges the
communication cost. Therefore, modifying the number of groups has opposite
eﬀect on the computation and the communication cost.

QI comp = M axi=1,NG [Comp timei] − M axj=1,N [Comp timej]

(1)

QI comm =

size(sample)
bandwidth

size(sample)
bandwidth

NG(cid:88)

i=1

NG(cid:88)

i=1

{M axj=1,NG[Countj(probes)] −

Counti(probes)} +

{M axj=1,NG[Countj(spatialU nits)] −

Counti(spatialU nits)}

(2)

PAMPAS computes two quality indicators to measure the impact of the
number of groups on the computation and communication costs, i.e., QI comp
and QI comm, as deﬁned by Formulas (1) and (2). QI comp estimates the degra-
dation of the computation time at the SP side generated by the fact that
several spatial cell aggregates are delegated to one SP instead of using one
SP for each cell. Estimating the computation time is fairly simple since the
time is typically linear with the number of samples to be processed by the
SP, assuming that the aggregation can be entirely processed in RAM. The
cost model can be extended to the case in which it is required to access the
secondary storage. QI comm estimates the degradation of the communication
cost caused by the imbalance of the group weights. The ﬁrst term indicates the
overhead incurred by the fake samples generated to balance the groups, while
the second term measures the overhead of generating fake results to balance
the number of aggregate results in each group.

Each time an SP computes the probe partitioning, it also computes the
values of QI comp and QI comm (line 2 in Algorithm 4). If QI comp > QI comm,
the SP multiplies by two the number of groups and re-partitions the probes.
If QI comp < QI comm the SP divides by two the number of groups and re-
partitions the probes (lines 5-8 in Algorithm 4). The SP continues to adjust
the number of groups until QI comp + QI comm has minimum value (lines 20-24
in Algorithm 4), meaning that the aggregation cost is near optimal. Thus, this
process allows adapting the number of groups to the number and the spatial
distribution of the probes.

PAMPAS+

6 PAMPAS+

23

In this section, we present an improved version of the proposed PAMPAS
protocol that we name PAMPAS+. The objective of PAMPAS+ is twofold.
First, PAMPAS+ enforces the security of the base protocol by taking into
account an enlarged threat model compared to the threat model introduced
in Section 3.2. Our second objective is to limit as much as possible the impact
of the increased security on the protocol requirements that were deﬁned in
Section 3.4. Speciﬁcally, the increased security should not be achieved at the
price of a signiﬁcant tradeoﬀ with the desirable features of PAMPAS, i.e.,
privacy, generality, eﬃciency, scalability and accuracy.

We introduce ﬁrst the extended threat model of PAMPAS+. Then we
present the modiﬁed aggregation and partitioning protocols of PAMPAS+.
The analysis of the privacy level and eﬃciency of PAMPAS+ in comparison
with the basic PAMPAS protocol are presented in Section 7 and Section 8
respectively.

6.1 Extended threat model

The PAMPAS protocol is based on four assumptions enunciated in Section 3.2.
In particular, Assumption 1 considers that the SPs are inviolable, which is rea-
sonable since the SPs integrate tamper-resistant hardware. Hardware protec-
tion has the salient advantage of precluding software and simple (low-budget)
hardware attacks. Yet, no hardware security can be described as unbreakable.
For this reason, in many cases the security of a system is rather evaluated by
comparing the estimated cost of a successful attack with the potential beneﬁt.
If the beneﬁt of a successful attack is much lower than its cost (e.g., ﬁnancial
or invested time), the system can be reasonably assumed to be secure. In the
opposite case, the system can be considered at risk. In the light of this consid-
eration, we revisit below the ﬁrst assumption of the base threat model. The
rest of the assumptions (2 to 4) deﬁned in Section 3.2 remain unchanged.

Assumption 1’. We assume that one or a few SP owners have the means to
conduct an advanced lab attack on the devices in their possession. A lab attack
is usually described as an invasive hardware attack for which the attacker has
the knowledge to perform reverse engineering of a device and also has access
to the necessary laboratory equipment. Such an attack, if successful, can oﬀer
the attacker access to secret cryptographic material (e.g., the secret encryption
keys) stored inside the device.

This new assumption has a major impact on the threat model. Let us
consider that following a successful attack, the attacker colludes with the SSI
by revealing to the SSI the shared secret key used to encrypt the messages
that are exchanged between SPs. In this case, the SSI can decrypt all the
messages in transit. In particular, the SSI has access to the update messages
from SPs containing the location of each user. Therefore, the privacy of all the
participants can be entirely compromised.

24

Iulian Sandu Popa et al.

Although the cost of the above presented attack is hard to estimate, this
shows that the risk of successfully corrupting one SP is to reveal to the attack-
ers all the sensitive information that are managed by the system. Therefore,
the ﬁrst objective of PAMPAS+ is to protect the participants against this
type of attack. To this end, we extend the threat model deﬁned in Section 3.2
by taking into account the possibility that a few participating SPs could be
corrupted, while the vast majority of the SPs remain trusted. Speciﬁcally, our
extended threat model is based on two main assumptions. First, even if a lab
attack on one or a few SPs is costly, it can be interesting for an attacker if
the attack beneﬁt is high. In our case, a high beneﬁt is equivalent to getting
access to a signiﬁcant amount of the private information. Second, we consider
that an attacker can directly access, at most, a very limited number of SPs
and therefore could control only a few SPs in the system. In other words, we
do not consider the case of a powerful state-size attacker that would be able to
control a signiﬁcant proportion from the total number of SPs. In this context,
PAMPAS+ searches to minimize the information leakage by the corrupted SPs
and to avoid a complete “meltdown” of the system as it would be the case for
the base protocol. The idea is to ensure that the amount of privacy leakage
remains proportional with the ratio of corrupted SPs in the system and there-
fore impose to an attacker to corrupt many SPs to gain access to a signiﬁcant
amount of private data, which contradicts the assumption above.

6.2 Aggregation Protocol in PAMPAS+

The main idea in PAMPAS+ is to avoid using a single shared key to encrypt
all the messages that the SPs exchange and that are relayed by the SSI. An
alternative to using the SSI as a message dispatcher would be to employ direct
point-to-point communications between the SPs. However, this latter solution
is not feasible in our context since it implies large resource consumption at
the SP side. For instance, in the aggregation phase the aggregating SPs would
have to manage a high number of connections (e.g., hundreds or thousands) in
a very short time window (i.e., during the duration of the aggregation phase),
which is not reasonable. For this reason, we still employ the SSI in our system
architecture.

Nevertheless, to avoid the risk of complete meltdown in case of a successful
lab attack on an SP, we propose in PAMPAS+ that each message transmitted
by an SP to the SSI to be encrypted such that only the recipient SP can
decrypt it. We have basically two options to achieve this. The ﬁrst is to use an
asymmetric public-secret key encryption (e.g., RSA encryption). Typically, in
the aggregation phase, the SPs in a group are informed about the identity of
the aggregating SP. Therefore, all the messages in the group are encrypted with
the public key of the aggregating SP. This public key can be broadcasted at the
beginning of aggregation phase for the SPs that do not have it. The problem
with this approach is the relatively large cost of the asymmetric encryption. For
instance, with our secure tokens, the cost of encrypting/decrypting a message

PAMPAS+

25

Algorithm 5: PAMPAS+ couple keys exchange protocol at the SSI-side
1 SSI-side():
2

/* Execution thread at SSI managing system join requests from new SPs */
while true do

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

joinM essage(SP i) = (certif icate SP i, certif iedID SP i) ;
newDeliveryListi = {allRegisteredSP s} ;
associate joinM essage(SP i) to newDeliveryListi ;
add newDeliveryListi to {allDeliveryLists} ;
foreach listk in {allDeliveryLists} do

/*Send join messages to the currently connected SPs*/
targets = listk → getDeliveryList() (cid:84){allConnectedSP s};
broadcast(joinM essage(newSP k), targets);
remove targets from listk;
if isEmpty(listk) then

delete listk;

{allRegisteredSP s} = {allRegisteredSP s} (cid:83) SP i ;

/* Execution thread at SSI for dispatching couple key messages to SPs */
while true do

newCoupleKeyM essage = (targetj , certif icate SP i,
certif iedID SP i, AE P Kj (CoupleKeyij )) ;
add newCoupleKeyM essage to {allCoupleKeyM essages};
foreach message in {allCoupleKeyM essages)} do

/* Push couple key messages to the currently connected SPs*/
target = message → getT arget();
if isConnected(target) then
unicast(message, target);
remove message from allCoupleKeyM essages;

using RSA with a key length of 256 bytes is around 0.4/0.6 seconds. This leads
to a large aggregation time, which is mostly explained by the high decryption
time that dominates the overall cost of the aggregation at the aggregating SP,
and to not respecting the eﬃciency requirement of the protocol.

The second and retained option is to use the very eﬃcient symmetric en-
cryption (e.g., AES 256) as in the base protocol. This requires that for any two
SPs participating in the system, there has to be a shared symmetric encryp-
tion key only known by the two SPs (called couple key hereafter) and used to
encrypt/decrypt all the messages that are exchanged between the two SPs.

Couple keys exchange protocol. Let us note that the secret couple keys
cannot be generated on the ﬂy in real-time. For example, at the aggregation
time, the aggregating SP would have to contact and establish a secret key with
all the SPs in its partition with which a secret key has not been established
before. This is much too costly since it requires exchanging asymmetrically
encrypted messages which incur an important processing time as described
above.

Therefore, the secret couple keys have to be generated ”oﬄine” (i.e., outside
the aggregation process) (see Algorithms 5 and 6). Typically, when a new SP
registers in the system, it sends a ”Hello” message to the SSI containing its

26

Iulian Sandu Popa et al.

Algorithm 6: PAMPAS+ couple keys exchange protocol at the SP-side
1 startRegistration(): /* for each newly arrived SP */
2

/* Build a certiﬁed ID to be send to all the other registered SPs*/
certif iedID SP i = AE SKi(Hash(inf o SP i)) /*Where
inf o SP i = (P ublicKey SP i, alias SP i/IP address SP i) */;
/* Send a couple-key generation request to all the other registered SPs*/
joinM essage SP i = (certif icate SP i, certif iedID SP i) ;
send f or broadcast(joinM essage SP i, SSI);

3

4

5

6

7 coupleKeyCreation(): /* for the connected SPs selected by the SSI */
8

joinM essage = receiveJoinM essage(SSI);
certif icate SP i = joinM essage → certif icate SP i;
certif iedID SP i = joinM essage → certif iedID SP i;
authentic = verif yCertif icate(certif icate SP i, certif iedID SP i);
if authentic then

newCoupleKey = AESRandomKeyCenerator();
certif iedIDself = AE SKself (Hash(inf oself ));
newCoupleKeyM essage = (target SP i, certif icateself ,
certif iedIDself , AE P Ki(newCoupleKey)) ;
send f or unicastcast(newCoupleKeyM essage, SSI);
add (newCoupleKeyM essage, tagij ) to CoupleKeyIndex;
/* the tagij is computed separately by SP i and SP j as Hash(P Ki(cid:107)P Kj )
such as P Ki < P Kj */

9

10

11

12

13

14

15

16

17

18

21

19 coupleKeyRegistration(): /* for the newly registering SP */
coupleKeyM essage = receiveCoupleKeyM essage(SSI);
20
certif icate SP i = coupleKeyM essage → certif icate SP i;
certif iedID SP i = coupleKeyM essage → certif iedID SP i;
authentic = verif yCertif icate(certif icate SP i, certif iedID SP i);
if authentic then

22

24

23

25

26

27

28

encryptedCoupleKey = coupleKeyM essage →
AE P Kself (newCoupleKey);
newCoupleKey = AE SK−1
add (newCoupleKeyM essage, tagij ) to CoupleKeyIndex;
/* the tagij is computed separately by SP i and SP j as Hash(P Ki(cid:107)P Kj )
such as P Ki < P Kj */

self (encryptedCoupleKey);

identiﬁcation (i.e., signed certiﬁcate proving that it is an SP and containing
its public key, see lines 1-6 in Algorithm 6 and lines 4-7 in Algorithm 5). This
message is broadcasted by the SSI to all the already registered SPs (lines 8-14
in Algorithm 5). At receiving a ”Hello” message, each SP generates a secret
random key used to communicate with the newly arrived SP, encrypts the
secret key with the public key of the new SP and sends the encrypted message
(lines 7-16 in Algorithm 6) to the SSI that will push it to the new SP. Both the
SP generating the couple key and the newly registered SP add the new couple
key to their couple key index using a couple key tag (lines 17-18 and 25-28
in Algorithm 6). More details about the usefulness of the couple key tags are
given in Algorithms 8 below.

This process can be costly (i.e., the number of exchanged messages is pro-
portional with the number of registered SPs) but it does not have to cope with

PAMPAS+

27

real-time constraint of the main aggregation process. The major inconvenient
is that a new SP entering the system cannot communicate with another SP
until the corresponding couple key is not created.

The idea of generating pairwise shared AES keys is a standard method
to increase cryptographic eﬃciency (instead of using asymmetric encryption
based on the public/private key). The same goes for the couple key exchange
protocol which is based on the classical approach of using the PKI certiﬁcates
to authenticate the two nodes to each other and also permit the secure cou-
ple key exchange. Note also that the security practices require to periodically
update the couple key to prevent an attacker that obtains the key to gain
access to the entire history of exchanged messages. However, in the context
of distributed data aggregation using secure hardware, the idea to use a dedi-
cated secret key to secure the data exchange between each couple of peers is
novel. For instance, [41, 42] use a single secrete key shared among all peers
as in the basic PAMPAS protocol. Similarly, in the context of distributed
privacy-preserving data publishing with secure hardware, [1] uses the tradi-
tional approach that divides the peers into several clusters and employs one
key for each cluster. Thus, in case of a lab attack, the data leakage is contained
to the participants belonging to the same cluster as the compromised peer. In
our context, the clusters correspond to the probe groups obtained through
partitioning. Nevertheless, this approach is not feasible in PAMPAS because
the high mobility of the participants leads to frequent probe repartitioning,
which in turn requires the costly operation of renewing the group keys at each
repartitioning.

By using a dedicated key for each pair of SPs, PAMPAS+ achieves a much
stronger security level, while protecting the privacy of the participants even
in case of successful lab attacks (as discussed in Section 7.3). On the other
hand, the increased security introduces a computational overhead since the
probes have to manage a large set of keys instead of a single key. The second
major contribution of PAMPAS+ is to propose optimizations to alleviate this
problem and keep the protocol eﬃcient and scalable. There are two signiﬁcant
optimizations. The ﬁrst optimization is the tagging and indexing of the shared
keys by each SP, which allows an optimal retrieval of the encryption key for
each received update sample. The second optimization is a new partitioning
algorithm able to compute a more balanced partitioning (see Section 6.3),
which reduces the number of inserted fake samples and thus improves the
aggregation time (see Sections 8.3 and 8.4).

Shared encryption key. The couple keys allow a secure data exchange
between SPs through the SSI during the collection and processing periods
(see Figure 4). Nevertheless, the global PAMPAS protocol also includes a de-
livery period and a probe partitioning process. The delivery period consists
in delivering the aggregation results to the participating SPs. The partition-
ing process consists in checking the current partitioning based on the spatial
distribution of the SPs and in computing and delivering to all the SPs a new
probe partitioning, if the current one is unbalanced. To keep the delivering
of the aggregation and the partitioning results eﬃcient, we continue to use in

28

Iulian Sandu Popa et al.

PAMPAS+ a shared encryption key as in the initial PAMPAS protocol (see
Section 4). Otherwise, the aggregating SP or the probe partitioning SP would
have to individually encrypt and send the results to the other SPs, which would
consume too many resources of the worker SP and take signiﬁcant time.

Using a shared key in the delivery phase of the aggregation protocol has
no impact on the privacy guarantees of our protocol since as indicated in
our threat model (see Section 3.2), our protocol focuses on the protection
of the raw data and the aggregation process and not on the exposure risks
that arise from analyzing the aggregate results. However, using a shared key
for delivering the partitioning results has the inconvenient of reducing the
privacy guarantees of the protocol in case of a successful lab attack. This is
thoroughly analyzed in Section 7.3. For now, let us note that this does not call
into question the complete security of the PAMPAS+ protocol, but merely the
level of the privacy oﬀered by the proposed protocol.

Global aggregation in PAMPAS+. Algorithms 7 and 8 present the
aggregation protocol in PAMPAS+ at the SSI-side and SP-side respectively.
The new protocol is similar with the basic protocol of PAMAPS and consists of
a collection period, a processing period and a delivery period. Compared with
the basic protocol, there are two major modiﬁcations in PAMPAS+. First,
the selection of the aggregating SPs is done at the beginning of the collection
period and not during the processing period. The reason is that the list of
the worker SPs has to be broadcasted to all the SPs beforehand so that each
participating SP can choose the appropriate couple key (i.e., the couple key
corresponding to the aggregating SP in its partition) to encrypt its sample
data (lines 2-7 in Algorithm 7 and lines 2-5 in Algorithm 8).

Second, each sample is encrypted using a couple key instead of the shared
key (lines 6-10 in Algorithm 8). Beside, each SP holds a hash index allowing
to eﬃciently retrieve the couple key shared with another SP (line 7 in Algo-
rithm 8). The couple key is also associated with a unique tag generated at
the creation of the key and shared by the two SPs holding the key. The tag is
required in the processing period to allow an aggregating SP to know which
couple key to use to decrypt a sample (lines 18-20 in Algorithm 8) since the
samples are anonymously sent to the SSI (line 11 in Algorithm 8). A second
hash index is equally built on the couple keys to allow the eﬃcient retrieval of
a couple key given the associated tag (line 19 in Algorithm 8). As in the basic
protocol, the SPs probabilistically send fake samples to compensate for the
unbalanced number of probes in the groups. Finally, we note that the security
of the protocol, and in particular the case of corrupted aggregating SPs, is
analyzed in Section 7.3.

6.3 Partitioning Protocol in PAMPAS+

In this section, we propose a new probe partitioning algorithm to be used with
PAMPAS+. We note from the beginning that the initial partitioning protocol
proposed in Section 5 can be applied without any change in the context of

PAMPAS+

29

Algorithm 7: PAMPAS+ aggregation protocol at the SSI-side
1 collection period():
2

/* Randomly select an SP for each group and broadcast the list to all connected
SPs */
aggSP List = EM P T Y ;
foreach i in {Esk(Gi)} do
randomly select SP i;
aggSP List.addP air(SP i, Esk(Gi)) ;

broadcast(aggSP List) ;
/* Receive encrypted updates from SPs */
while true do

message = (Esk(Gi), nE ckij (sample), tag ckij ) ;
store(message) → list[Esk(Gi)][currentT imeW indow];

3

4

5

6

7

8

9

10

11

12 processing period():
13

foreach i in {Esk(Gi)} do

14

15

16

17

18

19

/* feed in parallel the selected aggregating SPs */
while message ← list[Esk(Gi)][lastT imeW indow] do

send(message, SP i);

foreach i in {Esk(Gi)} do

/*Receive the ﬁnal results from the worker SPs*/
encResultf inal

= (Esk(Gi), nEsk(result));

i

20 delivery period():
21

foreach i in {Esk(Gi)} do

22

23

/*Send resulti to all requesting SPs*/
multicast(encResultf inal

, {SP k});

i

PAMPAS+. Thus, the new partitioning algorithm proposed in this section is
not motivated by a lack of compatibility but by the need of increasing the
eﬀectiveness. Speciﬁcally, our initial partitioning algorithm (lines 9 to 17 in
Algorithm 4) is very eﬃcient, its cost being linear with the number of spatial
units (i.e., O(N ) and O(NG) time and space complexity respectively, where N
is the number of spatial units and NG is the number of groups). However, this
high eﬃciency is counterbalanced by the quality of the obtained partitioning
(i.e., the balance factor with respect to the number of probes in the obtained
partitions) since the partitioning decisions are taken based on local knowledge
of the probe distribution in the spatial units.

The main objective of the new partitioning algorithm is to propose an
alternative to the base algorithm which oﬀers a diﬀerent tradeoﬀ between
the eﬃciency and the quality of the partitioning. The new algorithm (see
Algorithm 9) can increase the partitioning quality by making partitioning
decisions that are based on the global knowledge of the probe distribution in
the spatial units. The idea behind the proposed algorithm is to recursively
split the sorted vector of spatial units such that the total number of probes is
balanced as most as possible in the two obtained sub-vectors. This is equivalent

30

Iulian Sandu Popa et al.

6

5

4

3

Algorithm 8: PAMPAS+ aggregation protocol at the SP-side
1 collection period(): /* for all SPs */
/* Get the list of aggregating SPs */
2
aggSP List = receive(SSI);
/* Get the aggregating SP for this SP’s current group */
aggSP = getSP (aggSP List, Esk(Gi));
/* Get the couple key and the key tag corresponding to this SP and the
aggregating SP */
CKij = getCK(aggSP );
tagij = CKij → tag;
/* Generate and send the sensing update: update(Gi, sample) */
message = (Esk(Gi), nE ckij (sample), tagij ) ;
send anonymous(message, SSI);
/* Send a fake sample to the SSI with probability P f ake
if rand(0, 100) ≥ P f ake
then

*/

Gi

8

9

7

Gi

f akeM essage = (Esk(Gi), f akeSample, f akeT ag) ;
send anonymous(f akeM essage, SSI);

16 processing period(): /* only for the selected SPs, one for each Gi */
17

while message = receive(SSI) do
tagij = message → tagij ;
CKij = getCK(tagij );
sample = nE ck−1
result = result ⊕ sample;

ij (message);

encResultf inal
i
send(encResultf inal

i

, SSI);

= (Esk(Gi), nEsk(result));

24 delivery period(): /* for all SPs */
25

/* Pull the results for required {Gi} from the SSI */
foreach i in {Esk(Gi)} do

send request(Esk(Gi), SSI);
resultf inal
= nE−1
i

sk (receive(SSI));

10

11

12

13

14

15

18

19

20

21

22

23

26

27

28

to building a binary partitioning tree on the sorted vector of spatial units of
height h = log(NG).

The binary partitioning algorithm is implemented as a recursive function
(lines 23-32 in Algorithm 9). The function isLeaf (line 24) decides if a node is
internal (and therefore needs to be split) or not, while the split function deter-
mines the optimal position in the current node to do the split. The price to pay
for the potential higher quality of the partitioning is an increased computa-
tional complexity. Nevertheless, the complexity of the new algorithm remains
low and as we show in Section 8.3, it can still be used in real-time in our
context. Speciﬁcally, the new algorithm has O(N × log(NG)) and O(NG) time
and space complexity respectively.

Parallel partitioning. Beside, the partitioning algorithm can be easily
parallelized (i.e., executed in parallel by several SPs), which can drastically
reduce its execution time. As opposed to the base partitioning, several SPs can
be involved in the partitioning process of PAMPAS+. Speciﬁcally, there is a

PAMPAS+

31

Algorithm 9: Repartitioning process in PAMPAS+ (SP-side)
1 PROBE REPARTITIONING():/* one randomly selected SP */
2

compute QI comp and QI comm for current NG;
while true do

/* adjust the number of groups NG */;
if QI comp > QI comm then

tNG = 2 ∗ NG;

else

tNG = NG/2;

/* repartition for tNG */;
curN ode = 0;
mileStone1 = 0; mileStone2 = N − 1;
treeT able = new T reeT able();
BinaryPartitioning(treeT able, mileStone1, mileStone2,

curN ode, tNG);

/* check if the new partitioning for tNG is better than for NG*/
compute tQI comp and tQI comm for tNG;
if tQI comp + tQI comm < QI comp + QI comm then

NG = tNG; QI comp = tQI comp;
QI comm = tQI comm;

else

break;

send f or broadcast(nEsk(treeT able), SSI);

22 BinaryPartitioning(treeTable, mileStone1, mileStone2, curNode, tNG)
23

treeT able[curN ode].Inf o = [mileStone1, mileStone2];
if not isLeaf(treeT able[curN ode], tNG) then

treeT able[curN ode].T ype = Internal N ode;
splitP oint = split(treeT able, mileStone1, mileStone2,

curN ode);

child1 = new Child();
chile2 = new Child();
BinaryPartitioning(treeT able, mileStone1, splitP oint,
child1, tNG);
BinaryPartitioning(treeT able, splitP oint + 1, mileStone2,
child2, tNG);

else

treeT able[curN ode].T ype = Leaf N ode;

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

24

25

26

27

28

29

30

31

32

coordinator SP that triggers the partitioning and computes the top levels of the
binary partitioning tree. Then, the coordinator SP distributes the remaining
partitioning of the bottom levels of the tree to other SPs. The ﬁnal partitioning
results are in the end aggregated by one selected SP (e.g., the coordinator
SP). The beneﬁt of this approach is that the bottom levels of the partitioning
tree are computed in parallel by several SPs. On the other hand, a parallel
partitioning also entails a communication cost between the participating SPs.
We study these aspects in detail and compare the eﬃciency and eﬀectiveness
of the two proposed partitioning algorithms in Section 8.3.

32

Iulian Sandu Popa et al.

Let us ﬁnally note that the checking of the probe partitioning in PAMPAS+
is done exactly the same as in the base protocol (see Algorithm 3) and therefore
further discussions on this aspect are omitted in this section.

7 Security and Privacy Analysis

In this section, we discuss the security and privacy of the proposed proto-
cols. We analyze ﬁrst the security and privacy of the base PAMPAS protocols
in Section 7.1 and 7.2 respectively. Then, we analyze the additional privacy
protection oﬀered by PAMPAS+ in comparison with the base PAMPAS in
Section 7.3.

7.1 Security Analysis

The security analysis presented in this section is valid if all the four assump-
tions presented in Section 3.2 hold. The users cannot read the raw data of other
users because the data stored in memory is protected by the secure MCU (i.e.,
the RAM is located inside the MCU) and the data stored in NAND Flash are
cryptographically protected.

The SSI does not have the encryption key, so it cannot access the transiting
data. In addition, the non-deterministic encryption protects the data against
frequency-based attacks. The SSI may also try to buy an SP and pass for
a user to gain access to the shared encryption key. However, this would be
useless since the tamper-resistance of an SP protects the key. The SSI could
collude with a querier, but it will gain access only to the aggregate result.
Finally, since the samples are communicated through anonymizers, the SSI
cannot identify the senders or link consecutive messages from the same user.
The SSI could try to infer information from the deterministically encrypted
group ID values. Nevertheless, the SSI cannot perform a frequency-based at-
tack using the encrypted group ID, since all the groups contain approximately
the same number of messages. Therefore, the SSI cannot infer the correspond-
ing (approximate) location of a group or the topological neighborhood of the
groups (which would be the ﬁrst step to attack the users’ privacy). Hence, the
only knowledge the SSI acquires is the number of groups and its evolution over
time, which does not endanger the users’ privacy. Note that even if the SSI
has somehow access to the full partitioning information and the corresponding
encrypted ID, a user is still hidden under the corresponding group area and
within the crowd in the same group (let us recall that the messages are sent
anonymously so it is hard for the server to link the messages coming from the
same user). Hence, the protocols are secure and fully protect the raw data
generated by the users.

Although protecting the privacy of users beyond the aggregate results is out
of the scope of this paper (as discussed in Section 3.2), one can easily integrate
basic protection mechanisms in PAMPAS for such cases. For example, to avoid

PAMPAS+

33

the risk of exposure for the users situated in very sparse areas (e.g., a single
user or very few users located in a spatial unit), we can simply add a predicate
in the HAVING clause of the aggregate query (see Figure 3) indicating the
minimum number of users in a spatial unit. In this way, the sparse spatial
units are eliminated from the aggregate results. Another solution is to increase
the size of the sliding window or of the spatial units accordingly.

7.2 Privacy Analysis

As discussed in the previous section, neither the SP users, nor the SSI have
access to the samples (containing the exact locations of the probes) or the in-
termediary results generated by the SPs. Hence, the privacy leakage can only
be described in terms of statistical information exposure or location obfusca-
tion level. To underline the high level of privacy protection of PAMPAS w.r.t.
the SSI, we consider two metrics, i.e., an entropy-based metric and a location
obfuscation metric, and apply them in the context of two scenarios that are
related to our architecture. We then compare the privacy leakage in these two
scenarios with the privacy leakage in PAMPAS. We focus on the privacy leak-
age only at the SSI side since the SSI is untrusted and constitutes the transit
point of all the probe generated data, while an SP gets external probe data
sporadically (i.e., only when it is selected as aggregating SP).

Entropy-based metric. Entropy is a popular metric to describe location
privacy in general [11], and it is also appropriate to describe the privacy-
preserving mechanism of PAMPAS, similar to the work in [32]. Commonly,
entropy is used to quantify the average degree of uncertainty associated with
a set of events. In the case of location privacy, the idea is to prevent user
identiﬁcation by obfuscating her exact location in a spatial region containing
a certain number of individuals. Therefore, the level of privacy is directly
related to the popularity (i.e., number of individual footprints) of the region.
This means the higher the popularity, the higher the privacy level of the users
in that region. Then, entropy is used to quantify the degree of popularity of a
region. Formally, let reg be a spatial region and let U (reg) = {u1, u2, . . . up}
be the set of users in region reg. Let fi (with 1 ≤ i ≤ p) be the number of
sample updates (i.e., footprints) that user ui sends from reg and F = (cid:80)p
i=1 fi
be the total number of sample updates sent from reg.

Deﬁnition 1 Entropy of a region: the entropy of region reg is deﬁned as:

E(reg) = −

p
(cid:80)
i=1

F . log fi
fi
F .

Deﬁnition 2 Popularity of a region: the popularity of region reg is deﬁned
as:

P op(reg) = 2E(reg).

34

Iulian Sandu Popa et al.

Deﬁnition 3 Entropy privacy leakage: the entropy privacy leakage for each
updatek sent by user ui is deﬁned as:

entropy leakui(updatek) =

1
P op(location of updatek) .

The value of the entropy leakage for an update varies between 0 and 1,
with 0 indicating that there is no entropy leakage and 1 indicating a maximum
entropy leakage. The minimum value is obtained when the popularity of the
considered region is extremely high, i.e., there is a very large number of users
inside the region. The maximum value is obtained in the opposite case, i.e.,
the user is alone inside the region.

Location obfuscation-based metric. Location obfuscation is a widely
used technique in mobile applications to protect the user privacy [11], e.g., to
protect the identity [9] or the behavior [12] of the user. The idea is simple: the
exact user location reported in an update is replaced with a region containing
the user location [19], [20]. The larger the region is, the larger the obfuscation
and hence the protection. The protocols in PAMPAS do not reveal exact probe
locations to the SSI but leak some information regarding the group to which
each sample belongs to. Since each group is associated with a spatial partition
in the observed space (representing a region or a set of road segments), the
location obfuscation becomes a relevant metric in our context, e.g., if the
SSI knows the spatial extent of the partitions. Let obs space denote the total
observed space (two-dimensional or network) of an MPSS app. Let obf region
be the obfuscation area of an update with obf region ⊆ obs space.

Deﬁnition 4 Location privacy leakage: the location privacy leakage for each
updatek sent by user ui is deﬁned as:

location leakui(updatek) =





1 − size(obf region)
α·size(obs space) ,

if size(obf region)

≤ α · size(obs space)

0,

if size(obf region)

> α · size(obs space)

where α is a real value indicating the relative location sensitivity w.r.t. the
size of observed space.

Deﬁnition 4 oﬀers a simple way to quantify location leakage, with normal-
ized values between 0 and 1 as for the entropy leakage. It indicates that the
location privacy leakage for an update depends on the area of the obfuscation
region hiding the real location in the case of non-constrained movement or on
the total length of network segments in the region in the case of constrained
movement. If the obfuscation space is greater than the entire application space
multiplied by the location sensitivity factor α then the location leakage is min-
imum, i.e., 0. If the update contains the exact location of the user (i.e., a point
in space), the leakage has maximum value, i.e., 1. The location sensitivity fac-
tor α is a parameter indicating the region size (relative to the observed space

PAMPAS+

35

size) from which there is a location privacy leakage. For instance, for α = 0.01,
there is a location leakage only when the obfuscation region is smaller than
1% of the observed space.

To compute the privacy leakage in diﬀerent cases, we consider a simple
numerical example inspired by the datasets used in our experimental evalu-
ation (see Section 8.1). Let us consider that 200 thousand users participate
in a mobile sensing application that aggregates data over 20 thousand spatial
units (e.g., road segments in a road network). To keep the formulas tractable
(but without loss of generality), let us consider that each user produces 50
samples from 50 distinct spatial units. This implies that on average, there are
500 footprints (i.e., updates) in each spatial unit. Finally, we consider that
there is a location privacy leakage only when the obfuscation region is smaller
than 200 times the average road segment length, i.e., α = 0.01.

1

Scenario 1: there is no grouping of the probes. Each participant sends
the non-deterministically encrypted value of a sample together with the deter-
ministically encrypted value of the spatial unit identiﬁer to allow an eﬃcient
aggregation of the data. However, no fake sample is inserted by the probes. Al-
though the spatial unit identiﬁers are encrypted, the SSI could easily determine
the location of the spatial units if it has access to the global spatial distribution
of the probes (i.e., a frequency-based attack). In this case, the average entropy
of a spatial unit by applying Deﬁnition 1 is E(s.unit) = − (cid:80)500
500 =
i=1
log(500), which gives a popularity of P op(s.unit) = 500 and an average en-
tropy leakage of entropy leak = 0.002 for each update. Clearly, the privacy
leakage can be lower or higher for each spatial unit depending on the popu-
larity value compared with the average value. Similarly, the average location
leakage is location leakui = 1 − Average road segment length

0.01·T otal road segment length = 0.995.

500 .log 1

Scenario 2: there is a static partitioning of probes, i.e., the spatial units
are statically partitioned into a number of groups containing closely located
spatial units. As in the previous case, the probes send the deterministically
encrypted value of the spatial group and are also exposed to a frequency-
based attack from the SSI. However, grouping many spatial units leads to
decreasing the privacy leakage risk (but at the cost of increased aggregation
time). For instance, partitioning the spatial units in 200 groups (i.e., 100 spatial
units per group), leads to an average popularity P op(group) = 103 and thus
an average privacy leakage entropy leak(update) = 10−3, which is smaller
than in the previous scenario. Also, the obfuscation region is much larger
since it corresponds to 100 spatial units instead of one, i.e., location leakui =
1 −

0.01 · 200 = 0.5.
PAMPAS goes even further in the protection of the participants’ privacy
by using a dynamic partitioning of the probes based on their location and spa-
tial distribution. The adaptive partitioning produces nearly balanced groups
of probes. In addition, the eventual imbalance of the groups is corrected by
injecting fake tuples, which precludes the SSI doing frequency-based attacks.
This means that it is extremely diﬃcult for the SSI to estimate even the
approximate corresponding area of each group. Therefore, in our case, the en-
tropy applies indistinguishably to all the participants leading the a popularity

1

36

Iulian Sandu Popa et al.

P op(group) = 2 · 106 and an average privacy leakage entropy leak(update) =
5 · 10−7, while the location leakage is location leakui = 0. Practically, in PAM-
PAS, the privacy leakage depends only on the total number of participants,
while the obfuscation area corresponds to the entire observation space. Besides,
the number of groups is adaptively chosen such as to minimize the aggregation
cost.

7.3 Privacy Beneﬁts of PAMPAS+

The ﬁrst observation is that PAMPAS+ oﬀers the same privacy level as PAMAPS
if the base threat model (see Section 3.2) is considered. The explanation is that
the global mechanism of both the aggregation and the partitioning protocols
remains the same in PAMPAS+ compared to PAMPAS. In particular, the in-
sertion of fake tuples balances the number of messages generated by the probe
groups and precludes the SSI from inferring even the approximate location of
an update as explained in Section 7.1 and 7.2.

Besides, the PAMPAS+ aggregation protocol is designed to oﬀer strong
privacy guarantees to the participants in the context of an extended threat
model. The objective is to make the protocol robust to the (unlikely) situation
in which one or a few SPs are compromised as described in Assumption 1’ in
Section 6.1. We analyze hereafter the potential privacy leakage for a participant
in the worst case scenario with respect to the extended threat model, i.e., a
few SPs are compromised and at least one compromised SP colludes with the
SSI.

PAMPAS and lab attacks. Let us ﬁrst consider the basic PAMPAS
protocol. In this case, a corrupted SP that colludes with the SSI is equiv-
alent with the SSI obtaining the shared secret key. This allows the SSI to
decrypt all the messages that are exchanged between the SPs. Typically, the
SSI gets access to the sample data periodically sent by each participating SP,
i.e., sample = (location, time, value). If the location data is approximated to
the spatial unit that contains the actual location of the SP (e.g., only the road
identiﬁer is reported and not the exact location on the road), then the privacy
leakage for each update is the same with the value computed in Scenario 1 in
Section 7.2 (i.e., entropy leak(update) = 0.002 and location leakui = 0.995).
However, to achieve high accuracy it is likely that the applications would re-
quire the exact location of the probes, which leads to location leakui = 1.
Even if the updates are sent anonymously, having access to the exact location
of each update makes it easier for the SSI to link the updates coming from the
same probe (e.g., in relatively sparse areas) and thus compromise the privacy
of the participants.

PAMPAS+ and lab attacks. Let us have the same privacy analysis
in the context of PAMPAS+. Corrupting an SP and colluding with the SSI
is equivalent to oﬀering the SSI the couple keys and the shared secrete key
stored in that SP. The access to the couple keys of an SP allows the SSI
to decrypt the messages that are destined to that SP. This happens in the

PAMPAS+

37

aggregation phase whenever the corrupted SP is chosen as aggregating SP.
However, since the aggregating SP has to change at each aggregation time
window, the SSI will get access to the raw data in a single time window. For
a high number of participants, the probability to leak the data collected in a
time window is equal to the ratio between the number of corrupted SPs and the
total number of SPs, i.e., very low. Therefore, although the privacy leakage can
be occasionally signiﬁcant (e.g., entropy leak = 0.002/location leakui = 1 as
discussed in the previous paragraph), the very rare periodicity of this situation
makes that the overall privacy leakage to remain very low, i.e., similar to the
leakage in which none of the SPs is corrupted. To increase signiﬁcantly the
privacy leakage and therefore the probability to reconstruct the trajectories of
the SPs, an attacker would have to corrupt a signiﬁcant number of SPs, which
has a prohibitive cost. This shows the major advantage of the PAMPAS+
protocol over the basic protocol, i.e., having a dedicated encryption key for
the communication between each two SPs.

On the other hand, PAMPAS+ uses a single shared key for the eﬃcient
transmission of the partitioning and aggregation results. Gaining access to
the shared key would allow the SSI to decrypt the partitioning information
and hence to know the exact spatial extent of each partition. In addition, the
SSI knows to which partition belongs each update since the partition value is
deterministically encrypted with the shared key to allow the SSI to group the
messages partition-wise (line 11 in Algorithm 7). Hence, the entropy leakage
of each update transmitted by an SP can be estimated as done in Scenario 2 in
Section 7.2 (i.e., entropy leak(update) = 10−3). At the same time, the location
leakage is still small since the footprints of each participant are spatially hidden
within the partition and among the footprints of the other participants in the
same group, i.e., location leakui = 0.5.

Thus, PAMPAS+ oﬀers good privacy protection even in the context of the
extended threat model and deﬁnitely much better than compared with the
basic PAMPAS protocol, in which the privacy leakage is associated with the
exact location of the probe. We recall that in order to degrade the privacy
protection to this level, an attacker has to corrupt at least one SP and collude
with the SSI, which is costly. We recall also that the choice of keeping a
shared secret key in PAMPAS+ is determined by the eﬃciency and scalability
requirements of the proposed protocol and therefore it is a tradeoﬀ with the
privacy protection level.

A ﬁnal observation is that in the case of a lab attack, the privacy leakage
in PAMPAS+ depends on the probe partitioning, i.e., the number of probes
in a partition for the entropy leakage, and the spatial size of a partition for
the location leakage. Our current partitioning algorithms choose the number
of probe groups strictly based on data aggregation performance criteria (see
“Choosing the number of probe groups” in Section 5). However, extending
the partitioning model to include privacy related criteria is easy. For instance,
we can impose a minimum value for the number of probes in a group and/or
a minimum spatial extent of a partition, which in turn limits the potential

38

Iulian Sandu Popa et al.

entropy leakage and/or location leakage, respectively. Surely, this can have an
impact on the aggregation eﬃciency.

7.4 Other Attacks

The attacks studied in the previous section can be considered as ”passive”
attacks since, letting aside the act of corrupting the SPs and colluding with
the SSI, the attacker observes the private information to which he gains access
after breaking the data conﬁdentiality barrier, but does not derive from the
original protocol. However, a lab attack can oﬀer the attacker access to the
cryptographic material protected by the secure hardware, which in turn could
allow him to insert forged data into the system with the objective to infer or
gain access to even more private data. We discuss in this section two important
”active” attacks and explain the way the system handles them.

The ﬁrst type of active attack from the owner of a corrupted SP would be
to try to create a large number of fake identities that are all associated with
the corrupted SP to gain a disproportionate inﬂuence in the system, i.e., the
Sybil attack [14]. In this case, the beneﬁt of the attacker is multiplied with the
number of fake identities while the cost is minimized to corrupting a single
SP. To deter Sybil attacks we rely on the fact that a user cannot easily obtain
multiple user IDs because the user ID is derived from a user certiﬁcate and
obtaining digital certiﬁcates is not cheap. Speciﬁcally, we consider that a PKI
certiﬁcate is associated with the secure hardware of each SP and to gain access
to multiple certiﬁcates, an attacker would have to possess and corrupt as many
SPs, which contradicts the assumptions in our threat model (see Assumption
2 in Section 3.2). We recall that the certiﬁcate of an SP is veriﬁed at each
couple key exchange with another SP. Hence, a ”fake” SP, even if it succeeds
registering in the system (at the SSI) and be chosen as aggregating SP, it
will not be able to aggregate any data since this requires a prior couple key
exchange with all the other ”real” SPs in the system. Further, techniques such
as [34], [45], complementary to our protocol, can be used to address these
attacks.

The second possible active attack is related to the fact that the owner of a
corrupted SP may detain the secret cryptographic keys, which allows him to
either produce as many forged samples as needed (in the collection phase) or
forge a fake aggregation result (in the aggregation phase in case it is chosen as
aggregating SP). Tampering with the accuracy of the aggregation results may
be used by an attacker as a way to infer more private information. Yet, it is
reasonable to think that the attacker will make use of such actions only if he is
sure he cannot be detected since otherwise he can be banned from the system.
In the case of a corrupted SP forging many sample, an honest aggregating SP
can easily detect that there are many samples coming from a same SP (since
the samples have to be encrypted using the same couple key). Therefore, a
corrupted SP could forge a maximum of one sample for each partition to be
sure it cannot be detected. But this has a negligible inﬂuence on the accuracy of

PAMPAS+

39

the results knowing also that samples containing extreme values can be ﬁltered
out as being outliers. In the case of a corrupted aggregating SP, if the forged
aggregation result is very diﬀerent from the real result, this can be detected
in the next protocol iterations when the results for the same partition are
computed by honest SPs. A corrupted aggregating SP could still marginally
perturb the result, but the beneﬁt of doing so is equally small.

8 Experimental Evaluation

The goals of our experimental evaluation are twofold: (i) compare the execution
time and scalability of PAMPAS and PAMPAS+ with those of a state-of-the-
art protocol described in [41]; (ii) quantify the cost and scalability of our par-
titioning and aggregation protocols. We implemented and validated PAMPAS
and PAMPAS+ through emulations using secure tokens which have a hardware
conﬁguration representative for secure hardware platforms. For PAMPAS+,
we consider that the couple keys (see the protocols in Section 6.2) have been
exchanged between any two SPs participating in aggregation process. As ap-
plications for our experiments, we used traﬃc monitoring and noise monitor-
ing with both real and synthetic datasets representing small and medium-size
cities. Figure 6 illustrates our graphic interface for these applications; it shows
the aggregate results for the noise heat-map and the average travel time for
the road network. A demo of our prototype was presented in [43] using a traﬃc
monitoring scenario.

Fig. 6: Basic graphic visualization of aggregation maps for two applications: noise monitoring
(left) and traﬃc monitoring (right) [43]

8.1 Experimental Setting

Hardware platform. In our experimental evaluation, the SSI is hosted on
a PC (3.1 GHz i5-2400, 8GB RAM, running Windows 7) which also displays
the aggregate results in a graphical form for validation purpose. The SPs are
implemented by representative secure hardware devices (see Figure 7) which

40

Iulian Sandu Popa et al.

include an MCU with a 32-bit RISC CPU at 120MHz, a cryptographic co-
processor implementing AES and SHA, 128KB of static RAM and 1MB of
NOR Flash to store the software stack, a smartcard chip hosting the crypto-
graphic credentials (i.e., the secrete encryption keys) and an SD card reader
allowing for a large storage capacity. We used a commodity SD card (Samsung
SDHC Essential Class 10 of 32GB) as secondary Flash storage. The SSI in our
testing system manages a multi-channel Ethernet connection with a global
bandwidth of 100Mbps. Importantly, on the SP’s side, our implementation
limits the RAM consumption to only 30KB and the maximum communication
bandwidth to 200Kbps to validate the proposed protocols with less powerful
secure devices. Thus, in our experiments, all the SPs have this minimalist con-
ﬁguration. To emulate a very large number of SPs, we execute sequentially on
an SP the aggregate computations and communications for all the worker SPs
and measure the ”parallel” execution time as the maximum aggregation time
in the execution sequence.

Fig. 7: Secure tokens used in our experimental evaluation

Baseline system. To underline the importance of the PAMPAS and
PAMPAS+ protocols, we implemented the secure protocol proposed in [41]
and took it as the baseline. This protocol can be applied without modiﬁca-
tion to aggregate the samples collected in each time window. Since the basic
PAMPAS oﬀers the same level of security and privacy as the baseline protocol,
while PAMPAS+ oﬀers even stronger privacy protection (see Section 7.3), our
experimental evaluation focuses on the eﬃciency part. Note that in [41], two
more protocols are proposed that are even more expensive than the secure
protocol considered in our context.

Datasets and aggregate functions. We use both synthetic and real
datasets to test the eﬃciency and scalability of PAMPAS and PAMPAS+. We
employed the well-known Brinkhoﬀ generator [5] to generate mobility traces
on two real road networks of the cities of Oldenburg (Germany) and Stockton
(San Joaquin County, CA). Oldenburg is a small size network having 7035
road segments, while Stockton is a medium size road network having 24123
segments. Depending on the network size, we generated traces correspond-
ing to a medium and large number of users. With Oldenburg, the medium
and large datasets contain 47 thousand and 270 thousand users respectively.

PAMPAS+

41

With Stockton, the medium and large datasets contain 200 thousand and
1.35 million users respectively. The spatial distribution of the traces follows
the network spatial density. Compared to the existing real datasets, the syn-
thetic datasets have the prominent advantage of having excellent spatial and
temporal coverage. However, it is also important to validate the proposed
protocol with real datasets. To this end, we used the T-Drive Taxi trajectory
dataset [47]. This dataset contains around 15 million trajectory units collected
from 10357 taxis over a period from Feb. 2 to Feb. 8, 2008 in Beijing. Because
the density of taxis is too low compared to the synthetic dataset, we extracted
and merged a period of one hour in our tests, in order to generate a dataset
containing 191 thousand trajectories covering 32800 road segments.

To show the generality of PAMPAS and PAMPAS+, we selected three
aggregate functions, i.e., average, IDW [31] and median, corresponding to the
three aggregate types described in Section 3.3. We associate the average and
median aggregates with the traﬃc monitoring application, i.e., compute the
average travel time and the median speed for each road segment in a road
network. Hence, these two scenarios consider the constrained movement type.
The IDW aggregate is associated to the noise-level monitoring application and
a free movement type. In this case, we use the same generated mobility traces,
but consider them in the 2D space instead of the network space. Also, we
use a 64x64 grid to divide the observed 2D space into 4096 spatial units for
the free movement scenario. The speed sample values are directly generated
by the moving objects generator, while the noise values are generated by us
proportionally to the number of probes in the spatial unit.

8.2 Performance Evaluation

Fig. 8: Aggregation time of PAMPAS, PAMPAS+ and Baseline protocols with the real
dataset (left) and the synthetic dataset (right)

Execution time. Figure 8 compares the aggregation time (in a logarithmic
scale) of PAMPAS, PAMPAS+ and baseline protocols for the three considered
functions with 191 thousand probes in Beijing (real dataset) and with 200
thousand probes in Stockton. The aggregation time is global, i.e., it includes

42

Iulian Sandu Popa et al.

both the computation and communication time. The number of partitions was
selected as the optimal value for the average function (i.e., 128 partitions). The
results indicate that PAMPAS is very eﬃcient since it requires only a few sec-
onds to compute the aggregate results for all the tested functions in both
datasets. The aggregation time in PAMPAS+, although higher than in PAM-
PAS, is still small enough to respect the real-time requirement of the protocol.
The increased time is expected since in PAMPAS+ there is the additional cost
of accessing the couple key from the Flash memory for each sample during
the aggregation processes. Nevertheless, the ﬁxed number of partitions (i.e.,
128) used in these tests plays mostly in the disadvantage of PAMPAS+. As
we show in the scalability tests here below, the diﬀerence between PAMPAS
and PAMPAS+ remains acceptable in all cases when the number of partitions
is tuned correctly. Also, the aggregation times are similar with the real and
synthetic datasets for both PAMPAS and PAMPAS+. However, in both cases
the baseline protocol is much more costly (especially for complex aggregate
functions) leading to aggregation times up to three orders of magnitude higher
than PAMPAS. Moreover, the aggregation times with the baseline protocol are
larger for the Beijing dataset. The explanation is that the number of spatial
units is larger in Beijing (i.e., 32800) than in Stockton (i.e., 24123). On the
other hand, PAMPAS and PAMPAS+ are scalable with respect to both the
aggregation function and the number of spatial units in the query.

Scalability. We further test the scalability of the protocols with diﬀer-
ent number of probes, spatial units, and aggregate functions. Figure 9 shows
the aggregation time for the three protocols for the average (top graph) and
median (bottom graph) functions with medium and large number of users on
both road networks. The number of partitions in this evaluation is selected as
the optimal value for each case. Speciﬁcally, the number of partitions ranges
from 128 to 512 and from 128 to 1024 in PAMPAS and PAMPAS+ respectively
depending of the data size and the aggregation function, i.e., a larger data size
leads to a higher number of partitions as well as complex computations such
as the IDW or median functions. The results conﬁrm that only PAMPAS and
PAMPAS+ are scalable with respect to all the varying input parameters. In
the worst case, the computation time of PAMPAS and PAMPAS+ attains 14
seconds and 18 seconds respectively to compute the median speed for 1.35
million samples covering 24123 spatial units.

The baseline protocol does not scale with the number of samples and es-
pecially with the number of spatial units. Practically, the baseline can provide
real-time aggregation only for a small number of spatial units (i.e., 7000 in Old-
enburg) and basic aggregate functions (e.g., average). The very limited RAM
of the SPs and the impossibility to eﬃciently parallelize the aggregate com-
putation make the baseline inadequate for the requirements of participatory
sensing applications.

Cost and scalability of the partitioning protocol of PAMPAS.
Figure 10 (left) presents the partitioning computation time in PAMPAS for
both Oldenburg and Stockton networks. A new partitioning can be computed

PAMPAS+

43

Fig. 9: Scalability of the PAMPAS, PAMPAS+ and Baseline protocols with Average function
(top) and Median function (bottom)

Fig. 10: The partitioning costs (left) and the partitioning unbalance factor (right) in PAM-
PAS with diﬀerent number of partitions

in a few seconds by an SP11. This means that the checking and probes re-
partitioning can be executed frequently, which allows PAMPAS to adapt to
even fast changes in the spatial distribution of the probes. Most of the par-
titioning cost resides in reading and writing the partitioning data to the sec-
ondary Flash storage (see the detail in Section 8.3). This also explains the
increase of the partitioning time with the number of partitions, since in this
case the I/O operations are executed at a smaller granularity, which is more
costly.

11 We note that in this paper we employed an optimized implementation of the base parti-
tioning algorithm compared to the version used in [44]. While the general algorithm remains
the same (see Algorithm 4), we optimized the number of Flash IOs through a better usage
of the 30KB of RAM available for data processing at the SP side.

44

Iulian Sandu Popa et al.

Fig. 11: Communication and computation costs of Median function in PAMPAS with dif-
ferent number of partitions and road networks

Figure 10 (right) indicates that the partitioning unbalance factor of PAM-
PAS, i.e., the ratio between the maximum and the average partition size,
increases with the number of partitions. The unbalance factor is an important
indicator in PAMPAS since the higher the unbalance, the higher the number
of fake injected samples and, therefore, the communication cost.

Figure 11 shows the impact of the number of partitions on the global
aggregation time as well as on the computation and communication cost, which
compose the total time. The computation time decreases with the increase of
the number of partitions since the amount of work done by the aggregating
SPs also decreases. Conversely, the communication time increases with more
partitions since more fake samples are injected into the system as explained
above. Globally, the near-optimal aggregation time is obtained with a number
of partitions that minimizes the cumulated degradation of the computation
and communication costs (see Section 5). We obtained similar results with
the real dataset, for which the optimal number of partitions is 128 while the
network partitioning is computed in just 2 seconds. The aggregation cost is
partially shown in Figure 8 (left). For the sake of brevity and also due to the
similarity of the results with the synthetic datasets, we omit here the details
of the results with the real dataset.

8.3 Partitioning eﬃciency of PAMPAS+ versus PAMPAS

In this section, we analyze the eﬃciency and eﬀectiveness of the partitioning
algorithm of PAMPAS+ compared with the base algorithm. We compare the
overall cost and the unbalance factor with diﬀerent number of partitions for
the two methods. Then, we detail the global partitioning cost by separating the
CPU and the secondary memory access costs. Finally, we evaluate the parallel
execution cost of the PAMPAS+ partitioning method (see Section 6.3) with
diﬀerent number of probes.

Figure 12 shows the partitioning cost (left) and the unbalance factor (right)
in PAMPAS and PAMPAS+ for the Stockton large dataset. As expected, the
partitioning algorithm of PAMPAS+ is more costly but produces more bal-
anced partitions especially for large numbers of partitions. Overall, both meth-
ods have reasonable partitioning cost and acceptable unbalance factor, which

PAMPAS+

45

Fig. 12: The partitioning costs (left) and the partitioning unbalance factor (right) in PAM-
PAS and PAMPAS+ with diﬀerent number of partitions

Fig. 13: The detailed partitioning costs - CPU (left) and Flash IOs (right) - in PAMPAS
and PAMPAS+ with diﬀerent number of partitions

allows both algorithms to be employed in real-time in mobile participatory
sensing applications. Given the higher cost but better quality of the partition-
ing algorithm of PAMPAS+, this method will be preferred for large networks
and high number of participants. Also, the aggregation process of PAMPAS+
is more costly than in PAMPAS. Therefore, a more eﬀective partitioning is
required to reduce the aggregation cost (see Section 8.4), since a lower unbal-
ance factor reduces the volume of fake messages and hence the communication
cost while allowing to involve a larger number of SPs in the aggregation phase.
For a better understanding of the behavior of the two partitioning methods,
we detail in Figure 13 the CPU cost (left) and the IO cost (right). We can
observe that in terms of CPU cost the diﬀerence is only marginal between
the two algorithms. The performance diﬀerence is largely explained by the IO
cost. The recursive nature of the partitioning algorithm in PAMPAS+ requires
repeated reads/writes from/to the Flash storage especially given the low RAM
memory limit imposed in the protocol (i.e., 30KB), which explains the larger
number of IO compared with the base method.

Parallel partitioning. As described in Section 6.3, the partitioning al-
gorithm of PAMPAS+ can be easily parallelized. We validated experimentally
the parallel execution of the partitioning algorithm. Figure 14 shows the par-
titioning cost for diﬀerent numbers of partitions for the large Stockton dataset
when the partitioning process is executed by a diﬀerent number of SPs varying

46

Iulian Sandu Popa et al.

Fig. 14: The parallel partitioning costs in PAMPAS+ with diﬀerent number of partitions

from 1 to 32. The ﬁrst observation is that delegating the process to several SPs
can drastically reduce the partitioning cost for large number of partitions (i.e.,
above 256). At the same time, increasing the number of worker SPs above a
certain limit results is augmenting the partitioning cost. The reason is twofold.
First, the communication cost increases with increased number of SPs. Second,
when a large number of SPs are used, the coordinator SP (see Section 6.3) has
to do more work at the beginning of the process before delegating the tasks
to the other SPs.

Typically, a number of 4 to 8 SPs oﬀers the best performance in our
experiments. More importantly, if parallelized, the partitioning algorithm in
PAMPAS+ becomes faster than the equivalent algorithm in PAMPAS.

8.4 Aggregation eﬃciency of PAMPAS+ versus PAMPAS

Similar to PAMPAS, the number of partitions plays an important role in global
aggregation time of PAMPAS+ and has to be tuned correctly to obtain low
aggregation cost. Figure 15 shows the variation of the communication and
computation costs with diﬀerent number of partitions for the median func-
tion and the large Stockton and Oldenburg datasets. As in the base protocol,
increasing the number of partitions decreases the computation cost but aug-
ments the communication cost. However, due to a more eﬀective partitioning
(see Figure 12 (right)), the increase of the communication cost is slower in
PAMPAS+ then in PAMPAS. This also makes that, in some cases, the op-
timal number of partitions (i.e., minimizing the overall cost) to be higher
in PAMPAS+ then in PAMPAS for the same dataset and aggregation func-
tion. For instance, PAMPAS reaches the best performance with 256 partitions
while PAMPAS+ requires 512 partitions for the large Oldenburg dataset and
the median function.

PAMPAS+

47

Fig. 15: Communication and computation costs of Median function in PAMPAS+ with
diﬀerent number of partitions and road networks

Fig. 16: Overall costs of IDW function in PAMPAS and PAMPAS+ with diﬀerent number
of partitions

Figure 16 compares the overall aggregation cost of PAMPAS and PAMPAS+
with diﬀerent number of partitions for the IDW function and the medium
and large Stockton datasets. In general, both PAMPAS and PAMPAS+ of-
fer a reasonable cost in all cases. For PAMPAS+, the aggregation time drops
rapidly with the increase of the number of partitions before attaining the near-
optimal value. Compared with PAMPAS, the aggregation cost of PAMPAS+
is much higher for a small number of partitions, while the cost diﬀerence re-
duces to practically none for large number of partitions. If we compare the
near-optimal costs of the two protocols, we can observe that the aggregation
time of PAMPAS+ is about twice larger. However, the aggregation time of
PAMPAS+ remains suﬃciently small to be still considered as a real-time pro-
tocol even for very large number of users (i.e., 1.35 millions).

8.5 Discussion

This section wraps up the experimental evaluation. The ﬁrst observation is
that the existing data aggregation protocols built on secure hardware [41, 42]
have not been designed for applications requiring real-time processing such
as in the area of participatory sensing and therefore cannot be used in this
context. On the other hand, both protocols proposed in this paper are se-
cure, eﬃcient, scalable, accurate and generic with respect to the aggregation
function. PAMPAS is extremely eﬃcient and builds its eﬃciency on the rea-
sonable premise of the inviolability of secure hardware. PAMPAS+ goes one

48

Iulian Sandu Popa et al.

signiﬁcant step forward from the security point of view and trades eﬃciency to
increase the security level of the aggregation protocol. Thus, PAMPAS+ oﬀers
stronger privacy guarantees to the participants since it protects their privacy
even if some SPs are successfully compromised by their owner (see Section 6.1).
PAMPAS+ minimizes the information leakage by the corrupted SPs and hence
drastically reduces the beneﬁt of a successful lab attack (see Section 7.3). The
price to pay for the increased security level is larger aggregation time. Also,
PAMPAS+ requires an additional couple-key exchange phase in which each
pair of SPs exchanges a secret key, but this process does not have to meet the
real-time constraint imposed to the main aggregation process.

Selecting the partitioning algorithm. Both proposed protocols include
a speciﬁc partitioning algorithm. Nevertheless, we note that both the linear
partitioning algorithm of PAMPAS and the recursive binary partitioning of
PAMPAS+ can be interchanged in the two protocols. For the sake of clarity
we did not provide any results for the aggregation cost of the two protocols
using interchanged partitioning methods. The rationale is simple. Using the
binary partitioning in PAMPAS leads to decrease the aggregation cost of about
9.64% (on average), but at the same time signiﬁcantly increases the cost of the
partitioning phase. Since PAMPAS is already very eﬃcient in the aggregation
phase using the linear partitioning, we believe that a better partitioning is su-
perﬂuous in this case. Oppositely, using the linear partitioning in PAMPAS+
leads to increase the aggregation cost of about 12.53% (on average), but de-
creases the cost of the partitioning phase. Given that the aggregation cost
is signiﬁcantly larger in PAMPAS+ than in PAMPAS, any increase could be
perceived as being too much and hence the binary partitioning should be pre-
ferred in this case in our opinion. We also recall that the binary partitioning
can be executed in parallel which can drastically reduce the execution time
but requires several SPs to do the computation.

Selecting the query spatial units. In PAMPAS, the probe groups are
built on top of the spatial units requiring each group to include entirely the
spatial units it covers. This is done to increase the data aggregation eﬃciency
as explained in Sections 4 and 5. However, the way the spatial units are chosen
for a query can have an impact on the query computation eﬃciency. Choosing
units of smaller size is better since a ﬁner decomposition of the observed space
may allow for a more balanced group partitioning (especially for highly skewed
spatial distribution of participants), which in turn increases the aggregation
eﬃciency (since less fake tuples need to be generated to balance the data in
the groups). On the other hand, smaller units may increase the probability of
ﬁltering out more aggregation results corresponding to the units with low num-
ber of participants (as discussed in Section 7.1). In conclusion, while PAMPAS
is agnostic to the selection of the query spatial units, their conﬁguration can
impact its eﬃciency and to some extent its accuracy. Studying this issue is an
interesting perspective of future work.

Dealing with parallel MPS queries. In this paper, our focus is on hav-
ing a framework as generic as possible from the viewpoint of possible types
of spatio-temporal aggregation and then providing eﬃcient and secure proto-

PAMPAS+

49

cols to achieve such aggregations. Therefore, the spatial units are deﬁned per
query (see Section 3) and thus can change for diﬀerent queries. Maintaining
the partitioning for each query leads to a higher overhead, but this is the cost
for privacy and ﬂexibility. One solution to reduce this overhead is to consider
the same spatial units for diﬀerent queries. However, this raises a number
of issues. First, sharing the same spatial unit decomposition would, obviously,
make sense only if the physical referential space is the same (e.g., the geograph-
ical area of a city). However, even if the physical space is the same, the type
of movement can completely change the spatial unit representation (i.e., road
segments for vehicle movements versus grid cells for pedestrian movements).
So considering the same spatial units is possible only for the same type of
movement. Second, assuming that the previous elements are veriﬁed, there is
the question regarding the participants to the queries. If several queries are run
in parallel, the users may opt to participate to only part of them. Hence, for
any two parallel queries, there is no guarantee that the respective sets of par-
ticipants are identical. However, the distribution of the participants over the
spatial units is an essential parameter of the partitioning algorithm. Without
knowing the accurate spatial distribution, the system can no longer guaran-
tee the optimum privacy level. Also, verifying the intersection between two
lists of participants in a distributed and privacy-preserving way is not trivial
(and may even exceed the cost of partitioning). We should ﬁnally note that in
PAMPAS the partitioning cost is low (a few seconds in most cases) and can be
eﬀectively done in parallel by only a few SPs (see Section 8.3). Moreover, its
cost is much lower than the aggregation cost which dominates the overall cost
of PAMPAS since the aggregation involves a few hundred SPs at each iteration
as indicated by our experimental evaluation. However, optimizing the parti-
tioning cost with diﬀerent queries executed in parallel is another interesting
perspective of future work.

Boosting performance. Finally, it is worth mentioning that the aggre-
gation time can be greatly improved by increasing the processing power and
the communication bandwidth of the SSI. For example, increasing the server
bandwidth from 100Mbps to 1 GBps, makes the maximum aggregation time
(i.e., median function with the large Stockton dataset) to drop from 14 sec-
onds and 18 seconds to less than 7 seconds and 10 seconds in PAMPAS and
PAMPAS+ respectively. Also, in some scenarios, pushing the computation in
the user devices may be problematic (e.g., battery powered devices, concur-
rent applications running in the device). However, our protocols minimize this
type of problem thanks to their design and high eﬃciency. For instance, in our
tests, a user participating in the system for one hour, has a probability between
3.5% and 8.7% to participate once to an aggregate computation assuming that
aggregates results are produced every 30 seconds, and a probability between
0.004% and 0.12% to do a repartitioning assuming that the probes partition-
ing is checked every 1 minute. In all cases, the computation is done in a few
seconds at most and requires only modest resources (i.e., MCU-like low power
CPU, 30KB of RAM and 200Kbps communication bandwidth). Moreover, the
computation eﬀort is inversely proportional to the probability to be picked.

50

9 Conclusion

Iulian Sandu Popa et al.

This paper proposes PAMPAS and PAMPAS+, two related privacy-aware mo-
bile participatory sensing systems based on a distributed architecture and per-
sonal secure hardware. This combination allows PAMPAS and PAMPAS+ to
achieve the same level of privacy as cryptographic solutions without having to
sacriﬁce generality, scalability, and accuracy. Moreover, PAMPAS+ protects
the participants even against sophisticated hardware attacks without having
to sacriﬁce too much its eﬃciency. The proposed aggregation solutions are, to
the best of our knowledge, the ﬁrst proposal of distributed protocols that are
secure, eﬃcient, scalable and generic w.r.t. the aggregation computation and
that ﬁt both the strict hardware constraints of secure personal devices and the
real-time constraints of participatory sensing applications. The experimental
evaluation based on representative hardware for secure platforms validates the
proposed solutions.

References

1. Allard T, Nguyen B, Pucheral P (2014) METAP: revisiting privacy-
preserving data publishing using secure devices. Distributed and Parallel
Databases 32(2):191–244

2. Andr´es ME, Bordenabe NE, Chatzikokolakis K, Palamidessi C (2013)
location-based sys-
Geo-indistinguishability: Diﬀerential privacy for
tems.
the 2013 ACM SIGSAC Conference on
Computer &#38; Communications Security, ACM, New York, NY,
USA, CCS ’13, pp 901–914, DOI 10.1145/2508859.2516735, URL
http://doi.acm.org/10.1145/2508859.2516735

In: Proceedings of

3. ARM (2009) ARM Security Technology - Building a Secure System using

TrustZone Technology. ARM Technical White Paper

4. Baumann A, Peinado M, Hunt G (2014) Shielding applications from an

untrusted cloud with haven. In: OSDI, pp 267–283

5. Brinkhoﬀ T (2002) A framework for generating network-based moving

objects. GeoInformatica 6(2):153–180

6. Brown JWS, Ohrimenko O, Tamassia R (2013) Haze: privacy-preserving

real-time traﬃc statistics. In: ACM SIGSPATIAL, pp 540–543

7. Cao Y, Yoshikawa M, Xiao Y, Xiong L (2017) Quantifying diﬀerential
privacy under temporal correlations. In: Data Engineering (ICDE), 2017
IEEE 33rd International Conference on, IEEE, pp 821–832

8. Chatzikokolakis K, Palamidessi C,

Stronati M (2015)

cation
News
http://doi.acm.org/10.1145/2815493.2815499

geo-indistinguishability.
DOI

privacy
2(3):46–69,

via

10.1145/2815493.2815499,

9. Chow CY, Mokbel MF, Aref WG (2009) Casper*: Query process-
ing for location services without compromising privacy. ACM Trans

Lo-
ACM SIGLOG
URL

PAMPAS+

51

Database Syst 34(4):24:1–24:48, DOI 10.1145/1620585.1620591, URL
http://doi.acm.org/10.1145/1620585.1620591

10. Cornelius C, Kapadia A, Kotz D, Peebles D, Shin M, Triandopoulos N
(2008) AnonySense: Privacy-aware people-centric sensing. In: MobiSys
11. Damiani ML (2014) Location privacy models in mobile applications: con-
ceptual view and research directions. GeoInformatica 18(4):819–842
12. Damiani ML, Bertino E, Silvestri C (2010) The probe framework for the
personalized cloaking of private locations. Trans Data Privacy 3(2):123–
148, URL http://dl.acm.org/citation.cfm?id=1824401.1824404

13. D’Hondta E, Stevens M, Jacobs A (2013) Participatory noise mapping
works! an evaluation of participatory sensing as an alternative to standard
techniques for environmental monitoring. Pervasive and Mobile Comput-
ing 9(5):681–694

14. Douceur JR (2002) The

sybil attack.

First

International Workshop

the
Springer-Verlag, London, UK, UK,
http://dl.acm.org/citation.cfm?id=646334.687813

on

In: Revised Papers
Peer-to-Peer

from
Systems,
IPTPS ’01, pp 251–260, URL

15. Drosatos G, Efraimidis PS, Athanasiadis IN, Stevens M (2012) A privacy-
preserving cloud computing system for creating participatory noise maps.
In: COMPSAC, pp 581–586

16. Faezipour M, Nourani M, Saeed A, Addepalli S (2012) Progress and chal-
lenges in intelligent vehicle area networks. Magazine Communications of
the ACM 55(2):90–100

17. Ganti RK, Pham N, Tsai YE, Abdelzaher TF (2008) PoolView: Stream

privacy for grassroots participatory sensing. In: SenSys

18. Gao H, Liu CH, Wang W, Zhao J, Song Z, Su X, Crowcroft J, Leung KK
(2015) A survey of incentive mechanisms for participatory sensing. IEEE
Comm Surveys and Tutorials 17(2):918–943

19. Ghinita G, Damiani ML, Silvestri C, Bertino E (2016) Protecting against
velocity-based, proximity-based, and external event attacks in location-
centric social networks. ACM Trans Spatial Algorithms Syst 2(2):8:1–8:36,
DOI 10.1145/2910580, URL http://doi.acm.org/10.1145/2910580

20. Goel P, Kulik L, Ramamohanarao K (2016) Privacy-aware dynamic
ride sharing. ACM Trans Spatial Algorithms Syst 2(1):4:1–4:41, DOI
10.1145/2845080, URL http://doi.acm.org/10.1145/2845080

21. Gonz´alez J, H¨olzl M, Riedl P, Bonnet P, Mayrhofer R (2014) A practical
hardware-assisted approach to customize trusted boot for mobile devices.
In: Chow SSM, Camenisch J, Hui LCK, Yiu SM (eds) Information Secu-
rity, Springer International Publishing, pp 542–554

22. Hoh B, Iwuchukwu T, Jacobson Q, Work D, Bayen AM, Herring R, Her-
rera JC, Gruteser M, Annavaram M, Ban J (2012) Enhancing privacy and
accuracy in probe vehicle-based traﬃc monitoring via virtual trip lines.
IEEE Tran on Mobile Computing 11(5):849–864

23. Huang KL, Kanhere

SS, Hu W (2010)

Preserving

vacy
in
33(11):1266–1280,

participatory
DOI

sensing

systems.

Comput

10.1016/j.comcom.2009.08.012,

pri-
Commun
URL

52

Iulian Sandu Popa et al.

http://dx.doi.org/10.1016/j.comcom.2009.08.012

24. Jain N, Mishra S, Srinivasan A, Gehrke J, Widom J, Balakrishnan H,
C¸ etintemel U, Cherniack M, Tibbetts R, Zdonik SB (2008) Towards a
streaming sql standard. In: PVLDB 1(2), pp 1379–1390

25. Lallali S, Anciaux N, Popa IS, Pucheral P (2017) Supporting
secure keyword search in the personal
Information Sys-
tems 72:1 – 26, DOI https://doi.org/10.1016/j.is.2017.09.003, URL
http://www.sciencedirect.com/science/article/pii/S0306437916303891
26. Li M, Zhu L, Zhang Z, Xu R (2017) Achieving diﬀerential privacy of tra-
jectory data publishing in participatory sensing. Inf Sci 400(C):1–13, DOI
10.1016/j.ins.2017.03.015, URL https://doi.org/10.1016/j.ins.2017.03.015
27. Li Q, Cao G (2012) Eﬃcient and privacy-preserving data aggregation in

cloud.

mobile sensing. In: IEEE ICNP

28. Liu R, Cao J, VanSyckel S, Gao W (2016) Prime: Human-centric privacy
measurement based on user preferences towards data sharing in mobile
participatory sensing systems. In: 2016 IEEE International Conference
on Pervasive Computing and Communications (PerCom), pp 1–8, DOI
10.1109/PERCOM.2016.7456518

29. Maruseac M, Ghinita G, Trajcevski G, Scheuermann P (2017)
Privacy-preserving detection of anomalous phenomena in crowd-
sensing using ﬁne-grained weighted voting.
sourced environmental
Geoinformatica 21(4):733–762, DOI 10.1007/s10707-017-0304-3, URL
https://doi.org/10.1007/s10707-017-0304-3

30. de Montjoye YA, Hidalgo CA, Verleysen M, Blondel VD (2013) Unique in
the crowd: The privacy bounds of human mobility. Scientiﬁc reports 3
31. Nittel S, Whittier JC, Liang Q (2012) Real-time spatial interpolation
of continuous phenomena using mobile sensor data streams. In: ACM
SIGSPATIAL, pp 530–533

32. Pan J, Sandu-Popa I, Borcea C (2017) Divert: A distributed vehicular
traﬃc re-routing system for congestion avoidance. IEEE Transactions on
Mobile Computing 16(1):58–72, DOI 10.1109/TMC.2016.2538226

33. Penza M (2014) Cost action TD1105: New sensing technologies for envi-

ronmental sustainability in smart cities. In: IEEE SENSORS

34. Piro C, Shields C, Levine BN (2006) Detecting the sybil attack in mobile

ad hoc networks. In: 2006 Securecomm and Workshops, pp 1–11

35. Popa RA, Blumberg AJ, Balakrishnan H, Li FH (2011) Privacy and ac-
countability for location-based aggregate statistics. In: CCS, pp 653–666
36. Priebe C, Vaswani K, Costa M (2018) Enclavedb - a secure
IEEE, URL https://www.microsoft.com/en-

database using
us/research/publication/enclavedb-a-secure-database-using-sgx/

sgx.

37. Quercia D, Leontiadis I, Mcnamara L, Mascolo C, Crowcroft J (2011)
Spotme if you can: Randomized responses for location obfuscation on mo-
bile phones. In: ICDCS, pp 363–372

38. Sabt M, Achemlal M, Bouabdallah A (2015) Trusted execution en-
vironment: What it is, and what it is not. In: 2015 IEEE Trust-
com/BigDataSE/ISPA, vol 1, pp 57–64, DOI 10.1109/Trustcom.2015.357

PAMPAS+

53

39. Shi J, Zhang R, Liu Y, Zhang Y (2010) PriSense: Privacy-preserving data
aggregation in people-centric urban sensing systems. In: IEEE INFOCOM
40. Thiagarajan A, Ravindranath L, LaCurts K, Madden S, Balakrishnan H,
Toledo S, Eriksson J (2009) Vtrack: accurate, energy-aware road traﬃc
delay estimation using mobile phones. In: ACM SenSys, pp 85–98

41. To QC, Nguyen B, Pucheral P (2014) Privacy-preserving query execu-
tion using a decentralized architecture and tamper resistant hardware. In:
EDBT, pp 487–498

42. To QC, Nguyen B, Pucheral P (2016) Private and scalable execu-
tion of sql aggregates on a secure decentralized architecture. ACM
Trans Database Syst 41(3):16:1–16:43, DOI 10.1145/2894750, URL
http://doi.acm.org/10.1145/2894750

43. Ton-That DH, Sandu-Popa I, Zeitouni K (2015) PPTM: Privacy-aware
participatory traﬃc monitoring using mobile secure probes. In: IEEE
MDM, demo paper

44. Ton-That DH,

Sandu-Popa

I, Zeitouni K, Borcea C (2016)
se-
PAMPAS: Privacy-aware mobile participatory sensing using
cure probes.
the 28th International Confer-
ence on Scientiﬁc and Statistical Database Management, ACM,
SSDBM ’16,
10.1145/2949689.2949704, URL
http://doi.acm.org/10.1145/2949689.2949704

In: Proceedings of

4:1–4:12, DOI

pp

45. Wang G, Wang B, Wang T, Nika A, Zheng H, Zhao BY (2016)
Defending against sybil devices in crowdsourced mapping services.
In: Proceedings of the 14th Annual International Conference on Mo-
bile Systems, Applications, and Services, ACM, New York, NY,
USA, MobiSys ’16, pp 179–191, DOI 10.1145/2906388.2906420, URL
http://doi.acm.org/10.1145/2906388.2906420

46. Wang L, Yang D, Han X, Wang T, Zhang D, Ma X (2017) Location
privacy-preserving task allocation for mobile crowdsensing with diﬀer-
ential geo-obfuscation. In: Proceedings of the 26th International Con-
ference on World Wide Web, International World Wide Web Confer-
ences Steering Committee, Republic and Canton of Geneva, Switzer-
land, WWW ’17, pp 627–636, DOI 10.1145/3038912.3052696, URL
https://doi.org/10.1145/3038912.3052696

47. Yuan J, Zheng Y, Xie W, Xie X, Sun G, Huang Y (2010) T-drive: driving

directions based on taxi trajectories. In: SIGSPATIAL, pp 99–108

